record_number,buggy_code,fixed_code,code_similarity
109001,"@Override public void update(ModelEvent event){
  if (event.target == EventTarget.CRITERION_DEFINITION) {
    if (model != null) {
      root.setRedraw(false);
      if (model.getKAnonymityModel().isActive() && model.getKAnonymityModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getKAnonymityModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolK);
      }
      if (model.getDPresenceModel().isActive() && model.getDPresenceModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getDPresenceModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolD);
      }
      for (      ModelLDiversityCriterion c : model.getLDiversityModel().values()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
        item.setImage(0,symbolL);
      }
      for (      ModelTClosenessCriterion c : model.getTClosenessModel().values()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
        item.setImage(0,symbolT);
      }
      column1.pack();
      column2.pack();
      column3.pack();
      root.setRedraw(true);
    }
  }
}","@Override public void update(ModelEvent event){
  if (event.target == EventTarget.MODEL) {
    this.model=(Model)event.data;
  }
 else   if (event.target == EventTarget.CRITERION_DEFINITION) {
    if (model != null) {
      root.setRedraw(false);
      table.removeAll();
      if (model.getKAnonymityModel().isActive() && model.getKAnonymityModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getKAnonymityModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolK);
      }
      if (model.getDPresenceModel().isActive() && model.getDPresenceModel().isEnabled()) {
        TableItem item=new TableItem(table,SWT.NONE);
        item.setText(new String[]{""String_Node_Str"",model.getDPresenceModel().toString(),""String_Node_Str""});
        item.setImage(0,symbolD);
      }
      for (      ModelLDiversityCriterion c : model.getLDiversityModel().values()) {
        if (c.isActive() && c.isEnabled()) {
          TableItem item=new TableItem(table,SWT.NONE);
          item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
          item.setImage(0,symbolL);
        }
      }
      for (      ModelTClosenessCriterion c : model.getTClosenessModel().values()) {
        if (c.isActive() && c.isEnabled()) {
          TableItem item=new TableItem(table,SWT.NONE);
          item.setText(new String[]{""String_Node_Str"",c.toString(),c.getAttribute()});
          item.setImage(0,symbolT);
        }
      }
      column1.pack();
      column2.pack();
      column3.pack();
      root.setRedraw(true);
    }
  }
}",0.9225678358702846
109002,"private Composite build(final Composite parent){
  Composite group=new Composite(parent,SWT.NONE);
  group.setLayoutData(SWTUtil.createFillGridData());
  GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=2;
  group.setLayout(groupInputGridLayout);
  GridData gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.grabExcessHorizontalSpace=true;
  gd1.horizontalSpan=2;
  folder=new CTabFolder(group,SWT.TOP | SWT.BORDER | SWT.FLAT);
  folder.setUnselectedCloseVisible(false);
  folder.setSimple(true);
  folder.setTabHeight(25);
  folder.setLayoutData(gd1);
  folder.addCTabFolder2Listener(new CTabFolder2Adapter(){
    @Override public void close(    final CTabFolderEvent event){
      event.doit=false;
    }
  }
);
  final CTabItem tabKAnon=new CTabItem(folder,SWT.NULL);
  tabKAnon.setText(Resources.getMessage(""String_Node_Str""));
  tabKAnon.setShowClose(false);
  KAnonymityView kanon=new KAnonymityView(folder,controller,model);
  tabKAnon.setControl(kanon.getControl());
  tabKAnon.setImage(controller.getResources().getImage(""String_Node_Str""));
  folder.setSelection(tabKAnon);
  final CTabItem tabDPres=new CTabItem(folder,SWT.NULL);
  tabDPres.setText(Resources.getMessage(""String_Node_Str""));
  tabDPres.setShowClose(false);
  tabDPres.setImage(controller.getResources().getImage(""String_Node_Str""));
  DPresenceView dpres=new DPresenceView(folder,controller,model);
  tabDPres.setControl(dpres.getControl());
  final CTabItem tabLDiversity=new CTabItem(folder,SWT.NULL);
  tabLDiversity.setText(Resources.getMessage(""String_Node_Str""));
  tabLDiversity.setShowClose(false);
  tabLDiversity.setImage(controller.getResources().getImage(""String_Node_Str""));
  LDiversityView view=new LDiversityView(folder,controller,model);
  tabLDiversity.setControl(view.getControl());
  final CTabItem tabTcloseness=new CTabItem(folder,SWT.NULL);
  tabTcloseness.setText(Resources.getMessage(""String_Node_Str""));
  tabTcloseness.setShowClose(false);
  tabTcloseness.setImage(controller.getResources().getImage(""String_Node_Str""));
  TClosenessView view2=new TClosenessView(folder,controller,model);
  tabTcloseness.setControl(view2.getControl());
  folder.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      updateControlls();
    }
  }
);
  ToolBar toolbar=new ToolBar(folder,SWT.FLAT);
  enable=new ToolItem(toolbar,SWT.PUSH);
  enable.setImage(controller.getResources().getImage(""String_Node_Str""));
  enable.setToolTipText(Resources.getMessage(""String_Node_Str""));
  enable.setEnabled(false);
  enable.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      controller.actionCriterionEnable(getSelectedCriterion());
    }
  }
);
  push=new ToolItem(toolbar,SWT.PUSH);
  push.setImage(controller.getResources().getImage(""String_Node_Str""));
  push.setToolTipText(Resources.getMessage(""String_Node_Str""));
  push.setEnabled(false);
  push.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      controller.actionCriterionPush(getSelectedCriterion());
    }
  }
);
  pull=new ToolItem(toolbar,SWT.PUSH);
  pull.setImage(controller.getResources().getImage(""String_Node_Str""));
  pull.setToolTipText(Resources.getMessage(""String_Node_Str""));
  pull.setEnabled(false);
  pull.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      controller.actionCriterionPull(getSelectedCriterion());
    }
  }
);
  ToolItem help=new ToolItem(toolbar,SWT.PUSH);
  help.setImage(controller.getResources().getImage(""String_Node_Str""));
  help.setToolTipText(Resources.getMessage(""String_Node_Str""));
  folder.setTopRight(toolbar,SWT.RIGHT);
  int height=toolbar.computeSize(SWT.DEFAULT,SWT.DEFAULT).y;
  folder.setTabHeight(Math.max(height,folder.getTabHeight()));
  gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.horizontalSpan=2;
  CTabFolder folder2=new CTabFolder(group,SWT.TOP | SWT.BORDER | SWT.FLAT);
  folder2.setUnselectedCloseVisible(false);
  folder2.setSimple(true);
  folder2.setTabHeight(25);
  folder2.setLayoutData(gd1);
  SWTUtil.createHelpButton(controller,folder2,""String_Node_Str"");
  folder2.addCTabFolder2Listener(new CTabFolder2Adapter(){
    @Override public void close(    final CTabFolderEvent event){
      event.doit=false;
    }
  }
);
  final CTabItem tabGeneral=new CTabItem(folder2,SWT.NULL);
  tabGeneral.setText(""String_Node_Str"");
  tabGeneral.setShowClose(false);
  group=new Composite(folder2,SWT.NONE);
  group.setLayoutData(SWTUtil.createFillGridData());
  groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=3;
  group.setLayout(groupInputGridLayout);
  tabGeneral.setControl(group);
  final Label sLabel=new Label(group,SWT.PUSH);
  sLabel.setText(Resources.getMessage(""String_Node_Str""));
  labelOutliers=new Label(group,SWT.BORDER | SWT.CENTER);
  GridData d2=new GridData();
  d2.minimumWidth=LABEL_WIDTH;
  d2.widthHint=LABEL_WIDTH;
  d2.heightHint=LABEL_HEIGHT;
  labelOutliers.setLayoutData(d2);
  labelOutliers.setText(""String_Node_Str"");
  sliderOutliers=new Scale(group,SWT.HORIZONTAL);
  sliderOutliers.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  sliderOutliers.setMaximum(SLIDER_MAX);
  sliderOutliers.setMinimum(0);
  sliderOutliers.setSelection(0);
  sliderOutliers.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setAllowedOutliers(sliderToDouble(0d,0.999d,sliderOutliers.getSelection()));
      labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
      if (model.getInputConfig().getAllowedOutliers() != 0) {
        buttonPracticalMonotonicity.setEnabled(true);
      }
 else {
        buttonPracticalMonotonicity.setSelection(false);
        buttonPracticalMonotonicity.setEnabled(false);
        model.getInputConfig().setPracticalMonotonicity(false);
      }
    }
  }
);
  final Label mLabel=new Label(group,SWT.PUSH);
  mLabel.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  mLabel.setLayoutData(d2);
  final Composite mBase=new Composite(group,SWT.NONE);
  final GridData d8=SWTUtil.createFillHorizontallyGridData();
  d8.horizontalSpan=2;
  mBase.setLayoutData(d8);
  final GridLayout l=new GridLayout();
  l.numColumns=7;
  l.marginLeft=0;
  l.marginRight=0;
  l.marginBottom=0;
  l.marginTop=0;
  l.marginWidth=0;
  l.marginHeight=0;
  mBase.setLayout(l);
  comboMetric=new Combo(mBase,SWT.READ_ONLY);
  GridData d30=SWTUtil.createFillHorizontallyGridData();
  d30.verticalAlignment=SWT.CENTER;
  comboMetric.setLayoutData(d30);
  comboMetric.setItems(LABELS_METRIC);
  comboMetric.select(0);
  comboMetric.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (comboMetric.getSelectionIndex() != -1) {
        selectMetricAction(ITEMS_METRIC[comboMetric.getSelectionIndex()]);
      }
    }
  }
);
  final Label m2Label=new Label(group,SWT.PUSH);
  m2Label.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  m2Label.setLayoutData(d2);
  final GridData d82=SWTUtil.createFillHorizontallyGridData();
  d82.horizontalSpan=2;
  buttonPracticalMonotonicity=new Button(group,SWT.CHECK);
  buttonPracticalMonotonicity.setText(Resources.getMessage(""String_Node_Str""));
  buttonPracticalMonotonicity.setSelection(false);
  buttonPracticalMonotonicity.setEnabled(false);
  buttonPracticalMonotonicity.setLayoutData(d82);
  buttonPracticalMonotonicity.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setPracticalMonotonicity(buttonPracticalMonotonicity.getSelection());
    }
  }
);
  final Label m3Label=new Label(group,SWT.PUSH);
  m3Label.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  m3Label.setLayoutData(d2);
  final GridData d83=SWTUtil.createFillHorizontallyGridData();
  d83.horizontalSpan=2;
  buttonProtectSensitiveAssociations=new Button(group,SWT.CHECK);
  buttonProtectSensitiveAssociations.setText(Resources.getMessage(""String_Node_Str""));
  buttonProtectSensitiveAssociations.setSelection(true);
  buttonProtectSensitiveAssociations.setEnabled(false);
  buttonProtectSensitiveAssociations.setLayoutData(d83);
  buttonProtectSensitiveAssociations.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setProtectSensitiveAssociations(buttonProtectSensitiveAssociations.getSelection());
    }
  }
);
  final CTabItem tabOverview=new CTabItem(folder2,SWT.NULL);
  tabOverview.setText(""String_Node_Str"");
  tabOverview.setShowClose(false);
  clv=new CriteriaListView(folder2,controller,model);
  tabOverview.setControl(clv.getControl());
  folder2.setSelection(tabGeneral);
  return group;
}","private Composite build(final Composite parent){
  Composite group=new Composite(parent,SWT.NONE);
  group.setLayoutData(SWTUtil.createFillGridData());
  GridLayout groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=2;
  group.setLayout(groupInputGridLayout);
  GridData gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.grabExcessHorizontalSpace=true;
  gd1.horizontalSpan=2;
  folder=new CTabFolder(group,SWT.TOP | SWT.BORDER | SWT.FLAT);
  folder.setUnselectedCloseVisible(false);
  folder.setSimple(true);
  folder.setTabHeight(25);
  folder.setLayoutData(gd1);
  folder.addCTabFolder2Listener(new CTabFolder2Adapter(){
    @Override public void close(    final CTabFolderEvent event){
      event.doit=false;
    }
  }
);
  final CTabItem tabKAnon=new CTabItem(folder,SWT.NULL);
  tabKAnon.setText(Resources.getMessage(""String_Node_Str""));
  tabKAnon.setShowClose(false);
  KAnonymityView kanon=new KAnonymityView(folder,controller,model);
  tabKAnon.setControl(kanon.getControl());
  tabKAnon.setImage(controller.getResources().getImage(""String_Node_Str""));
  folder.setSelection(tabKAnon);
  final CTabItem tabDPres=new CTabItem(folder,SWT.NULL);
  tabDPres.setText(Resources.getMessage(""String_Node_Str""));
  tabDPres.setShowClose(false);
  tabDPres.setImage(controller.getResources().getImage(""String_Node_Str""));
  DPresenceView dpres=new DPresenceView(folder,controller,model);
  tabDPres.setControl(dpres.getControl());
  final CTabItem tabLDiversity=new CTabItem(folder,SWT.NULL);
  tabLDiversity.setText(Resources.getMessage(""String_Node_Str""));
  tabLDiversity.setShowClose(false);
  tabLDiversity.setImage(controller.getResources().getImage(""String_Node_Str""));
  LDiversityView view=new LDiversityView(folder,controller,model);
  tabLDiversity.setControl(view.getControl());
  final CTabItem tabTcloseness=new CTabItem(folder,SWT.NULL);
  tabTcloseness.setText(Resources.getMessage(""String_Node_Str""));
  tabTcloseness.setShowClose(false);
  tabTcloseness.setImage(controller.getResources().getImage(""String_Node_Str""));
  TClosenessView view2=new TClosenessView(folder,controller,model);
  tabTcloseness.setControl(view2.getControl());
  folder.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      updateControlls();
    }
  }
);
  ToolBar toolbar=new ToolBar(folder,SWT.FLAT);
  enable=new ToolItem(toolbar,SWT.PUSH);
  enable.setImage(controller.getResources().getImage(""String_Node_Str""));
  enable.setToolTipText(Resources.getMessage(""String_Node_Str""));
  enable.setEnabled(false);
  enable.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      controller.actionCriterionEnable(getSelectedCriterion());
    }
  }
);
  push=new ToolItem(toolbar,SWT.PUSH);
  push.setImage(controller.getResources().getImage(""String_Node_Str""));
  push.setToolTipText(Resources.getMessage(""String_Node_Str""));
  push.setEnabled(false);
  push.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      controller.actionCriterionPush(getSelectedCriterion());
    }
  }
);
  pull=new ToolItem(toolbar,SWT.PUSH);
  pull.setImage(controller.getResources().getImage(""String_Node_Str""));
  pull.setToolTipText(Resources.getMessage(""String_Node_Str""));
  pull.setEnabled(false);
  pull.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent arg0){
      controller.actionCriterionPull(getSelectedCriterion());
    }
  }
);
  ToolItem help=new ToolItem(toolbar,SWT.PUSH);
  help.setImage(controller.getResources().getImage(""String_Node_Str""));
  help.setToolTipText(Resources.getMessage(""String_Node_Str""));
  folder.setTopRight(toolbar,SWT.RIGHT);
  int height=toolbar.computeSize(SWT.DEFAULT,SWT.DEFAULT).y;
  folder.setTabHeight(Math.max(height,folder.getTabHeight()));
  gd1=SWTUtil.createFillGridData();
  gd1.grabExcessVerticalSpace=false;
  gd1.horizontalSpan=2;
  CTabFolder folder2=new CTabFolder(group,SWT.TOP | SWT.BORDER | SWT.FLAT);
  folder2.setUnselectedCloseVisible(false);
  folder2.setSimple(true);
  folder2.setTabHeight(25);
  folder2.setLayoutData(gd1);
  SWTUtil.createHelpButton(controller,folder2,""String_Node_Str"");
  folder2.addCTabFolder2Listener(new CTabFolder2Adapter(){
    @Override public void close(    final CTabFolderEvent event){
      event.doit=false;
    }
  }
);
  final CTabItem tabGeneral=new CTabItem(folder2,SWT.NULL);
  tabGeneral.setText(""String_Node_Str"");
  tabGeneral.setShowClose(false);
  group=new Composite(folder2,SWT.NONE);
  group.setLayoutData(SWTUtil.createFillGridData());
  groupInputGridLayout=new GridLayout();
  groupInputGridLayout.numColumns=3;
  group.setLayout(groupInputGridLayout);
  tabGeneral.setControl(group);
  final Label sLabel=new Label(group,SWT.PUSH);
  sLabel.setText(Resources.getMessage(""String_Node_Str""));
  labelOutliers=new Label(group,SWT.BORDER | SWT.CENTER);
  GridData d2=new GridData();
  d2.minimumWidth=LABEL_WIDTH;
  d2.widthHint=LABEL_WIDTH;
  d2.heightHint=LABEL_HEIGHT;
  labelOutliers.setLayoutData(d2);
  labelOutliers.setText(""String_Node_Str"");
  sliderOutliers=new Scale(group,SWT.HORIZONTAL);
  sliderOutliers.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  sliderOutliers.setMaximum(SLIDER_MAX);
  sliderOutliers.setMinimum(0);
  sliderOutliers.setSelection(0);
  sliderOutliers.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setAllowedOutliers(sliderToDouble(0d,0.999d,sliderOutliers.getSelection()));
      labelOutliers.setText(String.valueOf(model.getInputConfig().getAllowedOutliers()));
      if (model.getInputConfig().getAllowedOutliers() != 0) {
        buttonPracticalMonotonicity.setEnabled(true);
      }
 else {
        buttonPracticalMonotonicity.setSelection(false);
        buttonPracticalMonotonicity.setEnabled(false);
        model.getInputConfig().setPracticalMonotonicity(false);
      }
    }
  }
);
  final Label mLabel=new Label(group,SWT.PUSH);
  mLabel.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  mLabel.setLayoutData(d2);
  final Composite mBase=new Composite(group,SWT.NONE);
  final GridData d8=SWTUtil.createFillHorizontallyGridData();
  d8.horizontalSpan=2;
  mBase.setLayoutData(d8);
  final GridLayout l=new GridLayout();
  l.numColumns=7;
  l.marginLeft=0;
  l.marginRight=0;
  l.marginBottom=0;
  l.marginTop=0;
  l.marginWidth=0;
  l.marginHeight=0;
  mBase.setLayout(l);
  comboMetric=new Combo(mBase,SWT.READ_ONLY);
  GridData d30=SWTUtil.createFillHorizontallyGridData();
  d30.verticalAlignment=SWT.CENTER;
  comboMetric.setLayoutData(d30);
  comboMetric.setItems(LABELS_METRIC);
  comboMetric.select(0);
  comboMetric.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (comboMetric.getSelectionIndex() != -1) {
        selectMetricAction(ITEMS_METRIC[comboMetric.getSelectionIndex()]);
      }
    }
  }
);
  final Label m2Label=new Label(group,SWT.PUSH);
  m2Label.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  m2Label.setLayoutData(d2);
  final GridData d82=SWTUtil.createFillHorizontallyGridData();
  d82.horizontalSpan=2;
  buttonPracticalMonotonicity=new Button(group,SWT.CHECK);
  buttonPracticalMonotonicity.setText(Resources.getMessage(""String_Node_Str""));
  buttonPracticalMonotonicity.setSelection(false);
  buttonPracticalMonotonicity.setEnabled(false);
  buttonPracticalMonotonicity.setLayoutData(d82);
  buttonPracticalMonotonicity.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setPracticalMonotonicity(buttonPracticalMonotonicity.getSelection());
    }
  }
);
  final Label m3Label=new Label(group,SWT.PUSH);
  m3Label.setText(Resources.getMessage(""String_Node_Str""));
  d2=new GridData();
  d2.heightHint=LABEL_HEIGHT;
  d2.minimumHeight=LABEL_HEIGHT;
  m3Label.setLayoutData(d2);
  final GridData d83=SWTUtil.createFillHorizontallyGridData();
  d83.horizontalSpan=2;
  buttonProtectSensitiveAssociations=new Button(group,SWT.CHECK);
  buttonProtectSensitiveAssociations.setText(Resources.getMessage(""String_Node_Str""));
  buttonProtectSensitiveAssociations.setSelection(true);
  buttonProtectSensitiveAssociations.setEnabled(false);
  buttonProtectSensitiveAssociations.setLayoutData(d83);
  buttonProtectSensitiveAssociations.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      model.getInputConfig().setProtectSensitiveAssociations(buttonProtectSensitiveAssociations.getSelection());
    }
  }
);
  final CTabItem tabOverview=new CTabItem(folder2,SWT.NULL);
  tabOverview.setText(""String_Node_Str"");
  tabOverview.setShowClose(false);
  clv=new CriteriaListView(folder2,controller);
  tabOverview.setControl(clv.getControl());
  folder2.setSelection(tabGeneral);
  return group;
}",0.9996764103117248
109003,"@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  text=new StyledText(parent,SWT.BORDER);
  final GridData d=SWTUtil.createFillGridData();
  d.grabExcessHorizontalSpace=true;
  d.grabExcessVerticalSpace=true;
  text.setLayoutData(d);
  text.setText(this.initial);
  text.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent arg0){
      highlight();
      parse();
    }
  }
);
  error=new Label(parent,SWT.NONE);
  final GridData d2=SWTUtil.createFillGridData();
  d2.grabExcessHorizontalSpace=true;
  error.setLayoutData(d2);
  error.setText(""String_Node_Str"");
  return parent;
}","@Override protected Control createDialogArea(final Composite parent){
  parent.setLayout(new GridLayout());
  text=new StyledText(parent,SWT.BORDER | SWT.MULTI | SWT.WRAP);
  text.setLayoutData(SWTUtil.createFillGridData());
  text.setText(this.queryString);
  text.addModifyListener(new ModifyListener(){
    @Override public void modifyText(    ModifyEvent arg0){
      highlight();
      parse();
    }
  }
);
  error=new Label(parent,SWT.NONE);
  error.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  error.setText(""String_Node_Str"");
  return parent;
}",0.6656
109004,"private void parse(){
  final String query=text.getText();
  final DataSelector selector=DataSelector.create(data);
  QueryTokenizer parser=new QueryTokenizer(new QueryTokenizerListener(){
    private Operator current=null;
    private DataType<?> type=null;
    private void setCurrent(    Operator operator){
      if (current != null) {
        throw new RuntimeException(""String_Node_Str"" + operator);
      }
 else {
        current=operator;
      }
    }
    @Override public void geq(    int start,    int length){
      setCurrent(Operator.GEQ);
    }
    @Override public void value(    int start,    int length){
      if (current == null) {
        throw new RuntimeException(""String_Node_Str"" + query.substring(start + 1,start + length - 1));
      }
      if (type == null) {
        throw new RuntimeException(""String_Node_Str"" + query.substring(start + 1,start + length - 1));
      }
      Object value=type.fromString(query.substring(start + 1,start + length - 1));
switch (current) {
case EQUALS:
        if (value instanceof Date) {
          selector.equals((Date)value);
        }
 else         if (value instanceof String) {
          selector.equals((String)value);
        }
 else         if (value instanceof Double) {
          selector.equals((Double)value);
        }
      break;
case GEQ:
    if (value instanceof Date) {
      selector.geq((Date)value);
    }
 else     if (value instanceof String) {
      selector.geq((String)value);
    }
 else     if (value instanceof Double) {
      selector.geq((Double)value);
    }
  break;
case GREATER:
if (value instanceof Date) {
  selector.greater((Date)value);
}
 else if (value instanceof String) {
  selector.greater((String)value);
}
 else if (value instanceof Double) {
  selector.greater((Double)value);
}
break;
case LEQ:
if (value instanceof Date) {
selector.leq((Date)value);
}
 else if (value instanceof String) {
selector.leq((String)value);
}
 else if (value instanceof Double) {
selector.leq((Double)value);
}
break;
case LESS:
if (value instanceof Date) {
selector.less((Date)value);
}
 else if (value instanceof String) {
selector.less((String)value);
}
 else if (value instanceof Double) {
selector.less((Double)value);
}
break;
}
current=null;
type=null;
}
@Override public void field(int start,int length){
String field=query.substring(start + 1,start + length - 1);
int index=data.getHandle().getColumnIndexOf(field);
if (index == -1) {
throw new RuntimeException(""String_Node_Str"" + field);
}
 else {
type=data.getHandle().getDataType(field);
selector.field(field);
}
}
@Override public void begin(int start){
selector.begin();
}
@Override public void end(int start){
selector.end();
}
@Override public void and(int start,int length){
selector.and();
}
@Override public void or(int start,int length){
selector.or();
}
@Override public void less(int start){
setCurrent(Operator.LESS);
}
@Override public void greater(int start){
setCurrent(Operator.GREATER);
}
@Override public void leq(int start,int length){
setCurrent(Operator.LEQ);
}
@Override public void equals(int start){
setCurrent(Operator.EQUALS);
}
}
);
try {
parser.tokenize(query);
selector.compile();
}
 catch (Exception e) {
error.setText(e.getMessage());
e.printStackTrace();
return;
}
error.setText(""String_Node_Str"");
}","private void parse(){
  final String query=text.getText();
  final DataSelector selector=DataSelector.create(data);
  QueryTokenizer parser=new QueryTokenizer(new QueryTokenizerListener(){
    private Operator current=null;
    private DataType<?> type=null;
    private void setCurrent(    Operator operator){
      if (current != null) {
        throw new RuntimeException(""String_Node_Str"" + operator);
      }
 else {
        current=operator;
      }
    }
    @Override public void geq(    int start,    int length){
      setCurrent(Operator.GEQ);
    }
    @Override public void value(    int start,    int length){
      if (current == null) {
        throw new RuntimeException(""String_Node_Str"" + query.substring(start + 1,start + length - 1));
      }
      if (type == null) {
        throw new RuntimeException(""String_Node_Str"" + query.substring(start + 1,start + length - 1));
      }
      Object value=type.fromString(query.substring(start + 1,start + length - 1));
switch (current) {
case EQUALS:
        if (value instanceof Date) {
          selector.equals((Date)value);
        }
 else         if (value instanceof String) {
          selector.equals((String)value);
        }
 else         if (value instanceof Double) {
          selector.equals((Double)value);
        }
      break;
case GEQ:
    if (value instanceof Date) {
      selector.geq((Date)value);
    }
 else     if (value instanceof String) {
      selector.geq((String)value);
    }
 else     if (value instanceof Double) {
      selector.geq((Double)value);
    }
  break;
case GREATER:
if (value instanceof Date) {
  selector.greater((Date)value);
}
 else if (value instanceof String) {
  selector.greater((String)value);
}
 else if (value instanceof Double) {
  selector.greater((Double)value);
}
break;
case LEQ:
if (value instanceof Date) {
selector.leq((Date)value);
}
 else if (value instanceof String) {
selector.leq((String)value);
}
 else if (value instanceof Double) {
selector.leq((Double)value);
}
break;
case LESS:
if (value instanceof Date) {
selector.less((Date)value);
}
 else if (value instanceof String) {
selector.less((String)value);
}
 else if (value instanceof Double) {
selector.less((Double)value);
}
break;
}
current=null;
type=null;
}
@Override public void field(int start,int length){
String field=query.substring(start + 1,start + length - 1);
int index=data.getHandle().getColumnIndexOf(field);
if (index == -1) {
throw new RuntimeException(""String_Node_Str"" + field);
}
 else {
type=data.getHandle().getDataType(field);
selector.field(field);
}
}
@Override public void begin(int start){
selector.begin();
}
@Override public void end(int start){
selector.end();
}
@Override public void and(int start,int length){
selector.and();
}
@Override public void or(int start,int length){
selector.or();
}
@Override public void less(int start){
setCurrent(Operator.LESS);
}
@Override public void greater(int start){
setCurrent(Operator.GREATER);
}
@Override public void leq(int start,int length){
setCurrent(Operator.LEQ);
}
@Override public void equals(int start){
setCurrent(Operator.EQUALS);
}
@Override public void invalid(int start){
throw new RuntimeException(""String_Node_Str"" + start);
}
}
);
try {
parser.tokenize(query);
selector.compile();
}
 catch (Exception e) {
error.setText(e.getMessage());
ok.setEnabled(false);
return;
}
error.setText(""String_Node_Str"");
queryString=text.getText();
ok.setEnabled(true);
}",0.9334722428932876
109005,"private void highlight(){
  if (highlighter == null) {
    highlighter=new QueryTokenizer(new QueryTokenizerListener(){
      @Override public void geq(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void value(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_DARK_GRAY;
        styles.add(style);
      }
      @Override public void field(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_RED;
        styles.add(style);
      }
      @Override public void begin(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_GREEN;
        styles.add(style);
      }
      @Override public void end(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_GREEN;
        styles.add(style);
      }
      @Override public void and(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_GRAY;
        styles.add(style);
      }
      @Override public void or(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_GRAY;
        styles.add(style);
      }
      @Override public void less(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void greater(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void leq(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void equals(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
    }
);
  }
  styles.clear();
  highlighter.tokenize(text.getText());
  text.setRedraw(false);
  text.setStyleRanges(styles.toArray(new StyleRange[styles.size()]));
  text.setRedraw(true);
}","private void highlight(){
  if (highlighter == null) {
    highlighter=new QueryTokenizer(new QueryTokenizerListener(){
      @Override public void geq(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void value(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_DARK_GRAY;
        styles.add(style);
      }
      @Override public void field(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_RED;
        styles.add(style);
      }
      @Override public void begin(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_GREEN;
        styles.add(style);
      }
      @Override public void end(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_GREEN;
        styles.add(style);
      }
      @Override public void and(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_GRAY;
        styles.add(style);
      }
      @Override public void or(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_GRAY;
        styles.add(style);
      }
      @Override public void less(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void greater(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void leq(      int start,      int length){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=length;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void equals(      int start){
        StyleRange style=new StyleRange();
        style.start=start;
        style.length=1;
        style.fontStyle=SWT.BOLD;
        style.foreground=GUIHelper.COLOR_BLUE;
        styles.add(style);
      }
      @Override public void invalid(      int start){
      }
    }
);
  }
  styles.clear();
  highlighter.tokenize(text.getText());
  text.setRedraw(false);
  text.setStyleRanges(styles.toArray(new StyleRange[styles.size()]));
  text.setRedraw(true);
}",0.9898598270205786
109006,"public QueryDialog(final Data data,final Shell parent,String initial){
  super(parent);
  this.initial=initial;
  this.data=data;
}","public QueryDialog(final Data data,final Shell parent,String initial){
  super(parent);
  this.queryString=initial;
  this.data=data;
}",0.9473684210526316
109007,"public String getQuery(){
  return text.getText();
}","public String getQuery(){
  return queryString;
}",0.7920792079207921
109008,"public void tokenize(String query){
  int quote=-1;
  boolean first=true;
  char[] data=query.toCharArray();
  for (int i=0; i < data.length; i++) {
    if (data[i] == '\\') {
      i++;
    }
 else     if (data[i] == '""') {
      if (quote == -1) {
        quote=i;
      }
 else {
        if (first) {
          listener.field(quote,i - quote + 1);
        }
 else {
          listener.value(quote,i - quote + 1);
        }
        quote=-1;
        first=!first;
      }
    }
 else     if (quote == -1 && data[i] == '(') {
      listener.begin(i);
    }
 else     if (quote == -1 && data[i] == ')') {
      listener.end(i);
    }
 else     if (quote == -1 && i < data.length - 2 && data[i] == 'a' && data[i + 1] == 'n' && data[i + 2] == 'd') {
      listener.and(i,3);
    }
 else     if (quote == -1 && i < data.length - 1 && data[i] == 'o' && data[i + 1] == 'r') {
      listener.or(i,2);
    }
 else     if ((quote == -1 && i < data.length - 1 && data[i] == '<' && data[i + 1] == '=')) {
      listener.leq(i,2);
    }
 else     if ((quote == -1 && i < data.length - 1 && data[i] == '>' && data[i + 1] == '=')) {
      listener.geq(i,2);
    }
 else     if (quote == -1 && data[i] == '=') {
      listener.equals(i);
    }
 else     if (quote == -1 && data[i] == '<') {
      listener.less(i);
    }
 else     if (quote == -1 && data[i] == '>') {
      listener.greater(i);
    }
    if (i >= data.length)     break;
  }
}","public void tokenize(String query){
  int quote=-1;
  boolean first=true;
  char[] data=query.toCharArray();
  for (int i=0; i < data.length; i++) {
    if (data[i] == '\\') {
      i++;
    }
 else     if (data[i] == '""') {
      if (quote == -1) {
        quote=i;
      }
 else {
        if (first) {
          listener.field(quote,i - quote + 1);
        }
 else {
          listener.value(quote,i - quote + 1);
        }
        quote=-1;
        first=!first;
      }
    }
 else     if (quote == -1 && data[i] == '(') {
      listener.begin(i);
    }
 else     if (quote == -1 && data[i] == ')') {
      listener.end(i);
    }
 else     if (quote == -1 && i < data.length - 2 && data[i] == 'a' && data[i + 1] == 'n' && data[i + 2] == 'd') {
      listener.and(i,3);
      i+=2;
    }
 else     if (quote == -1 && i < data.length - 1 && data[i] == 'o' && data[i + 1] == 'r') {
      listener.or(i,2);
      i++;
    }
 else     if ((quote == -1 && i < data.length - 1 && data[i] == '<' && data[i + 1] == '=')) {
      listener.leq(i,2);
      i++;
    }
 else     if ((quote == -1 && i < data.length - 1 && data[i] == '>' && data[i + 1] == '=')) {
      listener.geq(i,2);
      i++;
    }
 else     if (quote == -1 && data[i] == '=') {
      listener.equals(i);
    }
 else     if (quote == -1 && data[i] == '<') {
      listener.less(i);
    }
 else     if (quote == -1 && data[i] == '>') {
      listener.greater(i);
    }
 else     if (quote == -1 && (data[i] != ' ' && data[i] != '\t' && data[i] != '\n')) {
      listener.invalid(i);
    }
    if (i >= data.length)     break;
  }
}",0.9454184584849488
109009,"/** 
 * Reset a previous lattice and run the algorithm 
 * @param handle
 * @param definition
 * @param config
 * @param lattice
 * @param algorithm
 * @return
 * @throws IOException
 */
protected Result anonymizeInternal(final DataHandle handle,final DataDefinition definition,final ARXConfiguration config,Lattice lattice,int multiplier,AbstractAlgorithm algorithm) throws IOException {
  final DataManager manager=prepareDataManager(handle,definition,config);
  config.initialize(manager);
  checkAfterEncoding(config,manager);
  if (lattice == null) {
    lattice=new LatticeBuilder(manager.getMaxLevels(),manager.getMinLevels(),manager.getHierachyHeights()).build();
  }
  printLattice(""String_Node_Str"",lattice);
  lattice.setListener(listener);
  lattice.setMultiplier(multiplier);
  final INodeChecker checker=new NodeChecker(manager,config.getMetric(),config,historySize,snapshotSizeDataset,snapshotSizeSnapshot);
  config.getMetric().initialize(manager.getDataQI(),manager.getHierarchies(),config);
  if (algorithm != null) {
    algorithm=FLASHAlgorithm.create((AbstractFLASHAlgorithm)algorithm,checker);
  }
 else {
    algorithm=FLASHAlgorithm.create(lattice,checker,new FLASHStrategy(lattice,manager.getHierarchies()));
  }
  algorithm.traverse();
  printLattice(""String_Node_Str"",lattice);
  return new Result(config.getMetric(),checker,lattice,manager,algorithm);
}","/** 
 * Reset a previous lattice and run the algorithm 
 * @param handle
 * @param definition
 * @param config
 * @param lattice
 * @param algorithm
 * @return
 * @throws IOException
 */
protected Result anonymizeInternal(final DataHandle handle,final DataDefinition definition,final ARXConfiguration config,Lattice lattice,int multiplier,AbstractAlgorithm algorithm) throws IOException {
  final DataManager manager=prepareDataManager(handle,definition,config);
  config.initialize(manager);
  checkAfterEncoding(config,manager);
  if (lattice == null) {
    lattice=new LatticeBuilder(manager.getMaxLevels(),manager.getMinLevels(),manager.getHierachyHeights()).build();
  }
  lattice.setListener(listener);
  lattice.setMultiplier(multiplier);
  final INodeChecker checker=new NodeChecker(manager,config.getMetric(),config,historySize,snapshotSizeDataset,snapshotSizeSnapshot);
  config.getMetric().initialize(manager.getDataQI(),manager.getHierarchies(),config);
  if (algorithm != null) {
    algorithm=FLASHAlgorithm.create((AbstractFLASHAlgorithm)algorithm,checker);
  }
 else {
    algorithm=FLASHAlgorithm.create(lattice,checker,new FLASHStrategy(lattice,manager.getHierarchies()));
  }
  algorithm.traverse();
  return new Result(config.getMetric(),checker,lattice,manager,algorithm);
}",0.9155455904334828
109010,"/** 
 * Finds an expression within the given range
 * @param ops
 * @param offset
 * @param length
 * @return
 */
private int findExpression(List<Operator> ops,int offset,int length){
  if (offset >= ops.size()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  Operator op=ops.get(offset);
  if (op instanceof BinaryOperator) {
    throw new RuntimeException(""String_Node_Str"");
  }
 else   if (op instanceof UnaryOperator) {
    return 1;
  }
 else   if (op instanceof PrecedenceOperator) {
    PrecedenceOperator pop=(PrecedenceOperator)op;
    if (!pop.begin) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      int open=1;
      for (int i=offset + 1; i < length; i++) {
        if (ops.get(i) instanceof PrecedenceOperator) {
          pop=(PrecedenceOperator)ops.get(i);
          if (pop.begin)           open++;
 else           open--;
          if (open == 0) {
            return i - offset + 1;
          }
        }
      }
      throw new RuntimeException(""String_Node_Str"" + open + ""String_Node_Str""+ length);
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Finds an expression within the given range
 * @param ops
 * @param offset
 * @param length
 * @return
 */
private int findExpression(List<Operator> ops,int offset,int length){
  if (offset >= ops.size()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  Operator op=ops.get(offset);
  if (op instanceof BinaryOperator) {
    throw new RuntimeException(""String_Node_Str"");
  }
 else   if (op instanceof UnaryOperator) {
    return 1;
  }
 else   if (op instanceof PrecedenceOperator) {
    PrecedenceOperator pop=(PrecedenceOperator)op;
    if (!pop.begin) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      int open=1;
      for (int i=offset + 1; i < offset + length; i++) {
        if (ops.get(i) instanceof PrecedenceOperator) {
          pop=(PrecedenceOperator)ops.get(i);
          if (pop.begin)           open++;
 else           open--;
          if (open == 0) {
            return i - offset + 1;
          }
        }
 else {
        }
      }
      throw new RuntimeException(""String_Node_Str"" + open + ""String_Node_Str""+ length);
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9882044560943644
109011,"private void update(){
  this.size=model.getInputConfig().getResearchSubset().length();
}","private void update(){
  int size=model.getInputConfig().getResearchSubset().size();
  int total=model.getInputConfig().getInput().getHandle().getNumRows();
  double percent=(double)size / (double)total * 100d;
  this.size.setText(String.valueOf(size));
  this.total.setText(String.valueOf(total));
  this.percent.setText(format.format(percent));
}",0.3615560640732265
109012,"private void actionImportData(final String path,final char separator){
  final WorkerImport worker=new WorkerImport(path,separator);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  model.getInputConfig().setInput(data);
  model.setInputBytes(new File(path).length());
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
    definition.setDataType(model.getInputConfig().getInput().getHandle().getAttributeName(i),DataType.STRING);
  }
  model.resetCriteria();
  model.getInputConfig().setResearchSubset(RowSet.create(data));
  update(new ModelEvent(this,EventTarget.MODEL,model));
  update(new ModelEvent(this,EventTarget.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,EventTarget.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,EventTarget.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,EventTarget.RESEARCH_SUBSET,null));
  }
}","private void actionImportData(final String path,final char separator){
  final WorkerImport worker=new WorkerImport(path,separator);
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
  reset();
  final Data data=worker.getResult();
  model.reset();
  RowSet subset=RowSet.create(data);
  for (int i=0; i < subset.length(); i++) {
    subset.add(i);
  }
  model.getInputConfig().setResearchSubset(subset);
  model.getInputConfig().setInput(data);
  model.setInputBytes(new File(path).length());
  final DataDefinition definition=data.getDefinition();
  for (int i=0; i < data.getHandle().getNumColumns(); i++) {
    definition.setAttributeType(model.getInputConfig().getInput().getHandle().getAttributeName(i),AttributeType.INSENSITIVE_ATTRIBUTE);
    definition.setDataType(model.getInputConfig().getInput().getHandle().getAttributeName(i),DataType.STRING);
  }
  model.resetCriteria();
  update(new ModelEvent(this,EventTarget.MODEL,model));
  update(new ModelEvent(this,EventTarget.INPUT,data.getHandle()));
  if (data.getHandle().getNumColumns() > 0) {
    model.setSelectedAttribute(data.getHandle().getAttributeName(0));
    update(new ModelEvent(this,EventTarget.SELECTED_ATTRIBUTE,data.getHandle().getAttributeName(0)));
    update(new ModelEvent(this,EventTarget.CRITERION_DEFINITION,null));
    update(new ModelEvent(this,EventTarget.RESEARCH_SUBSET,subset));
  }
}",0.9251700680272108
109013,"public void actionSubsetFile(){
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path == null) {
    return;
  }
  final SeparatorDialog dialog=new SeparatorDialog(main.getShell(),this,path,true);
  dialog.create();
  if (dialog.open() == Window.CANCEL) {
    return;
  }
  final WorkerImport worker=new WorkerImport(path,dialog.getSeparator());
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  DataSubset subset=DataSubset.create(data,subsetData);
  model.getInputConfig().setResearchSubset(subset.getRowSet());
  update(new ModelEvent(this,EventTarget.RESEARCH_SUBSET,subset.getRowSet()));
}","public void actionSubsetFile(){
  final String path=actionShowOpenFileDialog(""String_Node_Str"");
  if (path == null) {
    return;
  }
  final SeparatorDialog dialog=new SeparatorDialog(main.getShell(),this,path,true);
  dialog.create();
  if (dialog.open() == Window.CANCEL) {
    return;
  }
  final WorkerImport worker=new WorkerImport(path,dialog.getSeparator());
  main.showProgressDialog(Resources.getMessage(""String_Node_Str""),worker);
  if (worker.getError() != null) {
    main.showErrorDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str"") + worker.getError().getMessage());
    return;
  }
  Data subsetData=worker.getResult();
  Data data=model.getInputConfig().getInput();
  try {
    DataSubset subset=DataSubset.create(data,subsetData);
    model.getInputConfig().setResearchSubset(subset.getRowSet());
    update(new ModelEvent(this,EventTarget.RESEARCH_SUBSET,subset.getRowSet()));
  }
 catch (  IllegalArgumentException e) {
    main.showErrorDialog(""String_Node_Str"",e.getMessage());
  }
}",0.9377551020408164
109014,"private NatTable createTable(final Composite parent){
  final IDataProvider provider=new HandleDataProvider(null,null);
  gridLayer=new TableGridLayerStack(provider);
  final NatTable natTable=new NatTable(parent,gridLayer,false);
  final DataLayer bodyDataLayer=(DataLayer)gridLayer.getBodyDataLayer();
  final AggregrateConfigLabelAccumulator aggregrateConfigLabelAccumulator=new AggregrateConfigLabelAccumulator();
  bodyDataLayer.setConfigLabelAccumulator(aggregrateConfigLabelAccumulator);
  final ColumnOverrideLabelAccumulator columnLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  final ColumnOverrideLabelAccumulator bodyLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  aggregrateConfigLabelAccumulator.add(bodyLabelAccumulator);
  aggregrateConfigLabelAccumulator.add(columnLabelAccumulator);
  final DisplayColumnStyleEditorCommandHandler styleChooserCommandHandler=new DisplayColumnStyleEditorCommandHandler(gridLayer.getBodyLayer().getSelectionLayer(),columnLabelAccumulator,natTable.getConfigRegistry());
  bodyLayer=gridLayer.getBodyLayer();
  bodyLayer.registerCommandHandler(styleChooserCommandHandler);
  bodyLayer.registerPersistable(styleChooserCommandHandler);
  bodyLayer.registerPersistable(columnLabelAccumulator);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new DataTableDecorator(new TextPainter(false,true,0,true),new BorderStyle(2,GUIHelper.COLOR_BLACK,LineStyleEnum.SOLID)),DisplayMode.NORMAL,GridRegion.BODY);
  for (int i=0; i < GRADIENT.length; i++) {
    Style style=new Style();
    style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,GRADIENT[i]);
    natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"" + i);
  }
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new CheckBoxPainter(),DisplayMode.NORMAL,""String_Node_Str"");
  return natTable;
}","private NatTable createTable(final Composite parent){
  final IDataProvider provider=new HandleDataProvider(null);
  gridLayer=new TableGridLayerStack(provider);
  final NatTable natTable=new NatTable(parent,gridLayer,false);
  final DataLayer bodyDataLayer=(DataLayer)gridLayer.getBodyDataLayer();
  final AggregrateConfigLabelAccumulator aggregrateConfigLabelAccumulator=new AggregrateConfigLabelAccumulator();
  bodyDataLayer.setConfigLabelAccumulator(aggregrateConfigLabelAccumulator);
  final ColumnOverrideLabelAccumulator columnLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  final ColumnOverrideLabelAccumulator bodyLabelAccumulator=new ColumnOverrideLabelAccumulator(bodyDataLayer);
  aggregrateConfigLabelAccumulator.add(bodyLabelAccumulator);
  aggregrateConfigLabelAccumulator.add(columnLabelAccumulator);
  final DisplayColumnStyleEditorCommandHandler styleChooserCommandHandler=new DisplayColumnStyleEditorCommandHandler(gridLayer.getBodyLayer().getSelectionLayer(),columnLabelAccumulator,natTable.getConfigRegistry());
  bodyLayer=gridLayer.getBodyLayer();
  bodyLayer.registerCommandHandler(styleChooserCommandHandler);
  bodyLayer.registerPersistable(styleChooserCommandHandler);
  bodyLayer.registerPersistable(columnLabelAccumulator);
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new DataTableDecorator(new TextPainter(false,true,0,true),new BorderStyle(2,GUIHelper.COLOR_BLACK,LineStyleEnum.SOLID)),DisplayMode.NORMAL,GridRegion.BODY);
  for (int i=0; i < GRADIENT.length; i++) {
    Style style=new Style();
    style.setAttributeValue(CellStyleAttributes.BACKGROUND_COLOR,GRADIENT[i]);
    natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_STYLE,style,DisplayMode.NORMAL,""String_Node_Str"" + i);
  }
  natTable.getConfigRegistry().registerConfigAttribute(CellConfigAttributes.CELL_PAINTER,new CheckBoxPainter(),DisplayMode.NORMAL,""String_Node_Str"");
  return natTable;
}",0.998742770932864
109015,"public ArrayDataProvider(final String[][] data,final RowSet rows){
  this.data=data;
  this.rows=rows;
}","public ArrayDataProvider(final String[][] data){
  this.data=data;
}",0.7906976744186046
109016,"@Override public void setData(final String[][] data,final RowSet rows,int[] colors,int[] groups){
  this.table.setRedraw(false);
  this.handle=null;
  this.data=data;
  this.rows=rows;
  this.headerImages.clear();
  this.gridLayer=new TableGridLayerStack(new ArrayDataProvider(data,rows));
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(true);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(true);
  this.rowColors=colors;
  this.rowGroups=groups;
}","@Override public void setData(final String[][] data,final RowSet rows,int[] colors,int[] groups){
  this.table.setRedraw(false);
  this.handle=null;
  this.data=data;
  this.rows=rows;
  this.headerImages.clear();
  this.gridLayer=new TableGridLayerStack(new ArrayDataProvider(data));
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(true);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(true);
  this.rowColors=colors;
  this.rowGroups=groups;
}",0.996817313812858
109017,"public HandleDataProvider(final DataHandle data,final RowSet rows){
  this.data=data;
  this.rows=rows;
}","public HandleDataProvider(final DataHandle data){
  this.data=data;
}",0.7931034482758621
109018,"@Override public void reset(){
  this.table.setRedraw(false);
  this.headerImages.clear();
  this.gridLayer=new TableGridLayerStack(new HandleDataProvider(null,null));
  this.handle=null;
  this.data=null;
  this.rows=null;
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(false);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(false);
}","@Override public void reset(){
  this.table.setRedraw(false);
  this.headerImages.clear();
  this.gridLayer=new TableGridLayerStack(new HandleDataProvider(null));
  this.handle=null;
  this.data=null;
  this.rows=null;
  this.table.setLayer(gridLayer);
  this.table.refresh();
  this.gridLayer.getBodyLayer().getViewportLayer().recalculateScrollBars();
  this.table.getVerticalBar().setVisible(false);
  this.table.getHorizontalBar().setVisible(false);
  this.table.setRedraw(true);
  this.table.redraw();
  this.table.setVisible(false);
  this.table.getVerticalBar().setVisible(true);
  this.table.getHorizontalBar().setVisible(true);
  this.table.setVisible(false);
}",0.996276991809382
109019,"private void sortDefault(){
  list.removeAll();
  final DataType type=model.getDataType();
  Collections.sort(model.getItems(),new Comparator<String>(){
    @Override public int compare(    final String arg0,    final String arg1){
      try {
        return order * type.compare(arg0,arg1);
      }
 catch (      final ParseException e) {
        throw new RuntimeException(e);
      }
    }
  }
);
  for (  final String s : model.getItems()) {
    list.add(s);
  }
}","private void sortDefault(){
  list.removeAll();
  final DataType<?> type=model.getDataType();
  Collections.sort(model.getItems(),new Comparator<String>(){
    @Override public int compare(    final String arg0,    final String arg1){
      try {
        return order * type.compare(arg0,arg1);
      }
 catch (      final ParseException e) {
        throw new RuntimeException(e);
      }
    }
  }
);
  for (  final String s : model.getItems()) {
    list.add(s);
  }
}",0.9968051118210862
109020,"@Override public void createControl(final Composite parent){
  final Composite composite=new Composite(parent,SWT.NONE);
  final GridLayout compositeLayout=new GridLayout();
  compositeLayout.numColumns=1;
  composite.setLayout(compositeLayout);
  list=new List(composite,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  final int itemHeight=list.getItemHeight();
  final GridData data=new GridData(SWT.FILL,SWT.FILL,true,false);
  data.heightHint=10 * itemHeight;
  list.setLayoutData(data);
  final Composite bottom2=new Composite(composite,SWT.NONE);
  bottom2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout2=new GridLayout();
  bottomLayout2.numColumns=2;
  bottom2.setLayout(bottomLayout2);
  final Button up=new Button(bottom2,SWT.NONE);
  up.setText(Resources.getMessage(""String_Node_Str""));
  up.setImage(controller.getResources().getImage(""String_Node_Str""));
  up.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  up.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      up();
    }
  }
);
  final Button down=new Button(bottom2,SWT.NONE);
  down.setText(Resources.getMessage(""String_Node_Str""));
  down.setImage(controller.getResources().getImage(""String_Node_Str""));
  down.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  down.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      down();
    }
  }
);
  final Composite bottom1=new Composite(composite,SWT.NONE);
  bottom1.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=2;
  bottom1.setLayout(bottomLayout);
  final Label text=new Label(bottom1,SWT.NONE);
  text.setText(Resources.getMessage(""String_Node_Str""));
  final Combo combo=new Combo(bottom1,SWT.NONE);
  combo.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.select(1);
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (combo.getSelectionIndex() == 0) {
        sortDefault();
      }
 else       if (combo.getSelectionIndex() == 1) {
        sortLexicographic();
      }
 else       if (combo.getSelectionIndex() == 2) {
        sortNumeric();
      }
 else       if (combo.getSelectionIndex() == 3) {
        format=controller.actionShowDateFormatInputDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),model.getItems());
        if (format == null) {
          sortDefault();
          combo.select(0);
        }
 else {
          sortDate();
        }
      }
    }
  }
);
  try {
    sortDefault();
  }
 catch (  Exception e) {
  }
  setControl(composite);
}","@Override public void createControl(final Composite parent){
  final Composite composite=new Composite(parent,SWT.NONE);
  final GridLayout compositeLayout=new GridLayout();
  compositeLayout.numColumns=1;
  composite.setLayout(compositeLayout);
  list=new List(composite,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  final int itemHeight=list.getItemHeight();
  final GridData data=new GridData(SWT.FILL,SWT.FILL,true,false);
  data.heightHint=10 * itemHeight;
  list.setLayoutData(data);
  final Composite bottom2=new Composite(composite,SWT.NONE);
  bottom2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout2=new GridLayout();
  bottomLayout2.numColumns=2;
  bottom2.setLayout(bottomLayout2);
  final Button up=new Button(bottom2,SWT.NONE);
  up.setText(Resources.getMessage(""String_Node_Str""));
  up.setImage(controller.getResources().getImage(""String_Node_Str""));
  up.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  up.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      up();
    }
  }
);
  final Button down=new Button(bottom2,SWT.NONE);
  down.setText(Resources.getMessage(""String_Node_Str""));
  down.setImage(controller.getResources().getImage(""String_Node_Str""));
  down.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  down.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      down();
    }
  }
);
  final Composite bottom1=new Composite(composite,SWT.NONE);
  bottom1.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=2;
  bottom1.setLayout(bottomLayout);
  final Label text=new Label(bottom1,SWT.NONE);
  text.setText(Resources.getMessage(""String_Node_Str""));
  final Combo combo=new Combo(bottom1,SWT.NONE);
  combo.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.select(0);
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (combo.getSelectionIndex() == 0) {
        sortDefault();
      }
 else       if (combo.getSelectionIndex() == 1) {
        sortLexicographic();
      }
 else       if (combo.getSelectionIndex() == 2) {
        sortNumeric();
      }
 else       if (combo.getSelectionIndex() == 3) {
        format=controller.actionShowDateFormatInputDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),model.getItems());
        if (format == null) {
          sortDefault();
          combo.select(0);
        }
 else {
          sortDate();
        }
      }
    }
  }
);
  try {
    sortDefault();
  }
 catch (  Exception e) {
    sortLexicographic();
  }
  setControl(composite);
}",0.9955496950716992
109021,"@Override public void createControl(final Composite parent){
  final Composite composite=new Composite(parent,SWT.NONE);
  final GridLayout compositeLayout=new GridLayout();
  compositeLayout.numColumns=1;
  composite.setLayout(compositeLayout);
  list=new List(composite,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  final int itemHeight=list.getItemHeight();
  final GridData data=new GridData(SWT.FILL,SWT.FILL,true,false);
  data.heightHint=10 * itemHeight;
  list.setLayoutData(data);
  final Composite bottom2=new Composite(composite,SWT.NONE);
  bottom2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout2=new GridLayout();
  bottomLayout2.numColumns=2;
  bottom2.setLayout(bottomLayout2);
  final Button up=new Button(bottom2,SWT.NONE);
  up.setText(Resources.getMessage(""String_Node_Str""));
  up.setImage(controller.getResources().getImage(""String_Node_Str""));
  up.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  up.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      up();
    }
  }
);
  final Button down=new Button(bottom2,SWT.NONE);
  down.setText(Resources.getMessage(""String_Node_Str""));
  down.setImage(controller.getResources().getImage(""String_Node_Str""));
  down.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  down.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      down();
    }
  }
);
  final Composite bottom1=new Composite(composite,SWT.NONE);
  bottom1.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=2;
  bottom1.setLayout(bottomLayout);
  final Label text=new Label(bottom1,SWT.NONE);
  text.setText(Resources.getMessage(""String_Node_Str""));
  final Combo combo=new Combo(bottom1,SWT.NONE);
  combo.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.select(1);
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (combo.getSelectionIndex() == 0) {
        sortDefault();
      }
 else       if (combo.getSelectionIndex() == 1) {
        sortLexicographic();
      }
 else       if (combo.getSelectionIndex() == 2) {
        sortNumeric();
      }
 else       if (combo.getSelectionIndex() == 3) {
        format=controller.actionShowDateFormatInputDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),model.getItems());
        if (format == null) {
          sortDefault();
          combo.select(0);
        }
 else {
          sortDate();
        }
      }
    }
  }
);
  sortDefault();
  setControl(composite);
}","@Override public void createControl(final Composite parent){
  final Composite composite=new Composite(parent,SWT.NONE);
  final GridLayout compositeLayout=new GridLayout();
  compositeLayout.numColumns=1;
  composite.setLayout(compositeLayout);
  list=new List(composite,SWT.BORDER | SWT.SINGLE | SWT.V_SCROLL);
  final int itemHeight=list.getItemHeight();
  final GridData data=new GridData(SWT.FILL,SWT.FILL,true,false);
  data.heightHint=10 * itemHeight;
  list.setLayoutData(data);
  final Composite bottom2=new Composite(composite,SWT.NONE);
  bottom2.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout2=new GridLayout();
  bottomLayout2.numColumns=2;
  bottom2.setLayout(bottomLayout2);
  final Button up=new Button(bottom2,SWT.NONE);
  up.setText(Resources.getMessage(""String_Node_Str""));
  up.setImage(controller.getResources().getImage(""String_Node_Str""));
  up.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  up.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      up();
    }
  }
);
  final Button down=new Button(bottom2,SWT.NONE);
  down.setText(Resources.getMessage(""String_Node_Str""));
  down.setImage(controller.getResources().getImage(""String_Node_Str""));
  down.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  down.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      down();
    }
  }
);
  final Composite bottom1=new Composite(composite,SWT.NONE);
  bottom1.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  final GridLayout bottomLayout=new GridLayout();
  bottomLayout.numColumns=2;
  bottom1.setLayout(bottomLayout);
  final Label text=new Label(bottom1,SWT.NONE);
  text.setText(Resources.getMessage(""String_Node_Str""));
  final Combo combo=new Combo(bottom1,SWT.NONE);
  combo.setLayoutData(SWTUtil.createFillHorizontallyGridData());
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.add(Resources.getMessage(""String_Node_Str""));
  combo.select(1);
  combo.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    final SelectionEvent arg0){
      if (combo.getSelectionIndex() == 0) {
        sortDefault();
      }
 else       if (combo.getSelectionIndex() == 1) {
        sortLexicographic();
      }
 else       if (combo.getSelectionIndex() == 2) {
        sortNumeric();
      }
 else       if (combo.getSelectionIndex() == 3) {
        format=controller.actionShowDateFormatInputDialog(Resources.getMessage(""String_Node_Str""),Resources.getMessage(""String_Node_Str""),model.getItems());
        if (format == null) {
          sortDefault();
          combo.select(0);
        }
 else {
          sortDate();
        }
      }
    }
  }
);
  try {
    sortDefault();
  }
 catch (  Exception e) {
  }
  setControl(composite);
}",0.9928321386897816
109022,"/** 
 * Initializes the configuration
 * @param manager
 */
protected void initialize(DataManager manager){
  if (criteria.isEmpty()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  this.requirements=0x0;
  for (  PrivacyCriterion c : criteria) {
    this.requirements|=c.getRequirements();
  }
  if (this.containsCriterion(DPresence.class)) {
    this.getCriterion(DPresence.class).initialize(manager);
  }
  for (  PrivacyCriterion c : criteria) {
    if (!(c instanceof DPresence)) {
      c.initialize(manager);
    }
  }
  absMaxOutliers=(int)Math.floor(this.relMaxOutliers * (double)manager.getDataQI().getDataLength());
  List<PrivacyCriterion> list=new ArrayList<PrivacyCriterion>();
  if (this.containsCriterion(DPresence.class)) {
    list.add(this.getCriterion(DPresence.class));
  }
  if (this.containsCriterion(LDiversity.class)) {
    list.addAll(this.getCriteria(LDiversity.class));
  }
  if (this.containsCriterion(TCloseness.class)) {
    list.addAll(this.getCriteria(TCloseness.class));
  }
  this.aCriteria=list.toArray(new PrivacyCriterion[0]);
  this.snapshotLength=2;
  if (this.requires(REQUIREMENT_DISTRIBUTION)) {
    this.snapshotLength+=2;
  }
  if (this.requires(REQUIREMENT_SECONDARY_COUNTER)) {
    this.snapshotLength+=1;
  }
}","/** 
 * Initializes the configuration
 * @param manager
 */
protected void initialize(DataManager manager){
  if (criteria.isEmpty()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  this.requirements=0x0;
  for (  PrivacyCriterion c : criteria) {
    this.requirements|=c.getRequirements();
  }
  if (this.containsCriterion(DPresence.class)) {
    this.getCriterion(DPresence.class).initialize(manager);
  }
  for (  PrivacyCriterion c : criteria) {
    if (!(c instanceof DPresence)) {
      c.initialize(manager);
    }
  }
  int dataLength=0;
  if (this.containsCriterion(DPresence.class)) {
    dataLength=this.getCriterion(DPresence.class).getResearchSubsetSize();
  }
 else {
    dataLength=manager.getDataQI().getDataLength();
  }
  absMaxOutliers=(int)Math.floor(this.relMaxOutliers * (double)dataLength);
  List<PrivacyCriterion> list=new ArrayList<PrivacyCriterion>();
  if (this.containsCriterion(DPresence.class)) {
    list.add(this.getCriterion(DPresence.class));
  }
  if (this.containsCriterion(LDiversity.class)) {
    list.addAll(this.getCriteria(LDiversity.class));
  }
  if (this.containsCriterion(TCloseness.class)) {
    list.addAll(this.getCriteria(TCloseness.class));
  }
  this.aCriteria=list.toArray(new PrivacyCriterion[0]);
  this.snapshotLength=2;
  if (this.requires(REQUIREMENT_DISTRIBUTION)) {
    this.snapshotLength+=2;
  }
  if (this.requires(REQUIREMENT_SECONDARY_COUNTER)) {
    this.snapshotLength+=1;
  }
}",0.9122935779816512
109023,"@Override public void addAll(int[] key,int representant,int count,int sensitive,int pcount){
  final int hash=HashTableUtil.hashcode(key);
  final HashGroupifyEntry entry=addInternal(key,hash,representant,count,pcount);
  if (sensitive != -1) {
    if (entry.distribution == null) {
      entry.distribution=new Distribution();
    }
    entry.distribution.add(sensitive);
  }
}","@Override public void addAll(int[] key,int representant,int count,int sensitive,int pcount){
  final int hash=HashTableUtil.hashcode(key);
  final HashGroupifyEntry entry=addInternal(key,hash,representant,count,pcount);
  if (sensitive != -1) {
    if (entry.distribution == null) {
      entry.distribution=new Distribution();
    }
    if (subset == null || subset.get(representant)) {
      entry.distribution.add(sensitive);
    }
  }
}",0.9242053789731052
109024,"/** 
 * Returns the tree for the given sensitive attribute, if a generalization hierarchy is associated. Required for t-closeness with hierarchical distance EMD
 * @param attribute
 * @return tree
 */
public int[] getTree(String attribute){
  final int[][] data=dataSE.getArray();
  final int index=indexesSE.get(attribute);
  final int[][] hierarchy=hierarchiesSE.get(attribute).map;
  final int totalElementsP=data.length;
  final int height=hierarchy[0].length - 1;
  final int numLeafs=hierarchy.length;
  final ArrayList<Integer> treeList=new ArrayList<Integer>();
  treeList.add(totalElementsP);
  treeList.add(numLeafs);
  treeList.add(height);
  for (int i=0; i < numLeafs; i++) {
    treeList.add(0);
  }
  final int offsetLeafs=3;
  for (int i=0; i < data.length; i++) {
    if (subset == null || subset.get(i)) {
      int previousFreq=treeList.get(data[i][index] + offsetLeafs);
      previousFreq++;
      treeList.set(data[i][index] + offsetLeafs,previousFreq);
    }
  }
  for (int i=0; i < numLeafs; i++) {
    treeList.add(-1);
  }
class TNode {
    HashSet<Integer> children=new HashSet<Integer>();
    int offset=0;
    int level=0;
  }
  final int offsetsExtras=offsetLeafs + numLeafs;
  final HashMap<Integer,TNode> nodes=new HashMap<Integer,TNode>();
  final ArrayList<ArrayList<TNode>> levels=new ArrayList<ArrayList<TNode>>();
  for (int i=0; i < hierarchy[0].length; i++) {
    levels.add(new ArrayList<TNode>());
  }
  for (int i=0; i < hierarchy[0].length; i++) {
    for (int j=0; j < hierarchy.length; j++) {
      final int nodeID=hierarchy[j][i];
      TNode curNode=null;
      if (!nodes.containsKey(nodeID)) {
        curNode=new TNode();
        curNode.level=i;
        nodes.put(nodeID,curNode);
        final ArrayList<TNode> level=levels.get(curNode.level);
        level.add(curNode);
      }
 else {
        curNode=nodes.get(nodeID);
      }
      if (i > 0) {
        curNode.children.add(hierarchy[j][i - 1]);
      }
    }
  }
  for (  final ArrayList<TNode> level : levels) {
    for (    final TNode node : level) {
      if (node.level > 0) {
        node.offset=treeList.size();
        treeList.add(node.children.size());
        treeList.add(node.level);
        for (        final int child : node.children) {
          if (node.level == 1) {
            treeList.add(child + offsetsExtras);
          }
 else {
            treeList.add(nodes.get(child).offset);
          }
        }
        treeList.add(0);
        treeList.add(0);
      }
    }
  }
  final int[] treeArray=new int[treeList.size()];
  int count=0;
  for (  final int val : treeList) {
    treeArray[count++]=val;
  }
  return treeArray;
}","/** 
 * Returns the tree for the given sensitive attribute, if a generalization hierarchy is associated. Required for t-closeness with hierarchical distance EMD
 * @param attribute
 * @return tree
 */
public int[] getTree(String attribute){
  final int[][] data=dataSE.getArray();
  final int index=indexesSE.get(attribute);
  final int[][] hierarchy=hierarchiesSE.get(attribute).map;
  final int totalElementsP=subset == null ? data.length : subsetSize;
  final int height=hierarchy[0].length - 1;
  final int numLeafs=hierarchy.length;
  final ArrayList<Integer> treeList=new ArrayList<Integer>();
  treeList.add(totalElementsP);
  treeList.add(numLeafs);
  treeList.add(height);
  for (int i=0; i < numLeafs; i++) {
    treeList.add(0);
  }
  final int offsetLeafs=3;
  for (int i=0; i < data.length; i++) {
    if (subset == null || subset.get(i)) {
      int previousFreq=treeList.get(data[i][index] + offsetLeafs);
      previousFreq++;
      treeList.set(data[i][index] + offsetLeafs,previousFreq);
    }
  }
  for (int i=0; i < numLeafs; i++) {
    treeList.add(-1);
  }
class TNode {
    HashSet<Integer> children=new HashSet<Integer>();
    int offset=0;
    int level=0;
  }
  final int offsetsExtras=offsetLeafs + numLeafs;
  final HashMap<Integer,TNode> nodes=new HashMap<Integer,TNode>();
  final ArrayList<ArrayList<TNode>> levels=new ArrayList<ArrayList<TNode>>();
  for (int i=0; i < hierarchy[0].length; i++) {
    levels.add(new ArrayList<TNode>());
  }
  for (int i=0; i < hierarchy[0].length; i++) {
    for (int j=0; j < hierarchy.length; j++) {
      final int nodeID=hierarchy[j][i];
      TNode curNode=null;
      if (!nodes.containsKey(nodeID)) {
        curNode=new TNode();
        curNode.level=i;
        nodes.put(nodeID,curNode);
        final ArrayList<TNode> level=levels.get(curNode.level);
        level.add(curNode);
      }
 else {
        curNode=nodes.get(nodeID);
      }
      if (i > 0) {
        curNode.children.add(hierarchy[j][i - 1]);
      }
    }
  }
  for (  final ArrayList<TNode> level : levels) {
    for (    final TNode node : level) {
      if (node.level > 0) {
        node.offset=treeList.size();
        treeList.add(node.children.size());
        treeList.add(node.level);
        for (        final int child : node.children) {
          if (node.level == 1) {
            treeList.add(child + offsetsExtras);
          }
 else {
            treeList.add(nodes.get(child).offset);
          }
        }
        treeList.add(0);
        treeList.add(0);
      }
    }
  }
  final int[] treeArray=new int[treeList.size()];
  int count=0;
  for (  final int val : treeList) {
    treeArray[count++]=val;
  }
  return treeArray;
}",0.994392523364486
109025,"/** 
 * Performs some sanity checks.
 * @param data the allowed maximal number of outliers
 * @param config the configuration
 */
private void checkBeforeEncoding(final Data data,final ARXConfiguration config){
  if (data == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (config.containsCriterion(LDiversity.class) || config.containsCriterion(TCloseness.class)) {
    if (data.getDefinition().getSensitiveAttributes().size() == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  for (  String attr : data.getDefinition().getSensitiveAttributes()) {
    boolean found=false;
    for (    LDiversity c : config.getCriteria(LDiversity.class)) {
      if (c.getAttribute().equals(attr)) {
        found=true;
        break;
      }
    }
    if (!found) {
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (c.getAttribute().equals(attr)) {
          found=true;
          break;
        }
      }
    }
    if (!found) {
      throw new IllegalArgumentException(""String_Node_Str"" + attr + ""String_Node_Str"");
    }
  }
  for (  LDiversity c : config.getCriteria(LDiversity.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  for (  TCloseness c : config.getCriteria(TCloseness.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  final DataHandle handle=data.getHandle();
  if (!(handle instanceof DataHandleInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<String> attributes=new HashSet<String>();
  for (int i=0; i < handle.getNumColumns(); i++) {
    attributes.add(handle.getAttributeName(i));
  }
  for (  String attribute : data.getDefinition().getSensitiveAttributes()) {
    if (!attributes.contains(attribute)) {
      throw new IllegalArgumentException(""String_Node_Str"" + attribute + ""String_Node_Str"");
    }
  }
  for (  String attribute : data.getDefinition().getInsensitiveAttributes()) {
    if (!attributes.contains(attribute)) {
      throw new IllegalArgumentException(""String_Node_Str"" + attribute + ""String_Node_Str"");
    }
  }
  for (  String attribute : data.getDefinition().getIdentifyingAttributes()) {
    if (!attributes.contains(attribute)) {
      throw new IllegalArgumentException(""String_Node_Str"" + attribute + ""String_Node_Str"");
    }
  }
  for (  String attribute : data.getDefinition().getQuasiIdentifyingAttributes()) {
    if (!attributes.contains(attribute)) {
      throw new IllegalArgumentException(""String_Node_Str"" + attribute + ""String_Node_Str"");
    }
  }
  Map<String,String[][]> hierarchies=handle.getDefinition().getHierarchies();
  if ((config.getMaxOutliers() < 0d) || (config.getMaxOutliers() >= 1d)) {
    throw new IllegalArgumentException(""String_Node_Str"" + handle + ""String_Node_Str"");
  }
  if (hierarchies.size() > 15) {
    throw new IllegalArgumentException(""String_Node_Str"" + config.size());
  }
  if (hierarchies.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Performs some sanity checks.
 * @param data the allowed maximal number of outliers
 * @param config the configuration
 */
private void checkBeforeEncoding(final Data data,final ARXConfiguration config){
  if (data == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (config.containsCriterion(LDiversity.class) || config.containsCriterion(TCloseness.class)) {
    if (data.getDefinition().getSensitiveAttributes().size() == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  for (  String attr : data.getDefinition().getSensitiveAttributes()) {
    boolean found=false;
    for (    LDiversity c : config.getCriteria(LDiversity.class)) {
      if (c.getAttribute().equals(attr)) {
        found=true;
        break;
      }
    }
    if (!found) {
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (c.getAttribute().equals(attr)) {
          found=true;
          break;
        }
      }
    }
    if (!found) {
      throw new IllegalArgumentException(""String_Node_Str"" + attr + ""String_Node_Str"");
    }
  }
  for (  LDiversity c : config.getCriteria(LDiversity.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  for (  TCloseness c : config.getCriteria(TCloseness.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  final DataHandle handle=data.getHandle();
  if (!(handle instanceof DataHandleInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<String> attributes=new HashSet<String>();
  for (int i=0; i < handle.getNumColumns(); i++) {
    attributes.add(handle.getAttributeName(i));
  }
  for (  String attribute : data.getDefinition().getSensitiveAttributes()) {
    if (!attributes.contains(attribute)) {
      throw new IllegalArgumentException(""String_Node_Str"" + attribute + ""String_Node_Str"");
    }
  }
  for (  String attribute : data.getDefinition().getInsensitiveAttributes()) {
    if (!attributes.contains(attribute)) {
      throw new IllegalArgumentException(""String_Node_Str"" + attribute + ""String_Node_Str"");
    }
  }
  for (  String attribute : data.getDefinition().getIdentifyingAttributes()) {
    if (!attributes.contains(attribute)) {
      throw new IllegalArgumentException(""String_Node_Str"" + attribute + ""String_Node_Str"");
    }
  }
  for (  String attribute : data.getDefinition().getQuasiIdentifyingAttributes()) {
    if (!attributes.contains(attribute)) {
      throw new IllegalArgumentException(""String_Node_Str"" + attribute + ""String_Node_Str"");
    }
  }
  Map<String,String[][]> hierarchies=handle.getDefinition().getHierarchies();
  if ((config.getMaxOutliers() < 0d) || (config.getMaxOutliers() >= 1d)) {
    throw new IllegalArgumentException(""String_Node_Str"" + handle + ""String_Node_Str"");
  }
  if (hierarchies.size() > 15) {
    throw new IllegalArgumentException(""String_Node_Str"" + hierarchies.size());
  }
  if (hierarchies.size() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9974277500378272
109026,"@Override protected void createDataTypeArray(){
  dataTypes=new DataType[1][header.length];
  for (int i=0; i < header.length; i++) {
    final DataType type=definition.getDataType(header[i]);
    if (type != null) {
      dataTypes[0][i]=type;
    }
 else {
      dataTypes[0][i]=DataType.STRING;
    }
  }
}","@Override protected void createDataTypeArray(){
  dataTypes=new DataType[1][header.length];
  for (int i=0; i < header.length; i++) {
    final DataType<?> type=definition.getDataType(header[i]);
    if (type != null) {
      dataTypes[0][i]=type;
    }
 else {
      dataTypes[0][i]=DataType.STRING;
    }
  }
}",0.9951690821256038
109027,"/** 
 * Triggers a tagged event at the listener
 */
public void triggerTagged(){
  this.listener.nodeTagged(size * multiplier);
}","/** 
 * Triggers a tagged event at the listener
 */
public void triggerTagged(){
  if (this.listener != null)   this.listener.nodeTagged(size * multiplier);
}",0.8989547038327527
109028,"/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  final long time=System.currentTimeMillis();
  if (data == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (config.containsCriterion(LDiversity.class) || config.containsCriterion(TCloseness.class)) {
    if (data.getDefinition().getSensitiveAttributes().size() == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  for (  String attr : data.getDefinition().getSensitiveAttributes()) {
    boolean found=false;
    for (    LDiversity c : config.getCriteria(LDiversity.class)) {
      if (c.getAttribute().equals(attr)) {
        found=true;
        break;
      }
    }
    if (!found) {
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (c.getAttribute().equals(attr)) {
          found=true;
          break;
        }
      }
    }
    if (!found) {
      throw new IllegalArgumentException(""String_Node_Str"" + attr + ""String_Node_Str"");
    }
  }
  for (  LDiversity c : config.getCriteria(LDiversity.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  for (  TCloseness c : config.getCriteria(TCloseness.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  final DataHandle handle=data.getHandle();
  if (!(handle instanceof DataHandleInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkBeforeEncoding(config.getAllowedOutliers(),handle.getDefinition().getHierarchies());
  if (data.getDefinition().getSensitiveAttributes().size() > 1) {
    final AttributeType substition;
    if (config.isProtectSensitiveAssociations()) {
      substition=AttributeType.QUASI_IDENTIFYING_ATTRIBUTE;
    }
 else {
      substition=AttributeType.INSENSITIVE_ATTRIBUTE;
    }
    Result result=null;
    List<String> sensitive=new ArrayList<String>(data.getDefinition().getSensitiveAttributes());
    for (int i=0; i < sensitive.size(); i++) {
      String attribute=sensitive.get(i);
      config=config.clone();
      DataDefinition definition=handle.getDefinition().clone();
      for (      LDiversity c : config.getCriteria(LDiversity.class)) {
        if (!c.getAttribute().equals(attribute)) {
          config.removeCriterion(c);
          definition.setAttributeType(c.getAttribute(),substition);
        }
      }
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (!c.getAttribute().equals(attribute)) {
          config.removeCriterion(c);
          definition.setAttributeType(c.getAttribute(),substition);
        }
      }
      if (config.isProtectSensitiveAssociations()) {
        throw new RuntimeException(""String_Node_Str"");
      }
      Lattice lattice=null;
      AbstractAlgorithm algorithm=null;
      if (result != null) {
        if (config.isProtectSensitiveAssociations()) {
          throw new RuntimeException(""String_Node_Str"");
        }
 else {
          reset(result.lattice);
          lattice=result.lattice;
        }
        algorithm=result.algorithm;
      }
      result=anonymizeInternal(handle,definition,config,lattice,sensitive.size(),algorithm);
    }
    if (config.isProtectSensitiveAssociations()) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      return result.asResult(config,handle,time);
    }
  }
 else {
    return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
  }
}","/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  final long time=System.currentTimeMillis();
  if (data == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (config.containsCriterion(LDiversity.class) || config.containsCriterion(TCloseness.class)) {
    if (data.getDefinition().getSensitiveAttributes().size() == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  for (  String attr : data.getDefinition().getSensitiveAttributes()) {
    boolean found=false;
    for (    LDiversity c : config.getCriteria(LDiversity.class)) {
      if (c.getAttribute().equals(attr)) {
        found=true;
        break;
      }
    }
    if (!found) {
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (c.getAttribute().equals(attr)) {
          found=true;
          break;
        }
      }
    }
    if (!found) {
      throw new IllegalArgumentException(""String_Node_Str"" + attr + ""String_Node_Str"");
    }
  }
  for (  LDiversity c : config.getCriteria(LDiversity.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  for (  TCloseness c : config.getCriteria(TCloseness.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  final DataHandle handle=data.getHandle();
  if (!(handle instanceof DataHandleInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkBeforeEncoding(config.getAllowedOutliers(),handle.getDefinition().getHierarchies());
  if (data.getDefinition().getSensitiveAttributes().size() > 1) {
    final AttributeType substition;
    if (config.isProtectSensitiveAssociations()) {
      substition=AttributeType.QUASI_IDENTIFYING_ATTRIBUTE;
    }
 else {
      substition=AttributeType.INSENSITIVE_ATTRIBUTE;
    }
    Result result=null;
    List<String> sensitive=new ArrayList<String>(data.getDefinition().getSensitiveAttributes());
    for (int i=0; i < sensitive.size(); i++) {
      String attribute=sensitive.get(i);
      config=config.clone();
      DataDefinition definition=handle.getDefinition().clone();
      for (      LDiversity c : config.getCriteria(LDiversity.class)) {
        if (!c.getAttribute().equals(attribute)) {
          config.removeCriterion(c);
          definition.setAttributeType(c.getAttribute(),substition);
        }
      }
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (!c.getAttribute().equals(attribute)) {
          config.removeCriterion(c);
          definition.setAttributeType(c.getAttribute(),substition);
        }
      }
      if (config.isProtectSensitiveAssociations()) {
        throw new RuntimeException(""String_Node_Str"");
      }
      Lattice lattice=null;
      AbstractAlgorithm algorithm=null;
      if (result != null) {
        if (config.isProtectSensitiveAssociations()) {
          throw new RuntimeException(""String_Node_Str"");
        }
 else {
          resetLattice(result.lattice);
          lattice=result.lattice;
        }
        algorithm=result.algorithm;
      }
      result=anonymizeInternal(handle,definition,config,lattice,sensitive.size(),algorithm);
    }
    if (config.isProtectSensitiveAssociations()) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      return result.asResult(config,handle,time);
    }
  }
 else {
    return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
  }
}",0.9990999099909992
109029,"/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final Data data=getData();
  data.getDefinition().setAttributeType(""String_Node_Str"",getHierarchyAge());
  data.getDefinition().setAttributeType(""String_Node_Str"",getHierarchyZipcode());
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.SENSITIVE_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.SENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(3));
  config.addCriterion(new HierarchicalDistanceTCloseness(""String_Node_Str"",0.6d,getHierarchyDisease()));
  config.addCriterion(new HierarchicalDistanceTCloseness(""String_Node_Str"",0.6d,getHierarchyDisease()));
  config.setProtectSensitiveAssociations(false);
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    final Iterator<String[]> transformed=result.getHandle().iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final Data data=getData();
  data.getDefinition().setAttributeType(""String_Node_Str"",getHierarchyAge());
  data.getDefinition().setAttributeType(""String_Node_Str"",getHierarchyZipcode());
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.SENSITIVE_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.SENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(3));
  config.addCriterion(new HierarchicalDistanceTCloseness(""String_Node_Str"",0.6d,getHierarchyDisease()));
  config.addCriterion(new HierarchicalDistanceTCloseness(""String_Node_Str"",0.6d,getHierarchyDisease()));
  config.setProtectSensitiveAssociations(false);
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    printResult(result,data);
    if (result.getGlobalOptimum() != null) {
      System.out.println(""String_Node_Str"");
      final Iterator<String[]> transformed=result.getHandle().iterator();
      while (transformed.hasNext()) {
        System.out.print(""String_Node_Str"");
        System.out.println(Arrays.toString(transformed.next()));
      }
    }
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}",0.9793645594497216
109030,"/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  final long time=System.currentTimeMillis();
  if (data == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (config.containsCriterion(LDiversity.class) || config.containsCriterion(TCloseness.class)) {
    if (data.getDefinition().getSensitiveAttributes().size() == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  for (  String attr : data.getDefinition().getSensitiveAttributes()) {
    boolean found=false;
    for (    LDiversity c : config.getCriteria(LDiversity.class)) {
      if (c.getAttribute().equals(attr)) {
        found=true;
        break;
      }
    }
    if (!found) {
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (c.getAttribute().equals(attr)) {
          found=true;
          break;
        }
      }
    }
    if (!found) {
      throw new IllegalArgumentException(""String_Node_Str"" + attr + ""String_Node_Str"");
    }
  }
  for (  LDiversity c : config.getCriteria(LDiversity.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  for (  TCloseness c : config.getCriteria(TCloseness.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  final DataHandle handle=data.getHandle();
  if (!(handle instanceof DataHandleInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkBeforeEncoding(config.getAllowedOutliers(),handle.getDefinition().getHierarchies());
  if (data.getDefinition().getSensitiveAttributes().size() > 1) {
    final AttributeType substition;
    if (config.isProtectSensitiveAssociations()) {
      substition=AttributeType.QUASI_IDENTIFYING_ATTRIBUTE;
    }
 else {
      substition=AttributeType.INSENSITIVE_ATTRIBUTE;
    }
    Result result=null;
    List<String> sensitive=new ArrayList<String>(data.getDefinition().getSensitiveAttributes());
    for (int i=0; i < sensitive.size(); i++) {
      String attribute=sensitive.get(i);
      config=config.clone();
      DataDefinition definition=handle.getDefinition().clone();
      for (      LDiversity c : config.getCriteria(LDiversity.class)) {
        if (!c.getAttribute().equals(attribute)) {
          config.removeCriterion(c);
          definition.setAttributeType(attribute,substition);
        }
      }
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (!c.getAttribute().equals(attribute)) {
          config.removeCriterion(c);
          definition.setAttributeType(attribute,substition);
        }
      }
      Lattice lattice=null;
      if (result != null) {
        if (config.isProtectSensitiveAssociations()) {
          throw new RuntimeException(""String_Node_Str"");
        }
 else {
          reset(result.lattice);
          lattice=result.lattice;
        }
      }
      result=anonymizeInternal(handle,definition,config,lattice,sensitive.size());
    }
    if (config.isProtectSensitiveAssociations()) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      return result.asResult(config,handle,time);
    }
  }
 else {
    return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
  }
}","/** 
 * Performs data anonymization
 * @param data The data
 * @param config The privacy config
 * @return ARXResult
 * @throws IOException
 */
public ARXResult anonymize(final Data data,ARXConfiguration config) throws IOException {
  final long time=System.currentTimeMillis();
  if (data == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (config.containsCriterion(LDiversity.class) || config.containsCriterion(TCloseness.class)) {
    if (data.getDefinition().getSensitiveAttributes().size() == 0) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  for (  String attr : data.getDefinition().getSensitiveAttributes()) {
    boolean found=false;
    for (    LDiversity c : config.getCriteria(LDiversity.class)) {
      if (c.getAttribute().equals(attr)) {
        found=true;
        break;
      }
    }
    if (!found) {
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (c.getAttribute().equals(attr)) {
          found=true;
          break;
        }
      }
    }
    if (!found) {
      throw new IllegalArgumentException(""String_Node_Str"" + attr + ""String_Node_Str"");
    }
  }
  for (  LDiversity c : config.getCriteria(LDiversity.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  for (  TCloseness c : config.getCriteria(TCloseness.class)) {
    if (data.getDefinition().getAttributeType(c.getAttribute()) != AttributeType.SENSITIVE_ATTRIBUTE) {
      throw new RuntimeException(""String_Node_Str"" + c.getAttribute() + ""String_Node_Str"");
    }
  }
  final DataHandle handle=data.getHandle();
  if (!(handle instanceof DataHandleInput)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkBeforeEncoding(config.getAllowedOutliers(),handle.getDefinition().getHierarchies());
  if (data.getDefinition().getSensitiveAttributes().size() > 1) {
    final AttributeType substition;
    if (config.isProtectSensitiveAssociations()) {
      substition=AttributeType.QUASI_IDENTIFYING_ATTRIBUTE;
    }
 else {
      substition=AttributeType.INSENSITIVE_ATTRIBUTE;
    }
    Result result=null;
    List<String> sensitive=new ArrayList<String>(data.getDefinition().getSensitiveAttributes());
    for (int i=0; i < sensitive.size(); i++) {
      String attribute=sensitive.get(i);
      config=config.clone();
      DataDefinition definition=handle.getDefinition().clone();
      for (      LDiversity c : config.getCriteria(LDiversity.class)) {
        if (!c.getAttribute().equals(attribute)) {
          config.removeCriterion(c);
          definition.setAttributeType(c.getAttribute(),substition);
        }
      }
      for (      TCloseness c : config.getCriteria(TCloseness.class)) {
        if (!c.getAttribute().equals(attribute)) {
          config.removeCriterion(c);
          definition.setAttributeType(c.getAttribute(),substition);
        }
      }
      if (config.isProtectSensitiveAssociations()) {
        throw new RuntimeException(""String_Node_Str"");
      }
      Lattice lattice=null;
      if (result != null) {
        if (config.isProtectSensitiveAssociations()) {
          throw new RuntimeException(""String_Node_Str"");
        }
 else {
          reset(result.lattice);
          lattice=result.lattice;
        }
      }
      result=anonymizeInternal(handle,definition,config,lattice,sensitive.size());
    }
    if (config.isProtectSensitiveAssociations()) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      return result.asResult(config,handle,time);
    }
  }
 else {
    return anonymizeInternal(handle,handle.getDefinition(),config).asResult(config,handle,time);
  }
}",0.98205677557579
109031,"/** 
 * Prints the result
 * @param result
 * @param data
 */
protected static void printResult(final ARXResult result,final Data data){
  final ARXNode optimum=result.getGlobalOptimum();
  final List<String> qis=new ArrayList<String>(data.getDefinition().getQuasiIdentifyingAttributes());
  final StringBuffer[] identifiers=new StringBuffer[qis.size()];
  final StringBuffer[] generalizations=new StringBuffer[qis.size()];
  int lengthI=0;
  int lengthG=0;
  for (int i=0; i < qis.size(); i++) {
    identifiers[i]=new StringBuffer();
    generalizations[i]=new StringBuffer();
    identifiers[i].append(qis.get(i));
    generalizations[i].append(optimum.getGeneralization(qis.get(i))).append(""String_Node_Str"").append(data.getDefinition().getHierarchyHeight(qis.get(i)) - 1);
    lengthI=Math.max(lengthI,identifiers[i].length());
    lengthG=Math.max(lengthG,generalizations[i].length());
  }
  for (int i=0; i < qis.size(); i++) {
    while (identifiers[i].length() < lengthI) {
      identifiers[i].append(""String_Node_Str"");
    }
    while (generalizations[i].length() < lengthG) {
      generalizations[i].insert(0,""String_Node_Str"");
    }
  }
  final DecimalFormat df1=new DecimalFormat(""String_Node_Str"");
  final String sTotal=df1.format(result.getTime() / 1000d) + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + sTotal);
  System.out.println(""String_Node_Str"" + result.getGlobalOptimum().getMaximumInformationLoss().getValue());
  System.out.println(""String_Node_Str"");
  for (int i=0; i < qis.size(); i++) {
    System.out.println(""String_Node_Str"" + identifiers[i] + ""String_Node_Str""+ generalizations[i]);
  }
}","/** 
 * Prints the result
 * @param result
 * @param data
 */
protected static void printResult(final ARXResult result,final Data data){
  final DecimalFormat df1=new DecimalFormat(""String_Node_Str"");
  final String sTotal=df1.format(result.getTime() / 1000d) + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + sTotal);
  final ARXNode optimum=result.getGlobalOptimum();
  final List<String> qis=new ArrayList<String>(data.getDefinition().getQuasiIdentifyingAttributes());
  if (optimum == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  final StringBuffer[] identifiers=new StringBuffer[qis.size()];
  final StringBuffer[] generalizations=new StringBuffer[qis.size()];
  int lengthI=0;
  int lengthG=0;
  for (int i=0; i < qis.size(); i++) {
    identifiers[i]=new StringBuffer();
    generalizations[i]=new StringBuffer();
    identifiers[i].append(qis.get(i));
    generalizations[i].append(optimum.getGeneralization(qis.get(i))).append(""String_Node_Str"").append(data.getDefinition().getHierarchyHeight(qis.get(i)) - 1);
    lengthI=Math.max(lengthI,identifiers[i].length());
    lengthG=Math.max(lengthG,generalizations[i].length());
  }
  for (int i=0; i < qis.size(); i++) {
    while (identifiers[i].length() < lengthI) {
      identifiers[i].append(""String_Node_Str"");
    }
    while (generalizations[i].length() < lengthG) {
      generalizations[i].insert(0,""String_Node_Str"");
    }
  }
  System.out.println(""String_Node_Str"" + result.getGlobalOptimum().getMaximumInformationLoss().getValue());
  System.out.println(""String_Node_Str"");
  for (int i=0; i < qis.size(); i++) {
    System.out.println(""String_Node_Str"" + identifiers[i] + ""String_Node_Str""+ generalizations[i]);
  }
}",0.8596908442330559
109032,"/** 
 * Resets a lattice, i.e., it marks all anonymous transformations as ""not visited""
 * @param lattice
 */
private void reset(Lattice lattice){
  for (  Node[] level : lattice.getLevels()) {
    for (    Node node : level) {
      node.setNotTagged();
      node.setAnonymous(false);
      node.setKAnonymous(false);
    }
  }
}","/** 
 * Resets a lattice, i.e., it marks all anonymous transformations as ""not visited""
 * @param lattice
 */
private void reset(Lattice lattice){
  for (  Node[] level : lattice.getLevels()) {
    for (    Node node : level) {
      if (node.isAnonymous()) {
        node.setNotTagged();
        node.setNotChecked();
        node.setAnonymous(false);
        node.setKAnonymous(false);
      }
    }
  }
}",0.8970189701897019
109033,"/** 
 * Gets the handle.
 * @return the handle
 */
@Override public DataHandle getHandle(final ARXNode fnode){
  currentNode=fnode;
  if ((currentNode != null) && (currentNode == lastNode)) {
    return this;
  }
  lastNode=currentNode;
  final Node node=new Node(new IDGenerator());
  node.setTransformation(fnode.getTransformation(),0);
  if (currentNode.isChecked()) {
    node.setChecked();
  }
  checker.transformAndMarkOutliers(node);
  if (!currentNode.isChecked()) {
    currentNode.access().setChecked(true);
    if (node.isAnonymous()) {
      currentNode.access().setAnonymous();
    }
 else {
      currentNode.access().setNotAnonymous();
    }
    currentNode.access().setMaximumInformationLoss(node.getInformationLoss());
    currentNode.access().setMinimumInformationLoss(node.getInformationLoss());
    lattice.estimateInformationLoss();
  }
  createDataTypeArray();
  return this;
}","/** 
 * Gets the handle.
 * @return the handle
 */
@Override public DataHandle getHandle(final ARXNode fnode){
  currentNode=fnode;
  if ((currentNode != null) && (currentNode == lastNode)) {
    return this;
  }
  lastNode=currentNode;
  final Node node=new Node(0);
  node.setTransformation(fnode.getTransformation(),0);
  if (currentNode.isChecked()) {
    node.setChecked();
  }
  checker.transformAndMarkOutliers(node);
  if (!currentNode.isChecked()) {
    currentNode.access().setChecked(true);
    if (node.isAnonymous()) {
      currentNode.access().setAnonymous();
    }
 else {
      currentNode.access().setNotAnonymous();
    }
    currentNode.access().setMaximumInformationLoss(node.getInformationLoss());
    currentNode.access().setMinimumInformationLoss(node.getInformationLoss());
    lattice.estimateInformationLoss();
  }
  createDataTypeArray();
  return this;
}",0.98989898989899
109034,"@Override public void initialize(DataManager manager){
  bitset=new CompressedBitSet(manager.getDataQI().getDataLength());
  for (  Integer line : subset) {
    bitset.set(line);
  }
  this.subset=null;
}","@Override public void initialize(DataManager manager){
  bitset=new CompressedBitSet(manager.getDataQI().getDataLength());
  for (  Integer line : subset) {
    bitset.set(line);
  }
}",0.9484536082474226
109035,"/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultData subsetData=Data.create();
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DataSubset subset=DataSubset.create(data,subsetData);
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    Iterator<String[]> transformed=result.getHandle().iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
    System.out.println(""String_Node_Str"");
    transformed=result.getHandle().getContextSpecificView(config).iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultData subsetData=Data.create();
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subsetData.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DataSubset subset=DataSubset.create(data,subsetData);
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    System.out.println(""String_Node_Str"");
    print(data.getHandle().iterator());
    System.out.println(""String_Node_Str"");
    print(data.getHandle().getContextSpecificView(config).iterator());
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    print(result.getHandle().iterator());
    System.out.println(""String_Node_Str"");
    print(result.getHandle().getContextSpecificView(config).iterator());
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}",0.9510044096031356
109036,"/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  final DataSubset subset=DataSubset.create(data,selector);
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    Iterator<String[]> transformed=result.getHandle().iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
    System.out.println(""String_Node_Str"");
    transformed=result.getHandle().getContextSpecificView(config).iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DataSelector selector=DataSelector.create(data).field(""String_Node_Str"").equals(""String_Node_Str"");
  final DataSubset subset=DataSubset.create(data,selector);
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    System.out.println(""String_Node_Str"");
    print(data.getHandle().iterator());
    System.out.println(""String_Node_Str"");
    print(data.getHandle().getContextSpecificView(config).iterator());
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    print(result.getHandle().iterator());
    System.out.println(""String_Node_Str"");
    print(result.getHandle().getContextSpecificView(config).iterator());
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}",0.9445983379501384
109037,"/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DataSelector selector=DataSelector.create(data).begin().field(""String_Node_Str"").equals(""String_Node_Str"").and().field(""String_Node_Str"").equals(""String_Node_Str"").end().or().field(""String_Node_Str"").equals(""String_Node_Str"").or().field(""String_Node_Str"").equals(""String_Node_Str"").or().equals(""String_Node_Str"").or().equals(""String_Node_Str"").or().equals(""String_Node_Str"");
  final DataSubset subset=DataSubset.create(data,selector);
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    Iterator<String[]> transformed=result.getHandle().iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
    System.out.println(""String_Node_Str"");
    transformed=result.getHandle().getContextSpecificView(config).iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DataSelector selector=DataSelector.create(data).begin().field(""String_Node_Str"").equals(""String_Node_Str"").and().field(""String_Node_Str"").equals(""String_Node_Str"").end().or().field(""String_Node_Str"").equals(""String_Node_Str"").or().field(""String_Node_Str"").equals(""String_Node_Str"").or().equals(""String_Node_Str"").or().equals(""String_Node_Str"").or().equals(""String_Node_Str"");
  final DataSubset subset=DataSubset.create(data,selector);
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    System.out.println(""String_Node_Str"");
    print(data.getHandle().iterator());
    System.out.println(""String_Node_Str"");
    print(data.getHandle().getContextSpecificView(config).iterator());
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    print(result.getHandle().iterator());
    System.out.println(""String_Node_Str"");
    print(result.getHandle().getContextSpecificView(config).iterator());
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}",0.9472851871375856
109038,"/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DataSubset subset=DataSubset.create(data,new HashSet<Integer>(Arrays.asList(1,2,5,7,8)));
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    Iterator<String[]> transformed=result.getHandle().iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
    System.out.println(""String_Node_Str"");
    transformed=result.getHandle().getContextSpecificView(config).iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DataSubset subset=DataSubset.create(data,new HashSet<Integer>(Arrays.asList(1,2,5,7,8)));
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    System.out.println(""String_Node_Str"");
    print(data.getHandle().iterator());
    System.out.println(""String_Node_Str"");
    print(data.getHandle().getContextSpecificView(config).iterator());
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    print(result.getHandle().iterator());
    System.out.println(""String_Node_Str"");
    print(result.getHandle().getContextSpecificView(config).iterator());
  }
 catch (  final IllegalArgumentException e) {
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    throw new RuntimeException(e);
  }
}",0.9439357129508504
109039,"/** 
 * Creates a new handle that represents the research subset
 * @param source
 * @param subset
 */
public DataHandleSubset(DataHandle source,CompressedBitSet subset){
  this.source=source;
  ArrayList<Integer> list=new ArrayList<Integer>();
  for (int i=0; i < subset.getSize(); i++) {
    if (subset.get(i))     list.add(i);
  }
  this.subset=new int[list.size()];
  for (int i=0; i < list.size(); i++) {
    this.subset[i]=list.get(i);
  }
  createDataTypeArray();
}","/** 
 * Creates a new handle that represents the research subset
 * @param source
 * @param subset
 */
public DataHandleSubset(DataHandle source,CompressedBitSet subset){
  this.source=source;
  this.dataTypes=source.dataTypes;
  this.definition=source.definition;
  this.header=source.header;
  this.other=source.other;
  ArrayList<Integer> list=new ArrayList<Integer>();
  for (int i=0; i < subset.getSize(); i++) {
    if (subset.get(i))     list.add(i);
  }
  this.subset=new int[list.size()];
  for (int i=0; i < list.size(); i++) {
    this.subset[i]=list.get(i);
  }
  createDataTypeArray();
}",0.8805970149253731
109040,"@Override public boolean isAnonymous(HashGroupifyEntry entry){
  int[] buckets=entry.distribution.getBuckets();
  int totalElements=0;
  for (int i=0; i < buckets.length; i+=2) {
    if (buckets[i] != -1) {
      totalElements+=buckets[i + 1];
    }
  }
  double val=total;
  for (int i=0; i < buckets.length; i+=2) {
    if (buckets[i] != -1) {
      double frequency=distribution[buckets[i]];
      val+=Math.abs((frequency - ((double)buckets[i + 1] / (double)totalElements))) - frequency;
    }
  }
  val/=2;
  return val <= t;
}","@Override public boolean isAnonymous(HashGroupifyEntry entry){
  int[] buckets=entry.distribution.getBuckets();
  int totalElements=0;
  for (int i=0; i < buckets.length; i+=2) {
    if (buckets[i] != -1) {
      totalElements+=buckets[i + 1];
    }
  }
  double val=1.0d;
  for (int i=0; i < buckets.length; i+=2) {
    if (buckets[i] != -1) {
      double frequency=distribution[buckets[i]];
      val+=Math.abs((frequency - ((double)buckets[i + 1] / (double)totalElements))) - frequency;
    }
  }
  val/=2;
  return val <= t;
}",0.991533396048918
109041,"@Override public void initialize(DataManager manager){
  distribution=manager.getDistribution();
  total=manager.getDataQI().getDataLength();
}","@Override public void initialize(DataManager manager){
  distribution=manager.getDistribution();
}",0.8132780082987552
109042,"@Override public boolean isAnonymous(HashGroupifyEntry entry){
  int[] buckets=entry.distribution.getBuckets();
  int totalElements=0;
  for (int i=0; i < buckets.length; i+=2) {
    if (buckets[i] != -1) {
      totalElements+=buckets[i + 1];
    }
  }
  double val=0d;
  for (int i=0; i < buckets.length; i+=2) {
    if (buckets[i] != -1) {
      val+=Math.abs((distribution[buckets[i]] - ((double)buckets[i + 1] / (double)totalElements)));
    }
  }
  val/=2;
  return val <= t;
}","@Override public boolean isAnonymous(HashGroupifyEntry entry){
  int[] buckets=entry.distribution.getBuckets();
  int totalElements=0;
  for (int i=0; i < buckets.length; i+=2) {
    if (buckets[i] != -1) {
      totalElements+=buckets[i + 1];
    }
  }
  double val=total;
  for (int i=0; i < buckets.length; i+=2) {
    if (buckets[i] != -1) {
      double frequency=distribution[buckets[i]];
      val+=Math.abs((frequency - ((double)buckets[i + 1] / (double)totalElements))) - frequency;
    }
  }
  val/=2;
  return val <= t;
}",0.9004926108374385
109043,"@Override public void initialize(DataManager manager){
  distribution=manager.getDistribution();
}","@Override public void initialize(DataManager manager){
  distribution=manager.getDistribution();
  total=manager.getDataQI().getDataLength();
}",0.8132780082987552
109044,"/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final HashSet<Integer> subset=new HashSet<Integer>();
  subset.add(1);
  subset.add(2);
  subset.add(5);
  subset.add(7);
  subset.add(8);
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createPrecisionMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    final Iterator<String[]> transformed=result.getHandle().iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
  }
 catch (  final IllegalArgumentException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}","/** 
 * Entry point.
 * @param args the arguments
 */
public static void main(final String[] args){
  final DefaultData data=Data.create();
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final HashSet<Integer> subset=new HashSet<Integer>();
  subset.add(1);
  subset.add(2);
  subset.add(5);
  subset.add(7);
  subset.add(8);
  final DefaultHierarchy age=Hierarchy.create();
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  age.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy nationality=Hierarchy.create();
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  nationality.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final DefaultHierarchy zip=Hierarchy.create();
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  zip.add(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.IDENTIFYING_ATTRIBUTE);
  data.getDefinition().setAttributeType(""String_Node_Str"",zip);
  data.getDefinition().setAttributeType(""String_Node_Str"",age);
  data.getDefinition().setAttributeType(""String_Node_Str"",nationality);
  data.getDefinition().setAttributeType(""String_Node_Str"",AttributeType.INSENSITIVE_ATTRIBUTE);
  final ARXAnonymizer anonymizer=new ARXAnonymizer();
  final ARXConfiguration config=new ARXConfiguration();
  config.addCriterion(new KAnonymity(2));
  config.addCriterion(new DPresence(1d / 2d,2d / 3d,subset));
  config.setAllowedOutliers(0d);
  config.setMetric(Metric.createEntropyMetric());
  try {
    final ARXResult result=anonymizer.anonymize(data,config);
    printResult(result,data);
    System.out.println(""String_Node_Str"");
    final Iterator<String[]> transformed=result.getHandle().iterator();
    while (transformed.hasNext()) {
      System.out.print(""String_Node_Str"");
      System.out.println(Arrays.toString(transformed.next()));
    }
  }
 catch (  final IllegalArgumentException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
catch (  final IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
}",0.998475028593214
109045,"protected ARXResult anonymizeInternal(final DataHandle handle,final DataDefinition definition,final ARXConfiguration config) throws IOException {
  final DataManager manager=prepareDataManager(handle,definition,config);
  config.initialize(manager);
  final long time=System.currentTimeMillis();
  checkAfterEncoding(config,manager);
  final Lattice lattice=new LatticeBuilder(manager.getMaxLevels(),manager.getMinLevels(),manager.getHierachyHeights()).build();
  lattice.setListener(listener);
  final INodeChecker checker=new NodeChecker(manager,config.getMetric(),config,historySize,snapshotSizeDataset,snapshotSizeSnapshot);
  config.getMetric().initialize(manager.getDataQI(),manager.getHierarchies());
  final FLASHStrategy strategy=new FLASHStrategy(lattice,manager.getHierarchies());
  final AbstractAlgorithm algorithm=new FLASHAlgorithm(lattice,checker,strategy);
  algorithm.setListener(listener);
  algorithm.traverse();
  final Result result=new Result(config.getMetric(),checker,lattice);
  final DataHandleOutput outHandle=new DataHandleOutput(result.metric,manager,result.checker,System.currentTimeMillis() - time,suppressionString,handle.getDefinition(),result.lattice,removeOutliers,config);
  outHandle.associate(handle);
  handle.associate(outHandle);
  return outHandle;
}","protected ARXResult anonymizeInternal(final DataHandle handle,final DataDefinition definition,final ARXConfiguration config) throws IOException {
  final DataManager manager=prepareDataManager(handle,definition,config);
  config.initialize(manager);
  final long time=System.currentTimeMillis();
  checkAfterEncoding(config,manager);
  final Lattice lattice=new LatticeBuilder(manager.getMaxLevels(),manager.getMinLevels(),manager.getHierachyHeights()).build();
  lattice.setListener(listener);
  final INodeChecker checker=new NodeChecker(manager,config.getMetric(),config,historySize,snapshotSizeDataset,snapshotSizeSnapshot);
  config.getMetric().initialize(manager.getDataQI(),manager.getHierarchies(),config);
  final FLASHStrategy strategy=new FLASHStrategy(lattice,manager.getHierarchies());
  final AbstractAlgorithm algorithm=new FLASHAlgorithm(lattice,checker,strategy);
  algorithm.setListener(listener);
  algorithm.traverse();
  final Result result=new Result(config.getMetric(),checker,lattice);
  final DataHandleOutput outHandle=new DataHandleOutput(result.metric,manager,result.checker,System.currentTimeMillis() - time,suppressionString,handle.getDefinition(),result.lattice,removeOutliers,config);
  outHandle.associate(handle);
  handle.associate(outHandle);
  return outHandle;
}",0.9973004242190512
109046,"/** 
 * Returns all privacy criteria that are instances of the given class
 * @param clazz
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public <T extends PrivacyCriterion>Set<T> getCriteria(Class<T> clazz){
  Set<T> result=new HashSet<T>();
  for (  PrivacyCriterion c : criteria) {
    if (clazz.isInstance(c)) {
      result.add((T)c);
    }
  }
  if (result.isEmpty())   return null;
 else   return result;
}","/** 
 * Returns all privacy criteria that are instances of the given class
 * @param clazz
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public <T extends PrivacyCriterion>Set<T> getCriteria(Class<T> clazz){
  Set<T> result=new HashSet<T>();
  for (  PrivacyCriterion c : criteria) {
    if (clazz.isInstance(c)) {
      result.add((T)c);
    }
  }
  return result;
}",0.9102402022756004
109047,"/** 
 * For cloning
 * @param value
 * @param values
 */
private InformationLossCombined(final double value,final Map<Metric<?>,InformationLoss> values){
  super(value);
  this.values=values;
}","InformationLossCombined(final double value){
  super(value);
}",0.4862745098039215
109048,"/** 
 * Returns all criteria
 * @return
 */
public PrivacyCriterion[] getCriteria(){
  return this.criteria;
}","/** 
 * Returns all criteria.
 * @return
 */
public Set<PrivacyCriterion> getCriteria(){
  return this.criteria;
}",0.9642857142857144
109049,"/** 
 * Removes all criteria that are instances of the given class
 * @param clazz
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public <T extends PrivacyCriterion>boolean removeCriterion(Class<T> clazz){
  Set<T> toRemove=new HashSet<T>();
  for (  PrivacyCriterion c : criteria) {
    if (clazz.isInstance(c)) {
      toRemove.add((T)c);
    }
  }
  if (toRemove.isEmpty())   return false;
  int index=0;
  PrivacyCriterion[] temp=new PrivacyCriterion[criteria.length - toRemove.size()];
  for (  PrivacyCriterion c : criteria) {
    if (!toRemove.contains(c)) {
      temp[index++]=c;
    }
  }
  this.criteria=temp;
  return true;
}","/** 
 * Removes all criteria that are instances of the given class
 * @param clazz
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public <T extends PrivacyCriterion>boolean removeCriterion(Class<T> clazz){
  Set<T> toRemove=new HashSet<T>();
  for (  PrivacyCriterion c : criteria) {
    if (clazz.isInstance(c)) {
      toRemove.add((T)c);
    }
  }
  if (toRemove.isEmpty())   return false;
  criteria.removeAll(toRemove);
  return true;
}",0.7481617647058824
109050,"/** 
 * Adds a criterion to the configuration
 * @param c
 */
public ARXConfiguration addCriterion(PrivacyCriterion c){
  criteria=Arrays.copyOf(criteria,criteria.length + 1);
  criteria[criteria.length - 1]=c;
  return this;
}","/** 
 * Adds a criterion to the configuration
 * @param c
 */
public ARXConfiguration addCriterion(PrivacyCriterion c){
  criteria.add(c);
  return this;
}",0.7958115183246073
109051,"public ARXConfiguration clone(){
  throw new RuntimeException(""String_Node_Str"");
}","/** 
 * Clones this config
 */
public ARXConfiguration clone(){
  throw new RuntimeException(""String_Node_Str"");
}",0.8426395939086294
109052,"/** 
 * Initializes the configuration
 * @param manager
 */
protected void initialize(DataManager manager){
  this.requirements=0x0;
  for (  PrivacyCriterion c : criteria) {
    c.initialize(manager);
    this.requirements|=c.getRequirements();
  }
  absMaxOutliers=(int)Math.floor(this.relMaxOutliers * (double)manager.getDataQI().getDataLength());
  List<PrivacyCriterion> list=new ArrayList<PrivacyCriterion>();
  if (this.containsCriterion(DPresence.class)) {
    list.add(this.getCriterion(DPresence.class));
  }
  if (this.containsCriterion(LDiversity.class)) {
    list.add(this.getCriterion(LDiversity.class));
  }
  if (this.containsCriterion(TCloseness.class)) {
    list.add(this.getCriterion(TCloseness.class));
  }
  this.optimizedCriteria=list.toArray(new PrivacyCriterion[0]);
  if (this.containsCriterion(KAnonymity.class)) {
    list.add(0,this.getCriterion(KAnonymity.class));
    this.criteria=list.toArray(new PrivacyCriterion[0]);
  }
  this.snapshotLength=2;
  if (this.requires(REQUIREMENT_DISTRIBUTION)) {
    this.snapshotLength+=2;
  }
  if (this.requires(REQUIREMENT_SECONDARY_COUNTER)) {
    this.snapshotLength+=1;
  }
}","/** 
 * Initializes the configuration
 * @param manager
 */
protected void initialize(DataManager manager){
  if (criteria.isEmpty()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  this.requirements=0x0;
  for (  PrivacyCriterion c : criteria) {
    c.initialize(manager);
    this.requirements|=c.getRequirements();
  }
  absMaxOutliers=(int)Math.floor(this.relMaxOutliers * (double)manager.getDataQI().getDataLength());
  List<PrivacyCriterion> list=new ArrayList<PrivacyCriterion>();
  if (this.containsCriterion(DPresence.class)) {
    list.add(this.getCriterion(DPresence.class));
  }
  if (this.containsCriterion(LDiversity.class)) {
    list.add(this.getCriterion(LDiversity.class));
  }
  if (this.containsCriterion(TCloseness.class)) {
    list.add(this.getCriterion(TCloseness.class));
  }
  this.aCriteria=list.toArray(new PrivacyCriterion[0]);
  this.snapshotLength=2;
  if (this.requires(REQUIREMENT_DISTRIBUTION)) {
    this.snapshotLength+=2;
  }
  if (this.requires(REQUIREMENT_SECONDARY_COUNTER)) {
    this.snapshotLength+=1;
  }
}",0.8837630031659882
109053,"/** 
 * Creates a new instance of the ARX algorithm.
 * @param lattice The lattice
 * @param history The history
 * @param checker The checker
 * @param metric The metric
 */
public FLASHAlgorithm(final Lattice lattice,final INodeChecker checker,final FLASHStrategy metric){
  super(lattice,checker);
  strategy=metric;
  pqueue=new PriorityQueue<Node>(11,strategy);
  sorted=new boolean[lattice.getSize()];
  path=new ArrayList<Node>();
  stack=new Stack<Node>();
  this.history=checker.getHistory();
  if ((checker.getConfiguration().getAbsoluteMaxOutliers() == 0) || (checker.getConfiguration().isCriterionMonotonic() && checker.getMetric().isMonotonic()) || (checker.getConfiguration().isPracticalMonotonicity())) {
    traverseType=TraverseType.FIRST_PHASE_ONLY;
    history.setPruningStrategy(PruningStrategy.ANONYMOUS);
  }
 else {
    if (checker.getConfiguration().containsCriterion(KAnonymity.class)) {
      traverseType=TraverseType.FIRST_AND_SECOND_PHASE;
      history.setPruningStrategy(PruningStrategy.K_ANONYMOUS);
    }
 else {
      traverseType=TraverseType.SECOND_PHASE_ONLY;
      history.setPruningStrategy(PruningStrategy.CHECKED);
    }
  }
}","/** 
 * Creates a new instance of the ARX algorithm.
 * @param lattice The lattice
 * @param history The history
 * @param checker The checker
 * @param metric The metric
 */
public FLASHAlgorithm(final Lattice lattice,final INodeChecker checker,final FLASHStrategy metric){
  super(lattice,checker);
  strategy=metric;
  pqueue=new PriorityQueue<Node>(11,strategy);
  sorted=new boolean[lattice.getSize()];
  path=new ArrayList<Node>();
  stack=new Stack<Node>();
  this.history=checker.getHistory();
  if ((checker.getConfiguration().getAbsoluteMaxOutliers() == 0) || (checker.getConfiguration().isCriterionMonotonic() && checker.getMetric().isMonotonic()) || (checker.getConfiguration().isPracticalMonotonicity())) {
    traverseType=TraverseType.FIRST_PHASE_ONLY;
    history.setPruningStrategy(PruningStrategy.ANONYMOUS);
  }
 else {
    if (checker.getConfiguration().getMinimalGroupSize() != Integer.MAX_VALUE) {
      traverseType=TraverseType.FIRST_AND_SECOND_PHASE;
      history.setPruningStrategy(PruningStrategy.K_ANONYMOUS);
    }
 else {
      traverseType=TraverseType.SECOND_PHASE_ONLY;
      history.setPruningStrategy(PruningStrategy.CHECKED);
    }
  }
}",0.9679624092268262
109054,"@Override public boolean isAnonymous(HashGroupifyEntry entry){
  return entry.count >= k;
}","@Override public boolean isAnonymous(HashGroupifyEntry entry){
  throw new RuntimeException(""String_Node_Str"");
}",0.7254901960784313
109055,"/** 
 * Checks whether the given entry is anonymous
 * @param entry
 * @return
 */
private boolean isAnonymous(HashGroupifyEntry entry){
  for (int i=0; i < criteria.length; i++) {
    if (!criteria[i].isAnonymous(entry)) {
      return false;
    }
  }
  return true;
}","/** 
 * Checks whether the given entry is anonymous
 * @param entry
 * @return
 */
private boolean isAnonymous(HashGroupifyEntry entry){
  if (k != Integer.MAX_VALUE && entry.count < k) {
    return false;
  }
  for (int i=0; i < criteria.length; i++) {
    if (!criteria[i].isAnonymous(entry)) {
      return false;
    }
  }
  return true;
}",0.8809135399673735
109056,"/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(KAnonymity.class)) {
    k=config.getCriterion(KAnonymity.class).getK();
  }
 else {
    k=Integer.MAX_VALUE;
  }
  if (config.containsCriterion(DPresence.class)) {
    subset=config.getCriterion(DPresence.class).getResearchSubset();
  }
 else {
    subset=null;
  }
  criteria=config.getCriteria();
  criteriaIgnoreKAnonymity=config.getCriteriaIgnoreKAnonymity();
  if (config.containsCriterion(KAnonymity.class)) {
    if (config.getCriteria().length == 1) {
      this.isOnlyKAnonymity=true;
      this.containsKAnonymity=false;
    }
 else {
      this.isOnlyKAnonymity=false;
      this.containsKAnonymity=true;
    }
  }
 else {
    this.isOnlyKAnonymity=false;
    this.containsKAnonymity=false;
  }
}","/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(DPresence.class)) {
    subset=config.getCriterion(DPresence.class).getResearchSubset();
  }
 else {
    subset=null;
  }
  criteria=config.getCriteriaAsArray();
  k=config.getMinimalGroupSize();
}",0.6856240126382307
109057,"@Override public void addGroupify(int[] key,int representant,int count,Distribution distribution,int pcount){
  final HashGroupifyEntry entry=addInternal(key,representant,count,pcount);
  if (distribution != null) {
    if (entry.distribution == null) {
      entry.distribution=distribution;
    }
    entry.distribution.merge(distribution);
  }
}","@Override public void addGroupify(int[] key,int representant,int count,Distribution distribution,int pcount){
  final HashGroupifyEntry entry=addInternal(key,representant,count,pcount);
  if (distribution != null) {
    if (entry.distribution == null) {
      entry.distribution=distribution;
    }
 else {
      entry.distribution.merge(distribution);
    }
  }
}",0.9775280898876404
109058,"@Override public void addSnapshot(int[] key,int representant,int count,int[] elements,int[] frequencies,int pcount){
  final HashGroupifyEntry entry=addInternal(key,representant,count,pcount);
  if (elements != null) {
    if (entry.distribution == null) {
      entry.distribution=new Distribution(elements,frequencies);
    }
    entry.distribution.merge(elements,frequencies);
  }
}","@Override public void addSnapshot(int[] key,int representant,int count,int[] elements,int[] frequencies,int pcount){
  final HashGroupifyEntry entry=addInternal(key,representant,count,pcount);
  if (elements != null) {
    if (entry.distribution == null) {
      entry.distribution=new Distribution(elements,frequencies);
    }
 else {
      entry.distribution.merge(elements,frequencies);
    }
  }
}",0.979643765903308
109059,"/** 
 * Checks whether an equivalence class is anonymous
 * @param entry
 * @return
 */
private boolean isAnonymous(final HashGroupifyEntry entry){
switch (config.getCriterion()) {
case L_DIVERSITY:
switch (config.getLDiversityCriterion()) {
case RECURSIVE:
      return entry.distribution.isRecursiveCLDiverse(ldivC,k);
case DISTINCT:
    return entry.distribution.isDistinctLDiverse(k);
case ENTROPY:
  return entry.distribution.isEntropyLDiverse(logL,k);
default :
throw new UnsupportedOperationException(config.getLDiversityCriterion() + ""String_Node_Str"");
}
case T_CLOSENESS:
switch (config.getTClosenessCriterion()) {
case EMD_EQUAL:
return entry.distribution.isTCloseEqualDist(tcloseT,tCloseInitialDistribution);
case EMD_HIERARCHICAL:
System.arraycopy(tCloseEmpty,0,tCloseTree,tCloseExtraStart,tCloseEmpty.length);
return entry.distribution.isTCloseHierachical(tcloseT,tCloseTree);
default :
throw new UnsupportedOperationException(config.getLDiversityCriterion() + ""String_Node_Str"");
}
case K_ANONYMITY:
return entry.count >= k;
case D_PRESENCE:
if (entry.count > 0) {
double dCurrent=(double)entry.count / (double)entry.pcount;
return (dCurrent >= dMin) && (dCurrent <= dMax);
}
 else {
return true;
}
default :
throw new UnsupportedOperationException(config.getLDiversityCriterion() + ""String_Node_Str"");
}
}","/** 
 * Checks whether an equivalence class is anonymous
 * @param entry
 * @return
 */
private boolean isAnonymous(final HashGroupifyEntry entry){
switch (config.getCriterion()) {
case L_DIVERSITY:
switch (config.getLDiversityCriterion()) {
case RECURSIVE:
      return entry.distribution.isRecursiveCLDiverse(ldivC,k);
case DISTINCT:
    return entry.distribution.isDistinctLDiverse(k);
case ENTROPY:
  return entry.distribution.isEntropyLDiverse(logL,k);
default :
throw new UnsupportedOperationException(config.getLDiversityCriterion() + ""String_Node_Str"");
}
case T_CLOSENESS:
if (entry.count < k) {
return false;
}
switch (config.getTClosenessCriterion()) {
case EMD_EQUAL:
return entry.distribution.isTCloseEqualDist(tcloseT,tCloseInitialDistribution);
case EMD_HIERARCHICAL:
System.arraycopy(tCloseEmpty,0,tCloseTree,tCloseExtraStart,tCloseEmpty.length);
return entry.distribution.isTCloseHierachical(tcloseT,tCloseTree);
default :
throw new UnsupportedOperationException(config.getLDiversityCriterion() + ""String_Node_Str"");
}
case K_ANONYMITY:
return entry.count >= k;
case D_PRESENCE:
if (entry.count > 0) {
double dCurrent=(double)entry.count / (double)entry.pcount;
return (dCurrent >= dMin) && (dCurrent <= dMax);
}
 else {
return true;
}
default :
throw new UnsupportedOperationException(config.getLDiversityCriterion() + ""String_Node_Str"");
}
}",0.9854531891085416
109060,"/** 
 * Removes a snapshot
 * @param node
 */
private final void removeHistoryEntry(final Node node){
  final int[] snapshot=nodeToSnapshot.remove(node);
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
    for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
      dictionarySensValue.decrementRefCount(snapshot[i + 3]);
      dictionarySensFreq.decrementRefCount(snapshot[i + 4]);
    }
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
  dictionarySensValue.decrementRefCount(snapshot[i + 2]);
  dictionarySensFreq.decrementRefCount(snapshot[i + 3]);
}
}
}","/** 
 * Removes a snapshot
 * @param node
 */
private final void removeHistoryEntry(final Node node){
  final int[] snapshot=nodeToSnapshot.remove(node);
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
    for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
      dictionarySensValue.decrementRefCount(snapshot[i + 3]);
      dictionarySensFreq.decrementRefCount(snapshot[i + 4]);
    }
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
  dictionarySensValue.decrementRefCount(snapshot[i + 2]);
  dictionarySensFreq.decrementRefCount(snapshot[i + 3]);
}
}
}",0.970838396111786
109061,"/** 
 * Creates a new NodeChecker instance.
 * @param manager The manager
 * @param metric The metric
 * @param config The anonymization configuration
 * @param historyMaxSize The history max size
 * @param snapshotSizeDataset The history threshold
 * @param snapshotSizeSnapshot The history threshold replacement
 */
public NodeChecker(final DataManager manager,final Metric<?> metric,final ARXConfiguration config,final int historyMaxSize,final double snapshotSizeDataset,final double snapshotSizeSnapshot){
  this.metric=metric;
  this.config=config;
  data=manager.getDataQI();
  final int initialSize=(int)(manager.getDataQI().getDataLength() * 0.01d);
  final IntArrayDictionary dictionarySensValue;
  final IntArrayDictionary dictionarySensFreq;
  if (config.containsCriterion(TCloseness.class)) {
    dictionarySensValue=new IntArrayDictionary(initialSize);
    dictionarySensFreq=new IntArrayDictionary(initialSize);
  }
 else {
    dictionarySensValue=new IntArrayDictionary(0);
    dictionarySensFreq=new IntArrayDictionary(0);
  }
  history=new History(manager.getDataQI().getArray().length,historyMaxSize,snapshotSizeDataset,snapshotSizeSnapshot,config,dictionarySensValue,dictionarySensFreq);
  stateMachine=new StateMachine(history);
  currentGroupify=new HashGroupify(initialSize,config);
  lastGroupify=new HashGroupify(initialSize,config);
  transformer=new Transformer(manager.getDataQI().getArray(),manager.getHierarchies(),manager.getDataSE().getArray(),config,dictionarySensValue,dictionarySensFreq);
}","/** 
 * Creates a new NodeChecker instance.
 * @param manager The manager
 * @param metric The metric
 * @param config The anonymization configuration
 * @param historyMaxSize The history max size
 * @param snapshotSizeDataset The history threshold
 * @param snapshotSizeSnapshot The history threshold replacement
 */
public NodeChecker(final DataManager manager,final Metric<?> metric,final ARXConfiguration config,final int historyMaxSize,final double snapshotSizeDataset,final double snapshotSizeSnapshot){
  this.metric=metric;
  this.config=config;
  data=manager.getDataQI();
  final int initialSize=(int)(manager.getDataQI().getDataLength() * 0.01d);
  final IntArrayDictionary dictionarySensValue;
  final IntArrayDictionary dictionarySensFreq;
  if ((config.getRequirements() & ARXConfiguration.REQUIREMENT_DISTRIBUTION) != 0) {
    dictionarySensValue=new IntArrayDictionary(initialSize);
    dictionarySensFreq=new IntArrayDictionary(initialSize);
  }
 else {
    dictionarySensValue=new IntArrayDictionary(0);
    dictionarySensFreq=new IntArrayDictionary(0);
  }
  history=new History(manager.getDataQI().getArray().length,historyMaxSize,snapshotSizeDataset,snapshotSizeSnapshot,config,dictionarySensValue,dictionarySensFreq);
  stateMachine=new StateMachine(history);
  currentGroupify=new HashGroupify(initialSize,config);
  lastGroupify=new HashGroupify(initialSize,config);
  transformer=new Transformer(manager.getDataQI().getArray(),manager.getHierarchies(),manager.getDataSE().getArray(),config,dictionarySensValue,dictionarySensFreq);
}",0.9633235962349886
109062,"@Override public void addGroupify(int[] key,int representant,int count,Distribution distribution,int pcount){
  final int hash=HashTableUtil.hashcode(key);
  final HashGroupifyEntry entry;
  if (subset != null && subset.get(representant)) {
    entry=addInternal(key,representant,count,hash,pcount);
  }
 else {
    entry=addInternal(key,representant,0,hash,pcount);
  }
  if (distribution != null) {
    if (entry.distribution == null) {
      entry.distribution=distribution;
    }
    entry.distribution.merge(distribution);
  }
}","@Override public void addGroupify(int[] key,int representant,int count,Distribution distribution,int pcount){
  final HashGroupifyEntry entry=addInternal(key,representant,count,pcount);
  if (distribution != null) {
    if (entry.distribution == null) {
      entry.distribution=distribution;
    }
    entry.distribution.merge(distribution);
  }
}",0.6923950056753689
109063,"@Override public void addSnapshot(int[] key,int representant,int count,int[] elements,int[] frequencies,int pcount){
  final int hash=HashTableUtil.hashcode(key);
  final HashGroupifyEntry entry;
  if (subset != null && subset.get(representant)) {
    entry=addInternal(key,representant,count,hash,pcount);
  }
 else {
    entry=addInternal(key,representant,0,hash,pcount);
  }
  if (elements != null) {
    if (entry.distribution == null) {
      entry.distribution=new Distribution(elements,frequencies);
    }
    entry.distribution.merge(elements,frequencies);
  }
}","@Override public void addSnapshot(int[] key,int representant,int count,int[] elements,int[] frequencies,int pcount){
  final HashGroupifyEntry entry=addInternal(key,representant,count,pcount);
  if (elements != null) {
    if (entry.distribution == null) {
      entry.distribution=new Distribution(elements,frequencies);
    }
    entry.distribution.merge(elements,frequencies);
  }
}",0.3664921465968586
109064,"/** 
 * Internal adder method.
 * @param key the key
 * @param line the line
 * @param value the value
 * @param hash the hash
 * @return the hash groupify entry
 */
private final HashGroupifyEntry addInternal(final int[] key,final int line,final int value,final int hash,final int pvalue){
  int index=hash & (buckets.length - 1);
  HashGroupifyEntry entry=findEntry(key,index,hash);
  if (entry == null) {
    if (++elementCount > threshold) {
      rehash();
      index=hash & (buckets.length - 1);
    }
    entry=createEntry(key,index,hash,line);
  }
  entry.count+=value;
  if (subset != null) {
    entry.pcount+=pvalue;
    if (value > 0) {
      entry.representant=line;
    }
  }
  if (entry.count >= k) {
    if (!entry.isNotOutlier) {
      entry.isNotOutlier=true;
      currentOutliers-=(entry.count - value);
    }
  }
 else {
    currentOutliers+=value;
  }
  return entry;
}","/** 
 * Internal adder method.
 * @param key the key
 * @param line the line
 * @param value the value
 * @param hash the hash
 * @return the hash groupify entry
 */
private final HashGroupifyEntry addInternal(final int[] key,final int representant,int count,final int pcount){
  final int hash=HashTableUtil.hashcode(key);
  if (subset != null && !subset.get(representant)) {
    count=0;
  }
  int index=hash & (buckets.length - 1);
  HashGroupifyEntry entry=findEntry(key,index,hash);
  if (entry == null) {
    if (++elementCount > threshold) {
      rehash();
      index=hash & (buckets.length - 1);
    }
    entry=createEntry(key,index,hash,representant);
  }
  entry.count+=count;
  if (subset != null) {
    entry.pcount+=pcount;
    if (count > 0) {
      entry.representant=representant;
    }
  }
  if (entry.count >= k) {
    if (!entry.isNotOutlier) {
      entry.isNotOutlier=true;
      currentOutliers-=(entry.count - count);
    }
  }
 else {
    currentOutliers+=count;
  }
  return entry;
}",0.8502364687335786
109065,"@Override public void addAll(int[] key,int representant,int count,int sensitive,int pcount){
  final int hash=HashTableUtil.hashcode(key);
  final HashGroupifyEntry entry;
  if (subset != null && subset.get(representant)) {
    entry=addInternal(key,representant,count,hash,pcount);
  }
 else {
    entry=addInternal(key,representant,0,hash,pcount);
  }
  if (sensitive != -1) {
    if (entry.distribution == null) {
      entry.distribution=new Distribution();
    }
    entry.distribution.add(sensitive);
  }
}","@Override public void addAll(int[] key,int representant,int count,int sensitive,int pcount){
  final HashGroupifyEntry entry=addInternal(key,representant,count,pcount);
  if (sensitive != -1) {
    if (entry.distribution == null) {
      entry.distribution=new Distribution();
    }
    entry.distribution.add(sensitive);
  }
}",0.6769964243146603
109066,"/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.config=config;
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(KAnonymity.class)) {
    k=config.getCriterion(KAnonymity.class).getK();
  }
 else {
    k=Integer.MAX_VALUE;
  }
  if (config.containsCriterion(DPresence.class)) {
    subset=config.getCriterion(DPresence.class).getResearchSubset();
  }
 else {
    subset=null;
  }
  criteria=config.getCriteria();
  criteriaIgnoreKAnonymity=config.getCriteriaIgnoreKAnonymity();
}","/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(KAnonymity.class)) {
    k=config.getCriterion(KAnonymity.class).getK();
  }
 else {
    k=Integer.MAX_VALUE;
  }
  if (config.containsCriterion(DPresence.class)) {
    subset=config.getCriterion(DPresence.class).getResearchSubset();
  }
 else {
    subset=null;
  }
  criteria=config.getCriteria();
  criteriaIgnoreKAnonymity=config.getCriteriaIgnoreKAnonymity();
  if (config.containsCriterion(KAnonymity.class)) {
    if (config.getCriteria().length == 1) {
      this.isOnlyKAnonymity=true;
      this.containsKAnonymity=false;
    }
 else {
      this.isOnlyKAnonymity=false;
      this.containsKAnonymity=true;
    }
  }
 else {
    this.isOnlyKAnonymity=false;
    this.containsKAnonymity=false;
  }
}",0.8258373205741627
109067,"/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.config=config;
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(KAnonymity.class)) {
    k=config.getCriteria(KAnonymity.class)[0].getK();
  }
 else {
    k=Integer.MAX_VALUE;
  }
  if (config.containsCriterion(DPresence.class)) {
    subset=config.getCriteria(DPresence.class)[0].getResearchSubset();
  }
 else {
    subset=null;
  }
}","/** 
 * Constructs a new hash groupify operator
 * @param capacity The capacity
 * @param config The config
 */
public HashGroupify(int capacity,final ARXConfiguration config){
  capacity=HashTableUtil.calculateCapacity(capacity);
  this.elementCount=0;
  this.buckets=new HashGroupifyEntry[capacity];
  this.threshold=HashTableUtil.calculateThreshold(buckets.length,loadFactor);
  this.config=config;
  this.currentOutliers=0;
  this.absoluteMaxOutliers=config.getAbsoluteMaxOutliers();
  if (config.containsCriterion(KAnonymity.class)) {
    k=config.getCriteria(KAnonymity.class).iterator().next().getK();
  }
 else {
    k=Integer.MAX_VALUE;
  }
  if (config.containsCriterion(DPresence.class)) {
    subset=config.getCriteria(DPresence.class).iterator().next().getResearchSubset();
  }
 else {
    subset=null;
  }
}",0.9739454094292804
109068,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9971762807583704
109069,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9970174691095016
109070,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9959700633275764
109071,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9973149213655544
109072,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9971717171717172
109073,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9962466487935656
109074,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9974405850091408
109075,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.997310795236266
109076,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9964877069744104
109077,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9975550122249388
109078,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.997436836323691
109079,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9966996699669968
109080,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9976596456034772
109081,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9975515914655474
109082,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9968875055580256
109083,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.997755690926579
109084,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9976565115500502
109085,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9970551114850652
109086,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.997844163843548
109087,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.997752808988764
109088,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9972055888223552
109089,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.997925925925926
109090,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9978415047795252
109091,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9973414356247626
109092,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9980017128175848
109093,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9979234648472264
109094,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9974646867077146
109095,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9980721564307352
109096,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9979994284081166
109097,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9975770162686052
109098,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9981417573666048
109099,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9980742778541952
109100,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9976859504132232
109101,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9982065078145016
109102,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.998143728453991
109103,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9977855109142676
109104,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9982668977469672
109105,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9982083439979524
109106,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9978768577494692
109107,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
    outtuple[outindex13]=idindex13[intuple[index13]][stateindex13];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
    outtuple[outindex13]=idindex13[intuple[index13]][stateindex13];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9983233532934132
109108,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
    outtuple[outindex13]=idindex13[intuple[index13]][stateindex13];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
    outtuple[outindex13]=idindex13[intuple[index13]][stateindex13];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9982686124165224
109109,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
    outtuple[outindex13]=idindex13[intuple[index13]][stateindex13];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
    outtuple[outindex3]=idindex3[intuple[index3]][stateindex3];
    outtuple[outindex4]=idindex4[intuple[index4]][stateindex4];
    outtuple[outindex5]=idindex5[intuple[index5]][stateindex5];
    outtuple[outindex6]=idindex6[intuple[index6]][stateindex6];
    outtuple[outindex7]=idindex7[intuple[index7]][stateindex7];
    outtuple[outindex8]=idindex8[intuple[index8]][stateindex8];
    outtuple[outindex9]=idindex9[intuple[index9]][stateindex9];
    outtuple[outindex10]=idindex10[intuple[index10]][stateindex10];
    outtuple[outindex11]=idindex11[intuple[index11]][stateindex11];
    outtuple[outindex12]=idindex12[intuple[index12]][stateindex12];
    outtuple[outindex13]=idindex13[intuple[index13]][stateindex13];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9979609670841828
109110,"/** 
 * Creates a generic snapshot for all criteria
 * @param g the g
 * @return the int[]
 */
private final int[] createSnapshot(final IHashGroupify g){
  final int[] data=new int[g.size() * config.getSnapshotLength()];
  int index=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    data[index]=m.representant;
    data[index + 1]=m.count;
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
    data[index + 2]=m.pcount;
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
data[index + 2]=m.pcount;
Distribution fSet=m.distribution;
fSet.pack();
data[index + 3]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 4]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
fSet=m.distribution;
fSet.pack();
data[index + 2]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 3]=dictionarySensFreq.probe(fSet.getPackedFrequency());
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
index+=config.getSnapshotLength();
m=m.nextOrdered;
}
return data;
}","/** 
 * Creates a generic snapshot for all criteria
 * @param g the g
 * @return the int[]
 */
private final int[] createSnapshot(final IHashGroupify g){
  final int[] data=new int[g.size() * config.getSnapshotLength()];
  int index=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    data[index]=m.representant;
    data[index + 1]=m.count;
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
    data[index + 2]=m.pcount;
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
data[index + 2]=m.pcount;
Distribution fSet=m.distribution;
fSet.pack();
data[index + 3]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 4]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
fSet=m.distribution;
fSet.pack();
data[index + 2]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 3]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
index+=config.getSnapshotLength();
m=m.nextOrdered;
}
return data;
}",0.9973674313651748
109111,"/** 
 * Creates a generic snapshot for all criteria
 * @param g the g
 * @return the int[]
 */
private final int[] createSnapshot(final IHashGroupify g){
  final int[] data=new int[g.size() * config.getSnapshotLength()];
  int index=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    data[index]=m.representant;
    data[index + 1]=m.count;
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
    data[index + 2]=m.pcount;
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
data[index + 2]=m.pcount;
Distribution fSet=m.distribution;
fSet.pack();
data[index + 3]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 4]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
fSet=m.distribution;
fSet.pack();
data[index + 2]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 3]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
index+=config.getSnapshotLength();
m=m.nextOrdered;
}
return data;
}","/** 
 * Creates a generic snapshot for all criteria
 * @param g the g
 * @return the int[]
 */
private final int[] createSnapshot(final IHashGroupify g){
  final int[] data=new int[g.size() * config.getSnapshotLength()];
  int index=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    data[index]=m.representant;
    data[index + 1]=m.count;
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
    data[index + 2]=m.pcount;
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
data[index + 2]=m.pcount;
Distribution fSet=m.distribution;
fSet.pack();
data[index + 3]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 4]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
fSet=m.distribution;
fSet.pack();
data[index + 2]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 3]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
index+=config.getSnapshotLength();
m=m.nextOrdered;
}
return data;
}",0.9823139277818718
109112,"/** 
 * Instantiates a new abstract transformer.
 * @param data the data
 * @param hierarchies the hierarchies
 */
public AbstractTransformer(final int[][] data,final GeneralizationHierarchy[] hierarchies,final int[] sensitiveValues,final IntArrayDictionary dictionarySensValue,final IntArrayDictionary dictionarySensFreq,final ARXConfiguration config){
  this.config=config;
  this.data=data;
  this.hierarchies=hierarchies;
  this.sensitiveValues=sensitiveValues;
  this.dictionarySensValue=dictionarySensValue;
  this.dictionarySensFreq=dictionarySensFreq;
  this.ssStepWidth=config.getSnapshotLength();
  this.requirements=config.getRequirements();
  dimensions=data[0].length;
  int arraySizes=15;
  if (dimensions > arraySizes) {
    arraySizes=dimensions;
  }
  stateIndexArray=new int[arraySizes];
  columnIndexArray=new int[arraySizes];
  columnMapArray=new int[arraySizes][][];
  map=new int[hierarchies.length][][];
  for (int i=0; i < hierarchies.length; i++) {
    map[i]=hierarchies[i].getArray();
  }
}","/** 
 * Instantiates a new abstract transformer.
 * @param data the data
 * @param hierarchies the hierarchies
 */
public AbstractTransformer(final int[][] data,final GeneralizationHierarchy[] hierarchies,final int[] sensitiveValues,final IntArrayDictionary dictionarySensValue,final IntArrayDictionary dictionarySensFreq,final ARXConfiguration config){
  this.config=config;
  this.data=data;
  this.hierarchies=hierarchies;
  this.sensitiveValues=sensitiveValues;
  this.dictionarySensValue=dictionarySensValue;
  this.dictionarySensFreq=dictionarySensFreq;
  ssStepWidth=config.getSnapshotLength();
  requirements=config.getRequirements();
  dimensions=data[0].length;
  int arraySizes=15;
  if (dimensions > arraySizes) {
    arraySizes=dimensions;
  }
  stateIndexArray=new int[arraySizes];
  columnIndexArray=new int[arraySizes];
  columnMapArray=new int[arraySizes][][];
  map=new int[hierarchies.length][][];
  for (int i=0; i < hierarchies.length; i++) {
    map[i]=hierarchies[i].getArray();
  }
}",0.9950592885375494
109113,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9810576164167324
109114,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9800166527893422
109115,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9732142857142856
109116,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.981968444778362
109117,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.9810276679841896
109118,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.975
109119,"@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processSnapshot(){
  startIndex*=ssStepWidth;
  stopIndex*=ssStepWidth;
  for (int i=startIndex; i < stopIndex; i+=ssStepWidth) {
    intuple=data[snapshot[i]];
    outtuple=buffer[snapshot[i]];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],null,null,snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 3]),dictionarySensFreq.get(snapshot[i + 4]),snapshot[i + 2]);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addSnapshot(outtuple,snapshot[i],snapshot[i + 1],dictionarySensValue.get(snapshot[i + 2]),dictionarySensFreq.get(snapshot[i + 3]),-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9827956989247312
109120,"@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}","@Override protected void processGroupify(){
  int processed=0;
  while (element != null) {
    intuple=data[element.representant];
    outtuple=buffer[element.representant];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addGroupify(outtuple,element.representant,element.count,null,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addGroupify(outtuple,element.representant,element.count,null,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,element.pcount);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addGroupify(outtuple,element.representant,element.count,element.distribution,-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
processed++;
if (processed == numElements) {
return;
}
element=element.nextOrdered;
}
}",0.981941309255079
109121,"@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}","@Override protected void processAll(){
  for (int i=startIndex; i < stopIndex; i++) {
    intuple=data[i];
    outtuple=buffer[i];
    outtuple[outindex0]=idindex0[intuple[index0]][stateindex0];
    outtuple[outindex1]=idindex1[intuple[index1]][stateindex1];
    outtuple[outindex2]=idindex2[intuple[index2]][stateindex2];
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      groupify.addAll(outtuple,i,1,-1,-1);
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
  groupify.addAll(outtuple,i,1,-1,1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],1);
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
case ARXConfiguration.REQUIREMENT_DISTRIBUTION:
groupify.addAll(outtuple,i,1,sensitiveValues[i],-1);
break;
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}
}",0.9765625
109122,"/** 
 * Removes a snapshot
 * @param node
 */
private final void removeHistoryEntry(final Node node){
  final int[] snapshot=nodeToSnapshot.remove(node);
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
    for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
      dictionarySensValue.decrementRefCount(snapshot[i + 3]);
      dictionarySensFreq.decrementRefCount(snapshot[i + 4]);
    }
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
  dictionarySensValue.decrementRefCount(snapshot[i + 2]);
  dictionarySensFreq.decrementRefCount(snapshot[i + 3]);
}
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
}","/** 
 * Removes a snapshot
 * @param node
 */
private final void removeHistoryEntry(final Node node){
  final int[] snapshot=nodeToSnapshot.remove(node);
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
    for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
      dictionarySensValue.decrementRefCount(snapshot[i + 3]);
      dictionarySensFreq.decrementRefCount(snapshot[i + 4]);
    }
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
for (int i=0; i < snapshot.length; i+=config.getSnapshotLength()) {
  dictionarySensValue.decrementRefCount(snapshot[i + 2]);
  dictionarySensFreq.decrementRefCount(snapshot[i + 3]);
}
}
}",0.9568862275449102
109123,"/** 
 * Creates a generic snapshot for all criteria
 * @param g the g
 * @return the int[]
 */
private final int[] createSnapshot(final IHashGroupify g){
  final int[] data=new int[g.size() * config.getSnapshotLength()];
  int index=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    data[index]=m.representant;
    data[index + 1]=m.count;
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
      data[index + 2]=m.pcount;
    break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
  data[index + 2]=m.pcount;
Distribution fSet=m.distribution;
fSet.pack();
data[index + 3]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 4]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
fSet=m.distribution;
fSet.pack();
data[index + 2]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 3]=dictionarySensFreq.probe(fSet.getPackedFrequency());
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
index+=config.getSnapshotLength();
m=m.nextOrdered;
}
return data;
}","/** 
 * Creates a generic snapshot for all criteria
 * @param g the g
 * @return the int[]
 */
private final int[] createSnapshot(final IHashGroupify g){
  final int[] data=new int[g.size() * config.getSnapshotLength()];
  int index=0;
  HashGroupifyEntry m=g.getFirstEntry();
  while (m != null) {
    data[index]=m.representant;
    data[index + 1]=m.count;
switch (requirements) {
case ARXConfiguration.REQUIREMENT_COUNTER:
      break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER:
    data[index + 2]=m.pcount;
  break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_SECONDARY_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
data[index + 2]=m.pcount;
Distribution fSet=m.distribution;
fSet.pack();
data[index + 3]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 4]=dictionarySensFreq.probe(fSet.getPackedFrequency());
break;
case ARXConfiguration.REQUIREMENT_COUNTER | ARXConfiguration.REQUIREMENT_DISTRIBUTION:
fSet=m.distribution;
fSet.pack();
data[index + 2]=dictionarySensValue.probe(fSet.getPackedElements());
data[index + 3]=dictionarySensFreq.probe(fSet.getPackedFrequency());
default :
throw new RuntimeException(""String_Node_Str"" + requirements);
}
index+=config.getSnapshotLength();
m=m.nextOrdered;
}
return data;
}",0.9761721752498078
109124,"/** 
 * Returns a sorted array of integer docIds given the corresponding key.
 * @param docIdsKey The lookup key.
 * @return Not null
 */
protected DocsEnum lookupDocIds(Object docIdsKey){
  return (DocsEnum)docIdsKey;
}","/** 
 * Returns a sorted array of integer docIds given the corresponding key.
 * @param docIdsKey The lookup key.
 * @return Not null
 */
protected IntsRef lookupDocIds(Object docIdsKey){
  return (IntsRef)docIdsKey;
}",0.9315068493150684
109125,"TermPrefixCursor(TermsEnum termsEnum,Bits liveDocs){
  this.termsEnum=termsEnum;
  this.liveDocs=liveDocs;
}","TermPrefixCursor(TermsEnum termsEnum,Bits liveDocs,Map<BytesRef,IntsRef> docIdsCache){
  this.termsEnum=termsEnum;
  this.liveDocs=liveDocs;
  this.docIdsCache=docIdsCache;
}",0.7659574468085106
109126,"/** 
 * Seeks to prefixBuf or the next prefix of it. Sets docsEnum. 
 */
private boolean seekPrefix() throws IOException {
  TermsEnum.SeekStatus seekStatus=termsEnum.seekCeil(prefixBuf);
  docsEnum=null;
switch (seekStatus) {
case END:
    return false;
case FOUND:
  docsEnum=termsEnum.docs(liveDocs,docsEnum,DocsEnum.FLAG_NONE);
if (liveDocs == null) return true;
if (docsEnum.nextDoc() != DocsEnum.NO_MORE_DOCS) {
docsEnum=termsEnum.docs(liveDocs,docsEnum,DocsEnum.FLAG_NONE);
return true;
}
docsEnum=null;
if (termsEnum.next() == null) {
return false;
}
case NOT_FOUND:
BytesRef teTerm=termsEnum.term();
if (teTerm.length > prefixBuf.length) {
for (int i=0; i < prefixBuf.length; i++) {
if (prefixBuf.bytes[prefixBuf.offset + i] != teTerm.bytes[teTerm.offset + i]) return false;
}
if (teTerm.bytes[teTerm.offset + prefixBuf.length] != SEPARATOR_CHAR) return false;
return true;
}
return false;
}
throw new IllegalStateException(seekStatus.toString());
}","/** 
 * Seeks to prefixBuf or the next term that is prefixed by prefixBuf plus the separator char. Sets docIds. 
 */
private boolean seekPrefix() throws IOException {
  TermsEnum.SeekStatus seekStatus=termsEnum.seekCeil(prefixBuf);
  docIds=null;
switch (seekStatus) {
case END:
    return false;
case FOUND:
  docsEnum=termsEnum.docs(liveDocs,docsEnum,DocsEnum.FLAG_NONE);
docIds=docsEnumToIntsRef(docsEnum);
if (docIds.length > 0) {
return true;
}
docIds=null;
if (termsEnum.next() == null) {
return false;
}
case NOT_FOUND:
BytesRef teTerm=termsEnum.term();
if (teTerm.length > prefixBuf.length) {
for (int i=0; i < prefixBuf.length; i++) {
if (prefixBuf.bytes[prefixBuf.offset + i] != teTerm.bytes[teTerm.offset + i]) return false;
}
if (teTerm.bytes[teTerm.offset + prefixBuf.length] != SEPARATOR_CHAR) return false;
return true;
}
return false;
}
throw new IllegalStateException(seekStatus.toString());
}",0.8426124197002142
109127,"/** 
 * Appends the separator char (if not the first) plus the given word to the prefix buffer, then seeks to it. If false is returned, then the advance failed, after which this cursor should be considered void.  The {{word}} BytesRef is considered temporary. 
 */
boolean advance(BytesRef word) throws IOException {
  if (prefixBuf == null) {
    prefixBuf=word;
    if (seekPrefix()) {
      prefixBuf=new BytesRef(64);
      prefixBuf.copyBytes(word);
      return true;
    }
 else {
      prefixBuf=null;
      return false;
    }
  }
 else {
    prefixBuf.grow(1 + word.length);
    prefixBuf.bytes[prefixBuf.length++]=SEPARATOR_CHAR;
    prefixBuf.append(word);
    return seekPrefix();
  }
}","/** 
 * Appends the separator char (if not the first) plus the given word to the prefix buffer, then seeks to it. If the seek fails, false is returned and this cursor can be re-used as if in a new state.  The {{word}} BytesRef is considered temporary. 
 */
boolean advance(BytesRef word) throws IOException {
}",0.4638255698711596
109128,"public void testTypical() throws IOException {
  String NYC=""String_Node_Str"";
  TokenStream stream=new WhitespaceTokenizer(TEST_VERSION_CURRENT,new StringReader(NYC));
  ConcatenateFilter filter=new ConcatenateFilter(stream);
  assertTokenStreamContents(filter,new String[]{NYC},new int[]{0},new int[]{NYC.length()},new String[]{""String_Node_Str""},new int[]{1},null,NYC.length(),true);
}","public void testTypical() throws IOException {
  String NYC=""String_Node_Str"";
  TokenStream stream=new WhitespaceTokenizer(TEST_VERSION_CURRENT,new StringReader(NYC));
  ConcatenateFilter filter=new ConcatenateFilter(stream);
  try {
    assertTokenStreamContents(filter,new String[]{NYC},new int[]{0},new int[]{NYC.length()},new String[]{""String_Node_Str""},new int[]{1},null,NYC.length(),true);
  }
 catch (  AssertionError e) {
    if (!e.getMessage().equals(""String_Node_Str""))     throw e;
  }
}",0.8716216216216216
109129,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setTheme(SettingUtility.getTheme());
  GlobalContext.setActivity(this);
  setContentView(R.layout.activity_main);
  ViewPager pager=(ViewPager)findViewById(R.id.pager);
  pager.setAdapter(new MyPagerAdapter(getSupportFragmentManager()));
  LinePageIndicator mIndicator=(LinePageIndicator)findViewById(R.id.indicator);
  if (SettingUtility.isLightTheme()) {
    mIndicator.setBackgroundColor(Color.WHITE);
  }
  mIndicator.setViewPager(pager);
  if (SettingUtility.enableGTask()) {
    mIndicator.setCurrentItem(1);
  }
  MyUtils.deleteContinueTimes(this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setTheme(SettingUtility.getTheme());
  GlobalContext.setActivity(this);
  setContentView(R.layout.activity_main);
  ViewPager pager=(ViewPager)findViewById(R.id.pager);
  pager.setAdapter(new MyPagerAdapter(getSupportFragmentManager()));
  LinePageIndicator mIndicator=(LinePageIndicator)findViewById(R.id.indicator);
  if (SettingUtility.isLightTheme()) {
    mIndicator.setBackgroundColor(Color.WHITE);
  }
  mIndicator.setViewPager(pager);
  mIndicator.setCurrentItem(1);
  MyUtils.deleteContinueTimes(this);
}",0.8681318681318682
109130,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  GlobalContext.setActivity(this);
  setContentView(R.layout.preference_activity);
  initCre();
  getListView().setItemsCanFocus(true);
  if (!SettingUtility.isADRemoved()) {
    LinearLayout layout=(LinearLayout)findViewById(R.id.ad_view);
    adsMogoLayout=new AdsMogoLayout(this,""String_Node_Str"",false);
    adsMogoLayout.downloadIsShowDialog=true;
    layout.addView(adsMogoLayout);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  GlobalContext.setActivity(this);
  setContentView(R.layout.preference_activity);
  getListView().setItemsCanFocus(true);
  if (!SettingUtility.isADRemoved()) {
    LinearLayout layout=(LinearLayout)findViewById(R.id.ad_view);
    adsMogoLayout=new AdsMogoLayout(this,""String_Node_Str"",false);
    adsMogoLayout.downloadIsShowDialog=true;
    layout.addView(adsMogoLayout);
  }
}",0.986639260020555
109131,"@Override public boolean onPreferenceClick(Preference preference){
  chooseAccount();
  return false;
}","@Override public boolean onPreferenceClick(Preference preference){
  return false;
}",0.8983957219251337
109132,"private void setupSimplePreferencesScreen(){
  addPreferencesFromResource(MyUtils.isUnderHoneycomb() ? R.xml.preferences_for_low : R.xml.preferences);
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  Preference email_us_Preference=findPreference(""String_Node_Str"");
  Preference donate_Preference=findPreference(""String_Node_Str"");
  Preference about_Preference=findPreference(""String_Node_Str"");
  Preference select_google_account_Preference=findPreference(""String_Node_Str"");
  final Preference remove_manage_Preference=findPreference(""String_Node_Str"");
  final CheckBoxPreference fast_mode_Preference=(CheckBoxPreference)findPreference(""String_Node_Str"");
  fast_mode_Preference.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      if (newValue.toString().equals(""String_Node_Str"")) {
        MyScreenLocker locker=new MyScreenLocker(SettingActivity.this);
        locker.activeManage();
      }
 else {
        MyScreenLocker locker=new MyScreenLocker(SettingActivity.this);
        locker.removeManage();
        remove_manage_Preference.setEnabled(false);
      }
      return true;
    }
  }
);
  remove_manage_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      MyScreenLocker locker=new MyScreenLocker(SettingActivity.this);
      locker.removeManage();
      remove_manage_Preference.setEnabled(false);
      fast_mode_Preference.setChecked(false);
      return false;
    }
  }
);
  email_us_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      Intent intent=new Intent(Intent.ACTION_SEND);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_EMAIL,new String[]{""String_Node_Str""});
      startActivity(Intent.createChooser(intent,""String_Node_Str""));
      return false;
    }
  }
);
  donate_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      Uri uri=Uri.parse(""String_Node_Str"");
      startActivity(new Intent(Intent.ACTION_VIEW,uri));
      return false;
    }
  }
);
  about_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      startActivity(new Intent(SettingActivity.this,PlaneFighterActivity.class));
      return false;
    }
  }
);
  select_google_account_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      chooseAccount();
      return false;
    }
  }
);
}","private void setupSimplePreferencesScreen(){
  addPreferencesFromResource(MyUtils.isUnderHoneycomb() ? R.xml.preferences_for_low : R.xml.preferences);
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  bindPreferenceSummaryToValue(findPreference(""String_Node_Str""));
  Preference email_us_Preference=findPreference(""String_Node_Str"");
  Preference donate_Preference=findPreference(""String_Node_Str"");
  Preference about_Preference=findPreference(""String_Node_Str"");
  Preference select_google_account_Preference=findPreference(""String_Node_Str"");
  final Preference remove_manage_Preference=findPreference(""String_Node_Str"");
  final CheckBoxPreference fast_mode_Preference=(CheckBoxPreference)findPreference(""String_Node_Str"");
  fast_mode_Preference.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      if (newValue.toString().equals(""String_Node_Str"")) {
        MyScreenLocker locker=new MyScreenLocker(SettingActivity.this);
        locker.activeManage();
      }
 else {
        MyScreenLocker locker=new MyScreenLocker(SettingActivity.this);
        locker.removeManage();
        remove_manage_Preference.setEnabled(false);
      }
      return true;
    }
  }
);
  remove_manage_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      MyScreenLocker locker=new MyScreenLocker(SettingActivity.this);
      locker.removeManage();
      remove_manage_Preference.setEnabled(false);
      fast_mode_Preference.setChecked(false);
      return false;
    }
  }
);
  email_us_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      Intent intent=new Intent(Intent.ACTION_SEND);
      intent.setType(""String_Node_Str"");
      intent.putExtra(Intent.EXTRA_EMAIL,new String[]{""String_Node_Str""});
      startActivity(Intent.createChooser(intent,""String_Node_Str""));
      return false;
    }
  }
);
  donate_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      Uri uri=Uri.parse(""String_Node_Str"");
      startActivity(new Intent(Intent.ACTION_VIEW,uri));
      return false;
    }
  }
);
  about_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      startActivity(new Intent(SettingActivity.this,PlaneFighterActivity.class));
      return false;
    }
  }
);
  select_google_account_Preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      return false;
    }
  }
);
}",0.9963739555415418
109133,"@Override public Fragment getItem(int position){
  if (position == (SettingUtility.enableGTask() ? 1 : 0)) {
    Fragment fragment=new MainFragment();
    return fragment;
  }
 else   if (position == (SettingUtility.enableGTask() ? 2 : 1)) {
    Fragment fragment=new RecordFragment();
    return fragment;
  }
 else {
    Fragment fragment=new TaskListFragment();
    return fragment;
  }
}","@Override public Fragment getItem(int position){
  if (position == 1) {
    Fragment fragment=new MainFragment();
    return fragment;
  }
 else   if (position == 2) {
    Fragment fragment=new RecordFragment();
    return fragment;
  }
 else {
    Fragment fragment=new TaskListFragment();
    return fragment;
  }
}",0.6864406779661016
109134,"@Override public int getCount(){
  return SettingUtility.enableGTask() ? 3 : 2;
}","@Override public int getCount(){
  return 3;
}",0.7244094488188977
109135,"@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
switch (requestCode) {
case REQUEST_GOOGLE_PLAY_SERVICES:
    if (resultCode == Activity.RESULT_OK) {
      try {
        haveGooglePlayServices();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      checkGooglePlayServicesAvailable();
    }
  break;
case REQUEST_AUTHORIZATION:
if (resultCode == Activity.RESULT_OK) {
  SyncDBTasks.run(this);
}
 else {
  chooseAccount();
}
break;
case REQUEST_ACCOUNT_PICKER:
if (resultCode == Activity.RESULT_OK && data != null && data.getExtras() != null) {
String accountName=data.getExtras().getString(AccountManager.KEY_ACCOUNT_NAME);
if (accountName != null) {
credential.setSelectedAccountName(accountName);
SettingUtility.setAccountName(accountName);
SyncDBTasks.run(this);
}
}
break;
}
}","@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
switch (requestCode) {
case REQUEST_GOOGLE_PLAY_SERVICES:
    if (resultCode == Activity.RESULT_OK) {
      syncTask();
    }
 else {
      checkGooglePlayServicesAvailable();
    }
  break;
case REQUEST_AUTHORIZATION:
if (resultCode == Activity.RESULT_OK) {
  FragmentAsyncTask.run(this);
}
 else {
  chooseAccount();
}
break;
case REQUEST_ACCOUNT_PICKER:
if (resultCode == Activity.RESULT_OK && data != null && data.getExtras() != null) {
String accountName=data.getExtras().getString(AccountManager.KEY_ACCOUNT_NAME);
if (accountName != null) {
credential.setSelectedAccountName(accountName);
SettingUtility.setAccountName(accountName);
FragmentAsyncTask.run(this);
}
}
break;
}
}",0.9055299539170508
109136,"@Override public boolean onLongClick(View arg0){
  SyncDBTasks.run(TaskListFragment.this);
  return true;
}","@Override public boolean onLongClick(View arg0){
  chooseAccount();
  return true;
}",0.7853403141361257
109137,"private void initView(){
  TextView tv_title=(TextView)rootView.findViewById(R.id.tv_title_task);
  ImageButton addTaskBTN=(ImageButton)rootView.findViewById(R.id.btn_add_task);
  listView=(ListView)rootView.findViewById(R.id.list_task);
  Typeface roboto=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  tv_title.setTypeface(roboto);
  tv_title.setText(""String_Node_Str"");
  Boolean isLightTheme=SettingUtility.isLightTheme();
  if (isLightTheme) {
    tv_title.setTextColor(Color.BLACK);
    rootView.setBackgroundColor(Color.WHITE);
    addTaskBTN.setBackgroundColor(Color.argb(1,0,0,0));
    addTaskBTN.setImageResource(R.drawable.new_btn_gray);
  }
  addTaskBTN.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      TaskDialogFragment dialog=new TaskDialogFragment();
      dialog.initDialog(TaskListFragment.this);
      dialog.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  addTaskBTN.setOnLongClickListener(new OnLongClickListener(){
    @Override public boolean onLongClick(    View arg0){
      SyncDBTasks.run(TaskListFragment.this);
      return true;
    }
  }
);
}","private void initView(){
  TextView tv_title=(TextView)rootView.findViewById(R.id.tv_title_task);
  ImageButton addTaskBTN=(ImageButton)rootView.findViewById(R.id.btn_add_task);
  listView=(ListView)rootView.findViewById(R.id.list_task);
  Typeface roboto=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  tv_title.setTypeface(roboto);
  tv_title.setText(""String_Node_Str"");
  Boolean isLightTheme=SettingUtility.isLightTheme();
  if (isLightTheme) {
    tv_title.setTextColor(Color.BLACK);
    rootView.setBackgroundColor(Color.WHITE);
    addTaskBTN.setBackgroundColor(Color.argb(1,0,0,0));
    addTaskBTN.setImageResource(R.drawable.new_btn_gray);
  }
  addTaskBTN.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      TaskDialogFragment dialog=new TaskDialogFragment();
      dialog.initDialog(TaskListFragment.this);
      dialog.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  if (SettingUtility.enableGTask()) {
    addTaskBTN.setOnLongClickListener(new OnLongClickListener(){
      @Override public boolean onLongClick(      View arg0){
        chooseAccount();
        return true;
      }
    }
);
  }
}",0.9535577332765232
109138,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  rootView=inflater.inflate(R.layout.fragment_task,container,false);
  initView();
  showGoogleTask();
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  rootView=inflater.inflate(R.layout.fragment_task,container,false);
  initView();
  refreshView();
  initGoogleTask();
  return rootView;
}",0.9559748427672956
109139,"/** 
 * @param configuredMetricPathPrefix Prefix to add to the metric keys. May be null, in which case servers.your_hostname will be used.
 */
public ZabbixMetricMessageBuilder(@Nullable String hostName){
  this.hostName=hostName;
}","/** 
 * @param hostName hostname of the zabbix server
 */
public ZabbixMetricMessageBuilder(@Nullable String hostName){
  this.hostName=hostName;
}",0.6754617414248021
109140,"/** 
 * Builds a metric string to send to a Graphite instance.
 * @return The metric string without trailing newline
 */
public String buildMessage(String metricName,Object value,long timestamp){
  String valueToString=""String_Node_Str"";
  if (value != null) {
    valueToString=value.toString();
  }
  JsonObject jsonValue=new JsonObject();
  jsonValue.add(""String_Node_Str"",getHostName());
  jsonValue.add(""String_Node_Str"",metricName);
  jsonValue.add(""String_Node_Str"",valueToString);
  jsonValue.add(""String_Node_Str"",timestamp);
  return jsonValue.toString();
}","/** 
 * Builds a metric string to send to a Graphite instance.
 * @return The metric json string without trailing newline
 */
public String buildMessage(String metricName,Object value,long timestamp){
  String valueToString=""String_Node_Str"";
  if (value != null) {
    valueToString=value.toString();
  }
  JsonObject jsonValue=new JsonObject();
  jsonValue.add(""String_Node_Str"",getHostName());
  jsonValue.add(""String_Node_Str"",metricName);
  jsonValue.add(""String_Node_Str"",valueToString);
  jsonValue.add(""String_Node_Str"",timestamp);
  return jsonValue.toString();
}",0.9956101843722563
109141,"private boolean init(@Nonnull Map<String,String> settings){
  rfc3339.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  String projectId=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  if (StringUtils2.isNullOrEmpty(projectId)) {
    logger.info(""String_Node_Str"");
    projectId=getGoogleProjectId();
  }
  if (StringUtils2.isNullOrEmpty(projectId)) {
    logger.log(Level.WARNING,""String_Node_Str"");
    return false;
  }
  logger.info(""String_Node_Str"" + projectId);
  String applicationCredentials=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String serviceAccount=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String serviceAccountKey=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String separator=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  this.separator=StringUtils2.isNullOrEmpty(separator) ? ""String_Node_Str"" : separator;
  String namePrefix=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  this.namePrefix=StringUtils2.isNullOrEmpty(namePrefix) ? ""String_Node_Str"" : namePrefix;
  initStaticLabels(settings);
  return ApiFacade.initConnection(projectId,serviceAccount,serviceAccountKey,applicationCredentials);
}","private boolean init(@Nonnull Map<String,String> settings){
  rfc3339.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  cumulativePeriodStart=getNow();
  String projectId=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  if (StringUtils2.isNullOrEmpty(projectId)) {
    logger.info(""String_Node_Str"");
    projectId=getGoogleProjectId();
  }
  if (StringUtils2.isNullOrEmpty(projectId)) {
    logger.log(Level.WARNING,""String_Node_Str"");
    return false;
  }
  logger.info(""String_Node_Str"" + projectId);
  String applicationCredentials=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String serviceAccount=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String serviceAccountKey=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String separator=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  this.separator=StringUtils2.isNullOrEmpty(separator) ? ""String_Node_Str"" : separator;
  String namePrefix=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  this.namePrefix=StringUtils2.isNullOrEmpty(namePrefix) ? ""String_Node_Str"" : namePrefix;
  initStaticLabels(settings);
  return ApiFacade.initConnection(projectId,serviceAccount,serviceAccountKey,applicationCredentials);
}",0.9862348178137652
109142,"private void setFromFile(String credentialsFileLocation){
  try {
    JsonObject object=Json.parse(new InputStreamReader(new FileInputStream(credentialsFileLocation))).asObject();
    this.serviceAccount=object.get(""String_Node_Str"").asString();
    this.privateKey=getPrivateKeyFromString(object.get(""String_Node_Str"").asString());
  }
 catch (  IOException e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + credentialsFileLocation + ""String_Node_Str""+ e.getMessage(),e);
  }
}","private void setFromFile(String credentialsFileLocation){
  try {
    JsonObject object=Json.parse(new InputStreamReader(new FileInputStream(credentialsFileLocation),""String_Node_Str"")).asObject();
    this.serviceAccount=object.get(""String_Node_Str"").asString();
    this.privateKey=getPrivateKeyFromString(object.get(""String_Node_Str"").asString());
  }
 catch (  IOException e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + credentialsFileLocation + ""String_Node_Str""+ e.getMessage(),e);
  }
}",0.9816326530612244
109143,"private byte[] signSHA256withRSA(String value){
  byte[] result=null;
  try {
    Signature signature=Signature.getInstance(""String_Node_Str"");
    signature.initSign(this.privateKey);
    signature.update(value.getBytes());
    result=signature.sign();
  }
 catch (  Exception var7) {
    logger.log(Level.SEVERE,var7.getMessage(),var7);
  }
  return result;
}","private byte[] signSHA256withRSA(String value){
  byte[] result=null;
  try {
    Signature signature=Signature.getInstance(""String_Node_Str"");
    signature.initSign(this.privateKey);
    signature.update(value.getBytes(Charset.forName(""String_Node_Str"")));
    result=signature.sign();
  }
 catch (  Exception var7) {
    logger.log(Level.SEVERE,var7.getMessage(),var7);
  }
  return result;
}",0.955026455026455
109144,"private synchronized void prepareApiToken(){
  if (!isNullOrEmpty(token) && expiry != null && (System.currentTimeMillis() + 30000L) <= expiry.getTime())   return;
  try {
    JsonObject header=new JsonObject();
    header.add(""String_Node_Str"",""String_Node_Str"");
    header.add(""String_Node_Str"",""String_Node_Str"");
    long utcSeconds=(System.currentTimeMillis() / 1000);
    JsonObject claim=new JsonObject();
    claim.add(""String_Node_Str"",AUTH_URL);
    claim.add(""String_Node_Str"",utcSeconds + 3600l);
    claim.add(""String_Node_Str"",utcSeconds);
    claim.add(""String_Node_Str"",serviceAccount);
    claim.add(""String_Node_Str"",SCOPE);
    String payload=encodeBase64Url(header.toString().getBytes()) + ""String_Node_Str"" + encodeBase64Url(claim.toString().getBytes());
    String assertion=payload + ""String_Node_Str"" + encodeBase64Url(signSHA256withRSA(payload));
    LinkedHashMap<String,String> postParameters=new LinkedHashMap<>();
    postParameters.put(""String_Node_Str"",GRANT_TYPE);
    postParameters.put(""String_Node_Str"",assertion);
    String content=convertMapToContent(postParameters);
    String response=httpCall(AUTH_URL,""String_Node_Str"",content,null);
    String newToken=null;
    Date newExpiry=null;
    JsonObject json=Json.parse(response).asObject();
    if (json != null && json.get(""String_Node_Str"") != null) {
      newToken=json.get(""String_Node_Str"").asString();
      newExpiry=new Date(utcSeconds * 1000 + json.get(""String_Node_Str"").asInt() * 1000);
    }
    JsonValue error=json.get(""String_Node_Str"");
    if (error != null) {
      logger.log(Level.SEVERE,error.toString());
    }
    JsonValue errorDesc=json.get(""String_Node_Str"");
    if (errorDesc != null) {
      logger.log(Level.SEVERE,errorDesc.toString());
    }
    if (!isNullOrEmpty(newToken) && newExpiry != null && System.currentTimeMillis() < newExpiry.getTime()) {
      token=newToken;
      expiry=newExpiry;
      logger.log(Level.FINE,""String_Node_Str"" + token);
      logger.info(""String_Node_Str"" + expiry);
    }
 else {
      logger.log(Level.WARNING,""String_Node_Str"" + token + ""String_Node_Str""+ expiry);
    }
  }
 catch (  Exception ex) {
    logger.log(Level.SEVERE,""String_Node_Str"" + ex.getMessage(),ex);
  }
}","private void prepareApiToken(){
synchronized (tokenLock) {
    if (!isNullOrEmpty(token) && expiry != null && (System.currentTimeMillis() + 30000L) <= expiry.getTime()) {
      return;
    }
    try {
      JsonObject header=new JsonObject();
      header.add(""String_Node_Str"",""String_Node_Str"");
      header.add(""String_Node_Str"",""String_Node_Str"");
      long utcSeconds=(System.currentTimeMillis() / 1000);
      JsonObject claim=new JsonObject();
      claim.add(""String_Node_Str"",AUTH_URL);
      claim.add(""String_Node_Str"",utcSeconds + 3600l);
      claim.add(""String_Node_Str"",utcSeconds);
      claim.add(""String_Node_Str"",serviceAccount);
      claim.add(""String_Node_Str"",SCOPE);
      String payload=encodeBase64Url(header.toString().getBytes(Charset.forName(""String_Node_Str""))) + ""String_Node_Str"" + encodeBase64Url(claim.toString().getBytes(Charset.forName(""String_Node_Str"")));
      String assertion=payload + ""String_Node_Str"" + encodeBase64Url(signSHA256withRSA(payload));
      LinkedHashMap<String,String> postParameters=new LinkedHashMap<>();
      postParameters.put(""String_Node_Str"",GRANT_TYPE);
      postParameters.put(""String_Node_Str"",assertion);
      String content=convertMapToContent(postParameters);
      String response=httpCall(AUTH_URL,""String_Node_Str"",content,null);
      String newToken=null;
      Date newExpiry=null;
      JsonObject json=Json.parse(response).asObject();
      if (json != null && json.get(""String_Node_Str"") != null) {
        newToken=json.get(""String_Node_Str"").asString();
        newExpiry=new Date(utcSeconds * 1000 + json.get(""String_Node_Str"").asInt() * 1000);
      }
      JsonValue error=json.get(""String_Node_Str"");
      if (error != null) {
        logger.log(Level.SEVERE,error.toString());
      }
      JsonValue errorDesc=json.get(""String_Node_Str"");
      if (errorDesc != null) {
        logger.log(Level.SEVERE,errorDesc.toString());
      }
      if (!isNullOrEmpty(newToken) && newExpiry != null && System.currentTimeMillis() < newExpiry.getTime()) {
        token=newToken;
        expiry=newExpiry;
        logger.log(Level.FINE,""String_Node_Str"" + token);
        logger.info(""String_Node_Str"" + expiry);
      }
 else {
        logger.log(Level.WARNING,""String_Node_Str"" + token + ""String_Node_Str""+ expiry);
      }
    }
 catch (    Exception ex) {
      logger.log(Level.SEVERE,""String_Node_Str"" + ex.getMessage(),ex);
    }
  }
}",0.9497638471446972
109145,"private String httpCall(String urlString,String method,String content,String token) throws Exception {
  StringBuilder result=new StringBuilder();
  URL url=new URL(urlString);
  HttpURLConnection conn;
  conn=(HttpURLConnection)url.openConnection();
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + token);
  conn.setRequestMethod(method.toUpperCase());
  if (method.equalsIgnoreCase(""String_Node_Str"")) {
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  }
  if (!isNullOrEmpty(content)) {
    conn.setDoOutput(true);
  }
  conn.setDoInput(true);
  conn.setUseCaches(false);
  conn.setAllowUserInteraction(false);
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  conn.setRequestProperty(""String_Node_Str"",isNullOrEmpty(content) ? ""String_Node_Str"" : ""String_Node_Str"" + content.length());
  conn.connect();
  if (!isNullOrEmpty(content)) {
    OutputStream output=conn.getOutputStream();
    output.write(content.getBytes());
    output.flush();
  }
  InputStream is;
  boolean isError=false;
  if (conn.getResponseCode() < 400) {
    is=conn.getInputStream();
  }
 else {
    is=conn.getErrorStream();
    isError=true;
  }
  BufferedReader rd=new BufferedReader(new InputStreamReader(is,""String_Node_Str""));
  String line;
  while ((line=rd.readLine()) != null) {
    result.append(line);
  }
  rd.close();
  if (isError)   throw new RuntimeException(result.toString());
  return result.toString();
}","private String httpCall(String urlString,String method,String content,String token) throws Exception {
  StringBuilder result=new StringBuilder();
  URL url=new URL(urlString);
  HttpURLConnection conn;
  conn=(HttpURLConnection)url.openConnection();
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + token);
  conn.setRequestMethod(method.toUpperCase());
  if (method.equalsIgnoreCase(""String_Node_Str"")) {
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  }
  if (!isNullOrEmpty(content)) {
    conn.setDoOutput(true);
  }
  conn.setDoInput(true);
  conn.setUseCaches(false);
  conn.setAllowUserInteraction(false);
  conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  conn.setRequestProperty(""String_Node_Str"",isNullOrEmpty(content) ? ""String_Node_Str"" : ""String_Node_Str"" + content.length());
  conn.connect();
  if (!isNullOrEmpty(content)) {
    OutputStream output=conn.getOutputStream();
    output.write(content.getBytes(Charset.forName(""String_Node_Str"")));
    output.flush();
  }
  InputStream is;
  boolean isError=false;
  if (conn.getResponseCode() < 400) {
    is=conn.getInputStream();
  }
 else {
    is=conn.getErrorStream();
    isError=true;
  }
  BufferedReader rd=new BufferedReader(new InputStreamReader(is,""String_Node_Str""));
  String line;
  while ((line=rd.readLine()) != null) {
    result.append(line);
  }
  rd.close();
  if (isError)   throw new RuntimeException(result.toString());
  return result.toString();
}",0.9889250814332248
109146,"private boolean init(@Nonnull Map<String,String> settings){
  String projectId=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  if (StringUtils2.isNullOrEmpty(projectId)) {
    logger.info(""String_Node_Str"");
    projectId=getGkeProjectId();
  }
  if (StringUtils2.isNullOrEmpty(projectId)) {
    logger.log(Level.WARNING,""String_Node_Str"");
    return false;
  }
  logger.info(""String_Node_Str"" + projectId);
  String applicationCredentials=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String serviceAccount=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String serviceAccountKey=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String separator=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  this.separator=StringUtils2.isNullOrEmpty(separator) ? ""String_Node_Str"" : separator;
  String namePrefix=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  this.namePrefix=StringUtils2.isNullOrEmpty(namePrefix) ? ""String_Node_Str"" : namePrefix;
  initStaticLabels(settings);
  return ApiFacade.initConnection(projectId,serviceAccount,serviceAccountKey,applicationCredentials);
}","private boolean init(@Nonnull Map<String,String> settings){
  rfc3339.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  String projectId=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  if (StringUtils2.isNullOrEmpty(projectId)) {
    logger.info(""String_Node_Str"");
    projectId=getGoogleProjectId();
  }
  if (StringUtils2.isNullOrEmpty(projectId)) {
    logger.log(Level.WARNING,""String_Node_Str"");
    return false;
  }
  logger.info(""String_Node_Str"" + projectId);
  String applicationCredentials=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String serviceAccount=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String serviceAccountKey=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  String separator=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  this.separator=StringUtils2.isNullOrEmpty(separator) ? ""String_Node_Str"" : separator;
  String namePrefix=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  this.namePrefix=StringUtils2.isNullOrEmpty(namePrefix) ? ""String_Node_Str"" : namePrefix;
  initStaticLabels(settings);
  return ApiFacade.initConnection(projectId,serviceAccount,serviceAccountKey,applicationCredentials);
}",0.970873786407767
109147,"private void initStaticLabels(Map<String,String> settings){
  String hostname=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  if (StringUtils2.isNullOrEmpty(hostname)) {
    hostname=System.getenv(""String_Node_Str"");
  }
  logger.info(""String_Node_Str"" + hostname);
  this.staticLabels.put(""String_Node_Str"",hostname);
  for (  String key : settings.keySet()) {
    String value=StringUtils2.trimToEmpty(settings.get(key));
    if (StringUtils2.isNullOrEmpty(value) || RESERVED_KEYWORDS.contains(key.toLowerCase().trim())) {
      continue;
    }
    this.staticLabels.put(key,value);
    logger.log(Level.INFO,""String_Node_Str"" + key + ""String_Node_Str""+ value);
  }
}","private void initStaticLabels(Map<String,String> settings){
  String hostname=StringUtils2.trimToEmpty(settings.get(""String_Node_Str""));
  if (StringUtils2.isNullOrEmpty(hostname)) {
    hostname=System.getenv(""String_Node_Str"");
  }
  logger.info(""String_Node_Str"" + hostname);
  this.staticLabels.put(""String_Node_Str"",hostname);
  for (  Map.Entry<String,String> entry : settings.entrySet()) {
    String value=StringUtils2.trimToEmpty(settings.get(entry.getKey()));
    if (StringUtils2.isNullOrEmpty(value) || RESERVED_KEYWORDS.contains(entry.getKey().toLowerCase().trim())) {
      continue;
    }
    this.staticLabels.put(entry.getKey(),value);
    logger.log(Level.INFO,""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ value);
  }
}",0.9216783216783216
109148,"private static String getNow(){
  return rfc3339.format(new Date());
}","private String getNow(){
  return rfc3339.format(new Date());
}",0.9473684210526316
109149,"private synchronized void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {
  inputStream.defaultReadObject();
  table=new HashIndexTable();
  updateHashIndex();
}","private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {
  inputStream.defaultReadObject();
  table=new HashIndexTable();
  updateHashIndex();
}",0.96640826873385
109150,"@Nonnull public static Document getFileAsDocument(@Nonnull Resource resource) throws IoRuntimeException {
  if (resource == null)   throw new IoRuntimeException(new NullPointerException(""String_Node_Str""));
  DocumentBuilder dBuilder;
  try {
    dBuilder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
    try {
      File configurationFile=resource.getFile();
      return dBuilder.parse(configurationFile);
    }
 catch (    FileNotFoundException e) {
      return dBuilder.parse(resource.getInputStream());
    }
  }
 catch (  ParserConfigurationException|SAXException e) {
    throw new IoRuntimeException(e);
  }
catch (  IOException e) {
    throw IoRuntimeException.propagate(e);
  }
}","@Nonnull public static Document getFileAsDocument(@Nonnull Resource resource) throws IoRuntimeException {
  if (resource == null)   throw new IoRuntimeException(new NullPointerException(""String_Node_Str""));
  DocumentBuilder dBuilder;
  try {
    dBuilder=DocumentBuilderFactory.newInstance().newDocumentBuilder();
    try {
      File configurationFile=resource.getFile();
      return dBuilder.parse(configurationFile);
    }
 catch (    FileNotFoundRuntimeException e) {
      return dBuilder.parse(resource.getInputStream());
    }
  }
 catch (  ParserConfigurationException|SAXException e) {
    throw new IoRuntimeException(e);
  }
catch (  IOException e) {
    throw IoRuntimeException.propagate(e);
  }
}",0.995059985885674
109151,"public void start(){
  if (logger.isLoggable(Level.FINER)) {
    logger.fine(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
  }
 else {
    logger.fine(""String_Node_Str"" + getClass().getName() + ""String_Node_Str"");
  }
  if (scheduledFuture != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (config.getResultNameStrategy() == null)   throw new IllegalStateException(""String_Node_Str"");
  scheduledFuture=scheduledExecutorService.scheduleWithFixedDelay(new Runnable(){
    @Override public void run(){
      collectAndExport();
    }
  }
,config.getCollectInterval() / 2,config.getCollectInterval(),config.getCollectIntervalTimeUnit());
  if (config.getConfigReloadInterval() >= 0) {
    Runnable runnable=new Runnable(){
      private final Logger logger=Logger.getLogger(JmxTransExporter.class.getName() + ""String_Node_Str"");
      private long lastModified=configLoader.lastModified();
      @Override public void run(){
        long newLastModified=configLoader.lastModified();
        if (newLastModified == 0L) {
          if (logger.isLoggable(Level.FINER))           logger.finer(""String_Node_Str"" + lastModified + ""String_Node_Str""+ new Timestamp(lastModified)+ ""String_Node_Str""+ newLastModified);
        }
 else         if (newLastModified > lastModified) {
          logger.info(""String_Node_Str"" + configLoader);
          if (logger.isLoggable(Level.FINER))           logger.finer(""String_Node_Str"" + lastModified + ""String_Node_Str""+ new Timestamp(lastModified)+ ""String_Node_Str""+ newLastModified+ ""String_Node_Str""+ new Timestamp(newLastModified));
          lastModified=newLastModified;
          stop();
          config=configLoader.loadConfiguration();
          start();
        }
 else {
          if (logger.isLoggable(Level.FINER))           logger.finer(""String_Node_Str"" + lastModified + ""String_Node_Str""+ new Timestamp(lastModified)+ ""String_Node_Str""+ newLastModified+ ""String_Node_Str""+ new Timestamp(newLastModified));
        }
      }
    }
;
    int configReloadIntervalInSecs=Math.max(config.getConfigReloadInterval(),5);
    if (logger.isLoggable(Level.INFO))     logger.info(""String_Node_Str"" + configReloadIntervalInSecs + ""String_Node_Str"");
    scheduledExecutorService.scheduleWithFixedDelay(runnable,0,configReloadIntervalInSecs,TimeUnit.SECONDS);
  }
  logger.fine(getClass().getName() + ""String_Node_Str"");
}","public void start(){
  if (logger.isLoggable(Level.FINER)) {
    logger.fine(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
  }
 else {
    logger.fine(""String_Node_Str"" + getClass().getName() + ""String_Node_Str"");
  }
  if (scheduledExecutorService != null || scheduledFuture != null)   throw new IllegalArgumentException(""String_Node_Str"" + scheduledExecutorService + ""String_Node_Str""+ scheduledFuture);
  scheduledExecutorService=Executors.newScheduledThreadPool(1,threadFactory);
  if (config.getResultNameStrategy() == null)   throw new IllegalStateException(""String_Node_Str"");
  scheduledFuture=scheduledExecutorService.scheduleWithFixedDelay(new Runnable(){
    @Override public void run(){
      collectAndExport();
    }
  }
,config.getCollectInterval() / 2,config.getCollectInterval(),config.getCollectIntervalTimeUnit());
  if (config.getConfigReloadInterval() >= 0) {
    Runnable runnable=new Runnable(){
      private final Logger logger=Logger.getLogger(JmxTransExporter.class.getName() + ""String_Node_Str"");
      private long lastModified=configLoader.lastModified();
      @Override public void run(){
        long newLastModified=configLoader.lastModified();
        if (newLastModified == 0L) {
          if (logger.isLoggable(Level.FINER))           logger.finer(""String_Node_Str"" + lastModified + ""String_Node_Str""+ new Timestamp(lastModified)+ ""String_Node_Str""+ newLastModified);
        }
 else         if (newLastModified > lastModified) {
          logger.info(""String_Node_Str"" + configLoader);
          if (logger.isLoggable(Level.FINER))           logger.finer(""String_Node_Str"" + lastModified + ""String_Node_Str""+ new Timestamp(lastModified)+ ""String_Node_Str""+ newLastModified+ ""String_Node_Str""+ new Timestamp(newLastModified));
          lastModified=newLastModified;
          stop();
          config=configLoader.loadConfiguration();
          start();
        }
 else {
          if (logger.isLoggable(Level.FINER))           logger.finer(""String_Node_Str"" + lastModified + ""String_Node_Str""+ new Timestamp(lastModified)+ ""String_Node_Str""+ newLastModified+ ""String_Node_Str""+ new Timestamp(newLastModified));
        }
      }
    }
;
    int configReloadIntervalInSecs=Math.max(config.getConfigReloadInterval(),5);
    if (logger.isLoggable(Level.INFO))     logger.info(""String_Node_Str"" + configReloadIntervalInSecs + ""String_Node_Str"");
    scheduledExecutorService.scheduleWithFixedDelay(runnable,0,configReloadIntervalInSecs,TimeUnit.SECONDS);
  }
  logger.fine(getClass().getName() + ""String_Node_Str"");
}",0.9612747075433644
109152,"@Nonnull public String getResultName(@Nonnull Query query,@Nonnull ObjectName objectName,@Nullable String key){
  StringBuilder result=_getResultName(query,objectName);
  if (key != null) {
    result.append(""String_Node_Str"");
    result.append(key);
  }
  return result.toString();
}","@Nonnull public String getResultName(@Nonnull Query query,@Nonnull ObjectName objectName,@Nullable String key){
  String result;
  if (query.getResultAlias() == null) {
    if (key == null) {
      result=escapeObjectName(objectName) + ""String_Node_Str"" + query.getAttribute();
    }
 else {
      result=escapeObjectName(objectName) + ""String_Node_Str"" + query.getAttribute()+ ""String_Node_Str""+ key;
    }
  }
 else {
    result=resolveExpression(query.getResultAlias(),objectName);
  }
  return result;
}",0.3813131313131313
109153,"@EventHandler public void init(FMLInitializationEvent event){
  ModRecipes.InitializeRecipes();
  ResearchCategories.registerCategory(""String_Node_Str"",(String)null,new AspectList(),new ResourceLocation(""String_Node_Str"",""String_Node_Str""),new ResourceLocation(""String_Node_Str"",""String_Node_Str""),new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  ThaumcraftApi.registerResearchLocation(new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  ThaumcraftApi.registerResearchLocation(new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  ThaumcraftApi.registerResearchLocation(new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  proxy.registerRenderers();
  FocusEngine.registerElement(FocusEffectDislocate.class,new ResourceLocation(""String_Node_Str"",""String_Node_Str""),8760709);
}","@EventHandler public void init(FMLInitializationEvent event){
  proxy.init(event);
  ModRecipes.InitializeRecipes();
  ResearchCategories.registerCategory(""String_Node_Str"",(String)null,new AspectList(),new ResourceLocation(""String_Node_Str"",""String_Node_Str""),new ResourceLocation(""String_Node_Str"",""String_Node_Str""),new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  ThaumcraftApi.registerResearchLocation(new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  ThaumcraftApi.registerResearchLocation(new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  ThaumcraftApi.registerResearchLocation(new ResourceLocation(""String_Node_Str"",""String_Node_Str""));
  proxy.registerRenderers();
  FocusEngine.registerElement(FocusEffectDislocate.class,new ResourceLocation(""String_Node_Str"",""String_Node_Str""),8760709);
}",0.9872958257713248
109154,"@EventHandler public void preInit(FMLPreInitializationEvent event){
  logger=event.getModLog();
}","@EventHandler public void preInit(FMLPreInitializationEvent event){
  logger=event.getModLog();
  PacketHandler.registerMessages(LibMisc.MOD_ID);
}",0.7950819672131147
109155,"private SavedState(Parcel in){
  super(in);
  state=in.readParcelable(null);
}","private SavedState(Parcel in){
  super(in);
  state=(MultiStateViewData)in.readParcelable(MultiStateViewData.class.getClassLoader());
}",0.7230046948356808
109156,"private static void open(){
  props=new Properties();
  try {
    props.load(new FileReader(PROP_FILE));
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","private static void open(){
  props=new Properties();
  try {
    props.load(new FileReader(PROP_FILE));
    File downloadFile=new File((String)props.get(DIRECTORY_PROP));
    if (!downloadFile.exists()) {
      downloadFile.mkdirs();
    }
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.786833855799373
109157,"private void createContent(final Shell parent){
  Composite c1=new Composite(parent,SWT.BORDER);
  c1.setLayoutData(new GridData(SWT.FILL,SWT.NONE,true,false));
  c1.setLayout(new GridLayout(3,false));
  Label urlLabel=new Label(c1,SWT.NONE);
  urlLabel.setText(""String_Node_Str"");
  urlText=new Text(c1,SWT.BORDER);
  urlText.setLayoutData(new GridData(SWT.FILL,SWT.NONE,true,false));
  urlText.addKeyListener(new KeyAdapter(){
    @Override public void keyReleased(    KeyEvent e){
      if (!urlText.getText().isEmpty()) {
        downloadButton.setEnabled(true);
      }
 else {
        downloadButton.setEnabled(false);
      }
      parent.pack();
    }
  }
);
  toMP3Checkbox=new Button(c1,SWT.CHECK);
  toMP3Checkbox.setText(""String_Node_Str"");
  toMP3Checkbox.setSelection(Settings.toMP3());
  toMP3Checkbox.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      try {
        Settings.setToMP3(toMP3Checkbox.getSelection());
      }
 catch (      Exception ex) {
        MessageBox mb=new MessageBox(parent,SWT.ICON_ERROR);
        mb.setText(""String_Node_Str"");
        mb.setMessage(ex.getMessage());
        mb.open();
      }
    }
  }
);
  Label folderLabel=new Label(c1,SWT.NONE);
  folderLabel.setText(""String_Node_Str"");
  folderText=new Text(c1,SWT.BORDER);
  folderText.setEditable(false);
  folderText.setText(Settings.getDirectory().getAbsolutePath());
  folderText.setLayoutData(new GridData(SWT.FILL,SWT.NONE,true,false));
  openButton=new Button(c1,SWT.PUSH);
  openButton.setText(""String_Node_Str"");
  final DirectoryDialog directoryDialog=new DirectoryDialog(parent,SWT.OPEN);
  openButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent e){
      String directory=directoryDialog.open();
      if (directory != null) {
        folderText.setText(directory);
        Settings.setDirectory(new File(directory));
        parent.pack();
      }
    }
  }
);
  downloadButton=new Button(c1,SWT.PUSH);
  downloadButton.setEnabled(false);
  GridData gridData=new GridData(SWT.NONE,SWT.NONE,false,false);
  gridData.horizontalSpan=3;
  downloadButton.setLayoutData(gridData);
  downloadButton.setText(""String_Node_Str"");
  downloadButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent e){
      try {
        if (!folderText.getText().startsWith(""String_Node_Str"") && !folderText.getText().startsWith(""String_Node_Str"")) {
          MessageBox mb=new MessageBox(parent,SWT.ICON_ERROR);
          mb.setText(""String_Node_Str"");
          mb.setMessage(""String_Node_Str"");
          mb.open();
          return;
        }
        YouTubeDownloader.download(folderText.getText(),urlText.getText().trim(),toMP3Checkbox.getSelection());
      }
 catch (      Exception ex) {
        MessageBox mb=new MessageBox(parent,SWT.ICON_ERROR);
        mb.setText(""String_Node_Str"");
        mb.setMessage(ex.getMessage());
        mb.open();
      }
    }
  }
);
  Composite c2=new Composite(parent,SWT.BORDER);
  c2.setLayoutData(new GridData(SWT.FILL,SWT.NONE,true,false));
  c2.setLayout(new GridLayout(2,false));
  updateButton=new Button(c2,SWT.PUSH);
  updateButton.setText(""String_Node_Str"");
  updateButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent e){
      try {
        YouTubeDownloader.update();
      }
 catch (      Exception ex) {
        MessageBox mb=new MessageBox(parent,SWT.ICON_ERROR);
        mb.setText(""String_Node_Str"");
        mb.setMessage(ex.getMessage());
        mb.open();
      }
    }
  }
);
  Label authorLabel=new Label(c2,SWT.NONE);
  authorLabel.setLayoutData(new GridData(SWT.NONE,SWT.CENTER,false,false));
  authorLabel.setText(""String_Node_Str"");
}","private void createContent(final Shell parent){
  Composite c1=new Composite(parent,SWT.BORDER);
  c1.setLayoutData(new GridData(SWT.FILL,SWT.NONE,true,false));
  c1.setLayout(new GridLayout(3,false));
  Label urlLabel=new Label(c1,SWT.NONE);
  urlLabel.setText(""String_Node_Str"");
  urlText=new Text(c1,SWT.BORDER);
  urlText.setLayoutData(new GridData(SWT.FILL,SWT.NONE,true,false));
  urlText.addKeyListener(new KeyAdapter(){
    @Override public void keyReleased(    KeyEvent e){
      if (!urlText.getText().isEmpty()) {
        downloadButton.setEnabled(true);
      }
 else {
        downloadButton.setEnabled(false);
      }
      parent.pack();
    }
  }
);
  toMP3Checkbox=new Button(c1,SWT.CHECK);
  toMP3Checkbox.setText(""String_Node_Str"");
  toMP3Checkbox.setSelection(Settings.toMP3());
  toMP3Checkbox.addSelectionListener(new SelectionAdapter(){
    @Override public void widgetSelected(    SelectionEvent e){
      try {
        Settings.setToMP3(toMP3Checkbox.getSelection());
      }
 catch (      Exception ex) {
        MessageBox mb=new MessageBox(parent,SWT.ICON_ERROR);
        mb.setText(""String_Node_Str"");
        mb.setMessage(ex.getMessage());
        mb.open();
      }
    }
  }
);
  Label folderLabel=new Label(c1,SWT.NONE);
  folderLabel.setText(""String_Node_Str"");
  folderText=new Text(c1,SWT.BORDER);
  folderText.setEditable(false);
  folderText.setText(Settings.getDirectory().getAbsolutePath());
  folderText.setLayoutData(new GridData(SWT.FILL,SWT.NONE,true,false));
  openButton=new Button(c1,SWT.PUSH);
  openButton.setText(""String_Node_Str"");
  final DirectoryDialog directoryDialog=new DirectoryDialog(parent,SWT.OPEN);
  openButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent e){
      String directory=directoryDialog.open();
      if (directory != null) {
        folderText.setText(directory);
        Settings.setDirectory(new File(directory));
        parent.pack();
      }
    }
  }
);
  downloadButton=new Button(c1,SWT.PUSH);
  downloadButton.setEnabled(false);
  GridData gridData=new GridData(SWT.NONE,SWT.NONE,false,false);
  gridData.horizontalSpan=3;
  downloadButton.setLayoutData(gridData);
  downloadButton.setText(""String_Node_Str"");
  downloadButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent e){
      try {
        if (!urlText.getText().startsWith(""String_Node_Str"") && !urlText.getText().startsWith(""String_Node_Str"")) {
          MessageBox mb=new MessageBox(parent,SWT.ICON_ERROR);
          mb.setText(""String_Node_Str"");
          mb.setMessage(""String_Node_Str"");
          mb.open();
          return;
        }
        YouTubeDownloader.download(folderText.getText(),urlText.getText().trim(),toMP3Checkbox.getSelection());
      }
 catch (      Exception ex) {
        MessageBox mb=new MessageBox(parent,SWT.ICON_ERROR);
        mb.setText(""String_Node_Str"");
        mb.setMessage(ex.getMessage());
        mb.open();
      }
    }
  }
);
  Composite c2=new Composite(parent,SWT.BORDER);
  c2.setLayoutData(new GridData(SWT.FILL,SWT.NONE,true,false));
  c2.setLayout(new GridLayout(2,false));
  updateButton=new Button(c2,SWT.PUSH);
  updateButton.setText(""String_Node_Str"");
  updateButton.addMouseListener(new MouseAdapter(){
    @Override public void mouseDown(    MouseEvent e){
      try {
        YouTubeDownloader.update();
      }
 catch (      Exception ex) {
        MessageBox mb=new MessageBox(parent,SWT.ICON_ERROR);
        mb.setText(""String_Node_Str"");
        mb.setMessage(ex.getMessage());
        mb.open();
      }
    }
  }
);
  Label authorLabel=new Label(c2,SWT.NONE);
  authorLabel.setLayoutData(new GridData(SWT.NONE,SWT.CENTER,false,false));
  authorLabel.setText(""String_Node_Str"");
}",0.9976196773340388
109158,"protected static IntBuffer updateIntBuffer(IntBuffer buf,int[] arr,boolean wrap){
  if (USE_DIRECT_BUFFERS) {
    if (buf == null || buf.capacity() < arr.length) {
      buf=PGL.allocateDirectIntBuffer(arr.length);
    }
    buf.position(0);
    buf.put(arr);
    buf.rewind();
  }
 else {
    if (wrap) {
      buf=IntBuffer.wrap(arr);
    }
 else {
      if (buf == null || buf.capacity() < arr.length) {
        buf=IntBuffer.allocate(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }
  return buf;
}","protected static void updateIntBuffer(IntBuffer buf,int[] arr,int offset,int size){
  if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
    buf.position(offset);
    buf.put(arr,offset,size);
    buf.rewind();
  }
}",0.2846153846153846
109159,"protected static FloatBuffer updateFloatBuffer(FloatBuffer buf,float[] arr,boolean wrap){
  if (USE_DIRECT_BUFFERS) {
    if (buf == null || buf.capacity() < arr.length) {
      buf=PGL.allocateDirectFloatBuffer(arr.length);
    }
    buf.position(0);
    buf.put(arr);
    buf.rewind();
  }
 else {
    if (wrap) {
      buf=FloatBuffer.wrap(arr);
    }
 else {
      if (buf == null || buf.capacity() < arr.length) {
        buf=FloatBuffer.allocate(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }
  return buf;
}","protected static void updateFloatBuffer(FloatBuffer buf,float[] arr,int offset,int size){
  if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
    buf.position(offset);
    buf.put(arr,offset,size);
    buf.rewind();
  }
}",0.2925
109160,"protected static ByteBuffer updateByteBuffer(ByteBuffer buf,byte[] arr,boolean wrap){
  if (USE_DIRECT_BUFFERS) {
    if (buf == null || buf.capacity() < arr.length) {
      buf=PGL.allocateDirectByteBuffer(arr.length);
    }
    buf.position(0);
    buf.put(arr);
    buf.rewind();
  }
 else {
    if (wrap) {
      buf=ByteBuffer.wrap(arr);
    }
 else {
      if (buf == null || buf.capacity() < arr.length) {
        buf=ByteBuffer.allocate(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }
  return buf;
}","protected static void updateByteBuffer(ByteBuffer buf,byte[] arr,int offset,int size){
  if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
    buf.position(offset);
    buf.put(arr,offset,size);
    buf.rewind();
  }
}",0.2810126582278481
109161,"protected static ShortBuffer updateShortBuffer(ShortBuffer buf,short[] arr,boolean wrap){
  if (USE_DIRECT_BUFFERS) {
    if (buf == null || buf.capacity() < arr.length) {
      buf=PGL.allocateDirectShortBuffer(arr.length);
    }
    buf.position(0);
    buf.put(arr);
    buf.rewind();
  }
 else {
    if (wrap) {
      buf=ShortBuffer.wrap(arr);
    }
 else {
      if (buf == null || buf.capacity() < arr.length) {
        buf=ShortBuffer.allocate(arr.length);
      }
      buf.position(0);
      buf.put(arr);
      buf.rewind();
    }
  }
  return buf;
}","protected static void updateShortBuffer(ShortBuffer buf,short[] arr,int offset,int size){
  if (USE_DIRECT_BUFFERS || (buf.hasArray() && buf.array() != arr)) {
    buf.position(offset);
    buf.put(arr,offset,size);
    buf.rewind();
  }
}",0.2925
109162,"/** 
 * Format this XML data as a String.
 * @webref xml:method
 * @brief Formats XML data as a String
 * @param indent -1 for a single line (and no declaration), >= 0 for indents and newlines
 * @return the content
 * @see XML#toString()
 */
public String format(int indent){
  try {
    boolean useIndentAmount=false;
    TransformerFactory factory=TransformerFactory.newInstance();
    if (indent != -1) {
      try {
        factory.setAttribute(""String_Node_Str"",indent);
      }
 catch (      IllegalArgumentException e) {
        useIndentAmount=true;
      }
    }
    Transformer transformer=factory.newTransformer();
    if (indent == -1 || parent == null) {
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
    }
 else {
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
    }
    transformer.setOutputProperty(OutputKeys.METHOD,""String_Node_Str"");
    if (useIndentAmount) {
      transformer.setOutputProperty(""String_Node_Str"",String.valueOf(indent));
    }
    transformer.setOutputProperty(OutputKeys.ENCODING,""String_Node_Str"");
    transformer.setOutputProperty(OutputKeys.INDENT,""String_Node_Str"");
    final String decl=""String_Node_Str"";
    StringWriter tempWriter=new StringWriter();
    StreamResult tempResult=new StreamResult(tempWriter);
    transformer.transform(new DOMSource(node),tempResult);
    String[] tempLines=PApplet.split(tempWriter.toString(),'\n');
    PApplet.println(tempLines);
    if (tempLines[0].startsWith(decl)) {
      int declEnd=tempLines[0].indexOf(""String_Node_Str"") + 2;
      if (tempLines[0].length() == declEnd) {
        PApplet.println(""String_Node_Str"");
        tempLines=PApplet.subset(tempLines,1);
      }
 else {
        PApplet.println(""String_Node_Str"");
        tempLines[0]=tempLines[0].substring(declEnd);
      }
    }
    String singleLine=PApplet.join(PApplet.trim(tempLines),""String_Node_Str"");
    if (indent == -1) {
      return singleLine;
    }
    StringWriter stringWriter=new StringWriter();
    StreamResult xmlOutput=new StreamResult(stringWriter);
    Source source=new StreamSource(new StringReader(singleLine));
    transformer.transform(source,xmlOutput);
    return decl + ""String_Node_Str"" + stringWriter.toString();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * Format this XML data as a String.
 * @webref xml:method
 * @brief Formats XML data as a String
 * @param indent -1 for a single line (and no declaration), >= 0 for indents and newlines
 * @return the content
 * @see XML#toString()
 */
public String format(int indent){
  try {
    boolean useIndentAmount=false;
    TransformerFactory factory=TransformerFactory.newInstance();
    if (indent != -1) {
      try {
        factory.setAttribute(""String_Node_Str"",indent);
      }
 catch (      IllegalArgumentException e) {
        useIndentAmount=true;
      }
    }
    Transformer transformer=factory.newTransformer();
    if (indent == -1 || parent == null) {
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
    }
 else {
      transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,""String_Node_Str"");
    }
    transformer.setOutputProperty(OutputKeys.METHOD,""String_Node_Str"");
    if (useIndentAmount) {
      transformer.setOutputProperty(""String_Node_Str"",String.valueOf(indent));
    }
    transformer.setOutputProperty(OutputKeys.ENCODING,""String_Node_Str"");
    transformer.setOutputProperty(OutputKeys.INDENT,""String_Node_Str"");
    final String decl=""String_Node_Str"";
    final String sep=System.getProperty(""String_Node_Str"");
    StringWriter tempWriter=new StringWriter();
    StreamResult tempResult=new StreamResult(tempWriter);
    transformer.transform(new DOMSource(node),tempResult);
    String[] tempLines=PApplet.split(tempWriter.toString(),sep);
    if (tempLines[0].startsWith(""String_Node_Str"")) {
      int declEnd=tempLines[0].indexOf(""String_Node_Str"") + 2;
      if (tempLines[0].length() == declEnd) {
        tempLines=PApplet.subset(tempLines,1);
      }
 else {
        tempLines[0]=tempLines[0].substring(declEnd);
      }
    }
    String singleLine=PApplet.join(PApplet.trim(tempLines),""String_Node_Str"");
    if (indent == -1) {
      return singleLine;
    }
    StringWriter stringWriter=new StringWriter();
    StreamResult xmlOutput=new StreamResult(stringWriter);
    Source source=new StreamSource(new StringReader(singleLine));
    transformer.transform(source,xmlOutput);
    return decl + sep + stringWriter.toString();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}",0.9467353951890034
109163,"/** 
 * Converts input array of Java ARGB values representing an image of width x height resolution to native OpenGL format (RGBA on big endian, BGRA on little endian). It also rearranges the elements in the array so that the image is flipped vertically.
 */
protected static void javaToNativeARGB(int[] pixels,int width,int height){
  int index=0;
  int yindex=(height - 1) * width;
  for (int y=0; y < height / 2; y++) {
    if (BIG_ENDIAN) {
      for (int x=0; x < width; x++) {
        int temp=pixels[index];
        pixels[index]=((pixels[yindex] >> 24) & 0xff) | ((pixels[yindex] << 8) & 0xffffff00);
        pixels[yindex]=((temp >> 24) & 0xff) | ((temp << 8) & 0xffffff00);
        index++;
        yindex++;
      }
    }
 else {
      for (int x=0; x < width; x++) {
        int temp=pixels[index];
        pixels[index]=(pixels[yindex] & 0xff000000) | ((pixels[yindex] << 16) & 0xff0000) | (pixels[yindex] & 0xff00)| ((pixels[yindex] >> 16) & 0xff);
        pixels[yindex]=(pixels[yindex] & 0xff000000) | ((temp << 16) & 0xff0000) | (temp & 0xff00)| ((temp >> 16) & 0xff);
        index++;
        yindex++;
      }
    }
    yindex-=width * 2;
  }
  if ((height % 2) == 1) {
    index=(height / 2) * width;
    if (BIG_ENDIAN) {
      for (int x=0; x < width; x++) {
        pixels[index]=((pixels[index] >> 24) & 0xff) | ((pixels[index] << 8) & 0xffffff00);
        index++;
      }
    }
 else {
      for (int x=0; x < width; x++) {
        pixels[index]=(pixels[index] & 0xff000000) | ((pixels[index] << 16) & 0xff0000) | (pixels[index] & 0xff00)| ((pixels[index] >> 16) & 0xff);
        index++;
      }
    }
  }
}","/** 
 * Converts input array of Java ARGB values representing an image of width x height resolution to native OpenGL format (RGBA on big endian, BGRA on little endian). It also rearranges the elements in the array so that the image is flipped vertically.
 */
protected static void javaToNativeARGB(int[] pixels,int width,int height){
  int index=0;
  int yindex=(height - 1) * width;
  for (int y=0; y < height / 2; y++) {
    if (BIG_ENDIAN) {
      for (int x=0; x < width; x++) {
        int temp=pixels[index];
        pixels[index]=((pixels[yindex] >> 24) & 0xff) | ((pixels[yindex] << 8) & 0xffffff00);
        pixels[yindex]=((temp >> 24) & 0xff) | ((temp << 8) & 0xffffff00);
        index++;
        yindex++;
      }
    }
 else {
      for (int x=0; x < width; x++) {
        int temp=pixels[index];
        pixels[index]=(pixels[yindex] & 0xff000000) | ((pixels[yindex] << 16) & 0xff0000) | (pixels[yindex] & 0xff00)| ((pixels[yindex] >> 16) & 0xff);
        pixels[yindex]=(temp & 0xff000000) | ((temp << 16) & 0xff0000) | (temp & 0xff00)| ((temp >> 16) & 0xff);
        index++;
        yindex++;
      }
    }
    yindex-=width * 2;
  }
  if ((height % 2) == 1) {
    index=(height / 2) * width;
    if (BIG_ENDIAN) {
      for (int x=0; x < width; x++) {
        pixels[index]=((pixels[index] >> 24) & 0xff) | ((pixels[index] << 8) & 0xffffff00);
        index++;
      }
    }
 else {
      for (int x=0; x < width; x++) {
        pixels[index]=(pixels[index] & 0xff000000) | ((pixels[index] << 16) & 0xff0000) | (pixels[index] & 0xff00)| ((pixels[index] >> 16) & 0xff);
        index++;
      }
    }
  }
}",0.994475138121547
109164,"protected void setDefaults(){
  inGeo.clear();
  tessGeo.clear();
  texCache.clear();
  super.noTexture();
  setDefaultBlend();
  if (hints[DISABLE_DEPTH_TEST]) {
    pgl.disable(PGL.DEPTH_TEST);
  }
 else {
    pgl.enable(PGL.DEPTH_TEST);
  }
  pgl.depthFunc(PGL.LEQUAL);
  if (hints[DISABLE_OPTIMIZED_STROKE]) {
    flushMode=FLUSH_CONTINUOUSLY;
  }
 else {
    flushMode=FLUSH_WHEN_FULL;
  }
  if (primarySurface) {
    pgl.getIntegerv(PGL.SAMPLES,intBuffer);
    int temp=intBuffer.get(0);
    if (quality != temp && 1 < temp && 1 < quality) {
      quality=temp;
    }
  }
  if (quality < 2) {
    pgl.disable(PGL.MULTISAMPLE);
  }
 else {
    pgl.enable(PGL.MULTISAMPLE);
  }
  pgl.disable(PGL.POINT_SMOOTH);
  pgl.disable(PGL.LINE_SMOOTH);
  pgl.disable(PGL.POLYGON_SMOOTH);
  viewport.put(0,0);
  viewport.put(1,0);
  viewport.put(2,width);
  viewport.put(3,height);
  pgl.viewport(viewport.get(0),viewport.get(1),viewport.get(2),viewport.get(3));
  if (sized) {
    background(backgroundColor);
    defaultPerspective();
    defaultCamera();
    sized=false;
  }
 else {
    modelview.set(camera);
    modelviewInv.set(cameraInv);
    updateProjmodelview();
  }
  if (is3D()) {
    noLights();
    lightFalloff(1,0,0);
    lightSpecular(0,0,0);
  }
  pgl.frontFace(PGL.CW);
  pgl.disable(PGL.CULL_FACE);
  pgl.activeTexture(PGL.TEXTURE0);
  normalX=normalY=normalZ=0;
  pgl.depthMask(true);
  pgl.clearDepth(1);
  pgl.clearStencil(0);
  pgl.clear(PGL.DEPTH_BUFFER_BIT | PGL.STENCIL_BUFFER_BIT);
  if (!settingsInited) {
    defaultSettings();
  }
  if (restoreSurface) {
    restoreSurfaceFromPixels();
    restoreSurface=false;
  }
  if (hints[DISABLE_DEPTH_MASK]) {
    pgl.depthMask(false);
  }
 else {
    pgl.depthMask(true);
  }
  pixelsOp=OP_NONE;
  modified=false;
  setgetPixels=false;
  clearColorBuffer0=clearColorBuffer;
  clearColorBuffer=false;
}","protected void setDefaults(){
  inGeo.clear();
  tessGeo.clear();
  texCache.clear();
  super.noTexture();
  setBlendMode(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    pgl.disable(PGL.DEPTH_TEST);
  }
 else {
    pgl.enable(PGL.DEPTH_TEST);
  }
  pgl.depthFunc(PGL.LEQUAL);
  if (hints[DISABLE_OPTIMIZED_STROKE]) {
    flushMode=FLUSH_CONTINUOUSLY;
  }
 else {
    flushMode=FLUSH_WHEN_FULL;
  }
  if (primarySurface) {
    pgl.getIntegerv(PGL.SAMPLES,intBuffer);
    int temp=intBuffer.get(0);
    if (quality != temp && 1 < temp && 1 < quality) {
      quality=temp;
    }
  }
  if (quality < 2) {
    pgl.disable(PGL.MULTISAMPLE);
  }
 else {
    pgl.enable(PGL.MULTISAMPLE);
  }
  pgl.disable(PGL.POINT_SMOOTH);
  pgl.disable(PGL.LINE_SMOOTH);
  pgl.disable(PGL.POLYGON_SMOOTH);
  viewport.put(0,0);
  viewport.put(1,0);
  viewport.put(2,width);
  viewport.put(3,height);
  pgl.viewport(viewport.get(0),viewport.get(1),viewport.get(2),viewport.get(3));
  if (sized) {
    background(backgroundColor);
    defaultPerspective();
    defaultCamera();
    sized=false;
  }
 else {
    modelview.set(camera);
    modelviewInv.set(cameraInv);
    updateProjmodelview();
  }
  if (is3D()) {
    noLights();
    lightFalloff(1,0,0);
    lightSpecular(0,0,0);
  }
  pgl.frontFace(PGL.CW);
  pgl.disable(PGL.CULL_FACE);
  pgl.activeTexture(PGL.TEXTURE0);
  normalX=normalY=normalZ=0;
  pgl.depthMask(true);
  pgl.clearDepth(1);
  pgl.clearStencil(0);
  pgl.clear(PGL.DEPTH_BUFFER_BIT | PGL.STENCIL_BUFFER_BIT);
  if (!settingsInited) {
    defaultSettings();
  }
  if (restoreSurface) {
    restoreSurfaceFromPixels();
    restoreSurface=false;
  }
  if (hints[DISABLE_DEPTH_MASK]) {
    pgl.depthMask(false);
  }
 else {
    pgl.depthMask(true);
  }
  pixelsOp=OP_NONE;
  modified=false;
  setgetPixels=false;
  clearColorBuffer0=clearColorBuffer;
  clearColorBuffer=false;
}",0.993048128342246
109165,"/** 
 * Allows to set custom blend modes for the entire scene, using openGL. Reference article about blending modes: http://www.pegtop.net/delphi/articles/blendmodes/ HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN modes cannot be implemented in fixed-function pipeline because they require conditional blending and non-linear blending equations.
 */
@Override public void blendMode(int mode){
  if (blendMode != mode) {
    flush();
    blendMode=mode;
    pgl.enable(PGL.BLEND);
    if (mode == REPLACE) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE,PGL.ZERO);
    }
 else     if (mode == BLEND) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.SRC_ALPHA,PGL.ONE_MINUS_SRC_ALPHA);
    }
 else     if (mode == ADD) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.SRC_ALPHA,PGL.ONE);
    }
 else     if (mode == SUBTRACT) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE_MINUS_DST_COLOR,PGL.ZERO);
    }
 else     if (mode == LIGHTEST) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_MAX);
        pgl.blendFunc(PGL.SRC_ALPHA,PGL.DST_ALPHA);
      }
 else {
        PGraphics.showWarning(BLEND_DRIVER_ERROR,""String_Node_Str"");
      }
    }
 else     if (mode == DARKEST) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_MIN);
        pgl.blendFunc(PGL.SRC_ALPHA,PGL.DST_ALPHA);
      }
 else {
        PGraphics.showWarning(BLEND_DRIVER_ERROR,""String_Node_Str"");
      }
    }
 else     if (mode == DIFFERENCE) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_REVERSE_SUBTRACT);
        pgl.blendFunc(PGL.ONE,PGL.ONE);
      }
 else {
        PGraphics.showWarning(BLEND_DRIVER_ERROR,""String_Node_Str"");
      }
    }
 else     if (mode == EXCLUSION) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE_MINUS_DST_COLOR,PGL.ONE_MINUS_SRC_COLOR);
    }
 else     if (mode == MULTIPLY) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.DST_COLOR,PGL.SRC_COLOR);
    }
 else     if (mode == SCREEN) {
      if (blendEqSupported) {
        pgl.blendEquation(PGL.FUNC_ADD);
      }
      pgl.blendFunc(PGL.ONE_MINUS_DST_COLOR,PGL.ONE);
    }
 else     if (mode == OVERLAY) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
 else     if (mode == HARD_LIGHT) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
 else     if (mode == SOFT_LIGHT) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
 else     if (mode == DODGE) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
 else     if (mode == BURN) {
      PGraphics.showWarning(BLEND_RENDERER_ERROR,""String_Node_Str"");
    }
  }
}","/** 
 * Allows to set custom blend modes for the entire scene, using openGL. Reference article about blending modes: http://www.pegtop.net/delphi/articles/blendmodes/ HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN modes cannot be implemented in fixed-function pipeline because they require conditional blending and non-linear blending equations.
 */
@Override public void blendMode(int mode){
  if (blendMode != mode) {
    flush();
    setBlendMode(mode);
  }
}",0.262561719430729
109166,"protected void restoreGL(){
  blendMode(blendMode);
  if (hints[DISABLE_DEPTH_TEST]) {
    pgl.disable(PGL.DEPTH_TEST);
  }
 else {
    pgl.enable(PGL.DEPTH_TEST);
  }
  pgl.depthFunc(PGL.LEQUAL);
  if (quality < 2) {
    pgl.disable(PGL.MULTISAMPLE);
  }
 else {
    pgl.enable(PGL.MULTISAMPLE);
    pgl.disable(PGL.POINT_SMOOTH);
    pgl.disable(PGL.LINE_SMOOTH);
    pgl.disable(PGL.POLYGON_SMOOTH);
  }
  pgl.viewport(viewport.get(0),viewport.get(1),viewport.get(2),viewport.get(3));
  if (clip) {
    pgl.enable(PGL.SCISSOR_TEST);
    pgl.scissor(clipRect[0],clipRect[1],clipRect[2],clipRect[3]);
  }
 else {
    pgl.disable(PGL.SCISSOR_TEST);
  }
  pgl.frontFace(PGL.CW);
  pgl.disable(PGL.CULL_FACE);
  pgl.activeTexture(PGL.TEXTURE0);
  if (hints[DISABLE_DEPTH_MASK]) {
    pgl.depthMask(false);
  }
 else {
    pgl.depthMask(true);
  }
  currentFramebuffer.bind();
  pgl.drawBuffer(currentFramebuffer.getDefaultDrawBuffer());
}","protected void restoreGL(){
  setBlendMode(blendMode);
  if (hints[DISABLE_DEPTH_TEST]) {
    pgl.disable(PGL.DEPTH_TEST);
  }
 else {
    pgl.enable(PGL.DEPTH_TEST);
  }
  pgl.depthFunc(PGL.LEQUAL);
  if (quality < 2) {
    pgl.disable(PGL.MULTISAMPLE);
  }
 else {
    pgl.enable(PGL.MULTISAMPLE);
    pgl.disable(PGL.POINT_SMOOTH);
    pgl.disable(PGL.LINE_SMOOTH);
    pgl.disable(PGL.POLYGON_SMOOTH);
  }
  pgl.viewport(viewport.get(0),viewport.get(1),viewport.get(2),viewport.get(3));
  if (clip) {
    pgl.enable(PGL.SCISSOR_TEST);
    pgl.scissor(clipRect[0],clipRect[1],clipRect[2],clipRect[3]);
  }
 else {
    pgl.disable(PGL.SCISSOR_TEST);
  }
  pgl.frontFace(PGL.CW);
  pgl.disable(PGL.CULL_FACE);
  pgl.activeTexture(PGL.TEXTURE0);
  if (hints[DISABLE_DEPTH_MASK]) {
    pgl.depthMask(false);
  }
 else {
    pgl.depthMask(true);
  }
  currentFramebuffer.bind();
  pgl.drawBuffer(currentFramebuffer.getDefaultDrawBuffer());
}",0.9973333333333332
109167,"protected void drawTexture(int x,int y,int w,int h){
  pgl.drawTexture(texture.glTarget,texture.glName,texture.glWidth,texture.glHeight,x,y,x + w,y + h,x,height - (y + h),x + w,height - y);
}","protected void drawTexture(int x,int y,int w,int h){
  pgl.disable(PGL.BLEND);
  pgl.drawTexture(texture.glTarget,texture.glName,texture.glWidth,texture.glHeight,x,y,x + w,y + h,x,height - (y + h),x + w,height - y);
  pgl.enable(PGL.BLEND);
}",0.8822170900692841
109168,"protected void parsePath(){
  family=PATH;
  kind=0;
  String pathData=element.getString(""String_Node_Str"");
  if (pathData == null || PApplet.trim(pathData).length() == 0) {
    return;
  }
  char[] pathDataChars=pathData.toCharArray();
  StringBuffer pathBuffer=new StringBuffer();
  boolean lastSeparate=false;
  for (int i=0; i < pathDataChars.length; i++) {
    char c=pathDataChars[i];
    boolean separate=false;
    if (c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'Z' || c == 'z' || c == ',') {
      separate=true;
      if (i != 0) {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c == 'Z' || c == 'z') {
      separate=false;
    }
    if (c == '-' && !lastSeparate) {
      if (i == 0 || pathDataChars[i - 1] != 'e') {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c != ',') {
      pathBuffer.append(c);
    }
    if (separate && c != ',' && c != '-') {
      pathBuffer.append(""String_Node_Str"");
    }
    lastSeparate=separate;
  }
  String[] pathTokens=PApplet.splitTokens(pathBuffer.toString(),""String_Node_Str"" + WHITESPACE);
  vertices=new float[pathTokens.length][2];
  vertexCodes=new int[pathTokens.length];
  float cx=0;
  float cy=0;
  int i=0;
  char implicitCommand='\0';
  boolean prevCurve=false;
  float ctrlX, ctrlY;
  while (i < pathTokens.length) {
    char c=pathTokens[i].charAt(0);
    if (((c >= '0' && c <= '9') || (c == '-')) && implicitCommand != '\0') {
      c=implicitCommand;
      i--;
    }
 else {
      implicitCommand=c;
    }
switch (c) {
case 'M':
      cx=PApplet.parseFloat(pathTokens[i + 1]);
    cy=PApplet.parseFloat(pathTokens[i + 2]);
  parsePathMoveto(cx,cy);
implicitCommand='L';
i+=3;
break;
case 'm':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
cy=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathMoveto(cx,cy);
implicitCommand='l';
i+=3;
break;
case 'L':
cx=PApplet.parseFloat(pathTokens[i + 1]);
cy=PApplet.parseFloat(pathTokens[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'l':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
cy=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'H':
cx=PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'h':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'V':
cy=PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'v':
cy=cy + PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'C':
{
float ctrlX1=PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY1=PApplet.parseFloat(pathTokens[i + 2]);
float ctrlX2=PApplet.parseFloat(pathTokens[i + 3]);
float ctrlY2=PApplet.parseFloat(pathTokens[i + 4]);
float endX=PApplet.parseFloat(pathTokens[i + 5]);
float endY=PApplet.parseFloat(pathTokens[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
prevCurve=true;
}
break;
case 'c':
{
float ctrlX1=cx + PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY1=cy + PApplet.parseFloat(pathTokens[i + 2]);
float ctrlX2=cx + PApplet.parseFloat(pathTokens[i + 3]);
float ctrlY2=cy + PApplet.parseFloat(pathTokens[i + 4]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 5]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
prevCurve=true;
}
break;
case 'S':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float ctrlX2=PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY2=PApplet.parseFloat(pathTokens[i + 2]);
float endX=PApplet.parseFloat(pathTokens[i + 3]);
float endY=PApplet.parseFloat(pathTokens[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 's':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float ctrlX2=cx + PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY2=cy + PApplet.parseFloat(pathTokens[i + 2]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 3]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'Q':
{
ctrlX=PApplet.parseFloat(pathTokens[i + 1]);
ctrlY=PApplet.parseFloat(pathTokens[i + 2]);
float endX=PApplet.parseFloat(pathTokens[i + 3]);
float endY=PApplet.parseFloat(pathTokens[i + 4]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'q':
{
ctrlX=cx + PApplet.parseFloat(pathTokens[i + 1]);
ctrlY=cy + PApplet.parseFloat(pathTokens[i + 2]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 3]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 4]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'T':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float endX=PApplet.parseFloat(pathTokens[i + 1]);
float endY=PApplet.parseFloat(pathTokens[i + 2]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
prevCurve=true;
}
break;
case 't':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float endX=cx + PApplet.parseFloat(pathTokens[i + 1]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
prevCurve=true;
}
break;
case 'Z':
case 'z':
close=true;
i++;
break;
default :
String parsed=PApplet.join(PApplet.subset(pathTokens,0,i),""String_Node_Str"");
String unparsed=PApplet.join(PApplet.subset(pathTokens,i),""String_Node_Str"");
System.err.println(""String_Node_Str"" + parsed);
System.err.println(""String_Node_Str"" + unparsed);
if (pathTokens[i].equals(""String_Node_Str"") || pathTokens[i].equals(""String_Node_Str"")) {
String msg=""String_Node_Str"" + ""String_Node_Str"";
throw new RuntimeException(msg);
}
throw new RuntimeException(""String_Node_Str"" + pathTokens[i]);
}
}
}","protected void parsePath(){
  family=PATH;
  kind=0;
  String pathData=element.getString(""String_Node_Str"");
  if (pathData == null || PApplet.trim(pathData).length() == 0) {
    return;
  }
  char[] pathDataChars=pathData.toCharArray();
  StringBuffer pathBuffer=new StringBuffer();
  boolean lastSeparate=false;
  for (int i=0; i < pathDataChars.length; i++) {
    char c=pathDataChars[i];
    boolean separate=false;
    if (c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'Z' || c == 'z' || c == ',') {
      separate=true;
      if (i != 0) {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c == 'Z' || c == 'z') {
      separate=false;
    }
    if (c == '-' && !lastSeparate) {
      if (i == 0 || pathDataChars[i - 1] != 'e') {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c != ',') {
      pathBuffer.append(c);
    }
    if (separate && c != ',' && c != '-') {
      pathBuffer.append(""String_Node_Str"");
    }
    lastSeparate=separate;
  }
  String[] pathTokens=PApplet.splitTokens(pathBuffer.toString(),""String_Node_Str"" + WHITESPACE);
  vertices=new float[pathTokens.length][2];
  vertexCodes=new int[pathTokens.length];
  float cx=0;
  float cy=0;
  int i=0;
  char implicitCommand='\0';
  boolean prevCurve=false;
  float ctrlX, ctrlY;
  float movetoX=0;
  float movetoY=0;
  while (i < pathTokens.length) {
    char c=pathTokens[i].charAt(0);
    if (((c >= '0' && c <= '9') || (c == '-')) && implicitCommand != '\0') {
      c=implicitCommand;
      i--;
    }
 else {
      implicitCommand=c;
    }
switch (c) {
case 'M':
      cx=PApplet.parseFloat(pathTokens[i + 1]);
    cy=PApplet.parseFloat(pathTokens[i + 2]);
  movetoX=cx;
movetoY=cy;
parsePathMoveto(cx,cy);
implicitCommand='L';
i+=3;
break;
case 'm':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
cy=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathMoveto(cx,cy);
implicitCommand='l';
i+=3;
break;
case 'L':
cx=PApplet.parseFloat(pathTokens[i + 1]);
cy=PApplet.parseFloat(pathTokens[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'l':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
cy=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'H':
cx=PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'h':
cx=cx + PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'V':
cy=PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'v':
cy=cy + PApplet.parseFloat(pathTokens[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'C':
{
float ctrlX1=PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY1=PApplet.parseFloat(pathTokens[i + 2]);
float ctrlX2=PApplet.parseFloat(pathTokens[i + 3]);
float ctrlY2=PApplet.parseFloat(pathTokens[i + 4]);
float endX=PApplet.parseFloat(pathTokens[i + 5]);
float endY=PApplet.parseFloat(pathTokens[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
prevCurve=true;
}
break;
case 'c':
{
float ctrlX1=cx + PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY1=cy + PApplet.parseFloat(pathTokens[i + 2]);
float ctrlX2=cx + PApplet.parseFloat(pathTokens[i + 3]);
float ctrlY2=cy + PApplet.parseFloat(pathTokens[i + 4]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 5]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
prevCurve=true;
}
break;
case 'S':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float ctrlX2=PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY2=PApplet.parseFloat(pathTokens[i + 2]);
float endX=PApplet.parseFloat(pathTokens[i + 3]);
float endY=PApplet.parseFloat(pathTokens[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 's':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float ctrlX2=cx + PApplet.parseFloat(pathTokens[i + 1]);
float ctrlY2=cy + PApplet.parseFloat(pathTokens[i + 2]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 3]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'Q':
{
ctrlX=PApplet.parseFloat(pathTokens[i + 1]);
ctrlY=PApplet.parseFloat(pathTokens[i + 2]);
float endX=PApplet.parseFloat(pathTokens[i + 3]);
float endY=PApplet.parseFloat(pathTokens[i + 4]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'q':
{
ctrlX=cx + PApplet.parseFloat(pathTokens[i + 1]);
ctrlY=cy + PApplet.parseFloat(pathTokens[i + 2]);
float endX=cx + PApplet.parseFloat(pathTokens[i + 3]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 4]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
prevCurve=true;
}
break;
case 'T':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float endX=PApplet.parseFloat(pathTokens[i + 1]);
float endY=PApplet.parseFloat(pathTokens[i + 2]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
prevCurve=true;
}
break;
case 't':
{
if (!prevCurve) {
ctrlX=cx;
ctrlY=cy;
}
 else {
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
ctrlX=px + (px - ppx);
ctrlY=py + (py - ppy);
}
float endX=cx + PApplet.parseFloat(pathTokens[i + 1]);
float endY=cy + PApplet.parseFloat(pathTokens[i + 2]);
parsePathQuadto(ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
prevCurve=true;
}
break;
case 'Z':
case 'z':
cx=movetoX;
cy=movetoY;
close=true;
i++;
break;
default :
String parsed=PApplet.join(PApplet.subset(pathTokens,0,i),""String_Node_Str"");
String unparsed=PApplet.join(PApplet.subset(pathTokens,i),""String_Node_Str"");
System.err.println(""String_Node_Str"" + parsed);
System.err.println(""String_Node_Str"" + unparsed);
if (pathTokens[i].equals(""String_Node_Str"") || pathTokens[i].equals(""String_Node_Str"")) {
String msg=""String_Node_Str"" + ""String_Node_Str"";
throw new RuntimeException(msg);
}
throw new RuntimeException(""String_Node_Str"" + pathTokens[i]);
}
}
}",0.9936903888481292
109169,"protected void beginDraw(boolean clear0){
  if (!clear0 && glColorFbo[0] != 0) {
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[backTex],0);
    usingFBOlayer=true;
  }
 else {
    usingFBOlayer=false;
  }
}","protected void beginDraw(boolean clear0){
  if ((!clear0 || FORCE_SCREEN_FBO) && glColorFbo[0] != 0) {
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[backTex],0);
    if (firstFrame) {
      GLES20.glClearColor(0,0,0,0);
      GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
    }
 else     if (!clear0) {
      drawTexture(GLES20.GL_TEXTURE_2D,glColorTex[frontTex],fboWidth,fboHeight,0,0,pg.width,pg.height,0,0,pg.width,pg.height);
    }
    usingFBOlayer=true;
  }
 else {
    usingFBOlayer=false;
  }
  if (firstFrame) {
    firstFrame=false;
  }
}",0.6647173489278753
109170,"protected void endDraw(boolean clear){
  if (usingFBOlayer) {
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
    GLES20.glClearDepthf(1);
    GLES20.glClearColor(0,0,0,0);
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
    GLES20.glDisable(GLES20.GL_BLEND);
    drawTexture(GLES20.GL_TEXTURE_2D,glColorTex[backTex],fboWidth,fboHeight,0,0,pg.width,pg.height,0,0,pg.width,pg.height);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    if (!clear) {
      GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[frontTex],0);
      drawTexture(GLES20.GL_TEXTURE_2D,glColorTex[backTex],fboWidth,fboHeight,0,0,pg.width,pg.height,0,0,pg.width,pg.height);
      GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[backTex],0);
    }
    int temp=frontTex;
    frontTex=backTex;
    backTex=temp;
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
  }
}","protected void endDraw(boolean clear){
  if (usingFBOlayer) {
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
    GLES20.glClearDepthf(1);
    GLES20.glClearColor(0,0,0,0);
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
    GLES20.glDisable(GLES20.GL_BLEND);
    drawTexture(GLES20.GL_TEXTURE_2D,glColorTex[backTex],fboWidth,fboHeight,0,0,pg.width,pg.height,0,0,pg.width,pg.height);
    int temp=frontTex;
    frontTex=backTex;
    backTex=temp;
  }
}",0.5876902713434812
109171,"protected void update(){
  if (!initialized) {
    String ext=GLES20.glGetString(GLES20.GL_EXTENSIONS);
    if (-1 < ext.indexOf(""String_Node_Str"")) {
      fboWidth=pg.width;
      fboHeight=pg.height;
    }
 else {
      fboWidth=PGL.nextPowerOfTwo(pg.width);
      fboHeight=PGL.nextPowerOfTwo(pg.height);
    }
    boolean packed=ext.indexOf(""String_Node_Str"") != -1;
    GLES20.glGenTextures(2,glColorTex,0);
    for (int i=0; i < 2; i++) {
      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,glColorTex[i]);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_NEAREST);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_NEAREST);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE);
      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_RGBA,fboWidth,fboHeight,0,PGL.RGBA,PGL.UNSIGNED_BYTE,null);
      initTexture(GLES20.GL_TEXTURE_2D,PGL.RGBA,fboWidth,fboHeight);
    }
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,0);
    GLES20.glGenFramebuffers(1,glColorFbo,0);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[0],0);
    if (packed) {
      int[] depthStencil={0};
      GLES20.glGenRenderbuffers(1,depthStencil,0);
      GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,depthStencil[0]);
      GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,DEPTH24_STENCIL8,fboWidth,fboHeight);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER,depthStencil[0]);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_STENCIL_ATTACHMENT,GLES20.GL_RENDERBUFFER,depthStencil[0]);
    }
 else {
      int[] depth={0};
      int[] stencil={0};
      GLES20.glGenRenderbuffers(1,depth,0);
      GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,depth[0]);
      GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,GLES20.GL_DEPTH_COMPONENT16,fboWidth,fboHeight);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER,depth[0]);
      int[] temp=new int[1];
      GLES20.glGetIntegerv(GLES20.GL_STENCIL_BITS,temp,0);
      int stencilBits=temp[0];
      if (stencilBits == 8) {
        GLES20.glGenRenderbuffers(1,stencil,0);
        GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,stencil[0]);
        GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,GLES20.GL_STENCIL_INDEX8,fboWidth,fboHeight);
        GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_STENCIL_ATTACHMENT,GLES20.GL_RENDERBUFFER,stencil[0]);
      }
    }
    validateFramebuffer();
    GLES20.glClearDepthf(1);
    GLES20.glClearStencil(0);
    GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_STENCIL_BUFFER_BIT);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
    PGraphicsOpenGL.drawFramebuffer.glFbo=0;
    backTex=0;
    frontTex=1;
    initialized=true;
  }
}","protected void update(){
  if (!initialized) {
    String ext=GLES20.glGetString(GLES20.GL_EXTENSIONS);
    if (-1 < ext.indexOf(""String_Node_Str"")) {
      fboWidth=pg.width;
      fboHeight=pg.height;
    }
 else {
      fboWidth=PGL.nextPowerOfTwo(pg.width);
      fboHeight=PGL.nextPowerOfTwo(pg.height);
    }
    boolean packed=ext.indexOf(""String_Node_Str"") != -1;
    int depthBits=getDepthBits();
    int stencilBits=getStencilBits();
    GLES20.glGenTextures(2,glColorTex,0);
    for (int i=0; i < 2; i++) {
      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,glColorTex[i]);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_NEAREST);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_NEAREST);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE);
      GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE);
      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_RGBA,fboWidth,fboHeight,0,PGL.RGBA,PGL.UNSIGNED_BYTE,null);
      initTexture(GLES20.GL_TEXTURE_2D,PGL.RGBA,fboWidth,fboHeight);
    }
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,0);
    backTex=0;
    frontTex=1;
    GLES20.glGenFramebuffers(1,glColorFbo,0);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,glColorFbo[0]);
    GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,glColorTex[backTex],0);
    if (packed && depthBits == 24 && stencilBits == 8) {
      int[] depthStencil={0};
      GLES20.glGenRenderbuffers(1,depthStencil,0);
      GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,depthStencil[0]);
      GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,DEPTH24_STENCIL8,fboWidth,fboHeight);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER,depthStencil[0]);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_STENCIL_ATTACHMENT,GLES20.GL_RENDERBUFFER,depthStencil[0]);
    }
 else {
      int[] depth={0};
      int[] stencil={0};
      GLES20.glGenRenderbuffers(1,depth,0);
      GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,depth[0]);
      GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,GLES20.GL_DEPTH_COMPONENT16,fboWidth,fboHeight);
      GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_DEPTH_ATTACHMENT,GLES20.GL_RENDERBUFFER,depth[0]);
      if (stencilBits == 8) {
        GLES20.glGenRenderbuffers(1,stencil,0);
        GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER,stencil[0]);
        GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER,GLES20.GL_STENCIL_INDEX8,fboWidth,fboHeight);
        GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER,GLES20.GL_STENCIL_ATTACHMENT,GLES20.GL_RENDERBUFFER,stencil[0]);
      }
    }
    validateFramebuffer();
    GLES20.glClearDepthf(1);
    GLES20.glClearStencil(0);
    GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_STENCIL_BUFFER_BIT);
    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0);
    initialized=true;
  }
}",0.9350566459230892
109172,"private final float cos(float angle){
  return (float)Math.cos(angle);
}","static private final float cos(float angle){
  return (float)Math.cos(angle);
}",0.9536423841059604
109173,"private final float sin(float angle){
  return (float)Math.sin(angle);
}","static private final float sin(float angle){
  return (float)Math.sin(angle);
}",0.9536423841059604
109174,"private final float max(float a,float b){
  return (a > b) ? a : b;
}","static private final float max(float a,float b){
  return (a > b) ? a : b;
}",0.9517241379310344
109175,"private final float abs(float a){
  return (a < 0) ? -a : a;
}","static private final float abs(float a){
  return (a < 0) ? -a : a;
}",0.9465648854961832
109176,"protected void handleKeyEvent(KeyEvent event){
switch (event.getAction()) {
case KeyEvent.PRESSED:
    keyPressed=true;
  keyPressed();
break;
case KeyEvent.RELEASED:
keyPressed=false;
keyReleased();
break;
}
if (event.getAction() == KeyEvent.PRESSED && event.getKeyCode() == android.view.KeyEvent.KEYCODE_BACK) {
exit();
}
}","protected void handleKeyEvent(KeyEvent event){
switch (event.getAction()) {
case KeyEvent.PRESSED:
    keyPressed=true;
  keyPressed();
break;
case KeyEvent.RELEASED:
keyPressed=false;
keyReleased();
break;
}
handleMethods(""String_Node_Str"",new Object[]{event});
if (event.getAction() == KeyEvent.PRESSED && event.getKeyCode() == android.view.KeyEvent.KEYCODE_BACK) {
exit();
}
}",0.9232954545454546
109177,"static protected void copyGeometry(PShape src,PShape dest){
  copyMatrix(src,dest);
  copyStyles(src,dest);
  copyImage(src,dest);
  if (src.style) {
    for (int i=0; i < src.vertexCount; i++) {
      float[] vert=src.vertices[i];
      dest.normal(vert[PGraphics.NX],vert[PGraphics.NY],vert[PGraphics.NZ]);
      dest.vertex(vert[X],vert[Y],vert[Z],vert[PGraphics.U],vert[PGraphics.V]);
    }
  }
 else {
    for (int i=0; i < src.vertexCount; i++) {
      float[] vert=src.vertices[i];
      if (vert[Z] == 0) {
        dest.vertex(vert[X],vert[Y]);
      }
 else {
        dest.vertex(vert[X],vert[Y],vert[Z]);
      }
    }
  }
  dest.end();
}","static protected void copyGeometry(PShape src,PShape dest){
  copyMatrix(src,dest);
  copyStyles(src,dest);
  copyImage(src,dest);
  if (src.style) {
    for (int i=0; i < src.vertexCount; i++) {
      float[] vert=src.vertices[i];
      dest.fill(vert[PGraphics.R] * 255,vert[PGraphics.G] * 255,vert[PGraphics.B] * 255,vert[PGraphics.A] * 255);
      if (0 < PApplet.dist(vert[PGraphics.NX],vert[PGraphics.NY],vert[PGraphics.NZ],0,0,0)) {
        dest.normal(vert[PGraphics.NX],vert[PGraphics.NY],vert[PGraphics.NZ]);
      }
      dest.vertex(vert[X],vert[Y],vert[Z],vert[PGraphics.U],vert[PGraphics.V]);
    }
  }
 else {
    for (int i=0; i < src.vertexCount; i++) {
      float[] vert=src.vertices[i];
      if (vert[Z] == 0) {
        dest.vertex(vert[X],vert[Y]);
      }
 else {
        dest.vertex(vert[X],vert[Y],vert[Z]);
      }
    }
  }
  dest.end();
}",0.845442536327609
109178,"protected void addChildren(ArrayList<OBJFace> faces,ArrayList<OBJMaterial> materials,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  int mtlIdxCur=-1;
  OBJMaterial mtl=null;
  for (int i=0; i < faces.size(); i++) {
    OBJFace face=faces.get(i);
    if (mtlIdxCur != face.matIdx) {
      mtlIdxCur=PApplet.max(0,face.matIdx);
      mtl=materials.get(mtlIdxCur);
    }
    PShape child=new PShapeOBJ(face,mtl,coords,normals,texcoords);
    addChild(child);
  }
}","protected void addChildren(ArrayList<OBJFace> faces,ArrayList<OBJMaterial> materials,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  int mtlIdxCur=-1;
  OBJMaterial mtl=null;
  for (int i=0; i < faces.size(); i++) {
    OBJFace face=faces.get(i);
    if (mtlIdxCur != face.matIdx || face.matIdx == -1) {
      mtlIdxCur=PApplet.max(0,face.matIdx);
      mtl=materials.get(mtlIdxCur);
    }
    PShape child=new PShapeOBJ(face,mtl,coords,normals,texcoords);
    addChild(child);
  }
}",0.9794319294809012
109179,"static protected void parseOBJ(PApplet parent,BufferedReader reader,ArrayList<OBJFace> faces,ArrayList<OBJMaterial> materials,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  Hashtable<String,Integer> mtlTable=new Hashtable<String,Integer>();
  int mtlIdxCur=-1;
  boolean readv, readvn, readvt;
  try {
    readv=readvn=readvt=false;
    String line;
    String gname=""String_Node_Str"";
    while ((line=reader.readLine()) != null) {
      while (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"")[0];
        final String s=reader.readLine();
        if (s != null)         line+=s;
      }
      String[] parts=line.split(""String_Node_Str"");
      if (parts.length > 0) {
        if (parts[0].equals(""String_Node_Str"")) {
          PVector tempv=new PVector(Float.valueOf(parts[1]).floatValue(),Float.valueOf(parts[2]).floatValue(),Float.valueOf(parts[3]).floatValue());
          coords.add(tempv);
          readv=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          PVector tempn=new PVector(Float.valueOf(parts[1]).floatValue(),Float.valueOf(parts[2]).floatValue(),Float.valueOf(parts[3]).floatValue());
          normals.add(tempn);
          readvn=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          PVector tempv=new PVector(Float.valueOf(parts[1]).floatValue(),1 - Float.valueOf(parts[2]).floatValue());
          texcoords.add(tempv);
          readvt=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          if (parts[1] != null) {
            BufferedReader mreader=parent.createReader(parts[1]);
            if (mreader != null) {
              parseMTL(parent,mreader,materials,mtlTable);
            }
          }
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          gname=1 < parts.length ? parts[1] : ""String_Node_Str"";
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          if (parts[1] != null) {
            String mtlname=parts[1];
            if (mtlTable.containsKey(mtlname)) {
              Integer tempInt=mtlTable.get(mtlname);
              mtlIdxCur=tempInt.intValue();
            }
 else {
              mtlIdxCur=-1;
            }
          }
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          OBJFace face=new OBJFace();
          face.matIdx=mtlIdxCur;
          face.name=gname;
          for (int i=1; i < parts.length; i++) {
            String seg=parts[i];
            if (seg.indexOf(""String_Node_Str"") > 0) {
              String[] forder=seg.split(""String_Node_Str"");
              if (forder.length > 2) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
                if (forder[1].length() > 0 && readvt) {
                  face.texIdx.add(Integer.valueOf(forder[1]));
                }
                if (forder[2].length() > 0 && readvn) {
                  face.normIdx.add(Integer.valueOf(forder[2]));
                }
              }
 else               if (forder.length > 1) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
                if (forder[1].length() > 0) {
                  if (readvt) {
                    face.texIdx.add(Integer.valueOf(forder[1]));
                  }
 else                   if (readvn) {
                    face.normIdx.add(Integer.valueOf(forder[1]));
                  }
                }
              }
 else               if (forder.length > 0) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
              }
            }
 else {
              if (seg.length() > 0 && readv) {
                face.vertIdx.add(Integer.valueOf(seg));
              }
            }
          }
          faces.add(face);
        }
      }
    }
    if (materials.size() == 0) {
      OBJMaterial defMtl=new OBJMaterial();
      materials.add(defMtl);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","static protected void parseOBJ(PApplet parent,BufferedReader reader,ArrayList<OBJFace> faces,ArrayList<OBJMaterial> materials,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  Hashtable<String,Integer> mtlTable=new Hashtable<String,Integer>();
  int mtlIdxCur=-1;
  boolean readv, readvn, readvt;
  try {
    readv=readvn=readvt=false;
    String line;
    String gname=""String_Node_Str"";
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if (line.equals(""String_Node_Str"") || line.indexOf('#') == 0) {
        continue;
      }
      while (line.contains(""String_Node_Str"")) {
        line=line.split(""String_Node_Str"")[0];
        final String s=reader.readLine();
        if (s != null)         line+=s;
      }
      String[] parts=line.split(""String_Node_Str"");
      if (parts.length > 0) {
        if (parts[0].equals(""String_Node_Str"")) {
          PVector tempv=new PVector(Float.valueOf(parts[1]).floatValue(),Float.valueOf(parts[2]).floatValue(),Float.valueOf(parts[3]).floatValue());
          coords.add(tempv);
          readv=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          PVector tempn=new PVector(Float.valueOf(parts[1]).floatValue(),Float.valueOf(parts[2]).floatValue(),Float.valueOf(parts[3]).floatValue());
          normals.add(tempn);
          readvn=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          PVector tempv=new PVector(Float.valueOf(parts[1]).floatValue(),1 - Float.valueOf(parts[2]).floatValue());
          texcoords.add(tempv);
          readvt=true;
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          if (parts[1] != null) {
            BufferedReader mreader=parent.createReader(parts[1]);
            if (mreader != null) {
              parseMTL(parent,mreader,materials,mtlTable);
            }
          }
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          gname=1 < parts.length ? parts[1] : ""String_Node_Str"";
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          if (parts[1] != null) {
            String mtlname=parts[1];
            if (mtlTable.containsKey(mtlname)) {
              Integer tempInt=mtlTable.get(mtlname);
              mtlIdxCur=tempInt.intValue();
            }
 else {
              mtlIdxCur=-1;
            }
          }
        }
 else         if (parts[0].equals(""String_Node_Str"")) {
          OBJFace face=new OBJFace();
          face.matIdx=mtlIdxCur;
          face.name=gname;
          for (int i=1; i < parts.length; i++) {
            String seg=parts[i];
            if (seg.indexOf(""String_Node_Str"") > 0) {
              String[] forder=seg.split(""String_Node_Str"");
              if (forder.length > 2) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
                if (forder[1].length() > 0 && readvt) {
                  face.texIdx.add(Integer.valueOf(forder[1]));
                }
                if (forder[2].length() > 0 && readvn) {
                  face.normIdx.add(Integer.valueOf(forder[2]));
                }
              }
 else               if (forder.length > 1) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
                if (forder[1].length() > 0) {
                  if (readvt) {
                    face.texIdx.add(Integer.valueOf(forder[1]));
                  }
 else                   if (readvn) {
                    face.normIdx.add(Integer.valueOf(forder[1]));
                  }
                }
              }
 else               if (forder.length > 0) {
                if (forder[0].length() > 0 && readv) {
                  face.vertIdx.add(Integer.valueOf(forder[0]));
                }
              }
            }
 else {
              if (seg.length() > 0 && readv) {
                face.vertIdx.add(Integer.valueOf(seg));
              }
            }
          }
          faces.add(face);
        }
      }
    }
    if (materials.size() == 0) {
      OBJMaterial defMtl=new OBJMaterial();
      materials.add(defMtl);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9860917941585536
109180,"protected PShapeOBJ(OBJFace face,OBJMaterial mtl,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  family=GEOMETRY;
  if (face.vertIdx.size() == 3) {
    kind=TRIANGLES;
  }
 else   if (face.vertIdx.size() == 4) {
    kind=QUADS;
  }
 else {
    kind=POLYGON;
  }
  fillColor=rgbaValue(mtl.kd);
  ambientColor=rgbaValue(mtl.ka);
  specularColor=rgbaValue(mtl.ks);
  shininess=mtl.ns;
  if (mtl.kdMap != null) {
    tintColor=rgbaValue(mtl.kd,mtl.d);
  }
  vertexCount=face.vertIdx.size();
  vertices=new float[vertexCount][12];
  for (int j=0; j < face.vertIdx.size(); j++) {
    int vertIdx, normIdx;
    PVector vert, norms;
    vert=norms=null;
    vertIdx=face.vertIdx.get(j).intValue() - 1;
    vert=coords.get(vertIdx);
    if (j < face.normIdx.size()) {
      normIdx=face.normIdx.get(j).intValue() - 1;
      if (-1 < normIdx) {
        norms=normals.get(normIdx);
      }
    }
    vertices[j][X]=vert.x;
    vertices[j][Y]=vert.y;
    vertices[j][Z]=vert.z;
    vertices[j][PGraphics.R]=mtl.kd.x;
    vertices[j][PGraphics.B]=mtl.kd.y;
    vertices[j][PGraphics.G]=mtl.kd.z;
    vertices[j][PGraphics.A]=1;
    if (norms != null) {
      vertices[j][PGraphics.NX]=norms.x;
      vertices[j][PGraphics.NY]=norms.y;
      vertices[j][PGraphics.NZ]=norms.z;
    }
    if (mtl != null && mtl.kdMap != null) {
      int texIdx;
      PVector tex=null;
      if (j < face.texIdx.size()) {
        texIdx=face.texIdx.get(j).intValue() - 1;
        if (-1 < texIdx) {
          tex=texcoords.get(texIdx);
        }
      }
      image=mtl.kdMap;
      if (tex != null) {
        vertices[j][PGraphics.U]=tex.x;
        vertices[j][PGraphics.V]=tex.y;
      }
    }
  }
}","protected PShapeOBJ(OBJFace face,OBJMaterial mtl,ArrayList<PVector> coords,ArrayList<PVector> normals,ArrayList<PVector> texcoords){
  family=GEOMETRY;
  if (face.vertIdx.size() == 3) {
    kind=TRIANGLES;
  }
 else   if (face.vertIdx.size() == 4) {
    kind=QUADS;
  }
 else {
    kind=POLYGON;
  }
  stroke=false;
  fill=true;
  fillColor=rgbaValue(mtl.kd);
  ambientColor=rgbaValue(mtl.ka);
  specularColor=rgbaValue(mtl.ks);
  shininess=mtl.ns;
  if (mtl.kdMap != null) {
    tintColor=rgbaValue(mtl.kd,mtl.d);
  }
  vertexCount=face.vertIdx.size();
  vertices=new float[vertexCount][12];
  for (int j=0; j < face.vertIdx.size(); j++) {
    int vertIdx, normIdx;
    PVector vert, norms;
    vert=norms=null;
    vertIdx=face.vertIdx.get(j).intValue() - 1;
    vert=coords.get(vertIdx);
    if (j < face.normIdx.size()) {
      normIdx=face.normIdx.get(j).intValue() - 1;
      if (-1 < normIdx) {
        norms=normals.get(normIdx);
      }
    }
    vertices[j][X]=vert.x;
    vertices[j][Y]=vert.y;
    vertices[j][Z]=vert.z;
    vertices[j][PGraphics.R]=mtl.kd.x;
    vertices[j][PGraphics.G]=mtl.kd.y;
    vertices[j][PGraphics.B]=mtl.kd.z;
    vertices[j][PGraphics.A]=1;
    if (norms != null) {
      vertices[j][PGraphics.NX]=norms.x;
      vertices[j][PGraphics.NY]=norms.y;
      vertices[j][PGraphics.NZ]=norms.z;
    }
    if (mtl != null && mtl.kdMap != null) {
      int texIdx;
      PVector tex=null;
      if (j < face.texIdx.size()) {
        texIdx=face.texIdx.get(j).intValue() - 1;
        if (-1 < texIdx) {
          tex=texcoords.get(texIdx);
        }
      }
      image=mtl.kdMap;
      if (tex != null) {
        vertices[j][PGraphics.U]=tex.x;
        vertices[j][PGraphics.V]=tex.y;
      }
    }
  }
}",0.990420899854862
109181,"static protected PShape loadShapeImpl(PGraphics pg,String filename,String extension){
  PShapeOBJ obj=null;
  if (extension.equals(""String_Node_Str"")) {
    obj=new PShapeOBJ(pg.parent,filename);
  }
 else   if (extension.equals(""String_Node_Str"")) {
    try {
      InputStream input=new GZIPInputStream(pg.parent.createInput(filename));
      obj=new PShapeOBJ(pg.parent,PApplet.createReader(input));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (obj != null) {
    boolean prevStroke=pg.stroke;
    int prevTextureMode=pg.textureMode;
    pg.stroke=false;
    pg.textureMode=NORMAL;
    PShapeOpenGL p3d=PShapeOpenGL.createShape3D(pg.parent,obj);
    pg.stroke=prevStroke;
    pg.textureMode=prevTextureMode;
    return p3d;
  }
 else {
    return null;
  }
}","static protected PShape loadShapeImpl(PGraphics pg,String filename,String extension){
  PShapeOBJ obj=null;
  if (extension.equals(""String_Node_Str"")) {
    obj=new PShapeOBJ(pg.parent,filename);
  }
 else   if (extension.equals(""String_Node_Str"")) {
    try {
      InputStream input=new GZIPInputStream(pg.parent.createInput(filename));
      obj=new PShapeOBJ(pg.parent,PApplet.createReader(input));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (obj != null) {
    int prevTextureMode=pg.textureMode;
    pg.textureMode=NORMAL;
    PShapeOpenGL p3d=PShapeOpenGL.createShape3D(pg.parent,obj);
    pg.textureMode=prevTextureMode;
    return p3d;
  }
 else {
    return null;
  }
}",0.9461077844311376
109182,"protected int getTypeFromVertexShader(String filename){
  String[] source=parent.loadStrings(filename);
  Pattern pointPattern=Pattern.compile(""String_Node_Str"");
  Pattern linePattern=Pattern.compile(""String_Node_Str"");
  Pattern lightPattern1=Pattern.compile(""String_Node_Str"");
  Pattern lightPattern2=Pattern.compile(""String_Node_Str"");
  Pattern texPattern=Pattern.compile(""String_Node_Str"");
  int type=PShader.COLOR;
  for (int i=0; i < source.length; i++) {
    boolean foundPoint=pointPattern.matcher(source[i]).find();
    boolean foundLine=linePattern.matcher(source[i]).find();
    boolean foundLight=lightPattern1.matcher(source[i]).find() || lightPattern2.matcher(source[i]).find();
    boolean foundTex=texPattern.matcher(source[i]).find();
    if (foundPoint) {
      type=PShader.POINT;
    }
 else     if (foundLine) {
      type=PShader.LINE;
    }
 else     if (foundLight && foundTex) {
      type=PShader.TEXLIGHT;
    }
 else     if (foundLight) {
      type=PShader.LIGHT;
    }
 else     if (foundTex) {
      type=PShader.TEXTURE;
    }
    if (type != PShader.COLOR)     break;
  }
  return type;
}","protected int getTypeFromVertexShader(String filename){
  String[] source=parent.loadStrings(filename);
  Pattern pointPattern=Pattern.compile(""String_Node_Str"");
  Pattern linePattern=Pattern.compile(""String_Node_Str"");
  Pattern lightPattern1=Pattern.compile(""String_Node_Str"");
  Pattern lightPattern2=Pattern.compile(""String_Node_Str"");
  Pattern texPattern=Pattern.compile(""String_Node_Str"");
  boolean foundPoint=false;
  boolean foundLine=false;
  boolean foundLight=false;
  boolean foundTex=false;
  for (int i=0; i < source.length; i++) {
    foundPoint|=pointPattern.matcher(source[i]).find();
    foundLine|=linePattern.matcher(source[i]).find();
    foundLight|=lightPattern1.matcher(source[i]).find();
    foundLight|=lightPattern2.matcher(source[i]).find();
    foundTex|=texPattern.matcher(source[i]).find();
  }
  int type=PShader.COLOR;
  if (foundPoint) {
    type=PShader.POINT;
  }
 else   if (foundLine) {
    type=PShader.LINE;
  }
 else   if (foundLight && foundTex) {
    type=PShader.TEXLIGHT;
  }
 else   if (foundLight) {
    type=PShader.LIGHT;
  }
 else   if (foundTex) {
    type=PShader.TEXTURE;
  }
  return type;
}",0.6106467223933129
109183,"public final float hue(int what){
  if (what != cacheHsbKey) {
    Color.RGBToHSV((what >> 16) & 0xff,(what >> 8) & 0xff,what & 0xff,cacheHsbValue);
    cacheHsbKey=what;
  }
  return cacheHsbValue[0] * colorModeX;
}","public final float hue(int what){
  if (what != cacheHsbKey) {
    Color.RGBToHSV((what >> 16) & 0xff,(what >> 8) & 0xff,what & 0xff,cacheHsbValue);
    cacheHsbKey=what;
  }
  return (cacheHsbValue[0] / 360f) * colorModeX;
}",0.979591836734694
109184,"public void setFrameRate(float framerate){
  pgl.setFramerate(framerate);
}","public void setFrameRate(float frameRate){
  pgl.setFrameRate(frameRate);
}",0.96
109185,"public Object initCache(PImage img){
  Texture tex=(Texture)img.getCache(pgPrimary);
  if (tex == null || tex.contextIsOutdated()) {
    tex=addTexture(img);
    img.loadPixels();
    tex.set(img.pixels);
  }
  return tex;
}","public Object initCache(PImage img){
  Texture tex=(Texture)img.getCache(pgPrimary);
  if (tex == null || tex.contextIsOutdated()) {
    tex=addTexture(img);
    if (tex != null) {
      img.loadPixels();
      tex.set(img.pixels);
    }
  }
  return tex;
}",0.8814968814968815
109186,"protected boolean bufferUpdate(int[] pixels){
  BufferData data=null;
  try {
    data=bufferCache.remove(0);
  }
 catch (  NoSuchElementException ex) {
    PGraphics.showWarning(""String_Node_Str"");
  }
  if (data != null) {
    if ((data.w != width) || (data.h != height)) {
      init(data.w,data.h);
    }
    bind();
    setNative(data.rgbBuf,0,0,width,height);
    unbind();
    data.rgbBuf.get(pixels);
    convertToARGB(pixels);
    data.dispose();
    return true;
  }
 else {
    return false;
  }
}","protected boolean bufferUpdate(int[] pixels){
  BufferData data=null;
  try {
    data=bufferCache.remove(0);
  }
 catch (  NoSuchElementException ex) {
    PGraphics.showWarning(""String_Node_Str"");
  }
  if (data != null) {
    if ((data.w != width) || (data.h != height)) {
      init(data.w,data.h);
    }
    setNative(data.rgbBuf,0,0,width,height);
    data.rgbBuf.get(pixels);
    convertToARGB(pixels);
    data.dispose();
    return true;
  }
 else {
    return false;
  }
}",0.9737373737373738
109187,"void addArc(float a,float b,float c,float d,float start,float stop,boolean fill,boolean stroke,int ellipseMode){
  float x=a;
  float y=b;
  float w=c;
  float h=d;
  if (ellipseMode == CORNERS) {
    w=c - a;
    h=d - b;
  }
 else   if (ellipseMode == RADIUS) {
    x=a - c;
    y=b - d;
    w=c * 2;
    h=d * 2;
  }
 else   if (ellipseMode == CENTER) {
    x=a - c / 2f;
    y=b - d / 2f;
  }
  if (Float.isInfinite(start) || Float.isInfinite(stop))   return;
  if (stop < start)   return;
  while (start < 0) {
    start+=TWO_PI;
    stop+=TWO_PI;
  }
  if (stop - start > TWO_PI) {
    start=0;
    stop=TWO_PI;
  }
  float hr=w / 2f;
  float vr=h / 2f;
  float centerX=x + hr;
  float centerY=y + vr;
  int startLUT=(int)(0.5f + (start / TWO_PI) * SINCOS_LENGTH);
  int stopLUT=(int)(0.5f + (stop / TWO_PI) * SINCOS_LENGTH);
  if (fill) {
    vertex(centerX,centerY,VERTEX);
  }
  int increment=1;
  int pidx, idx;
  pidx=idx=0;
  for (int i=startLUT; i < stopLUT; i+=increment) {
    int ii=i % SINCOS_LENGTH;
    if (ii < 0)     ii+=SINCOS_LENGTH;
    idx=addVertex(centerX + cosLUT[ii] * hr,centerY + sinLUT[ii] * vr,VERTEX);
    if (0 < i) {
      if (stroke)       addEdge(pidx,idx,i == 1,false);
    }
    pidx=idx;
  }
  idx=addVertex(centerX + cosLUT[stopLUT % SINCOS_LENGTH] * hr,centerY + sinLUT[stopLUT % SINCOS_LENGTH] * vr,VERTEX);
  if (stroke)   addEdge(pidx,idx,false,true);
}","void addArc(float a,float b,float c,float d,float start,float stop,boolean fill,boolean stroke,int ellipseMode){
  float x=a;
  float y=b;
  float w=c;
  float h=d;
  if (ellipseMode == CORNERS) {
    w=c - a;
    h=d - b;
  }
 else   if (ellipseMode == RADIUS) {
    x=a - c;
    y=b - d;
    w=c * 2;
    h=d * 2;
  }
 else   if (ellipseMode == CENTER) {
    x=a - c / 2f;
    y=b - d / 2f;
  }
  if (Float.isInfinite(start) || Float.isInfinite(stop))   return;
  if (stop < start)   return;
  while (start < 0) {
    start+=TWO_PI;
    stop+=TWO_PI;
  }
  if (stop - start > TWO_PI) {
    start=0;
    stop=TWO_PI;
  }
  float hr=w / 2f;
  float vr=h / 2f;
  float centerX=x + hr;
  float centerY=y + vr;
  int startLUT=(int)(0.5f + (start / TWO_PI) * SINCOS_LENGTH);
  int stopLUT=(int)(0.5f + (stop / TWO_PI) * SINCOS_LENGTH);
  if (fill) {
    vertex(centerX,centerY,VERTEX);
  }
  int increment=1;
  int pidx, idx;
  pidx=idx=0;
  for (int i=startLUT; i < stopLUT; i+=increment) {
    int ii=i % SINCOS_LENGTH;
    if (ii < 0)     ii+=SINCOS_LENGTH;
    idx=addVertex(centerX + cosLUT[ii] * hr,centerY + sinLUT[ii] * vr,VERTEX);
    if (startLUT < i) {
      if (stroke)       addEdge(pidx,idx,i == startLUT + 1,false);
    }
    pidx=idx;
  }
  idx=addVertex(centerX + cosLUT[stopLUT % SINCOS_LENGTH] * hr,centerY + sinLUT[stopLUT % SINCOS_LENGTH] * vr,VERTEX);
}",0.976173285198556
109188,"public void hint(int which){
  boolean oldValue=hints[which];
  super.hint(which);
  boolean newValue=hints[which];
  if (oldValue == newValue) {
    return;
  }
  if (which == DISABLE_DEPTH_TEST) {
    flush();
    pgl.disableDepthTest();
    pgl.setClearColor(0,0,0,0);
    pgl.clearDepthBuffer();
  }
 else   if (which == ENABLE_DEPTH_TEST) {
    flush();
    pgl.enableDepthTest();
  }
 else   if (which == DISABLE_DEPTH_MASK) {
    flush();
    pgl.disableDepthMask();
  }
 else   if (which == ENABLE_DEPTH_MASK) {
    flush();
    pgl.enableDepthMask();
  }
 else   if (which == DISABLE_ACCURATE_2D) {
    flush();
    setFlushMode(FLUSH_WHEN_FULL);
  }
 else   if (which == ENABLE_ACCURATE_2D) {
    flush();
    setFlushMode(FLUSH_CONTINUOUSLY);
  }
 else   if (which == DISABLE_TEXTURE_CACHE) {
    flush();
  }
 else   if (which == DISABLE_PERSPECTIVE_CORRECTED_LINES) {
    if (0 < tessGeo.lineVertexCount && 0 < tessGeo.lineIndexCount) {
      flush();
    }
  }
 else   if (which == ENABLE_PERSPECTIVE_CORRECTED_LINES) {
    if (0 < tessGeo.lineVertexCount && 0 < tessGeo.lineIndexCount) {
      flush();
    }
  }
}","public void hint(int which){
  boolean oldValue=which > 0 ? hints[which] : hints[-which];
  super.hint(which);
  boolean newValue=which > 0 ? hints[which] : hints[-which];
  if (oldValue == newValue) {
    return;
  }
  if (which == DISABLE_DEPTH_TEST) {
    flush();
    pgl.disableDepthTest();
    pgl.setClearColor(0,0,0,0);
    pgl.clearDepthBuffer();
  }
 else   if (which == ENABLE_DEPTH_TEST) {
    flush();
    pgl.enableDepthTest();
  }
 else   if (which == DISABLE_DEPTH_MASK) {
    flush();
    pgl.disableDepthMask();
  }
 else   if (which == ENABLE_DEPTH_MASK) {
    flush();
    pgl.enableDepthMask();
  }
 else   if (which == DISABLE_ACCURATE_2D) {
    flush();
    setFlushMode(FLUSH_WHEN_FULL);
  }
 else   if (which == ENABLE_ACCURATE_2D) {
    flush();
    setFlushMode(FLUSH_CONTINUOUSLY);
  }
 else   if (which == DISABLE_TEXTURE_CACHE) {
    flush();
  }
 else   if (which == DISABLE_PERSPECTIVE_CORRECTED_LINES) {
    if (0 < tessGeo.lineVertexCount && 0 < tessGeo.lineIndexCount) {
      flush();
    }
  }
 else   if (which == ENABLE_PERSPECTIVE_CORRECTED_LINES) {
    if (0 < tessGeo.lineVertexCount && 0 < tessGeo.lineIndexCount) {
      flush();
    }
  }
}",0.975799481417459
109189,"/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      HttpGet httpRequest=null;
      httpRequest=new HttpGet(URI.create(filename));
      HttpClient httpclient=new DefaultHttpClient();
      HttpResponse response=(HttpResponse)httpclient.execute(httpRequest);
      HttpEntity entity=response.getEntity();
      BufferedHttpEntity bufHttpEntity=new BufferedHttpEntity(entity);
      return bufHttpEntity.getContent();
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}","/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      HttpGet httpRequest=null;
      httpRequest=new HttpGet(URI.create(filename));
      HttpClient httpclient=new DefaultHttpClient();
      HttpResponse response=(HttpResponse)httpclient.execute(httpRequest);
      HttpEntity entity=response.getEntity();
      return entity.getContent();
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}",0.9719402985074628
109190,"public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    enableLighting();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][3]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightEnable(lightCount);
  lightNoAmbient(lightCount);
  lightDirection(lightCount);
  lightDiffuse(lightCount);
  lightSpecular(lightCount);
  lightFalloff(lightCount);
  lightNoSpot(lightCount);
  lightCount++;
}","public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    enableLighting();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][3]=currentLightSpecular[3];
  lightNormal[lightCount][0]=-nx;
  lightNormal[lightCount][1]=-ny;
  lightNormal[lightCount][2]=-nz;
  lightNormal[lightCount][3]=0.0f;
  lightEnable(lightCount);
  lightNoAmbient(lightCount);
  lightDirection(lightCount);
  lightDiffuse(lightCount);
  lightSpecular(lightCount);
  lightFalloff(lightCount);
  lightNoSpot(lightCount);
  lightCount++;
}",0.9233226837060704
109191,"/** 
 * More flexible method for dealing with camera(). <P> The actual call is like gluLookat. Here's the real skinny on what does what: <PRE> camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz); </PRE> do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used. <P> Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following: <PRE> beginCamera(); rotateY(PI / 8); endCamera(); </PRE> will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this: <PRE> beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera(); </PRE> That will rotate a little off of the default view. Note that this is entirely equivalent to <PRE> camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera(); </PRE> because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
 */
public void camera(float eyeX,float eyeY,float eyeZ,float centerX,float centerY,float centerZ,float upX,float upY,float upZ){
  eyeY=height - eyeY;
  centerY=height - centerY;
  float z0=eyeX - centerX;
  float z1=eyeY - centerY;
  float z2=eyeZ - centerZ;
  float mag=PApplet.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  if (mag != 0) {
    z0/=mag;
    z1/=mag;
    z2/=mag;
  }
  float y0=upX;
  float y1=upY;
  float y2=upZ;
  float x0=y1 * z2 - y2 * z1;
  float x1=-y0 * z2 + y2 * z0;
  float x2=y0 * z1 - y1 * z0;
  y0=z1 * x2 - z2 * x1;
  y1=-z0 * x2 + z2 * x0;
  y2=z0 * x1 - z1 * x0;
  mag=PApplet.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (mag != 0) {
    x0/=mag;
    x1/=mag;
    x2/=mag;
  }
  mag=PApplet.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (mag != 0) {
    y0/=mag;
    y1/=mag;
    y2/=mag;
  }
  float[] m=glmodelview;
  m[0]=x0;
  m[1]=y0;
  m[2]=z0;
  m[3]=0.0f;
  m[4]=x1;
  m[5]=y1;
  m[6]=z1;
  m[7]=0.0f;
  m[8]=x2;
  m[9]=y2;
  m[10]=z2;
  m[11]=0;
  m[12]=0.0f;
  m[13]=0.0f;
  m[14]=0.0f;
  m[15]=1.0f;
  float tx=-eyeX;
  float ty=-eyeY + height;
  float tz=-eyeZ;
  m[12]+=tx * m[0] + ty * m[4] + tz * m[8];
  m[13]+=tx * m[1] + ty * m[5] + tz * m[9];
  m[14]+=tx * m[2] + ty * m[6] + tz * m[10];
  m[15]+=tx * m[3] + ty * m[7] + tz * m[11];
  m[4]=-m[4];
  m[5]=-m[5];
  m[6]=-m[6];
  m[7]=-m[7];
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glLoadMatrixf(glmodelview,0);
  if (usingGLMatrixStack) {
    modelviewStack.set(glmodelview);
  }
  copyGLArrayToPMatrix(glmodelview,modelview);
  modelviewUpdated=true;
  calculateModelviewInvNoScaling();
  PApplet.arrayCopy(glmodelview,pcamera);
  PApplet.arrayCopy(glmodelviewInv,pcameraInv);
  copyGLArrayToPMatrix(pcamera,camera);
  copyGLArrayToPMatrix(pcameraInv,cameraInv);
}","/** 
 * More flexible method for dealing with camera(). <P> The actual call is like gluLookat. Here's the real skinny on what does what: <PRE> camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz); </PRE> do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used. <P> Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following: <PRE> beginCamera(); rotateY(PI / 8); endCamera(); </PRE> will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this: <PRE> beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera(); </PRE> That will rotate a little off of the default view. Note that this is entirely equivalent to <PRE> camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera(); </PRE> because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
 */
public void camera(float eyeX,float eyeY,float eyeZ,float centerX,float centerY,float centerZ,float upX,float upY,float upZ){
  float z0=eyeX - centerX;
  float z1=eyeY - centerY;
  float z2=eyeZ - centerZ;
  float mag=PApplet.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  if (mag != 0) {
    z0/=mag;
    z1/=mag;
    z2/=mag;
  }
  float y0=upX;
  float y1=upY;
  float y2=upZ;
  float x0=y1 * z2 - y2 * z1;
  float x1=-y0 * z2 + y2 * z0;
  float x2=y0 * z1 - y1 * z0;
  y0=z1 * x2 - z2 * x1;
  y1=-z0 * x2 + z2 * x0;
  y2=z0 * x1 - z1 * x0;
  mag=PApplet.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (mag != 0) {
    x0/=mag;
    x1/=mag;
    x2/=mag;
  }
  mag=PApplet.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (mag != 0) {
    y0/=mag;
    y1/=mag;
    y2/=mag;
  }
  float[] m=glmodelview;
  m[0]=x0;
  m[1]=y0;
  m[2]=z0;
  m[3]=0.0f;
  m[4]=x1;
  m[5]=y1;
  m[6]=z1;
  m[7]=0.0f;
  m[8]=x2;
  m[9]=y2;
  m[10]=z2;
  m[11]=0;
  m[12]=0.0f;
  m[13]=0.0f;
  m[14]=0.0f;
  m[15]=1.0f;
  float tx=-eyeX;
  float ty=-eyeY;
  float tz=-eyeZ;
  m[12]+=tx * m[0] + ty * m[4] + tz * m[8];
  m[13]+=tx * m[1] + ty * m[5] + tz * m[9];
  m[14]+=tx * m[2] + ty * m[6] + tz * m[10];
  m[15]+=tx * m[3] + ty * m[7] + tz * m[11];
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glLoadMatrixf(glmodelview,0);
  if (usingGLMatrixStack) {
    modelviewStack.set(glmodelview);
  }
  copyGLArrayToPMatrix(glmodelview,modelview);
  modelviewUpdated=true;
  calculateModelviewInvNoScaling();
  PApplet.arrayCopy(glmodelview,pcamera);
  PApplet.arrayCopy(glmodelviewInv,pcameraInv);
  copyGLArrayToPMatrix(pcamera,camera);
  copyGLArrayToPMatrix(pcameraInv,cameraInv);
}",0.9832824538450357
109192,"/** 
 * Same as glFrustum(), except that it wipes out (rather than multiplies against) the current perspective matrix. <P> Implementation based on the explanation in the OpenGL blue book.
 */
public void frustum(float left,float right,float bottom,float top,float znear,float zfar){
  float temp, temp2, temp3, temp4;
  temp=2.0f * znear;
  temp2=right - left;
  temp3=top - bottom;
  temp4=zfar - znear;
  glprojection[0]=temp / temp2;
  glprojection[1]=0.0f;
  glprojection[2]=0.0f;
  glprojection[3]=0.0f;
  glprojection[4]=0.0f;
  glprojection[5]=temp / temp3;
  glprojection[6]=0.0f;
  glprojection[7]=0.0f;
  glprojection[8]=(right + left) / temp2;
  glprojection[9]=(top + bottom) / temp3;
  glprojection[10]=(-zfar - znear) / temp4;
  glprojection[11]=-1.0f;
  glprojection[12]=0.0f;
  glprojection[13]=0.0f;
  glprojection[14]=(-temp * zfar) / temp4;
  glprojection[15]=0.0f;
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadMatrixf(glprojection,0);
  copyGLArrayToPMatrix(glprojection,projection);
  projectionUpdated=true;
  PApplet.arrayCopy(glprojection,pprojection);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
}","/** 
 * Same as glFrustum(), except that it wipes out (rather than multiplies against) the current perspective matrix. <P> Implementation based on the explanation in the OpenGL blue book.
 */
public void frustum(float left,float right,float bottom,float top,float znear,float zfar){
  float temp, temp2, temp3, temp4;
  temp=2.0f * znear;
  temp2=right - left;
  temp3=top - bottom;
  temp4=zfar - znear;
  glprojection[0]=temp / temp2;
  glprojection[1]=0.0f;
  glprojection[2]=0.0f;
  glprojection[3]=0.0f;
  glprojection[4]=0.0f;
  glprojection[5]=-temp / temp3;
  glprojection[6]=0.0f;
  glprojection[7]=0.0f;
  glprojection[8]=(right + left) / temp2;
  glprojection[9]=(top + bottom) / temp3;
  glprojection[10]=(-zfar - znear) / temp4;
  glprojection[11]=-1.0f;
  glprojection[12]=0.0f;
  glprojection[13]=0.0f;
  glprojection[14]=(-temp * zfar) / temp4;
  glprojection[15]=0.0f;
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadMatrixf(glprojection,0);
  copyGLArrayToPMatrix(glprojection,projection);
  projectionUpdated=true;
  PApplet.arrayCopy(glprojection,pprojection);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
}",0.9995541685242978
109193,"public void beginShape(int kind){
  shape=kind;
  if (hints[ENABLE_DEPTH_SORT]) {
    shapeFirst=vertexCount;
    shapeLast=0;
  }
 else {
    vertexCount=0;
    pathCount=0;
    faceCount=0;
    pointCount=0;
    lineCount=0;
    triangleCount=0;
  }
  shapeTextures=0;
  noTexture();
}","public void beginShape(int kind){
  shape=kind;
  if (hints[ENABLE_DEPTH_SORT]) {
    shapeFirst=vertexCount;
    shapeLast=0;
  }
 else {
    vertexCount=0;
    curveVertexCount=0;
    pathCount=0;
    faceCount=0;
    pointCount=0;
    lineCount=0;
    triangleCount=0;
  }
  shapeTextures=0;
  noTexture();
}",0.959866220735786
109194,"public void endDraw(){
  if (primarySurface) {
    Canvas screen=null;
    try {
      screen=parent.getSurfaceHolder().lockCanvas(null);
      if (screen != null) {
        screen.drawBitmap(bitmap,new Matrix(),null);
      }
    }
  finally {
      if (screen != null) {
        parent.getSurfaceHolder().unlockCanvasAndPost(screen);
      }
    }
  }
  if (!primarySurface) {
    loadPixels();
  }
  modified=true;
}","public void endDraw(){
  if (primarySurface) {
    Canvas screen=null;
    try {
      screen=parent.getSurfaceHolder().lockCanvas(null);
      if (screen != null) {
        screen.drawBitmap(bitmap,new Matrix(),null);
      }
    }
  finally {
      if (screen != null) {
        parent.getSurfaceHolder().unlockCanvasAndPost(screen);
      }
    }
  }
 else {
    loadPixels();
  }
  setModified();
  super.updatePixels();
}",0.9041420118343196
109195,"public void rect(float a,float b,float c,float d,float tl,float tr,float br,float bl){
  float hradius, vradius;
switch (rectMode) {
case CORNERS:
    break;
case CORNER:
  c+=a;
d+=b;
break;
case RADIUS:
hradius=c;
vradius=d;
c=a + hradius;
d=b + vradius;
a-=hradius;
b-=vradius;
break;
case CENTER:
hradius=c / 2.0f;
vradius=d / 2.0f;
c=a + hradius;
d=b + vradius;
a-=hradius;
b-=vradius;
}
if (a > c) {
float temp=a;
a=c;
c=temp;
}
if (b > d) {
float temp=b;
b=d;
d=temp;
}
rectImpl(a,b,c,d,tl,tr,br,bl);
}","public void rect(float a,float b,float c,float d,float tl,float tr,float br,float bl){
  float hradius, vradius;
switch (rectMode) {
case CORNERS:
    break;
case CORNER:
  c+=a;
d+=b;
break;
case RADIUS:
hradius=c;
vradius=d;
c=a + hradius;
d=b + vradius;
a-=hradius;
b-=vradius;
break;
case CENTER:
hradius=c / 2.0f;
vradius=d / 2.0f;
c=a + hradius;
d=b + vradius;
a-=hradius;
b-=vradius;
}
if (a > c) {
float temp=a;
a=c;
c=temp;
}
if (b > d) {
float temp=b;
b=d;
d=temp;
}
float maxRounding=PApplet.min((c - a) / 2,(d - b) / 2);
if (tl > maxRounding) tl=maxRounding;
if (tr > maxRounding) tr=maxRounding;
if (br > maxRounding) br=maxRounding;
if (bl > maxRounding) bl=maxRounding;
rectImpl(a,b,c,d,tl,tr,br,bl);
}",0.8303425774877651
109196,"protected PImage getImpl(int x,int y,int w,int h){
  PImage newbie=parent.createImage(w,h,ARGB);
  PTexture newbieTex=addTexture(newbie);
  IntBuffer newbieBuffer=IntBuffer.allocate(w * h);
  gl.glReadPixels(x,height - y,w,-h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,newbieBuffer);
  copyToTexture(newbieTex,newbieBuffer,0,0,w,h);
  newbie.loadPixels();
  newbieTex.get(newbie.pixels);
  return newbie;
}","protected PImage getImpl(int x,int y,int w,int h){
  PImage newbie=parent.createImage(w,h,ARGB);
  PTexture newbieTex=addTexture(newbie);
  IntBuffer newbieBuffer=IntBuffer.allocate(w * h);
  boolean nonCurrent=!primarySurface && offscreenFramebuffer != currentFramebuffer;
  if (nonCurrent) {
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
  }
  gl.glReadPixels(x,height - y - h,w,h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,newbieBuffer);
  if (nonCurrent) {
    popFramebuffer();
  }
  copyToTexture(newbieTex,newbieBuffer,0,0,w,h);
  newbie.loadPixels();
  newbieTex.flippedY=true;
  newbieTex.get(newbie.pixels);
  return newbie;
}",0.7559808612440191
109197,"protected void loadTextureImpl(int sampling){
  if (width == 0 || height == 0)   return;
  if (texture == null) {
    PTexture.Parameters params=PTexture.newParameters(ARGB,sampling);
    texture=new PTexture(parent,width,height,params);
    texture.setFlippedY(true);
    this.setCache(a3d,texture);
    this.setParams(a3d,params);
    texCrop=new int[4];
    texCrop[0]=0;
    texCrop[1]=0;
    texCrop[2]=width;
    texCrop[3]=height;
  }
}","protected void loadTextureImpl(int sampling){
  if (width == 0 || height == 0)   return;
  if (texture == null) {
    PTexture.Parameters params=PTexture.newParameters(ARGB,sampling);
    texture=new PTexture(parent,width,height,params);
    texture.setFlippedY(true);
    this.setCache(a3d,texture);
    this.setParams(a3d,params);
    texCrop=new int[4];
    texCrop[0]=0;
    texCrop[1]=height;
    texCrop[2]=width;
    texCrop[3]=-height;
  }
}",0.9910313901345292
109198,"/** 
 * Remove the shape with index idx.
 */
public void removeChild(int idx){
  if (idx < childCount) {
    PShape child=children[idx];
    for (int i=idx; i < childCount - 1; i++) {
      children[i]=children[i + 1];
    }
    childCount--;
    if (child.getName() != null && nameTable != null) {
      nameTable.remove(child.getName());
    }
  }
}","/** 
 * Remove the child shape with index idx.
 */
public void removeChild(int idx){
  if (idx < childCount) {
    PShape child=children[idx];
    for (int i=idx; i < childCount - 1; i++) {
      children[i]=children[i + 1];
    }
    childCount--;
    if (child.getName() != null && nameTable != null) {
      nameTable.remove(child.getName());
    }
  }
}",0.9915254237288136
109199,"protected void drawPath(PGraphics g){
  if (vertices == null)   return;
  g.beginShape();
  if (vertexCodeCount == 0) {
    if (vertices[0].length == 2) {
      for (int i=0; i < vertexCount; i++) {
        g.vertex(vertices[i][X],vertices[i][Y]);
      }
    }
 else {
      for (int i=0; i < vertexCount; i++) {
        g.vertex(vertices[i][X],vertices[i][Y],vertices[i][Z]);
      }
    }
  }
 else {
    int index=0;
    if (vertices[0].length == 2) {
      for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
          g.vertex(vertices[index][X],vertices[index][Y]);
        index++;
      break;
case BEZIER_VERTEX:
    g.bezierVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 2][X],vertices[index + 2][Y]);
  index+=3;
break;
case CURVE_VERTEX:
g.curveVertex(vertices[index][X],vertices[index][Y]);
index++;
case BREAK:
g.breakShape();
}
}
}
 else {
for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
g.vertex(vertices[index][X],vertices[index][Y],vertices[index][Z]);
index++;
break;
case BEZIER_VERTEX:
g.bezierVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 0][Z],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 1][Z],vertices[index + 2][X],vertices[index + 2][Y],vertices[index + 2][Z]);
index+=3;
break;
case CURVE_VERTEX:
g.curveVertex(vertices[index][X],vertices[index][Y],vertices[index][Z]);
index++;
case BREAK:
g.breakShape();
}
}
}
}
g.endShape(close ? CLOSE : OPEN);
}","protected void drawPath(PGraphics g){
  if (vertices == null)   return;
  g.beginShape();
  if (vertexCodeCount == 0) {
    if (vertices[0].length == 2) {
      for (int i=0; i < vertexCount; i++) {
        g.vertex(vertices[i][X],vertices[i][Y]);
      }
    }
 else {
      for (int i=0; i < vertexCount; i++) {
        g.vertex(vertices[i][X],vertices[i][Y],vertices[i][Z]);
      }
    }
  }
 else {
    int index=0;
    if (vertices[0].length == 2) {
      for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
          g.vertex(vertices[index][X],vertices[index][Y]);
        index++;
      break;
case QUAD_BEZIER_VERTEX:
    g.quadVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 1][X],vertices[index + 1][Y]);
  index+=2;
break;
case BEZIER_VERTEX:
g.bezierVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 2][X],vertices[index + 2][Y]);
index+=3;
break;
case CURVE_VERTEX:
g.curveVertex(vertices[index][X],vertices[index][Y]);
index++;
case BREAK:
g.breakShape();
}
}
}
 else {
for (int j=0; j < vertexCodeCount; j++) {
switch (vertexCodes[j]) {
case VERTEX:
g.vertex(vertices[index][X],vertices[index][Y],vertices[index][Z]);
index++;
break;
case QUAD_BEZIER_VERTEX:
g.quadVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 0][Z],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 0][Z]);
index+=2;
break;
case BEZIER_VERTEX:
g.bezierVertex(vertices[index + 0][X],vertices[index + 0][Y],vertices[index + 0][Z],vertices[index + 1][X],vertices[index + 1][Y],vertices[index + 1][Z],vertices[index + 2][X],vertices[index + 2][Y],vertices[index + 2][Z]);
index+=3;
break;
case CURVE_VERTEX:
g.curveVertex(vertices[index][X],vertices[index][Y],vertices[index][Z]);
index++;
case BREAK:
g.breakShape();
}
}
}
}
g.endShape(close ? CLOSE : OPEN);
}",0.8990719257540604
109200,"/** 
 * Add a shape to the name lookup table.
 */
protected void addName(String nom,PShape shape){
  if (parent != null) {
    parent.addName(nom,shape);
  }
 else {
    if (nameTable == null) {
      nameTable=new HashMap<String,PShape>();
    }
    nameTable.put(nom,shape);
  }
}","/** 
 * Add a shape to the name lookup table.
 */
public void addName(String nom,PShape shape){
  if (parent != null) {
    parent.addName(nom,shape);
  }
 else {
    if (nameTable == null) {
      nameTable=new HashMap<String,PShape>();
    }
    nameTable.put(nom,shape);
  }
}",0.9803921568627452
109201,"/** 
 * Add a shape to the name lookup table.
 */
protected void addName(String nom,PShape shape){
  if (nameTable == null) {
    nameTable=new HashMap<String,PShape>();
  }
  nameTable.put(nom,shape);
}","/** 
 * Add a shape to the name lookup table.
 */
public void addName(String nom,PShape shape){
  if (nameTable == null) {
    nameTable=new HashMap<String,PShape>();
  }
  nameTable.put(nom,shape);
}",0.9727047146401984
109202,"public PShape groupChildren(PShape[] gchildren,String gname){
  if (family != GROUP)   return null;
  PShape3D group=new PShape3D();
  group.family=PShape.GROUP;
  group.name=gname;
  group.papplet=papplet;
  group.a3d=a3d;
  group.gl=gl;
  group.root=root;
  PShape child, p;
  int idx;
  child=gchildren[0];
  p=child.parent;
  if (p != null) {
    idx=p.getChildIdx(child);
    if (idx < 0)     idx=0;
  }
 else {
    p=this;
    idx=0;
  }
  p.addChild(group,idx);
  for (int i=0; i < gchildren.length; i++) {
    child=gchildren[i];
    p=child.parent;
    if (p != null) {
      idx=p.getChildIdx(child);
      if (-1 < idx) {
        p.removeChild(idx);
      }
    }
  }
  group.firstVertex=root.vertexCount;
  group.lastVertex=0;
  for (int i=0; i < gchildren.length; i++) {
    group.firstVertex=PApplet.min(group.firstVertex,((PShape3D)gchildren[i]).firstVertex);
    group.lastVertex=PApplet.max(group.lastVertex,((PShape3D)gchildren[i]).lastVertex);
  }
  for (int i=0; i < gchildren.length; i++) {
    group.addChildImpl(gchildren[i],false);
  }
  return group;
}","public PShape groupChildren(PShape[] gchildren,String gname){
  if (family != GROUP)   return null;
  PShape3D group=new PShape3D();
  group.family=PShape.GROUP;
  group.name=gname;
  group.papplet=papplet;
  group.a3d=a3d;
  group.gl=gl;
  group.root=root;
  PShape child, p;
  int idx;
  child=gchildren[0];
  p=child.parent;
  if (p != null) {
    idx=p.getChildIndex(child);
    if (idx < 0)     idx=0;
  }
 else {
    p=this;
    idx=0;
  }
  p.addChild(group,idx);
  for (int i=0; i < gchildren.length; i++) {
    child=gchildren[i];
    p=child.parent;
    if (p != null) {
      idx=p.getChildIndex(child);
      if (-1 < idx) {
        p.removeChild(idx);
      }
    }
  }
  group.firstVertex=root.vertexCount;
  group.lastVertex=0;
  for (int i=0; i < gchildren.length; i++) {
    group.firstVertex=PApplet.min(group.firstVertex,((PShape3D)gchildren[i]).firstVertex);
    group.lastVertex=PApplet.max(group.lastVertex,((PShape3D)gchildren[i]).lastVertex);
  }
  for (int i=0; i < gchildren.length; i++) {
    group.addChildImpl(gchildren[i],false);
  }
  return group;
}",0.9962928637627432
109203,"/** 
 * Draw a sphere with radius r centered at coordinate 0, 0, 0. <P> Implementation notes: <P> cache all the points of the sphere in a static array top and bottom are just a bunch of triangles that land in the center point <P> sphere is a series of concentric circles who radii vary along the shape, based on, er.. cos or something <PRE> [toxi 031031] new sphere code. removed all multiplies with radius, as scale() will take care of that anyway [toxi 031223] updated sphere code (removed modulos) and introduced sphereAt(x,y,z,r) to avoid additional translate()'s on the user/sketch side [davbol 080801] now using separate sphereDetailU/V </PRE>
 */
public void sphere(float r){
  if ((sphereDetailU < 3) || (sphereDetailV < 2)) {
    sphereDetail(30);
  }
  edge(false);
  beginShape(TRIANGLE_STRIP);
  for (int i=0; i < sphereDetailU; i++) {
    normal(0,-1,0);
    vertex(0,-r,0);
    normal(sphereX[i],sphereY[i],sphereZ[i]);
    vertex(r * sphereX[i],r * sphereY[i],r * sphereZ[i]);
  }
  vertex(0,-r,0);
  normal(sphereX[0],sphereY[0],sphereZ[0]);
  vertex(r * sphereX[0],r * sphereY[0],r * sphereZ[0]);
  endShape();
  int v1, v11, v2;
  int voff=0;
  for (int i=2; i < sphereDetailV; i++) {
    v1=v11=voff;
    voff+=sphereDetailU;
    v2=voff;
    beginShape(TRIANGLE_STRIP);
    for (int j=0; j < sphereDetailU; j++) {
      normal(sphereX[v1],sphereY[v1],sphereZ[v1]);
      vertex(r * sphereX[v1],r * sphereY[v1],r * sphereZ[v1++]);
      normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
      vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2++]);
    }
    v1=v11;
    v2=voff;
    normal(sphereX[v1],sphereY[v1],sphereZ[v1]);
    vertex(r * sphereX[v1],r * sphereY[v1],r * sphereZ[v1]);
    normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
    vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2]);
    endShape();
  }
  beginShape(TRIANGLE_STRIP);
  for (int i=0; i < sphereDetailU; i++) {
    v2=voff + i;
    normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
    vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2]);
    normal(0,1,0);
    vertex(0,r,0);
  }
  normal(sphereX[voff],sphereY[voff],sphereZ[voff]);
  vertex(r * sphereX[voff],r * sphereY[voff],r * sphereZ[voff]);
  normal(0,1,0);
  vertex(0,r,0);
  endShape();
  edge(true);
}","/** 
 * Draw a sphere with radius r centered at coordinate 0, 0, 0. <P> Implementation notes: <P> cache all the points of the sphere in a static array top and bottom are just a bunch of triangles that land in the center point <P> sphere is a series of concentric circles who radii vary along the shape, based on, er.. cos or something <PRE> [toxi 031031] new sphere code. removed all multiplies with radius, as scale() will take care of that anyway [toxi 031223] updated sphere code (removed modulos) and introduced sphereAt(x,y,z,r) to avoid additional translate()'s on the user/sketch side [davbol 080801] now using separate sphereDetailU/V </PRE>
 */
public void sphere(float r){
  if ((sphereDetailU < 3) || (sphereDetailV < 2)) {
    sphereDetail(30);
  }
  edge(false);
  beginShape(TRIANGLE_STRIP);
  for (int i=0; i < sphereDetailU; i++) {
    normal(0,-1,0);
    vertex(0,-r,0);
    normal(sphereX[i],sphereY[i],sphereZ[i]);
    vertex(r * sphereX[i],r * sphereY[i],r * sphereZ[i]);
  }
  normal(0,-r,0);
  vertex(0,-r,0);
  normal(sphereX[0],sphereY[0],sphereZ[0]);
  vertex(r * sphereX[0],r * sphereY[0],r * sphereZ[0]);
  endShape();
  int v1, v11, v2;
  int voff=0;
  for (int i=2; i < sphereDetailV; i++) {
    v1=v11=voff;
    voff+=sphereDetailU;
    v2=voff;
    beginShape(TRIANGLE_STRIP);
    for (int j=0; j < sphereDetailU; j++) {
      normal(sphereX[v1],sphereY[v1],sphereZ[v1]);
      vertex(r * sphereX[v1],r * sphereY[v1],r * sphereZ[v1++]);
      normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
      vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2++]);
    }
    v1=v11;
    v2=voff;
    normal(sphereX[v1],sphereY[v1],sphereZ[v1]);
    vertex(r * sphereX[v1],r * sphereY[v1],r * sphereZ[v1]);
    normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
    vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2]);
    endShape();
  }
  beginShape(TRIANGLE_STRIP);
  for (int i=0; i < sphereDetailU; i++) {
    v2=voff + i;
    normal(sphereX[v2],sphereY[v2],sphereZ[v2]);
    vertex(r * sphereX[v2],r * sphereY[v2],r * sphereZ[v2]);
    normal(0,1,0);
    vertex(0,r,0);
  }
  normal(sphereX[voff],sphereY[voff],sphereZ[voff]);
  vertex(r * sphereX[voff],r * sphereY[voff],r * sphereZ[voff]);
  normal(0,1,0);
  vertex(0,r,0);
  endShape();
  edge(true);
}",0.996031746031746
109204,"/** 
 * First try to create a default font, but if that's not possible, throw   an exception that halts the program because textFont() has not been used  prior to the specified method.
 */
protected void defaultFontOrDeath(String method,float size){
  if (parent != null) {
    textFont=parent.createDefaultFont(size);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + method + ""String_Node_Str"");
  }
}","/** 
 * First try to create a default font, but if that's not possible, throw an exception that halts the program because textFont() has not been used prior to the specified method.
 */
protected void defaultFontOrDeath(String method,float size){
  if (parent != null) {
    textFont=parent.createDefaultFont(size);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + method + ""String_Node_Str"");
  }
}",0.9963811821471652
109205,"/** 
 * This utility method creates a texture for the provided image, and adds it to the metadata cache of the image.
 * @param img the image to have a texture metadata associated to it
 */
protected PTexture addTexture(PImage img){
  PTexture.Parameters params=(PTexture.Parameters)img.getParams(a3d);
  if (params == null) {
    params=PTexture.newParameters();
    img.setParams(a3d,params);
  }
  PTexture tex=new PTexture(img.parent,img.width,img.height,params);
  img.loadPixels();
  tex.set(img.pixels);
  img.setCache(a3d,tex);
  return tex;
}","/** 
 * This utility method creates a texture for the provided image, and adds it to the metadata cache of the image.
 * @param img the image to have a texture metadata associated to it
 */
protected PTexture addTexture(PImage img){
  PTexture.Parameters params=(PTexture.Parameters)img.getParams(a3d);
  if (params == null) {
    params=PTexture.newParameters();
    img.setParams(a3d,params);
  }
  PTexture tex=new PTexture(img.parent,img.width,img.height,params);
  if (img.pixels == null) {
    img.loadPixels();
  }
  tex.set(img.pixels);
  img.setCache(a3d,tex);
  return tex;
}",0.9419014084507042
109206,"/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      URL url=new URL(filename);
      stream=url.openStream();
      return stream;
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}","/** 
 * Call createInput() without automatic gzip decompression.
 */
public InputStream createInputRaw(String filename){
  InputStream stream=null;
  if (filename == null)   return null;
  if (filename.length() == 0) {
    return null;
  }
  if (filename.indexOf(""String_Node_Str"") != -1) {
    try {
      HttpGet httpRequest=null;
      httpRequest=new HttpGet(URI.create(filename));
      HttpClient httpclient=new DefaultHttpClient();
      HttpResponse response=(HttpResponse)httpclient.execute(httpRequest);
      HttpEntity entity=response.getEntity();
      BufferedHttpEntity bufHttpEntity=new BufferedHttpEntity(entity);
      return bufHttpEntity.getContent();
    }
 catch (    MalformedURLException mfue) {
    }
catch (    FileNotFoundException fnfe) {
    }
catch (    IOException e) {
      e.printStackTrace();
      return null;
    }
  }
  AssetManager assets=getAssets();
  try {
    stream=assets.open(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  IOException e) {
  }
  File absFile=new File(filename);
  if (absFile.exists()) {
    try {
      stream=new FileInputStream(absFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  File sketchFile=new File(sketchPath(filename));
  if (sketchFile.exists()) {
    try {
      stream=new FileInputStream(sketchFile);
      if (stream != null) {
        return stream;
      }
    }
 catch (    FileNotFoundException fnfe) {
    }
  }
  Context context=getApplicationContext();
  try {
    stream=context.openFileInput(filename);
    if (stream != null) {
      return stream;
    }
  }
 catch (  FileNotFoundException e) {
  }
  return null;
}",0.8656906429026098
109207,"static final public String hex(int what,int digits){
  String stuff=Integer.toHexString(what).toUpperCase();
  int length=stuff.length();
  if (length > digits) {
    return stuff.substring(length - digits);
  }
 else   if (length < digits) {
    return ""String_Node_Str"".substring(8 - (digits - length)) + stuff;
  }
  return stuff;
}","/** 
 * Format an integer as a hex string using the specified number of digits.
 * @param what the value to format
 * @param digits the number of digits (maximum 8)
 * @return a String object with the formatted values
 */
static final public String hex(int what,int digits){
  String stuff=Integer.toHexString(what).toUpperCase();
  if (digits > 8) {
    digits=8;
  }
  int length=stuff.length();
  if (length > digits) {
    return stuff.substring(length - digits);
  }
 else   if (length < digits) {
    return ""String_Node_Str"".substring(8 - (digits - length)) + stuff;
  }
  return stuff;
}",0.7204301075268817
109208,"/** 
 * Returns a String that contains the binary value of an int. The digits parameter determines how many digits will be used.
 */
static final public String binary(int what,int digits){
  String stuff=Integer.toBinaryString(what);
  int length=stuff.length();
  if (length > digits) {
    return stuff.substring(length - digits);
  }
 else   if (length < digits) {
    int offset=32 - (digits - length);
    return ""String_Node_Str"".substring(offset) + stuff;
  }
  return stuff;
}","/** 
 * Returns a String that contains the binary value of an int. The digits parameter determines how many digits will be used.
 */
static final public String binary(int what,int digits){
  String stuff=Integer.toBinaryString(what);
  if (digits > 32) {
    digits=32;
  }
  int length=stuff.length();
  if (length > digits) {
    return stuff.substring(length - digits);
  }
 else   if (length < digits) {
    int offset=32 - (digits - length);
    return ""String_Node_Str"".substring(offset) + stuff;
  }
  return stuff;
}",0.6944444444444444
109209,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (DEBUG)   println(""String_Node_Str"" + Thread.currentThread().getName());
  Window window=getWindow();
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  window.setFlags(WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  DisplayMetrics dm=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(dm);
  screenWidth=dm.widthPixels;
  screenHeight=dm.heightPixels;
  if (DEBUG)   println(""String_Node_Str"" + dm);
  int sw=sketchWidth();
  int sh=sketchHeight();
  if (sketchRenderer().equals(A2D)) {
    surfaceView=new SketchSurfaceView2D(this,sw,sh);
  }
 else   if (sketchRenderer().equals(A3D)) {
    surfaceView=new SketchSurfaceView3D(this,sw,sh);
  }
  g=((SketchSurfaceView)surfaceView).getGraphics();
  if (sw == screenWidth && sh == screenHeight) {
    window.setContentView(surfaceView);
  }
 else {
    RelativeLayout overallLayout=new RelativeLayout(this);
    RelativeLayout.LayoutParams lp=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
    lp.addRule(RelativeLayout.CENTER_IN_PARENT);
    LinearLayout layout=new LinearLayout(this);
    layout.addView(surfaceView,sketchWidth(),sketchHeight());
    overallLayout.addView(layout,lp);
    window.setContentView(overallLayout);
  }
  finished=false;
  looping=true;
  redraw=true;
  firstMotion=true;
  Context context=getApplicationContext();
  sketchPath=context.getFilesDir().getAbsolutePath();
  handler=new Handler();
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  start();
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (DEBUG)   println(""String_Node_Str"" + Thread.currentThread().getName());
  Window window=getWindow();
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  window.setFlags(WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
  window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  DisplayMetrics dm=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(dm);
  screenWidth=dm.widthPixels;
  screenHeight=dm.heightPixels;
  if (DEBUG)   println(""String_Node_Str"" + dm);
  int sw=sketchWidth();
  int sh=sketchHeight();
  if (sketchRenderer().equals(A2D)) {
    surfaceView=new SketchSurfaceView2D(this,sw,sh);
  }
 else   if (sketchRenderer().equals(A3D)) {
    surfaceView=new SketchSurfaceView3D(this,sw,sh);
  }
  g=((SketchSurfaceView)surfaceView).getGraphics();
  if (sw == screenWidth && sh == screenHeight) {
    window.setContentView(surfaceView);
  }
 else {
    RelativeLayout overallLayout=new RelativeLayout(this);
    RelativeLayout.LayoutParams lp=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);
    lp.addRule(RelativeLayout.CENTER_IN_PARENT);
    LinearLayout layout=new LinearLayout(this);
    layout.addView(surfaceView,sketchWidth(),sketchHeight());
    overallLayout.addView(layout,lp);
    window.setContentView(overallLayout);
  }
  finished=false;
  looping=true;
  redraw=true;
  firstMotion=true;
  sizeMethods=new RegisteredMethods();
  preMethods=new RegisteredMethods();
  drawMethods=new RegisteredMethods();
  postMethods=new RegisteredMethods();
  mouseEventMethods=new RegisteredMethods();
  keyEventMethods=new RegisteredMethods();
  disposeMethods=new RegisteredMethods();
  Context context=getApplicationContext();
  sketchPath=context.getFilesDir().getAbsolutePath();
  handler=new Handler();
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  start();
}",0.928696522391794
109210,"protected void setMultitextureBlend(PTexture[] textures,int num){
  if (2 < num) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  gl.glDisable(GL10.GL_BLEND);
  if (!texenvCrossbarSupported) {
    PGraphics.showWarning(""String_Node_Str"");
    if (blendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
    }
 else     if (blendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
    }
 else     if (blendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
 else {
    if (blendMode == REPLACE) {
    }
 else     if (blendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_PRIMARY_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == MULTIPLY) {
    }
 else     if (blendMode == ADD) {
    }
 else     if (blendMode == SUBTRACT) {
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
  gl.glEnable(GL10.GL_BLEND);
  gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
}","protected void setMultitextureBlend(PTexture[] textures,int num){
  if (2 < num) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  gl.glDisable(GL10.GL_BLEND);
  if (!texenvCrossbarSupported) {
    PGraphics.showWarning(""String_Node_Str"");
    if (blendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
    }
 else     if (blendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
    }
 else     if (blendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (blendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
 else {
    if (blendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (blendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (blendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (blendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (blendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
  gl.glEnable(GL10.GL_BLEND);
  gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
}",0.7684215652851507
109211,"protected void drawGeometry(PGraphics g){
  PShape3D p3d=(PShape3D)parent;
  int numTextures;
  float pointSize;
  pointSize=PApplet.min(g.strokeWeight,PGraphicsAndroid3D.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glNormalBufferID);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  if (p3d.vertexColor) {
    gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glColorBufferID);
    gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  }
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glVertexBufferID);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  numTextures=0;
  for (int t=0; t < textures.length; t++) {
    if (textures[t] != null) {
      PTexture tex=textures[t].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[numTextures]=tex;
        numTextures++;
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (0 < numTextures) {
    if (pointSprites) {
      gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,ptDistAtt,0);
      gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,PGraphicsAndroid3D.maxPointSize);
      gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
      gl.glEnable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL11.GL_TEXTURE0 + t);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glTexCoordBufferID[t]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
      if (1 < numTextures) {
        a3d.setMultitextureBlend(renderTextures,numTextures);
      }
    }
  }
  if (!p3d.vertexColor) {
    if (0 < numTextures) {
      if (g.tint) {
        gl.glColor4f(g.tintR,g.tintG,g.tintB,g.tintA);
      }
 else {
        gl.glColor4f(1,1,1,1);
      }
    }
 else {
      gl.glColor4f(g.fillR,g.fillG,g.fillB,g.fillA);
    }
  }
  if (0 < strokeWeight) {
    gl.glLineWidth(strokeWeight);
  }
 else {
    gl.glLineWidth(g.strokeWeight);
  }
  if (0 < glMode && !pointSprites) {
    gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  }
 else {
    gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  }
  if (0 < numTextures) {
    if (1 < numTextures) {
      a3d.clearMultitextureBlend(numTextures);
    }
    if (pointSprites) {
      gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glDisable(tex.getGLTarget());
    }
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}","protected void drawGeometry(PGraphics g){
  PShape3D p3d=(PShape3D)parent;
  int numTextures;
  float pointSize;
  pointSize=PApplet.min(g.strokeWeight,PGraphicsAndroid3D.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glNormalBufferID);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  if (p3d.vertexColor) {
    gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glColorBufferID);
    gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  }
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glVertexBufferID);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  numTextures=0;
  for (int t=0; t < textures.length; t++) {
    if (textures[t] != null) {
      PTexture tex=textures[t].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[numTextures]=tex;
        numTextures++;
      }
 else {
        break;
      }
    }
 else {
      break;
    }
  }
  if (0 < numTextures) {
    if (pointSprites) {
      gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,ptDistAtt,0);
      gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,PGraphicsAndroid3D.maxPointSize);
      gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
      gl.glEnable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL11.GL_TEXTURE0 + t);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glTexCoordBufferID[t]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
      if (1 < numTextures) {
        a3d.setMultitextureBlend(renderTextures,numTextures);
      }
    }
  }
  if (!p3d.vertexColor) {
    if (0 < numTextures) {
      if (g.tint) {
        gl.glColor4f(g.tintR,g.tintG,g.tintB,g.tintA);
      }
 else {
        gl.glColor4f(1,1,1,1);
      }
    }
 else {
      gl.glColor4f(g.fillR,g.fillG,g.fillB,g.fillA);
    }
  }
  if (0 < strokeWeight) {
    gl.glLineWidth(strokeWeight);
  }
 else {
    gl.glLineWidth(g.strokeWeight);
  }
  gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  if (0 < numTextures) {
    if (1 < numTextures) {
      a3d.clearMultitextureBlend(numTextures);
    }
    if (pointSprites) {
      gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glDisable(tex.getGLTarget());
    }
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}",0.9748598879103284
109212,"protected void addDefaultChild(){
  PShape child=createChild(""String_Node_Str"",0,vertexCount - 1,glMode,0,null);
  addChild(child);
}","protected void addDefaultChild(){
  PShape child=createChild(""String_Node_Str"",0,vertexCount - 1,getDrawModeImpl(),0,null);
  addChild(child);
}",0.9530685920577616
109213,"protected void copyToTexture(IntBuffer buffer,int glid,int gltarget){
  gl.glEnable(gltarget);
  gl.glBindTexture(gltarget,glid);
  gl.glTexSubImage2D(gltarget,0,0,0,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,buffer);
  gl.glDisable(gltarget);
}","protected void copyToTexture(IntBuffer buffer,int glid,int gltarget){
  gl.glEnable(gltarget);
  gl.glBindTexture(gltarget,glid);
  gl.glTexSubImage2D(gltarget,0,0,0,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,buffer);
  gl.glBindTexture(gltarget,0);
  gl.glDisable(gltarget);
}",0.9398496240601504
109214,"protected void clearMultitextureBlend(int num){
  for (int i=0; i < num; i++) {
    gl11.glActiveTexture(GL11.GL_TEXTURE0 + i);
    gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_MODULATE);
  }
}","protected void clearMultitextureBlend(int num){
  for (int i=0; i < num; i++) {
    gl11.glActiveTexture(GL11.GL_TEXTURE0 + i);
    gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_MODULATE);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.86
109215,"protected void setMultitextureBlend(PTexture[] textures,int num){
  if (2 < num) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  if (!texenvCrossbarSupported) {
    PGraphics.showWarning(""String_Node_Str"");
    if (multitexureBlendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
    }
 else     if (multitexureBlendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
 else {
    if (multitexureBlendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
}","protected void setMultitextureBlend(PTexture[] textures,int num){
  if (2 < num) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  if (!texenvCrossbarSupported) {
    PGraphics.showWarning(""String_Node_Str"");
    if (multitexureBlendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
    }
 else     if (multitexureBlendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else     if (multitexureBlendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_REPLACE);
      gl11.glActiveTexture(GL11.GL_TEXTURE1);
      gl11.glBindTexture(textures[1].getGLTarget(),textures[1].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_PREVIOUS);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
 else {
    if (multitexureBlendMode == REPLACE) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_REPLACE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == BLEND) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_RGB,GL11.GL_ONE_MINUS_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_INTERPOLATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC2_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND2_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == MULTIPLY) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_MODULATE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == ADD) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_ADD);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else     if (multitexureBlendMode == SUBTRACT) {
      gl11.glActiveTexture(GL11.GL_TEXTURE0);
      gl11.glBindTexture(textures[0].getGLTarget(),textures[0].getGLID());
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_TEXTURE_ENV_MODE,GL11.GL_COMBINE);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_RGB,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_RGB,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_RGB,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_RGB,GL11.GL_SRC_COLOR);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_COMBINE_ALPHA,GL11.GL_SUBTRACT);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC0_ALPHA,GL11.GL_TEXTURE0);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_SRC1_ALPHA,GL11.GL_TEXTURE1);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND0_ALPHA,GL11.GL_SRC_ALPHA);
      gl11.glTexEnvi(GL11.GL_TEXTURE_ENV,GL11.GL_OPERAND1_ALPHA,GL11.GL_SRC_ALPHA);
      modulateWithPrimaryColor(1,textures[1]);
    }
 else {
      PGraphics.showWarning(""String_Node_Str"");
    }
  }
  gl.glDisable(GL10.GL_BLEND);
}",0.9986878306878308
109216,"protected void drawTexture(PTexture tex,int[] crop,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,crop,0);
  gl11x.glDrawTexiOES(x,y,0,w,h);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_MODULATE);
  gl.glDisable(tex.getGLTarget());
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}","protected void drawTexture(PTexture tex,int[] crop,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,crop,0);
  gl11x.glDrawTexiOES(x,y,0,w,h);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_MODULATE);
  gl.glBindTexture(tex.getGLTarget(),0);
  gl.glDisable(tex.getGLTarget());
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.971704623878537
109217,"protected void copyToTexture(PTexture tex,IntBuffer buffer,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
  gl.glTexSubImage2D(tex.getGLTarget(),0,x,y,w,h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,buffer);
  gl.glDisable(tex.getGLTarget());
}","protected void copyToTexture(PTexture tex,IntBuffer buffer,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
  gl.glTexSubImage2D(tex.getGLTarget(),0,x,y,w,h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,buffer);
  gl.glBindTexture(tex.getGLTarget(),0);
  gl.glDisable(tex.getGLTarget());
}",0.9362363919129082
109218,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  normalBuffer.rewind();
  for (int t=0; t < numTexBuffers; t++) {
    texCoordBuffer[t].rewind();
  }
  numMultitextures=0;
  clearMultitextures();
  clearMultitextures0();
  gl.glShadeModel(GL10.GL_SMOOTH);
  blend(BLEND);
  textureBlend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lights=false;
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glFrontFace(GL10.GL_CW);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  gl.glLightModelfv(GL10.GL_LIGHT_MODEL_AMBIENT,baseLight,0);
  gl.glLightModelx(GL10.GL_LIGHT_MODEL_TWO_SIDE,0);
  shapeFirst=0;
  normalX=normalY=normalZ=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (offscreenFramebuffer == null) {
          createOffscreenFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (texture == null) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (offscreenFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(offscreenFramebuffer);
          offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            drawOffscreenTexture((offscreenIndex + 1) % 2);
          }
        }
      }
 else {
        if (texture != null) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (offscreenFramebuffer == null) {
      createOffscreenFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
    offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      drawOffscreenTexture((offscreenIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  normalBuffer.rewind();
  for (int t=0; t < numTexBuffers; t++) {
    texCoordBuffer[t].rewind();
  }
  numMultitextures=0;
  clearMultitextures();
  clearMultitextures0();
  gl.glShadeModel(GL10.GL_SMOOTH);
  blend(BLEND);
  textureBlend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  noLights();
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glFrontFace(GL10.GL_CW);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  gl.glLightModelfv(GL10.GL_LIGHT_MODEL_AMBIENT,baseLight,0);
  gl.glLightModelx(GL10.GL_LIGHT_MODEL_TWO_SIDE,0);
  shapeFirst=0;
  normalX=normalY=normalZ=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (offscreenFramebuffer == null) {
          createOffscreenFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (texture == null) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (offscreenFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(offscreenFramebuffer);
          offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            drawOffscreenTexture((offscreenIndex + 1) % 2);
          }
        }
      }
 else {
        if (texture != null) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (offscreenFramebuffer == null) {
      createOffscreenFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
    offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      drawOffscreenTexture((offscreenIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}",0.9893187066974596
109219,"protected void addNewFace(boolean firstFace,PImage[] images){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    PImage tempi[][]=new PImage[faceCount << 1][MAX_TEXTURES];
    PApplet.arrayCopy(faceTextures,0,tempi,0,faceCount);
    faceTextures=tempi;
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  PImage p[]=faceTextures[faceCount];
  if (1 < numMultitextures) {
    PApplet.arrayCopy(images,0,p,0,numMultitextures);
  }
  if (0 < numMultitextures) {
    p[0]=images[0];
  }
 else {
    p[0]=null;
  }
  faceCount++;
}","protected void addNewFace(boolean firstFace,PImage[] images){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    PImage tempi[][]=new PImage[faceCount << 1][MAX_TEXTURES];
    PApplet.arrayCopy(faceTextures,0,tempi,0,faceCount);
    faceTextures=tempi;
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  PImage p[]=faceTextures[faceCount];
  if (1 < numMultitextures) {
    PApplet.arrayCopy(images,0,p,0,numMultitextures);
  }
  if (0 < numMultitextures) {
    p[0]=images[0];
  }
 else {
    p[0]=null;
  }
  java.util.Arrays.fill(p,numMultitextures,maxTextureUnits,null);
  faceCount++;
}",0.9510385756676558
109220,"protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  int numTextures=0;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    PImage[] images=faceTextures[j];
    if (1 < numMultitextures) {
      for (int t=0; t < numMultitextures; t++) {
        if (images[t] != null) {
          PTexture tex=images[t].getTexture();
          if (tex == null) {
            tex=images[t].createTexture();
            if (tex == null) {
              break;
            }
          }
          gl.glEnable(tex.getGLTarget());
          gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
          gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
          renderTextures[numTextures]=tex;
          numTextures++;
        }
 else {
          break;
        }
      }
    }
 else     if (images[0] != null) {
      PTexture tex=images[0].getTexture();
      if (tex == null) {
        tex=images[0].createTexture();
      }
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL10.GL_TEXTURE0);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[0]=tex;
        numTextures=1;
      }
    }
    if (0 < numTextures) {
      if (numTexBuffers < numTextures) {
        addTexBuffers(numTextures - numTexBuffers);
      }
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      if (1 < numTextures) {
        setMultitextureBlend(renderTextures,numTextures);
      }
    }
    if (recordingShape) {
      numRecordedTextures=PApplet.max(numRecordedTextures,numTextures);
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      PShape3D child=(PShape3D)PShape3D.createChild(""String_Node_Str"" + recordedChildren.size(),n0,n1,TRIANGLES,0,images);
      recordedChildren.add(child);
    }
    int size=3 * faceLength[j];
    while (vertexBuffer.capacity() / 3 < size) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    for (int t=0; t < numTextures; t++) {
      texCoordBuffer[t].position(0);
    }
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      int na=triangles[i][VERTEX1];
      int nb=triangles[i][VERTEX2];
      int nc=triangles[i][VERTEX3];
      float a[]=vertices[na];
      float b[]=vertices[nb];
      float c[]=vertices[nc];
      if (autoNormal && (a[HAS_NORMAL] == 0 || b[HAS_NORMAL] == 0 || c[HAS_NORMAL] == 0)) {
        float x1=b[X] - a[X];
        float y1=b[Y] - a[Y];
        float z1=b[Z] - a[Z];
        float x2=b[X] - c[X];
        float y2=b[Y] - c[Y];
        float z2=b[Z] - c[Z];
        float cx=y1 * z2 - y2 * z1;
        float cy=z1 * x2 - z2 * x1;
        float cz=x1 * y2 - x2 * y1;
        float norm=PApplet.sqrt(cx * cx + cy * cy + cz * cz);
        cx/=norm;
        cy/=norm;
        cz/=norm;
        a[NX]=b[NX]=c[NX]=cx;
        a[NY]=b[NY]=c[NY]=cy;
        a[NZ]=b[NZ]=c[NZ]=cz;
        a[HAS_NORMAL]=b[HAS_NORMAL]=c[HAS_NORMAL]=1;
      }
      if (numTextures == 1) {
        float uscale=1.0f;
        float vscale=1.0f;
        float cx=0.0f;
        float sx=+1.0f;
        float cy=0.0f;
        float sy=+1.0f;
        PTexture tex=renderTextures[0];
        uscale*=tex.getMaxTexCoordU();
        vscale*=tex.getMaxTexCoordV();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
        renderUa[0]=(cx + sx * a[U]) * uscale;
        renderVa[0]=(cy + sy * a[V]) * vscale;
        renderUb[0]=(cx + sx * b[U]) * uscale;
        renderVb[0]=(cy + sy * b[V]) * vscale;
        renderUc[0]=(cx + sx * c[U]) * uscale;
        renderVc[0]=(cy + sy * c[V]) * vscale;
      }
 else       if (1 < numTextures) {
        for (int t=0; t < numTextures; t++) {
          float uscale=1.0f;
          float vscale=1.0f;
          float cx=0.0f;
          float sx=+1.0f;
          float cy=0.0f;
          float sy=+1.0f;
          PTexture tex=renderTextures[t];
          uscale*=tex.getMaxTexCoordU();
          vscale*=tex.getMaxTexCoordV();
          if (tex.isFlippedX()) {
            cx=1.0f;
            sx=-1.0f;
          }
          if (tex.isFlippedY()) {
            cy=1.0f;
            sy=-1.0f;
          }
          renderUa[t]=(cx + sx * vertexU[na][t]) * uscale;
          renderVa[t]=(cy + sy * vertexV[na][t]) * vscale;
          renderUb[t]=(cx + sx * vertexU[nb][t]) * uscale;
          renderVb[t]=(cy + sy * vertexV[nb][t]) * vscale;
          renderUc[t]=(cx + sx * vertexU[nc][t]) * uscale;
          renderVc[t]=(cy + sy * vertexV[nc][t]) * vscale;
        }
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUa[t],renderVa[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUa[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVa[t]);
        }
        n++;
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUb[t],renderVb[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUb[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVb[t]);
        }
        n++;
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUc[t],renderVc[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUc[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVc[t]);
        }
        n++;
      }
      i++;
    }
    if (!recordingShape) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      for (int t=0; t < numTextures; t++) {
        texCoordBuffer[t].put(texCoordArray[t]);
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      for (int t=0; t < numTextures; t++) {
        texCoordBuffer[t].position(0);
      }
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer[t]);
      }
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (0 < numTextures) {
      if (1 < numTextures) {
        clearMultitextureBlend(numTextures);
      }
      for (int t=0; t < numTextures; t++) {
        PTexture tex=renderTextures[t];
        gl.glDisable(tex.getGLTarget());
      }
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report(""String_Node_Str"");
}","protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  int numTextures=0;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    PImage[] images=faceTextures[j];
    if (1 < numMultitextures) {
      for (int t=0; t < numMultitextures; t++) {
        if (images[t] != null) {
          PTexture tex=images[t].getTexture();
          if (tex == null) {
            tex=images[t].createTexture();
            if (tex == null) {
              break;
            }
          }
          gl.glEnable(tex.getGLTarget());
          gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
          gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
          renderTextures[numTextures]=tex;
          numTextures++;
        }
 else {
          break;
        }
      }
    }
 else     if (images[0] != null) {
      PTexture tex=images[0].getTexture();
      if (tex == null) {
        tex=images[0].createTexture();
      }
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glActiveTexture(GL10.GL_TEXTURE0);
        gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
        renderTextures[0]=tex;
        numTextures=1;
      }
    }
    if (0 < numTextures) {
      if (numTexBuffers < numTextures) {
        addTexBuffers(numTextures - numTexBuffers);
      }
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      if (1 < numTextures) {
        setMultitextureBlend(renderTextures,numTextures);
      }
    }
    if (recordingShape) {
      numRecordedTextures=PApplet.max(numRecordedTextures,numTextures);
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      PShape3D child=(PShape3D)PShape3D.createChild(""String_Node_Str"" + recordedChildren.size(),n0,n1,TRIANGLES,0,images);
      recordedChildren.add(child);
    }
    int size=3 * faceLength[j];
    while (vertexBuffer.capacity() / 3 < size) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    for (int t=0; t < numTextures; t++) {
      texCoordBuffer[t].position(0);
    }
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      int na=triangles[i][VERTEX1];
      int nb=triangles[i][VERTEX2];
      int nc=triangles[i][VERTEX3];
      float a[]=vertices[na];
      float b[]=vertices[nb];
      float c[]=vertices[nc];
      if (autoNormal && (a[HAS_NORMAL] == 0 || b[HAS_NORMAL] == 0 || c[HAS_NORMAL] == 0)) {
        float x1=b[X] - a[X];
        float y1=b[Y] - a[Y];
        float z1=b[Z] - a[Z];
        float x2=b[X] - c[X];
        float y2=b[Y] - c[Y];
        float z2=b[Z] - c[Z];
        float cx=y1 * z2 - y2 * z1;
        float cy=z1 * x2 - z2 * x1;
        float cz=x1 * y2 - x2 * y1;
        float norm=PApplet.sqrt(cx * cx + cy * cy + cz * cz);
        cx/=norm;
        cy/=norm;
        cz/=norm;
        a[NX]=b[NX]=c[NX]=cx;
        a[NY]=b[NY]=c[NY]=cy;
        a[NZ]=b[NZ]=c[NZ]=cz;
        a[HAS_NORMAL]=b[HAS_NORMAL]=c[HAS_NORMAL]=1;
      }
      if (numTextures == 1) {
        float uscale=1.0f;
        float vscale=1.0f;
        float cx=0.0f;
        float sx=+1.0f;
        float cy=0.0f;
        float sy=+1.0f;
        PTexture tex=renderTextures[0];
        uscale*=tex.getMaxTexCoordU();
        vscale*=tex.getMaxTexCoordV();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
        renderUa[0]=(cx + sx * a[U]) * uscale;
        renderVa[0]=(cy + sy * a[V]) * vscale;
        renderUb[0]=(cx + sx * b[U]) * uscale;
        renderVb[0]=(cy + sy * b[V]) * vscale;
        renderUc[0]=(cx + sx * c[U]) * uscale;
        renderVc[0]=(cy + sy * c[V]) * vscale;
      }
 else       if (1 < numTextures) {
        for (int t=0; t < numTextures; t++) {
          float uscale=1.0f;
          float vscale=1.0f;
          float cx=0.0f;
          float sx=+1.0f;
          float cy=0.0f;
          float sy=+1.0f;
          PTexture tex=renderTextures[t];
          uscale*=tex.getMaxTexCoordU();
          vscale*=tex.getMaxTexCoordV();
          if (tex.isFlippedX()) {
            cx=1.0f;
            sx=-1.0f;
          }
          if (tex.isFlippedY()) {
            cy=1.0f;
            sy=-1.0f;
          }
          renderUa[t]=(cx + sx * vertexU[na][t]) * uscale;
          renderVa[t]=(cy + sy * vertexV[na][t]) * vscale;
          renderUb[t]=(cx + sx * vertexU[nb][t]) * uscale;
          renderVb[t]=(cy + sy * vertexV[nb][t]) * vscale;
          renderUc[t]=(cx + sx * vertexU[nc][t]) * uscale;
          renderVc[t]=(cy + sy * vertexV[nc][t]) * vscale;
        }
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUa[t],renderVa[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUa[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVa[t]);
        }
        n++;
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUb[t],renderVb[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUb[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVb[t]);
        }
        n++;
      }
      if (recordingShape) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        for (int t=0; t < numTextures; t++) {
          recordedTexCoords[t].add(new PVector(renderUc[t],renderVc[t],0.0f));
        }
        for (int t=numTextures; t < maxTextureUnits; t++) {
          recordedTexCoords[t].add(new PVector(0.0f,0.0f,0.0f));
        }
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        for (int t=0; t < numTextures; t++) {
          texCoordArray[t][2 * n + 0]=toFixed32(renderUc[t]);
          texCoordArray[t][2 * n + 1]=toFixed32(renderVc[t]);
        }
        n++;
      }
      i++;
    }
    if (!recordingShape) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      for (int t=0; t < numTextures; t++) {
        texCoordBuffer[t].put(texCoordArray[t]);
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      for (int t=0; t < numTextures; t++) {
        texCoordBuffer[t].position(0);
      }
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer[t]);
      }
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (0 < numTextures) {
      if (1 < numTextures) {
        clearMultitextureBlend(numTextures);
      }
      for (int t=0; t < numTextures; t++) {
        PTexture tex=renderTextures[t];
        gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
        gl.glBindTexture(tex.getGLTarget(),0);
      }
      for (int t=0; t < numTextures; t++) {
        PTexture tex=renderTextures[t];
        gl.glDisable(tex.getGLTarget());
      }
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report(""String_Node_Str"");
}",0.9903240669636
109221,"protected void drawGeometry(PGraphics g){
  PShape3D p3d=(PShape3D)parent;
  int numTextures;
  float pointSize;
  pointSize=PApplet.min(g.strokeWeight,PGraphicsAndroid3D.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glNormalBufferID);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  if (p3d.vertexColor) {
    gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glColorBufferID);
    gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  }
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glVertexBufferID);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  numTextures=0;
  for (int t=0; t < textures.length; t++) {
    if (textures[t] != null) {
      PTexture tex=textures[t].getTexture();
      if (tex == null) {
        tex=textures[t].createTexture();
        if (tex == null) {
          break;
        }
      }
      gl.glEnable(tex.getGLTarget());
      gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
      gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
      renderTextures[numTextures]=tex;
      numTextures++;
    }
 else {
      break;
    }
  }
  if (0 < numTextures) {
    if (pointSprites) {
      gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,ptDistAtt,0);
      gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,PGraphicsAndroid3D.maxPointSize);
      gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
      gl.glEnable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL11.GL_TEXTURE0 + t);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glTexCoordBufferID[t]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
      if (1 < numTextures) {
        a3d.setMultitextureBlend(renderTextures,numTextures);
      }
    }
  }
  if (!p3d.vertexColor) {
    if (0 < numTextures) {
      if (g.tint) {
        gl.glColor4f(g.tintR,g.tintG,g.tintB,g.tintA);
      }
 else {
        gl.glColor4f(1,1,1,1);
      }
    }
 else {
      gl.glColor4f(g.fillR,g.fillG,g.fillB,g.fillA);
    }
  }
  if (0 < strokeWeight) {
    gl.glLineWidth(strokeWeight);
  }
 else {
    gl.glLineWidth(g.strokeWeight);
  }
  gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  if (0 < numTextures) {
    if (1 < numTextures) {
      a3d.clearMultitextureBlend(numTextures);
    }
    if (pointSprites) {
      gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glDisable(tex.getGLTarget());
    }
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}","protected void drawGeometry(PGraphics g){
  PShape3D p3d=(PShape3D)parent;
  int numTextures;
  float pointSize;
  pointSize=PApplet.min(g.strokeWeight,PGraphicsAndroid3D.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glNormalBufferID);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  if (p3d.vertexColor) {
    gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glColorBufferID);
    gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  }
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glVertexBufferID);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  numTextures=0;
  for (int t=0; t < textures.length; t++) {
    if (textures[t] != null) {
      PTexture tex=textures[t].getTexture();
      if (tex == null) {
        tex=textures[t].createTexture();
        if (tex == null) {
          break;
        }
      }
      gl.glEnable(tex.getGLTarget());
      gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
      gl.glBindTexture(tex.getGLTarget(),tex.getGLID());
      renderTextures[numTextures]=tex;
      numTextures++;
    }
 else {
      break;
    }
  }
  if (0 < numTextures) {
    if (pointSprites) {
      gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,ptDistAtt,0);
      gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
      gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,PGraphicsAndroid3D.maxPointSize);
      gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
      gl.glEnable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      for (int t=0; t < numTextures; t++) {
        gl.glClientActiveTexture(GL11.GL_TEXTURE0 + t);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,p3d.glTexCoordBufferID[t]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
      if (1 < numTextures) {
        a3d.setMultitextureBlend(renderTextures,numTextures);
      }
    }
  }
  if (!p3d.vertexColor) {
    if (0 < numTextures) {
      if (g.tint) {
        gl.glColor4f(g.tintR,g.tintG,g.tintB,g.tintA);
      }
 else {
        gl.glColor4f(1,1,1,1);
      }
    }
 else {
      gl.glColor4f(g.fillR,g.fillG,g.fillB,g.fillA);
    }
  }
  if (0 < strokeWeight) {
    gl.glLineWidth(strokeWeight);
  }
 else {
    gl.glLineWidth(g.strokeWeight);
  }
  gl.glDrawArrays(glMode,firstVertex,lastVertex - firstVertex + 1);
  if (0 < numTextures) {
    if (1 < numTextures) {
      a3d.clearMultitextureBlend(numTextures);
    }
    if (pointSprites) {
      gl.glDisable(GL11.GL_POINT_SPRITE_OES);
    }
 else {
      gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glActiveTexture(GL10.GL_TEXTURE0 + t);
      gl.glBindTexture(tex.getGLTarget(),0);
    }
    for (int t=0; t < numTextures; t++) {
      PTexture tex=renderTextures[t];
      gl.glDisable(tex.getGLTarget());
    }
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}",0.9720618073981584
109222,"protected void loadTexcoords(int unit,int first,int last){
  if (last < first || first < 0 || vertexCount <= last) {
    PGraphics.showWarning(""String_Node_Str"");
    updateElement=-1;
    return;
  }
  if (updateElement != -1) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  if (PGraphicsAndroid3D.maxTextureUnits <= unit) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  updateElement=TEXCOORDS;
  firstUpdateIdx=first;
  lastUpdateIdx=last;
  if (numTexBuffers <= unit) {
    addTexBuffers(unit - numTexBuffers + 1);
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[unit]);
  int offset=first * 2;
  int size=(last - first + 1) * 2;
  texCoordBuffer.limit(texCoordBuffer.capacity());
  texCoordBuffer.rewind();
  texCoordBuffer.get(texcoords,offset,size);
  updateTexunit=unit;
}","protected void loadTexcoords(int unit,int first,int last){
  if (last < first || first < 0 || vertexCount <= last) {
    PGraphics.showWarning(""String_Node_Str"");
    updateElement=-1;
    return;
  }
  if (updateElement != -1) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  if (PGraphicsAndroid3D.maxTextureUnits <= unit) {
    PGraphics.showWarning(""String_Node_Str"");
    return;
  }
  updateElement=TEXCOORDS;
  firstUpdateIdx=first;
  lastUpdateIdx=last;
  if (numTexBuffers <= unit) {
    addTexBuffers(unit - numTexBuffers + 1);
  }
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[unit]);
  int offset=first * 2;
  int size=(last - first + 1) * 2;
  texCoordBuffer.limit(texCoordBuffer.capacity());
  texCoordBuffer.rewind();
  texCoordBuffer.get(texcoords,offset,size);
  normalizeTexcoords(unit);
  updateTexunit=unit;
}",0.9774881516587678
109223,"public void updateTexcoords(){
  if (updateElement == TEXCOORDS) {
    int offset=firstUpdateIdx * 2;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 2;
    texCoordBuffer.position(0);
    texCoordBuffer.put(texcoords,offset,size);
    texCoordBuffer.flip();
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * PGraphicsAndroid3D.SIZEOF_FLOAT,size * PGraphicsAndroid3D.SIZEOF_FLOAT,texCoordBuffer);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
    texCoordSet[updateTexunit]=true;
    updateElement=-1;
  }
 else {
    PGraphics.showWarning(""String_Node_Str"");
  }
}","public void updateTexcoords(){
  if (updateElement == TEXCOORDS) {
    int offset=firstUpdateIdx * 2;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 2;
    unnormalizeTexcoords(updateTexunit);
    texCoordBuffer.position(0);
    texCoordBuffer.put(texcoords,offset,size);
    texCoordBuffer.flip();
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * PGraphicsAndroid3D.SIZEOF_FLOAT,size * PGraphicsAndroid3D.SIZEOF_FLOAT,texCoordBuffer);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
    texCoordSet[updateTexunit]=true;
    updateElement=-1;
  }
 else {
    PGraphics.showWarning(""String_Node_Str"");
  }
}",0.9653423499577346
109224,"/** 
 * Creates the opengl texture object.
 * @param w int
 * @param h int  
 */
protected void createTexture(int w,int h){
  deleteTexture();
  if (PGraphicsAndroid3D.npotTexSupported) {
    glWidth=w;
    glHeight=h;
  }
 else {
    glWidth=nextPowerOfTwo(w);
    glHeight=nextPowerOfTwo(h);
  }
  if ((glWidth > PGraphicsAndroid3D.maxTextureSize) || (glHeight > PGraphicsAndroid3D.maxTextureSize)) {
    glWidth=glHeight=0;
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + PGraphicsAndroid3D.maxTextureSize + ""String_Node_Str"");
  }
  usingMipmaps=((glMinFilter == GL10.GL_NEAREST_MIPMAP_NEAREST) || (glMinFilter == GL10.GL_LINEAR_MIPMAP_NEAREST) || (glMinFilter == GL10.GL_NEAREST_MIPMAP_LINEAR)|| (glMinFilter == GL10.GL_LINEAR_MIPMAP_LINEAR));
  gl.glEnable(glTarget);
  glID=a3d.createGLResource(PGraphicsAndroid3D.GL_TEXTURE_OBJECT);
  gl.glBindTexture(glTarget,glID);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_MIN_FILTER,glMinFilter);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_MAG_FILTER,glMagFilter);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_WRAP_S,glWrapS);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_WRAP_T,glWrapT);
  gl.glTexImage2D(glTarget,0,glFormat,glWidth,glHeight,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,null);
  gl.glDisable(glTarget);
  flippedX=false;
  flippedY=false;
  maxTexCoordU=(float)w / glWidth;
  maxTexCoordV=(float)h / glHeight;
}","/** 
 * Creates the opengl texture object.
 * @param w int
 * @param h int  
 */
protected void createTexture(int w,int h){
  deleteTexture();
  if (PGraphicsAndroid3D.npotTexSupported) {
    glWidth=w;
    glHeight=h;
  }
 else {
    glWidth=nextPowerOfTwo(w);
    glHeight=nextPowerOfTwo(h);
  }
  if ((glWidth > PGraphicsAndroid3D.maxTextureSize) || (glHeight > PGraphicsAndroid3D.maxTextureSize)) {
    glWidth=glHeight=0;
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + PGraphicsAndroid3D.maxTextureSize + ""String_Node_Str"");
  }
  usingMipmaps=((glMinFilter == GL10.GL_NEAREST_MIPMAP_NEAREST) || (glMinFilter == GL10.GL_LINEAR_MIPMAP_NEAREST) || (glMinFilter == GL10.GL_NEAREST_MIPMAP_LINEAR)|| (glMinFilter == GL10.GL_LINEAR_MIPMAP_LINEAR));
  gl.glEnable(glTarget);
  glID=a3d.createGLResource(PGraphicsAndroid3D.GL_TEXTURE_OBJECT);
  gl.glBindTexture(glTarget,glID);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_MIN_FILTER,glMinFilter);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_MAG_FILTER,glMagFilter);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_WRAP_S,glWrapS);
  gl.glTexParameterf(glTarget,GL10.GL_TEXTURE_WRAP_T,glWrapT);
  gl.glTexImage2D(glTarget,0,glFormat,glWidth,glHeight,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,null);
  gl.glBindTexture(glTarget,0);
  gl.glDisable(glTarget);
  flippedX=false;
  flippedY=false;
  maxTexCoordU=(float)w / glWidth;
  maxTexCoordV=(float)h / glHeight;
}",0.9887005649717514
109225,"/** 
 * Sets the texture as flipped or not flipped on the vertical direction.
 * @param v boolean;
 */
protected void setFlippedY(boolean v){
  flippedY=v;
}","/** 
 * Sets the texture as flipped or not flipped on the vertical direction.
 * @param v boolean;
 */
public void setFlippedY(boolean v){
  flippedY=v;
}",0.964630225080386
109226,"public void addChild(PShape who){
  if (family == GROUP) {
    super.addChild(who);
    PShape3D who3d=(PShape3D)who;
    who3d.papplet=papplet;
    who3d.a3d=a3d;
    who3d.gl=gl;
    for (int n=who3d.firstVertex; n < who3d.lastVertex; n++) {
      vertexChild[n]=who3d;
    }
  }
 else {
    PGraphics.showWarning(""String_Node_Str"");
  }
}","public void addChild(PShape who){
  if (family == GROUP) {
    super.addChild(who);
    PShape3D who3d=(PShape3D)who;
    who3d.papplet=papplet;
    who3d.a3d=a3d;
    who3d.gl=gl;
    for (int n=who3d.firstVertex; n <= who3d.lastVertex; n++) {
      vertexChild[n]=who3d;
    }
  }
 else {
    PGraphics.showWarning(""String_Node_Str"");
  }
}",0.9985358711566618
109227,"/** 
 * Similar to gluPerspective(). Implementation based on Mesa's glu.c
 */
public void perspective(float fov,float aspect,float zNear,float zFar){
  float ymax=cameraNear * (float)Math.tan(cameraFOV / 2);
  float ymin=-ymax;
  float xmin=ymin * cameraAspect;
  float xmax=ymax * cameraAspect;
  frustum(xmin,xmax,ymin,ymax,cameraNear,cameraFar);
}","/** 
 * Similar to gluPerspective(). Implementation based on Mesa's glu.c
 */
public void perspective(float fov,float aspect,float zNear,float zFar){
  float ymax=zNear * (float)Math.tan(fov / 2);
  float ymin=-ymax;
  float xmin=ymin * aspect;
  float xmax=ymax * aspect;
  frustum(xmin,xmax,ymin,ymax,zNear,zFar);
}",0.815592203898051
109228,"/** 
 * More flexible method for dealing with camera(). <P> The actual call is like gluLookat. Here's the real skinny on what does what: <PRE> camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz); </PRE> do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used. <P> Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following: <PRE> beginCamera(); rotateY(PI / 8); endCamera(); </PRE> will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this: <PRE> beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera(); </PRE> That will rotate a little off of the default view. Note that this is entirely equivalent to <PRE> camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera(); </PRE> because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
 */
public void camera(float eyeX,float eyeY,float eyeZ,float centerX,float centerY,float centerZ,float upX,float upY,float upZ){
  eyeY=height - eyeY;
  centerY=height - centerY;
  float z0=eyeX - centerX;
  float z1=eyeY - centerY;
  float z2=eyeZ - centerZ;
  float mag=sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  if (mag != 0) {
    z0/=mag;
    z1/=mag;
    z2/=mag;
  }
  float y0=upX;
  float y1=upY;
  float y2=upZ;
  float x0=y1 * z2 - y2 * z1;
  float x1=-y0 * z2 + y2 * z0;
  float x2=y0 * z1 - y1 * z0;
  y0=z1 * x2 - z2 * x1;
  y1=-z0 * x2 + z2 * x0;
  y2=z0 * x1 - z1 * x0;
  mag=sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (mag != 0) {
    x0/=mag;
    x1/=mag;
    x2/=mag;
  }
  mag=sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (mag != 0) {
    y0/=mag;
    y1/=mag;
    y2/=mag;
  }
  float[] m=glmodelview;
  m[0]=x0;
  m[1]=y0;
  m[2]=z0;
  m[3]=0.0f;
  m[4]=x1;
  m[5]=y1;
  m[6]=z1;
  m[7]=0.0f;
  m[8]=x2;
  m[9]=y2;
  m[10]=z2;
  m[11]=0;
  m[12]=0.0f;
  m[13]=0.0f;
  m[14]=0.0f;
  m[15]=1.0f;
  float tx=-eyeX;
  float ty=-eyeY + height;
  float tz=-eyeZ;
  m[12]+=tx * m[0] + ty * m[4] + tz * m[8];
  m[13]+=tx * m[1] + ty * m[5] + tz * m[9];
  m[14]+=tx * m[2] + ty * m[6] + tz * m[10];
  m[15]+=tx * m[3] + ty * m[7] + tz * m[11];
  m[4]=-m[4];
  m[5]=-m[5];
  m[6]=-m[6];
  m[7]=-m[7];
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glLoadMatrixf(glmodelview,0);
  if (usingModelviewStack) {
    modelviewStack.set(glmodelview);
  }
  copyGLArrayToPMatrix(glmodelview,modelview);
  modelviewUpdated=true;
  calculateModelviewInvNoScaling();
  PApplet.arrayCopy(glmodelview,pcamera);
  PApplet.arrayCopy(glmodelviewInv,pcameraInv);
  copyGLArrayToPMatrix(pcamera,camera);
  copyGLArrayToPMatrix(pcameraInv,cameraInv);
}","/** 
 * More flexible method for dealing with camera(). <P> The actual call is like gluLookat. Here's the real skinny on what does what: <PRE> camera(); or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz); </PRE> do not need to be called from with beginCamera();/endCamera(); That's because they always apply to the camera transformation, and they always totally replace it. That means that any coordinate transforms done before camera(); in draw() will be wiped out. It also means that camera() always operates in untransformed world coordinates. Therefore it is always redundant to call resetMatrix(); before camera(); This isn't technically true of gluLookat, but it's pretty much how it's used. <P> Now, beginCamera(); and endCamera(); are useful if you want to move the camera around using transforms like translate(), etc. They will wipe out any coordinate system transforms that occur before them in draw(), but they will not automatically wipe out the camera transform. This means that they should be at the top of draw(). It also means that the following: <PRE> beginCamera(); rotateY(PI / 8); endCamera(); </PRE> will result in a camera that spins without stopping. If you want to just rotate a small constant amount, try this: <PRE> beginCamera(); camera(); // sets up the default view rotateY(PI / 8); endCamera(); </PRE> That will rotate a little off of the default view. Note that this is entirely equivalent to <PRE> camera(); // sets up the default view beginCamera(); rotateY(PI / 8); endCamera(); </PRE> because camera() doesn't care whether or not it's inside a begin/end clause. Basically it's safe to use camera() or camera(ex, ey, ez, cx, cy, cz, ux, uy, uz) as naked calls because they do all the matrix resetting automatically.
 */
public void camera(float eyeX,float eyeY,float eyeZ,float centerX,float centerY,float centerZ,float upX,float upY,float upZ){
  eyeY=height - eyeY;
  centerY=height - centerY;
  currentEyeX=eyeX;
  currentCenterY=centerY;
  float z0=eyeX - centerX;
  float z1=eyeY - centerY;
  float z2=eyeZ - centerZ;
  float mag=sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  if (mag != 0) {
    z0/=mag;
    z1/=mag;
    z2/=mag;
  }
  float y0=upX;
  float y1=upY;
  float y2=upZ;
  float x0=y1 * z2 - y2 * z1;
  float x1=-y0 * z2 + y2 * z0;
  float x2=y0 * z1 - y1 * z0;
  y0=z1 * x2 - z2 * x1;
  y1=-z0 * x2 + z2 * x0;
  y2=z0 * x1 - z1 * x0;
  mag=sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (mag != 0) {
    x0/=mag;
    x1/=mag;
    x2/=mag;
  }
  mag=sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (mag != 0) {
    y0/=mag;
    y1/=mag;
    y2/=mag;
  }
  float[] m=glmodelview;
  m[0]=x0;
  m[1]=y0;
  m[2]=z0;
  m[3]=0.0f;
  m[4]=x1;
  m[5]=y1;
  m[6]=z1;
  m[7]=0.0f;
  m[8]=x2;
  m[9]=y2;
  m[10]=z2;
  m[11]=0;
  m[12]=0.0f;
  m[13]=0.0f;
  m[14]=0.0f;
  m[15]=1.0f;
  float tx=-eyeX;
  float ty=-eyeY + height;
  float tz=-eyeZ;
  m[12]+=tx * m[0] + ty * m[4] + tz * m[8];
  m[13]+=tx * m[1] + ty * m[5] + tz * m[9];
  m[14]+=tx * m[2] + ty * m[6] + tz * m[10];
  m[15]+=tx * m[3] + ty * m[7] + tz * m[11];
  m[4]=-m[4];
  m[5]=-m[5];
  m[6]=-m[6];
  m[7]=-m[7];
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glLoadMatrixf(glmodelview,0);
  if (usingModelviewStack) {
    modelviewStack.set(glmodelview);
  }
  copyGLArrayToPMatrix(glmodelview,modelview);
  modelviewUpdated=true;
  calculateModelviewInvNoScaling();
  PApplet.arrayCopy(glmodelview,pcamera);
  PApplet.arrayCopy(glmodelviewInv,pcameraInv);
  copyGLArrayToPMatrix(pcamera,camera);
  copyGLArrayToPMatrix(pcameraInv,cameraInv);
}",0.99342293394338
109229,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  perspective();
  camera();
  lights=false;
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (offscreenFramebuffer == null) {
          createOffscreenFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (texture == null) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (offscreenFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(offscreenFramebuffer);
          offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            drawOffscreenTexture((offscreenIndex + 1) % 2);
          }
        }
      }
 else {
        if (texture != null) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (offscreenFramebuffer == null) {
      createOffscreenFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
    offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      drawOffscreenTexture((offscreenIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lights=false;
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (offscreenFramebuffer == null) {
          createOffscreenFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (texture == null) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (offscreenFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(offscreenFramebuffer);
          offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            drawOffscreenTexture((offscreenIndex + 1) % 2);
          }
        }
      }
 else {
        if (texture != null) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (offscreenFramebuffer == null) {
      createOffscreenFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(offscreenFramebuffer);
    offscreenFramebuffer.setColorBuffer(offscreenTextures[offscreenIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      drawOffscreenTexture((offscreenIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}",0.9963302752293578
109230,"/** 
 * Similar to gluOrtho(), but wipes out the current projection matrix. <P> Implementation partially based on Mesa's matrix.c.
 */
public void ortho(float left,float right,float bottom,float top,float near,float far){
  float x=2.0f / (right - left);
  float y=2.0f / (top - bottom);
  float z=-2.0f / (far - near);
  float tx=-(right + left) / (right - left);
  float ty=-(top + bottom) / (top - bottom);
  float tz=-(far + near) / (far - near);
  glprojection[0]=x;
  glprojection[1]=0.0f;
  glprojection[2]=0.0f;
  glprojection[3]=0.0f;
  glprojection[4]=0.0f;
  glprojection[5]=y;
  glprojection[6]=0.0f;
  glprojection[7]=0.0f;
  glprojection[8]=0;
  glprojection[9]=0;
  glprojection[10]=z;
  glprojection[11]=0.0f;
  glprojection[12]=tx;
  glprojection[13]=ty;
  glprojection[14]=tz;
  glprojection[15]=1.0f;
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadMatrixf(glprojection,0);
  copyGLArrayToPMatrix(glprojection,projection);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
}","/** 
 * Properly setting the ortographic projection depends on the values  used to set the camera (eye and center).
 */
public void ortho(float left,float right,float bottom,float top,float near,float far){
  left-=currentEyeX;
  right-=currentEyeX;
  bottom-=currentCenterY;
  top-=currentCenterY;
  float x=2.0f / (right - left);
  float y=2.0f / (top - bottom);
  float z=-2.0f / (far - near);
  float tx=-(right + left) / (right - left);
  float ty=-(top + bottom) / (top - bottom);
  float tz=-(far + near) / (far - near);
  glprojection[0]=x;
  glprojection[1]=0.0f;
  glprojection[2]=0.0f;
  glprojection[3]=0.0f;
  glprojection[4]=0.0f;
  glprojection[5]=y;
  glprojection[6]=0.0f;
  glprojection[7]=0.0f;
  glprojection[8]=0;
  glprojection[9]=0;
  glprojection[10]=z;
  glprojection[11]=0.0f;
  glprojection[12]=tx;
  glprojection[13]=ty;
  glprojection[14]=tz;
  glprojection[15]=1.0f;
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glLoadMatrixf(glprojection,0);
  copyGLArrayToPMatrix(glprojection,projection);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
}",0.8477728830151737
109231,"protected void updatePixelsImpl(int x,int y,int w,int h){
  int x2=x + w;
  int y2=y + h;
  if (!modified) {
    mx1=x;
    mx2=x2;
    my1=y;
    my2=y2;
    modified=true;
  }
 else {
    if (x < mx1)     mx1=x;
    if (x > mx2)     mx2=x;
    if (y < my1)     my1=y;
    if (y > my2)     my2=y;
    if (x2 < mx1)     mx1=x2;
    if (x2 > mx2)     mx2=x2;
    if (y2 < my1)     my1=y2;
    if (y2 > my2)     my2=y2;
  }
}","protected void updatePixelsImpl(int x,int y,int w,int h){
  int x2=x + w;
  int y2=y + h;
  if (!modified) {
    mx1=x;
    mx2=x2;
    my1=y;
    my2=y2;
    modified=true;
  }
 else {
    if (x < mx1)     mx1=x;
    if (x > mx2)     mx2=x;
    if (y < my1)     my1=y;
    if (y > my2)     my2=y;
    if (x2 < mx1)     mx1=x2;
    if (x2 > mx2)     mx2=x2;
    if (y2 < my1)     my1=y2;
    if (y2 > my2)     my2=y2;
  }
  if (texture != null) {
  }
}",0.9668571428571427
109232,"/** 
 * Call this when you want to mess with the pixels[] array. <p/> For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
 */
public void loadPixels(){
  if (pixels == null || pixels.length != width * height) {
    pixels=new int[width * height];
  }
  if (bitmap != null) {
    bitmap.getPixels(pixels,0,width,0,0,width,height);
  }
}","/** 
 * Call this when you want to mess with the pixels[] array. <p/> For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
 */
public void loadPixels(){
  if (pixels == null || pixels.length != width * height) {
    pixels=new int[width * height];
  }
  if (bitmap != null) {
    bitmap.getPixels(pixels,0,width,0,0,width,height);
  }
  if (texture != null) {
  }
}",0.9646772228989038
109233,"static public boolean saveStream(File targetFile,InputStream sourceStream){
  File tempFile=null;
  try {
    File parentDir=targetFile.getParentFile();
    tempFile=File.createTempFile(targetFile.getName(),null,parentDir);
    BufferedInputStream bis=new BufferedInputStream(sourceStream,16384);
    FileOutputStream fos=new FileOutputStream(tempFile);
    BufferedOutputStream bos=new BufferedOutputStream(fos);
    byte[] buffer=new byte[8192];
    int bytesRead;
    while ((bytesRead=bis.read(buffer)) != -1) {
      bos.write(buffer,0,bytesRead);
    }
    bos.flush();
    bos.close();
    bos=null;
    if (!tempFile.renameTo(targetFile)) {
      System.err.println(""String_Node_Str"" + tempFile.getAbsolutePath());
      return false;
    }
    return true;
  }
 catch (  IOException e) {
    if (tempFile != null) {
      tempFile.delete();
    }
    e.printStackTrace();
    return false;
  }
}","static public boolean saveStream(File targetFile,InputStream sourceStream){
  File tempFile=null;
  try {
    File parentDir=targetFile.getParentFile();
    createPath(targetFile);
    tempFile=File.createTempFile(targetFile.getName(),null,parentDir);
    BufferedInputStream bis=new BufferedInputStream(sourceStream,16384);
    FileOutputStream fos=new FileOutputStream(tempFile);
    BufferedOutputStream bos=new BufferedOutputStream(fos);
    byte[] buffer=new byte[8192];
    int bytesRead;
    while ((bytesRead=bis.read(buffer)) != -1) {
      bos.write(buffer,0,bytesRead);
    }
    bos.flush();
    bos.close();
    bos=null;
    if (!tempFile.renameTo(targetFile)) {
      System.err.println(""String_Node_Str"" + tempFile.getAbsolutePath());
      return false;
    }
    return true;
  }
 catch (  IOException e) {
    if (tempFile != null) {
      tempFile.delete();
    }
    e.printStackTrace();
    return false;
  }
}",0.9847494553376906
109234,"/** 
 * I want to print lines to a file. Why am I always explaining myself? It's the JavaSoft API engineers who need to explain themselves.
 */
static public PrintWriter createWriter(OutputStream output){
  try {
    OutputStreamWriter osw=new OutputStreamWriter(output,""String_Node_Str"");
    return new PrintWriter(osw);
  }
 catch (  UnsupportedEncodingException e) {
  }
  return null;
}","/** 
 * I want to print lines to a file. Why am I always explaining myself? It's the JavaSoft API engineers who need to explain themselves.
 */
static public PrintWriter createWriter(OutputStream output){
  try {
    BufferedOutputStream bos=new BufferedOutputStream(output,8192);
    OutputStreamWriter osw=new OutputStreamWriter(bos,""String_Node_Str"");
    return new PrintWriter(osw);
  }
 catch (  UnsupportedEncodingException e) {
  }
  return null;
}",0.885478158205431
109235,"/** 
 * Takes a path and creates any in-between folders if they don't already exist. Useful when trying to save to a subfolder that may not actually exist.
 */
static public void createPath(String path){
  try {
    File file=new File(path);
    String parent=file.getParent();
    if (parent != null) {
      File unit=new File(parent);
      if (!unit.exists())       unit.mkdirs();
    }
  }
 catch (  SecurityException se) {
    System.err.println(""String_Node_Str"" + path);
  }
}","static public void createPath(File file){
  try {
    String parent=file.getParent();
    if (parent != null) {
      File unit=new File(parent);
      if (!unit.exists())       unit.mkdirs();
    }
  }
 catch (  SecurityException se) {
    System.err.println(""String_Node_Str"" + file.getAbsolutePath());
  }
}",0.7103274559193955
109236,"/** 
 * Returns a path inside the applet folder to save to. Like sketchPath(), but creates any in-between folders so that things save properly. <p/> All saveXxxx() functions use the path to the sketch folder, rather than its data folder. Once exported, the data folder will be found inside the jar file of the exported application or applet. In this case, it's not possible to save data into the jar file, because it will often be running from a server, or marked in-use if running from a local file system. With this in mind, saving to the data path doesn't make sense anyway. If you know you're running locally, and want to save to the data folder, use <TT>saveXxxx(""data/blah.dat"")</TT>.
 */
public String savePath(String where){
  if (where == null)   return null;
  System.out.println(""String_Node_Str"" + where);
  String filename=sketchPath(where);
  System.out.println(""String_Node_Str"" + filename);
  createPath(filename);
  return filename;
}","/** 
 * Returns a path inside the applet folder to save to. Like sketchPath(), but creates any in-between folders so that things save properly. <p/> All saveXxxx() functions use the path to the sketch folder, rather than its data folder. Once exported, the data folder will be found inside the jar file of the exported application or applet. In this case, it's not possible to save data into the jar file, because it will often be running from a server, or marked in-use if running from a local file system. With this in mind, saving to the data path doesn't make sense anyway. If you know you're running locally, and want to save to the data folder, use <TT>saveXxxx(""data/blah.dat"")</TT>.
 */
public String savePath(String where){
  if (where == null)   return null;
  String filename=sketchPath(where);
  createPath(filename);
  return filename;
}",0.9050527484730704
109237,"/** 
 * Calculate the angle between two vectors, using the dot product
 * @param v1 a vector
 * @param v2 another vector
 * @return the angle between the vectors
 */
static public float angleBetween(PVector v1,PVector v2){
  float dot=v1.dot(v2);
  float theta=(float)Math.acos(dot / (v1.mag() * v2.mag()));
  return theta;
}","/** 
 * Calculate the angle between two vectors, using the dot product
 * @param v1 a vector
 * @param v2 another vector
 * @return the angle between the vectors
 */
static public float angleBetween(PVector v1,PVector v2){
  double dot=v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  double v1mag=Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
  double v2mag=Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
  double amt=dot / (v1mag * v2mag);
  if (amt <= -1 || amt >= 1) {
    return PConstants.PI;
  }
  return (float)Math.acos(amt);
}",0.5796766743648961
109238,"/** 
 * Returns the value of an attribute.
 * @param name the non-null full name of the attribute.
 * @param defaultValue the default value of the attribute.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public double getDouble(String name,double defaultValue){
  String value=this.getAttribute(name,Double.toString(defaultValue));
  return Double.parseDouble(value);
}","/** 
 * Returns the value of an attribute.
 * @param name the non-null full name of the attribute.
 * @param defaultValue the default value of the attribute.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public double getDouble(String name,double defaultValue){
  String value=getString(name);
  return (value == null) ? defaultValue : Double.parseDouble(value);
}",0.8874841972187105
109239,"/** 
 * Returns a float attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @return the value, or defaultValue if the attribute does not exist.
 * @webref
 * @brief Returns a float attribute of the element.
 */
public float getFloat(String name,float defaultValue){
  String value=this.getAttribute(name,Float.toString(defaultValue));
  return Float.parseFloat(value);
}","/** 
 * Returns a float attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @return the value, or defaultValue if the attribute does not exist.
 * @webref
 * @brief Returns a float attribute of the element.
 */
public float getFloat(String name,float defaultValue){
  String value=getString(name);
  if (value == null) {
    return defaultValue;
  }
  return PApplet.parseFloat(value,defaultValue);
}",0.9061624649859944
109240,"/** 
 * Returns a boolean attribute of the element. If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> is returned. When using the version of the method without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value false is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns a boolean attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public boolean getBoolean(String name,boolean defaultValue){
  String value=this.getAttribute(name,Boolean.toString(defaultValue));
  return value.equals(""String_Node_Str"") || value.toLowerCase().equals(""String_Node_Str"");
}","/** 
 * Returns a boolean attribute of the element. If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> is returned. When using the version of the method without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value false is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns a boolean attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public boolean getBoolean(String name,boolean defaultValue){
  String value=getString(name);
  return (value != null) && (value.equals(""String_Node_Str"") || value.toLowerCase().equals(""String_Node_Str""));
}",0.8393782383419689
109241,"/** 
 * Returns a String attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @webref
 * @param name the name of the attribute
 * @param default Value value returned if the attribute is not found
 * @brief Returns a String attribute of the element.
 * @deprecated use getString() or getAttribute()
 */
public String getStringAttribute(String name,String defaultValue){
  return getAttribute(name,defaultValue);
}","/** 
 * Returns a String attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @webref
 * @param name the name of the attribute
 * @param default Value value returned if the attribute is not found
 * @brief Returns a String attribute of the element.
 * @deprecated use getString() or getAttribute()
 */
public String getStringAttribute(String name,String defaultValue){
  return getString(name,defaultValue);
}",0.988085782366958
109242,"public String getString(String name,String defaultValue){
  return getAttribute(name,defaultValue);
}","public String getString(String name,String defaultValue){
  XMLAttribute attr=this.findAttribute(name);
  if (attr == null) {
    return defaultValue;
  }
 else {
    return attr.getValue();
  }
}",0.6397306397306397
109243,"/** 
 * Returns an integer attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns an integer attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public int getInt(String name,int defaultValue){
  String value=this.getAttribute(name,Integer.toString(defaultValue));
  return Integer.parseInt(value);
}","/** 
 * Returns an integer attribute of the element. If the <b>default</b> parameter is used and the attribute doesn't exist, the <b>default</b> value is returned. When using the version of the method without the <b>default</b> parameter, if the attribute doesn't exist, the value 0 is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns an integer attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public int getInt(String name,int defaultValue){
  String value=getString(name);
  return (value == null) ? defaultValue : PApplet.parseInt(value,defaultValue);
}",0.9240596167494676
109244,"/** 
 * Returns true if the element equals another element.
 * @param rawElement the element to compare to
 */
public boolean equals(Object object){
  if (!(object instanceof XMLElement)) {
    return false;
  }
  XMLElement rawElement=(XMLElement)object;
  if (!this.name.equals(rawElement.getLocalName())) {
    return false;
  }
  if (this.attributes.size() != rawElement.getAttributeCount()) {
    return false;
  }
  Enumeration<XMLAttribute> en=this.attributes.elements();
  while (en.hasMoreElements()) {
    XMLAttribute attr=(XMLAttribute)en.nextElement();
    if (!rawElement.hasAttribute(attr.getName())) {
      return false;
    }
    String value=rawElement.getAttribute(attr.getName(),null);
    if (!attr.getValue().equals(value)) {
      return false;
    }
  }
  if (this.children.size() != rawElement.getChildCount()) {
    return false;
  }
  for (int i=0; i < this.children.size(); i++) {
    XMLElement child1=this.getChild(i);
    XMLElement child2=rawElement.getChild(i);
    if (!child1.equals(child2)) {
      return false;
    }
  }
  return true;
}","/** 
 * Returns true if the element equals another element.
 * @param rawElement the element to compare to
 */
public boolean equals(Object object){
  if (!(object instanceof XMLElement)) {
    return false;
  }
  XMLElement rawElement=(XMLElement)object;
  if (!this.name.equals(rawElement.getLocalName())) {
    return false;
  }
  if (this.attributes.size() != rawElement.getAttributeCount()) {
    return false;
  }
  Enumeration<XMLAttribute> en=this.attributes.elements();
  while (en.hasMoreElements()) {
    XMLAttribute attr=(XMLAttribute)en.nextElement();
    if (!rawElement.hasAttribute(attr.getName())) {
      return false;
    }
    String value=rawElement.getString(attr.getName(),null);
    if (!attr.getValue().equals(value)) {
      return false;
    }
  }
  if (this.children.size() != rawElement.getChildCount()) {
    return false;
  }
  for (int i=0; i < this.children.size(); i++) {
    XMLElement child1=this.getChild(i);
    XMLElement child2=rawElement.getChild(i);
    if (!child1.equals(child2)) {
      return false;
    }
  }
  return true;
}",0.9930200093066542
109245,"/** 
 * Writes an XML element.
 * @param xml the non-null XML element to write.
 * @param prettyPrint if spaces need to be inserted to make the output morereadable
 * @param initialIndent how many spaces to indent the first element.
 */
public void write(XMLElement xml,boolean prettyPrint,int initialIndent,int eachIndent,boolean collapseEmptyElements) throws IOException {
  if (prettyPrint) {
    for (int i=0; i < initialIndent; i++) {
      this.writer.print(' ');
    }
  }
  if (xml.getLocalName() == null) {
    if (xml.getContent() != null) {
      if (prettyPrint) {
        this.writeEncoded(xml.getContent().trim());
        writer.println();
      }
 else {
        this.writeEncoded(xml.getContent());
      }
    }
  }
 else {
    this.writer.print('<');
    this.writer.print(xml.getName());
    for (    String key : xml.listAttributes()) {
      String value=xml.getAttribute(key,null);
      this.writer.print(""String_Node_Str"" + key + ""String_Node_Str"");
      this.writeEncoded(value);
      this.writer.print('""');
    }
    if ((xml.getContent() != null) && (xml.getContent().length() > 0)) {
      writer.print('>');
      this.writeEncoded(xml.getContent());
      writer.print(""String_Node_Str"" + xml.getName() + '>');
      if (prettyPrint) {
        writer.println();
      }
    }
 else     if (xml.hasChildren() || (!collapseEmptyElements)) {
      writer.print('>');
      if (prettyPrint) {
        writer.println();
      }
      int count=xml.getChildCount();
      for (int i=0; i < count; i++) {
        XMLElement child=xml.getChild(i);
        this.write(child,prettyPrint,initialIndent + eachIndent,eachIndent,collapseEmptyElements);
      }
      if (prettyPrint) {
        for (int i=0; i < initialIndent; i++) {
          this.writer.print(' ');
        }
      }
      this.writer.print(""String_Node_Str"" + xml.getName() + ""String_Node_Str"");
      if (prettyPrint) {
        writer.println();
      }
    }
 else {
      this.writer.print(""String_Node_Str"");
      if (prettyPrint) {
        writer.println();
      }
    }
  }
  this.writer.flush();
}","/** 
 * Writes an XML element.
 * @param xml the non-null XML element to write.
 * @param prettyPrint if spaces need to be inserted to make the output morereadable
 * @param initialIndent how many spaces to indent the first element.
 */
public void write(XMLElement xml,boolean prettyPrint,int initialIndent,int eachIndent,boolean collapseEmptyElements) throws IOException {
  if (prettyPrint) {
    for (int i=0; i < initialIndent; i++) {
      this.writer.print(' ');
    }
  }
  if (xml.getLocalName() == null) {
    if (xml.getContent() != null) {
      if (prettyPrint) {
        this.writeEncoded(xml.getContent().trim());
        writer.println();
      }
 else {
        this.writeEncoded(xml.getContent());
      }
    }
  }
 else {
    this.writer.print('<');
    this.writer.print(xml.getName());
    for (    String key : xml.listAttributes()) {
      String value=xml.getString(key,null);
      this.writer.print(""String_Node_Str"" + key + ""String_Node_Str"");
      this.writeEncoded(value);
      this.writer.print('""');
    }
    if ((xml.getContent() != null) && (xml.getContent().length() > 0)) {
      writer.print('>');
      this.writeEncoded(xml.getContent());
      writer.print(""String_Node_Str"" + xml.getName() + '>');
      if (prettyPrint) {
        writer.println();
      }
    }
 else     if (xml.hasChildren() || (!collapseEmptyElements)) {
      writer.print('>');
      if (prettyPrint) {
        writer.println();
      }
      int count=xml.getChildCount();
      for (int i=0; i < count; i++) {
        XMLElement child=xml.getChild(i);
        this.write(child,prettyPrint,initialIndent + eachIndent,eachIndent,collapseEmptyElements);
      }
      if (prettyPrint) {
        for (int i=0; i < initialIndent; i++) {
          this.writer.print(' ');
        }
      }
      this.writer.print(""String_Node_Str"" + xml.getName() + ""String_Node_Str"");
      if (prettyPrint) {
        writer.println();
      }
    }
 else {
      this.writer.print(""String_Node_Str"");
      if (prettyPrint) {
        writer.println();
      }
    }
  }
  this.writer.flush();
}",0.9964191931248508
109246,"public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    glEnableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}","public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    glEnableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][3]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9992307692307691
109247,"public void loadTexture(PTexture.Parameters params){
  if (texture == null) {
    texture=new PTexture(parent,width,height,params);
    texUpdated=false;
  }
  if (pixels != null) {
    pixelsToTexture();
  }
}","public void loadTexture(PTexture.Parameters params){
  if (texture == null) {
    texture=new PTexture(parent,width,height,params);
    texUpdated=false;
  }
  if (pixels == null) {
    loadPixels();
  }
 else {
    pixelsToTexture();
  }
}",0.76
109248,"/** 
 * Call this when you want to mess with the pixels[] array. <p/> For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
 */
public void loadPixels(){
  if (pixels == null || pixels.length != width * height) {
    pixels=new int[width * height];
  }
  if (bitmap != null) {
    bitmap.getPixels(pixels,0,width,0,0,width,height);
  }
  if (parent.g.is3D()) {
    loadTexture();
  }
}","/** 
 * Call this when you want to mess with the pixels[] array. <p/> For subclasses where the pixels[] buffer isn't set by default, this should copy all data into the pixels[] array
 */
public void loadPixels(){
  if (pixels == null || pixels.length != width * height) {
    pixels=new int[width * height];
  }
  if (bitmap != null) {
    bitmap.getPixels(pixels,0,width,0,0,width,height);
  }
  if (parent.g.is3D()) {
    if (texture == null) {
      texture=new PTexture(parent,width,height,new PTexture.Parameters(format));
      texUpdated=false;
    }
    pixelsToTexture();
  }
}",0.8543689320388349
109249,"private void writeLibraries(final File libsFolder,final File assetsFolder) throws IOException {
  final Sketch sketch=editor.getSketch();
  for (  LibraryFolder library : sketch.getImportedLibraries()) {
    final File exportSettings=new File(libraryFolder,""String_Node_Str"");
    final HashMap<String,String> exportTable=Base.readSettings(exportSettings);
    final String androidList=exportTable.get(""String_Node_Str"");
    String exportList[]=null;
    if (androidList != null) {
      exportList=PApplet.splitTokens(androidList,""String_Node_Str"");
    }
 else {
      exportList=libraryFolder.list();
    }
    for (int i=0; i < exportList.length; i++) {
      exportList[i]=PApplet.trim(exportList[i]);
      if (exportList[i].equals(""String_Node_Str"") || exportList[i].equals(""String_Node_Str"") || exportList[i].equals(""String_Node_Str"")) {
        continue;
      }
      final File exportFile=new File(libraryFolder,exportList[i]);
      if (!exportFile.exists()) {
        System.err.println(""String_Node_Str"" + exportList[i] + ""String_Node_Str"");
      }
 else       if (exportFile.isDirectory()) {
        System.err.println(""String_Node_Str"" + exportList[i] + ""String_Node_Str"");
      }
 else {
        final String name=exportFile.getName();
        final String lcname=name.toLowerCase();
        if (lcname.endsWith(""String_Node_Str"") || lcname.endsWith(""String_Node_Str"")) {
          final String jarName=name.substring(0,name.length() - 4) + ""String_Node_Str"";
          Base.copyFile(exportFile,new File(libsFolder,jarName));
        }
 else {
          Base.copyFile(exportFile,new File(assetsFolder,name));
        }
      }
    }
  }
  final File codeFolder=sketch.getCodeFolder();
  if (codeFolder != null && codeFolder.exists()) {
    for (    final File item : codeFolder.listFiles()) {
      if (!item.isDirectory()) {
        final String name=item.getName();
        final String lcname=name.toLowerCase();
        if (lcname.endsWith(""String_Node_Str"") || lcname.endsWith(""String_Node_Str"")) {
          String jarName=name.substring(0,name.length() - 4) + ""String_Node_Str"";
          Base.copyFile(item,new File(libsFolder,jarName));
        }
      }
    }
  }
}","private void writeLibraries(final File libsFolder,final File assetsFolder) throws IOException {
  final Sketch sketch=editor.getSketch();
  for (  LibraryFolder library : sketch.getImportedLibraries()) {
    File libraryFolder=new File(library.getPath());
    final File exportSettings=new File(libraryFolder,""String_Node_Str"");
    final HashMap<String,String> exportTable=Base.readSettings(exportSettings);
    final String androidList=exportTable.get(""String_Node_Str"");
    String exportList[]=null;
    if (androidList != null) {
      exportList=PApplet.splitTokens(androidList,""String_Node_Str"");
    }
 else {
      exportList=libraryFolder.list();
    }
    for (int i=0; i < exportList.length; i++) {
      exportList[i]=PApplet.trim(exportList[i]);
      if (exportList[i].equals(""String_Node_Str"") || exportList[i].equals(""String_Node_Str"") || exportList[i].equals(""String_Node_Str"")) {
        continue;
      }
      final File exportFile=new File(libraryFolder,exportList[i]);
      if (!exportFile.exists()) {
        System.err.println(""String_Node_Str"" + exportList[i] + ""String_Node_Str"");
      }
 else       if (exportFile.isDirectory()) {
        System.err.println(""String_Node_Str"" + exportList[i] + ""String_Node_Str"");
      }
 else {
        final String name=exportFile.getName();
        final String lcname=name.toLowerCase();
        if (lcname.endsWith(""String_Node_Str"") || lcname.endsWith(""String_Node_Str"")) {
          final String jarName=name.substring(0,name.length() - 4) + ""String_Node_Str"";
          Base.copyFile(exportFile,new File(libsFolder,jarName));
        }
 else {
          Base.copyFile(exportFile,new File(assetsFolder,name));
        }
      }
    }
  }
  final File codeFolder=sketch.getCodeFolder();
  if (codeFolder != null && codeFolder.exists()) {
    for (    final File item : codeFolder.listFiles()) {
      if (!item.isDirectory()) {
        final String name=item.getName();
        final String lcname=name.toLowerCase();
        if (lcname.endsWith(""String_Node_Str"") || lcname.endsWith(""String_Node_Str"")) {
          String jarName=name.substring(0,name.length() - 4) + ""String_Node_Str"";
          Base.copyFile(item,new File(libsFolder,jarName));
        }
      }
    }
  }
}",0.9882935614588024
109250,"/** 
 * Calculate the angle between two vectors, using the dot product
 * @param v1 a vector
 * @param v2 another vector
 * @return the angle between the vectors
 */
static public float angleBetween(PVector v1,PVector v2){
  double dot=v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  double v1mag=Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
  double v2mag=Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
  double amt=dot / (v1mag * v2mag);
  if (amt <= -1 || amt >= 1) {
    return PConstants.PI;
  }
  return (float)Math.acos(amt);
}","/** 
 * Calculate the angle between two vectors, using the dot product
 * @param v1 a vector
 * @param v2 another vector
 * @return the angle between the vectors
 */
static public float angleBetween(PVector v1,PVector v2){
  double dot=v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
  double v1mag=Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
  double v2mag=Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
  double amt=dot / (v1mag * v2mag);
  if (amt <= -1) {
    return PConstants.PI;
  }
 else   if (amt >= 1) {
    return 0;
  }
  return (float)Math.acos(amt);
}",0.9424460431654677
109251,"/** 
 * Returns the full name (i.e. the name including an eventual namespace prefix) of the element.
 * @webref
 * @brief  	Returns the name of the element.
 * @return the name, or null if the element only contains #PCDATA.
 */
public String getName(){
  return this.fullName;
}","/** 
 * Returns the full name (i.e. the name including an eventual namespace prefix) of the element.
 * @webref
 * @brief     Returns the name of the element.
 * @return the name, or null if the element only contains #PCDATA.
 */
public String getName(){
  return this.fullName;
}",0.992831541218638
109252,"/** 
 * Returns the content of an element. If there is no such content, <b>null</b> is returned. =advanced Return the #PCDATA content of the element. If the element has a combination of #PCDATA content and child elements, the #PCDATA sections can be retrieved as unnamed child objects. In this case, this method returns null.
 * @webref 
 * @brief  	Returns the content of an element
 * @return the content.
 */
public String getContent(){
  return this.content;
}","/** 
 * Returns the content of an element. If there is no such content, <b>null</b> is returned. =advanced Return the #PCDATA content of the element. If the element has a combination of #PCDATA content and child elements, the #PCDATA sections can be retrieved as unnamed child objects. In this case, this method returns null.
 * @webref
 * @brief     Returns the content of an element
 * @return the content.
 */
public String getContent(){
  return this.content;
}",0.9946178686759956
109253,"/** 
 * Returns a boolean attribute of the element. If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> is returned. When using the version of the method without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value false is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns a boolean attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public boolean getBoolean(String name,boolean defaultValue){
  String value=getString(name);
  return (value != null) && (value.equals(""String_Node_Str"") || value.toLowerCase().equals(""String_Node_Str""));
}","/** 
 * Returns a boolean attribute of the element. If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> is returned. When using the version of the method without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value false is returned.
 * @param name the name of the attribute
 * @param defaultValue value returned if the attribute is not found
 * @webref
 * @brief Returns a boolean attribute of the element.
 * @return the value, or defaultValue if the attribute does not exist.
 */
public boolean getBoolean(String name,boolean defaultValue){
  String value=getString(name);
  if (value == null) {
    return defaultValue;
  }
  return (value.equals(""String_Node_Str"") || value.toLowerCase().equals(""String_Node_Str""));
}",0.9672867222578576
109254,"/** 
 * Returns the name of the element without its namespace. 
 * @return the name, or null if the element only contains #PCDATA.
 */
public String getLocalName(){
  return this.name;
}","/** 
 * Returns the name of the element without its namespace.
 * @return the name, or null if the element only contains #PCDATA.
 */
public String getLocalName(){
  return this.name;
}",0.9973045822102424
109255,"/** 
 * Put the names of all children into an array. Same as looping through  each child and calling getName() on each XMLElement.
 */
public String[] listChildren(){
  int childCount=getChildCount();
  String[] outgoing=new String[childCount];
  for (int i=0; i < childCount; i++) {
    outgoing[i]=getChild(i).getName();
  }
  return outgoing;
}","/** 
 * Put the names of all children into an array. Same as looping through each child and calling getName() on each XMLElement.
 */
public String[] listChildren(){
  int childCount=getChildCount();
  String[] outgoing=new String[childCount];
  for (int i=0; i < childCount; i++) {
    outgoing[i]=getChild(i).getName();
  }
  return outgoing;
}",0.9985569985569984
109256,"protected void parseMTL(BufferedReader reader,ArrayList<OBJMaterial> materials,Hashtable<String,Integer> materialsHash){
  try {
    String line;
    OBJMaterial currentMtl=null;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      String elements[]=line.split(""String_Node_Str"");
      if (elements.length > 0) {
        if (elements[0].equals(""String_Node_Str"")) {
          String mtlname=elements[1];
          currentMtl=new OBJMaterial(mtlname);
          materialsHash.put(mtlname,new Integer(materials.size()));
          materials.add(currentMtl);
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 1) {
          String texname=elements[1];
          currentMtl.kdMap=parent.loadImage(texname);
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.ka.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.ka.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.ka.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.kd.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.kd.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.kd.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.ks.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.ks.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.ks.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if ((elements[0].equals(""String_Node_Str"") || elements[0].equals(""String_Node_Str"")) && elements.length > 1) {
          currentMtl.d=Float.valueOf(elements[1]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 1) {
          currentMtl.ns=Float.valueOf(elements[1]).floatValue();
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","protected void parseMTL(BufferedReader reader,ArrayList<OBJMaterial> materials,Hashtable<String,Integer> materialsHash){
  try {
    String line;
    OBJMaterial currentMtl=null;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      String elements[]=line.split(""String_Node_Str"");
      if (elements.length > 0) {
        if (elements[0].equals(""String_Node_Str"")) {
          String mtlname=elements[1];
          currentMtl=new OBJMaterial(mtlname);
          materialsHash.put(mtlname,new Integer(materials.size()));
          materials.add(currentMtl);
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 1) {
          String texname=elements[1];
          currentMtl.kdMap=parent.loadImage(texname);
          currentMtl.kdMap.getTexture().setFlippedY(true);
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.ka.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.ka.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.ka.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.kd.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.kd.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.kd.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 3) {
          currentMtl.ks.x=Float.valueOf(elements[1]).floatValue();
          currentMtl.ks.y=Float.valueOf(elements[2]).floatValue();
          currentMtl.ks.z=Float.valueOf(elements[3]).floatValue();
        }
 else         if ((elements[0].equals(""String_Node_Str"") || elements[0].equals(""String_Node_Str"")) && elements.length > 1) {
          currentMtl.d=Float.valueOf(elements[1]).floatValue();
        }
 else         if (elements[0].equals(""String_Node_Str"") && elements.length > 1) {
          currentMtl.ns=Float.valueOf(elements[1]).floatValue();
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.98603550295858
109257,"/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (gl11 == null || gl11x == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  if (!blend || blendMode != BLEND) {
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  }
  if (textFont.texIDList == null) {
    textFont.initTexture(gl,maxTextureSize,maxTextureSize);
    textFont.addAllGlyphsToTexture(gl);
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  textFont.currentTexID=textFont.texIDList[0];
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFont.currentTexID);
  gl.glColor4f(colorFloats[0],colorFloats[1],colorFloats[2],colorFloats[3]);
  if (textMode == MODEL) {
    if (textVertexBuffer == null) {
      allocateTextModel();
    }
    gl.glNormal3f(0,0,1);
    textVertexCount=0;
  }
  super.textLineImpl(buffer,start,stop,x,y);
  if (textMode == MODEL && 0 < textVertexCount) {
    renderTextModel();
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
  gl.glDisable(GL10.GL_TEXTURE_2D);
}","/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (gl11 == null || gl11x == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  if (!blend || blendMode != BLEND) {
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  }
  if (textFont.texIDList == null) {
    textFont.initTexture(gl,maxTextureSize,maxTextureSize);
    textFont.addAllGlyphsToTexture(gl);
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  textFont.currentTexID=textFont.texIDList[0];
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFont.currentTexID);
  gl.glColor4f(fillR,fillG,fillB,fillA);
  if (textMode == MODEL) {
    if (textVertexBuffer == null) {
      allocateTextModel();
    }
    gl.glNormal3f(0,0,1);
    textVertexCount=0;
  }
  super.textLineImpl(buffer,start,stop,x,y);
  if (textMode == MODEL && 0 < textVertexCount) {
    renderTextModel();
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
  gl.glDisable(GL10.GL_TEXTURE_2D);
}",0.9638128861429832
109258,"/** 
 * In the current implementation, start and stop are ignored (in OpenGL). This will obviously have to be revisited if/when proper depth sorting is implemented.
 */
protected void renderLines(int start,int stop){
  report(""String_Node_Str"");
  float sw0=0;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      if (sw0 != sw && recordingModel) {
        int n0=recordedVertices.size();
        int n1=n0 + pathLength[j];
        for (int k=j + 1; k < stop; k++) {
          int i1=pathOffset[k];
          float sw1=vertices[lines[i1][VERTEX1]][SW];
          if (sw0 != sw1) {
            break;
          }
          n1=n0 + pathLength[k];
        }
        VertexGroup group=PShape3D.newVertexGroup(n0,n1,LINE_STRIP,sw,null);
        recordedGroups.add(group);
      }
      if (vertexBuffer.capacity() / 3 <= 3 * (pathLength[j] + 1)) {
        expandBuffers();
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      int n=0;
      float a[]=vertices[lines[i][VERTEX1]];
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[SR],a[SG],a[SB],a[SA]});
        recordedNormals.add(new PVector(0,0,0));
        recordedTexCoords.add(new PVector(0,0,0));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[SR]);
        colorArray[4 * n + 1]=toFixed32(a[SG]);
        colorArray[4 * n + 2]=toFixed32(a[SB]);
        colorArray[4 * n + 3]=toFixed32(a[SA]);
        n++;
      }
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        if (recordingModel) {
          recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
          recordedColors.add(new float[]{b[SR],b[SG],b[SB],b[SA]});
          recordedNormals.add(new PVector(0,0,0));
          recordedTexCoords.add(new PVector(0,0,0));
        }
 else {
          vertexArray[3 * n + 0]=toFixed32(b[X]);
          vertexArray[3 * n + 1]=toFixed32(b[Y]);
          vertexArray[3 * n + 2]=toFixed32(b[Z]);
          colorArray[4 * n + 0]=toFixed32(b[SR]);
          colorArray[4 * n + 1]=toFixed32(b[SG]);
          colorArray[4 * n + 2]=toFixed32(b[SB]);
          colorArray[4 * n + 3]=toFixed32(b[SA]);
          n++;
        }
        i++;
      }
      if (!recordingModel) {
        vertexBuffer.put(vertexArray);
        colorBuffer.put(colorArray);
        vertexBuffer.position(0);
        colorBuffer.position(0);
        gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
        gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
        gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
      }
    }
    sw0=sw;
  }
  report(""String_Node_Str"");
}","/** 
 * In the current implementation, start and stop are ignored (in OpenGL). This will obviously have to be revisited if/when proper depth sorting is implemented.
 */
protected void renderLines(int start,int stop){
  report(""String_Node_Str"");
  float sw0=0;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      if (sw0 != sw && recordingModel) {
        int n0=recordedVertices.size();
        int n1=n0 + pathLength[j];
        for (int k=j + 1; k < stop; k++) {
          int i1=pathOffset[k];
          float sw1=vertices[lines[i1][VERTEX1]][SW];
          if (sw0 != sw1) {
            break;
          }
          n1=n0 + pathLength[k];
        }
        VertexGroup group=PShape3D.newVertexGroup(n0,n1,LINE_STRIP,sw,null);
        recordedGroups.add(group);
      }
      if (vertexBuffer.capacity() / 3 <= 3 * (pathLength[j] + 1)) {
        expandBuffers();
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      int n=0;
      float a[]=vertices[lines[i][VERTEX1]];
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[SR],a[SG],a[SB],a[SA]});
        recordedNormals.add(new PVector(0,0,0));
        recordedTexCoords.add(new PVector(0,0,0));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[SR]);
        colorArray[4 * n + 1]=toFixed32(a[SG]);
        colorArray[4 * n + 2]=toFixed32(a[SB]);
        colorArray[4 * n + 3]=toFixed32(a[SA]);
        n++;
      }
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        if (recordingModel) {
          recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
          recordedColors.add(new float[]{b[SR],b[SG],b[SB],b[SA]});
          recordedNormals.add(new PVector(0,0,0));
          recordedTexCoords.add(new PVector(0,0,0));
        }
 else {
          vertexArray[3 * n + 0]=toFixed32(b[X]);
          vertexArray[3 * n + 1]=toFixed32(b[Y]);
          vertexArray[3 * n + 2]=toFixed32(b[Z]);
          colorArray[4 * n + 0]=toFixed32(b[SR]);
          colorArray[4 * n + 1]=toFixed32(b[SG]);
          colorArray[4 * n + 2]=toFixed32(b[SB]);
          colorArray[4 * n + 3]=toFixed32(b[SA]);
          n++;
        }
        i++;
      }
      if (!recordingModel) {
        vertexBuffer.put(vertexArray);
        colorBuffer.put(colorArray);
        vertexBuffer.position(0);
        colorBuffer.position(0);
        gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
        gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
        gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
      }
    }
    sw0=sw;
  }
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  report(""String_Node_Str"");
}",0.9841425535393168
109259,"/** 
 * Disables lighting.
 */
public void noLights(){
  lights=false;
  gl.glDisable(GL10.GL_LIGHTING);
  lightCount=0;
}","/** 
 * Disables lighting.
 */
public void noLights(){
  disableLights();
  lightCount=0;
}",0.7887323943661971
109260,"public void pointLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=POINT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}","public void pointLight(float r,float g,float b,float x,float y,float z){
  if (!lights) {
    enableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=POINT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9820096533567354
109261,"public void spotLight(float r,float g,float b,float x,float y,float z,float nx,float ny,float nz,float angle,float concentration){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=SPOT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightSpotAngle[lightCount]=PApplet.degrees(angle);
  lightSpotAngleCos[lightCount]=Math.max(0,(float)Math.cos(angle));
  lightSpotConcentration[lightCount]=concentration;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightSpotAngle(lightCount);
  glLightSpotConcentration(lightCount);
  lightCount++;
}","public void spotLight(float r,float g,float b,float x,float y,float z,float nx,float ny,float nz,float angle,float concentration){
  if (!lights) {
    enableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=SPOT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightSpotAngle[lightCount]=PApplet.degrees(angle);
  lightSpotAngleCos[lightCount]=Math.max(0,(float)Math.cos(angle));
  lightSpotConcentration[lightCount]=concentration;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightSpotAngle(lightCount);
  glLightSpotConcentration(lightCount);
  lightCount++;
}",0.9875719915125796
109262,"/** 
 * Sets up an ambient and directional light using OpenGL. API takef from PGraphics3D. <PRE> The Lighting Skinny: The way lighting works is complicated enough that it's worth producing a document to describe it. Lighting calculations proceed pretty much exactly as described in the OpenGL red book. Light-affecting material properties: AMBIENT COLOR - multiplies by light's ambient component - for believability this should match diffuse color DIFFUSE COLOR - multiplies by light's diffuse component SPECULAR COLOR - multiplies by light's specular component - usually less colored than diffuse/ambient SHININESS - the concentration of specular effect - this should be set pretty high (20-50) to see really noticeable specularity EMISSIVE COLOR - constant additive color effect Light types: AMBIENT - one color - no specular color - no direction - may have falloff (constant, linear, and quadratic) - may have position (which matters in non-constant falloff case) - multiplies by a material's ambient reflection DIRECTIONAL - has diffuse color - has specular color - has direction - no position - no falloff - multiplies by a material's diffuse and specular reflections POINT - has diffuse color - has specular color - has position - no direction - may have falloff (constant, linear, and quadratic) - multiplies by a material's diffuse and specular reflections SPOT - has diffuse color - has specular color - has position - has direction - has cone angle (set to half the total cone angle) - has concentration value - may have falloff (constant, linear, and quadratic) - multiplies by a material's diffuse and specular reflections Normal modes: All of the primitives (rect, box, sphere, etc.) have their normals set nicely. During beginShape/endShape normals can be set by the user. AUTO-NORMAL - if no normal is set during the shape, we are in auto-normal mode - auto-normal calculates one normal per triangle (face-normal mode) SHAPE-NORMAL - if one normal is set during the shape, it will be used for all vertices VERTEX-NORMAL - if multiple normals are set, each normal applies to subsequent vertices - (except for the first one, which applies to previous and subsequent vertices) Efficiency consequences: There is a major efficiency consequence of position-dependent lighting calculations per vertex. (See below for determining whether lighting is vertex position-dependent.) If there is no position dependency then the only factors that affect the lighting contribution per vertex are its colors and its normal. There is a major efficiency win if 1) lighting is not position dependent 2) we are in AUTO-NORMAL or SHAPE-NORMAL mode because then we can calculate one lighting contribution per shape (SHAPE-NORMAL) or per triangle (AUTO-NORMAL) and simply multiply it into the vertex colors. The converse is our worst-case performance when 1) lighting is position dependent 2) we are in AUTO-NORMAL mode because then we must calculate lighting per-face * per-vertex. Each vertex has a different lighting contribution per face in which it appears. Yuck. Determining vertex position dependency: If any of the following factors are TRUE then lighting is vertex position dependent: 1) Any lights uses non-constant falloff 2) There are any point or spot lights 3) There is a light with specular color AND there is a material with specular color So worth noting is that default lighting (a no-falloff ambient and a directional without specularity) is not position-dependent. We should capitalize. Simon Greenwold, April 2005 </PRE>
 */
public void lights(){
  lights=true;
  gl.glEnable(GL10.GL_LIGHTING);
  int colorModeSaved=colorMode;
  colorMode=RGB;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  ambientLight(colorModeX * 0.5f,colorModeY * 0.5f,colorModeZ * 0.5f);
  directionalLight(colorModeX * 0.5f,colorModeY * 0.5f,colorModeZ * 0.5f,0,0,-1);
  colorMode=colorModeSaved;
}","/** 
 * Sets up an ambient and directional light using OpenGL. API taken from PGraphics3D. <PRE> The Lighting Skinny: The way lighting works is complicated enough that it's worth producing a document to describe it. Lighting calculations proceed pretty much exactly as described in the OpenGL red book. Light-affecting material properties: AMBIENT COLOR - multiplies by light's ambient component - for believability this should match diffuse color DIFFUSE COLOR - multiplies by light's diffuse component SPECULAR COLOR - multiplies by light's specular component - usually less colored than diffuse/ambient SHININESS - the concentration of specular effect - this should be set pretty high (20-50) to see really noticeable specularity EMISSIVE COLOR - constant additive color effect Light types: AMBIENT - one color - no specular color - no direction - may have falloff (constant, linear, and quadratic) - may have position (which matters in non-constant falloff case) - multiplies by a material's ambient reflection DIRECTIONAL - has diffuse color - has specular color - has direction - no position - no falloff - multiplies by a material's diffuse and specular reflections POINT - has diffuse color - has specular color - has position - no direction - may have falloff (constant, linear, and quadratic) - multiplies by a material's diffuse and specular reflections SPOT - has diffuse color - has specular color - has position - has direction - has cone angle (set to half the total cone angle) - has concentration value - may have falloff (constant, linear, and quadratic) - multiplies by a material's diffuse and specular reflections Normal modes: All of the primitives (rect, box, sphere, etc.) have their normals set nicely. During beginShape/endShape normals can be set by the user. AUTO-NORMAL - if no normal is set during the shape, we are in auto-normal mode - auto-normal calculates one normal per triangle (face-normal mode) SHAPE-NORMAL - if one normal is set during the shape, it will be used for all vertices VERTEX-NORMAL - if multiple normals are set, each normal applies to subsequent vertices - (except for the first one, which applies to previous and subsequent vertices) Efficiency consequences: There is a major efficiency consequence of position-dependent lighting calculations per vertex. (See below for determining whether lighting is vertex position-dependent.) If there is no position dependency then the only factors that affect the lighting contribution per vertex are its colors and its normal. There is a major efficiency win if 1) lighting is not position dependent 2) we are in AUTO-NORMAL or SHAPE-NORMAL mode because then we can calculate one lighting contribution per shape (SHAPE-NORMAL) or per triangle (AUTO-NORMAL) and simply multiply it into the vertex colors. The converse is our worst-case performance when 1) lighting is position dependent 2) we are in AUTO-NORMAL mode because then we must calculate lighting per-face * per-vertex. Each vertex has a different lighting contribution per face in which it appears. Yuck. Determining vertex position dependency: If any of the following factors are TRUE then lighting is vertex position dependent: 1) Any lights uses non-constant falloff 2) There are any point or spot lights 3) There is a light with specular color AND there is a material with specular color So worth noting is that default lighting (a no-falloff ambient and a directional without specularity) is not position-dependent. We should capitalize. Simon Greenwold, April 2005 </PRE>
 */
public void lights(){
  enableLights();
  int colorModeSaved=colorMode;
  colorMode=RGB;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  ambientLight(colorModeX * 0.5f,colorModeY * 0.5f,colorModeZ * 0.5f);
  directionalLight(colorModeX * 0.5f,colorModeY * 0.5f,colorModeZ * 0.5f,0,0,-1);
  colorMode=colorModeSaved;
}",0.9940568475452196
109263,"public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}","public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (!lights) {
    enableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9839530332681018
109264,"/** 
 * Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
 */
public void ambientLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=AMBIENT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightAmbient(lightCount);
  glLightPosition(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}","/** 
 * Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
 */
public void ambientLight(float r,float g,float b,float x,float y,float z){
  if (!lights) {
    enableLights();
  }
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=AMBIENT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightAmbient(lightCount);
  glLightPosition(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  glLightNoDiffuse(lightCount);
  glLightNoSpecular(lightCount);
  lightCount++;
}",0.9520795660036168
109265,"protected void vertexCheck(){
  if (vertexCount == vertices.length) {
    float temp[][]=new float[vertexCount << 1][VERTEX_FIELD_COUNT];
    System.arraycopy(vertices,0,temp,0,vertexCount);
    vertices=temp;
  }
}","protected void vertexCheck(){
  if (vertexCount == vertices.length) {
    float temp[][]=new float[vertexCount << 1][VERTEX_FIELD_COUNT];
    System.arraycopy(vertices,0,temp,0,vertexCount);
    vertices=temp;
    PImage texTmp[]=new PImage[vertexCount << 1];
    System.arraycopy(verticesTexture,0,texTmp,0,vertexCount);
    verticesTexture=texTmp;
  }
}",0.7543859649122807
109266,"protected void addNewFace(boolean firstFace){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    faceTexture=PApplet.expand(faceTexture);
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  faceTexture[faceCount]=textureImage;
  faceCount++;
}","protected void addNewFace(boolean firstFace,PImage tex){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    faceTexture=PApplet.expand(faceTexture);
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  faceTexture[faceCount]=tex;
  faceCount++;
}",0.9721448467966574
109267,"protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  PTexture tex=null;
  boolean texturing=false;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    FACECOUNT++;
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    if (recordingModel) {
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      VertexGroup group=PShape3D.newVertexGroup(n0,n1,TRIANGLES,0,faceTexture[j]);
      recordedGroups.add(group);
    }
    if (vertexBuffer.capacity() / 3 < 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    texCoordBuffer.position(0);
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      TRIANGLECOUNT++;
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * a[U]) * uscale,(cy + sy * a[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * a[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * a[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * b[U]) * uscale,(cy + sy * b[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * b[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * b[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * c[U]) * uscale,(cy + sy * c[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * c[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * c[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      i++;
    }
    if (!recordingModel) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      if (texturing) {
        texCoordBuffer.put(texCoordArray);
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      texCoordBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      if (texturing) {
        gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer);
      }
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (texturing) {
      gl.glBindTexture(tex.getGLTarget(),0);
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report(""String_Node_Str"");
}","protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  PTexture tex=null;
  boolean texturing=false;
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=start; j < stop; j++) {
    int i=faceOffset[j];
    FACECOUNT++;
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    if (recordingModel) {
      int n0=recordedVertices.size();
      int n1=n0 + 3 * faceLength[j] - 1;
      VertexGroup group=PShape3D.newVertexGroup(n0,n1,TRIANGLES,0,faceTexture[j]);
      recordedGroups.add(group);
    }
    if (vertexBuffer.capacity() / 3 < 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    texCoordBuffer.position(0);
    int n=0;
    for (int k=0; k < faceLength[j]; k++) {
      TRIANGLECOUNT++;
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(a[X],a[Y],a[Z]));
        recordedColors.add(new float[]{a[R],a[G],a[B],a[A]});
        recordedNormals.add(new PVector(a[NX],a[NY],a[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * a[U]) * uscale,(cy + sy * a[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(a[X]);
        vertexArray[3 * n + 1]=toFixed32(a[Y]);
        vertexArray[3 * n + 2]=toFixed32(a[Z]);
        colorArray[4 * n + 0]=toFixed32(a[R]);
        colorArray[4 * n + 1]=toFixed32(a[G]);
        colorArray[4 * n + 2]=toFixed32(a[B]);
        colorArray[4 * n + 3]=toFixed32(a[A]);
        normalArray[3 * n + 0]=toFixed32(a[NX]);
        normalArray[3 * n + 1]=toFixed32(a[NY]);
        normalArray[3 * n + 2]=toFixed32(a[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * a[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * a[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(b[X],b[Y],b[Z]));
        recordedColors.add(new float[]{b[R],b[G],b[B],b[A]});
        recordedNormals.add(new PVector(b[NX],b[NY],b[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * b[U]) * uscale,(cy + sy * b[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(b[X]);
        vertexArray[3 * n + 1]=toFixed32(b[Y]);
        vertexArray[3 * n + 2]=toFixed32(b[Z]);
        colorArray[4 * n + 0]=toFixed32(b[R]);
        colorArray[4 * n + 1]=toFixed32(b[G]);
        colorArray[4 * n + 2]=toFixed32(b[B]);
        colorArray[4 * n + 3]=toFixed32(b[A]);
        normalArray[3 * n + 0]=toFixed32(b[NX]);
        normalArray[3 * n + 1]=toFixed32(b[NY]);
        normalArray[3 * n + 2]=toFixed32(b[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * b[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * b[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      if (recordingModel) {
        recordedVertices.add(new PVector(c[X],c[Y],c[Z]));
        recordedColors.add(new float[]{c[R],c[G],c[B],c[A]});
        recordedNormals.add(new PVector(c[NX],c[NY],c[NZ]));
        recordedTexCoords.add(new PVector((cx + sx * c[U]) * uscale,(cy + sy * c[V]) * vscale,0.0f));
      }
 else {
        vertexArray[3 * n + 0]=toFixed32(c[X]);
        vertexArray[3 * n + 1]=toFixed32(c[Y]);
        vertexArray[3 * n + 2]=toFixed32(c[Z]);
        colorArray[4 * n + 0]=toFixed32(c[R]);
        colorArray[4 * n + 1]=toFixed32(c[G]);
        colorArray[4 * n + 2]=toFixed32(c[B]);
        colorArray[4 * n + 3]=toFixed32(c[A]);
        normalArray[3 * n + 0]=toFixed32(c[NX]);
        normalArray[3 * n + 1]=toFixed32(c[NY]);
        normalArray[3 * n + 2]=toFixed32(c[NZ]);
        texCoordArray[2 * n + 0]=toFixed32((cx + sx * c[U]) * uscale);
        texCoordArray[2 * n + 1]=toFixed32((cy + sy * c[V]) * vscale);
        n++;
        VERTEXCOUNT++;
      }
      i++;
    }
    if (!recordingModel) {
      vertexBuffer.put(vertexArray);
      colorBuffer.put(colorArray);
      normalBuffer.put(normalArray);
      if (texturing) {
        texCoordBuffer.put(texCoordArray);
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      normalBuffer.position(0);
      texCoordBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
      if (texturing) {
        gl.glTexCoordPointer(2,GL10.GL_FIXED,0,texCoordBuffer);
      }
      gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    }
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  report(""String_Node_Str"");
}",0.9961250322913976
109268,"/** 
 * Add the triangle.
 */
protected void addTriangle(int a,int b,int c){
  if (triangleCount == triangles.length) {
    int temp[][]=new int[triangleCount << 1][TRIANGLE_FIELD_COUNT];
    System.arraycopy(triangles,0,temp,0,triangleCount);
    triangles=temp;
  }
  triangles[triangleCount][VERTEX1]=a;
  triangles[triangleCount][VERTEX2]=b;
  triangles[triangleCount][VERTEX3]=c;
  triangleCount++;
  boolean firstFace=triangleCount == 1;
  if (textureImage != textureImagePrev || firstFace) {
    addNewFace(firstFace);
  }
 else {
    faceLength[faceCount - 1]++;
  }
  textureImagePrev=textureImage;
}","/** 
 * Add the triangle.
 */
protected void addTriangle(int a,int b,int c){
  if (triangleCount == triangles.length) {
    int temp[][]=new int[triangleCount << 1][TRIANGLE_FIELD_COUNT];
    System.arraycopy(triangles,0,temp,0,triangleCount);
    triangles=temp;
  }
  triangles[triangleCount][VERTEX1]=a;
  triangles[triangleCount][VERTEX2]=b;
  triangles[triangleCount][VERTEX3]=c;
  PImage tex=verticesTexture[a];
  boolean firstFace=triangleCount == 0;
  if (tex != textureImagePrev || firstFace) {
    addNewFace(firstFace,tex);
  }
 else {
    faceLength[faceCount - 1]++;
  }
  triangleCount++;
  textureImagePrev=tex;
}",0.6612772837510105
109269,"public int addTexture(GL10 gl){
  int[] textures=new int[1];
  gl.glGenTextures(1,textures,0);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textures[0]);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MIN_FILTER,GL10.GL_NEAREST);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MAG_FILTER,GL10.GL_NEAREST);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_S,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_T,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexImage2D(GL10.GL_TEXTURE_2D,0,GL10.GL_RGBA,texWidth,texHeight,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,null);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,0);
  currentTexID=-1;
  if (texIDList == null) {
    texIDList=new int[1];
    texIDList[0]=textures[0];
  }
 else {
    int[] tmp=texIDList;
    texIDList=new int[texIDList.length + 1];
    PApplet.arrayCopy(tmp,texIDList,tmp.length);
    texIDList[tmp.length]=textures[0];
  }
  return textures[0];
}","public int addTexture(GL10 gl){
  int[] textures=new int[1];
  gl.glGenTextures(1,textures,0);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textures[0]);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MIN_FILTER,GL10.GL_NEAREST);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MAG_FILTER,GL10.GL_NEAREST);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_S,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_T,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexImage2D(GL10.GL_TEXTURE_2D,0,GL10.GL_RGBA,texWidth,texHeight,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,null);
  if (texIDList == null) {
    texIDList=new int[1];
    texIDList[0]=textures[0];
  }
 else {
    int[] tmp=texIDList;
    texIDList=new int[texIDList.length + 1];
    PApplet.arrayCopy(tmp,texIDList,tmp.length);
    texIDList[tmp.length]=textures[0];
  }
  currentTexID=textures[0];
  return currentTexID;
}",0.9323308270676692
109270,"protected void addToTexture(GL10 gl){
  int[] rgba=new int[width * height];
  int t=0;
  int p=0;
  if (PGraphicsAndroid3D.BIG_ENDIAN) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=(image.pixels[p++] << 24) | 0xFFFFFFFF;
      }
    }
  }
 else {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=(image.pixels[p++] << 24) | 0xFFFFFFFF;
      }
    }
  }
  if (offsetX + width > texWidth) {
    offsetX=0;
    offsetY+=lineHeight;
    lineHeight=0;
  }
  lineHeight=Math.max(lineHeight,height);
  if (offsetY + lineHeight > texHeight) {
    lastTexID=addTexture(gl);
    offsetX=0;
    offsetY=0;
    lineHeight=0;
  }
  if (lastTexID == -1) {
    lastTexID=texIDList[0];
  }
  if (currentTexID != lastTexID) {
    gl.glBindTexture(GL10.GL_TEXTURE_2D,lastTexID);
    currentTexID=lastTexID;
  }
  gl.glTexSubImage2D(GL10.GL_TEXTURE_2D,0,offsetX,offsetY,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(rgba));
  texture=new TextureInfo(currentTexID,offsetX,offsetY + height,width,-height);
  offsetX+=width;
}","protected void addToTexture(GL10 gl){
  int[] rgba=new int[width * height];
  int t=0;
  int p=0;
  if (PGraphicsAndroid3D.BIG_ENDIAN) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=0xFFFFFF00 | image.pixels[p++];
      }
    }
  }
 else {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=(image.pixels[p++] << 24) | 0x00FFFFFF;
      }
    }
  }
  if (offsetX + width > texWidth) {
    offsetX=0;
    offsetY+=lineHeight;
    lineHeight=0;
  }
  lineHeight=Math.max(lineHeight,height);
  if (offsetY + lineHeight > texHeight) {
    lastTexID=addTexture(gl);
    offsetX=0;
    offsetY=0;
    lineHeight=0;
  }
  if (lastTexID == -1) {
    lastTexID=texIDList[0];
  }
  if (currentTexID != lastTexID) {
    gl.glBindTexture(GL10.GL_TEXTURE_2D,lastTexID);
    currentTexID=lastTexID;
  }
  gl.glTexSubImage2D(GL10.GL_TEXTURE_2D,0,offsetX,offsetY,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(rgba));
  texture=new TextureInfo(currentTexID,offsetX,offsetY + height,width,-height);
  offsetX+=width;
}",0.864986498649865
109271,"public TextureInfo(int glid,int cropX,int cropY,int cropW,int cropH){
  this.glid=glid;
  crop=new int[4];
  crop[0]=cropX;
  crop[1]=cropY;
  crop[2]=cropW;
  crop[3]=cropH;
}","public TextureInfo(int glid,int cropX,int cropY,int cropW,int cropH){
  this.glid=glid;
  crop=new int[4];
  crop[0]=cropX;
  crop[1]=cropY;
  crop[2]=cropW;
  crop[3]=cropH;
  u0=(float)cropX / (float)texWidth;
  u1=u0 + (float)cropW / (float)texWidth;
  v0=(float)(cropY + cropH) / (float)texHeight;
  v1=(float)cropY / (float)texHeight;
}",0.6808510638297872
109272,"protected void allocate(){
  if (!matricesAllocated) {
    glprojection=new float[16];
    glmodelview=new float[16];
    glmodelviewInv=new float[16];
    pcamera=new float[16];
    pcameraInv=new float[16];
    projection=new PMatrix3D();
    modelview=new PMatrix3D();
    modelviewInv=new PMatrix3D();
    camera=new PMatrix3D();
    cameraInv=new PMatrix3D();
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    vertexArray=new int[DEFAULT_BUFFER_SIZE * 3];
    colorArray=new int[DEFAULT_BUFFER_SIZE * 4];
    texCoordArray=new int[DEFAULT_BUFFER_SIZE * 2];
    normalArray=new int[DEFAULT_BUFFER_SIZE * 3];
    vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    textVerticesBuffer=vbb.asIntBuffer();
    tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    textTexCoordsBuffer=tbb.asIntBuffer();
    textVerticesArray=new int[DEFAULT_BUFFER_SIZE * 3];
    textTexCoordsArray=new int[DEFAULT_BUFFER_SIZE * 2];
    buffersAllocated=true;
  }
}","protected void allocate(){
  if (!matricesAllocated) {
    glprojection=new float[16];
    glmodelview=new float[16];
    glmodelviewInv=new float[16];
    pcamera=new float[16];
    pcameraInv=new float[16];
    projection=new PMatrix3D();
    modelview=new PMatrix3D();
    modelviewInv=new PMatrix3D();
    camera=new PMatrix3D();
    cameraInv=new PMatrix3D();
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    vertexArray=new int[DEFAULT_BUFFER_SIZE * 3];
    colorArray=new int[DEFAULT_BUFFER_SIZE * 4];
    texCoordArray=new int[DEFAULT_BUFFER_SIZE * 2];
    normalArray=new int[DEFAULT_BUFFER_SIZE * 3];
    buffersAllocated=true;
  }
}",0.895843287147635
109273,"protected void textCharModelImpl(Glyph.TextureInfo tex,float x1,float y1,float x2,float y2){
  if (textFont.currentTexID != tex.glid) {
    gl.glBindTexture(GL10.GL_TEXTURE_2D,tex.glid);
    textFont.currentTexID=tex.glid;
  }
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  gl11x.glDrawTexfOES(x1,height - y2,0,x2 - x1,y2 - y1);
}","protected void textCharModelImpl(Glyph.TextureInfo tex,float x1,float y1,float x2,float y2){
  if (textFont.currentTexID != tex.glid) {
    if (0 < textVertexCount) {
      renderTextModel();
      textVertexCount=0;
    }
    gl.glBindTexture(GL10.GL_TEXTURE_2D,tex.glid);
    textFont.currentTexID=tex.glid;
  }
  if (textVertexBuffer.capacity() < textVertexCount + 6) {
    expandTextBuffers();
  }
  int n=textVertexCount;
  textVertexArray[3 * n + 0]=toFixed32(x1);
  textVertexArray[3 * n + 1]=toFixed32(y1);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u0);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v0);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x2);
  textVertexArray[3 * n + 1]=toFixed32(y2);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u1);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v1);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x1);
  textVertexArray[3 * n + 1]=toFixed32(y2);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u0);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v1);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x1);
  textVertexArray[3 * n + 1]=toFixed32(y1);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u0);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v0);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x2);
  textVertexArray[3 * n + 1]=toFixed32(y1);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u1);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v0);
  n++;
  textVertexArray[3 * n + 0]=toFixed32(x2);
  textVertexArray[3 * n + 1]=toFixed32(y2);
  textVertexArray[3 * n + 2]=toFixed32(0);
  textTexCoordArray[2 * n + 0]=toFixed32(tex.u1);
  textTexCoordArray[2 * n + 1]=toFixed32(tex.v1);
  n++;
  textVertexCount=n;
}",0.2087960906263882
109274,"/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (gl11 == null || gl11x == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  if (!blend || blendMode != BLEND) {
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  }
  if (textFont.texIDList == null) {
    textFont.initTexture(gl,maxTextureSize,maxTextureSize);
    textFont.addAllGlyphsToTexture(gl);
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  textFont.currentTexID=textFont.texIDList[0];
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFont.currentTexID);
  gl.glColor4f(colorFloats[0],colorFloats[1],colorFloats[2],colorFloats[3]);
  super.textLineImpl(buffer,start,stop,x,y);
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
  gl.glDisable(GL10.GL_TEXTURE_2D);
}","/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (gl11 == null || gl11x == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  if (!blend || blendMode != BLEND) {
    gl.glEnable(GL10.GL_BLEND);
    gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  }
  if (textFont.texIDList == null) {
    textFont.initTexture(gl,maxTextureSize,maxTextureSize);
    textFont.addAllGlyphsToTexture(gl);
  }
  gl.glEnable(GL10.GL_TEXTURE_2D);
  textFont.currentTexID=textFont.texIDList[0];
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFont.currentTexID);
  gl.glColor4f(colorFloats[0],colorFloats[1],colorFloats[2],colorFloats[3]);
  if (textMode == MODEL) {
    if (textVertexBuffer == null) {
      allocateTextModel();
    }
    gl.glNormal3f(0,0,1);
    textVertexCount=0;
  }
  super.textLineImpl(buffer,start,stop,x,y);
  if (textMode == MODEL && 0 < textVertexCount) {
    renderTextModel();
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
  gl.glDisable(GL10.GL_TEXTURE_2D);
}",0.8911368015414258
109275,"protected PImage getImpl(int x,int y,int w,int h){
  PImage newbie=new PImage(w,h);
  IntBuffer newbieBuffer=IntBuffer.allocate(w * h);
  gl.glReadPixels(x,y,w,h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,newbieBuffer);
  newbieBuffer.get(newbie.pixels);
  nativeToJavaARGB(newbie);
  return newbie;
}","protected PImage getImpl(int x,int y,int w,int h){
  PImage newbie=parent.createImage(w,h,ARGB);
  PTexture newbieTex=newbie.getTexture();
  IntBuffer newbieBuffer=IntBuffer.allocate(w * h);
  gl.glReadPixels(x,height - y,w,-h,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,newbieBuffer);
  copyToTexture(newbieTex,newbieBuffer,0,0,w,h);
  newbie.textureToPixels();
  return newbie;
}",0.6285714285714286
109276,"protected void allocate(){
  if (!matricesAllocated) {
    glprojection=new float[16];
    glmodelview=new float[16];
    glmodelviewInv=new float[16];
    pcamera=new float[16];
    pcameraInv=new float[16];
    projection=new PMatrix3D();
    modelview=new PMatrix3D();
    modelviewInv=new PMatrix3D();
    camera=new PMatrix3D();
    cameraInv=new PMatrix3D();
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    vertexArray=new int[DEFAULT_BUFFER_SIZE * 3];
    colorArray=new int[DEFAULT_BUFFER_SIZE * 4];
    texCoordArray=new int[DEFAULT_BUFFER_SIZE * 2];
    normalArray=new int[DEFAULT_BUFFER_SIZE * 3];
    getsetBuffer=IntBuffer.allocate(1);
    getsetBuffer.rewind();
    getsetTex=new PTexture(parent,1,1,new PTexture.Parameters(ARGB,NEAREST));
    buffersAllocated=true;
  }
}","protected void allocate(){
  if (!matricesAllocated) {
    glprojection=new float[16];
    glmodelview=new float[16];
    glmodelviewInv=new float[16];
    pcamera=new float[16];
    pcameraInv=new float[16];
    projection=new PMatrix3D();
    modelview=new PMatrix3D();
    modelviewInv=new PMatrix3D();
    camera=new PMatrix3D();
    cameraInv=new PMatrix3D();
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    vertexArray=new int[DEFAULT_BUFFER_SIZE * 3];
    colorArray=new int[DEFAULT_BUFFER_SIZE * 4];
    texCoordArray=new int[DEFAULT_BUFFER_SIZE * 2];
    normalArray=new int[DEFAULT_BUFFER_SIZE * 3];
    getsetBuffer=IntBuffer.allocate(1);
    getsetBuffer.rewind();
    buffersAllocated=true;
  }
}",0.9773527931555108
109277,"protected void drawTexture(PTexture tex,int[] crop,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,crop,0);
  gl11x.glDrawTexiOES(0,x,y,w,h);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_MODULATE);
  gl.glDisable(tex.getGLTarget());
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}","protected void drawTexture(PTexture tex,int[] crop,int x,int y,int w,int h){
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,crop,0);
  gl11x.glDrawTexiOES(x,y,0,w,h);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_MODULATE);
  gl.glDisable(tex.getGLTarget());
  if (hints[DISABLE_DEPTH_MASK]) {
    gl.glDepthMask(false);
  }
 else {
    gl.glDepthMask(true);
  }
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.9971870604781996
109278,"protected void defaultSettings(){
  super.defaultSettings();
  manipulatingCamera=false;
  scalingDuringCamManip=false;
  if (usingModelviewStack) {
    modelviewStack=new A3DMatrixStack();
  }
  textureMode(IMAGE);
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    try {
      Method meth=this.getClass().getMethod(""String_Node_Str"",new Class[]{PGraphicsAndroid3D.class});
      recreateResourceIdx=a3d.addRecreateResourceMethod(this,meth);
    }
 catch (    Exception e) {
      recreateResourceIdx=-1;
    }
  }
}","protected void defaultSettings(){
  super.defaultSettings();
  manipulatingCamera=false;
  scalingDuringCamManip=false;
  clearColorBuffer=false;
  if (fbStack == null) {
    fbStack=new Stack<PFramebuffer>();
    screenFramebuffer=new PFramebuffer(parent,width,height,true);
    setFramebuffer(screenFramebuffer);
  }
  if (usingModelviewStack && modelviewStack == null) {
    modelviewStack=new A3DMatrixStack();
  }
  textureMode(IMAGE);
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    try {
      Method meth=this.getClass().getMethod(""String_Node_Str"",new Class[]{PGraphicsAndroid3D.class});
      recreateResourceIdx=a3d.addRecreateResourceMethod(this,meth);
    }
 catch (    Exception e) {
      recreateResourceIdx=-1;
    }
  }
}",0.8306997742663657
109279,"protected void backgroundImpl(){
  gl.glClearColor(backgroundR,backgroundG,backgroundB,1);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
}","protected void backgroundImpl(){
  gl.glClearColor(backgroundR,backgroundG,backgroundB,1);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  if (0 < parent.frameCount) {
    clearColorBuffer=true;
  }
}",0.8368421052631579
109280,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  perspective();
  camera();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (fbStack == null) {
    fbStack=new Stack<PFramebuffer>();
    screenFramebuffer=new PFramebuffer(parent,width,height,true);
    setFramebuffer(screenFramebuffer);
  }
  if (clear && primarySurface) {
    gl.glClearColor(0,0,0,0);
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  }
 else {
    if (fboSupported) {
      if (drawFramebuffer == null) {
        createDrawFramebuffer();
      }
      pushFramebuffer();
      setFramebuffer(drawFramebuffer);
      drawFramebuffer.addColorBuffer(drawTextures[drawIndex]);
      gl.glClearColor(0,0,0,0);
      if (clear) {
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      }
 else {
        gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
        renderDrawTexture((drawIndex + 1) % 2);
      }
    }
 else {
      if (gl11 == null || gl11x == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (screenTexID[0] == 0) {
        createScreenTexture();
      }
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      drawScreenTexture();
    }
  }
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    if (a3d.lights) {
      noLights();
    }
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  perspective();
  camera();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (primarySurface) {
    if (parent.frameCount == 0) {
      if (fboSupported) {
        if (drawFramebuffer == null) {
          createDrawFramebuffer();
        }
      }
 else {
        if (gl11 == null || gl11x == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (screenTexID[0] == 0) {
          createScreenTexture();
        }
      }
    }
    if (clearColorBuffer) {
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      if (fboSupported) {
        if (drawFramebuffer != null) {
          pushFramebuffer();
          setFramebuffer(drawFramebuffer);
          drawFramebuffer.setColorBuffer(drawTextures[drawIndex]);
          gl.glClearColor(0,0,0,0);
          if (parent.frameCount == 0) {
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          }
 else {
            gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
            renderDrawTexture((drawIndex + 1) % 2);
          }
        }
      }
 else {
        if (screenTexID[0] != 0) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          if (0 < parent.frameCount) {
            drawScreenTexture();
          }
        }
      }
    }
  }
 else {
    if (!fboSupported) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (drawFramebuffer == null) {
      createDrawFramebuffer();
    }
    pushFramebuffer();
    setFramebuffer(drawFramebuffer);
    drawFramebuffer.setColorBuffer(drawTextures[drawIndex]);
    gl.glClearColor(0,0,0,0);
    if (clearColorBuffer || parent.frameCount == 0) {
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
 else {
      gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      renderDrawTexture((drawIndex + 1) % 2);
    }
  }
  clearColorBuffer0=clearColorBuffer;
  report(""String_Node_Str"");
}",0.61060988812703
109281,"public void endDraw(){
  if (!clear || !primarySurface) {
    if (fboSupported) {
      if (drawFramebuffer != null) {
        popFramebuffer();
        if (primarySurface) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          renderDrawTexture(drawIndex);
        }
        swapDrawIndex();
      }
    }
 else {
      if (screenTexID[0] != 0) {
        copyFrameToScreenTexture();
      }
    }
  }
  if (primarySurface) {
    gl.glFlush();
  }
 else {
    ((PGraphicsAndroid3D)parent.g).restoreGLState();
  }
  report(""String_Node_Str"");
}","public void endDraw(){
  if (primarySurface) {
    if (!clearColorBuffer0) {
      if (fboSupported) {
        if (drawFramebuffer != null) {
          popFramebuffer();
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          renderDrawTexture(drawIndex);
          swapDrawIndex();
        }
      }
 else {
        if (screenTexID[0] != 0) {
          copyFrameToScreenTexture();
        }
      }
    }
  }
 else {
    if (drawFramebuffer != null) {
      popFramebuffer();
      swapDrawIndex();
    }
  }
  if (primarySurface) {
    gl.glFlush();
  }
 else {
    ((PGraphicsAndroid3D)parent.g).restoreGLState();
  }
  report(""String_Node_Str"");
}",0.7701582516955539
109282,"/** 
 * Copy texture to pixels. Involves video memory to main memory transfer (slow).
 */
public void get(int[] pixels){
  if ((pixels == null) || (pixels.length != width * height)) {
    pixels=new int[width * height];
  }
  int size=glWidth * glHeight;
  int[] tmp=new int[size];
  IntBuffer pixelBuffer=BufferUtil.newIntBuffer(size);
  PFramebuffer fbo=new PFramebuffer(parent,glWidth,glHeight);
  fbo.addColorBuffer(this);
  a3d.pushFramebuffer();
  a3d.setFramebuffer(fbo);
  gl.glReadPixels(0,0,glWidth,glHeight,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,pixelBuffer);
  a3d.popFramebuffer();
  pixelBuffer.get(tmp);
  pixelBuffer.rewind();
  convertToARGB(tmp,pixels);
  if (flippedX)   flipArrayOnX(pixels,1);
  if (flippedY)   flipArrayOnY(pixels,1);
}","/** 
 * Copy texture to pixels. Involves video memory to main memory transfer (slow).
 */
public void get(int[] pixels){
  if ((pixels == null) || (pixels.length != width * height)) {
    pixels=new int[width * height];
  }
  int size=glWidth * glHeight;
  int[] tmp=new int[size];
  IntBuffer pixelBuffer=BufferUtil.newIntBuffer(size);
  PFramebuffer fbo=new PFramebuffer(parent,glWidth,glHeight);
  fbo.setColorBuffer(this);
  a3d.pushFramebuffer();
  a3d.setFramebuffer(fbo);
  gl.glReadPixels(0,0,glWidth,glHeight,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,pixelBuffer);
  a3d.popFramebuffer();
  pixelBuffer.get(tmp);
  pixelBuffer.rewind();
  convertToARGB(tmp,pixels);
  if (flippedX)   flipArrayOnX(pixels,1);
  if (flippedY)   flipArrayOnY(pixels,1);
}",0.99601593625498
109283,"synchronized public void noClear(){
  if (g instanceof PGraphicsAndroid3D) {
    ((PGraphicsAndroid3D)g).noClear();
  }
}","synchronized public void noClear(){
  if (g instanceof PGraphicsAndroid3D) {
    ((PGraphicsAndroid3D)g).noClear();
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.7934426229508197
109284,"synchronized public void clear(){
  if (g instanceof PGraphicsAndroid3D) {
    ((PGraphicsAndroid3D)g).clear();
  }
}","synchronized public void clear(){
  if (g instanceof PGraphicsAndroid3D) {
    ((PGraphicsAndroid3D)g).clear();
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.7878787878787878
109285,"protected void defaultSettings(){
  super.defaultSettings();
  manipulatingCamera=false;
  perspective();
  textureMode(IMAGE);
}","protected void defaultSettings(){
  super.defaultSettings();
  manipulatingCamera=false;
  textureMode(IMAGE);
}",0.9294605809128632
109286,"protected void drawScreenTexture(){
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,screenTexID[0]);
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,screenTexCrop,0);
  gl11x.glDrawTexiOES(0,0,0,width,height);
  gl.glDisable(GL10.GL_TEXTURE_2D);
  gl.glDepthMask(true);
  gl.glEnable(GL10.GL_BLEND);
}","protected void drawScreenTexture(){
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,screenTexID[0]);
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl11.glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,screenTexCrop,0);
  gl11x.glDrawTexiOES(0,0,0,width,height);
  gl.glDisable(GL10.GL_TEXTURE_2D);
  gl.glDepthMask(true);
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.8927738927738927
109287,"void createDrawFramebuffer(){
  drawTexCrop=new int[4];
  drawTexCrop[0]=0;
  drawTexCrop[1]=0;
  drawTexCrop[2]=width;
  drawTexCrop[3]=height;
  drawImages=new PImage[2];
  drawImages[0]=parent.createImage(width,height,ARGB,NEAREST);
  drawImages[1]=parent.createImage(width,height,ARGB,NEAREST);
  drawTextures=new PTexture[2];
  drawTextures[0]=drawImages[0].getTexture();
  drawTextures[1]=drawImages[1].getTexture();
  drawIndex=0;
  drawFramebuffer=new PFramebuffer(parent,drawTextures[0].getGLWidth(),drawTextures[0].getGLHeight(),false);
  drawFramebuffer.addDepthBuffer(DEPTH_BITS);
  if (0 < STENCIL_BITS) {
    drawFramebuffer.addStencilBuffer(STENCIL_BITS);
  }
}","void createDrawFramebuffer(){
  drawTexCrop=new int[4];
  drawTexCrop[0]=0;
  drawTexCrop[1]=0;
  drawTexCrop[2]=width;
  drawTexCrop[3]=height;
  drawImages=new PImage[2];
  drawImages[0]=parent.createImage(width,height,ARGB,NEAREST);
  drawImages[1]=parent.createImage(width,height,ARGB,NEAREST);
  drawTextures=new PTexture[2];
  drawTextures[0]=drawImages[0].getTexture();
  drawTextures[1]=drawImages[1].getTexture();
  drawTextures[0].setFlippedY(true);
  drawTextures[1].setFlippedY(true);
  drawIndex=0;
  drawFramebuffer=new PFramebuffer(parent,drawTextures[0].getGLWidth(),drawTextures[0].getGLHeight(),false);
  drawFramebuffer.addDepthBuffer(DEPTH_BITS);
  if (0 < STENCIL_BITS) {
    drawFramebuffer.addStencilBuffer(STENCIL_BITS);
  }
}",0.9481065918653576
109288,"public void renderDrawTexture(int idx){
  PTexture tex=drawTextures[idx];
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(tex.getGLTarget(),GL11Ext.GL_TEXTURE_CROP_RECT_OES,drawTexCrop,0);
  gl11x.glDrawTexiOES(0,0,0,width,height);
  gl.glDisable(tex.getGLTarget());
  gl.glDepthMask(true);
  gl.glEnable(GL10.GL_BLEND);
}","public void renderDrawTexture(int idx){
  PTexture tex=drawTextures[idx];
  gl.glEnable(tex.getGLTarget());
  gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
  gl.glDepthMask(false);
  gl.glDisable(GL10.GL_BLEND);
  gl.glTexEnvf(GL10.GL_TEXTURE_ENV,GL10.GL_TEXTURE_ENV_MODE,GL10.GL_REPLACE);
  gl11.glTexParameteriv(tex.getGLTarget(),GL11Ext.GL_TEXTURE_CROP_RECT_OES,drawTexCrop,0);
  gl11x.glDrawTexiOES(0,0,0,width,height);
  gl.glDisable(tex.getGLTarget());
  gl.glDepthMask(true);
  if (blend) {
    blend(blendMode);
  }
 else {
    noBlend();
  }
}",0.9155963302752294
109289,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    OPENGL_VENDOR=a3d.OPENGL_VENDOR;
    OPENGL_RENDERER=a3d.OPENGL_RENDERER;
    OPENGL_VERSION=a3d.OPENGL_VERSION;
    npotTexSupported=a3d.npotTexSupported;
    mipmapSupported=a3d.mipmapSupported;
    matrixGetSupported=a3d.matrixGetSupported;
    vboSupported=a3d.vboSupported;
    fboSupported=a3d.fboSupported;
    maxTextureSize=a3d.maxTextureSize;
    maxPointSize=a3d.maxPointSize;
  }
  if (!settingsInited)   defaultSettings();
  resetMatrix();
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (fbStack == null) {
    fbStack=new Stack<PFramebuffer>();
    screenFramebuffer=new PFramebuffer(parent,width,height,true);
    setFramebuffer(screenFramebuffer);
  }
  if (clear && primarySurface) {
    gl.glClearColor(0,0,0,0);
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  }
 else {
    if (fboSupported) {
      if (drawFramebuffer == null) {
        createDrawFramebuffer();
      }
      pushFramebuffer();
      setFramebuffer(drawFramebuffer);
      drawFramebuffer.addColorBuffer(drawTextures[drawIndex]);
      gl.glClearColor(0,0,0,0);
      if (clear) {
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      }
 else {
        gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      }
      renderDrawTexture((drawIndex + 1) % 2);
    }
 else {
      if (screenTexID[0] == 0) {
        createScreenTexture();
      }
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      drawScreenTexture();
    }
  }
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  VERTEXCOUNT=0;
  TRIANGLECOUNT=0;
  FACECOUNT=0;
  if (!primarySurface) {
    PGraphicsAndroid3D a3d=(PGraphicsAndroid3D)parent.g;
    a3d.saveGLState();
    for (int i=0; i < a3d.lightCount; i++) {
      a3d.glLightDisable(i);
    }
    gl=a3d.gl;
    gl11=a3d.gl11;
    gl11x=a3d.gl11x;
    gl11xp=a3d.gl11xp;
    OPENGL_VENDOR=a3d.OPENGL_VENDOR;
    OPENGL_RENDERER=a3d.OPENGL_RENDERER;
    OPENGL_VERSION=a3d.OPENGL_VERSION;
    npotTexSupported=a3d.npotTexSupported;
    mipmapSupported=a3d.mipmapSupported;
    matrixGetSupported=a3d.matrixGetSupported;
    vboSupported=a3d.vboSupported;
    fboSupported=a3d.fboSupported;
    maxTextureSize=a3d.maxTextureSize;
    maxPointSize=a3d.maxPointSize;
  }
  if (!settingsInited) {
    defaultSettings();
  }
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  blend(BLEND);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (fbStack == null) {
    fbStack=new Stack<PFramebuffer>();
    screenFramebuffer=new PFramebuffer(parent,width,height,true);
    setFramebuffer(screenFramebuffer);
  }
  if (clear && primarySurface) {
    gl.glClearColor(0,0,0,0);
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  }
 else {
    if (fboSupported) {
      if (drawFramebuffer == null) {
        createDrawFramebuffer();
      }
      pushFramebuffer();
      setFramebuffer(drawFramebuffer);
      drawFramebuffer.addColorBuffer(drawTextures[drawIndex]);
      gl.glClearColor(0,0,0,0);
      if (clear) {
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      }
 else {
        gl.glClear(GL10.GL_DEPTH_BUFFER_BIT);
      }
      renderDrawTexture((drawIndex + 1) % 2);
    }
 else {
      if (screenTexID[0] == 0) {
        createScreenTexture();
      }
      gl.glClearColor(0,0,0,0);
      gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
      drawScreenTexture();
    }
  }
  report(""String_Node_Str"");
}",0.9876119687440442
109290,"public void endDraw(){
  if (!clear || !primarySurface) {
    if (fboSupported) {
      if (drawFramebuffer != null) {
        popFramebuffer();
        if (primarySurface) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          renderDrawTexture(drawIndex);
        }
        swapDrawIndex();
      }
    }
 else {
      if (screenTexID[0] != 0) {
        copyFrameToScreenTexture();
      }
    }
  }
  gl.glFlush();
  if (!primarySurface) {
    ((PGraphicsAndroid3D)parent.g).restoreGLState();
  }
  report(""String_Node_Str"");
}","public void endDraw(){
  if (!clear || !primarySurface) {
    if (fboSupported) {
      if (drawFramebuffer != null) {
        popFramebuffer();
        if (primarySurface) {
          gl.glClearColor(0,0,0,0);
          gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
          renderDrawTexture(drawIndex);
        }
        swapDrawIndex();
      }
    }
 else {
      if (screenTexID[0] != 0) {
        copyFrameToScreenTexture();
      }
    }
  }
  if (primarySurface) {
    gl.glFlush();
  }
 else {
    ((PGraphicsAndroid3D)parent.g).restoreGLState();
  }
  report(""String_Node_Str"");
}",0.95616211745244
109291,"public void mult(float[] m){
}","public void mult(float n0,float n4,float n8,float n12,float n1,float n5,float n9,float n13,float n2,float n6,float n10,float n14,float n3,float n7,float n11,float n15){
  float r0=current[0] * n0 + current[4] * n1 + current[8] * n2 + current[12] * n3;
  float r4=current[0] * n4 + current[4] * n5 + current[8] * n6 + current[12] * n7;
  float r8=current[0] * n8 + current[4] * n9 + current[8] * n10 + current[12] * n11;
  float r12=current[0] * n12 + current[4] * n13 + current[8] * n14 + current[12] * n15;
  float r1=current[1] * n0 + current[5] * n1 + current[9] * n2 + current[13] * n3;
  float r5=current[1] * n4 + current[5] * n5 + current[9] * n6 + current[13] * n7;
  float r9=current[1] * n8 + current[5] * n8 + current[9] * n10 + current[13] * n11;
  float r13=current[1] * n12 + current[5] * n13 + current[9] * n14 + current[13] * n15;
  float r2=current[2] * n0 + current[6] * n1 + current[10] * n2 + current[14] * n3;
  float r6=current[2] * n4 + current[6] * n5 + current[10] * n6 + current[14] * n7;
  float r10=current[2] * n8 + current[6] * n9 + current[10] * n10 + current[14] * n11;
  float r14=current[2] * n12 + current[6] * n13 + current[10] * n14 + current[14] * n15;
  float r3=current[3] * n0 + current[7] * n1 + current[11] * n2 + current[15] * n3;
  float r7=current[3] * n4 + current[7] * n5 + current[11] * n6 + current[15] * n7;
  float r11=current[3] * n8 + current[7] * n9 + current[11] * n10 + current[15] * n11;
  float r15=current[3] * n12 + current[7] * n13 + current[11] * n14 + current[15] * n15;
  current[0]=r0;
  current[4]=r4;
  current[8]=r8;
  current[12]=r12;
  current[1]=r1;
  current[5]=r5;
  current[9]=r9;
  current[13]=r13;
  current[2]=r2;
  current[6]=r6;
  current[10]=r10;
  current[14]=r14;
  current[3]=r3;
  current[7]=r7;
  current[11]=r11;
  current[15]=r15;
}",0.0281081081081081
109292,"public A3DMatrixStack(){
}","public A3DMatrixStack(){
  matrixStack=new Stack<float[]>();
  current=new float[16];
  set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
}",0.3398692810457516
109293,"public void push(){
}","public void push(){
  float[] mat=new float[16];
  PApplet.arrayCopy(current,mat);
  matrixStack.push(mat);
}",0.3230769230769231
109294,"public void pop(){
}","public void pop(){
  try {
    float[] mat=matrixStack.pop();
    PApplet.arrayCopy(mat,current);
  }
 catch (  EmptyStackException e) {
    PGraphics.showWarning(""String_Node_Str"");
  }
}",0.1923076923076923
109295,"public void get(float[] m){
}","public void get(float[] mat){
  PApplet.arrayCopy(current,mat);
}",0.6170212765957447
109296,"public void set(float[] m){
}","public void set(float n0,float n4,float n8,float n12,float n1,float n5,float n9,float n13,float n2,float n6,float n10,float n14,float n3,float n7,float n11,float n15){
  current[0]=n0;
  current[4]=n4;
  current[8]=n8;
  current[12]=n12;
  current[1]=n1;
  current[5]=n5;
  current[9]=n9;
  current[13]=n13;
  current[2]=n2;
  current[6]=n6;
  current[10]=n10;
  current[14]=n14;
  current[3]=n3;
  current[7]=n7;
  current[11]=n11;
  current[15]=n15;
}",0.1037344398340249
109297,"public void rotate(float a,float rx,float ry,float rz){
}","public void rotate(float angle,float rx,float ry,float rz){
  float c=PApplet.cos(angle);
  float s=PApplet.sin(angle);
  float t=1.0f - c;
  mult((t * rx * rx) + c,(t * rx * ry) - (s * rz),(t * rx * rz) + (s * ry),0,(t * rx * ry) + (s * rz),(t * ry * ry) + c,(t * ry * rz) - (s * rx),0,(t * rx * rz) - (s * ry),(t * ry * rz) + (s * rx),(t * rz * rz) + c,0,0,0,0,1);
}",0.268235294117647
109298,"public void translate(float tx,float ty,float tz){
}","public void translate(float tx,float ty,float tz){
  current[12]+=tx * current[0] + ty * current[4] + tz * current[8];
  current[13]+=tx * current[1] + ty * current[5] + tz * current[9];
  current[14]+=tx * current[2] + ty * current[6] + tz * current[10];
  current[15]+=tx * current[3] + ty * current[7] + tz * current[11];
}",0.2751322751322751
109299,"public void scale(float sx,float sy,float sz){
}","public void scale(float sx,float sy,float sz){
  current[0]*=sx;
  current[4]*=sy;
  current[8]*=sz;
  current[1]*=sx;
  current[5]*=sy;
  current[9]*=sz;
  current[2]*=sx;
  current[6]*=sy;
  current[10]*=sz;
  current[3]*=sx;
  current[7]*=sy;
  current[11]*=sz;
}",0.3057324840764331
109300,"protected void addToTexture(GL10 gl){
  if (offsetX + width > texWidth) {
    offsetX=0;
    offsetY+=lineHeight;
    lineHeight=0;
  }
  lineHeight=Math.max(lineHeight,height);
  if (offsetY + lineHeight > texHeight) {
    addTexture(gl);
    offsetX=0;
    offsetY=0;
    lineHeight=0;
  }
  int[] rgba=new int[width * height];
  int t=0;
  int p=0;
  if (PGraphicsAndroid3D.BIG_ENDIAN) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=255 << 24 | 255 << 16 | 0 << 8 | 0;
      }
    }
  }
 else {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=255 << 24 | 0 << 16 | 0 << 8 | 0;
      }
    }
  }
  gl.glTexSubImage2D(GL10.GL_TEXTURE_2D,0,offsetX,offsetY,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(rgba));
  texture=new TextureInfo(currentID,offsetX,offsetY,width,height);
  offsetX+=width;
}","protected void addToTexture(GL10 gl){
  if (offsetX + width > texWidth) {
    offsetX=0;
    offsetY+=lineHeight;
    lineHeight=0;
  }
  lineHeight=Math.max(lineHeight,height);
  if (offsetY + lineHeight > texHeight) {
    addTexture(gl);
    offsetX=0;
    offsetY=0;
    lineHeight=0;
  }
  int[] rgba=new int[width * height];
  int t=0;
  int p=0;
  if (PGraphicsAndroid3D.BIG_ENDIAN) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=0xFFFFFF00 | image.pixels[p++];
      }
    }
  }
 else {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        rgba[t++]=(image.pixels[p++] << 24) | 0x00FFFFFF;
      }
    }
  }
  gl.glTexSubImage2D(GL10.GL_TEXTURE_2D,0,offsetX,offsetY,width,height,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(rgba));
  texture=new TextureInfo(currentID,offsetX,offsetY,width,height);
  offsetX+=width;
}",0.802646085997795
109301,"protected void textCharModelImpl(Glyph.TextureInfo tex,float x1,float y1,float x2,float y2,int u2,int v2){
  if (textFontTexID != textFont.currentID) {
    textFontTexID=textFont.currentID;
    gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  }
  ((GL11)gl).glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  ((GL11Ext)gl).glDrawTexiOES((int)x1,height - (int)y1,0,(int)(x2 - x1),(int)(y2 - y1));
}","protected void textCharModelImpl(Glyph.TextureInfo tex,float x1,float y1,float x2,float y2,int u2,int v2){
  if (textFontTexID != tex.glid) {
    textFontTexID=tex.glid;
    gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  }
  ((GL11)gl).glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  ((GL11Ext)gl).glDrawTexiOES((int)x1,height - (int)y1,0,(int)(x2 - x1),(int)(y2 - y1));
}",0.92
109302,"/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (textFont.mTextureID == -1) {
    textFont.initialize(gl,maxTextureSize,maxTextureSize);
    textFont.addToTexture(gl);
  }
  textFontTexID=textFont.currentID;
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glShadeModel(GL10.GL_FLAT);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glOrthof(0.0f,width,0.0f,height,0.0f,1.0f);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  super.textLineImpl(buffer,start,stop,x,y);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glPopMatrix();
}","/** 
 * Implementation of actual drawing for a line of text.
 */
protected void textLineImpl(char buffer[],int start,int stop,float x,float y){
  if (textFont.mTextureID == -1) {
    textFont.initialize(gl,maxTextureSize,maxTextureSize);
    textFont.addToTexture(gl);
  }
  textFontTexID=textFont.currentID;
  gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glOrthof(0.0f,width,0.0f,height,0.0f,1.0f);
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  super.textLineImpl(buffer,start,stop,x,y);
  gl.glMatrixMode(GL10.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GL10.GL_MODELVIEW);
  gl.glPopMatrix();
}",0.9791535060012634
109303,"protected void textCharScreenImpl(Glyph.TextureInfo tex,int xx,int yy,int w0,int h0){
  if (textFontTexID != textFont.currentID) {
    textFontTexID=textFont.currentID;
    gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  }
  ((GL11)gl).glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  ((GL11Ext)gl).glDrawTexiOES((int)xx,(int)yy,0,(int)w0,(int)h0);
}","protected void textCharScreenImpl(Glyph.TextureInfo tex,int xx,int yy,int w0,int h0){
  if (textFontTexID != tex.glid) {
    textFontTexID=tex.glid;
    gl.glBindTexture(GL10.GL_TEXTURE_2D,textFontTexID);
  }
  ((GL11)gl).glTexParameteriv(GL10.GL_TEXTURE_2D,GL11Ext.GL_TEXTURE_CROP_RECT_OES,tex.crop,0);
  ((GL11Ext)gl).glDrawTexiOES((int)xx,(int)yy,0,(int)w0,(int)h0);
}",0.9186351706036744
109304,"public void render(int gr0,int gr1){
  int texTarget=GL11.GL_TEXTURE_2D;
  GLTexture tex;
  float pointSize;
  gl.glLineWidth(a3d.strokeWeight);
  pointSize=PApplet.min(a3d.strokeWeight,a3d.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glNormalBufferID[0]);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  gl.glEnableClientState(GL11.GL_COLOR_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glColorBufferID[0]);
  gl.glColorPointer(4,GL11.GL_FLOAT,0,0);
  gl.glEnableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glVertexBufferID[0]);
  gl.glVertexPointer(3,GL11.GL_FLOAT,0,0);
  VertexGroup group;
  for (int i=gr0; i <= gr1; i++) {
    group=(VertexGroup)groups.get(i);
    tex=group.texture;
    if (tex != null) {
      texTarget=group.texture.getGLTarget();
      gl.glEnable(texTarget);
      gl.glActiveTexture(GL11.GL_TEXTURE0);
      gl.glBindTexture(GL11.GL_TEXTURE_2D,group.texture.getGLTextureID());
      if (pointSprites) {
        float quadratic[]={1.0f,0.0f,0.01f,1};
        ByteBuffer temp=ByteBuffer.allocateDirect(16);
        temp.order(ByteOrder.nativeOrder());
        gl.glPointParameterfv(GL11.GL_POINT_DISTANCE_ATTENUATION,(FloatBuffer)temp.asFloatBuffer().put(quadratic).flip());
        gl.glPointParameterf(GL11.GL_POINT_FADE_THRESHOLD_SIZE,0.6f * pointSize);
        gl.glPointParameterf(GL11.GL_POINT_SIZE_MIN,1.0f);
        gl.glPointParameterf(GL11.GL_POINT_SIZE_MAX,a3d.maxPointSize);
        gl.glTexEnvf(GL11.GL_POINT_SPRITE_OES,GL11.GL_COORD_REPLACE_OES,GL11.GL_TRUE);
        gl.glEnable(GL11.GL_POINT_SPRITE_OES);
      }
 else {
        gl.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
        gl.glClientActiveTexture(GL11.GL_TEXTURE0);
        gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glTexCoordBufferID[0]);
        gl.glTexCoordPointer(2,GL11.GL_FLOAT,0,0);
      }
    }
    gl.glPushMatrix();
    gl.glScalef(1,-1,1);
    gl.glDrawArrays(glMode,group.first,group.last - group.first + 1);
    gl.glPopMatrix();
    if (tex != null) {
      if (pointSprites) {
        gl.glDisable(GL11.GL_POINT_SPRITE_OES);
      }
 else {
        gl.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
      }
      gl.glDisable(texTarget);
    }
  }
  gl.glDisableClientState(GL11.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL11.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
}","public void render(int gr0,int gr1){
  int texTarget=GL11.GL_TEXTURE_2D;
  GLTexture tex;
  float pointSize;
  gl.glLineWidth(a3d.strokeWeight);
  pointSize=PApplet.min(a3d.strokeWeight,a3d.maxPointSize);
  gl.glPointSize(pointSize);
  gl.glEnableClientState(GL11.GL_NORMAL_ARRAY);
  gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,glNormalBufferID[0]);
  gl.glNormalPointer(GL11.GL_FLOAT,0,0);
  gl.glDisableClientState(GL11.GL_NORMAL_ARRAY);
  System.out.println(""String_Node_Str"");
}",0.297594501718213
109305,"protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=0; j < faceCount; j++) {
    int i=faceOffset[j];
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    if (vertexBuffer.capacity() == 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.rewind();
    colorBuffer.rewind();
    normalBuffer.rewind();
    textureBuffer.rewind();
    for (int k=0; k < faceLength[j]; k++) {
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      colorBuffer.put(toFixed32(a[R]));
      colorBuffer.put(toFixed32(a[G]));
      colorBuffer.put(toFixed32(a[B]));
      colorBuffer.put(toFixed32(a[A]));
      normalBuffer.put(toFixed32(a[NX]));
      normalBuffer.put(toFixed32(a[NY]));
      normalBuffer.put(toFixed32(a[NZ]));
      textureBuffer.put(toFixed32((cx + sx * a[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * a[V]) * vscale));
      vertexBuffer.put(toFixed32(b[X]));
      vertexBuffer.put(toFixed32(b[Y]));
      vertexBuffer.put(toFixed32(b[Z]));
      colorBuffer.put(toFixed32(b[R]));
      colorBuffer.put(toFixed32(b[G]));
      colorBuffer.put(toFixed32(b[B]));
      colorBuffer.put(toFixed32(b[A]));
      normalBuffer.put(toFixed32(b[NX]));
      normalBuffer.put(toFixed32(b[NY]));
      normalBuffer.put(toFixed32(b[NZ]));
      textureBuffer.put(toFixed32((cx + sx * b[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * b[V]) * vscale));
      vertexBuffer.put(toFixed32(c[X]));
      vertexBuffer.put(toFixed32(c[Y]));
      vertexBuffer.put(toFixed32(c[Z]));
      colorBuffer.put(toFixed32(c[R]));
      colorBuffer.put(toFixed32(c[G]));
      colorBuffer.put(toFixed32(c[B]));
      colorBuffer.put(toFixed32(c[A]));
      normalBuffer.put(toFixed32(c[NX]));
      normalBuffer.put(toFixed32(c[NY]));
      normalBuffer.put(toFixed32(c[NZ]));
      textureBuffer.put(toFixed32((cx + sx * c[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * c[V]) * vscale));
      i++;
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    textureBuffer.position(0);
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report(""String_Node_Str"");
}","protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=0; j < faceCount; j++) {
    int i=faceOffset[j];
    if (faceTexture[j] != null) {
      tex=faceTexture[j].getTexture();
      if (tex != null) {
        gl.glEnable(tex.getGLTarget());
        gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        texturing=true;
      }
 else {
        texturing=false;
      }
    }
 else {
      texturing=false;
    }
    System.out.println(""String_Node_Str"" + vertexBuffer.capacity() / 3 + ""String_Node_Str"" + 3 * faceLength[j]);
    if (vertexBuffer.capacity() / 3 < 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.rewind();
    colorBuffer.rewind();
    normalBuffer.rewind();
    textureBuffer.rewind();
    for (int k=0; k < faceLength[j]; k++) {
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      colorBuffer.put(toFixed32(a[R]));
      colorBuffer.put(toFixed32(a[G]));
      colorBuffer.put(toFixed32(a[B]));
      colorBuffer.put(toFixed32(a[A]));
      normalBuffer.put(toFixed32(a[NX]));
      normalBuffer.put(toFixed32(a[NY]));
      normalBuffer.put(toFixed32(a[NZ]));
      textureBuffer.put(toFixed32((cx + sx * a[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * a[V]) * vscale));
      vertexBuffer.put(toFixed32(b[X]));
      vertexBuffer.put(toFixed32(b[Y]));
      vertexBuffer.put(toFixed32(b[Z]));
      colorBuffer.put(toFixed32(b[R]));
      colorBuffer.put(toFixed32(b[G]));
      colorBuffer.put(toFixed32(b[B]));
      colorBuffer.put(toFixed32(b[A]));
      normalBuffer.put(toFixed32(b[NX]));
      normalBuffer.put(toFixed32(b[NY]));
      normalBuffer.put(toFixed32(b[NZ]));
      textureBuffer.put(toFixed32((cx + sx * b[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * b[V]) * vscale));
      vertexBuffer.put(toFixed32(c[X]));
      vertexBuffer.put(toFixed32(c[Y]));
      vertexBuffer.put(toFixed32(c[Z]));
      colorBuffer.put(toFixed32(c[R]));
      colorBuffer.put(toFixed32(c[G]));
      colorBuffer.put(toFixed32(c[B]));
      colorBuffer.put(toFixed32(c[A]));
      normalBuffer.put(toFixed32(c[NX]));
      normalBuffer.put(toFixed32(c[NY]));
      normalBuffer.put(toFixed32(c[NZ]));
      textureBuffer.put(toFixed32((cx + sx * c[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * c[V]) * vscale));
      i++;
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    textureBuffer.position(0);
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report(""String_Node_Str"");
}",0.984390243902439
109306,"protected void renderPoints(int start,int stop){
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  if (vertexBuffer.capacity() == stop - start) {
    expandBuffers();
  }
  vertexBuffer.rewind();
  colorBuffer.rewind();
  float sw=vertices[lines[start][VERTEX1]][SW];
  if (sw > 0) {
    gl.glPointSize(sw);
    for (int i=start; i < stop; i++) {
      float[] a=vertices[points[i][VERTEX1]];
      colorBuffer.put(toFixed16(a[SR]));
      colorBuffer.put(toFixed16(a[SG]));
      colorBuffer.put(toFixed16(a[SB]));
      colorBuffer.put(toFixed16(a[SA]));
      vertexBuffer.put(toFixed32(a[VX]));
      vertexBuffer.put(toFixed32(a[VY]));
      vertexBuffer.put(toFixed32(a[VZ]));
    }
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glDrawArrays(GL10.GL_POINTS,start,stop - start);
  }
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
}","protected void renderPoints(int start,int stop){
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  if (vertexBuffer.capacity() / 3 < 3 * (stop - start)) {
    expandBuffers();
  }
  vertexBuffer.rewind();
  colorBuffer.rewind();
  float sw=vertices[lines[start][VERTEX1]][SW];
  if (sw > 0) {
    gl.glPointSize(sw);
    for (int i=start; i < stop; i++) {
      float[] a=vertices[points[i][VERTEX1]];
      colorBuffer.put(toFixed16(a[SR]));
      colorBuffer.put(toFixed16(a[SG]));
      colorBuffer.put(toFixed16(a[SB]));
      colorBuffer.put(toFixed16(a[SA]));
      vertexBuffer.put(toFixed32(a[VX]));
      vertexBuffer.put(toFixed32(a[VY]));
      vertexBuffer.put(toFixed32(a[VZ]));
    }
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glDrawArrays(GL10.GL_POINTS,start,stop - start);
  }
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
}",0.992563212692117
109307,"/** 
 * In the current implementation, start and stop are ignored (in OpenGL). This will obviously have to be revisited if/when proper depth sorting is implemented.
 */
protected void renderLines(int start,int stop){
  report(""String_Node_Str"");
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=0; j < pathCount; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      if (vertexBuffer.capacity() == pathLength[j] + 1) {
        expandBuffers();
      }
      vertexBuffer.rewind();
      colorBuffer.rewind();
      float a[]=vertices[lines[i][VERTEX1]];
      colorBuffer.put(toFixed32(a[SR]));
      colorBuffer.put(toFixed32(a[SG]));
      colorBuffer.put(toFixed32(a[SB]));
      colorBuffer.put(toFixed32(a[SA]));
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        colorBuffer.put(toFixed32(b[SR]));
        colorBuffer.put(toFixed32(b[SG]));
        colorBuffer.put(toFixed32(b[SB]));
        colorBuffer.put(toFixed32(b[SA]));
        vertexBuffer.put(toFixed32(b[X]));
        vertexBuffer.put(toFixed32(b[Y]));
        vertexBuffer.put(toFixed32(b[Z]));
        i++;
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
    }
  }
  gl.glPopMatrix();
  report(""String_Node_Str"");
}","/** 
 * In the current implementation, start and stop are ignored (in OpenGL). This will obviously have to be revisited if/when proper depth sorting is implemented.
 */
protected void renderLines(int start,int stop){
  report(""String_Node_Str"");
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  for (int j=0; j < pathCount; j++) {
    int i=pathOffset[j];
    float sw=vertices[lines[i][VERTEX1]][SW];
    if (sw > 0) {
      gl.glLineWidth(sw);
      if (vertexBuffer.capacity() / 3 <= 3 * (pathLength[j] + 1)) {
        expandBuffers();
      }
      vertexBuffer.rewind();
      colorBuffer.rewind();
      float a[]=vertices[lines[i][VERTEX1]];
      colorBuffer.put(toFixed32(a[SR]));
      colorBuffer.put(toFixed32(a[SG]));
      colorBuffer.put(toFixed32(a[SB]));
      colorBuffer.put(toFixed32(a[SA]));
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      for (int k=0; k < pathLength[j]; k++) {
        float b[]=vertices[lines[i][VERTEX2]];
        colorBuffer.put(toFixed32(b[SR]));
        colorBuffer.put(toFixed32(b[SG]));
        colorBuffer.put(toFixed32(b[SB]));
        colorBuffer.put(toFixed32(b[SA]));
        vertexBuffer.put(toFixed32(b[X]));
        vertexBuffer.put(toFixed32(b[Y]));
        vertexBuffer.put(toFixed32(b[Z]));
        i++;
      }
      vertexBuffer.position(0);
      colorBuffer.position(0);
      gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
      gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
      gl.glDrawArrays(GL10.GL_LINE_STRIP,0,pathLength[j] + 1);
    }
  }
  gl.glPopMatrix();
  report(""String_Node_Str"");
}",0.9959723820483314
109308,"/** 
 * Preferred method of creating new PImage objects, ensures that a reference to the parent PApplet is included, which makes save() work without needing an absolute path.
 */
public PImage createImage(int wide,int high,int format){
  PImage image=new PImage(wide,high,format);
  image.parent=this;
  if (g instanceof PGraphicsAndroid3D) {
    image.format=ARGB;
    image.initTexture();
  }
  return image;
}","public PImage createImage(int wide,int high,GLTexture.Parameters params){
  PImage image=new PImage(wide,high,params.format);
  image.parent=this;
  if (g instanceof PGraphicsAndroid3D) {
    image.format=params.format;
    image.initTexture(params);
  }
  return image;
}",0.6403508771929824
109309,"protected void drawScreenTexture(){
  screenVertBuffer.position(0);
  screenTexCoordBuffer.position(0);
  gl.glColor4f(1.0f,1.0f,1.0f,1.0f);
  gl.glEnable(GL10.GL_TEXTURE_2D);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,screenTexID[0]);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
  gl.glVertexPointer(3,GL10.GL_FIXED,0,screenVertBuffer);
  gl.glTexCoordPointer(2,GL10.GL_FIXED,0,screenTexCoordBuffer);
  gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * 2);
  gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
}","protected void drawScreenTexture(){
  beginShape(QUADS);
  texture(screenTex);
  vertex(0,0,0,screenTex.height);
  vertex(width,0,screenTex.width,screenTex.height);
  vertex(width,height,screenTex.width,0);
  vertex(0,height,0,0);
  endShape();
}",0.1030444964871194
109310,"protected void allocate(){
  if (!matricesAllocated) {
    projection=new float[16];
    modelview=new float[16];
    modelviewInv=new float[16];
    camera=new float[16];
    cameraInv=new float[16];
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    buffersAllocated=true;
  }
  if (!screenTexAllocated) {
    screenNVertices=6;
    ByteBuffer vbb=ByteBuffer.allocateDirect(screenNVertices * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    screenVertBuffer=vbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(screenNVertices * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    screenTexCoordBuffer=tbb.asIntBuffer();
    screenTexAllocated=true;
  }
}","protected void allocate(){
  if (!matricesAllocated) {
    projection=new float[16];
    modelview=new float[16];
    modelviewInv=new float[16];
    camera=new float[16];
    cameraInv=new float[16];
    matricesAllocated=true;
  }
  if (!lightsAllocated) {
    lightType=new int[MAX_LIGHTS];
    lightPosition=new float[MAX_LIGHTS][4];
    lightNormal=new float[MAX_LIGHTS][4];
    lightDiffuse=new float[MAX_LIGHTS][4];
    lightSpecular=new float[MAX_LIGHTS][4];
    lightFalloffConstant=new float[MAX_LIGHTS];
    lightFalloffLinear=new float[MAX_LIGHTS];
    lightFalloffQuadratic=new float[MAX_LIGHTS];
    lightSpotAngle=new float[MAX_LIGHTS];
    lightSpotAngleCos=new float[MAX_LIGHTS];
    lightSpotConcentration=new float[MAX_LIGHTS];
    currentLightSpecular=new float[4];
    lightsAllocated=true;
  }
  if (!buffersAllocated) {
    ByteBuffer vbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    vbb.order(ByteOrder.nativeOrder());
    vertexBuffer=vbb.asIntBuffer();
    ByteBuffer cbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 4 * SIZEOF_INT);
    cbb.order(ByteOrder.nativeOrder());
    colorBuffer=cbb.asIntBuffer();
    ByteBuffer tbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 2 * SIZEOF_INT);
    tbb.order(ByteOrder.nativeOrder());
    texCoordBuffer=tbb.asIntBuffer();
    ByteBuffer nbb=ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE * 3 * SIZEOF_INT);
    nbb.order(ByteOrder.nativeOrder());
    normalBuffer=nbb.asIntBuffer();
    buffersAllocated=true;
  }
}",0.8811392037198489
109311,"/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  if (!settingsInited)   defaultSettings();
  resetMatrix();
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  gl.glEnable(GL10.GL_BLEND);
  gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (screenTexID[0] == 0) {
    createScreenTexture();
  }
  tint(255);
  beginShape(QUADS);
  texture(screenTex);
  vertex(0,0,0,screenTex.height);
  vertex(width,0,screenTex.width,screenTex.height);
  vertex(width,height,screenTex.width,0);
  vertex(0,height,0,0);
  endShape();
  report(""String_Node_Str"");
}","/** 
 * OpenGL cannot draw until a proper native peer is available, so this returns the value of PApplet.isDisplayable() (inherited from Component).
 */
public void beginDraw(){
  if (!settingsInited)   defaultSettings();
  resetMatrix();
  report(""String_Node_Str"");
  vertexBuffer.rewind();
  colorBuffer.rewind();
  texCoordBuffer.rewind();
  normalBuffer.rewind();
  textureImage=null;
  textureImagePrev=null;
  gl.glEnable(GL10.GL_BLEND);
  gl.glBlendFunc(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  if (hints[DISABLE_DEPTH_TEST]) {
    gl.glDisable(GL10.GL_DEPTH_TEST);
  }
 else {
    gl.glEnable(GL10.GL_DEPTH_TEST);
  }
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glFrontFace(GL10.GL_CW);
  gl.glViewport(0,0,width,height);
  camera();
  perspective();
  lightCount=0;
  lightFalloff(1,0,0);
  lightSpecular(0,0,0);
  gl.glEnable(GL10.GL_COLOR_MATERIAL);
  gl.glEnable(GL10.GL_NORMALIZE);
  gl.glEnable(GL10.GL_RESCALE_NORMAL);
  shapeFirst=0;
  if (clear) {
    gl.glClearColor(0,0,0,0);
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  }
 else {
    if (screenTex == null || screenTex.width != width || screenTex.height != height) {
      createScreenTexture();
    }
    drawScreenTexture();
  }
  report(""String_Node_Str"");
}",0.8295769078687228
109312,"public void endDraw(){
  copyFrameToScreenTexture();
  gl.glFlush();
  report(""String_Node_Str"");
}","public void endDraw(){
  if (!clear && screenTex != null) {
    copyFrameToScreenTexture();
  }
  gl.glFlush();
  report(""String_Node_Str"");
}",0.8215767634854771
109313,"public void setSize(int iwidth,int iheight){
  width=iwidth;
  height=iheight;
  width1=width - 1;
  height1=height - 1;
  allocate();
  reapplySettings();
  deleteScreenTexture();
  vertexCheck();
  cameraFOV=60 * DEG_TO_RAD;
  cameraX=width / 2.0f;
  cameraY=height / 2.0f;
  cameraZ=cameraY / ((float)Math.tan(cameraFOV / 2.0f));
  cameraNear=cameraZ / 10.0f;
  cameraFar=cameraZ * 10.0f;
  cameraAspect=(float)width / (float)height;
}","public void setSize(int iwidth,int iheight){
  width=iwidth;
  height=iheight;
  width1=width - 1;
  height1=height - 1;
  allocate();
  reapplySettings();
  vertexCheck();
  cameraFOV=60 * DEG_TO_RAD;
  cameraX=width / 2.0f;
  cameraY=height / 2.0f;
  cameraZ=cameraY / ((float)Math.tan(cameraFOV / 2.0f));
  cameraNear=cameraZ / 10.0f;
  cameraFar=cameraZ * 10.0f;
  cameraAspect=(float)width / (float)height;
}",0.9706227967097532
109314,"protected void createScreenTexture(){
  int[] pix=new int[width * height];
  for (int i=0; i < width * height; i++)   pix[i]=0xFF000000;
  gl.glGenTextures(1,screenTexID,0);
  gl.glBindTexture(GL10.GL_TEXTURE_2D,screenTexID[0]);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MIN_FILTER,GL10.GL_LINEAR);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MAG_FILTER,GL10.GL_LINEAR);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_S,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_T,GL10.GL_CLAMP_TO_EDGE);
  gl.glTexImage2D(GL10.GL_TEXTURE_2D,0,GL10.GL_RGBA,width,height,0,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(pix));
  gl.glBindTexture(GL10.GL_TEXTURE_2D,0);
  int fw=toFixed32(width);
  int fh=toFixed32(height);
  int one=toFixed32(1.0f);
  int[] quadCoords={0,fh,0,0,0,0,fw,0,0,0,fh,0,fw,0,0,fw,fh,0};
  int[] quadTexCoords={0,one,0,0,one,0,0,one,one,0,one,one};
  screenVertBuffer.position(0);
  screenTexCoordBuffer.position(0);
  screenVertBuffer.put(quadCoords);
  screenTexCoordBuffer.put(quadTexCoords);
  screenTex=parent.createImage(width,height,ARGB);
  screenTex.getTexture().set(pix);
}","protected void createScreenTexture(){
  int[] pix=new int[width * height];
  for (int i=0; i < width * height; i++)   pix[i]=0xFF0000;
  screenTex=parent.createImage(width,height,ARGB,GLConstants.NEAREST);
  screenTex.getTexture().set(pix);
}",0.3126760563380282
109315,"public void initTexture(){
  texture=new GLTexture(parent,width,height,new GLTexture.Parameters(format));
  updateTexture();
}","public void initTexture(GLTexture.Parameters params){
  texture=new GLTexture(parent,width,height,params);
  updateTexture();
}",0.782608695652174
109316,"public void skewX(float angle){
  apply(1,0,1,angle,0,0);
}","public void skewX(float angle){
  apply(1,0,1,tan(angle),0,0);
}",0.959349593495935
109317,"public void skewY(float angle){
  apply(1,0,1,0,angle,0);
}","public void skewY(float angle){
  apply(1,0,1,0,tan(angle),0);
}",0.959349593495935
109318,"protected boolean isWarped(){
  return ((m00 != 1) || (m01 != 0) && (m10 != 0) || (m11 != 1));
}","protected boolean isWarped(){
  return ((m00 != 1) || (m01 != 0) || (m10 != 0)|| (m11 != 1));
}",0.9738219895287958
109319,"public void requestDraw(){
  ((GLSurfaceView)parent.surfaceView).requestRender();
}","public void requestDraw(){
  if (parent.looping) {
    ((GLSurfaceView)parent.surfaceView).requestRender();
  }
}",0.8469387755102041
109320,"public AndroidSDK(final String sdkPath) throws BadSDKException, IOException {
  sdk=new File(sdkPath);
  if (!sdk.exists()) {
    throw new BadSDKException(sdk + ""String_Node_Str"");
  }
  tools=new File(sdk,""String_Node_Str"");
  if (!tools.exists()) {
    throw new BadSDKException(""String_Node_Str"" + sdk);
  }
  androidTool=findAndroidTool(tools);
  final Platform p=Base.getPlatform();
  p.setenv(""String_Node_Str"",sdk.getCanonicalPath());
  p.setenv(""String_Node_Str"",tools.getCanonicalPath() + File.pathSeparator + p.getenv(""String_Node_Str""));
}","public AndroidSDK(final String sdkPath) throws BadSDKException, IOException {
  sdk=new File(sdkPath);
  if (!sdk.exists()) {
    throw new BadSDKException(sdk + ""String_Node_Str"");
  }
  tools=new File(sdk,""String_Node_Str"");
  if (!tools.exists()) {
    throw new BadSDKException(""String_Node_Str"" + sdk);
  }
  androidTool=findAndroidTool(tools);
  final Platform p=Base.getPlatform();
  String path=p.getenv(""String_Node_Str"");
  p.setenv(""String_Node_Str"",sdk.getCanonicalPath());
  path=tools.getCanonicalPath() + File.pathSeparator + path;
  final String javaHomeProp=System.getProperty(""String_Node_Str"");
  if (javaHomeProp == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  final File javaHome=new File(javaHomeProp).getCanonicalFile();
  p.setenv(""String_Node_Str"",javaHome.getCanonicalPath());
  path=new File(javaHome,""String_Node_Str"").getCanonicalPath() + File.pathSeparator + path;
  p.setenv(""String_Node_Str"",path);
}",0.7105788423153693
109321,"public void set(int x,int y,PImage src){
  if (src.format == ALPHA) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (src.bitmap == null) {
    canvas.drawBitmap(src.pixels,0,src.width,x,y,src.width,src.height,false,null);
  }
 else {
    if (src.width != src.bitmap.getWidth() || src.height != src.bitmap.getHeight()) {
      src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      src.modified=true;
    }
    if (src.modified) {
      if (!src.bitmap.isMutable()) {
        src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      }
      src.bitmap.setPixels(src.pixels,0,src.width,0,0,src.width,src.height);
      src.modified=false;
    }
  }
  canvas.save(Canvas.MATRIX_SAVE_FLAG);
  canvas.setMatrix(null);
  canvas.drawBitmap(src.bitmap,x,y,null);
  canvas.restore();
}","public void set(int x,int y,PImage src){
  if (src.format == ALPHA) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (src.bitmap == null) {
    canvas.drawBitmap(src.pixels,0,src.width,x,y,src.width,src.height,false,null);
  }
 else {
    if (src.width != src.bitmap.getWidth() || src.height != src.bitmap.getHeight()) {
      src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      src.modified=true;
    }
    if (src.modified) {
      if (!src.bitmap.isMutable()) {
        src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      }
      src.bitmap.setPixels(src.pixels,0,src.width,0,0,src.width,src.height);
      src.modified=false;
    }
    canvas.save(Canvas.MATRIX_SAVE_FLAG);
    canvas.setMatrix(null);
    canvas.drawBitmap(src.bitmap,x,y,null);
    canvas.restore();
  }
}",0.992822966507177
109322,"/** 
 * Resize this image to a new width and height. Use 0 for wide or high to make that dimension scale proportionally.
 */
public void resize(int wide,int high){
  loadPixels();
  if (wide <= 0 && high <= 0) {
    width=0;
    height=0;
    pixels=new int[0];
  }
 else {
    if (wide == 0) {
      float diff=(float)high / (float)height;
      wide=(int)(width * diff);
    }
 else     if (high == 0) {
      float diff=(float)wide / (float)width;
      high=(int)(height * diff);
    }
    PImage temp=new PImage(wide,high,this.format);
    temp.copy(this,0,0,width,height,0,0,wide,high);
    this.width=wide;
    this.height=high;
    this.pixels=temp.pixels;
    this.bitmap=null;
  }
  updatePixels();
}","/** 
 * Resize this image to a new width and height. Use 0 for wide or high to make that dimension scale proportionally.
 */
public void resize(int wide,int high){
  loadPixels();
  if (wide <= 0 && high <= 0) {
    width=0;
    height=0;
    pixels=new int[0];
    bitmap=null;
  }
 else {
    if (wide == 0) {
      float diff=(float)high / (float)height;
      wide=(int)(width * diff);
    }
 else     if (high == 0) {
      float diff=(float)wide / (float)width;
      high=(int)(height * diff);
    }
    PImage temp=new PImage(wide,high,this.format);
    temp.copy(this,0,0,width,height,0,0,wide,high);
    this.width=wide;
    this.height=high;
    this.pixels=temp.pixels;
    this.bitmap=null;
  }
  updatePixels();
}",0.988169798190675
109323,"/** 
 * Link to an external page without all the muss. <P> When run with an applet, uses the browser to open the url, for applications, attempts to launch a browser with the url. <P> Works on Mac OS X and Windows. For Linux, use: <PRE>open(new String[] { ""firefox"", url });</PRE> or whatever you want as your browser, since Linux doesn't yet have a standard method for launching URLs.
 */
public void link(String url,String frameTitle){
}","/** 
 * Link to an external page without all the muss. <P> When run with an applet, uses the browser to open the url, for applications, attempts to launch a browser with the url. <P> Works on Mac OS X and Windows. For Linux, use: <PRE>open(new String[] { ""firefox"", url });</PRE> or whatever you want as your browser, since Linux doesn't yet have a standard method for launching URLs.
 */
public void link(String url,String frameTitle){
  Intent viewIntent=new Intent(""String_Node_Str"",Uri.parse(url));
  startActivity(viewIntent);
}",0.90216271884655
109324,"/** 
 * Handle renderer-specific image drawing.
 */
protected void imageImpl(PImage src,float x1,float y1,float x2,float y2,int u1,int v1,int u2,int v2){
  if (src.bitmap == null && src.format == ALPHA) {
    src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
    int[] px=new int[src.pixels.length];
    for (int i=0; i < px.length; i++) {
      px[i]=src.pixels[i] << 24 | 0xFFFFFF;
    }
    src.bitmap.setPixels(px,0,src.width,0,0,src.width,src.height);
    src.modified=false;
  }
  if (src.bitmap == null) {
    int offset=v1 * src.width + u1;
    canvas.drawBitmap(src.pixels,offset,src.width,x1,y1,u2 - u1,v2 - v1,src.format == ARGB,tint ? tintPaint : null);
  }
 else {
    if (src.width != src.bitmap.getWidth() || src.height != src.bitmap.getHeight()) {
      src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      src.modified=true;
    }
    if (src.modified) {
      if (!src.bitmap.isMutable()) {
        src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
      }
      src.bitmap.setPixels(src.pixels,0,src.width,0,0,src.width,src.height);
      src.modified=false;
    }
    if (imageImplSrcRect == null) {
      imageImplSrcRect=new Rect(u1,v1,u2,v2);
      imageImplDstRect=new RectF(x1,y1,x2,y2);
    }
 else {
      imageImplSrcRect.set(u1,v1,u2,v2);
      imageImplDstRect.set(x1,y1,x2,y2);
    }
    canvas.drawBitmap(src.bitmap,imageImplSrcRect,imageImplDstRect,tint ? tintPaint : null);
  }
}","/** 
 * Handle renderer-specific image drawing.
 */
protected void imageImpl(PImage src,float x1,float y1,float x2,float y2,int u1,int v1,int u2,int v2){
  if (src.bitmap == null && src.format == ALPHA) {
    src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
    int[] px=new int[src.pixels.length];
    for (int i=0; i < px.length; i++) {
      px[i]=src.pixels[i] << 24 | 0xFFFFFF;
    }
    src.bitmap.setPixels(px,0,src.width,0,0,src.width,src.height);
    src.modified=false;
  }
  if (src.bitmap == null || src.width != src.bitmap.getWidth() || src.height != src.bitmap.getHeight()) {
    src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
    src.modified=true;
  }
  if (src.modified) {
    if (!src.bitmap.isMutable()) {
      src.bitmap=Bitmap.createBitmap(src.width,src.height,Config.ARGB_8888);
    }
    src.bitmap.setPixels(src.pixels,0,src.width,0,0,src.width,src.height);
    src.modified=false;
  }
  if (imageImplSrcRect == null) {
    imageImplSrcRect=new Rect(u1,v1,u2,v2);
    imageImplDstRect=new RectF(x1,y1,x2,y2);
  }
 else {
    imageImplSrcRect.set(u1,v1,u2,v2);
    imageImplDstRect.set(x1,y1,x2,y2);
  }
  canvas.drawBitmap(src.bitmap,imageImplSrcRect,imageImplDstRect,tint ? tintPaint : null);
}",0.8757741347905282
109325,"public void pointLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=POINT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  lightCount++;
}","public void pointLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=POINT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9859665006790402
109326,"public void spotLight(float r,float g,float b,float x,float y,float z,float nx,float ny,float nz,float angle,float concentration){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=SPOT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=0.0f;
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightSpotAngle[lightCount]=angle;
  lightSpotAngleCos[lightCount]=Math.max(0,(float)Math.cos(angle));
  lightSpotConcentration[lightCount]=concentration;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightSpotAngle(lightCount);
  glLightSpotConcentration(lightCount);
  lightCount++;
}","public void spotLight(float r,float g,float b,float x,float y,float z,float nx,float ny,float nz,float angle,float concentration){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=SPOT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  lightSpotAngle[lightCount]=PApplet.degrees(angle);
  lightSpotAngleCos[lightCount]=Math.max(0,(float)Math.cos(angle));
  lightSpotConcentration[lightCount]=concentration;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightPosition(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightSpotAngle(lightCount);
  glLightSpotConcentration(lightCount);
  lightCount++;
}",0.8546744831842024
109327,"public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  lightCount++;
}","public void directionalLight(float r,float g,float b,float nx,float ny,float nz){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=DIRECTIONAL;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightSpecular[lightCount][0]=currentLightSpecular[0];
  lightSpecular[lightCount][1]=currentLightSpecular[1];
  lightSpecular[lightCount][2]=currentLightSpecular[2];
  lightSpecular[lightCount][2]=currentLightSpecular[3];
  float invn=1.0f / PApplet.dist(0,0,0,nx,ny,nz);
  lightNormal[lightCount][0]=invn * nx;
  lightNormal[lightCount][1]=invn * ny;
  lightNormal[lightCount][2]=invn * nz;
  lightNormal[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightNoAmbient(lightCount);
  glLightDirection(lightCount);
  glLightDiffuse(lightCount);
  glLightSpecular(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9883299798792756
109328,"/** 
 * Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
 */
public void ambientLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=AMBIENT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=0.0f;
  glLightEnable(lightCount);
  glLightAmbient(lightCount);
  glLightPosition(lightCount);
  glLightFalloff(lightCount);
  lightCount++;
}","/** 
 * Add an ambient light based on the current color mode. This version includes an (x, y, z) position for situations where the falloff distance is used.
 */
public void ambientLight(float r,float g,float b,float x,float y,float z){
  if (lightCount == MAX_LIGHTS) {
    throw new RuntimeException(""String_Node_Str"" + MAX_LIGHTS + ""String_Node_Str"");
  }
  colorCalc(r,g,b);
  lightDiffuse[lightCount][0]=calcR;
  lightDiffuse[lightCount][1]=calcG;
  lightDiffuse[lightCount][2]=calcB;
  lightDiffuse[lightCount][3]=1.0f;
  lightType[lightCount]=AMBIENT;
  lightFalloffConstant[lightCount]=currentLightFalloffConstant;
  lightFalloffLinear[lightCount]=currentLightFalloffLinear;
  lightFalloffQuadratic[lightCount]=currentLightFalloffQuadratic;
  lightPosition[lightCount][0]=x;
  lightPosition[lightCount][1]=y;
  lightPosition[lightCount][2]=z;
  lightPosition[lightCount][3]=1.0f;
  glLightEnable(lightCount);
  glLightAmbient(lightCount);
  glLightPosition(lightCount);
  glLightFalloff(lightCount);
  glLightNoSpot(lightCount);
  lightCount++;
}",0.9850746268656716
109329,"public PImage loadImage(String filename){
  InputStream stream=createInput(filename);
  if (stream == null) {
    System.err.println(""String_Node_Str"" + filename + ""String_Node_Str"");
    return null;
  }
  long t=System.currentTimeMillis();
  Bitmap bitmap=null;
  try {
    bitmap=BitmapFactory.decodeStream(stream);
  }
  finally {
    try {
      stream.close();
      stream=null;
    }
 catch (    IOException e) {
    }
  }
  int much=(int)(System.currentTimeMillis() - t);
  println(""String_Node_Str"" + filename + ""String_Node_Str""+ nfc(much));
  PImage image=new PImage(bitmap);
  image.parent=this;
  return image;
}","public PImage loadImage(String filename){
  InputStream stream=createInput(filename);
  if (stream == null) {
    System.err.println(""String_Node_Str"" + filename + ""String_Node_Str"");
    return null;
  }
  Bitmap bitmap=null;
  try {
    bitmap=BitmapFactory.decodeStream(stream);
  }
  finally {
    try {
      stream.close();
      stream=null;
    }
 catch (    IOException e) {
    }
  }
  PImage image=new PImage(bitmap);
  image.parent=this;
  return image;
}",0.7264409881061299
109330,"protected void textCharModelImpl(PImage glyph,float x1,float y1,float x2,float y2,int u2,int v2){
  boolean savedTint=tint;
  int savedTintColor=tintColor;
  float savedTintR=tintR;
  float savedTintG=tintG;
  float savedTintB=tintB;
  float savedTintA=tintA;
  boolean savedTintAlpha=tintAlpha;
  tint(fillColor);
  imageImpl(glyph,x1,y1,x2,y2,0,0,u2,v2);
  if (savedTint) {
    tint(tintColor);
  }
 else {
    noTint();
  }
}","protected void textCharModelImpl(PImage glyph,float x1,float y1,float x2,float y2,int u2,int v2){
  boolean savedTint=tint;
  int savedTintColor=tintColor;
  tint(fillColor);
  imageImpl(glyph,x1,y1,x2,y2,0,0,u2,v2);
  if (savedTint) {
    tint(savedTintColor);
  }
 else {
    noTint();
  }
}",0.7073509015256588
109331,"public void setTexCoord(ArrayList<PVector> data){
  if (updateElement != TEXTURES) {
    throw new RuntimeException(""String_Node_Str"");
  }
  firstUpdateIdx=0;
  lastUpdateIdx=numVertices - 1;
  PVector vec;
  for (int i=0; i < numVertices; i++) {
    vec=(PVector)data.get(i);
    if (a3d.imageMode == IMAGE) {
      if (vertGroup[i] != null && vertGroup[i].texture == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      updateTexCoordArray[2 * i + 0]=vec.x / vertGroup[i].texture.width;
      updateTexCoordArray[2 * i + 1]=vec.y / vertGroup[i].texture.height;
    }
 else {
      updateTexCoordArray[2 * i + 0]=vec.x;
      updateTexCoordArray[2 * i + 1]=vec.y;
    }
  }
}","public void setTexCoord(ArrayList<PVector> data){
  if (updateElement != TEXTURES) {
    throw new RuntimeException(""String_Node_Str"");
  }
  firstUpdateIdx=0;
  lastUpdateIdx=numVertices - 1;
  if (updateTexture != null) {
    for (int i=0; i < numVertices; i++)     if (vertGroup[i] != null) {
      vertGroup[i].texture=updateTexture;
    }
  }
  PVector vec;
  for (int i=0; i < numVertices; i++) {
    vec=(PVector)data.get(i);
    if (a3d.imageMode == IMAGE) {
      if (vertGroup[i] != null && vertGroup[i].texture == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      updateTexCoordArray[2 * i + 0]=vec.x / vertGroup[i].texture.width;
      updateTexCoordArray[2 * i + 1]=vec.y / vertGroup[i].texture.height;
    }
 else {
      updateTexCoordArray[2 * i + 0]=vec.x;
      updateTexCoordArray[2 * i + 1]=vec.y;
    }
  }
}",0.9004495825305073
109332,"public void setVertex(ArrayList<PVector> data){
  if (updateElement != VERTICES) {
    throw new RuntimeException(""String_Node_Str"");
  }
  firstUpdateIdx=0;
  lastUpdateIdx=numVertices - 1;
  PVector vec;
  for (int i=0; i < numVertices; i++) {
    vec=(PVector)data.get(i);
    updateVertexArray[3 * i + 0]=vec.x;
    updateVertexArray[3 * i + 1]=vec.y;
    updateVertexArray[3 * i + 2]=vec.z;
  }
}","public void setVertex(ArrayList<PVector> data){
  if (updateElement != VERTICES) {
    throw new RuntimeException(""String_Node_Str"");
  }
  firstUpdateIdx=0;
  lastUpdateIdx=numVertices - 1;
  if (creatingGroup) {
    grIdx0=0;
    grIdx1=numVertices - 1;
  }
  PVector vec;
  for (int i=0; i < numVertices; i++) {
    vec=(PVector)data.get(i);
    updateVertexArray[3 * i + 0]=vec.x;
    updateVertexArray[3 * i + 1]=vec.y;
    updateVertexArray[3 * i + 2]=vec.z;
  }
}",0.920780711825488
109333,"protected void addNewFace(){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    faceTexture=PApplet.expand(faceTexture);
  }
  faceOffset[faceCount]=triangleCount;
  faceLength[faceCount]=1;
  faceTexture[faceCount]=textureImage;
  faceCount++;
}","protected void addNewFace(boolean firstFace){
  if (faceCount == faceOffset.length) {
    faceOffset=PApplet.expand(faceOffset);
    faceLength=PApplet.expand(faceLength);
    faceTexture=PApplet.expand(faceTexture);
  }
  faceOffset[faceCount]=firstFace ? 0 : triangleCount;
  faceLength[faceCount]=1;
  faceTexture[faceCount]=textureImage;
  faceCount++;
}",0.9516837481698388
109334,"protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=0; j < faceCount; j++) {
    int i=faceOffset[j];
    if (faceTexture[j] != null) {
      try {
        tex=(GLTexture)faceTexture[j];
      }
 catch (      ClassCastException cce) {
        throw new RuntimeException(""String_Node_Str"");
      }
      gl.glEnable(tex.getGLTarget());
      gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      texturing=true;
    }
 else {
      texturing=false;
    }
    if (vertexBuffer.capacity() == 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.rewind();
    colorBuffer.rewind();
    normalBuffer.rewind();
    textureBuffer.rewind();
    for (int k=i; k < faceLength[j]; k++) {
      float a[]=vertices[triangles[k][VERTEX1]];
      float b[]=vertices[triangles[k][VERTEX2]];
      float c[]=vertices[triangles[k][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      colorBuffer.put(toFixed32(a[R]));
      colorBuffer.put(toFixed32(a[G]));
      colorBuffer.put(toFixed32(a[B]));
      colorBuffer.put(toFixed32(a[A]));
      normalBuffer.put(toFixed32(a[NX]));
      normalBuffer.put(toFixed32(a[NY]));
      normalBuffer.put(toFixed32(a[NZ]));
      textureBuffer.put(toFixed32((cx + sx * a[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * a[V]) * vscale));
      vertexBuffer.put(toFixed32(b[X]));
      vertexBuffer.put(toFixed32(b[Y]));
      vertexBuffer.put(toFixed32(b[Z]));
      colorBuffer.put(toFixed32(b[R]));
      colorBuffer.put(toFixed32(b[G]));
      colorBuffer.put(toFixed32(b[B]));
      colorBuffer.put(toFixed32(b[A]));
      normalBuffer.put(toFixed32(b[NX]));
      normalBuffer.put(toFixed32(b[NY]));
      normalBuffer.put(toFixed32(b[NZ]));
      textureBuffer.put(toFixed32((cx + sx * b[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * b[V]) * vscale));
      vertexBuffer.put(toFixed32(c[X]));
      vertexBuffer.put(toFixed32(c[Y]));
      vertexBuffer.put(toFixed32(c[Z]));
      colorBuffer.put(toFixed32(c[R]));
      colorBuffer.put(toFixed32(c[G]));
      colorBuffer.put(toFixed32(c[B]));
      colorBuffer.put(toFixed32(c[A]));
      normalBuffer.put(toFixed32(c[NX]));
      normalBuffer.put(toFixed32(c[NY]));
      normalBuffer.put(toFixed32(c[NZ]));
      textureBuffer.put(toFixed32((cx + sx * c[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * c[V]) * vscale));
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    textureBuffer.position(0);
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report(""String_Node_Str"");
}","protected void renderTriangles(int start,int stop){
  report(""String_Node_Str"");
  GLTexture tex=null;
  boolean texturing=false;
  vertexBuffer.position(0);
  colorBuffer.position(0);
  normalBuffer.position(0);
  textureBuffer.position(0);
  gl.glPushMatrix();
  gl.glScalef(1,-1,1);
  gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
  gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);
  for (int j=0; j < faceCount; j++) {
    int i=faceOffset[j];
    if (faceTexture[j] != null) {
      try {
        tex=(GLTexture)faceTexture[j];
      }
 catch (      ClassCastException cce) {
        throw new RuntimeException(""String_Node_Str"");
      }
      gl.glEnable(tex.getGLTarget());
      gl.glBindTexture(tex.getGLTarget(),tex.getGLTextureID());
      gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
      texturing=true;
    }
 else {
      texturing=false;
    }
    if (vertexBuffer.capacity() == 3 * faceLength[j]) {
      expandBuffers();
    }
    vertexBuffer.rewind();
    colorBuffer.rewind();
    normalBuffer.rewind();
    textureBuffer.rewind();
    for (int k=0; k < faceLength[j]; k++) {
      float a[]=vertices[triangles[i][VERTEX1]];
      float b[]=vertices[triangles[i][VERTEX2]];
      float c[]=vertices[triangles[i][VERTEX3]];
      float uscale=1.0f;
      float vscale=1.0f;
      float cx=0.0f;
      float sx=+1.0f;
      float cy=0.0f;
      float sy=+1.0f;
      if (texturing) {
        uscale*=tex.getMaxTextureCoordS();
        vscale*=tex.getMaxTextureCoordT();
        if (tex.isFlippedX()) {
          cx=1.0f;
          sx=-1.0f;
        }
        if (tex.isFlippedY()) {
          cy=1.0f;
          sy=-1.0f;
        }
      }
      vertexBuffer.put(toFixed32(a[X]));
      vertexBuffer.put(toFixed32(a[Y]));
      vertexBuffer.put(toFixed32(a[Z]));
      colorBuffer.put(toFixed32(a[R]));
      colorBuffer.put(toFixed32(a[G]));
      colorBuffer.put(toFixed32(a[B]));
      colorBuffer.put(toFixed32(a[A]));
      normalBuffer.put(toFixed32(a[NX]));
      normalBuffer.put(toFixed32(a[NY]));
      normalBuffer.put(toFixed32(a[NZ]));
      textureBuffer.put(toFixed32((cx + sx * a[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * a[V]) * vscale));
      vertexBuffer.put(toFixed32(b[X]));
      vertexBuffer.put(toFixed32(b[Y]));
      vertexBuffer.put(toFixed32(b[Z]));
      colorBuffer.put(toFixed32(b[R]));
      colorBuffer.put(toFixed32(b[G]));
      colorBuffer.put(toFixed32(b[B]));
      colorBuffer.put(toFixed32(b[A]));
      normalBuffer.put(toFixed32(b[NX]));
      normalBuffer.put(toFixed32(b[NY]));
      normalBuffer.put(toFixed32(b[NZ]));
      textureBuffer.put(toFixed32((cx + sx * b[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * b[V]) * vscale));
      vertexBuffer.put(toFixed32(c[X]));
      vertexBuffer.put(toFixed32(c[Y]));
      vertexBuffer.put(toFixed32(c[Z]));
      colorBuffer.put(toFixed32(c[R]));
      colorBuffer.put(toFixed32(c[G]));
      colorBuffer.put(toFixed32(c[B]));
      colorBuffer.put(toFixed32(c[A]));
      normalBuffer.put(toFixed32(c[NX]));
      normalBuffer.put(toFixed32(c[NY]));
      normalBuffer.put(toFixed32(c[NZ]));
      textureBuffer.put(toFixed32((cx + sx * c[U]) * uscale));
      textureBuffer.put(toFixed32((cy + sy * c[V]) * vscale));
      i++;
    }
    vertexBuffer.position(0);
    colorBuffer.position(0);
    normalBuffer.position(0);
    textureBuffer.position(0);
    gl.glVertexPointer(3,GL10.GL_FIXED,0,vertexBuffer);
    gl.glColorPointer(4,GL10.GL_FIXED,0,colorBuffer);
    gl.glNormalPointer(GL10.GL_FIXED,0,normalBuffer);
    if (texturing)     gl.glTexCoordPointer(2,GL10.GL_FIXED,0,textureBuffer);
    gl.glDrawArrays(GL10.GL_TRIANGLES,0,3 * faceLength[j]);
    if (texturing) {
      gl.glDisable(tex.getGLTarget());
      gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
    }
  }
  gl.glDisableClientState(GL10.GL_NORMAL_ARRAY);
  gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
  gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
  gl.glPopMatrix();
  report(""String_Node_Str"");
}",0.9976701410177804
109335,"/** 
 * Add the triangle.
 */
protected void addTriangle(int a,int b,int c){
  if (triangleCount == triangles.length) {
    int temp[][]=new int[triangleCount << 1][TRIANGLE_FIELD_COUNT];
    System.arraycopy(triangles,0,temp,0,triangleCount);
    triangles=temp;
  }
  triangles[triangleCount][VERTEX1]=a;
  triangles[triangleCount][VERTEX2]=b;
  triangles[triangleCount][VERTEX3]=c;
  triangleCount++;
  if (textureImage != textureImagePrev || triangleCount == 1) {
    addNewFace();
  }
 else {
    faceLength[faceCount - 1]++;
  }
  textureImagePrev=textureImage;
}","/** 
 * Add the triangle.
 */
protected void addTriangle(int a,int b,int c){
  if (triangleCount == triangles.length) {
    int temp[][]=new int[triangleCount << 1][TRIANGLE_FIELD_COUNT];
    System.arraycopy(triangles,0,temp,0,triangleCount);
    triangles=temp;
  }
  triangles[triangleCount][VERTEX1]=a;
  triangles[triangleCount][VERTEX2]=b;
  triangles[triangleCount][VERTEX3]=c;
  triangleCount++;
  boolean firstFace=triangleCount == 1;
  if (textureImage != textureImagePrev || firstFace) {
    addNewFace(firstFace);
  }
 else {
    faceLength[faceCount - 1]++;
  }
  textureImagePrev=textureImage;
}",0.935483870967742
109336,"/** 
 * Copy pixels to texture. Involves main memory to video memory transfer (slow).
 */
void update(){
  set(this.pixels);
}","/** 
 * Copy pixels to texture. Involves main memory to video memory transfer (slow).
 */
void update(){
  set(this.pixels,this.format);
}",0.9545454545454546
109337,"public void set(int[] pixels,int format){
  if (pixels.length != width * height) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (glTextureID[0] == 0) {
    createTexture(width,height);
  }
  int[] convArray=pixels;
  int glFormat;
  if (format == ALPHA) {
    glFormat=GL10.GL_ALPHA;
  }
 else   if (format == RGB) {
    glFormat=GL10.GL_RGB;
  }
 else {
    glFormat=GL10.GL_RGBA;
  }
  convArray=convertToRGBA(pixels,format);
  gl.glBindTexture(glTarget,glTextureID[0]);
  if (usingMipmaps) {
    if (a3d.gl11 != null && a3d.mipmapSupported) {
      gl.glTexParameterf(GL11.GL_TEXTURE_2D,GL11.GL_GENERATE_MIPMAP,GL11.GL_TRUE);
    }
 else {
    }
  }
  gl.glTexSubImage2D(glTarget,0,0,0,glWidth,glHeight,glFormat,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(convArray));
  gl.glBindTexture(glTarget,0);
}","public void set(int[] intArray,int arrayFormat){
  if (intArray.length != width * height) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (glTextureID[0] == 0) {
    createTexture(width,height);
  }
  int[] convArray=convertToRGBA(intArray,arrayFormat);
  gl.glBindTexture(glTarget,glTextureID[0]);
  if (usingMipmaps) {
    if (a3d.gl11 != null && a3d.mipmapSupported) {
      gl.glTexParameterf(GL11.GL_TEXTURE_2D,GL11.GL_GENERATE_MIPMAP,GL11.GL_TRUE);
    }
 else {
    }
  }
  gl.glTexSubImage2D(glTarget,0,0,0,glWidth,glHeight,GL10.GL_RGBA,GL10.GL_UNSIGNED_BYTE,IntBuffer.wrap(convArray));
  gl.glBindTexture(glTarget,0);
}",0.7725085910652921
109338,"/** 
 * Creates an instance of GLTexture using image file filename as source and the specified texture parameters.
 * @param parent PApplet
 * @param filename String
 * @param params Parameters
 */
public GLTexture(PApplet parent,String filename,Parameters params){
  super(1,1,params.format);
  this.parent=parent;
  a3d=(PGraphicsAndroid3D)parent.g;
  gl=a3d.gl;
  PImage img=parent.loadImage(filename);
  set(img);
}","/** 
 * Creates an instance of GLTexture using image file filename as source and the specified texture parameters.
 * @param parent PApplet
 * @param filename String
 * @param params Parameters
 */
public GLTexture(PApplet parent,String filename,Parameters params){
  super(1,1,params.format);
  this.parent=parent;
  a3d=(PGraphicsAndroid3D)parent.g;
  gl=a3d.gl;
  PImage img=parent.loadImage(filename);
  setParameters(params);
  set(img);
}",0.9710312862108922
109339,"/** 
 * Handle renderer-specific image drawing.
 */
protected void imageImpl(PImage who,float x1,float y1,float x2,float y2,int u1,int v1,int u2,int v2){
  rect.set(x1,y1,x2,y2);
  if (who.bitmap == null || who.width != who.bitmap.getWidth() || who.height != who.bitmap.getHeight()) {
    who.bitmap=Bitmap.createBitmap(width,height,Config.ARGB_8888);
    who.modified=true;
  }
  if (who.modified) {
    who.bitmap.setPixels(who.pixels,0,who.width,0,0,who.width,who.height);
  }
  if (imageImplSrcRect == null) {
    imageImplSrcRect=new Rect(u1,v1,u2 - u1,v2 - v1);
    imageImplDstRect=new Rect((int)x1,(int)y1,(int)(x2 - x1),(int)(y2 - y1));
  }
 else {
    imageImplSrcRect.set(u1,v1,u2 - u1,v2 - v1);
    imageImplDstRect.set((int)x1,(int)y1,(int)(x2 - x1),(int)(y2 - y1));
  }
  canvas.drawBitmap(who.bitmap,imageImplSrcRect,imageImplDstRect,tint ? tintPaint : null);
}","/** 
 * Handle renderer-specific image drawing.
 */
protected void imageImpl(PImage who,float x1,float y1,float x2,float y2,int u1,int v1,int u2,int v2){
  rect.set(x1,y1,x2,y2);
  if (who.bitmap == null || who.width != who.bitmap.getWidth() || who.height != who.bitmap.getHeight()) {
    who.bitmap=Bitmap.createBitmap(who.width,who.height,Config.ARGB_8888);
    who.modified=true;
  }
  if (who.modified) {
    who.bitmap.setPixels(who.pixels,0,who.width,0,0,who.width,who.height);
  }
  if (imageImplSrcRect == null) {
    imageImplSrcRect=new Rect(u1,v1,u2 - u1,v2 - v1);
    imageImplDstRect=new Rect((int)x1,(int)y1,(int)(x2 - x1),(int)(y2 - y1));
  }
 else {
    imageImplSrcRect.set(u1,v1,u2 - u1,v2 - v1);
    imageImplDstRect.set((int)x1,(int)y1,(int)(x2 - x1),(int)(y2 - y1));
  }
  canvas.drawBitmap(who.bitmap,imageImplSrcRect,imageImplDstRect,tint ? tintPaint : null);
}",0.9897727272727272
109340,"public void endUpdate(){
  if (updateElement == -1) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (lastUpdateIdx < firstUpdateIdx)   return;
  if (updateElement == VERTICES) {
    if (updateVertexArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 3;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 3;
    vertices.put(updateVertexArray,offset,size);
    vertices.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,vertices);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == COLORS) {
    if (updateColorArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 4;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 4;
    colors.put(updateColorArray,size,offset);
    colors.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,size * SIZEOF_FLOAT,offset * SIZEOF_FLOAT,colors);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == NORMALS) {
    if (updateNormalArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 3;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 3;
    normals.put(updateNormalArray,offset,size);
    normals.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,normals);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == TEXTURES) {
    if (updateTexCoordArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 2;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 2;
    texCoords.put(updateNormalArray,offset,size);
    texCoords.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,texCoords);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == GROUPS) {
    createGroups();
  }
  updateElement=-1;
}","public void endUpdate(){
  if (updateElement == -1) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (lastUpdateIdx < firstUpdateIdx)   return;
  if (updateElement == VERTICES) {
    if (updateVertexArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 3;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 3;
    vertices.put(updateVertexArray,offset,size);
    vertices.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,vertices);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == COLORS) {
    if (updateColorArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 4;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 4;
    colors.put(updateColorArray,size,offset);
    colors.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,size * SIZEOF_FLOAT,offset * SIZEOF_FLOAT,colors);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == NORMALS) {
    if (updateNormalArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 3;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 3;
    normals.put(updateNormalArray,offset,size);
    normals.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,normals);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == TEXTURES) {
    if (updateTexCoordArray == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int offset=firstUpdateIdx * 2;
    int size=(lastUpdateIdx - firstUpdateIdx + 1) * 2;
    texCoords.put(updateTexCoordArray,offset,size);
    texCoords.position(0);
    gl.glBufferSubData(GL11.GL_ARRAY_BUFFER,offset * SIZEOF_FLOAT,size * SIZEOF_FLOAT,texCoords);
    gl.glBindBuffer(GL11.GL_ARRAY_BUFFER,0);
  }
 else   if (updateElement == GROUPS) {
    createGroups();
  }
  updateElement=-1;
}",0.9965329370975732
109341,"protected void parsePath(){
  family=PATH;
  kind=0;
  String pathData=element.getStringAttribute(""String_Node_Str"");
  if (pathData == null)   return;
  char[] pathDataChars=pathData.toCharArray();
  StringBuffer pathBuffer=new StringBuffer();
  boolean lastSeparate=false;
  for (int i=0; i < pathDataChars.length; i++) {
    char c=pathDataChars[i];
    boolean separate=false;
    if (c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'Z' || c == 'z' || c == ',') {
      separate=true;
      if (i != 0) {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c == 'Z' || c == 'z') {
      separate=false;
    }
    if (c == '-' && !lastSeparate) {
      pathBuffer.append(""String_Node_Str"");
    }
    if (c != ',') {
      pathBuffer.append(c);
    }
    if (separate && c != ',' && c != '-') {
      pathBuffer.append(""String_Node_Str"");
    }
    lastSeparate=separate;
  }
  String[] pathDataKeys=PApplet.splitTokens(pathBuffer.toString(),""String_Node_Str"" + WHITESPACE);
  vertices=new float[pathDataKeys.length][2];
  vertexCodes=new int[pathDataKeys.length];
  float cx=0;
  float cy=0;
  int i=0;
  while (i < pathDataKeys.length) {
    char c=pathDataKeys[i].charAt(0);
switch (c) {
case 'M':
      cx=PApplet.parseFloat(pathDataKeys[i + 1]);
    cy=PApplet.parseFloat(pathDataKeys[i + 2]);
  parsePathMoveto(cx,cy);
i+=3;
break;
case 'm':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
cy=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathMoveto(cx,cy);
i+=3;
break;
case 'L':
cx=PApplet.parseFloat(pathDataKeys[i + 1]);
cy=PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'l':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
cy=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'H':
cx=PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'h':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'V':
cy=PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'v':
cy=cy + PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'C':
{
float ctrlX1=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY1=PApplet.parseFloat(pathDataKeys[i + 2]);
float ctrlX2=PApplet.parseFloat(pathDataKeys[i + 3]);
float ctrlY2=PApplet.parseFloat(pathDataKeys[i + 4]);
float endX=PApplet.parseFloat(pathDataKeys[i + 5]);
float endY=PApplet.parseFloat(pathDataKeys[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
}
break;
case 'c':
{
float ctrlX1=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY1=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float ctrlX2=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float ctrlY2=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 5]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
}
break;
case 'S':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX1=px + (px - ppx);
float ctrlY1=py + (py - ppy);
float ctrlX2=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY2=PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 's':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX1=px + (px - ppx);
float ctrlY1=py + (py - ppy);
float ctrlX2=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY2=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'Q':
{
float ctrlX=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY=PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'q':
{
float ctrlX=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'T':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX=px + (px - ppx);
float ctrlY=py + (py - ppy);
float endX=PApplet.parseFloat(pathDataKeys[i + 1]);
float endY=PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
}
break;
case 't':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX=px + (px - ppx);
float ctrlY=py + (py - ppy);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
}
break;
case 'Z':
case 'z':
close=true;
i++;
break;
default :
String parsed=PApplet.join(PApplet.subset(pathDataKeys,0,i),""String_Node_Str"");
String unparsed=PApplet.join(PApplet.subset(pathDataKeys,i),""String_Node_Str"");
System.err.println(""String_Node_Str"" + parsed);
System.err.println(""String_Node_Str"" + unparsed);
if (pathDataKeys[i].equals(""String_Node_Str"") || pathDataKeys[i].equals(""String_Node_Str"")) {
String msg=""String_Node_Str"" + ""String_Node_Str"";
throw new RuntimeException(msg);
}
throw new RuntimeException(""String_Node_Str"" + pathDataKeys[i]);
}
}
}","protected void parsePath(){
  family=PATH;
  kind=0;
  String pathData=element.getStringAttribute(""String_Node_Str"");
  if (pathData == null)   return;
  char[] pathDataChars=pathData.toCharArray();
  StringBuffer pathBuffer=new StringBuffer();
  boolean lastSeparate=false;
  for (int i=0; i < pathDataChars.length; i++) {
    char c=pathDataChars[i];
    boolean separate=false;
    if (c == 'M' || c == 'm' || c == 'L' || c == 'l' || c == 'H' || c == 'h' || c == 'V' || c == 'v' || c == 'C' || c == 'c' || c == 'S' || c == 's' || c == 'Q' || c == 'q' || c == 'T' || c == 't' || c == 'Z' || c == 'z' || c == ',') {
      separate=true;
      if (i != 0) {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c == 'Z' || c == 'z') {
      separate=false;
    }
    if (c == '-' && !lastSeparate) {
      if (i == 0 || pathDataChars[i - 1] != 'e') {
        pathBuffer.append(""String_Node_Str"");
      }
    }
    if (c != ',') {
      pathBuffer.append(c);
    }
    if (separate && c != ',' && c != '-') {
      pathBuffer.append(""String_Node_Str"");
    }
    lastSeparate=separate;
  }
  String[] pathDataKeys=PApplet.splitTokens(pathBuffer.toString(),""String_Node_Str"" + WHITESPACE);
  vertices=new float[pathDataKeys.length][2];
  vertexCodes=new int[pathDataKeys.length];
  float cx=0;
  float cy=0;
  int i=0;
  while (i < pathDataKeys.length) {
    char c=pathDataKeys[i].charAt(0);
switch (c) {
case 'M':
      cx=PApplet.parseFloat(pathDataKeys[i + 1]);
    cy=PApplet.parseFloat(pathDataKeys[i + 2]);
  parsePathMoveto(cx,cy);
i+=3;
break;
case 'm':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
cy=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathMoveto(cx,cy);
i+=3;
break;
case 'L':
cx=PApplet.parseFloat(pathDataKeys[i + 1]);
cy=PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'l':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
cy=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathLineto(cx,cy);
i+=3;
break;
case 'H':
cx=PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'h':
cx=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'V':
cy=PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'v':
cy=cy + PApplet.parseFloat(pathDataKeys[i + 1]);
parsePathLineto(cx,cy);
i+=2;
break;
case 'C':
{
float ctrlX1=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY1=PApplet.parseFloat(pathDataKeys[i + 2]);
float ctrlX2=PApplet.parseFloat(pathDataKeys[i + 3]);
float ctrlY2=PApplet.parseFloat(pathDataKeys[i + 4]);
float endX=PApplet.parseFloat(pathDataKeys[i + 5]);
float endY=PApplet.parseFloat(pathDataKeys[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
}
break;
case 'c':
{
float ctrlX1=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY1=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float ctrlX2=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float ctrlY2=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 5]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 6]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=7;
}
break;
case 'S':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX1=px + (px - ppx);
float ctrlY1=py + (py - ppy);
float ctrlX2=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY2=PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 's':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX1=px + (px - ppx);
float ctrlY1=py + (py - ppy);
float ctrlX2=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY2=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX1,ctrlY1,ctrlX2,ctrlY2,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'Q':
{
float ctrlX=PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY=PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'q':
{
float ctrlX=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float ctrlY=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 3]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 4]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=5;
}
break;
case 'T':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX=px + (px - ppx);
float ctrlY=py + (py - ppy);
float endX=PApplet.parseFloat(pathDataKeys[i + 1]);
float endY=PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
}
break;
case 't':
{
float ppx=vertices[vertexCount - 2][X];
float ppy=vertices[vertexCount - 2][Y];
float px=vertices[vertexCount - 1][X];
float py=vertices[vertexCount - 1][Y];
float ctrlX=px + (px - ppx);
float ctrlY=py + (py - ppy);
float endX=cx + PApplet.parseFloat(pathDataKeys[i + 1]);
float endY=cy + PApplet.parseFloat(pathDataKeys[i + 2]);
parsePathCurveto(ctrlX,ctrlY,ctrlX,ctrlY,endX,endY);
cx=endX;
cy=endY;
i+=3;
}
break;
case 'Z':
case 'z':
close=true;
i++;
break;
default :
String parsed=PApplet.join(PApplet.subset(pathDataKeys,0,i),""String_Node_Str"");
String unparsed=PApplet.join(PApplet.subset(pathDataKeys,i),""String_Node_Str"");
System.err.println(""String_Node_Str"" + parsed);
System.err.println(""String_Node_Str"" + unparsed);
if (pathDataKeys[i].equals(""String_Node_Str"") || pathDataKeys[i].equals(""String_Node_Str"")) {
String msg=""String_Node_Str"" + ""String_Node_Str"";
throw new RuntimeException(msg);
}
throw new RuntimeException(""String_Node_Str"" + pathDataKeys[i]);
}
}
}",0.995186617217707
109342,"private static void sortMembers(Node[][] map){
  for (  Node[] mapRow : map) {
    for (    Node node : mapRow) {
      Collections.sort(node.getAssignedIDs(),Collections.reverseOrder());
    }
  }
}","private static void sortMembers(Node[][] map){
  for (  Node[] mapRow : map) {
    for (    Node node : mapRow) {
      Collections.sort(node.getAssignedIDs(),new Comparator<Pair<Double,Long>>(){
        @Override public int compare(        Pair<Double,Long> a,        Pair<Double,Long> b){
          if (a.getFirst() > b.getFirst()) {
            return -1;
          }
          if (a.getFirst() < b.getFirst()) {
            return 1;
          }
          return 0;
        }
      }
);
    }
  }
}",0.4878744650499286
109343,"public static void main(String[] args) throws Exception {
  AUCEvaluator eval=new AUCEvaluator();
  EvaluationResult result=eval.evaluate(new File(args[0]));
  log.info(result.toString());
}","public static void main(String[] args) throws Exception {
  EvaluationResult result=new AUCEvaluator().evaluate(new File(args[0]));
  log.info(String.valueOf(result));
}",0.7799442896935933
109344,"@Override public final EvaluationResult evaluate(File originalDataDir,double trainingPercentage,double evaluationPercentage,RescorerProvider provider) throws TasteException, IOException, InterruptedException {
  Preconditions.checkArgument(trainingPercentage > 0.0 && trainingPercentage < 1.0,""String_Node_Str"",trainingPercentage);
  Preconditions.checkArgument(evaluationPercentage > 0.0 && evaluationPercentage <= 1.0,""String_Node_Str"",evaluationPercentage);
  Preconditions.checkArgument(originalDataDir.exists() && originalDataDir.isDirectory(),""String_Node_Str"",originalDataDir);
  File trainingDataDir=Files.createTempDir();
  trainingDataDir.deleteOnExit();
  File trainingFile=new File(trainingDataDir,""String_Node_Str"");
  trainingFile.deleteOnExit();
  File trainingModelFile=new File(originalDataDir,""String_Node_Str"");
  if (trainingModelFile.exists() && trainingModelFile.isFile()) {
    Files.copy(trainingModelFile,new File(trainingDataDir,trainingModelFile.getName()));
  }
  ServerRecommender recommender=null;
  try {
    Multimap<Long,RecommendedItem> testData=split(originalDataDir,trainingFile,trainingPercentage,evaluationPercentage,provider);
    recommender=new ServerRecommender(trainingDataDir);
    recommender.await();
    return evaluate(recommender,testData);
  }
  finally {
    recommender.close();
    IOUtils.deleteRecursively(trainingDataDir);
  }
}","@Override public final EvaluationResult evaluate(File originalDataDir,double trainingPercentage,double evaluationPercentage,RescorerProvider provider) throws TasteException, IOException, InterruptedException {
  Preconditions.checkArgument(trainingPercentage > 0.0 && trainingPercentage < 1.0,""String_Node_Str"",trainingPercentage);
  Preconditions.checkArgument(evaluationPercentage > 0.0 && evaluationPercentage <= 1.0,""String_Node_Str"",evaluationPercentage);
  Preconditions.checkArgument(originalDataDir.exists() && originalDataDir.isDirectory(),""String_Node_Str"",originalDataDir);
  File trainingDataDir=Files.createTempDir();
  trainingDataDir.deleteOnExit();
  File trainingFile=new File(trainingDataDir,""String_Node_Str"");
  trainingFile.deleteOnExit();
  File trainingModelFile=new File(originalDataDir,""String_Node_Str"");
  if (trainingModelFile.exists() && trainingModelFile.isFile()) {
    Files.copy(trainingModelFile,new File(trainingDataDir,trainingModelFile.getName()));
  }
  ServerRecommender recommender=null;
  try {
    Multimap<Long,RecommendedItem> testData=split(originalDataDir,trainingFile,trainingPercentage,evaluationPercentage,provider);
    recommender=new ServerRecommender(trainingDataDir);
    recommender.await();
    return evaluate(recommender,testData);
  }
  finally {
    if (recommender != null) {
      recommender.close();
    }
    IOUtils.deleteRecursively(trainingDataDir);
  }
}",0.9718560741004632
109345,"public static void main(String[] args) throws Exception {
  EstimatedStrengthEvaluator eval=new EstimatedStrengthEvaluator();
  EvaluationResult result=eval.evaluate(new File(args[0]));
  log.info(result.toString());
}","public static void main(String[] args) throws Exception {
  EvaluationResult result=new EstimatedStrengthEvaluator().evaluate(new File(args[0]));
  log.info(String.valueOf(result));
}",0.7780548628428927
109346,"@Override public Number call() throws IOException, TasteException, InterruptedException {
  PrecisionRecallEvaluator prEvaluator=new PrecisionRecallEvaluator();
  MyrrixIRStatistics stats=(MyrrixIRStatistics)prEvaluator.evaluate(dataDir,0.9,evaluationPercentage,null);
  return stats.getMeanAveragePrecision();
}","@Override public Number call() throws IOException, TasteException, InterruptedException {
  MyrrixIRStatistics stats=(MyrrixIRStatistics)new PrecisionRecallEvaluator().evaluate(dataDir,0.9,evaluationPercentage,null);
  return stats == null ? null : stats.getMeanAveragePrecision();
}",0.773109243697479
109347,"public static void main(String[] args) throws Exception {
  if (args.length < 4) {
    System.err.println(""String_Node_Str"");
    return;
  }
  final File dataDir=new File(args[0]);
  Preconditions.checkArgument(dataDir.exists() && dataDir.isDirectory(),""String_Node_Str"",dataDir);
  Preconditions.checkArgument(dataDir.listFiles().length > 0,""String_Node_Str"",dataDir);
  int numSteps=Integer.parseInt(args[1]);
  Preconditions.checkArgument(numSteps >= 2,""String_Node_Str"",numSteps);
  final double evaluationPercentage=Double.parseDouble(args[2]);
  Preconditions.checkArgument(evaluationPercentage > 0.0 && evaluationPercentage <= 1.0,""String_Node_Str"",evaluationPercentage);
  Map<String,ParameterRange> parameterRanges=Maps.newHashMapWithExpectedSize(args.length);
  for (int i=3; i < args.length; i++) {
    String[] propValue=EQUALS.split(args[i]);
    String systemProperty=propValue[0];
    String[] minMax=COLON.split(propValue[1]);
    ParameterRange range;
    try {
      int min=Integer.parseInt(minMax[0]);
      int max=Integer.parseInt(minMax.length == 1 ? minMax[0] : minMax[1]);
      range=new ParameterRange(min,max);
    }
 catch (    NumberFormatException ignored) {
      double min=Double.parseDouble(minMax[0]);
      double max=Double.parseDouble(minMax.length == 1 ? minMax[0] : minMax[1]);
      range=new ParameterRange(min,max);
    }
    parameterRanges.put(systemProperty,range);
  }
  Callable<Number> evaluator=new Callable<Number>(){
    @Override public Number call() throws IOException, TasteException, InterruptedException {
      PrecisionRecallEvaluator prEvaluator=new PrecisionRecallEvaluator();
      MyrrixIRStatistics stats=(MyrrixIRStatistics)prEvaluator.evaluate(dataDir,0.9,evaluationPercentage,null);
      return stats.getMeanAveragePrecision();
    }
  }
;
  ParameterOptimizer optimizer=new ParameterOptimizer(parameterRanges,numSteps,evaluator,false);
  Map<String,Number> optimalValues=optimizer.findGoodParameterValues();
  System.out.println(optimalValues);
}","public static void main(String[] args) throws Exception {
  if (args.length < 4) {
    System.err.println(""String_Node_Str"");
    return;
  }
  final File dataDir=new File(args[0]);
  Preconditions.checkArgument(dataDir.exists() && dataDir.isDirectory(),""String_Node_Str"",dataDir);
  Preconditions.checkArgument(dataDir.listFiles().length > 0,""String_Node_Str"",dataDir);
  int numSteps=Integer.parseInt(args[1]);
  Preconditions.checkArgument(numSteps >= 2,""String_Node_Str"",numSteps);
  final double evaluationPercentage=Double.parseDouble(args[2]);
  Preconditions.checkArgument(evaluationPercentage > 0.0 && evaluationPercentage <= 1.0,""String_Node_Str"",evaluationPercentage);
  Map<String,ParameterRange> parameterRanges=Maps.newHashMapWithExpectedSize(args.length);
  for (int i=3; i < args.length; i++) {
    String[] propValue=EQUALS.split(args[i]);
    String systemProperty=propValue[0];
    String[] minMax=COLON.split(propValue[1]);
    ParameterRange range;
    try {
      int min=Integer.parseInt(minMax[0]);
      int max=Integer.parseInt(minMax.length == 1 ? minMax[0] : minMax[1]);
      range=new ParameterRange(min,max);
    }
 catch (    NumberFormatException ignored) {
      double min=Double.parseDouble(minMax[0]);
      double max=Double.parseDouble(minMax.length == 1 ? minMax[0] : minMax[1]);
      range=new ParameterRange(min,max);
    }
    parameterRanges.put(systemProperty,range);
  }
  Callable<Number> evaluator=new Callable<Number>(){
    @Override public Number call() throws IOException, TasteException, InterruptedException {
      MyrrixIRStatistics stats=(MyrrixIRStatistics)new PrecisionRecallEvaluator().evaluate(dataDir,0.9,evaluationPercentage,null);
      return stats == null ? null : stats.getMeanAveragePrecision();
    }
  }
;
  ParameterOptimizer optimizer=new ParameterOptimizer(parameterRanges,numSteps,evaluator,false);
  Map<String,Number> optimalValues=optimizer.findGoodParameterValues();
  System.out.println(optimalValues);
}",0.9272681829542614
109348,"/** 
 * @return a {@link Map} between the values of the given {@link System} properties and the best value foundduring search
 * @throws ExecutionException if an error occurs while calling {@code evaluator}; the cause is the underlying exception
 */
public Map<String,Number> findGoodParameterValues() throws ExecutionException {
  int numProperties=parameterRanges.size();
  String[] propertyNames=new String[numProperties];
  Number[][] parameterValuesToTry=new Number[numProperties][];
  int index=0;
  for (  Map.Entry<String,ParameterRange> entry : parameterRanges.entrySet()) {
    propertyNames[index]=entry.getKey();
    parameterValuesToTry[index]=entry.getValue().buildSteps(numSteps);
    index++;
  }
  int numTests=1;
  for (  Number[] toTry : parameterValuesToTry) {
    numTests*=toTry.length;
  }
  List<Pair<Double,String>> testResultLinesByValue=Lists.newArrayListWithCapacity(numTests);
  Map<String,Number> bestParameterValues=Maps.newHashMap();
  double bestValue=minimize ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
  for (int test=0; test < numTests; test++) {
    StringBuilder testResultLine=new StringBuilder();
    for (int prop=0; prop < numProperties; prop++) {
      String property=propertyNames[prop];
      Number parameterValue=getParameterValueToTry(parameterValuesToTry,test,prop);
      String propertyString=parameterValue.toString();
      log.info(""String_Node_Str"",property,propertyString);
      System.setProperty(property,propertyString);
      testResultLine.append('[').append(property).append('=').append(propertyString).append(""String_Node_Str"");
    }
    double testValue;
    try {
      testValue=evaluator.call().doubleValue();
    }
 catch (    Exception e) {
      throw new ExecutionException(e);
    }
    testResultLine.append(""String_Node_Str"").append(testValue);
    testResultLinesByValue.add(new Pair<Double,String>(testValue,testResultLine.toString()));
    log.info(""String_Node_Str"",testResultLine);
    if (minimize ? testValue < bestValue : testValue > bestValue) {
      log.info(""String_Node_Str"",testValue);
      bestValue=testValue;
      for (int prop=0; prop < numProperties; prop++) {
        String property=propertyNames[prop];
        Number parameterValue=getParameterValueToTry(parameterValuesToTry,test,prop);
        bestParameterValues.put(property,parameterValue);
      }
    }
    Collections.sort(testResultLinesByValue,new Comparator<Pair<Double,String>>(){
      @Override public int compare(      Pair<Double,String> a,      Pair<Double,String> b){
        if (a.getFirst() > b.getFirst()) {
          return -1;
        }
        if (a.getFirst() < b.getFirst()) {
          return 1;
        }
        return 0;
      }
    }
);
    for (    Pair<Double,String> result : testResultLinesByValue) {
      log.info(""String_Node_Str"",result.getSecond());
    }
    log.info(""String_Node_Str"",bestParameterValues);
  }
  log.info(""String_Node_Str"",bestParameterValues);
  return bestParameterValues;
}","/** 
 * @return a {@link Map} between the values of the given {@link System} properties and the best value foundduring search
 * @throws ExecutionException if an error occurs while calling {@code evaluator}; the cause is the underlying exception
 */
public Map<String,Number> findGoodParameterValues() throws ExecutionException {
  int numProperties=parameterRanges.size();
  String[] propertyNames=new String[numProperties];
  Number[][] parameterValuesToTry=new Number[numProperties][];
  int index=0;
  for (  Map.Entry<String,ParameterRange> entry : parameterRanges.entrySet()) {
    propertyNames[index]=entry.getKey();
    parameterValuesToTry[index]=entry.getValue().buildSteps(numSteps);
    index++;
  }
  int numTests=1;
  for (  Number[] toTry : parameterValuesToTry) {
    numTests*=toTry.length;
  }
  List<Pair<Double,String>> testResultLinesByValue=Lists.newArrayListWithCapacity(numTests);
  Map<String,Number> bestParameterValues=Maps.newHashMap();
  double bestValue=minimize ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
  for (int test=0; test < numTests; test++) {
    StringBuilder testResultLine=new StringBuilder();
    for (int prop=0; prop < numProperties; prop++) {
      String property=propertyNames[prop];
      Number parameterValue=getParameterValueToTry(parameterValuesToTry,test,prop);
      String propertyString=parameterValue.toString();
      log.info(""String_Node_Str"",property,propertyString);
      System.setProperty(property,propertyString);
      testResultLine.append('[').append(property).append('=').append(propertyString).append(""String_Node_Str"");
    }
    Number evaluatorResult;
    try {
      evaluatorResult=evaluator.call();
    }
 catch (    Exception e) {
      throw new ExecutionException(e);
    }
    if (evaluatorResult == null) {
      continue;
    }
    double testValue=evaluatorResult.doubleValue();
    testResultLine.append(""String_Node_Str"").append(testValue);
    testResultLinesByValue.add(new Pair<Double,String>(testValue,testResultLine.toString()));
    log.info(""String_Node_Str"",testResultLine);
    if (minimize ? testValue < bestValue : testValue > bestValue) {
      log.info(""String_Node_Str"",testValue);
      bestValue=testValue;
      for (int prop=0; prop < numProperties; prop++) {
        String property=propertyNames[prop];
        Number parameterValue=getParameterValueToTry(parameterValuesToTry,test,prop);
        bestParameterValues.put(property,parameterValue);
      }
    }
    Collections.sort(testResultLinesByValue,new Comparator<Pair<Double,String>>(){
      @Override public int compare(      Pair<Double,String> a,      Pair<Double,String> b){
        if (a.getFirst() > b.getFirst()) {
          return -1;
        }
        if (a.getFirst() < b.getFirst()) {
          return 1;
        }
        return 0;
      }
    }
);
    for (    Pair<Double,String> result : testResultLinesByValue) {
      log.info(""String_Node_Str"",result.getSecond());
    }
    log.info(""String_Node_Str"",bestParameterValues);
  }
  log.info(""String_Node_Str"",bestParameterValues);
  return bestParameterValues;
}",0.9696969696969696
109349,"public static void main(String[] args) throws Exception {
  PrecisionRecallEvaluator eval=new PrecisionRecallEvaluator();
  EvaluationResult result=eval.evaluate(new File(args[0]));
  log.info(result.toString());
}","public static void main(String[] args) throws Exception {
  EvaluationResult result=new PrecisionRecallEvaluator().evaluate(new File(args[0]));
  log.info(String.valueOf(result));
}",0.779746835443038
109350,"@Override public EvaluationResult evaluate(final MyrrixRecommender recommender,final RescorerProvider provider,final Multimap<Long,RecommendedItem> testData) throws TasteException {
  final Mean precision=new Mean();
  final Mean recall=new Mean();
  final Mean ndcg=new Mean();
  final Mean meanAveragePrecision=new Mean();
  Processor<Long> processor=new Processor<Long>(){
    @Override public void process(    Long userID,    long count){
      Collection<RecommendedItem> values=testData.get(userID);
      int numValues=values.size();
      if (numValues == 0) {
        return;
      }
      IDRescorer rescorer=provider == null ? null : provider.getRecommendRescorer(new long[]{userID},recommender);
      List<RecommendedItem> recs;
      try {
        recs=recommender.recommend(userID,numValues,rescorer);
      }
 catch (      NoSuchUserException nsue) {
        log.warn(""String_Node_Str"",userID);
        return;
      }
catch (      TasteException te) {
        log.warn(""String_Node_Str"",te);
        return;
      }
      int numRecs=recs.size();
      Collection<Long> valueIDs=Sets.newHashSet();
      for (      RecommendedItem rec : values) {
        valueIDs.add(rec.getItemID());
      }
      int intersectionSize=0;
      double score=0.0;
      double maxScore=0.0;
      Mean precisionAtI=new Mean();
      double averagePrecision=0.0;
      for (int i=0; i < numRecs; i++) {
        RecommendedItem rec=recs.get(i);
        double value=LN2 / Math.log(2.0 + i);
        if (valueIDs.contains(rec.getItemID())) {
          intersectionSize++;
          score+=value;
          precisionAtI.increment(1.0);
          averagePrecision+=precisionAtI.getResult();
        }
 else {
          precisionAtI.increment(0.0);
        }
        maxScore+=value;
      }
      averagePrecision/=numValues;
synchronized (precision) {
        precision.increment(numRecs == 0 ? 0.0 : (double)intersectionSize / numRecs);
        recall.increment((double)intersectionSize / numValues);
        ndcg.increment(maxScore == 0.0 ? 0.0 : score / maxScore);
        meanAveragePrecision.increment(averagePrecision);
        if (count % 10000 == 0) {
          log.info(new IRStatisticsImpl(precision.getResult(),recall.getResult(),ndcg.getResult(),meanAveragePrecision.getResult()).toString());
        }
      }
    }
  }
;
  Paralleler<Long> paralleler=new Paralleler<Long>(testData.keySet().iterator(),processor,""String_Node_Str"");
  try {
    if (Boolean.parseBoolean(System.getProperty(""String_Node_Str"",""String_Node_Str""))) {
      paralleler.runInParallel();
    }
 else {
      paralleler.runInSerial();
    }
  }
 catch (  InterruptedException ie) {
    throw new TasteException(ie);
  }
catch (  ExecutionException e) {
    throw new TasteException(e.getCause());
  }
  EvaluationResult result=new IRStatisticsImpl(precision.getResult(),recall.getResult(),ndcg.getResult(),meanAveragePrecision.getResult());
  log.info(result.toString());
  return result;
}","@Override public EvaluationResult evaluate(final MyrrixRecommender recommender,final RescorerProvider provider,final Multimap<Long,RecommendedItem> testData) throws TasteException {
  final Mean precision=new Mean();
  final Mean recall=new Mean();
  final Mean ndcg=new Mean();
  final Mean meanAveragePrecision=new Mean();
  Processor<Long> processor=new Processor<Long>(){
    @Override public void process(    Long userID,    long count){
      Collection<RecommendedItem> values=testData.get(userID);
      int numValues=values.size();
      if (numValues == 0) {
        return;
      }
      IDRescorer rescorer=provider == null ? null : provider.getRecommendRescorer(new long[]{userID},recommender);
      List<RecommendedItem> recs;
      try {
        recs=recommender.recommend(userID,numValues,rescorer);
      }
 catch (      NoSuchUserException nsue) {
        log.warn(""String_Node_Str"",userID);
        return;
      }
catch (      TasteException te) {
        log.warn(""String_Node_Str"",te);
        return;
      }
      int numRecs=recs.size();
      Collection<Long> valueIDs=Sets.newHashSet();
      for (      RecommendedItem rec : values) {
        valueIDs.add(rec.getItemID());
      }
      int intersectionSize=0;
      double score=0.0;
      double maxScore=0.0;
      Mean precisionAtI=new Mean();
      double averagePrecision=0.0;
      for (int i=0; i < numRecs; i++) {
        RecommendedItem rec=recs.get(i);
        double value=LN2 / Math.log(2.0 + i);
        if (valueIDs.contains(rec.getItemID())) {
          intersectionSize++;
          score+=value;
          precisionAtI.increment(1.0);
          averagePrecision+=precisionAtI.getResult();
        }
 else {
          precisionAtI.increment(0.0);
        }
        maxScore+=value;
      }
      averagePrecision/=numValues;
synchronized (precision) {
        precision.increment(numRecs == 0 ? 0.0 : (double)intersectionSize / numRecs);
        recall.increment((double)intersectionSize / numValues);
        ndcg.increment(maxScore == 0.0 ? 0.0 : score / maxScore);
        meanAveragePrecision.increment(averagePrecision);
        if (count % 10000 == 0) {
          log.info(new IRStatisticsImpl(precision.getResult(),recall.getResult(),ndcg.getResult(),meanAveragePrecision.getResult()).toString());
        }
      }
    }
  }
;
  Paralleler<Long> paralleler=new Paralleler<Long>(testData.keySet().iterator(),processor,""String_Node_Str"");
  try {
    if (Boolean.parseBoolean(System.getProperty(""String_Node_Str"",""String_Node_Str""))) {
      paralleler.runInParallel();
    }
 else {
      paralleler.runInSerial();
    }
  }
 catch (  InterruptedException ie) {
    throw new TasteException(ie);
  }
catch (  ExecutionException e) {
    throw new TasteException(e.getCause());
  }
  EvaluationResult result;
  if (precision.getN() > 0) {
    result=new IRStatisticsImpl(precision.getResult(),recall.getResult(),ndcg.getResult(),meanAveragePrecision.getResult());
  }
 else {
    result=null;
  }
  log.info(String.valueOf(result));
  return result;
}",0.9834107498341076
109351,"public static void main(String[] args) throws Exception {
  ReconstructionEvaluator eval=new ReconstructionEvaluator();
  EvaluationResult result=eval.evaluate(new File(args[0]));
  log.info(result.toString());
}","public static void main(String[] args) throws Exception {
  EvaluationResult result=new ReconstructionEvaluator().evaluate(new File(args[0]));
  log.info(String.valueOf(result));
}",0.7806122448979592
109352,"@Test public void testEval() throws Exception {
  AUCEvaluator evaluator=new AUCEvaluator();
  EvaluationResult stats=evaluator.evaluate(new File(""String_Node_Str""));
  log.info(stats.toString());
  assertTrue(stats.getScore() > 0.955);
}","@Test public void testEval() throws Exception {
  EvaluationResult stats=new AUCEvaluator().evaluate(new File(""String_Node_Str""));
  log.info(String.valueOf(stats));
  assertTrue(stats.getScore() > 0.955);
}",0.7101123595505618
109353,"@Test public void testEval() throws Exception {
  EstimatedStrengthEvaluator evaluator=new EstimatedStrengthEvaluator();
  EvaluationResult stats=evaluator.evaluate(new File(""String_Node_Str""));
  log.info(stats.toString());
  assertTrue(stats.getScore() < 0.77);
}","@Test public void testEval() throws Exception {
  EvaluationResult stats=new EstimatedStrengthEvaluator().evaluate(new File(""String_Node_Str""));
  log.info(String.valueOf(stats));
  assertTrue(stats.getScore() < 0.77);
}",0.7051546391752578
109354,"@Override public Number call() throws IOException, TasteException, InterruptedException {
  PrecisionRecallEvaluator prEvaluator=new PrecisionRecallEvaluator();
  MyrrixIRStatistics stats=(MyrrixIRStatistics)prEvaluator.evaluate(new File(""String_Node_Str""),0.9,0.5,null);
  return stats.getMeanAveragePrecision();
}","@Override public Number call() throws IOException, TasteException, InterruptedException {
  MyrrixIRStatistics stats=(MyrrixIRStatistics)new PrecisionRecallEvaluator().evaluate(new File(""String_Node_Str""),0.9,0.5,null);
  return stats == null ? null : stats.getMeanAveragePrecision();
}",0.7753743760399334
109355,"@Test public void testFindGoodParameterValues() throws Exception {
  Map<String,ParameterRange> propertyRanges=Maps.newHashMap();
  propertyRanges.put(""String_Node_Str"",new ParameterRange(0.0001,0.1));
  propertyRanges.put(""String_Node_Str"",new ParameterRange(10,40));
  Callable<Number> evaluator=new Callable<Number>(){
    @Override public Number call() throws IOException, TasteException, InterruptedException {
      PrecisionRecallEvaluator prEvaluator=new PrecisionRecallEvaluator();
      MyrrixIRStatistics stats=(MyrrixIRStatistics)prEvaluator.evaluate(new File(""String_Node_Str""),0.9,0.5,null);
      return stats.getMeanAveragePrecision();
    }
  }
;
  ParameterOptimizer optimizer=new ParameterOptimizer(propertyRanges,evaluator);
  Map<String,Number> parameterValues=optimizer.findGoodParameterValues();
  log.info(parameterValues.toString());
  assertEquals(0.1,parameterValues.get(""String_Node_Str"").doubleValue());
  assertEquals(23,parameterValues.get(""String_Node_Str"").intValue());
}","@Test public void testFindGoodParameterValues() throws Exception {
  Map<String,ParameterRange> propertyRanges=Maps.newHashMap();
  propertyRanges.put(""String_Node_Str"",new ParameterRange(0.0001,0.1));
  propertyRanges.put(""String_Node_Str"",new ParameterRange(10,40));
  Callable<Number> evaluator=new Callable<Number>(){
    @Override public Number call() throws IOException, TasteException, InterruptedException {
      MyrrixIRStatistics stats=(MyrrixIRStatistics)new PrecisionRecallEvaluator().evaluate(new File(""String_Node_Str""),0.9,0.5,null);
      return stats == null ? null : stats.getMeanAveragePrecision();
    }
  }
;
  ParameterOptimizer optimizer=new ParameterOptimizer(propertyRanges,evaluator);
  Map<String,Number> parameterValues=optimizer.findGoodParameterValues();
  log.info(String.valueOf(parameterValues));
  assertEquals(0.1,parameterValues.get(""String_Node_Str"").doubleValue());
  assertEquals(23,parameterValues.get(""String_Node_Str"").intValue());
}",0.9262626262626262
109356,"@Test public void testEval() throws Exception {
  PrecisionRecallEvaluator evaluator=new PrecisionRecallEvaluator();
  MyrrixIRStatistics stats=(MyrrixIRStatistics)evaluator.evaluate(new File(""String_Node_Str""));
  log.info(stats.toString());
  assertTrue(stats.getPrecision() > 0.2);
  assertTrue(stats.getRecall() > 0.2);
  assertTrue(stats.getNormalizedDiscountedCumulativeGain() > 0.22);
  assertTrue(stats.getF1Measure() > 0.2);
  assertTrue(stats.getMeanAveragePrecision() > 0.125);
}","@Test public void testEval() throws Exception {
  MyrrixIRStatistics stats=(MyrrixIRStatistics)new PrecisionRecallEvaluator().evaluate(new File(""String_Node_Str""));
  log.info(String.valueOf(stats));
  assertTrue(stats.getPrecision() > 0.2);
  assertTrue(stats.getRecall() > 0.2);
  assertTrue(stats.getNormalizedDiscountedCumulativeGain() > 0.22);
  assertTrue(stats.getF1Measure() > 0.2);
  assertTrue(stats.getMeanAveragePrecision() > 0.125);
}",0.8601921024546425
109357,"@Test public void testEval() throws Exception {
  PrecisionRecallEvaluator evaluator=new PrecisionRecallEvaluator();
  MyrrixIRStatistics stats=(MyrrixIRStatistics)evaluator.evaluate(new File(""String_Node_Str""));
  log.info(stats.toString());
  assertTrue(stats.getPrecision() > 0.2);
  assertTrue(stats.getRecall() > 0.2);
  assertTrue(stats.getNormalizedDiscountedCumulativeGain() > 0.22);
  assertTrue(stats.getF1Measure() > 0.2);
  assertTrue(stats.getMeanAveragePrecision() > 0.125);
}","@Test public void testEval() throws Exception {
  MyrrixIRStatistics stats=(MyrrixIRStatistics)new PrecisionRecallEvaluator().evaluate(new File(""String_Node_Str""));
  log.info(String.valueOf(stats));
  assertTrue(stats.getPrecision() > 0.2);
  assertTrue(stats.getRecall() > 0.2);
  assertTrue(stats.getNormalizedDiscountedCumulativeGain() > 0.22);
  assertTrue(stats.getF1Measure() > 0.2);
  assertTrue(stats.getMeanAveragePrecision() > 0.125);
}",0.8601921024546425
109358,"@Test public void testEval() throws Exception {
  ReconstructionEvaluator evaluator=new ReconstructionEvaluator();
  EvaluationResult stats=evaluator.evaluate(new File(""String_Node_Str""));
  log.info(stats.toString());
  assertTrue(stats.getScore() < 0.41);
}","@Test public void testEval() throws Exception {
  EvaluationResult stats=new ReconstructionEvaluator().evaluate(new File(""String_Node_Str""));
  log.info(String.valueOf(stats));
  assertTrue(stats.getScore() < 0.41);
}",0.7436974789915967
109359,"@Test public void testEval() throws Exception {
  PrecisionRecallEvaluator evaluator=new PrecisionRecallEvaluator();
  MyrrixIRStatistics stats=(MyrrixIRStatistics)evaluator.evaluate(new File(""String_Node_Str""));
  log.info(stats.toString());
}","@Test public void testEval() throws Exception {
  MyrrixIRStatistics stats=(MyrrixIRStatistics)new PrecisionRecallEvaluator().evaluate(new File(""String_Node_Str""));
  log.info(String.valueOf(stats));
}",0.6831460674157304
109360,"private static Multimap<Long,RecommendedItem> readDataFile(File dataDir,double evaluationPercentage,RescorerProvider provider) throws IOException {
  int perMillion=(int)(1000000 * FastMath.sqrt(evaluationPercentage));
  Multimap<Long,RecommendedItem> data=ArrayListMultimap.create();
  for (  File dataFile : dataDir.listFiles(new PatternFilenameFilter(""String_Node_Str""))) {
    log.info(""String_Node_Str"",dataFile);
    int count=0;
    for (    CharSequence line : new FileLineIterable(dataFile)) {
      Iterator<String> parts=COMMA_TAB_SPLIT.split(line).iterator();
      String userIDString=parts.next();
      if (userIDString.hashCode() % 1000000 <= perMillion) {
        String itemIDString=parts.next();
        if (itemIDString.hashCode() % 1000000 <= perMillion) {
          long userID=Long.parseLong(userIDString);
          long itemID=Long.parseLong(itemIDString);
          if (parts.hasNext()) {
            String token=parts.next().trim();
            if (!token.isEmpty()) {
              float value=LangUtils.parseFloat(token);
              if (provider != null) {
                IDRescorer rescorer=provider.getRecommendRescorer(new long[]{userID},(MyrrixRecommender)null);
                if (rescorer != null) {
                  value=(float)rescorer.rescore(itemID,value);
                }
              }
              data.put(userID,new GenericRecommendedItem(itemID,value));
            }
          }
 else {
            float value=1.0f;
            if (provider != null) {
              IDRescorer rescorer=provider.getRecommendRescorer(new long[]{userID},(MyrrixRecommender)null);
              if (rescorer != null) {
                value=(float)rescorer.rescore(itemID,value);
              }
            }
            data.put(userID,new GenericRecommendedItem(itemID,value));
          }
        }
      }
      if (++count % 1000000 == 0) {
        log.info(""String_Node_Str"",count);
      }
    }
  }
  return data;
}","private static DataFileContents readDataFile(File dataDir,double evaluationPercentage,RescorerProvider provider) throws IOException {
  int perMillion=(int)(1000000 * FastMath.sqrt(evaluationPercentage));
  Multimap<Long,RecommendedItem> data=ArrayListMultimap.create();
  Multimap<String,RecommendedItem> itemTags=ArrayListMultimap.create();
  Multimap<String,RecommendedItem> userTags=ArrayListMultimap.create();
  for (  File dataFile : dataDir.listFiles(new PatternFilenameFilter(""String_Node_Str""))) {
    log.info(""String_Node_Str"",dataFile);
    int count=0;
    for (    CharSequence line : new FileLineIterable(dataFile)) {
      Iterator<String> parts=COMMA_TAB_SPLIT.split(line).iterator();
      String userIDString=parts.next();
      if (userIDString.hashCode() % 1000000 <= perMillion) {
        String itemIDString=parts.next();
        if (itemIDString.hashCode() % 1000000 <= perMillion) {
          Long userID=null;
          boolean userIsTag=userIDString.startsWith(""String_Node_Str"");
          if (!userIsTag) {
            userID=Long.valueOf(userIDString);
          }
          boolean itemIsTag=itemIDString.startsWith(""String_Node_Str"");
          Long itemID=null;
          if (!itemIsTag) {
            itemID=Long.valueOf(itemIDString);
          }
          Preconditions.checkArgument(!(userIsTag && itemIsTag),""String_Node_Str"");
          if (parts.hasNext()) {
            String token=parts.next().trim();
            if (!token.isEmpty()) {
              float value=LangUtils.parseFloat(token);
              if (userIsTag) {
                itemTags.put(userIDString,new GenericRecommendedItem(itemID,value));
              }
 else               if (itemIsTag) {
                userTags.put(itemIDString,new GenericRecommendedItem(userID,value));
              }
 else {
                if (provider != null) {
                  IDRescorer rescorer=provider.getRecommendRescorer(new long[]{userID},(MyrrixRecommender)null);
                  if (rescorer != null) {
                    value=(float)rescorer.rescore(itemID,value);
                  }
                }
                data.put(userID,new GenericRecommendedItem(itemID,value));
              }
            }
          }
 else {
            if (userIsTag) {
              itemTags.put(userIDString,new GenericRecommendedItem(itemID,1.0f));
            }
 else             if (itemIsTag) {
              userTags.put(itemIDString,new GenericRecommendedItem(userID,1.0f));
            }
 else {
              float value=1.0f;
              if (provider != null) {
                IDRescorer rescorer=provider.getRecommendRescorer(new long[]{userID},(MyrrixRecommender)null);
                if (rescorer != null) {
                  value=(float)rescorer.rescore(itemID,value);
                }
              }
              data.put(userID,new GenericRecommendedItem(itemID,value));
            }
          }
        }
      }
      if (++count % 1000000 == 0) {
        log.info(""String_Node_Str"",count);
      }
    }
  }
  return new DataFileContents(data,itemTags,userTags);
}",0.7442596991290578
109361,"private Multimap<Long,RecommendedItem> split(File dataDir,File trainingFile,double trainPercentage,double evaluationPercentage,RescorerProvider provider) throws IOException {
  Multimap<Long,RecommendedItem> data=readDataFile(dataDir,evaluationPercentage,provider);
  log.info(""String_Node_Str"",data.size());
  Multimap<Long,RecommendedItem> testData=ArrayListMultimap.create();
  Writer trainingOut=IOUtils.buildGZIPWriter(trainingFile);
  try {
    Iterator<Map.Entry<Long,Collection<RecommendedItem>>> it=data.asMap().entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<Long,Collection<RecommendedItem>> entry=it.next();
      long userID=entry.getKey();
      List<RecommendedItem> userPrefs=Lists.newArrayList(entry.getValue());
      it.remove();
      if (isSplitTestByPrefValue()) {
        Collections.sort(userPrefs,ByValueAscComparator.INSTANCE);
      }
      int numTraining=FastMath.max(1,(int)(trainPercentage * userPrefs.size()));
      for (      RecommendedItem rec : userPrefs.subList(0,numTraining)) {
        trainingOut.write(Long.toString(userID));
        trainingOut.write(DELIMITER);
        trainingOut.write(Long.toString(rec.getItemID()));
        trainingOut.write(DELIMITER);
        trainingOut.write(Float.toString(rec.getValue()));
        trainingOut.write('\n');
      }
      for (      RecommendedItem rec : userPrefs.subList(numTraining,userPrefs.size())) {
        testData.put(userID,rec);
      }
    }
  }
  finally {
    trainingOut.close();
  }
  log.info(""String_Node_Str"",testData.size());
  return testData;
}","private Multimap<Long,RecommendedItem> split(File dataDir,File trainingFile,double trainPercentage,double evaluationPercentage,RescorerProvider provider) throws IOException {
  DataFileContents dataFileContents=readDataFile(dataDir,evaluationPercentage,provider);
  Multimap<Long,RecommendedItem> data=dataFileContents.getData();
  log.info(""String_Node_Str"",data.size());
  Multimap<Long,RecommendedItem> testData=ArrayListMultimap.create();
  Writer trainingOut=IOUtils.buildGZIPWriter(trainingFile);
  try {
    Iterator<Map.Entry<Long,Collection<RecommendedItem>>> it=data.asMap().entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<Long,Collection<RecommendedItem>> entry=it.next();
      long userID=entry.getKey();
      List<RecommendedItem> userPrefs=Lists.newArrayList(entry.getValue());
      it.remove();
      if (isSplitTestByPrefValue()) {
        Collections.sort(userPrefs,ByValueAscComparator.INSTANCE);
      }
      int numTraining=FastMath.max(1,(int)(trainPercentage * userPrefs.size()));
      for (      RecommendedItem rec : userPrefs.subList(0,numTraining)) {
        trainingOut.write(Long.toString(userID));
        trainingOut.write(DELIMITER);
        trainingOut.write(Long.toString(rec.getItemID()));
        trainingOut.write(DELIMITER);
        trainingOut.write(Float.toString(rec.getValue()));
        trainingOut.write('\n');
      }
      for (      RecommendedItem rec : userPrefs.subList(numTraining,userPrefs.size())) {
        testData.put(userID,rec);
      }
    }
    for (    Map.Entry<String,RecommendedItem> entry : dataFileContents.getItemTags().entries()) {
      trainingOut.write(entry.getKey());
      trainingOut.write(DELIMITER);
      trainingOut.write(Long.toString(entry.getValue().getItemID()));
      trainingOut.write(DELIMITER);
      trainingOut.write(Float.toString(entry.getValue().getValue()));
      trainingOut.write('\n');
    }
    for (    Map.Entry<String,RecommendedItem> entry : dataFileContents.getUserTags().entries()) {
      trainingOut.write(Long.toString(entry.getValue().getItemID()));
      trainingOut.write(DELIMITER);
      trainingOut.write(entry.getKey());
      trainingOut.write(DELIMITER);
      trainingOut.write(Float.toString(entry.getValue().getValue()));
      trainingOut.write('\n');
    }
  }
  finally {
    trainingOut.close();
  }
  log.info(""String_Node_Str"",testData.size());
  return testData;
}",0.7655622489959839
109362,"/** 
 * @return true iff the given file is a gzip-compressed file with no content; the file itself may notbe empty because it contains gzip headers and footers
 * @throw IOException if the file is not a gzip file or can't be read
 */
public static boolean isGZIPFileEmpty(File f) throws IOException {
  InputStream in=new GZIPInputStream(new FileInputStream(f));
  try {
    return in.read() == -1;
  }
  finally {
    Closeables.close(in,true);
  }
}","/** 
 * @return true iff the given file is a gzip-compressed file with no content; the file itself may notbe empty because it contains gzip headers and footers
 * @throws IOException if the file is not a gzip file or can't be read
 */
public static boolean isGZIPFileEmpty(File f) throws IOException {
  InputStream in=new GZIPInputStream(new FileInputStream(f));
  try {
    return in.read() == -1;
  }
  finally {
    Closeables.close(in,true);
  }
}",0.9988925802879292
109363,"/** 
 * @param userVectors user feature vector(s) for which recommendations are being made. This may or may notinfluence which items are returned.
 * @return a set of items most likely to be a good recommendation for the given users. These are returnedas item ID / vector pairs ( {@link FastByIDMap.MapEntry}). They are returned as an   {@link Iterator} --and not just one, but potentially many. If several are returned, then the caller will process the {@link Iterator}s in parallel for speed.
 */
Collection<Iterator<FastByIDMap.MapEntry<float[]>>> getCandidateIterator(float[][] userVectors);","/** 
 * @param userVectors user feature vector(s) for which recommendations are being made. This may or may notinfluence which items are returned.
 * @return a set of items most likely to be a good recommendation for the given users. These are returnedas item ID / vector pairs ( {@link FastByIDMap}'s   {@code MapEntry}). They are returned as an   {@link Iterator} --and not just one, but potentially many. If several are returned, then the caller will process the {@link Iterator}s in parallel for speed.
 */
Collection<Iterator<FastByIDMap.MapEntry<float[]>>> getCandidateIterator(float[][] userVectors);",0.9883527454242927
109364,"@Override public double rescore(LongPair itemIDs,double value){
  double result=value;
  for (  Rescorer<LongPair> rescorer : rescorers) {
    value=rescorer.rescore(itemIDs,value);
    if (Double.isNaN(value)) {
      return Double.NaN;
    }
  }
  return result;
}","@Override public double rescore(LongPair itemIDs,double value){
  for (  Rescorer<LongPair> rescorer : rescorers) {
    value=rescorer.rescore(itemIDs,value);
    if (Double.isNaN(value)) {
      return Double.NaN;
    }
  }
  return value;
}",0.9330708661417324
109365,"@Override public double rescore(long itemID,double value){
  double result=value;
  for (  IDRescorer rescorer : rescorers) {
    value=rescorer.rescore(itemID,value);
    if (Double.isNaN(value)) {
      return Double.NaN;
    }
  }
  return result;
}","@Override public double rescore(long itemID,double value){
  for (  IDRescorer rescorer : rescorers) {
    value=rescorer.rescore(itemID,value);
    if (Double.isNaN(value)) {
      return Double.NaN;
    }
  }
  return value;
}",0.9291666666666668
109366,"static void readInputFiles(FastByIDMap<FastIDSet> knownItemIDs,FastByIDMap<FastByIDFloatMap> rbyRow,FastByIDMap<FastByIDFloatMap> rbyColumn,File inputDir) throws IOException {
  FilenameFilter csvFilter=new PatternFilenameFilter(""String_Node_Str"");
  File[] otherFiles=inputDir.listFiles(new InvertedFilenameFilter(csvFilter));
  if (otherFiles != null) {
    for (    File otherFile : otherFiles) {
      log.info(""String_Node_Str"",otherFile.getName());
    }
  }
  File[] inputFiles=inputDir.listFiles(csvFilter);
  if (inputFiles == null) {
    log.info(""String_Node_Str"",inputDir);
    return;
  }
  Arrays.sort(inputFiles,ByLastModifiedComparator.INSTANCE);
  int lines=0;
  int badLines=0;
  for (  File inputFile : inputFiles) {
    log.info(""String_Node_Str"",inputFile);
    for (    CharSequence line : new FileLineIterable(inputFile)) {
      Iterator<String> it=COMMA.split(line).iterator();
      long userID;
      long itemID;
      float value;
      try {
        userID=Long.parseLong(it.next());
        itemID=Long.parseLong(it.next());
        if (it.hasNext()) {
          String valueToken=it.next().trim();
          value=valueToken.isEmpty() ? Float.NaN : LangUtils.parseFloat(valueToken);
        }
 else {
          value=1.0f;
        }
      }
 catch (      NoSuchElementException nsee) {
        log.warn(""String_Node_Str"",line);
        if (++badLines > 100) {
          throw new IOException(""String_Node_Str"");
        }
        continue;
      }
catch (      IllegalArgumentException iae) {
        if (lines == 0) {
          log.info(""String_Node_Str"");
        }
 else {
          log.warn(""String_Node_Str"",line);
          if (++badLines > 100) {
            throw new IOException(""String_Node_Str"");
          }
        }
        continue;
      }
      if (Float.isNaN(value)) {
        MatrixUtils.remove(userID,itemID,rbyRow,rbyColumn);
      }
 else {
        MatrixUtils.addTo(userID,itemID,value,rbyRow,rbyColumn);
      }
      if (knownItemIDs != null) {
        FastIDSet itemIDs=knownItemIDs.get(userID);
        if (Float.isNaN(value)) {
          if (itemIDs != null) {
            itemIDs.remove(itemID);
            if (itemIDs.isEmpty()) {
              knownItemIDs.remove(userID);
            }
          }
        }
 else {
          if (itemIDs == null) {
            itemIDs=new FastIDSet();
            knownItemIDs.put(userID,itemIDs);
          }
          itemIDs.add(itemID);
        }
      }
      if (++lines % 1000000 == 0) {
        log.info(""String_Node_Str"",lines);
      }
    }
  }
  removeSmall(rbyRow);
  removeSmall(rbyColumn);
}","static void readInputFiles(FastByIDMap<FastIDSet> knownItemIDs,FastByIDMap<FastByIDFloatMap> rbyRow,FastByIDMap<FastByIDFloatMap> rbyColumn,File inputDir) throws IOException {
  FilenameFilter csvFilter=new PatternFilenameFilter(""String_Node_Str"");
  File[] otherFiles=inputDir.listFiles(new InvertedFilenameFilter(csvFilter));
  if (otherFiles != null) {
    for (    File otherFile : otherFiles) {
      log.info(""String_Node_Str"",otherFile.getName());
    }
  }
  File[] inputFiles=inputDir.listFiles(csvFilter);
  if (inputFiles == null) {
    log.info(""String_Node_Str"",inputDir);
    return;
  }
  Arrays.sort(inputFiles,ByLastModifiedComparator.INSTANCE);
  int lines=0;
  int badLines=0;
  for (  File inputFile : inputFiles) {
    log.info(""String_Node_Str"",inputFile);
    for (    CharSequence line : new FileLineIterable(inputFile)) {
      lines++;
      Iterator<String> it=COMMA.split(line).iterator();
      long userID;
      long itemID;
      float value;
      try {
        userID=Long.parseLong(it.next());
        itemID=Long.parseLong(it.next());
        if (it.hasNext()) {
          String valueToken=it.next().trim();
          value=valueToken.isEmpty() ? Float.NaN : LangUtils.parseFloat(valueToken);
        }
 else {
          value=1.0f;
        }
      }
 catch (      NoSuchElementException nsee) {
        log.warn(""String_Node_Str"",line);
        if (++badLines > 100) {
          throw new IOException(""String_Node_Str"");
        }
        continue;
      }
catch (      IllegalArgumentException iae) {
        if (lines == 1) {
          log.info(""String_Node_Str"");
        }
 else {
          log.warn(""String_Node_Str"",line);
          if (++badLines > 100) {
            throw new IOException(""String_Node_Str"");
          }
        }
        continue;
      }
      if (Float.isNaN(value)) {
        MatrixUtils.remove(userID,itemID,rbyRow,rbyColumn);
      }
 else {
        MatrixUtils.addTo(userID,itemID,value,rbyRow,rbyColumn);
      }
      if (knownItemIDs != null) {
        FastIDSet itemIDs=knownItemIDs.get(userID);
        if (Float.isNaN(value)) {
          if (itemIDs != null) {
            itemIDs.remove(itemID);
            if (itemIDs.isEmpty()) {
              knownItemIDs.remove(userID);
            }
          }
        }
 else {
          if (itemIDs == null) {
            itemIDs=new FastIDSet();
            knownItemIDs.put(userID,itemIDs);
          }
          itemIDs.add(itemID);
        }
      }
      if (lines % 1000000 == 0) {
        log.info(""String_Node_Str"",lines);
      }
    }
  }
  removeSmall(rbyRow);
  removeSmall(rbyColumn);
}",0.9963636363636365
109367,"/** 
 * @param host Serving Layer host to communicate with. Defaults to {@link #DEFAULT_PORT}.
 */
public void setHost(String host){
  this.host=host;
}","/** 
 * @param host Serving Layer host to communicate with. Defaults to {@link #DEFAULT_PORT}.
 */
public void setHost(String host){
  Preconditions.checkArgument(host == null || (!host.startsWith(""String_Node_Str"") && !host.startsWith(""String_Node_Str"")),""String_Node_Str"",host);
  this.host=host;
}",0.6150442477876106
109368,"@Override public RecommendedItem next(){
  FastByIDMap.MapEntry<float[]> entry=Yiterator.next();
  long itemID=entry.getKey();
  FastIDSet theKnownItemIDs=knownItemIDs;
  if (theKnownItemIDs != null) {
synchronized (theKnownItemIDs) {
      if (theKnownItemIDs.contains(itemID)) {
        return null;
      }
    }
  }
  IDRescorer rescorer=this.rescorer;
  boolean hasRescorer=rescorer != null;
  if (hasRescorer && rescorer.isFiltered(itemID)) {
    return null;
  }
  float[] itemFeatures=entry.getValue();
  double sum=0.0;
  int count=0;
  for (  float[] oneUserFeatures : features) {
    double dot=SimpleVectorMath.dot(itemFeatures,oneUserFeatures);
    if (hasRescorer) {
      dot=rescorer.rescore(itemID,dot);
    }
    sum+=dot;
    count++;
  }
  float result=(float)(sum / count);
  Preconditions.checkState(LangUtils.isFinite(result),""String_Node_Str"");
  delegate.set(itemID,result);
  return delegate;
}","@Override public RecommendedItem next(){
  FastByIDMap.MapEntry<float[]> entry=Yiterator.next();
  long itemID=entry.getKey();
  FastIDSet theKnownItemIDs=knownItemIDs;
  if (theKnownItemIDs != null) {
synchronized (theKnownItemIDs) {
      if (theKnownItemIDs.contains(itemID)) {
        return null;
      }
    }
  }
  IDRescorer rescorer=this.rescorer;
  boolean hasRescorer=rescorer != null;
  if (hasRescorer && rescorer.isFiltered(itemID)) {
    return null;
  }
  float[] itemFeatures=entry.getValue();
  double sum=0.0;
  int count=0;
  for (  float[] oneUserFeatures : features) {
    double dot=SimpleVectorMath.dot(itemFeatures,oneUserFeatures);
    if (hasRescorer) {
      dot=rescorer.rescore(itemID,dot);
      if (!LangUtils.isFinite(dot)) {
        return null;
      }
    }
    sum+=dot;
    count++;
  }
  float result=(float)(sum / count);
  Preconditions.checkState(LangUtils.isFinite(result),""String_Node_Str"");
  delegate.set(itemID,result);
  return delegate;
}",0.9648662821185108
109369,"/** 
 * Handle the change of the brush size
 * @param view the current brush view
 */
private void handleBrushSize(View view){
  float bSize=getResources().getInteger(R.integer.medium_size);
  if (view.getId() == R.id.small_brush) {
    bSize=getResources().getInteger(R.integer.small_size);
  }
 else   if (view.getId() == R.id.large_brush) {
    bSize=getResources().getInteger(R.integer.large_size);
  }
 else   if (view.getId() == R.id.largest_brush) {
    bSize=getResources().getInteger(R.integer.largest_size);
  }
  drawView.setErase(false);
  drawView.setBrushSize(bSize);
}","/** 
 * Handle the change of the brush size
 * @param view the current brush view
 */
public void handleBrushSize(View view){
  drawView.setErase(false);
switch (view.getId()) {
case R.id.small_brush:
    drawView.setBrushSize(getResources().getInteger(R.integer.small_size));
  break;
case R.id.large_brush:
drawView.setBrushSize(getResources().getInteger(R.integer.large_size));
break;
case R.id.largest_brush:
drawView.setBrushSize(getResources().getInteger(R.integer.largest_size));
break;
default :
drawView.setBrushSize(getResources().getInteger(R.integer.medium_size));
}
}",0.3095442820292347
109370,"private void handleColorPick(){
  drawView.setErase(false);
  drawView.setBrushSize(drawView.getLastBrushSize());
  openColorPickerDialog(false);
}","private void handleColorPick(){
  drawView.setErase(false);
  openColorPickerDialog(false);
}",0.775
109371,"/** 
 * Handle the new button click
 */
private void openNewDrawingDialog(){
  MaterialDialog.Builder builder=new MaterialDialog.Builder(this);
  builder.title(""String_Node_Str"").callback(getMDCallback()).positiveText(""String_Node_Str"").negativeText(""String_Node_Str"").content((""String_Node_Str"" + ""String_Node_Str""));
  builder.show();
}","/** 
 * Handle the new button click
 */
private void openNewDrawingDialog(){
  MaterialDialog.Builder builder=new MaterialDialog.Builder(this);
  builder.title(R.string.action_new_drawing).callback(getMDCallback()).positiveText(R.string.action_ok).negativeText(R.string.action_cancel).content((R.string.action_new_q));
  builder.show();
}",0.7071005917159763
109372,"/** 
 * Handle the save button click
 */
private void openCreateJigsawDialog(){
  CharSequence levels[]=new CharSequence[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  MaterialDialog.Builder builder=new MaterialDialog.Builder(this).title(""String_Node_Str"").items(levels).itemsCallback(getMDListCallback());
  builder.show();
}","/** 
 * Handle the save button click
 */
private void openCreateJigsawDialog(){
  CharSequence levels[]=new CharSequence[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  MaterialDialog.Builder builder=new MaterialDialog.Builder(this).title(R.string.level_difficulty).items(levels).itemsCallback(getMDListCallback());
  builder.show();
}",0.9387755102040816
109373,"/** 
 * Set new brush size for drawing
 * @param newSize the new color
 */
public void setBrushSize(float newSize){
  brushSize=TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,newSize,getResources().getDisplayMetrics());
  drawPaint.setStrokeWidth(brushSize);
  lastBrushSize=brushSize;
}","/** 
 * Set new brush size for drawing
 * @param newSize the new color
 */
public void setBrushSize(float newSize){
  lastBrushSize=brushSize;
  brushSize=TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,newSize,getResources().getDisplayMetrics());
  drawPaint.setStrokeWidth(brushSize);
}",0.9081632653061223
109374,"@Override public void onTick(){
  if (!bot.hasSpawned() || !bot.isConnected())   return;
  if (ticksToGo > 0) {
    ticksToGo--;
    return;
  }
  MainPlayerEntity player=bot.getPlayer();
  if (player == null)   return;
  if (firstStart) {
    bot.say(""String_Node_Str"");
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    connectionHandler.sendPacket(new Packet255KickDisconnect(""String_Node_Str""));
    ticksToGo=15;
    firstStart=false;
    return;
  }
 else   canSpam=true;
  if (canSpam) {
    if (die) {
      connectionHandler.sendPacket(new Packet255KickDisconnect(""String_Node_Str""));
      ticksToGo=15;
      return;
    }
    if (!bot.hasSpawned())     return;
    if (spamMessage == null)     return;
    if (nextMessage > 0) {
      nextMessage--;
      return;
    }
    String message=spamMessage;
    MessageFormatter formatter=new MessageFormatter();
    String botName;
synchronized (bots) {
      botName=bots.get(nextBot++).bot.getSession().getUsername();
      if (nextBot >= bots.size())       nextBot=0;
    }
    formatter.setVariable(""String_Node_Str"",botName);
    if (spamList.length > 0) {
      formatter.setVariable(""String_Node_Str"",spamList[nextSpamList++]);
      if (nextSpamList >= spamList.length)       nextSpamList=0;
    }
    formatter.setVariable(""String_Node_Str"",Util.generateRandomString(15 + random.nextInt(6)));
    formatter.setVariable(""String_Node_Str"",Character.toString(msgChars[nextMsgChar++]));
    if (nextMsgChar >= msgChars.length)     nextMsgChar=0;
    message=formatter.format(message);
    connectionHandler.sendPacket(new Packet3Chat(message));
  }
}","@EventHandler public void onTick(TickEvent event){
  if (!bot.hasSpawned() || !bot.isConnected())   return;
  if (ticksToGo > 0) {
    ticksToGo--;
    return;
  }
  MainPlayerEntity player=bot.getPlayer();
  if (player == null)   return;
  if (firstStart) {
    bot.say(""String_Node_Str"");
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    connectionHandler.sendPacket(new Packet255KickDisconnect(""String_Node_Str""));
    ticksToGo=15;
    firstStart=false;
    return;
  }
 else   canSpam=true;
  if (canSpam) {
    if (die) {
      connectionHandler.sendPacket(new Packet255KickDisconnect(""String_Node_Str""));
      ticksToGo=15;
      return;
    }
    if (!bot.hasSpawned())     return;
    if (spamMessage == null)     return;
    if (nextMessage > 0) {
      nextMessage--;
      return;
    }
    String message=spamMessage;
    MessageFormatter formatter=new MessageFormatter();
    String botName;
synchronized (bots) {
      botName=bots.get(nextBot++).bot.getSession().getUsername();
      if (nextBot >= bots.size())       nextBot=0;
    }
    formatter.setVariable(""String_Node_Str"",botName);
    if (spamList.length > 0) {
      formatter.setVariable(""String_Node_Str"",spamList[nextSpamList++]);
      if (nextSpamList >= spamList.length)       nextSpamList=0;
    }
    formatter.setVariable(""String_Node_Str"",Util.generateRandomString(15 + random.nextInt(6)));
    formatter.setVariable(""String_Node_Str"",Character.toString(msgChars[nextMsgChar++]));
    if (nextMsgChar >= msgChars.length)     nextMsgChar=0;
    message=formatter.format(message);
    connectionHandler.sendPacket(new Packet3Chat(message));
  }
}",0.9908148148148148
109375,"@EventHandler public void onPacketProcess(PacketProcessEvent event){
  Packet packet=event.getPacket();
switch (packet.getId()) {
case 0:
    connectionHandler.sendPacket(new Packet0KeepAlive(new Random().nextInt()));
  break;
case 3:
String message=((Packet3Chat)packet).message;
message=Util.stripColors(message);
System.out.println(""String_Node_Str"" + bot.getSession().getUsername() + ""String_Node_Str""+ message);
String testMessage=""String_Node_Str"";
String testMessage2=""String_Node_Str"";
String testMessage3=""String_Node_Str"";
if (message.contains(testMessage)) {
try {
String captcha=message.split(Pattern.quote(testMessage))[1].split(""String_Node_Str"")[0];
ScriptEngineManager mgr=new ScriptEngineManager();
ScriptEngine engine=mgr.getEngineByName(""String_Node_Str"");
String solved=engine.eval(captcha).toString();
solved=solved.split(""String_Node_Str"")[0];
connectionHandler.sendPacket(new Packet3Chat(solved));
}
 catch (Exception exception) {
exception.printStackTrace();
}
}
 else if (message.contains(testMessage2) && message.contains(testMessage3)) {
try {
String captcha=message.split(Pattern.quote(testMessage2))[1].split(Pattern.quote(testMessage3))[0];
connectionHandler.sendPacket(new Packet3Chat(captcha));
}
 catch (Exception exception) {
exception.printStackTrace();
}
}
 else if (message.startsWith(""String_Node_Str"")) {
String password=Util.generateRandomString(10 + random.nextInt(6));
bot.say(""String_Node_Str"" + password + ""String_Node_Str""+ password);
}
 else if (message.startsWith(""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet3Chat(message));
}
 else if ((message.contains(""String_Node_Str"") && message.contains(""String_Node_Str"")) || message.contains(""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet3Chat(""String_Node_Str""));
}
 else if (message.contains(owner + ""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet3Chat(""String_Node_Str""));
}
 else if (message.contains(owner)) {
if (message.contains(""String_Node_Str"")) {
spamMessage=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length());
}
 else if (message.contains(""String_Node_Str"")) {
spamMessage=null;
bot.getTaskManager().stopAll();
bot.setActivity(null);
}
 else if (message.contains(""String_Node_Str"")) {
die=true;
bot.getTaskManager().stopAll();
bot.setActivity(null);
}
 else if (message.contains(""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet3Chat(message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length())));
}
 else if (message.contains(""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet255KickDisconnect(""String_Node_Str""));
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
if (player == null) return;
PlayerInventory inventory=player.getInventory();
inventory.setCurrentHeldSlot(Integer.parseInt(message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"")[0]));
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
PlayerInventory inventory=player.getInventory();
String substring=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"")[0];
int id=Integer.parseInt(substring);
for (int slot=0; slot < 40; slot++) {
ItemStack item=inventory.getItemAt(slot);
if (item != null && item.getId() == id) {
inventory.selectItemAt(slot,true);
inventory.dropSelectedItem();
}
}
inventory.close();
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
PlayerInventory inventory=player.getInventory();
if (message.contains(""String_Node_Str"")) {
String substring=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"")[0];
try {
int slot=Integer.parseInt(substring);
if (slot < 0 || slot >= 40) return;
if (inventory.getItemAt(slot) != null) {
inventory.selectItemAt(slot,true);
inventory.dropSelectedItem();
}
return;
}
 catch (NumberFormatException e) {
}
}
for (int slot=0; slot < 40; slot++) {
if (inventory.getItemAt(slot) != null) {
inventory.selectItemAt(slot,true);
inventory.dropSelectedItem();
}
}
inventory.close();
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
PlayerInventory inventory=player.getInventory();
String substring=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length());
try {
int slot1=Integer.parseInt(substring.split(""String_Node_Str"")[0]);
int slot2=Integer.parseInt(substring.split(""String_Node_Str"")[1]);
if (slot1 < 0 || slot1 >= 45 || slot2 < 0 || slot2 >= 45) return;
inventory.selectItemAt(slot1);
inventory.selectItemAt(slot2);
inventory.selectItemAt(slot1);
}
 catch (NumberFormatException e) {
}
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
PlayerInventory inventory=player.getInventory();
boolean helmet=inventory.getArmorAt(0) != null;
boolean chestplate=inventory.getArmorAt(1) != null;
boolean leggings=inventory.getArmorAt(2) != null;
boolean boots=inventory.getArmorAt(3) != null;
boolean changed=false;
for (int i=0; i < 36; i++) {
ItemStack item=inventory.getItemAt(i);
if (item == null) continue;
int armorSlot;
int id=item.getId();
if (!helmet && (id == 86 || id == 298 || id == 302 || id == 306 || id == 310 || id == 314)) {
armorSlot=0;
helmet=true;
}
 else if (!chestplate && (id == 299 || id == 303 || id == 307 || id == 311 || id == 315)) {
armorSlot=1;
chestplate=true;
}
 else if (!leggings && (id == 300 || id == 304 || id == 308 || id == 312 || id == 316)) {
armorSlot=2;
leggings=true;
}
 else if (!boots && (id == 301 || id == 305 || id == 309 || id == 313 || id == 317)) {
armorSlot=3;
boots=true;
}
 else if (helmet && chestplate && leggings&& boots) break;
 else continue;
inventory.selectItemAt(i);
inventory.selectArmorAt(armorSlot);
changed=true;
}
if (!changed) {
for (int i=0; i < 36; i++) {
ItemStack item=inventory.getItemAt(i);
if (item != null) continue;
int armorSlot;
if (helmet) {
armorSlot=0;
helmet=false;
}
 else if (chestplate) {
armorSlot=1;
chestplate=false;
}
 else if (leggings) {
armorSlot=2;
leggings=false;
}
 else if (boots) {
armorSlot=3;
boots=false;
}
 else if (!helmet && !chestplate && !leggings&& !boots) break;
 else continue;
inventory.selectArmorAt(armorSlot);
inventory.selectItemAt(i);
}
}
inventory.close();
bot.say(""String_Node_Str"");
}
 else if (message.contains(""String_Node_Str"")) {
String name=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"")[0];
owner=name;
bot.say(""String_Node_Str"" + name);
}
 else if (message.contains(""String_Node_Str"")) {
String[] args=new String[0];
if (message.trim().contains(""String_Node_Str"")) args=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"");
String name=owner;
if (args.length > 0) {
name=args[0];
if (name.equalsIgnoreCase(owner)) {
name=owner;
args=new String[0];
}
}
FollowTask followTask=bot.getTaskManager().getTaskFor(FollowTask.class);
if (followTask.isActive()) followTask.stop();
for (Entity entity : bot.getWorld().getEntities()) {
if (entity instanceof PlayerEntity && Util.stripColors(((PlayerEntity)entity).getName()).equalsIgnoreCase(name)) {
followTask.follow(entity);
bot.say(""String_Node_Str"" + (args.length > 0 ? Util.stripColors(((PlayerEntity)entity).getName()) : ""String_Node_Str"") + ""String_Node_Str"");
return;
}
}
bot.say(""String_Node_Str"" + name + ""String_Node_Str"");
}
 else if (message.contains(""String_Node_Str"")) {
String[] args=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"");
String name=args[0];
AttackTask attackTask=bot.getTaskManager().getTaskFor(AttackTask.class);
for (Entity entity : bot.getWorld().getEntities()) {
if (entity instanceof PlayerEntity && Util.stripColors(((PlayerEntity)entity).getName()).equalsIgnoreCase(name)) {
attackTask.setAttackEntity(entity);
bot.say(""String_Node_Str"" + Util.stripColors(((PlayerEntity)entity).getName()) + ""String_Node_Str"");
return;
}
}
bot.say(""String_Node_Str"" + name + ""String_Node_Str"");
}
 else if (message.contains(""String_Node_Str"")) {
String[] args=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"");
MainPlayerEntity player=bot.getPlayer();
BlockLocation location=new BlockLocation(player.getLocation());
boolean relativeX=args[0].charAt(0) == '+', relativeZ=args[args.length - 1].charAt(0) == '+';
int x, y, z;
if (relativeX) x=location.getX() + Integer.parseInt(args[0].substring(1));
 else x=Integer.parseInt(args[0]);
if (relativeZ) z=location.getZ() + Integer.parseInt(args[args.length - 1].substring(1));
 else z=Integer.parseInt(args[args.length - 1]);
if (args.length < 3) {
World world=bot.getWorld();
for (y=256; y > 0; y--) {
int id=world.getBlockIdAt(x,y - 1,z);
if (BlockType.getById(id).isSolid()) break;
}
if (y <= 0) {
bot.say(""String_Node_Str"");
return;
}
}
 else y=Integer.parseInt(args[1]);
BlockLocation target=new BlockLocation(x,y,z);
bot.setActivity(new WalkActivity(bot,target));
bot.say(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ z+ ""String_Node_Str"");
}
 else if (message.contains(""String_Node_Str"")) {
HostileTask task=bot.getTaskManager().getTaskFor(HostileTask.class);
if (task.isActive()) {
task.stop();
bot.say(""String_Node_Str"");
}
 else {
task.start();
bot.say(""String_Node_Str"");
}
}
}
 else if (message.contains(""String_Node_Str"") && spamMessage != null && createFaction) {
String msg=""String_Node_Str"" + Util.generateRandomString(7 + random.nextInt(4));
bot.say(msg);
}
break;
case 8:
Packet8UpdateHealth updateHealth=(Packet8UpdateHealth)packet;
if (updateHealth.healthMP <= 0) connectionHandler.sendPacket(new Packet205ClientCommand(1));
break;
case 9:
TaskManager taskManager=bot.getTaskManager();
taskManager.stopAll();
bot.setActivity(null);
break;
}
}","@EventHandler public void onPacketProcess(PacketProcessEvent event){
  Packet packet=event.getPacket();
switch (packet.getId()) {
case 0:
    connectionHandler.sendPacket(new Packet0KeepAlive(new Random().nextInt()));
  break;
case 3:
String message=((Packet3Chat)packet).message;
message=Util.stripColors(message);
System.out.println(""String_Node_Str"" + bot.getSession().getUsername() + ""String_Node_Str""+ message);
String testMessage=""String_Node_Str"";
String testMessage2=""String_Node_Str"";
String testMessage3=""String_Node_Str"";
if (message.contains(testMessage)) {
try {
String captcha=message.split(Pattern.quote(testMessage))[1].split(""String_Node_Str"")[0];
ScriptEngineManager mgr=new ScriptEngineManager();
ScriptEngine engine=mgr.getEngineByName(""String_Node_Str"");
String solved=engine.eval(captcha).toString();
solved=solved.split(""String_Node_Str"")[0];
connectionHandler.sendPacket(new Packet3Chat(solved));
}
 catch (Exception exception) {
exception.printStackTrace();
}
}
 else if (message.contains(testMessage2) && message.contains(testMessage3)) {
try {
String captcha=message.split(Pattern.quote(testMessage2))[1].split(Pattern.quote(testMessage3))[0];
connectionHandler.sendPacket(new Packet3Chat(captcha));
}
 catch (Exception exception) {
exception.printStackTrace();
}
}
 else if (message.startsWith(""String_Node_Str"")) {
String password=Util.generateRandomString(10 + random.nextInt(6));
bot.say(""String_Node_Str"" + password + ""String_Node_Str""+ password);
}
 else if (message.startsWith(""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet3Chat(message));
}
 else if ((message.contains(""String_Node_Str"") && message.contains(""String_Node_Str"")) || message.contains(""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet3Chat(""String_Node_Str""));
}
 else if (message.contains(owner + ""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet3Chat(""String_Node_Str""));
}
 else if (message.contains(owner)) {
if (message.contains(""String_Node_Str"")) {
spamMessage=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length());
}
 else if (message.contains(""String_Node_Str"")) {
spamMessage=null;
bot.getTaskManager().stopAll();
bot.setActivity(null);
}
 else if (message.contains(""String_Node_Str"")) {
die=true;
bot.getTaskManager().stopAll();
bot.setActivity(null);
}
 else if (message.contains(""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet3Chat(message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length())));
}
 else if (message.contains(""String_Node_Str"")) {
connectionHandler.sendPacket(new Packet255KickDisconnect(""String_Node_Str""));
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
if (player == null) return;
PlayerInventory inventory=player.getInventory();
inventory.setCurrentHeldSlot(Integer.parseInt(message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"")[0]));
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
PlayerInventory inventory=player.getInventory();
String substring=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"")[0];
int id=Integer.parseInt(substring);
for (int slot=0; slot < 40; slot++) {
ItemStack item=inventory.getItemAt(slot);
if (item != null && item.getId() == id) {
inventory.selectItemAt(slot,true);
inventory.dropSelectedItem();
}
}
inventory.close();
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
PlayerInventory inventory=player.getInventory();
if (message.contains(""String_Node_Str"")) {
String substring=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"")[0];
try {
int slot=Integer.parseInt(substring);
if (slot < 0 || slot >= 40) return;
if (inventory.getItemAt(slot) != null) {
inventory.selectItemAt(slot,true);
inventory.dropSelectedItem();
}
return;
}
 catch (NumberFormatException e) {
}
}
for (int slot=0; slot < 40; slot++) {
if (inventory.getItemAt(slot) != null) {
inventory.selectItemAt(slot,true);
inventory.dropSelectedItem();
}
}
inventory.close();
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
PlayerInventory inventory=player.getInventory();
String substring=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length());
try {
int slot1=Integer.parseInt(substring.split(""String_Node_Str"")[0]);
int slot2=Integer.parseInt(substring.split(""String_Node_Str"")[1]);
if (slot1 < 0 || slot1 >= 45 || slot2 < 0 || slot2 >= 45) return;
inventory.selectItemAt(slot1);
inventory.selectItemAt(slot2);
inventory.selectItemAt(slot1);
}
 catch (NumberFormatException e) {
}
}
 else if (message.contains(""String_Node_Str"")) {
MainPlayerEntity player=bot.getPlayer();
PlayerInventory inventory=player.getInventory();
boolean helmet=inventory.getArmorAt(0) != null;
boolean chestplate=inventory.getArmorAt(1) != null;
boolean leggings=inventory.getArmorAt(2) != null;
boolean boots=inventory.getArmorAt(3) != null;
boolean changed=false;
for (int i=0; i < 36; i++) {
ItemStack item=inventory.getItemAt(i);
if (item == null) continue;
int armorSlot;
int id=item.getId();
if (!helmet && (id == 86 || id == 298 || id == 302 || id == 306 || id == 310 || id == 314)) {
armorSlot=0;
helmet=true;
}
 else if (!chestplate && (id == 299 || id == 303 || id == 307 || id == 311 || id == 315)) {
armorSlot=1;
chestplate=true;
}
 else if (!leggings && (id == 300 || id == 304 || id == 308 || id == 312 || id == 316)) {
armorSlot=2;
leggings=true;
}
 else if (!boots && (id == 301 || id == 305 || id == 309 || id == 313 || id == 317)) {
armorSlot=3;
boots=true;
}
 else if (helmet && chestplate && leggings&& boots) break;
 else continue;
inventory.selectItemAt(i);
inventory.selectArmorAt(armorSlot);
changed=true;
}
if (!changed) {
for (int i=0; i < 36; i++) {
ItemStack item=inventory.getItemAt(i);
if (item != null) continue;
int armorSlot;
if (helmet) {
armorSlot=0;
helmet=false;
}
 else if (chestplate) {
armorSlot=1;
chestplate=false;
}
 else if (leggings) {
armorSlot=2;
leggings=false;
}
 else if (boots) {
armorSlot=3;
boots=false;
}
 else if (!helmet && !chestplate && !leggings&& !boots) break;
 else continue;
inventory.selectArmorAt(armorSlot);
inventory.selectItemAt(i);
}
}
inventory.close();
bot.say(""String_Node_Str"" + owner + ""String_Node_Str"");
}
 else if (message.contains(""String_Node_Str"")) {
String name=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"")[0];
owner=name;
bot.say(""String_Node_Str"" + owner + ""String_Node_Str""+ name);
}
 else if (message.contains(""String_Node_Str"")) {
String[] args=new String[0];
if (message.trim().contains(""String_Node_Str"")) args=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"");
String name=owner;
if (args.length > 0) {
name=args[0];
if (name.equalsIgnoreCase(owner)) {
name=owner;
args=new String[0];
}
}
FollowTask followTask=bot.getTaskManager().getTaskFor(FollowTask.class);
if (followTask.isActive()) followTask.stop();
for (Entity entity : bot.getWorld().getEntities()) {
if (entity instanceof PlayerEntity && Util.stripColors(((PlayerEntity)entity).getName()).equalsIgnoreCase(name)) {
followTask.follow(entity);
bot.say(""String_Node_Str"" + owner + ""String_Node_Str""+ (args.length > 0 ? Util.stripColors(((PlayerEntity)entity).getName()) : ""String_Node_Str"")+ ""String_Node_Str"");
return;
}
}
bot.say(""String_Node_Str"" + owner + ""String_Node_Str""+ name+ ""String_Node_Str"");
}
 else if (message.contains(""String_Node_Str"")) {
String[] args=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"");
String name=args[0];
AttackTask attackTask=bot.getTaskManager().getTaskFor(AttackTask.class);
for (Entity entity : bot.getWorld().getEntities()) {
if (entity instanceof PlayerEntity && Util.stripColors(((PlayerEntity)entity).getName()).equalsIgnoreCase(name)) {
attackTask.setAttackEntity(entity);
bot.say(""String_Node_Str"" + owner + ""String_Node_Str""+ Util.stripColors(((PlayerEntity)entity).getName())+ ""String_Node_Str"");
return;
}
}
bot.say(""String_Node_Str"" + owner + ""String_Node_Str""+ name+ ""String_Node_Str"");
}
 else if (message.contains(""String_Node_Str"")) {
String[] args=message.substring(message.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()).split(""String_Node_Str"");
MainPlayerEntity player=bot.getPlayer();
BlockLocation location=new BlockLocation(player.getLocation());
boolean relativeX=args[0].charAt(0) == '+', relativeZ=args[args.length - 1].charAt(0) == '+';
int x, y, z;
if (relativeX) x=location.getX() + Integer.parseInt(args[0].substring(1));
 else x=Integer.parseInt(args[0]);
if (relativeZ) z=location.getZ() + Integer.parseInt(args[args.length - 1].substring(1));
 else z=Integer.parseInt(args[args.length - 1]);
if (args.length < 3) {
World world=bot.getWorld();
for (y=256; y > 0; y--) {
int id=world.getBlockIdAt(x,y - 1,z);
if (BlockType.getById(id).isSolid()) break;
}
if (y <= 0) {
bot.say(""String_Node_Str"" + owner + ""String_Node_Str"");
return;
}
}
 else y=Integer.parseInt(args[1]);
BlockLocation target=new BlockLocation(x,y,z);
player.getLocation().getDistanceTo(new WorldLocation(target));
bot.setActivity(new WalkActivity(bot,target));
bot.say(""String_Node_Str"" + owner + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ z+ ""String_Node_Str"");
}
 else if (message.contains(""String_Node_Str"")) {
HostileTask task=bot.getTaskManager().getTaskFor(HostileTask.class);
task.start();
bot.say(""String_Node_Str"" + owner + ""String_Node_Str"");
}
}
 else if (message.contains(""String_Node_Str"") && spamMessage != null && createFaction) {
String msg=""String_Node_Str"" + Util.generateRandomString(7 + random.nextInt(4));
bot.say(msg);
}
break;
case 8:
Packet8UpdateHealth updateHealth=(Packet8UpdateHealth)packet;
if (updateHealth.healthMP <= 0) connectionHandler.sendPacket(new Packet205ClientCommand(1));
break;
case 9:
TaskManager taskManager=bot.getTaskManager();
taskManager.stopAll();
bot.setActivity(null);
break;
}
}",0.981062859409082
109376,"private DarkBotMCSpambot(DarkBot darkBot,String server,String username,String password,String sessionId,String loginProxy,String proxy,String owner){
synchronized (bots) {
    bots.add(this);
synchronized (slotsTaken) {
      slotsTaken.notifyAll();
    }
  }
  MinecraftBotData.Builder builder=MinecraftBotData.builder();
  if (proxy != null && !proxy.isEmpty()) {
    int port=80;
    ProxyType type=ProxyType.SOCKS;
    if (proxy.contains(""String_Node_Str"")) {
      String[] parts=proxy.split(""String_Node_Str"");
      proxy=parts[0];
      port=Integer.parseInt(parts[1]);
      if (parts.length > 2)       type=ProxyType.values()[Integer.parseInt(parts[2]) - 1];
    }
    builder.withSocksProxy(new ProxyData(proxy,port,type));
    this.proxy=new Proxy(Proxy.Type.SOCKS,new InetSocketAddress(proxy,port));
  }
  if (loginProxy != null && !loginProxy.isEmpty()) {
    int port=80;
    if (loginProxy.contains(""String_Node_Str"")) {
      String[] parts=loginProxy.split(""String_Node_Str"");
      loginProxy=parts[0];
      port=Integer.parseInt(parts[1]);
    }
    builder.withHttpProxy(new ProxyData(loginProxy,port,ProxyType.HTTP));
    this.loginProxy=new Proxy(Proxy.Type.HTTP,new InetSocketAddress(loginProxy,port));
  }
  builder.withUsername(username);
  if (sessionId != null)   builder.withSessionId(sessionId);
 else   builder.withPassword(password);
  if (server != null && !server.isEmpty()) {
    int port=25565;
    if (server.contains(""String_Node_Str"")) {
      String[] parts=server.split(""String_Node_Str"");
      server=parts[0];
      port=Integer.parseInt(parts[1]);
    }
    builder.withServer(server).withPort(port);
  }
 else   throw new IllegalArgumentException(""String_Node_Str"");
  this.owner=owner;
  MinecraftBotData botData=builder.build();
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.out.println(""String_Node_Str"" + username + ""String_Node_Str"");
  bot=new MinecraftBot(darkBot,botData);
  TaskManager taskManager=bot.getTaskManager();
  taskManager.registerTask(new FallTask(bot));
  taskManager.registerTask(new FollowTask(bot));
  taskManager.registerTask(new DefendTask(bot));
  taskManager.registerTask(new AttackTask(bot));
  taskManager.registerTask(new HostileTask(bot));
  taskManager.registerTask(new EatTask(bot));
  connectionHandler=bot.getConnectionHandler();
  Session session=bot.getSession();
  System.gc();
  System.out.println(""String_Node_Str"" + username + ""String_Node_Str""+ amountJoined.incrementAndGet()+ ""String_Node_Str"");
  bot.getEventManager().registerListener(this);
  bot.getGameHandler().registerListener(this);
  long lastShoutTime=System.currentTimeMillis();
  while (bot.isConnected()) {
  }
synchronized (bots) {
    bots.remove(this);
  }
  amountJoined.decrementAndGet();
  slotsTaken.decrementAndGet();
synchronized (slotsTaken) {
    slotsTaken.notifyAll();
  }
}","private DarkBotMCSpambot(DarkBot darkBot,String server,String username,String password,String sessionId,String loginProxy,String proxy,String owner){
synchronized (bots) {
    bots.add(this);
synchronized (slotsTaken) {
      slotsTaken.notifyAll();
    }
  }
  MinecraftBotData.Builder builder=MinecraftBotData.builder();
  if (proxy != null && !proxy.isEmpty()) {
    int port=80;
    ProxyType type=ProxyType.SOCKS;
    if (proxy.contains(""String_Node_Str"")) {
      String[] parts=proxy.split(""String_Node_Str"");
      proxy=parts[0];
      port=Integer.parseInt(parts[1]);
      if (parts.length > 2)       type=ProxyType.values()[Integer.parseInt(parts[2]) - 1];
    }
    builder.withSocksProxy(new ProxyData(proxy,port,type));
    this.proxy=new Proxy(Proxy.Type.SOCKS,new InetSocketAddress(proxy,port));
  }
  if (loginProxy != null && !loginProxy.isEmpty()) {
    int port=80;
    if (loginProxy.contains(""String_Node_Str"")) {
      String[] parts=loginProxy.split(""String_Node_Str"");
      loginProxy=parts[0];
      port=Integer.parseInt(parts[1]);
    }
    builder.withHttpProxy(new ProxyData(loginProxy,port,ProxyType.HTTP));
    this.loginProxy=new Proxy(Proxy.Type.HTTP,new InetSocketAddress(loginProxy,port));
  }
  builder.withUsername(username);
  if (sessionId != null)   builder.withSessionId(sessionId);
 else   builder.withPassword(password);
  if (server != null && !server.isEmpty()) {
    int port=25565;
    if (server.contains(""String_Node_Str"")) {
      String[] parts=server.split(""String_Node_Str"");
      server=parts[0];
      port=Integer.parseInt(parts[1]);
    }
    builder.withServer(server).withPort(port);
  }
 else   throw new IllegalArgumentException(""String_Node_Str"");
  this.owner=owner;
  MinecraftBotData botData=builder.build();
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.out.println(""String_Node_Str"" + username + ""String_Node_Str"");
  bot=new MinecraftBot(darkBot,botData);
  TaskManager taskManager=bot.getTaskManager();
  taskManager.registerTask(new FallTask(bot));
  taskManager.registerTask(new FollowTask(bot));
  taskManager.registerTask(new DefendTask(bot));
  taskManager.registerTask(new AttackTask(bot));
  taskManager.registerTask(new HostileTask(bot));
  taskManager.registerTask(new EatTask(bot));
  connectionHandler=bot.getConnectionHandler();
  Session session=bot.getSession();
  System.gc();
  System.out.println(""String_Node_Str"" + username + ""String_Node_Str""+ amountJoined.incrementAndGet()+ ""String_Node_Str"");
  bot.getEventManager().registerListener(this);
  long lastShoutTime=System.currentTimeMillis();
  while (bot.isConnected()) {
  }
synchronized (bots) {
    bots.remove(this);
  }
  amountJoined.decrementAndGet();
  slotsTaken.decrementAndGet();
synchronized (slotsTaken) {
    slotsTaken.notifyAll();
  }
}",0.9918951543369546
109377,"@Override public void step(){
  if (isDone())   return;
  heuristic.prioritize(openSet);
  PathNode current=openSet.remove(0);
  if (complete == null && current.getLocation().equals(end)) {
    complete=reconstructPath(current);
    return;
  }
  calculate(current,false);
  heuristic.prioritize(openSetReverse);
  PathNode currentReverse=openSetReverse.remove(0);
  if (completeReverse == null && currentReverse.getLocation().equals(start))   completeReverse=reconstructPath(currentReverse);
 else   if (completeReverse == null)   calculate(currentReverse,true);
}","@Override public void step(){
  if (isDone())   return;
  PathNode current=heuristic.findNext(openSet);
  openSet.remove(current);
  if (complete == null && current.getLocation().equals(end)) {
    complete=reconstructPath(current);
    return;
  }
  calculate(current,false);
  if (completeReverse != null)   return;
  PathNode currentReverse=heuristic.findNext(openSetReverse);
  openSetReverse.remove(current);
  if (completeReverse == null && currentReverse.getLocation().equals(start))   completeReverse=reconstructPath(currentReverse);
 else   if (completeReverse == null)   calculate(currentReverse,true);
}",0.8108566581849025
109378,"@Override public synchronized void run(){
  MainPlayerEntity player=bot.getPlayer();
  if (player == null)   return;
  if (player.getDistanceTo(attackEntity) > 4) {
    BlockLocation location=new BlockLocation((int)attackEntity.getX(),(int)(attackEntity.getY() + 0.5),(int)attackEntity.getZ());
    World world=bot.getWorld();
    BlockLocation original=location;
    BlockLocation below=location.offset(0,-1,0);
    while (!BlockType.getById(world.getBlockIdAt(below)).isSolid() && !world.getPathFinder().getHeuristic().isClimbableBlock(below)) {
      location=below;
      below=below.offset(0,-1,0);
      if (original.getY() - location.getY() >= 5)       return;
    }
    bot.setActivity(new WalkActivity(bot,location,true));
    return;
  }
 else {
    if (attackCooldown > 0) {
      attackCooldown--;
      return;
    }
    ConnectionHandler connectionHandler=bot.getConnectionHandler();
    if (!bot.getTaskManager().getTaskFor(EatTask.class).isActive())     switchToBestSword();
    connectionHandler.sendPacket(new Packet18Animation(player.getId(),Animation.SWING_ARM));
    connectionHandler.sendPacket(new Packet7UseEntity(player.getId(),attackEntity.getId(),1));
    attackCooldown=5;
  }
}","@Override public synchronized void run(){
  MainPlayerEntity player=bot.getPlayer();
  if (player == null)   return;
  if (player.getDistanceTo(attackEntity) > 4) {
    BlockLocation location=new BlockLocation(attackEntity.getLocation());
    World world=bot.getWorld();
    BlockLocation original=location;
    BlockLocation below=location.offset(0,-1,0);
    while (!BlockType.getById(world.getBlockIdAt(below)).isSolid() && !world.getPathFinder().getHeuristic().isClimbableBlock(below)) {
      location=below;
      below=below.offset(0,-1,0);
      if (original.getY() - location.getY() >= 5)       return;
    }
    bot.setActivity(new WalkActivity(bot,location,true));
    return;
  }
 else {
    if (attackCooldown > 0) {
      attackCooldown--;
      return;
    }
    ConnectionHandler connectionHandler=bot.getConnectionHandler();
    if (!bot.getTaskManager().getTaskFor(EatTask.class).isActive())     switchToBestSword();
    connectionHandler.sendPacket(new Packet18Animation(player.getId(),Animation.SWING_ARM));
    connectionHandler.sendPacket(new Packet7UseEntity(player.getId(),attackEntity.getId(),1));
    attackCooldown=5;
  }
}",0.969439728353141
109379,"@Override public synchronized void run(){
  if (eatTask.isActive())   return;
  if (ticksWait > 0) {
    ticksWait--;
    return;
  }
  World world=bot.getWorld();
  MainPlayerEntity player=bot.getPlayer();
  System.out.println(""String_Node_Str"");
  BlockLocation ourLocation=new BlockLocation((int)(Math.round(player.getX() - 0.5)),(int)player.getY(),(int)(Math.round(player.getZ() - 0.5)));
  boolean flip=false;
  for (int y=point1.getY(); y <= point2.getY(); y++) {
    for (int x=Math.min(point1.getX(),point2.getX()); x <= Math.max(point1.getX(),point2.getX()); x++) {
      int z1=Math.min(point1.getZ(),point2.getZ());
      int z2=Math.max(point1.getZ(),point2.getZ());
      if (flip) {
        int temp=z1;
        z1=z2;
        z2=temp;
      }
      for (int z=z1; flip ? z >= z2 : z <= z2; z+=flip ? -1 : 1) {
        if (startCounterLocation != null && startCounterLocation.getX() == x && startCounterLocation.getY() == y && startCounterLocation.getZ() == z)         continue;
        int id=world.getBlockIdAt(x,y,z);
        if (!BlockType.getById(id).isSolid()) {
          BlockLocation location=new BlockLocation(x,y,z);
          if (startCounterLocation != null) {
            System.out.println(ourLocation + ""String_Node_Str"" + location);
            BlockLocation original=location;
            BlockLocation below=location.offset(0,-1,0);
            while (!BlockType.getById(world.getBlockIdAt(below)).isSolid() && !world.getPathFinder().getHeuristic().isClimbableBlock(below)) {
              location=below;
              below=below.offset(0,-1,0);
              if (original.getY() - location.getY() >= 5)               return;
            }
            if (!location.equals(ourLocation)) {
              System.out.println(""String_Node_Str"");
              bot.setActivity(new WalkActivity(bot,location));
              ticksWait=4;
              return;
            }
            int index=player.getInventory().getFirstSlot(blockId);
            if (index == -1) {
              System.out.println(""String_Node_Str"");
              stop();
              return;
            }
            System.out.println(""String_Node_Str"");
            player.switchHeldItems(index);
            player.placeBlock(startCounterLocation);
            startCounterLocation=null;
          }
          startCounterLocation=location;
        }
      }
      flip=!flip;
    }
  }
}","@Override public synchronized void run(){
  if (eatTask.isActive())   return;
  if (ticksWait > 0) {
    ticksWait--;
    return;
  }
  World world=bot.getWorld();
  MainPlayerEntity player=bot.getPlayer();
  System.out.println(""String_Node_Str"");
  BlockLocation ourLocation=new BlockLocation(player.getLocation());
  boolean flip=false;
  for (int y=point1.getY(); y <= point2.getY(); y++) {
    for (int x=Math.min(point1.getX(),point2.getX()); x <= Math.max(point1.getX(),point2.getX()); x++) {
      int z1=Math.min(point1.getZ(),point2.getZ());
      int z2=Math.max(point1.getZ(),point2.getZ());
      if (flip) {
        int temp=z1;
        z1=z2;
        z2=temp;
      }
      for (int z=z1; flip ? z >= z2 : z <= z2; z+=flip ? -1 : 1) {
        if (startCounterLocation != null && startCounterLocation.getX() == x && startCounterLocation.getY() == y && startCounterLocation.getZ() == z)         continue;
        int id=world.getBlockIdAt(x,y,z);
        if (!BlockType.getById(id).isSolid()) {
          BlockLocation location=new BlockLocation(x,y,z);
          if (startCounterLocation != null) {
            System.out.println(ourLocation + ""String_Node_Str"" + location);
            BlockLocation original=location;
            BlockLocation below=location.offset(0,-1,0);
            while (!BlockType.getById(world.getBlockIdAt(below)).isSolid() && !world.getPathFinder().getHeuristic().isClimbableBlock(below)) {
              location=below;
              below=below.offset(0,-1,0);
              if (original.getY() - location.getY() >= 5)               return;
            }
            if (!location.equals(ourLocation)) {
              System.out.println(""String_Node_Str"");
              bot.setActivity(new WalkActivity(bot,location));
              ticksWait=4;
              return;
            }
            int index=player.getInventory().getFirstSlot(blockId);
            if (index == -1) {
              System.out.println(""String_Node_Str"");
              stop();
              return;
            }
            System.out.println(""String_Node_Str"");
            player.switchHeldItems(index);
            player.placeBlock(startCounterLocation);
            startCounterLocation=null;
          }
          startCounterLocation=location;
        }
      }
      flip=!flip;
    }
  }
}",0.9758474576271188
109380,"@Override public void perform(GraphRewrite event,EvaluationContext context,JavaTypeReferenceModel payload){
  List<JavaClassModel> classes=payload.getFile().getJavaClasses();
  classes.forEach(classModel -> {
    GraphService<EjbMessageDrivenModel> ejbMessageDrivenService=new GraphService<>(event.getGraphContext(),EjbMessageDrivenModel.class);
    Iterable<EjbMessageDrivenModel> messageDrivenModels=ejbMessageDrivenService.findAllByProperty(EjbMessageDrivenModel.EJB_IMPLEMENTATION_CLASS,classModel.getClassName(),true);
    if (messageDrivenModels.iterator().hasNext())     return;
    EjbMessageDrivenModel messageDrivenModel=ejbMessageDrivenService.create();
    messageDrivenModel.setApplications(payload.getFile().getApplications());
    messageDrivenModel.setEjbClass(classModel);
  }
);
}","@Override public void perform(GraphRewrite event,EvaluationContext context,JavaTypeReferenceModel payload){
  List<JavaClassModel> classes=payload.getFile().getJavaClasses();
  classes.forEach(classModel -> {
    GraphService<EjbMessageDrivenModel> ejbMessageDrivenService=new GraphService<>(event.getGraphContext(),EjbMessageDrivenModel.class);
    Iterable<EjbMessageDrivenModel> messageDrivenModels=findByClass(event.getGraphContext(),EjbMessageDrivenModel.EJB_IMPLEMENTATION_CLASS,classModel,EjbMessageDrivenModel.class);
    if (messageDrivenModels.iterator().hasNext())     return;
    EjbMessageDrivenModel messageDrivenModel=ejbMessageDrivenService.create();
    messageDrivenModel.setApplications(payload.getFile().getApplications());
    messageDrivenModel.setEjbClass(classModel);
  }
);
}",0.5982478097622027
109381,"@Override public Configuration getConfiguration(RuleLoaderContext ruleLoaderContext){
  return ConfigurationBuilder.begin().addRule().when(Query.fromType(XmlFileModel.class).withProperty(XmlFileModel.ROOT_TAG_NAME,""String_Node_Str"")).perform(new AbstractIterationOperation<XmlFileModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    XmlFileModel payload){
      try {
        Document doc=new XmlFileService(event.getGraphContext()).loadDocument(event,context,payload);
        extractMetadata(event,context,payload,doc);
      }
 catch (      Exception ex) {
        payload.setParseError(""String_Node_Str"" + ex.getMessage());
      }
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.IMPLEMENTS_TYPE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbEntityBeanModel> ejbEntityService=new GraphService<>(event.getGraphContext(),EjbEntityBeanModel.class);
        Iterable<EjbEntityBeanModel> entityBeanModels=ejbEntityService.findAllByProperty(EjbEntityBeanModel.EJB_IMPLEMENTATION_CLASS,classModel.getClassName(),true);
        if (entityBeanModels.iterator().hasNext())         return;
        EjbEntityBeanModel entity=ejbEntityService.create();
        entity.setApplications(payload.getFile().getApplications());
        entity.setEjbClass(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.INHERITANCE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=ejbSessionService.findAllByProperty(EjbEntityBeanModel.EJB_HOME,classModel.getClassName(),true);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbHome(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.INHERITANCE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=ejbSessionService.findAllByProperty(EjbEntityBeanModel.EJB_REMOTE,classModel.getClassName(),true);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbRemote(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.IMPLEMENTS_TYPE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=ejbSessionService.findAllByProperty(EjbEntityBeanModel.EJB_IMPLEMENTATION_CLASS,classModel.getClassName(),true);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbClass(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.INHERITANCE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=ejbSessionService.findAllByProperty(EjbEntityBeanModel.EJB_LOCAL_HOME,classModel.getClassName(),true);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbLocalHome(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.INHERITANCE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=ejbSessionService.findAllByProperty(EjbEntityBeanModel.EJB_LOCAL,classModel.getClassName(),true);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbLocal(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.IMPLEMENTS_TYPE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbMessageDrivenModel> ejbMessageDrivenService=new GraphService<>(event.getGraphContext(),EjbMessageDrivenModel.class);
        Iterable<EjbMessageDrivenModel> messageDrivenModels=ejbMessageDrivenService.findAllByProperty(EjbMessageDrivenModel.EJB_IMPLEMENTATION_CLASS,classModel.getClassName(),true);
        if (messageDrivenModels.iterator().hasNext())         return;
        EjbMessageDrivenModel messageDrivenModel=ejbMessageDrivenService.create();
        messageDrivenModel.setApplications(payload.getFile().getApplications());
        messageDrivenModel.setEjbClass(classModel);
      }
);
    }
  }
);
}","@Override public Configuration getConfiguration(RuleLoaderContext ruleLoaderContext){
  return ConfigurationBuilder.begin().addRule().when(Query.fromType(XmlFileModel.class).withProperty(XmlFileModel.ROOT_TAG_NAME,""String_Node_Str"")).perform(new AbstractIterationOperation<XmlFileModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    XmlFileModel payload){
      try {
        Document doc=new XmlFileService(event.getGraphContext()).loadDocument(event,context,payload);
        extractMetadata(event,context,payload,doc);
      }
 catch (      Exception ex) {
        payload.setParseError(""String_Node_Str"" + ex.getMessage());
      }
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.IMPLEMENTS_TYPE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbEntityBeanModel> ejbEntityService=new GraphService<>(event.getGraphContext(),EjbEntityBeanModel.class);
        Iterable<EjbEntityBeanModel> entityBeanModels=findByClass(event.getGraphContext(),EjbEntityBeanModel.EJB_IMPLEMENTATION_CLASS,classModel,EjbEntityBeanModel.class);
        if (entityBeanModels.iterator().hasNext())         return;
        EjbEntityBeanModel entity=ejbEntityService.create();
        entity.setApplications(payload.getFile().getApplications());
        entity.setEjbClass(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.INHERITANCE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=findByClass(event.getGraphContext(),EjbSessionBeanModel.EJB_HOME,classModel,EjbSessionBeanModel.class);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbHome(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.INHERITANCE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=findByClass(event.getGraphContext(),EjbSessionBeanModel.EJB_REMOTE,classModel,EjbSessionBeanModel.class);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbRemote(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.IMPLEMENTS_TYPE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=findByClass(event.getGraphContext(),EjbSessionBeanModel.EJB_IMPLEMENTATION_CLASS,classModel,EjbSessionBeanModel.class);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbClass(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.INHERITANCE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=findByClass(event.getGraphContext(),EjbSessionBeanModel.EJB_LOCAL_HOME,classModel,EjbSessionBeanModel.class);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbLocalHome(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.INHERITANCE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbSessionBeanModel> ejbSessionService=new GraphService<>(event.getGraphContext(),EjbSessionBeanModel.class);
        Iterable<EjbSessionBeanModel> sessionModels=findByClass(event.getGraphContext(),EjbSessionBeanModel.EJB_LOCAL,classModel,EjbSessionBeanModel.class);
        if (sessionModels.iterator().hasNext())         return;
        EjbSessionBeanModel sessionBeanModel=ejbSessionService.create();
        sessionBeanModel.setApplications(payload.getFile().getApplications());
        sessionBeanModel.setEjbLocal(classModel);
      }
);
    }
  }
).addRule().when(JavaClass.references(""String_Node_Str"").at(TypeReferenceLocation.IMPLEMENTS_TYPE)).perform(new AbstractIterationOperation<JavaTypeReferenceModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    JavaTypeReferenceModel payload){
      List<JavaClassModel> classes=payload.getFile().getJavaClasses();
      classes.forEach(classModel -> {
        GraphService<EjbMessageDrivenModel> ejbMessageDrivenService=new GraphService<>(event.getGraphContext(),EjbMessageDrivenModel.class);
        Iterable<EjbMessageDrivenModel> messageDrivenModels=findByClass(event.getGraphContext(),EjbMessageDrivenModel.EJB_IMPLEMENTATION_CLASS,classModel,EjbMessageDrivenModel.class);
        if (messageDrivenModels.iterator().hasNext())         return;
        EjbMessageDrivenModel messageDrivenModel=ejbMessageDrivenService.create();
        messageDrivenModel.setApplications(payload.getFile().getApplications());
        messageDrivenModel.setEjbClass(classModel);
      }
);
    }
  }
);
}",0.9087172688100762
109382,"protected Map<ProjectModel,Map<String,Integer>> countFilesBySuffix(){
  Map<ProjectModel,Map<String,Integer>> result=new HashMap<>();
  Iterable<FileModel> files=this.getGraphContext().getQuery().type(FileModel.class).hasNot(FileModel.IS_DIRECTORY,true).vertices(FileModel.class);
  StreamSupport.stream(files.spliterator(),false).forEach((  FileModel file) -> {
    String suffix=StringUtils.substringAfterLast(file.getFileName(),""String_Node_Str"");
    if (suffix.isEmpty()) {
      return;
    }
    ProjectModel projectModel=file.getProjectModel();
    ProjectModel rootProjectModel=projectModel.getRootProjectModel();
    Map<String,Integer> suffixToCount;
    if (rootProjectModel == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      if (!result.containsKey(rootProjectModel)) {
        result.put(rootProjectModel,new HashMap<>());
      }
      suffixToCount=result.get(rootProjectModel);
    }
    Integer val=suffixToCount.get(suffix);
    if (val == null) {
      suffixToCount.put(suffix,1);
    }
 else {
      suffixToCount.put(suffix,val + 1);
    }
  }
);
  return result;
}","public Map<ProjectModel,Map<String,Integer>> countFilesBySuffix(){
  Map<ProjectModel,Map<String,Integer>> result=new HashMap<>();
  Iterable<FileModel> files=this.getGraphContext().getQuery().type(FileModel.class).hasNot(FileModel.IS_DIRECTORY,true).vertices(FileModel.class);
  StreamSupport.stream(files.spliterator(),false).forEach((  FileModel file) -> {
    String suffix=StringUtils.substringAfterLast(file.getFileName(),""String_Node_Str"");
    if (suffix.isEmpty() || file.isWindupGenerated()) {
      return;
    }
    ProjectModel projectModel=file.getProjectModel();
    ProjectModel rootProjectModel=projectModel.getRootProjectModel();
    Map<String,Integer> suffixToCount;
    if (rootProjectModel == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      if (!result.containsKey(rootProjectModel)) {
        result.put(rootProjectModel,new HashMap<>());
      }
      suffixToCount=result.get(rootProjectModel);
    }
    Integer val=suffixToCount.get(suffix);
    if (val == null) {
      suffixToCount.put(suffix,1);
    }
 else {
      suffixToCount.put(suffix,val + 1);
    }
  }
);
  return result;
}",0.9819144243493604
109383,"@Override public boolean belongsToProject(ProjectModel projectModel){
  return this.getClassFile().belongsToProject(projectModel);
}","@Override public boolean belongsToProject(ProjectModel projectModel){
  FileModel classFile=this.getClassFile();
  if (classFile == null) {
    String name=this.getClassName();
    String aPackage=this.getPackageName();
    Logger.getLogger(JavaClassModel.class.getName()).warning(""String_Node_Str"");
    return false;
  }
  return this.getClassFile().belongsToProject(projectModel);
}",0.4874274661508704
109384,"@Override public Iterable<ProjectModel> getRootProjectModels(){
  return this.getClassFile().getRootProjectModels();
}","@Override public Iterable<ProjectModel> getRootProjectModels(){
  FileModel classFile=this.getClassFile();
  if (classFile == null) {
    String name=this.getClassName();
    String aPackage=this.getPackageName();
    JavaSourceFileModel originalSource=this.getOriginalSource();
    Logger.getLogger(JavaClassModel.class.getName()).warning(""String_Node_Str"");
    return Collections.emptyList();
  }
  return this.getClassFile().getRootProjectModels();
}",0.3881118881118881
109385,"/** 
 * Associates a Set of ProjectModels with this index. This allows us to get from any Project Model to the associated index. NOTE: This should generally include the projectmodel and all child projects (flattened) to make searching easier.
 */
@Adjacency(label=APPLICATION_REPORT_INDEX_TO_PROJECT_MODEL,direction=Direction.OUT) public void addProjectModel(ProjectModel projectModel);","/** 
 * Associates a Set of ProjectModels with this index. This allows us to get from any Project Model to the associated index. NOTE: This should generally include the projectmodel and all child projects (flattened) to make searching easier.
 */
@Adjacency(label=APPLICATION_REPORT_INDEX_TO_PROJECT_MODEL,direction=Direction.OUT) void addProjectModel(ProjectModel projectModel);",0.9908496732026144
109386,"/** 
 * Adds a ReportModel that should be displayed in the index
 */
@Adjacency(label=APPLICATION_REPORT_INDEX_TO_REPORT_MODEL,direction=Direction.OUT) public void addApplicationReportModel(ApplicationReportModel reportModel);","/** 
 * Adds a ReportModel that should be displayed in the index
 */
@Adjacency(label=APPLICATION_REPORT_INDEX_TO_REPORT_MODEL,direction=Direction.OUT) void addApplicationReportModel(ApplicationReportModel reportModel);",0.9842696629213484
109387,"/** 
 * Get all ReportModels that should be displayed in the index
 */
@Adjacency(label=APPLICATION_REPORT_INDEX_TO_REPORT_MODEL,direction=Direction.OUT) public Iterable<ApplicationReportModel> getApplicationReportModels();","/** 
 * Get all ReportModels that should be displayed in the index
 */
@Adjacency(label=APPLICATION_REPORT_INDEX_TO_REPORT_MODEL,direction=Direction.OUT) Iterable<ApplicationReportModel> getApplicationReportModels();",0.9840546697038725
109388,"/** 
 * Associates a Set of ProjectModels with this index. This allows us to get from any Project Model to the associated index. NOTE: This should generally include the projectmodel and all child projects (flattened) to make searching easier.
 */
@Adjacency(label=APPLICATION_REPORT_INDEX_TO_PROJECT_MODEL,direction=Direction.OUT) public Iterable<ProjectModel> getProjectModels();","/** 
 * Associates a Set of ProjectModels with this index. This allows us to get from any Project Model to the associated index. NOTE: This should generally include the projectmodel and all child projects (flattened) to make searching easier.
 */
@Adjacency(label=APPLICATION_REPORT_INDEX_TO_PROJECT_MODEL,direction=Direction.OUT) Iterable<ProjectModel> getProjectModels();",0.9907038512616202
109389,"@Override public Object exec(List arguments) throws TemplateModelException {
  if (arguments.size() == 0)   throw new TemplateModelException(""String_Node_Str"" + NAME + ""String_Node_Str"");
  final GraphRewrite event=(GraphRewrite)((StringModel)arguments.get(0)).getWrappedObject();
  final ProjectModel projectModel;
  StringModel projectModelArg=(StringModel)arguments.get(1);
  if (projectModelArg == null)   projectModel=null;
 else   projectModel=(ProjectModel)projectModelArg.getWrappedObject();
  Set<String> includeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(2));
  Set<String> excludeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(3));
  Set<ProjectModel> projectModels=getProjects(projectModel);
  Map<IssueCategoryModel,List<ProblemSummary>> problemSummariesOriginal=ProblemSummaryService.getProblemSummaries(event,projectModels,includeTags,excludeTags);
  Comparator<IssueCategoryModel> severityComparator=new IssueCategoryModel.IssueSummaryPriorityComparator();
  Map<IssueCategoryModel,List<ProblemSummary>> problemSummaries=new TreeMap<>(severityComparator);
  problemSummaries.putAll(problemSummariesOriginal);
  Map<String,List<ProblemSummary>> primarySummariesByString=new LinkedHashMap<>(problemSummariesOriginal.size());
  for (  Map.Entry<IssueCategoryModel,List<ProblemSummary>> entry : problemSummaries.entrySet()) {
    String severityString=entry.getKey() == null ? null : entry.getKey().getName();
    primarySummariesByString.put(severityString,entry.getValue());
  }
  return primarySummariesByString;
}","@Override public Object exec(List arguments) throws TemplateModelException {
  if (arguments.size() == 0)   throw new TemplateModelException(""String_Node_Str"" + NAME + ""String_Node_Str"");
  final GraphRewrite event=(GraphRewrite)((StringModel)arguments.get(0)).getWrappedObject();
  final ProjectModel projectModel;
  StringModel projectModelArg=(StringModel)arguments.get(1);
  if (projectModelArg == null)   projectModel=null;
 else   projectModel=(ProjectModel)projectModelArg.getWrappedObject();
  Set<String> includeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(2));
  Set<String> excludeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(3));
  Set<ProjectModel> projectModels=getProjects(projectModel);
  Map<IssueCategoryModel,List<ProblemSummary>> problemSummariesOriginal=ProblemSummaryService.getProblemSummaries(event.getGraphContext(),projectModels,includeTags,excludeTags);
  Comparator<IssueCategoryModel> severityComparator=new IssueCategoryModel.IssueSummaryPriorityComparator();
  Map<IssueCategoryModel,List<ProblemSummary>> problemSummaries=new TreeMap<>(severityComparator);
  problemSummaries.putAll(problemSummariesOriginal);
  Map<String,List<ProblemSummary>> primarySummariesByString=new LinkedHashMap<>(problemSummariesOriginal.size());
  for (  Map.Entry<IssueCategoryModel,List<ProblemSummary>> entry : problemSummaries.entrySet()) {
    String severityString=entry.getKey() == null ? null : entry.getKey().getName();
    primarySummariesByString.put(severityString,entry.getValue());
  }
  return primarySummariesByString;
}",0.994328922495274
109390,"/** 
 * Gets lists of   {@link ProblemSummary} objects organized by {@link IssueCategoryModel}.
 */
public static Map<IssueCategoryModel,List<ProblemSummary>> getProblemSummaries(GraphRewrite event,Set<ProjectModel> projectModels,Set<String> includeTags,Set<String> excludeTags){
  Map<IssueCategoryModel,List<ProblemSummary>> results=new TreeMap<>(new IssueCategoryModel.IssueSummaryPriorityComparator());
  Map<RuleSummaryKey,ProblemSummary> ruleToSummary=new HashMap<>();
  InlineHintService hintService=new InlineHintService(event.getGraphContext());
  final Iterable<InlineHintModel> hints=projectModels == null ? hintService.findAll() : hintService.getHintsForProjects(projectModels);
  for (  InlineHintModel hint : hints) {
    Set<String> tags=hint.getTags();
    if (!TagUtil.checkMatchingTags(tags,includeTags,excludeTags,false))     continue;
    RuleSummaryKey key=new RuleSummaryKey(hint.getEffort(),hint.getRuleID(),hint.getTitle());
    ProblemSummary summary=ruleToSummary.get(key);
    if (summary == null) {
      summary=new ProblemSummary(UUID.randomUUID().toString(),hint.getIssueCategory(),hint.getRuleID(),hint.getTitle(),1,hint.getEffort());
      for (      LinkModel link : hint.getLinks()) {
        summary.addLink(link.getDescription(),link.getLink());
      }
      ruleToSummary.put(key,summary);
      addToResults(results,summary);
    }
 else {
      summary.setNumberFound(summary.getNumberFound() + 1);
    }
    summary.addFile(hint.getHint(),hint.getFile());
  }
  ClassificationService classificationService=new ClassificationService(event.getGraphContext());
  for (  ClassificationModel classification : classificationService.findAll()) {
    Set<String> tags=classification.getTags();
    if (!TagUtil.checkMatchingTags(tags,includeTags,excludeTags,false))     continue;
    List<FileModel> newFileModels=new ArrayList<>();
    for (    FileModel file : classification.getFileModels()) {
      if (projectModels != null) {
        if (!projectModels.contains(file.getProjectModel()))         continue;
      }
      newFileModels.add(file);
    }
    if (newFileModels.isEmpty())     continue;
    RuleSummaryKey key=new RuleSummaryKey(classification.getEffort(),classification.getRuleID(),classification.getClassification());
    ProblemSummary summary=ruleToSummary.get(key);
    if (summary == null) {
      summary=new ProblemSummary(UUID.randomUUID().toString(),classification.getIssueCategory(),classification.getRuleID(),classification.getClassification(),0,classification.getEffort());
      for (      LinkModel link : classification.getLinks()) {
        summary.addLink(link.getDescription(),link.getLink());
      }
      ruleToSummary.put(key,summary);
      addToResults(results,summary);
    }
    for (    FileModel file : newFileModels)     summary.addFile(classification.getDescription(),file);
    summary.setNumberFound(summary.getNumberFound() + newFileModels.size());
  }
  return results;
}","/** 
 * Gets lists of   {@link ProblemSummary} objects organized by {@link IssueCategoryModel}.
 */
public static Map<IssueCategoryModel,List<ProblemSummary>> getProblemSummaries(GraphContext graphContext,Set<ProjectModel> projectModels,Set<String> includeTags,Set<String> excludeTags){
  Map<IssueCategoryModel,List<ProblemSummary>> results=new TreeMap<>(new IssueCategoryModel.IssueSummaryPriorityComparator());
  Map<RuleSummaryKey,ProblemSummary> ruleToSummary=new HashMap<>();
  InlineHintService hintService=new InlineHintService(graphContext);
  final Iterable<InlineHintModel> hints=projectModels == null ? hintService.findAll() : hintService.getHintsForProjects(projectModels);
  for (  InlineHintModel hint : hints) {
    Set<String> tags=hint.getTags();
    if (!TagUtil.checkMatchingTags(tags,includeTags,excludeTags,false))     continue;
    RuleSummaryKey key=new RuleSummaryKey(hint.getEffort(),hint.getRuleID(),hint.getTitle());
    ProblemSummary summary=ruleToSummary.get(key);
    if (summary == null) {
      summary=new ProblemSummary(UUID.randomUUID().toString(),hint.getIssueCategory(),hint.getRuleID(),hint.getTitle(),1,hint.getEffort());
      for (      LinkModel link : hint.getLinks()) {
        summary.addLink(link.getDescription(),link.getLink());
      }
      ruleToSummary.put(key,summary);
      addToResults(results,summary);
    }
 else {
      summary.setNumberFound(summary.getNumberFound() + 1);
    }
    summary.addFile(hint.getHint(),hint.getFile());
  }
  ClassificationService classificationService=new ClassificationService(graphContext);
  for (  ClassificationModel classification : classificationService.findAll()) {
    Set<String> tags=classification.getTags();
    if (!TagUtil.checkMatchingTags(tags,includeTags,excludeTags,false))     continue;
    List<FileModel> newFileModels=new ArrayList<>();
    for (    FileModel file : classification.getFileModels()) {
      if (projectModels != null) {
        if (!projectModels.contains(file.getProjectModel()))         continue;
      }
      newFileModels.add(file);
    }
    if (newFileModels.isEmpty())     continue;
    RuleSummaryKey key=new RuleSummaryKey(classification.getEffort(),classification.getRuleID(),classification.getClassification());
    ProblemSummary summary=ruleToSummary.get(key);
    if (summary == null) {
      summary=new ProblemSummary(UUID.randomUUID().toString(),classification.getIssueCategory(),classification.getRuleID(),classification.getClassification(),0,classification.getEffort());
      for (      LinkModel link : classification.getLinks()) {
        summary.addLink(link.getDescription(),link.getLink());
      }
      ruleToSummary.put(key,summary);
      addToResults(results,summary);
    }
    for (    FileModel file : newFileModels)     summary.addFile(classification.getDescription(),file);
    summary.setNumberFound(summary.getNumberFound() + newFileModels.size());
  }
  return results;
}",0.990334068170256
109391,"private void generateDataSummary(GraphRewrite event){
  ReportService reportService=new ReportService(event.getGraphContext());
  try {
    Path dataDirectory=reportService.getReportDataDirectory();
    Path issueSummaryJSPath=dataDirectory.resolve(ISSUE_SUMMARIES_JS);
    try (FileWriter issueSummaryWriter=new FileWriter(issueSummaryJSPath.toFile())){
      WindupConfigurationModel windupConfiguration=WindupConfigurationService.getConfigurationModel(event.getGraphContext());
      issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
      for (      FileModel inputApplicationFile : windupConfiguration.getInputPaths()) {
        ProjectModel inputApplication=inputApplicationFile.getProjectModel();
        ProjectModelTraversal projectModelTraversal=new ProjectModelTraversal(inputApplication,new OnlyOnceTraversalStrategy());
        MappingJsonFactory jsonFactory=new MappingJsonFactory();
        jsonFactory.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);
        ObjectMapper objectMapper=new ObjectMapper(jsonFactory);
        Map<String,List<ProblemSummary>> summariesBySeverity=ProblemSummaryService.getProblemSummaries(event,projectModelTraversal.getAllProjects(true),Collections.emptySet(),Collections.emptySet()).entrySet().stream().collect(Collectors.toMap((e) -> e.getKey().getName(),Map.Entry::getValue));
        issueSummaryWriter.write(""String_Node_Str"" + inputApplication.asVertex().getId() + ""String_Node_Str"");
        objectMapper.writeValue(issueSummaryWriter,summariesBySeverity);
        issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
      }
      issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
      for (      EffortReportService.EffortLevel level : EffortReportService.EffortLevel.values()) {
        issueSummaryWriter.write(""String_Node_Str"" + level.getPoints() + ""String_Node_Str""+ level.getShortDescription()+ ""String_Node_Str"");
        issueSummaryWriter.write(NEWLINE);
      }
      issueSummaryWriter.write(""String_Node_Str"");
      String comma=""String_Node_Str"";
      for (      EffortLevel level : EffortLevel.values()) {
        issueSummaryWriter.write(comma);
        comma=""String_Node_Str"";
        issueSummaryWriter.write(""String_Node_Str"");
        issueSummaryWriter.write(level.getShortDescription());
        issueSummaryWriter.write(""String_Node_Str"");
      }
      issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
      issueSummaryWriter.write(""String_Node_Str"");
      IssueCategoryRegistry issueCategoryRegistry=IssueCategoryRegistry.instance(event.getRewriteContext());
      for (      IssueCategory issueCategory : issueCategoryRegistry.getIssueCategories()) {
        issueSummaryWriter.write(""String_Node_Str"" + issueCategory.getName() + ""String_Node_Str"");
      }
      issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
    }
   }
 catch (  Exception e) {
    throw new WindupException(""String_Node_Str"" + e.getMessage(),e);
  }
}","private void generateDataSummary(GraphRewrite event){
  ReportService reportService=new ReportService(event.getGraphContext());
  try {
    Path dataDirectory=reportService.getReportDataDirectory();
    Path issueSummaryJSPath=dataDirectory.resolve(ISSUE_SUMMARIES_JS);
    try (FileWriter issueSummaryWriter=new FileWriter(issueSummaryJSPath.toFile())){
      WindupConfigurationModel windupConfiguration=WindupConfigurationService.getConfigurationModel(event.getGraphContext());
      issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
      for (      FileModel inputApplicationFile : windupConfiguration.getInputPaths()) {
        ProjectModel inputApplication=inputApplicationFile.getProjectModel();
        ProjectModelTraversal projectModelTraversal=new ProjectModelTraversal(inputApplication,new OnlyOnceTraversalStrategy());
        MappingJsonFactory jsonFactory=new MappingJsonFactory();
        jsonFactory.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);
        ObjectMapper objectMapper=new ObjectMapper(jsonFactory);
        Map<String,List<ProblemSummary>> summariesBySeverity=ProblemSummaryService.getProblemSummaries(event.getGraphContext(),projectModelTraversal.getAllProjects(true),Collections.emptySet(),Collections.emptySet()).entrySet().stream().collect(Collectors.toMap((e) -> e.getKey().getName(),Map.Entry::getValue));
        issueSummaryWriter.write(""String_Node_Str"" + inputApplication.asVertex().getId() + ""String_Node_Str"");
        objectMapper.writeValue(issueSummaryWriter,summariesBySeverity);
        issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
      }
      issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
      for (      EffortReportService.EffortLevel level : EffortReportService.EffortLevel.values()) {
        issueSummaryWriter.write(""String_Node_Str"" + level.getPoints() + ""String_Node_Str""+ level.getShortDescription()+ ""String_Node_Str"");
        issueSummaryWriter.write(NEWLINE);
      }
      issueSummaryWriter.write(""String_Node_Str"");
      String comma=""String_Node_Str"";
      for (      EffortLevel level : EffortLevel.values()) {
        issueSummaryWriter.write(comma);
        comma=""String_Node_Str"";
        issueSummaryWriter.write(""String_Node_Str"");
        issueSummaryWriter.write(level.getShortDescription());
        issueSummaryWriter.write(""String_Node_Str"");
      }
      issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
      issueSummaryWriter.write(""String_Node_Str"");
      IssueCategoryRegistry issueCategoryRegistry=IssueCategoryRegistry.instance(event.getRewriteContext());
      for (      IssueCategory issueCategory : issueCategoryRegistry.getIssueCategories()) {
        issueSummaryWriter.write(""String_Node_Str"" + issueCategory.getName() + ""String_Node_Str"");
      }
      issueSummaryWriter.write(""String_Node_Str"" + NEWLINE);
    }
   }
 catch (  Exception e) {
    throw new WindupException(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.9969429347826086
109392,"public void start(FramedGraph<EventGraph<TitanGraph>> graph){
  try (PrintWriter out=new PrintWriter(""String_Node_Str"")){
    String path=getClass().getResource(""String_Node_Str"").getPath();
    if (path.contains(""String_Node_Str"")) {
      path=path.split(""String_Node_Str"")[0];
    }
    if (path.contains(""String_Node_Str"")) {
      path=path.split(""String_Node_Str"")[1];
    }
    if (path.endsWith(""String_Node_Str"")) {
      File rexsterAddonDir=new File(path);
      new File(rexsterExtractDirectory).mkdirs();
      extractZipFile(rexsterAddonDir,rexsterExtractDirectory);
    }
 else {
      String substring=path.substring(0,path.length() - 8);
      rexsterExtractDirectory=substring;
    }
    out.println(createRexsterXmlFileString(configuration));
    out.flush();
    RexsterProperties properties=new RexsterProperties(""String_Node_Str"");
    configureScriptEngine(properties);
    rexsterServer=new HttpRexsterServer(properties);
    rexsterServer.start(new DefaultRexsterApplication(""String_Node_Str"",graph.getBaseGraph()));
    rexPro=new RexProRexsterServer(properties,true);
    rexPro.start(new DefaultRexsterApplication(""String_Node_Str"",graph));
    started=true;
  }
 catch (  FileNotFoundException e) {
    log.warning(""String_Node_Str"");
  }
catch (  Exception e) {
    log.warning(""String_Node_Str"");
  }
}","public void start(FramedGraph<EventGraph<TitanGraph>> graph){
  try (PrintWriter out=new PrintWriter(""String_Node_Str"")){
    String path=getClass().getResource(""String_Node_Str"").getPath();
    if (path.contains(""String_Node_Str"")) {
      path=path.split(""String_Node_Str"")[0];
    }
    if (path.contains(""String_Node_Str"")) {
      path=path.split(""String_Node_Str"")[1];
    }
    if (path.endsWith(""String_Node_Str"")) {
      File rexsterAddonDir=new File(path);
      new File(rexsterExtractDirectory).mkdirs();
      extractJarFile(rexsterAddonDir,rexsterExtractDirectory);
    }
 else {
      String substring=path.substring(0,path.length() - 8);
      rexsterExtractDirectory=substring;
    }
    out.println(createRexsterXmlFileString(configuration));
    out.flush();
    RexsterProperties properties=new RexsterProperties(""String_Node_Str"");
    configureScriptEngine(properties);
    rexsterServer=new HttpRexsterServer(properties);
    rexsterServer.start(new DefaultRexsterApplication(""String_Node_Str"",graph.getBaseGraph()));
    rexPro=new RexProRexsterServer(properties,true);
    rexPro.start(new DefaultRexsterApplication(""String_Node_Str"",graph));
    started=true;
  }
 catch (  Exception e) {
    log.severe(""String_Node_Str"" + e.getLocalizedMessage());
    e.printStackTrace();
  }
}",0.9151515151515152
109393,"@Override public Object exec(@SuppressWarnings(""String_Node_Str"") List arguments) throws TemplateModelException {
  ExecutionStatistics.get().begin(NAME);
  if (arguments.size() < 2) {
    throw new TemplateModelException(""String_Node_Str"");
  }
  StringModel projectModelTraversalArg=(StringModel)arguments.get(0);
  ProjectModelTraversal traversal=(ProjectModelTraversal)projectModelTraversalArg.getWrappedObject();
  TemplateBooleanModel recursiveBooleanModel=(TemplateBooleanModel)arguments.get(1);
  boolean recursive=recursiveBooleanModel.getAsBoolean();
  Set<String> includeTags=Collections.emptySet();
  if (arguments.size() >= 3) {
    includeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(2));
  }
  Set<String> excludeTags=Collections.emptySet();
  if (arguments.size() >= 4) {
    excludeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(3));
  }
  traversal.reset();
  Map<Severity,Integer> classificationEffortDetails=classificationService.getMigrationEffortBySeverity(traversal,includeTags,excludeTags,recursive);
  traversal.reset();
  Map<Severity,Integer> hintEffortDetails=inlineHintService.getMigrationEffortBySeverity(traversal,includeTags,excludeTags,recursive);
  Map<String,Integer> results=new HashMap<>(classificationEffortDetails.size() + hintEffortDetails.size());
  addAllIncidents(results,classificationEffortDetails);
  addAllIncidents(results,hintEffortDetails);
  ExecutionStatistics.get().end(NAME);
  return results;
}","@Override public Object exec(@SuppressWarnings(""String_Node_Str"") List arguments) throws TemplateModelException {
  ExecutionStatistics.get().begin(NAME);
  if (arguments.size() < 2) {
    throw new TemplateModelException(""String_Node_Str"");
  }
  StringModel projectModelTraversalArg=(StringModel)arguments.get(0);
  ProjectModelTraversal traversal=(ProjectModelTraversal)projectModelTraversalArg.getWrappedObject();
  TemplateBooleanModel recursiveBooleanModel=(TemplateBooleanModel)arguments.get(1);
  boolean recursive=recursiveBooleanModel.getAsBoolean();
  Set<String> includeTags=Collections.emptySet();
  if (arguments.size() >= 3) {
    includeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(2));
  }
  Set<String> excludeTags=Collections.emptySet();
  if (arguments.size() >= 4) {
    excludeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(3));
  }
  Map<Severity,Integer> classificationEffortDetails=classificationService.getMigrationEffortBySeverity(traversal,includeTags,excludeTags,recursive);
  Map<Severity,Integer> hintEffortDetails=inlineHintService.getMigrationEffortBySeverity(traversal,includeTags,excludeTags,recursive);
  Map<String,Integer> results=new HashMap<>(classificationEffortDetails.size() + hintEffortDetails.size());
  addAllIncidents(results,classificationEffortDetails);
  addAllIncidents(results,hintEffortDetails);
  ExecutionStatistics.get().end(NAME);
  return results;
}",0.9857723577235772
109394,"@Override public Object exec(@SuppressWarnings(""String_Node_Str"") List arguments) throws TemplateModelException {
  ExecutionStatistics.get().begin(NAME);
  if (arguments.size() < 2) {
    throw new TemplateModelException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringModel projectModelTraversalArg=(StringModel)arguments.get(0);
  ProjectModelTraversal projectModelTraversal=(ProjectModelTraversal)projectModelTraversalArg.getWrappedObject();
  TemplateBooleanModel recursiveBooleanModel=(TemplateBooleanModel)arguments.get(1);
  boolean recursive=recursiveBooleanModel.getAsBoolean();
  Set<String> includeTags=Collections.emptySet();
  if (arguments.size() >= 3) {
    includeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(2));
  }
  Set<String> excludeTags=Collections.emptySet();
  if (arguments.size() >= 4) {
    excludeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(3));
  }
  projectModelTraversal.reset();
  Map<Integer,Integer> classificationEffortDetails=classificationService.getMigrationEffortByPoints(projectModelTraversal,includeTags,excludeTags,recursive,false);
  projectModelTraversal.reset();
  Map<Integer,Integer> hintEffortDetails=inlineHintService.getMigrationEffortByPoints(projectModelTraversal,includeTags,excludeTags,recursive,false);
  Map<Integer,Integer> results=sumMaps(classificationEffortDetails,hintEffortDetails);
  ExecutionStatistics.get().end(NAME);
  int points=sumPoints(results);
  LOG.info(String.format(""String_Node_Str"",NAME,points,results,classificationEffortDetails,hintEffortDetails,projectModelTraversal,recursive ? ""String_Node_Str"" : ""String_Node_Str"",includeTags,excludeTags));
  return results;
}","@Override public Object exec(@SuppressWarnings(""String_Node_Str"") List arguments) throws TemplateModelException {
  ExecutionStatistics.get().begin(NAME);
  if (arguments.size() < 2) {
    throw new TemplateModelException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringModel projectModelTraversalArg=(StringModel)arguments.get(0);
  ProjectModelTraversal projectModelTraversal=(ProjectModelTraversal)projectModelTraversalArg.getWrappedObject();
  TemplateBooleanModel recursiveBooleanModel=(TemplateBooleanModel)arguments.get(1);
  boolean recursive=recursiveBooleanModel.getAsBoolean();
  Set<String> includeTags=Collections.emptySet();
  if (arguments.size() >= 3) {
    includeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(2));
  }
  Set<String> excludeTags=Collections.emptySet();
  if (arguments.size() >= 4) {
    excludeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(3));
  }
  Map<Integer,Integer> classificationEffortDetails=classificationService.getMigrationEffortByPoints(projectModelTraversal,includeTags,excludeTags,recursive,false);
  Map<Integer,Integer> hintEffortDetails=inlineHintService.getMigrationEffortByPoints(projectModelTraversal,includeTags,excludeTags,recursive,false);
  Map<Integer,Integer> results=sumMaps(classificationEffortDetails,hintEffortDetails);
  ExecutionStatistics.get().end(NAME);
  int points=sumPoints(results);
  LOG.info(String.format(""String_Node_Str"",NAME,points,results,classificationEffortDetails,hintEffortDetails,projectModelTraversal,recursive ? ""String_Node_Str"" : ""String_Node_Str"",includeTags,excludeTags));
  return results;
}",0.9802158273381296
109395,"@Override public RuleProviderRegistry getRuleProviderRegistry(GraphContext graphContext){
  WindupConfigurationModel configurationModel=WindupConfigurationService.getConfigurationModel(graphContext);
  FileModel windupRulesPath=new FileService(graphContext).createByFilePath(PathUtil.getWindupRulesDir().toString());
  FileModel userRulesPath=new FileService(graphContext).createByFilePath(PathUtil.getUserRulesDir().toString());
  boolean pathAlreadyAdded=false;
  for (  FileModel existingRulePath : configurationModel.getUserRulesPaths()) {
    if (existingRulePath.equals(windupRulesPath))     pathAlreadyAdded=true;
  }
  if (!pathAlreadyAdded) {
    configurationModel.addUserRulesPath(windupRulesPath);
    configurationModel.addUserRulesPath(userRulesPath);
  }
  for (  Path additionalUserRulesPath : this.userRulesPaths) {
    FileModel additionalRulesFileModel=new FileService(graphContext).createByFilePath(additionalUserRulesPath.toString());
    configurationModel.addUserRulesPath(additionalRulesFileModel);
  }
  this.cachedRegistry=ruleLoader.loadConfiguration(graphContext,null);
  this.cacheRefreshTime=System.currentTimeMillis();
  return this.cachedRegistry;
}","@Override public RuleProviderRegistry getRuleProviderRegistry(GraphContext graphContext){
  initCaches(graphContext);
  return this.cachedRegistry;
}",0.2195488721804511
109396,"@Override public Set<String> getAvailableSourceTechnologies(){
  Set<String> sourceOptions=new HashSet<>();
  RuleProviderRegistry registry=getRuleProviderRegistry();
  if (registry == null)   return Collections.emptySet();
  for (  RuleProvider provider : registry.getProviders()) {
    for (    TechnologyReference technologyReference : provider.getMetadata().getSourceTechnologies()) {
      sourceOptions.add(technologyReference.getId());
    }
  }
  return sourceOptions;
}","@Override public Set<String> getAvailableSourceTechnologies(){
  Set<TechnologyReference> sourceOptions=new HashSet<>();
  RuleProviderRegistry registry=getRuleProviderRegistry();
  if (registry == null)   return Collections.emptySet();
  for (  RuleProvider provider : registry.getProviders()) {
    for (    TechnologyReference technologyReference : provider.getMetadata().getSourceTechnologies()) {
      sourceOptions.add(technologyReference);
    }
  }
  addTransformers(sourceOptions);
  return sourceOptions.stream().map(TechnologyReference::getId).collect(Collectors.toSet());
}",0.8214285714285714
109397,"@Override public Set<String> getAvailableTargetTechnologies(){
  Set<String> targetOptions=new HashSet<>();
  RuleProviderRegistry registry=getRuleProviderRegistry();
  if (registry == null)   return Collections.emptySet();
  for (  RuleProvider provider : registry.getProviders()) {
    for (    TechnologyReference technologyReference : provider.getMetadata().getTargetTechnologies()) {
      targetOptions.add(technologyReference.getId());
    }
  }
  return targetOptions;
}","@Override public Set<String> getAvailableTargetTechnologies(){
  Set<TechnologyReference> targetOptions=new HashSet<>();
  RuleProviderRegistry registry=getRuleProviderRegistry();
  if (registry == null)   return Collections.emptySet();
  for (  RuleProvider provider : registry.getProviders()) {
    for (    TechnologyReference technologyReference : provider.getMetadata().getTargetTechnologies()) {
      targetOptions.add(technologyReference);
    }
  }
  addTransformers(targetOptions);
  return targetOptions.stream().map(TechnologyReference::getId).collect(Collectors.toSet());
}",0.8214285714285714
109398,"/** 
 * Resets the state of this traversal, so it can be reused.
 */
public void reset(){
  this.traversalStrategy.reset();
}","/** 
 * Resets the internal state of this traversal, so it can be reused.
 */
public void reset(){
  this.traversalStrategy.reset();
}",0.9652509652509652
109399,"private Set<ProjectModel> addProjects(Set<ProjectModel> existingVertices,ProjectModelTraversal traversal){
  existingVertices.add(traversal.getCanonicalProject());
  for (  ProjectModelTraversal child : traversal.getChildren())   addProjects(existingVertices,child);
  return existingVertices;
}","private Set<ProjectModel> addProjects(Set<ProjectModel> existingVertices,ProjectModelTraversal traversal){
  TraversalState nodeTraversalState=traversal.getTraversalState();
  if (nodeTraversalState == TraversalState.ALL)   existingVertices.add(traversal.getCanonicalProject());
  if (nodeTraversalState != TraversalState.NONE) {
    for (    ProjectModelTraversal child : traversal.getChildren())     addProjects(existingVertices,child);
  }
  return existingVertices;
}",0.7597911227154047
109400,"@Override public Iterable<ProjectModelTraversal> getChildren(final ProjectModelTraversal traversal){
  ProjectModel canonicalProject=traversal.getCanonicalProject();
  Iterable<ProjectModelTraversal> defaultChildren=Iterables.transform(canonicalProject.getChildProjects(),new Function<ProjectModel,ProjectModelTraversal>(){
    @Override public ProjectModelTraversal apply(    ProjectModel input){
      return new ProjectModelTraversal(traversal,input,SharedLibsTraversalStrategy.this);
    }
  }
);
  return Iterables.filter(defaultChildren,new Predicate<ProjectModelTraversal>(){
    @Override public boolean apply(    ProjectModelTraversal input){
      final ProjectModel project=input.getCurrent();
      FileModel rootFile=project.getRootFileModel();
      LOG.info(""String_Node_Str"" + rootFile.getFilePath() + ""String_Node_Str""+ rootFile);
      if (!(project instanceof DuplicateProjectModel))       return false;
      LOG.info(""String_Node_Str"");
      if (!(rootFile instanceof DuplicateArchiveModel))       return false;
      LOG.info(""String_Node_Str"");
      if (!ProjectService.SHARED_LIBS_UNIQUE_ID.equals(input.getCanonicalProject().getRootProjectModel().getUniqueID()))       return false;
      LOG.info(""String_Node_Str"");
      final boolean added=alreadySeenHashes.add(rootFile.getSHA1Hash());
      LOG.info(""String_Node_Str"" + added);
      return added;
    }
  }
);
}","@Override public Iterable<ProjectModelTraversal> getChildren(final ProjectModelTraversal traversal){
  ProjectModel canonicalProject=traversal.getCanonicalProject();
  Iterable<ProjectModelTraversal> defaultChildren=Iterables.transform(canonicalProject.getChildProjects(),new Function<ProjectModel,ProjectModelTraversal>(){
    @Override public ProjectModelTraversal apply(    ProjectModel input){
      return new ProjectModelTraversal(traversal,input,SharedLibsTraversalStrategy.this);
    }
  }
);
  return Iterables.filter(defaultChildren,new Predicate<ProjectModelTraversal>(){
    @Override public boolean apply(    ProjectModelTraversal input){
      ProjectModelTraversal.TraversalState traversalState=getTraversalState(input);
      return traversalState != ProjectModelTraversal.TraversalState.NONE;
    }
  }
);
}",0.6038756196484903
109401,"@Override public boolean apply(ProjectModelTraversal input){
  final ProjectModel project=input.getCurrent();
  FileModel rootFile=project.getRootFileModel();
  LOG.info(""String_Node_Str"" + rootFile.getFilePath() + ""String_Node_Str""+ rootFile);
  if (!(project instanceof DuplicateProjectModel))   return false;
  LOG.info(""String_Node_Str"");
  if (!(rootFile instanceof DuplicateArchiveModel))   return false;
  LOG.info(""String_Node_Str"");
  if (!ProjectService.SHARED_LIBS_UNIQUE_ID.equals(input.getCanonicalProject().getRootProjectModel().getUniqueID()))   return false;
  LOG.info(""String_Node_Str"");
  final boolean added=alreadySeenHashes.add(rootFile.getSHA1Hash());
  LOG.info(""String_Node_Str"" + added);
  return added;
}","@Override public boolean apply(ProjectModelTraversal input){
  ProjectModelTraversal.TraversalState traversalState=getTraversalState(input);
  return traversalState != ProjectModelTraversal.TraversalState.NONE;
}",0.2057264050901378
109402,"@Override public void reset(){
  this.alreadySeenHashes=new HashSet<>();
}","@Override public void reset(){
}",0.6037735849056604
109403,"/** 
 * Resets the state of this strategy, so it can be reused. For instance, if the strategy is keeping some intermediate data like a set of visited projects etc.
 */
public void reset();","/** 
 * Resets the state of this strategy, so it can be reused. For instance, if the strategy is keeping some intermediate data like a set of visited projects etc.
 */
void reset();",0.981029810298103
109404,"@Override public void perform(final GraphRewrite event,final EvaluationContext context,final ReportModel payload){
  String templatePath=payload.getTemplatePath();
  String outputFilename=payload.getReportFilename();
  ExecutionStatistics.get().begin(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str"");
  try {
    ReportService reportService=new ReportService(event.getGraphContext());
    Path outputDir=reportService.getReportDirectory();
    if (!Files.isDirectory(outputDir)) {
      Files.createDirectories(outputDir);
    }
    Path outputPath=outputDir.resolve(outputFilename);
    LOG.info(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputPath.toAbsolutePath().toString()+ ""String_Node_Str"");
    Configuration freemarkerConfig=new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
    DefaultObjectWrapperBuilder objectWrapperBuilder=new DefaultObjectWrapperBuilder(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
    objectWrapperBuilder.setUseAdaptersForContainers(true);
    freemarkerConfig.setObjectWrapper(objectWrapperBuilder.build());
    freemarkerConfig.setAPIBuiltinEnabled(true);
    freemarkerConfig.setTemplateLoader(new FurnaceFreeMarkerTemplateLoader());
    freemarkerConfig.setTemplateUpdateDelayMilliseconds(3600);
    Template template=freemarkerConfig.getTemplate(templatePath);
    Variables variables=Variables.instance(event);
    Map<String,Object> vars=FreeMarkerUtil.findFreeMarkerContextVariables(variables,variableNames.toArray(new String[variableNames.size()]));
    if (useDefaultPayloadVariableName) {
      vars.put(DEFAULT_ITERATION_PAYLOAD_NAME,payload);
    }
    final Map<String,Object> freeMarkerExtensions;
    freeMarkerExtensions=furnace.getLockManager().performLocked(LockMode.WRITE,new Callable<Map<String,Object>>(){
      @Override public Map<String,Object> call() throws Exception {
        return FreeMarkerUtil.findFreeMarkerExtensions(furnace,event);
      }
    }
);
    Map<String,Object> objects=new HashMap<>(vars);
    objects.putAll(freeMarkerExtensions);
    try (FileWriter fw=new FileWriter(outputPath.toFile())){
      template.process(objects,fw);
    }
     FreeMarkerUtil.addAssociatedReportData(event.getGraphContext(),payload,vars);
  }
 catch (  IOException|TemplateException e) {
    LOG.log(Level.WARNING,""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str""+ e.getMessage(),e);
  }
 finally {
    ExecutionStatistics.get().end(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str"");
  }
}","@Override public void perform(final GraphRewrite event,final EvaluationContext context,final ReportModel payload){
  String templatePath=payload.getTemplatePath();
  String outputFilename=payload.getReportFilename();
  ExecutionStatistics.get().begin(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str"");
  try {
    ReportService reportService=new ReportService(event.getGraphContext());
    Path outputDir=reportService.getReportDirectory();
    if (!Files.isDirectory(outputDir)) {
      Files.createDirectories(outputDir);
    }
    Path outputPath=outputDir.resolve(outputFilename);
    LOG.info(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputPath.toAbsolutePath().toString()+ ""String_Node_Str"");
    Configuration freemarkerConfig=new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
    DefaultObjectWrapperBuilder objectWrapperBuilder=new DefaultObjectWrapperBuilder(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
    objectWrapperBuilder.setUseAdaptersForContainers(true);
    freemarkerConfig.setObjectWrapper(objectWrapperBuilder.build());
    freemarkerConfig.setAPIBuiltinEnabled(true);
    freemarkerConfig.setTemplateLoader(new FurnaceFreeMarkerTemplateLoader());
    freemarkerConfig.setTemplateUpdateDelayMilliseconds(3600);
    Template template=freemarkerConfig.getTemplate(templatePath);
    Variables variables=Variables.instance(event);
    Map<String,Object> vars=FreeMarkerUtil.findFreeMarkerContextVariables(variables,variableNames.toArray(new String[variableNames.size()]));
    if (useDefaultPayloadVariableName) {
      vars.put(DEFAULT_ITERATION_PAYLOAD_NAME,payload);
    }
    final Map<String,Object> freeMarkerExtensions;
    freeMarkerExtensions=furnace.getLockManager().performLocked(LockMode.WRITE,new Callable<Map<String,Object>>(){
      @Override public Map<String,Object> call() throws Exception {
        return FreeMarkerUtil.findFreeMarkerExtensions(furnace,event);
      }
    }
);
    Map<String,Object> objects=new HashMap<>(vars);
    objects.putAll(freeMarkerExtensions);
    try (FileWriter fw=new FileWriter(outputPath.toFile())){
      template.process(objects,fw);
    }
   }
 catch (  IOException|TemplateException e) {
    LOG.log(Level.WARNING,""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str""+ e.getMessage(),e);
  }
 finally {
    ExecutionStatistics.get().end(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str"");
  }
}",0.9839781164517388
109405,"private void getMigrationEffortDetails(ProjectModelTraversal traversal,Set<String> includeTags,Set<String> excludeTags,boolean recursive,boolean includeZero,EffortAccumulatorFunction accumulatorFunction){
  LOG.log(Level.INFO,String.format(""String_Node_Str"",traversal,recursive ? ""String_Node_Str"" : ""String_Node_Str"",includeZero ? ""String_Node_Str"" : ""String_Node_Str"",accumulatorFunction,includeTags,excludeTags));
  final Set<Vertex> initialVertices=traversal.getAllProjectsAsVertices(recursive);
  GremlinPipeline<Vertex,Vertex> pipeline=new GremlinPipeline<>(this.getGraphContext().getGraph());
  pipeline.V();
  if (!includeZero) {
    pipeline.has(EffortReportModel.EFFORT,Compare.GREATER_THAN,0);
    pipeline.has(WindupVertexFrame.TYPE_PROP,Text.CONTAINS,ClassificationModel.TYPE);
  }
 else {
    pipeline.has(WindupVertexFrame.TYPE_PROP,ClassificationModel.TYPE);
  }
  pipeline.as(""String_Node_Str"");
  pipeline.out(ClassificationModel.FILE_MODEL);
  pipeline.in(ProjectModel.PROJECT_MODEL_TO_FILE);
  pipeline.filter(new SetMembersFilter(initialVertices));
  pipeline.back(""String_Node_Str"");
  boolean checkTags=!includeTags.isEmpty() || !excludeTags.isEmpty();
  FileService fileService=new FileService(getGraphContext());
  for (  Vertex v : pipeline) {
    LOG.info(""String_Node_Str"" + frame(v));
    if (checkTags && !frame(v).matchesTags(includeTags,excludeTags))     continue;
    for (    Vertex fileVertex : v.getVertices(Direction.OUT,ClassificationModel.FILE_MODEL)) {
      FileModel fileModel=fileService.frame(fileVertex);
      if (initialVertices.contains(fileModel.getProjectModel().asVertex()))       accumulatorFunction.accumulate(v);
    }
    LOG.info(""String_Node_Str"" + ((MapSumEffortAccumulatorFunction)accumulatorFunction).getResults());
  }
}","private void getMigrationEffortDetails(ProjectModelTraversal traversal,Set<String> includeTags,Set<String> excludeTags,boolean recursive,boolean includeZero,EffortAccumulatorFunction accumulatorFunction){
  LOG.log(Level.INFO,String.format(""String_Node_Str"",traversal,recursive ? ""String_Node_Str"" : ""String_Node_Str"",includeZero ? ""String_Node_Str"" : ""String_Node_Str"",accumulatorFunction,includeTags,excludeTags));
  final Set<Vertex> initialVertices=traversal.getAllProjectsAsVertices(recursive);
  GremlinPipeline<Vertex,Vertex> pipeline=new GremlinPipeline<>(this.getGraphContext().getGraph());
  pipeline.V();
  if (!includeZero) {
    pipeline.has(EffortReportModel.EFFORT,Compare.GREATER_THAN,0);
    pipeline.has(WindupVertexFrame.TYPE_PROP,Text.CONTAINS,ClassificationModel.TYPE);
  }
 else {
    pipeline.has(WindupVertexFrame.TYPE_PROP,ClassificationModel.TYPE);
  }
  pipeline.as(""String_Node_Str"");
  pipeline.out(ClassificationModel.FILE_MODEL);
  pipeline.in(ProjectModel.PROJECT_MODEL_TO_FILE);
  pipeline.filter(new SetMembersFilter(initialVertices));
  pipeline.back(""String_Node_Str"");
  boolean checkTags=!includeTags.isEmpty() || !excludeTags.isEmpty();
  FileService fileService=new FileService(getGraphContext());
  for (  Vertex v : pipeline) {
    if (checkTags && !frame(v).matchesTags(includeTags,excludeTags))     continue;
    for (    Vertex fileVertex : v.getVertices(Direction.OUT,ClassificationModel.FILE_MODEL)) {
      FileModel fileModel=fileService.frame(fileVertex);
      if (initialVertices.contains(fileModel.getProjectModel().asVertex()))       accumulatorFunction.accumulate(v);
    }
  }
}",0.9569546120058564
109406,"@Override public Object exec(@SuppressWarnings(""String_Node_Str"") List arguments) throws TemplateModelException {
  ExecutionStatistics.get().begin(NAME);
  if (arguments.size() < 2) {
    throw new TemplateModelException(""String_Node_Str"");
  }
  StringModel projectModelTraversalArg=(StringModel)arguments.get(0);
  ProjectModelTraversal traversal=(ProjectModelTraversal)projectModelTraversalArg.getWrappedObject();
  TemplateBooleanModel recursiveBooleanModel=(TemplateBooleanModel)arguments.get(1);
  boolean recursive=recursiveBooleanModel.getAsBoolean();
  Set<String> includeTags=Collections.emptySet();
  if (arguments.size() >= 3) {
    includeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(2));
  }
  Set<String> excludeTags=Collections.emptySet();
  if (arguments.size() >= 4) {
    excludeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(3));
  }
  traversal.reset();
  Map<Severity,Integer> classifEffortDetails=classificationService.getMigrationEffortBySeverity(traversal,includeTags,excludeTags,recursive);
  traversal.reset();
  Map<Severity,Integer> hintEffortDetails=inlineHintService.getMigrationEffortBySeverity(traversal,includeTags,excludeTags,recursive);
  Map<String,Integer> results=new HashMap<>(classifEffortDetails.size() + hintEffortDetails.size());
  addAllIncidents(results,classifEffortDetails);
  addAllIncidents(results,hintEffortDetails);
  ExecutionStatistics.get().end(NAME);
  return results;
}","@Override public Object exec(@SuppressWarnings(""String_Node_Str"") List arguments) throws TemplateModelException {
  ExecutionStatistics.get().begin(NAME);
  if (arguments.size() < 2) {
    throw new TemplateModelException(""String_Node_Str"");
  }
  StringModel projectModelTraversalArg=(StringModel)arguments.get(0);
  ProjectModelTraversal traversal=(ProjectModelTraversal)projectModelTraversalArg.getWrappedObject();
  TemplateBooleanModel recursiveBooleanModel=(TemplateBooleanModel)arguments.get(1);
  boolean recursive=recursiveBooleanModel.getAsBoolean();
  Set<String> includeTags=Collections.emptySet();
  if (arguments.size() >= 3) {
    includeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(2));
  }
  Set<String> excludeTags=Collections.emptySet();
  if (arguments.size() >= 4) {
    excludeTags=FreeMarkerUtil.simpleSequenceToSet((SimpleSequence)arguments.get(3));
  }
  traversal.reset();
  Map<Severity,Integer> classificationEffortDetails=classificationService.getMigrationEffortBySeverity(traversal,includeTags,excludeTags,recursive);
  traversal.reset();
  Map<Severity,Integer> hintEffortDetails=inlineHintService.getMigrationEffortBySeverity(traversal,includeTags,excludeTags,recursive);
  Map<String,Integer> results=new HashMap<>(classificationEffortDetails.size() + hintEffortDetails.size());
  addAllIncidents(results,classificationEffortDetails);
  addAllIncidents(results,hintEffortDetails);
  ExecutionStatistics.get().end(NAME);
  return results;
}",0.992936427850656
109407,"@Override public InputSource resolveEntity(String name,String publicId,String baseURI,String systemId) throws SAXException, IOException {
  URL url=baseURI != null ? new URL(new URL(baseURI),systemId) : new URL(systemId);
  URLConnection connection=url.openConnection();
  if (!(connection instanceof HttpURLConnection))   return new InputSource(connection.getInputStream());
  HttpURLConnection httpConnection=(HttpURLConnection)connection;
  int status=httpConnection.getResponseCode();
  if ((status != HttpURLConnection.HTTP_OK) && (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)) {
    String newUrl=httpConnection.getHeaderField(""String_Node_Str"");
    httpConnection=(HttpURLConnection)new URL(newUrl).openConnection();
  }
  InputSource inputSource=new InputSource(httpConnection.getInputStream());
  inputSource.setSystemId(url.toString());
  inputSource.setPublicId(publicId);
  return inputSource;
}","@Override public InputSource resolveEntity(String name,String publicId,String baseURI,String systemId) throws SAXException, IOException {
  URL url=baseURI != null ? new URL(new URL(baseURI),systemId) : new URL(systemId);
  URLConnection connection=url.openConnection();
  if (!(connection instanceof HttpURLConnection))   return new InputSource(connection.getInputStream());
  HttpURLConnection httpConnection=(HttpURLConnection)connection;
  int status=httpConnection.getResponseCode();
  for (int i=0; i < 4 && isRedirect(status); i++) {
    String newUrl=httpConnection.getHeaderField(""String_Node_Str"");
    httpConnection=(HttpURLConnection)new URL(newUrl).openConnection();
    status=httpConnection.getResponseCode();
  }
  InputSource inputSource=new InputSource(httpConnection.getInputStream());
  inputSource.setSystemId(url.toString());
  inputSource.setPublicId(publicId);
  return inputSource;
}",0.86282722513089
109408,"@Override public void perform(GraphRewrite event,EvaluationContext context,XmlFileModel sourceFile){
  boolean validationFailed=false;
  try {
    if (StringUtils.isNotBlank(sourceFile.getParseError()))     return;
    SAXParserFactory factory=SAXParserFactory.newInstance();
    factory.setNamespaceAware(true);
    factory.setValidating(true);
    factory.setXIncludeAware(false);
    final SAXParser parser=factory.newSAXParser();
    parser.setProperty(JAXP_SCHEMA_LANGUAGE,XMLConstants.W3C_XML_SCHEMA_NS_URI);
    final List<String> xsdURLs=new ArrayList<>();
    final List<SAXParseException> parseExceptions=new ArrayList<>();
    DefaultHandler2 handler=new DefaultHandler2(){
      private final EnhancedEntityResolver2 entityResolver=new EnhancedEntityResolver2();
      private boolean firstElementFound=false;
      private Locator locator;
      @Override public InputSource resolveEntity(      String publicId,      String systemId) throws IOException, SAXException {
        return entityResolver.resolveEntity(publicId,systemId);
      }
      @Override public InputSource resolveEntity(      String name,      String publicId,      String baseURI,      String systemId) throws SAXException, IOException {
        return entityResolver.resolveEntity(name,publicId,baseURI,systemId);
      }
      @Override public void setDocumentLocator(      Locator locator){
        this.locator=locator;
      }
      @Override public void startElement(      String uri,      String localName,      String qName,      Attributes attributes) throws SAXException {
        if (!firstElementFound) {
          firstElementFound=true;
          try {
            xsdURLs.addAll(getXSDLocations(attributes));
            for (            String xsdUrl : xsdURLs) {
              try (InputStream is=new URL(xsdUrl).openStream()){
              }
 catch (              IOException e) {
                throw new InvalidXSDURLException(e.getMessage(),xsdUrl);
              }
            }
          }
 catch (          InvalidXSDURLException e) {
            parseExceptions.add(new SAXParseException(e.getMessage(),locator,e));
          }
        }
        super.startElement(uri,localName,qName,attributes);
      }
      @Override public void warning(      SAXParseException e) throws SAXException {
        super.warning(e);
      }
      @Override public void error(      SAXParseException e) throws SAXException {
        parseExceptions.add(e);
      }
      @Override public void fatalError(      SAXParseException e) throws SAXException {
        parseExceptions.add(e);
      }
    }
;
    parser.parse(sourceFile.asFile(),handler);
    if (!xsdURLs.isEmpty()) {
      for (      SAXParseException exception : parseExceptions) {
        validationFailed=true;
        createSAXParseHint(event,context,sourceFile,exception);
      }
    }
  }
 catch (  SAXParseException e) {
    validationFailed=true;
    createSAXParseHint(event,context,sourceFile,e);
  }
catch (  ParserConfigurationException|IOException|SAXException e) {
    validationFailed=true;
  }
 finally {
    if (validationFailed) {
      sourceFile.setGenerateSourceReport(true);
      ClassificationService classificationService=new ClassificationService(event.getGraphContext());
      ClassificationModel model=classificationService.attachClassification(context,sourceFile,XmlFileModel.NOT_VALID_XML,null);
      TagSetService tagSetService=new TagSetService(event.getGraphContext());
      model.setTagModel(tagSetService.getOrCreate(event,Collections.singleton(NOT_VALID_XML_TAG)));
    }
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,XmlFileModel sourceFile){
  boolean validationFailed=false;
  try {
    if (StringUtils.isNotBlank(sourceFile.getParseError()))     return;
    SAXParserFactory factory=SAXParserFactory.newInstance();
    factory.setNamespaceAware(true);
    factory.setValidating(true);
    factory.setXIncludeAware(false);
    final SAXParser parser=factory.newSAXParser();
    parser.setProperty(JAXP_SCHEMA_LANGUAGE,XMLConstants.W3C_XML_SCHEMA_NS_URI);
    ValidateXmlHandler handler=new ValidateXmlHandler();
    parser.parse(sourceFile.asFile(),handler);
    if (!handler.getXsdURLs().isEmpty()) {
      for (      SAXParseException exception : handler.getParseExceptions()) {
        validationFailed=true;
        createSAXParseHint(event,context,sourceFile,exception);
      }
    }
  }
 catch (  SAXParseException e) {
    validationFailed=true;
    createSAXParseHint(event,context,sourceFile,e);
  }
catch (  ParserConfigurationException|IOException|SAXException e) {
    validationFailed=true;
  }
 finally {
    if (validationFailed) {
      sourceFile.setGenerateSourceReport(true);
      ClassificationService classificationService=new ClassificationService(event.getGraphContext());
      ClassificationModel model=classificationService.attachClassification(context,sourceFile,XmlFileModel.NOT_VALID_XML,null);
      TagSetService tagSetService=new TagSetService(event.getGraphContext());
      model.setTagModel(tagSetService.getOrCreate(event,Collections.singleton(NOT_VALID_XML_TAG)));
    }
  }
}",0.542451913736157
109409,"private void validateReportIndex(GraphContext graphContext){
  Path mainReportPath=getReportIndex(graphContext,MAIN_APP_FILENAME);
  Assert.assertNotNull(mainReportPath);
  Path copyAppPath=getReportIndex(graphContext,COPY_EAR_FILENAME);
  Assert.assertNotNull(copyAppPath);
  Path sharedLibsPath=getReportIndex(graphContext,ProjectService.SHARED_LIBS_FILENAME);
  Assert.assertNotNull(sharedLibsPath);
  TestReportIndexReportUtil reportIndex=new TestReportIndexReportUtil();
  reportIndex.loadPage(mainReportPath);
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",0,0));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",2,0));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",0,0));
  reportIndex.loadPage(copyAppPath);
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",0,0));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",2,0));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",0,0));
  reportIndex.loadPage(sharedLibsPath);
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",2,6));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",86,584));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",0,0));
}","private void validateReportIndex(GraphContext graphContext){
  Path mainReportPath=getReportIndex(graphContext,MAIN_APP_FILENAME);
  Assert.assertNotNull(mainReportPath);
  Path copyAppPath=getReportIndex(graphContext,COPY_EAR_FILENAME);
  Assert.assertNotNull(copyAppPath);
  Path sharedLibsPath=getReportIndex(graphContext,ProjectService.SHARED_LIBS_FILENAME);
  Assert.assertNotNull(sharedLibsPath);
  TestReportIndexReportUtil reportIndex=new TestReportIndexReportUtil();
  reportIndex.loadPage(mainReportPath);
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",2,6));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",88,584));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",0,0));
  reportIndex.loadPage(copyAppPath);
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",2,6));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",88,584));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",0,0));
  reportIndex.loadPage(sharedLibsPath);
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",2,6));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",86,584));
  Assert.assertTrue(reportIndex.checkIncidentByCategoryRow(""String_Node_Str"",0,0));
}",0.5663716814159292
109410,"private void getMigrationEffortDetails(ProjectModelTraversal traversal,Set<String> includeTags,Set<String> excludeTags,boolean recursive,boolean includeZero,EffortAccumulatorFunction accumulatorFunction){
  final Set<Vertex> initialVertices=traversal.getAllProjectsAsVertices(recursive);
  GremlinPipeline<Vertex,Vertex> pipeline=new GremlinPipeline<>(this.getGraphContext().getGraph());
  pipeline.V();
  if (!includeZero) {
    pipeline.has(EffortReportModel.EFFORT,Compare.GREATER_THAN,0);
    pipeline.has(WindupVertexFrame.TYPE_PROP,Text.CONTAINS,ClassificationModel.TYPE);
  }
 else {
    pipeline.has(WindupVertexFrame.TYPE_PROP,ClassificationModel.TYPE);
  }
  pipeline.as(""String_Node_Str"");
  pipeline.out(ClassificationModel.FILE_MODEL);
  pipeline.in(ProjectModel.PROJECT_MODEL_TO_FILE);
  pipeline.filter(new SetMembersFilter(initialVertices));
  pipeline.back(""String_Node_Str"");
  boolean checkTags=!includeTags.isEmpty() || !excludeTags.isEmpty();
  for (  Vertex v : pipeline) {
    if (checkTags && !frame(v).matchesTags(includeTags,excludeTags))     continue;
    for (    Vertex fileVertex : v.getVertices(Direction.OUT,ClassificationModel.FILE_MODEL))     accumulatorFunction.accumulate(v);
  }
}","private void getMigrationEffortDetails(ProjectModelTraversal traversal,Set<String> includeTags,Set<String> excludeTags,boolean recursive,boolean includeZero,EffortAccumulatorFunction accumulatorFunction){
  final Set<Vertex> initialVertices=traversal.getAllProjectsAsVertices(recursive);
  GremlinPipeline<Vertex,Vertex> pipeline=new GremlinPipeline<>(this.getGraphContext().getGraph());
  pipeline.V();
  if (!includeZero) {
    pipeline.has(EffortReportModel.EFFORT,Compare.GREATER_THAN,0);
    pipeline.has(WindupVertexFrame.TYPE_PROP,Text.CONTAINS,ClassificationModel.TYPE);
  }
 else {
    pipeline.has(WindupVertexFrame.TYPE_PROP,ClassificationModel.TYPE);
  }
  pipeline.as(""String_Node_Str"");
  pipeline.out(ClassificationModel.FILE_MODEL);
  pipeline.in(ProjectModel.PROJECT_MODEL_TO_FILE);
  pipeline.filter(new SetMembersFilter(initialVertices));
  pipeline.back(""String_Node_Str"");
  boolean checkTags=!includeTags.isEmpty() || !excludeTags.isEmpty();
  FileService fileService=new FileService(getGraphContext());
  for (  Vertex v : pipeline) {
    if (checkTags && !frame(v).matchesTags(includeTags,excludeTags))     continue;
    for (    Vertex fileVertex : v.getVertices(Direction.OUT,ClassificationModel.FILE_MODEL)) {
      FileModel fileModel=fileService.frame(fileVertex);
      if (initialVertices.contains(fileModel.getProjectModel().asVertex()))       accumulatorFunction.accumulate(v);
    }
  }
}",0.916256157635468
109411,"@Deployment @AddonDependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static AddonArchive getDeployment(){
  AddonArchive archive=ShrinkWrap.create(AddonArchive.class).addBeansXML().addAsResource(new File(""String_Node_Str""));
  return archive;
}","@Deployment @AddonDependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static AddonArchive getDeployment(){
  return ShrinkWrap.create(AddonArchive.class).addBeansXML().addAsResource(new File(""String_Node_Str""));
}",0.9368131868131868
109412,"@Test public void testClassificationEffort() throws Exception {
  try (GraphContext context=factory.create()){
    ClassificationService classificationService=new ClassificationService(context);
    ProjectModel projectModel=fillData(context);
    ProjectModelTraversal projectModelTraversal=new ProjectModelTraversal(projectModel);
    Set<String> emptySet=Collections.emptySet();
    final Map<Integer,Integer> effortByCategory=classificationService.getMigrationEffortByPoints(projectModelTraversal,emptySet,emptySet,true,true);
    int totalEffort=0;
    for (    Map.Entry<Integer,Integer> effortEntry : effortByCategory.entrySet())     totalEffort+=effortEntry.getKey() * effortEntry.getValue();
    Assert.assertEquals(143,totalEffort);
    boolean foundF1Effort=false;
    boolean foundF2Effort=false;
    for (    FileModel fm : projectModel.getFileModels()) {
      if (fm.getFilePath().equals(""String_Node_Str"")) {
        int fileEffort=classificationService.getMigrationEffortPoints(fm);
        Assert.assertEquals(140,fileEffort);
        foundF1Effort=true;
      }
 else       if (fm.getFilePath().equals(""String_Node_Str"")) {
        int fileEffort=classificationService.getMigrationEffortPoints(fm);
        Assert.assertEquals(3,fileEffort);
        foundF2Effort=true;
      }
    }
    Assert.assertTrue(foundF1Effort);
    Assert.assertTrue(foundF2Effort);
  }
 }","@Test public void testClassificationEffort() throws Exception {
  try (GraphContext context=factory.create()){
    ClassificationService classificationService=new ClassificationService(context);
    ProjectModel projectModel=fillData(context)[0];
    ProjectModelTraversal projectModelTraversal=new ProjectModelTraversal(projectModel);
    Set<String> emptySet=Collections.emptySet();
    final Map<Integer,Integer> effortByCategory=classificationService.getMigrationEffortByPoints(projectModelTraversal,emptySet,emptySet,true,true);
    int totalEffort=0;
    for (    Map.Entry<Integer,Integer> effortEntry : effortByCategory.entrySet())     totalEffort+=effortEntry.getKey() * effortEntry.getValue();
    Assert.assertEquals(143,totalEffort);
    boolean foundF1Effort=false;
    boolean foundF2Effort=false;
    for (    FileModel fm : projectModel.getFileModels()) {
      if (fm.getFilePath().equals(""String_Node_Str"")) {
        int fileEffort=classificationService.getMigrationEffortPoints(fm);
        Assert.assertEquals(140,fileEffort);
        foundF1Effort=true;
      }
 else       if (fm.getFilePath().equals(""String_Node_Str"")) {
        int fileEffort=classificationService.getMigrationEffortPoints(fm);
        Assert.assertEquals(3,fileEffort);
        foundF2Effort=true;
      }
    }
    Assert.assertTrue(foundF1Effort);
    Assert.assertTrue(foundF2Effort);
  }
 }",0.998918139199423
109413,"private ProjectModel fillData(GraphContext context){
  ClassificationService classificationService=new ClassificationService(context);
  FileModel f1=context.getFramed().addVertex(null,FileModel.class);
  f1.setFilePath(""String_Node_Str"");
  FileModel f2=context.getFramed().addVertex(null,FileModel.class);
  f2.setFilePath(""String_Node_Str"");
  ClassificationModel b1=classificationService.create();
  ClassificationModel b1b=classificationService.create();
  b1.addFileModel(f1);
  b1.setEffort(20);
  b1b.addFileModel(f1);
  b1b.setEffort(120);
  ClassificationModel b2=classificationService.create();
  b2.addFileModel(f2);
  b2.setEffort(3);
  ProjectModel projectModel=context.getFramed().addVertex(null,ProjectModel.class);
  projectModel.addFileModel(f1);
  projectModel.addFileModel(f2);
  return projectModel;
}","private ProjectModel[] fillData(GraphContext context){
  ClassificationService classificationService=new ClassificationService(context);
  FileService fileService=new FileService(context);
  ProjectService projectService=new ProjectService(context);
  FileModel f1=fileService.create();
  f1.setFilePath(""String_Node_Str"");
  FileModel f2=fileService.create();
  f2.setFilePath(""String_Node_Str"");
  ClassificationModel b1=classificationService.create();
  ClassificationModel b1b=classificationService.create();
  b1.addFileModel(f1);
  b1.setEffort(20);
  b1b.addFileModel(f1);
  b1b.setEffort(120);
  ClassificationModel b2=classificationService.create();
  b2.addFileModel(f2);
  b2.setEffort(3);
  ProjectModel projectModel=projectService.create();
  projectModel.addFileModel(f1);
  projectModel.addFileModel(f2);
  ProjectModel projectModel2=projectService.create();
  FileModel f3=fileService.create();
  f3.setFilePath(""String_Node_Str"");
  projectModel2.addFileModel(f3);
  b2.addFileModel(f3);
  return new ProjectModel[]{projectModel,projectModel2};
}",0.6185676392572944
109414,"private void processFileLocationModel(Writer writer,String cssClass,FileLocationModel obj,String defaultText) throws IOException {
  String position=""String_Node_Str"" + obj.getLineNumber() + ""String_Node_Str""+ obj.getColumnNumber()+ ""String_Node_Str"";
  String linkText=StringUtils.isBlank(defaultText) ? getPrettyPathForFile(obj.getFile()) + position : defaultText;
  String anchor=obj.asVertex().getId().toString();
  SourceReportModel result=sourceReportService.getSourceReportForFileModel(obj.getFile());
  if (result == null) {
    writer.write(linkText);
  }
  renderLink(writer,cssClass,result.getReportFilename() + ""String_Node_Str"" + anchor,linkText);
}","private void processFileLocationModel(Writer writer,String cssClass,FileLocationModel obj,String defaultText) throws IOException {
  String position=""String_Node_Str"" + obj.getLineNumber() + ""String_Node_Str""+ obj.getColumnNumber()+ ""String_Node_Str"";
  String linkText=StringUtils.isBlank(defaultText) ? getPrettyPathForFile(obj.getFile()) + position : defaultText;
  String anchor=obj.asVertex().getId().toString();
  SourceReportModel result=sourceReportService.getSourceReportForFileModel(obj.getFile());
  if (result == null)   writer.write(linkText);
 else   renderLink(writer,cssClass,result.getReportFilename() + ""String_Node_Str"" + anchor,linkText);
}",0.9909228441754916
109415,"private void processFileLocationModel(Writer writer,String cssClass,FileLocationModel obj,String defaultText) throws IOException {
  String position=""String_Node_Str"" + obj.getLineNumber() + ""String_Node_Str""+ obj.getColumnNumber()+ ""String_Node_Str"";
  String linkText=StringUtils.isBlank(defaultText) ? getPrettyPathForFile(obj.getFile()) + position : defaultText;
  String anchor=obj.asVertex().getId().toString();
  SourceReportModel result=sourceReportService.getSourceReportForFileModel(obj.getFile());
  if (result == null) {
    writer.write(linkText);
  }
  renderLink(writer,cssClass,result.getReportFilename() + ""String_Node_Str"" + anchor,linkText);
}","private void processFileLocationModel(Writer writer,String cssClass,FileLocationModel obj,String defaultText) throws IOException {
  String position=""String_Node_Str"" + obj.getLineNumber() + ""String_Node_Str""+ obj.getColumnNumber()+ ""String_Node_Str"";
  String linkText=StringUtils.isBlank(defaultText) ? getPrettyPathForFile(obj.getFile()) + position : defaultText;
  String anchor=obj.asVertex().getId().toString();
  SourceReportModel result=sourceReportService.getSourceReportForFileModel(obj.getFile());
  if (result == null)   writer.write(linkText);
 else   renderLink(writer,cssClass,result.getReportFilename() + ""String_Node_Str"" + anchor,linkText);
}",0.9909228441754916
109416,"private ApplicationReportModel createSingleApplicationMigrationIssuesReport(GraphContext context,ProjectModel projectModel){
  ReportService reportService=new ReportService(context);
  ApplicationReportModel report=createMigrationIssuesReportBase(context);
  report.setReportName(""String_Node_Str"");
  report.setProjectModel(projectModel);
  reportService.setUniqueFilename(report,""String_Node_Str"",""String_Node_Str"");
  return report;
}","private ApplicationReportModel createSingleApplicationMigrationIssuesReport(GraphContext context,ProjectModel projectModel){
  ReportService reportService=new ReportService(context);
  ApplicationReportModel report=createMigrationIssuesReportBase(context);
  report.setReportName(MIGRATION_ISSUES_REPORT_NAME);
  report.setProjectModel(projectModel);
  reportService.setUniqueFilename(report,""String_Node_Str"",""String_Node_Str"");
  return report;
}",0.9514124293785312
109417,"private ApplicationReportModel createGlobalMigrationIssuesReport(GraphContext context){
  ReportService reportService=new ReportService(context);
  ApplicationReportModel report=createMigrationIssuesReportBase(context);
  report.setReportName(""String_Node_Str"");
  report.setDisplayInGlobalApplicationIndex(true);
  reportService.setUniqueFilename(report,""String_Node_Str"",""String_Node_Str"");
  return report;
}","private ApplicationReportModel createGlobalMigrationIssuesReport(GraphContext context){
  ReportService reportService=new ReportService(context);
  ApplicationReportModel report=createMigrationIssuesReportBase(context);
  report.setReportName(ALL_MIGRATION_ISSUES_REPORT_NAME);
  report.setDisplayInGlobalApplicationIndex(true);
  reportService.setUniqueFilename(report,""String_Node_Str"",""String_Node_Str"");
  return report;
}",0.9438470728793308
109418,"/** 
 * Provides a link to the Navigation Index that is used for this particular report
 */
@Adjacency(label=ApplicationReportIndexModel.APPLICATION_REPORT_INDEX_TO_REPORT_MODEL,direction=Direction.IN) ApplicationReportIndexModel getApplicationReportIndexModel();","@Override public ApplicationReportIndexModel getApplicationReportIndexModel(){
  ApplicationReportIndexModel result=null;
  for (  Vertex v : it().getVertices(Direction.IN,ApplicationReportIndexModel.APPLICATION_REPORT_INDEX_TO_REPORT_MODEL)) {
    ApplicationReportIndexModel model=frame(v,ApplicationReportIndexModel.class);
    if (result == null)     result=model;
 else     if (!result.getProjectModels().iterator().hasNext() && model.getProjectModels().iterator().hasNext())     result=model;
  }
  return result;
}",0.1964285714285714
109419,"private ClassReference createClassReference(TypeReferenceLocation location,String source,String reference,int startPosition){
  String subString=StringUtils.substring(source,0,startPosition + 1);
  String[] lines=subString.split(""String_Node_Str"");
  int lineNumber=lines.length;
  int column=lines[lines.length - 1].indexOf(source.substring(startPosition));
  int length=reference.length();
  return new ClassReference(reference,ResolutionStatus.UNKNOWN,location,lineNumber,column,length,reference);
}","private ClassReference createClassReference(TypeReferenceLocation location,String source,String reference,int startPosition){
  String subString=StringUtils.substring(source,0,startPosition + 1);
  String[] lines=subString.split(""String_Node_Str"");
  int lineNumber=lines.length;
  int column=lines[lines.length - 1].indexOf(source.substring(startPosition));
  int length=reference.length();
  return new ClassReference(reference,null,null,null,ResolutionStatus.UNKNOWN,location,lineNumber,column,length,reference);
}",0.985279685966634
109420,"@Override public void perform(GraphRewrite event,EvaluationContext context,ReportModel payload){
  String templatePath=payload.getTemplatePath();
  String outputFilename=payload.getReportFilename();
  ExecutionStatistics.get().begin(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str"");
  try {
    ReportService reportService=new ReportService(event.getGraphContext());
    Path outputDir=Paths.get(reportService.getReportDirectory());
    if (!Files.isDirectory(outputDir)) {
      Files.createDirectories(outputDir);
    }
    Path outputPath=outputDir.resolve(outputFilename);
    LOG.info(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputPath.toAbsolutePath().toString()+ ""String_Node_Str"");
    Configuration freemarkerConfig=new Configuration();
    freemarkerConfig.setTemplateLoader(new FurnaceFreeMarkerTemplateLoader());
    freemarkerConfig.setTemplateUpdateDelay(500);
    Template template=freemarkerConfig.getTemplate(templatePath);
    Variables varStack=Variables.instance(event);
    Map<String,Object> vars=FreeMarkerUtil.findFreeMarkerContextVariables(varStack,variableNames.toArray(new String[variableNames.size()]));
    if (useDefaultPayloadVariableName) {
      vars.put(DEFAULT_ITERATION_PAYLOAD_NAME,payload);
    }
    Map<String,Object> freeMarkerExtensions=FreeMarkerUtil.findFreeMarkerExtensions(furnace,event);
    Map<String,Object> objects=new HashMap<>(vars);
    objects.putAll(freeMarkerExtensions);
    try (FileWriter fw=new FileWriter(outputPath.toFile())){
      template.process(objects,fw);
    }
     FreeMarkerUtil.addAssociatedReportData(event.getGraphContext(),payload,vars);
  }
 catch (  IOException e) {
    LOG.log(Level.WARNING,""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str""+ e.getMessage(),e);
  }
catch (  TemplateException e) {
    LOG.log(Level.WARNING,""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str""+ e.getMessage(),e);
  }
 finally {
    ExecutionStatistics.get().end(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str"");
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,ReportModel payload){
  String templatePath=payload.getTemplatePath();
  String outputFilename=payload.getReportFilename();
  ExecutionStatistics.get().begin(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str"");
  try {
    ReportService reportService=new ReportService(event.getGraphContext());
    Path outputDir=Paths.get(reportService.getReportDirectory());
    if (!Files.isDirectory(outputDir)) {
      Files.createDirectories(outputDir);
    }
    Path outputPath=outputDir.resolve(outputFilename);
    LOG.info(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputPath.toAbsolutePath().toString()+ ""String_Node_Str"");
    Configuration freemarkerConfig=new Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
    freemarkerConfig.setTemplateLoader(new FurnaceFreeMarkerTemplateLoader());
    freemarkerConfig.setTemplateUpdateDelayMilliseconds(3600);
    Template template=freemarkerConfig.getTemplate(templatePath);
    Variables varStack=Variables.instance(event);
    Map<String,Object> vars=FreeMarkerUtil.findFreeMarkerContextVariables(varStack,variableNames.toArray(new String[variableNames.size()]));
    if (useDefaultPayloadVariableName) {
      vars.put(DEFAULT_ITERATION_PAYLOAD_NAME,payload);
    }
    Map<String,Object> freeMarkerExtensions=FreeMarkerUtil.findFreeMarkerExtensions(furnace,event);
    Map<String,Object> objects=new HashMap<>(vars);
    objects.putAll(freeMarkerExtensions);
    try (FileWriter fw=new FileWriter(outputPath.toFile())){
      template.process(objects,fw);
    }
     FreeMarkerUtil.addAssociatedReportData(event.getGraphContext(),payload,vars);
  }
 catch (  IOException e) {
    LOG.log(Level.WARNING,""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str""+ e.getMessage(),e);
  }
catch (  TemplateException e) {
    LOG.log(Level.WARNING,""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str""+ e.getMessage(),e);
  }
 finally {
    ExecutionStatistics.get().end(""String_Node_Str"" + templatePath + ""String_Node_Str""+ outputFilename+ ""String_Node_Str"");
  }
}",0.985307621671258
109421,"public static String trimLeadingAndTrailingSpaces(String markdown){
  StringBuilder markdownSB=new StringBuilder();
  StringBuilder currentLine=new StringBuilder();
  for (int i=0; i < markdown.length(); i++) {
    char currentChar=markdown.charAt(i);
    if (currentChar == '\r' || currentChar == '\n') {
      markdownSB.append(currentLine.toString().trim()).append(SystemUtils.LINE_SEPARATOR);
      currentLine.setLength(0);
      if (currentChar == '\r' && markdown.length() > (i + 1) && markdown.charAt(i + 1) == '\n') {
        i++;
      }
    }
 else {
      currentLine.append(currentChar);
    }
  }
  markdownSB.append(currentLine);
  return markdownSB.toString();
}","public static String trimLeadingAndTrailingSpaces(String markdown){
  StringBuilder markdownSB=new StringBuilder();
  StringBuilder currentLine=new StringBuilder();
  String firstLineIndent=null;
  for (int i=0; i < markdown.length(); i++) {
    char currentChar=markdown.charAt(i);
    if (currentChar == '\r' || currentChar == '\n') {
      String currentLineString=currentLine.toString();
      if (firstLineIndent == null && !StringUtils.isEmpty(currentLineString)) {
        int firstNonWhitespaceIndex=StringUtils.indexOfAnyBut(currentLineString,""String_Node_Str"");
        if (firstNonWhitespaceIndex != -1)         firstLineIndent=currentLineString.substring(0,firstNonWhitespaceIndex);
      }
      if (firstLineIndent != null)       currentLineString=StringUtils.removeStart(currentLineString,firstLineIndent);
      markdownSB.append(currentLineString).append(SystemUtils.LINE_SEPARATOR);
      currentLine.setLength(0);
      if (currentChar == '\r' && markdown.length() > (i + 1) && markdown.charAt(i + 1) == '\n') {
        i++;
      }
    }
 else {
      currentLine.append(currentChar);
    }
  }
  markdownSB.append(currentLine);
  return markdownSB.toString();
}",0.7096774193548387
109422,"private void setDefaultOutputPath(Map<String,Object> optionValues){
  if (!optionValues.containsKey(OutputPathOption.NAME)) {
    File inputFile=(File)optionValues.get(InputPathOption.NAME);
    if (inputFile != null) {
      File outputFile=new File(inputFile.getAbsoluteFile().getParentFile(),inputFile.getName() + ""String_Node_Str"");
      optionValues.put(OutputPathOption.NAME,outputFile);
    }
  }
}","private void setDefaultOutputPath(Map<String,Object> optionValues){
  if (!optionValues.containsKey(OutputPathOption.NAME)) {
    File inputFile=(File)optionValues.get(InputPathOption.NAME);
    if (inputFile != null) {
      try {
        File canonicalInputFile=inputFile.getCanonicalFile();
        File outputFile=new File(canonicalInputFile.getParentFile(),canonicalInputFile.getName() + ""String_Node_Str"");
        optionValues.put(OutputPathOption.NAME,outputFile);
      }
 catch (      IOException e) {
        throw new WindupException(""String_Node_Str"" + inputFile);
      }
    }
  }
}",0.7377866400797607
109423,"public boolean isRequired(){
  return false;
}","public boolean isRequired(){
  return true;
}",0.9230769230769232
109424,"@Override public ValidationResult validate(Object value){
  return ValidationResult.SUCCESS;
}","@Override public ValidationResult validate(Object value){
  if (value == null) {
    return new ValidationResult(ValidationResult.Level.ERROR,NAME + ""String_Node_Str"");
  }
  return ValidationResult.SUCCESS;
}",0.6204620462046204
109425,"@Override public Void call() throws Exception {
  ASTParser parser=ASTParser.newParser(AST.JLS8);
  parser.setBindingsRecovery(false);
  parser.setResolveBindings(true);
  Map<Object,Object> options=JavaCore.getOptions();
  JavaCore.setComplianceOptions(JavaCore.VERSION_1_8,options);
  options.put(JavaCore.CORE_INCOMPLETE_CLASSPATH,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_ENUM_IDENTIFIER,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE,""String_Node_Str"");
  options.put(JavaCore.CORE_CIRCULAR_CLASSPATH,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_ASSERT_IDENTIFIER,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION,""String_Node_Str"");
  options.put(JavaCore.CORE_JAVA_BUILD_INVALID_CLASSPATH,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT,""String_Node_Str"");
  options.put(JavaCore.CORE_OUTPUT_LOCATION_OVERLAPPING_ANOTHER_SOURCE,""String_Node_Str"");
  parser.setCompilerOptions(options);
  parser.setCompilerOptions(options);
  parser.setEnvironment(libraryPaths.toArray(new String[libraryPaths.size()]),sourcePaths.toArray(new String[sourcePaths.size()]),null,true);
  parser.createASTs(batch.toArray(new String[batch.size()]),encodings,bindingKeys,requestor,null);
  return null;
}","@Override public Void call() throws Exception {
  ASTParser parser=ASTParser.newParser(AST.JLS8);
  parser.setBindingsRecovery(false);
  parser.setResolveBindings(true);
  Map<Object,Object> options=JavaCore.getOptions();
  JavaCore.setComplianceOptions(JavaCore.VERSION_1_8,options);
  options.put(JavaCore.CORE_INCOMPLETE_CLASSPATH,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_ENUM_IDENTIFIER,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE,""String_Node_Str"");
  options.put(JavaCore.CORE_CIRCULAR_CLASSPATH,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_ASSERT_IDENTIFIER,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION,""String_Node_Str"");
  options.put(JavaCore.CORE_JAVA_BUILD_INVALID_CLASSPATH,""String_Node_Str"");
  options.put(JavaCore.COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT,""String_Node_Str"");
  options.put(JavaCore.CORE_OUTPUT_LOCATION_OVERLAPPING_ANOTHER_SOURCE,""String_Node_Str"");
  options.put(JavaCore.CORE_JAVA_BUILD_DUPLICATE_RESOURCE,""String_Node_Str"");
  parser.setCompilerOptions(options);
  parser.setCompilerOptions(options);
  parser.setEnvironment(libraryPaths.toArray(new String[libraryPaths.size()]),sourcePaths.toArray(new String[sourcePaths.size()]),null,true);
  parser.createASTs(batch.toArray(new String[batch.size()]),encodings,bindingKeys,requestor,null);
  return null;
}",0.9711964549483012
109426,"/** 
 * Process the given batch of files and pass the results back to the listener as each file is processed.
 */
public static BatchASTFuture analyze(final BatchASTListener listener,final WildcardImportResolver importResolver,final Set<String> libraryPaths,final Set<String> sourcePaths,Set<Path> sourceFiles){
  final ExecutorService executor=Executors.newFixedThreadPool(THREADPOOL_SIZE);
  final String[] encodings=null;
  final String[] bindingKeys=new String[0];
  final FileASTRequestor requestor=new FileASTRequestor(){
    @Override public void acceptAST(    String sourcePath,    CompilationUnit ast){
      try {
        super.acceptAST(sourcePath,ast);
        ReferenceResolvingVisitor visitor=new ReferenceResolvingVisitor(importResolver,ast,sourcePath);
        ast.accept(visitor);
        listener.processed(Paths.get(sourcePath),visitor.getJavaClassReferences());
      }
 catch (      Throwable t) {
        listener.failed(Paths.get(sourcePath),t);
      }
    }
  }
;
  List<List<String>> batches=createBatches(sourceFiles);
  for (  final List<String> batch : batches) {
    executor.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        ASTParser parser=ASTParser.newParser(AST.JLS8);
        parser.setBindingsRecovery(false);
        parser.setResolveBindings(true);
        Map<Object,Object> options=JavaCore.getOptions();
        JavaCore.setComplianceOptions(JavaCore.VERSION_1_8,options);
        options.put(JavaCore.CORE_INCOMPLETE_CLASSPATH,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_ENUM_IDENTIFIER,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE,""String_Node_Str"");
        options.put(JavaCore.CORE_CIRCULAR_CLASSPATH,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_ASSERT_IDENTIFIER,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION,""String_Node_Str"");
        options.put(JavaCore.CORE_JAVA_BUILD_INVALID_CLASSPATH,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT,""String_Node_Str"");
        options.put(JavaCore.CORE_OUTPUT_LOCATION_OVERLAPPING_ANOTHER_SOURCE,""String_Node_Str"");
        parser.setCompilerOptions(options);
        parser.setCompilerOptions(options);
        parser.setEnvironment(libraryPaths.toArray(new String[libraryPaths.size()]),sourcePaths.toArray(new String[sourcePaths.size()]),null,true);
        parser.createASTs(batch.toArray(new String[batch.size()]),encodings,bindingKeys,requestor,null);
        return null;
      }
    }
);
  }
  executor.shutdown();
  return new BatchASTFuture(){
    @Override public boolean isDone(){
      return executor.isTerminated();
    }
  }
;
}","/** 
 * Process the given batch of files and pass the results back to the listener as each file is processed.
 */
public static BatchASTFuture analyze(final BatchASTListener listener,final WildcardImportResolver importResolver,final Set<String> libraryPaths,final Set<String> sourcePaths,Set<Path> sourceFiles){
  final ExecutorService executor=Executors.newFixedThreadPool(THREADPOOL_SIZE);
  final String[] encodings=null;
  final String[] bindingKeys=new String[0];
  final FileASTRequestor requestor=new FileASTRequestor(){
    @Override public void acceptAST(    String sourcePath,    CompilationUnit ast){
      try {
        super.acceptAST(sourcePath,ast);
        ReferenceResolvingVisitor visitor=new ReferenceResolvingVisitor(importResolver,ast,sourcePath);
        ast.accept(visitor);
        listener.processed(Paths.get(sourcePath),visitor.getJavaClassReferences());
      }
 catch (      Throwable t) {
        listener.failed(Paths.get(sourcePath),t);
      }
    }
  }
;
  List<List<String>> batches=createBatches(sourceFiles);
  for (  final List<String> batch : batches) {
    executor.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        ASTParser parser=ASTParser.newParser(AST.JLS8);
        parser.setBindingsRecovery(false);
        parser.setResolveBindings(true);
        Map<Object,Object> options=JavaCore.getOptions();
        JavaCore.setComplianceOptions(JavaCore.VERSION_1_8,options);
        options.put(JavaCore.CORE_INCOMPLETE_CLASSPATH,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_ENUM_IDENTIFIER,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_FORBIDDEN_REFERENCE,""String_Node_Str"");
        options.put(JavaCore.CORE_CIRCULAR_CLASSPATH,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_ASSERT_IDENTIFIER,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION,""String_Node_Str"");
        options.put(JavaCore.CORE_JAVA_BUILD_INVALID_CLASSPATH,""String_Node_Str"");
        options.put(JavaCore.COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT,""String_Node_Str"");
        options.put(JavaCore.CORE_OUTPUT_LOCATION_OVERLAPPING_ANOTHER_SOURCE,""String_Node_Str"");
        options.put(JavaCore.CORE_JAVA_BUILD_DUPLICATE_RESOURCE,""String_Node_Str"");
        parser.setCompilerOptions(options);
        parser.setCompilerOptions(options);
        parser.setEnvironment(libraryPaths.toArray(new String[libraryPaths.size()]),sourcePaths.toArray(new String[sourcePaths.size()]),null,true);
        parser.createASTs(batch.toArray(new String[batch.size()]),encodings,bindingKeys,requestor,null);
        return null;
      }
    }
);
  }
  executor.shutdown();
  return new BatchASTFuture(){
    @Override public boolean isDone(){
      return executor.isTerminated();
    }
  }
;
}",0.984870317002882
109427,"private static List<List<String>> createBatches(Set<Path> sourceFiles){
  List<List<String>> result=new ArrayList<>();
  List<String> batch=new ArrayList<>(BATCH_SIZE);
  for (  Path path : sourceFiles) {
    if (batch.size() == BATCH_SIZE) {
      result.add(batch);
      batch=new ArrayList<>(BATCH_SIZE);
    }
    batch.add(path.toAbsolutePath().toString());
  }
  return result;
}","private static List<List<String>> createBatches(Set<Path> sourceSet){
  List<List<String>> result=new ArrayList<>();
  List<Path> sourceFiles=new ArrayList<>(sourceSet);
  while (!sourceFiles.isEmpty()) {
    ListIterator<Path> sourceFileIterator=sourceFiles.listIterator();
    Set<String> batchDupeCheck=new HashSet<>();
    List<String> batch=new ArrayList<>(BATCH_SIZE);
    result.add(batch);
    while (sourceFileIterator.hasNext()) {
      if (batch.size() == BATCH_SIZE) {
        batch=new ArrayList<>(BATCH_SIZE);
        result.add(batch);
        batchDupeCheck.clear();
      }
      Path path=sourceFileIterator.next();
      if (!batchDupeCheck.contains(path.getFileName().toString())) {
        batch.add(path.toAbsolutePath().toString());
        batchDupeCheck.add(path.getFileName().toString());
        sourceFileIterator.remove();
      }
    }
  }
  return result;
}",0.4474097331240188
109428,"/** 
 * Returns an appropriate output directory for the decompiled data based upon the provided   {@link JavaClassFileModel}. This should be the top-level directory for the package (eg, /tmp/project/foo for the file /tmp/project/foo/com/example/Foo.class). This could be the same directory as the file itself, if the file is already in the output directory. If the .class file is referencing a file in the input directory, then this will be a classes folder underneath the output directory.
 */
static File getOutputDirectoryForClass(GraphContext context,JavaClassFileModel fileModel){
  final File result;
  WindupConfigurationModel configuration=WindupConfigurationService.getConfigurationModel(context);
  String inputPath=configuration.getInputPath().getFilePath();
  if (fileModel.getFilePath().startsWith(inputPath)) {
    String outputPath=configuration.getOutputPath().getFilePath();
    result=Paths.get(outputPath).resolve(""String_Node_Str"").toFile();
  }
 else {
    String packageName=fileModel.getPackageName();
    if (StringUtils.isBlank(packageName))     return fileModel.asFile().getParentFile();
    String[] packageComponents=packageName.split(""String_Node_Str"");
    File rootFile=fileModel.asFile().getParentFile();
    for (int i=0; i < packageComponents.length; i++) {
      rootFile=rootFile.getParentFile();
    }
    result=rootFile;
  }
  return result;
}","/** 
 * Returns an appropriate output directory for the decompiled data based upon the provided   {@link JavaClassFileModel}. This should be the top-level directory for the package (eg, /tmp/project/foo for the file /tmp/project/foo/com/example/Foo.class). This could be the same directory as the file itself, if the file is already in the output directory. If the .class file is referencing a file in the input directory, then this will be a classes folder underneath the output directory.
 */
static File getOutputDirectoryForClass(GraphContext context,JavaClassFileModel fileModel){
  final File result;
  WindupConfigurationModel configuration=WindupConfigurationService.getConfigurationModel(context);
  File inputPath=configuration.getInputPath().asFile();
  if (PathUtil.isInSubDirectory(inputPath,fileModel.asFile())) {
    String outputPath=configuration.getOutputPath().getFilePath();
    result=Paths.get(outputPath).resolve(""String_Node_Str"").toFile();
  }
 else {
    String packageName=fileModel.getPackageName();
    if (StringUtils.isBlank(packageName))     return fileModel.asFile().getParentFile();
    String[] packageComponents=packageName.split(""String_Node_Str"");
    File rootFile=fileModel.asFile().getParentFile();
    for (int i=0; i < packageComponents.length; i++) {
      rootFile=rootFile.getParentFile();
    }
    result=rootFile;
  }
  return result;
}",0.93314058547163
109429,"public void perform(final GraphRewrite event,EvaluationContext context){
  ExecutionStatistics.get().begin(""String_Node_Str"");
  try {
    WindupJavaConfigurationService windupJavaConfigurationService=new WindupJavaConfigurationService(event.getGraphContext());
    WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
    GraphService<JavaSourceFileModel> service=new GraphService<>(event.getGraphContext(),JavaSourceFileModel.class);
    Iterable<JavaSourceFileModel> allJavaSourceModels=service.findAll();
    final Set<Path> allSourceFiles=new TreeSet<>();
    Set<String> sourcePaths=new HashSet<>();
    for (    JavaSourceFileModel javaFile : allJavaSourceModels) {
      FileModel rootSourceFolder=javaFile.getRootSourceFolder();
      if (rootSourceFolder != null) {
        sourcePaths.add(rootSourceFolder.getFilePath());
      }
      if (windupJavaConfigurationService.shouldScanPackage(javaFile.getPackageName())) {
        Path path=Paths.get(javaFile.getFilePath());
        allSourceFiles.add(path);
        sourcePathToFileModel.put(path,javaFile);
      }
    }
    GraphService<JarArchiveModel> libraryService=new GraphService<>(event.getGraphContext(),JarArchiveModel.class);
    Iterable<JarArchiveModel> libraries=libraryService.findAll();
    Set<String> libraryPaths=new HashSet<>();
    WindupConfigurationModel configurationModel=WindupConfigurationService.getConfigurationModel(event.getGraphContext());
    for (    TechnologyReferenceModel target : configurationModel.getTargetTechnologies()) {
      TechnologyMetadata technologyMetadata=technologyMetadataProvider.getMetadata(event.getGraphContext(),new TechnologyReference(target));
      if (technologyMetadata != null && technologyMetadata instanceof JavaTechnologyMetadata) {
        JavaTechnologyMetadata javaMetadata=(JavaTechnologyMetadata)technologyMetadata;
        for (        Path additionalClasspath : javaMetadata.getAdditionalClasspaths())         libraryPaths.add(additionalClasspath.toString());
      }
    }
    for (    FileModel additionalClasspath : javaConfiguration.getAdditionalClasspaths()) {
      libraryPaths.add(additionalClasspath.getFilePath());
    }
    for (    JarArchiveModel library : libraries) {
      if (library.getUnzippedDirectory() != null) {
        libraryPaths.add(library.getUnzippedDirectory().getFilePath());
      }
 else {
        libraryPaths.add(library.getFilePath());
      }
    }
    ExecutionStatistics.get().begin(""String_Node_Str"");
    try {
      WindupWildcardImportResolver.setContext(event.getGraphContext());
      final BlockingQueue<Pair<Path,List<ClassReference>>> processedPaths=new ArrayBlockingQueue<>(ANALYSIS_QUEUE_SIZE);
      final Set<Path> failedPaths=Sets.getConcurrentSet();
      BatchASTListener listener=new BatchASTListener(){
        @Override public void processed(        Path filePath,        List<ClassReference> references){
          try {
            processedPaths.put(new ImmutablePair<>(filePath,filterClassReferences(references)));
          }
 catch (          InterruptedException e) {
            throw new WindupException(e.getMessage(),e);
          }
        }
        @Override public void failed(        Path filePath,        Throwable cause){
          LOG.log(Level.WARNING,""String_Node_Str"" + filePath + ""String_Node_Str""+ cause.getMessage(),cause);
          failedPaths.add(filePath);
        }
      }
;
      Set<Path> filesToProcess=new TreeSet<>(allSourceFiles);
      BatchASTFuture future=BatchASTProcessor.analyze(listener,importResolver,libraryPaths,sourcePaths,filesToProcess);
      ProgressEstimate estimate=new ProgressEstimate(filesToProcess.size());
      while (!future.isDone() || !processedPaths.isEmpty()) {
        if (processedPaths.size() > (ANALYSIS_QUEUE_SIZE / 2))         LOG.info(""String_Node_Str"" + processedPaths.size() + ""String_Node_Str""+ ANALYSIS_QUEUE_SIZE);
        Pair<Path,List<ClassReference>> pair=processedPaths.poll(250,TimeUnit.MILLISECONDS);
        if (pair == null)         continue;
        processReferences(event.getGraphContext(),pair.getKey(),pair.getValue());
        estimate.addWork(1);
        printProgressEstimate(event,estimate);
        if (estimate.getWorked() % COMMIT_INTERVAL == 0) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        filesToProcess.remove(pair.getKey());
      }
      for (      Path path : failedPaths) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),path);
        classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
      }
      if (!filesToProcess.isEmpty()) {
        for (        Path unprocessed : new ArrayList<>(filesToProcess)) {
          try {
            List<ClassReference> references=ASTProcessor.analyze(importResolver,libraryPaths,sourcePaths,unprocessed);
            processReferences(event.getGraphContext(),unprocessed,filterClassReferences(references));
            filesToProcess.remove(unprocessed);
          }
 catch (          Exception e) {
            LOG.log(Level.WARNING,""String_Node_Str"" + unprocessed + ""String_Node_Str""+ e.getMessage(),e);
            ClassificationService classificationService=new ClassificationService(event.getGraphContext());
            JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
            classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
          }
          estimate.addWork(1);
          printProgressEstimate(event,estimate);
        }
      }
      if (!filesToProcess.isEmpty()) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        StringBuilder message=new StringBuilder();
        message.append(""String_Node_Str"" + filesToProcess.size() + ""String_Node_Str"");
        for (        Path unprocessed : filesToProcess) {
          JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
          message.append(""String_Node_Str"" + unprocessed + ""String_Node_Str"");
          classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
        }
        LOG.warning(message.toString());
      }
      ExecutionStatistics.get().end(""String_Node_Str"");
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,""String_Node_Str"" + e.getMessage(),e);
    }
 finally {
      WindupWildcardImportResolver.setContext(null);
    }
  }
  finally {
    ExecutionStatistics.get().end(""String_Node_Str"");
  }
}","public void perform(final GraphRewrite event,EvaluationContext context){
  ExecutionStatistics.get().begin(""String_Node_Str"");
  try {
    WindupJavaConfigurationService windupJavaConfigurationService=new WindupJavaConfigurationService(event.getGraphContext());
    final WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
    final boolean classNotFoundAnalysisEnabled=javaConfiguration.isClassNotFoundAnalysisEnabled();
    GraphService<JavaSourceFileModel> service=new GraphService<>(event.getGraphContext(),JavaSourceFileModel.class);
    Iterable<JavaSourceFileModel> allJavaSourceModels=service.findAll();
    final Set<Path> allSourceFiles=new TreeSet<>();
    Set<String> sourcePaths=new HashSet<>();
    for (    JavaSourceFileModel javaFile : allJavaSourceModels) {
      FileModel rootSourceFolder=javaFile.getRootSourceFolder();
      if (rootSourceFolder != null) {
        sourcePaths.add(rootSourceFolder.getFilePath());
      }
      if (windupJavaConfigurationService.shouldScanPackage(javaFile.getPackageName())) {
        Path path=Paths.get(javaFile.getFilePath());
        allSourceFiles.add(path);
        sourcePathToFileModel.put(path,javaFile);
      }
    }
    GraphService<JarArchiveModel> libraryService=new GraphService<>(event.getGraphContext(),JarArchiveModel.class);
    Iterable<JarArchiveModel> libraries=libraryService.findAll();
    Set<String> libraryPaths=new HashSet<>();
    WindupConfigurationModel configurationModel=WindupConfigurationService.getConfigurationModel(event.getGraphContext());
    for (    TechnologyReferenceModel target : configurationModel.getTargetTechnologies()) {
      TechnologyMetadata technologyMetadata=technologyMetadataProvider.getMetadata(event.getGraphContext(),new TechnologyReference(target));
      if (technologyMetadata != null && technologyMetadata instanceof JavaTechnologyMetadata) {
        JavaTechnologyMetadata javaMetadata=(JavaTechnologyMetadata)technologyMetadata;
        for (        Path additionalClasspath : javaMetadata.getAdditionalClasspaths())         libraryPaths.add(additionalClasspath.toString());
      }
    }
    for (    FileModel additionalClasspath : javaConfiguration.getAdditionalClasspaths()) {
      libraryPaths.add(additionalClasspath.getFilePath());
    }
    for (    JarArchiveModel library : libraries) {
      libraryPaths.add(library.getFilePath());
    }
    ExecutionStatistics.get().begin(""String_Node_Str"");
    try {
      WindupWildcardImportResolver.setContext(event.getGraphContext());
      final BlockingQueue<Pair<Path,List<ClassReference>>> processedPaths=new ArrayBlockingQueue<>(ANALYSIS_QUEUE_SIZE);
      final Set<Path> failedPaths=Sets.getConcurrentSet();
      BatchASTListener listener=new BatchASTListener(){
        @Override public void processed(        Path filePath,        List<ClassReference> references){
          try {
            processedPaths.put(new ImmutablePair<>(filePath,filterClassReferences(references,classNotFoundAnalysisEnabled)));
          }
 catch (          InterruptedException e) {
            throw new WindupException(e.getMessage(),e);
          }
        }
        @Override public void failed(        Path filePath,        Throwable cause){
          LOG.log(Level.WARNING,""String_Node_Str"" + filePath + ""String_Node_Str""+ cause.getMessage(),cause);
          failedPaths.add(filePath);
        }
      }
;
      Set<Path> filesToProcess=new TreeSet<>(allSourceFiles);
      BatchASTFuture future=BatchASTProcessor.analyze(listener,importResolver,libraryPaths,sourcePaths,filesToProcess);
      ProgressEstimate estimate=new ProgressEstimate(filesToProcess.size());
      while (!future.isDone() || !processedPaths.isEmpty()) {
        if (processedPaths.size() > (ANALYSIS_QUEUE_SIZE / 2))         LOG.info(""String_Node_Str"" + processedPaths.size() + ""String_Node_Str""+ ANALYSIS_QUEUE_SIZE);
        Pair<Path,List<ClassReference>> pair=processedPaths.poll(250,TimeUnit.MILLISECONDS);
        if (pair == null)         continue;
        processReferences(event.getGraphContext(),pair.getKey(),pair.getValue());
        estimate.addWork(1);
        printProgressEstimate(event,estimate);
        if (estimate.getWorked() % COMMIT_INTERVAL == 0) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        filesToProcess.remove(pair.getKey());
      }
      for (      Path path : failedPaths) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),path);
        classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
      }
      if (!filesToProcess.isEmpty()) {
        for (        Path unprocessed : new ArrayList<>(filesToProcess)) {
          try {
            List<ClassReference> references=ASTProcessor.analyze(importResolver,libraryPaths,sourcePaths,unprocessed);
            processReferences(event.getGraphContext(),unprocessed,filterClassReferences(references,classNotFoundAnalysisEnabled));
            filesToProcess.remove(unprocessed);
          }
 catch (          Exception e) {
            LOG.log(Level.WARNING,""String_Node_Str"" + unprocessed + ""String_Node_Str""+ e.getMessage(),e);
            ClassificationService classificationService=new ClassificationService(event.getGraphContext());
            JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
            classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
          }
          estimate.addWork(1);
          printProgressEstimate(event,estimate);
        }
      }
      if (!filesToProcess.isEmpty()) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        StringBuilder message=new StringBuilder();
        message.append(""String_Node_Str"" + filesToProcess.size() + ""String_Node_Str"");
        for (        Path unprocessed : filesToProcess) {
          JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
          message.append(""String_Node_Str"" + unprocessed + ""String_Node_Str"");
          classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
        }
        LOG.warning(message.toString());
      }
      ExecutionStatistics.get().end(""String_Node_Str"");
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,""String_Node_Str"" + e.getMessage(),e);
    }
 finally {
      WindupWildcardImportResolver.setContext(null);
    }
  }
  finally {
    ExecutionStatistics.get().end(""String_Node_Str"");
  }
}",0.9755610972568578
109430,"@Override public void processed(Path filePath,List<ClassReference> references){
  try {
    processedPaths.put(new ImmutablePair<>(filePath,filterClassReferences(references)));
  }
 catch (  InterruptedException e) {
    throw new WindupException(e.getMessage(),e);
  }
}","@Override public void processed(Path filePath,List<ClassReference> references){
  try {
    processedPaths.put(new ImmutablePair<>(filePath,filterClassReferences(references,classNotFoundAnalysisEnabled)));
  }
 catch (  InterruptedException e) {
    throw new WindupException(e.getMessage(),e);
  }
}",0.9492119089316988
109431,"private List<ClassReference> filterClassReferences(List<ClassReference> references){
  List<ClassReference> results=new ArrayList<>(references.size());
  for (  ClassReference reference : references) {
    boolean shouldKeep=reference.getLocation() == TypeReferenceLocation.TYPE;
    shouldKeep|=reference.getResolutionStatus() != ResolutionStatus.RESOLVED;
    shouldKeep|=TypeInterestFactory.matchesAny(reference.getQualifiedName(),reference.getLocation());
    if (shouldKeep) {
      results.add(reference);
    }
  }
  return results;
}","private List<ClassReference> filterClassReferences(List<ClassReference> references,boolean classNotFoundAnalysisEnabled){
  List<ClassReference> results=new ArrayList<>(references.size());
  for (  ClassReference reference : references) {
    boolean shouldKeep=reference.getLocation() == TypeReferenceLocation.TYPE;
    shouldKeep|=classNotFoundAnalysisEnabled && reference.getResolutionStatus() != ResolutionStatus.RESOLVED;
    shouldKeep|=TypeInterestFactory.matchesAny(reference.getQualifiedName(),reference.getLocation());
    if (shouldKeep) {
      results.add(reference);
    }
  }
  return results;
}",0.94005212858384
109432,"@Override public Configuration getConfiguration(GraphContext context){
  return ConfigurationBuilder.begin().addRule().perform(new AttachHintOperation()).withId(RULE_ID);
}","@Override public Configuration getConfiguration(GraphContext context){
  return ConfigurationBuilder.begin().addRule().when(Query.fromType(WindupJavaConfigurationModel.class).withProperty(WindupJavaConfigurationModel.CLASS_NOT_FOUND_ANALYSIS_ENABLED,true)).perform(new AttachHintOperation()).withId(RULE_ID);
}",0.7136929460580913
109433,"@Override public Configuration getConfiguration(GraphContext context){
  GraphOperation copyConfigToGraph=new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      Map<String,Object> config=event.getGraphContext().getOptionMap();
      Boolean sourceMode=(Boolean)config.get(SourceModeOption.NAME);
      @SuppressWarnings(""String_Node_Str"") List<String> includeJavaPackages=(List<String>)config.get(ScanPackagesOption.NAME);
      @SuppressWarnings(""String_Node_Str"") final List<String> excludeJavaPackages;
      if (config.get(ExcludePackagesOption.NAME) == null)       excludeJavaPackages=new ArrayList<>();
 else       excludeJavaPackages=new ArrayList<>((List<String>)config.get(ExcludePackagesOption.NAME));
      Predicate<File> predicate=new FileSuffixPredicate(""String_Node_Str"");
      Visitor<File> visitor=new Visitor<File>(){
        @Override public void visit(        File file){
          try (FileInputStream inputStream=new FileInputStream(file)){
            LineIterator it=IOUtils.lineIterator(inputStream,""String_Node_Str"");
            while (it.hasNext()) {
              String line=it.next();
              if (!line.startsWith(""String_Node_Str"") && !line.trim().isEmpty()) {
                excludeJavaPackages.add(line);
              }
            }
          }
 catch (          Exception e) {
            throw new WindupException(""String_Node_Str"" + file.toString() + ""String_Node_Str"",e);
          }
        }
      }
;
      FileVisit.visit(PathUtil.getUserIgnoreDir().toFile(),predicate,visitor);
      FileVisit.visit(PathUtil.getWindupIgnoreDir().toFile(),predicate,visitor);
      WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
      javaConfiguration.setSourceMode(sourceMode == null ? false : sourceMode);
      javaConfiguration.setScanJavaPackageList(includeJavaPackages);
      javaConfiguration.setExcludeJavaPackageList(excludeJavaPackages);
      List<File> additionalClasspaths=(List<File>)config.get(AdditionalClasspathOption.NAME);
      if (additionalClasspaths != null) {
        FileService fileService=new FileService(event.getGraphContext());
        for (        File file : additionalClasspaths) {
          FileModel fileModel=fileService.createByFilePath(file.getAbsolutePath());
          javaConfiguration.addAdditionalClasspath(fileModel);
        }
      }
    }
  }
;
  return ConfigurationBuilder.begin().addRule().perform(copyConfigToGraph);
}","@Override public Configuration getConfiguration(GraphContext context){
  GraphOperation copyConfigToGraph=new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      Map<String,Object> config=event.getGraphContext().getOptionMap();
      Boolean sourceMode=(Boolean)config.get(SourceModeOption.NAME);
      Boolean enableClassFoundFoundAnalysis=(Boolean)config.get(EnableClassNotFoundAnalysisOption.NAME);
      @SuppressWarnings(""String_Node_Str"") List<String> includeJavaPackages=(List<String>)config.get(ScanPackagesOption.NAME);
      @SuppressWarnings(""String_Node_Str"") final List<String> excludeJavaPackages;
      if (config.get(ExcludePackagesOption.NAME) == null)       excludeJavaPackages=new ArrayList<>();
 else       excludeJavaPackages=new ArrayList<>((List<String>)config.get(ExcludePackagesOption.NAME));
      Predicate<File> predicate=new FileSuffixPredicate(""String_Node_Str"");
      Visitor<File> visitor=new Visitor<File>(){
        @Override public void visit(        File file){
          try (FileInputStream inputStream=new FileInputStream(file)){
            LineIterator it=IOUtils.lineIterator(inputStream,""String_Node_Str"");
            while (it.hasNext()) {
              String line=it.next();
              if (!line.startsWith(""String_Node_Str"") && !line.trim().isEmpty()) {
                excludeJavaPackages.add(line);
              }
            }
          }
 catch (          Exception e) {
            throw new WindupException(""String_Node_Str"" + file.toString() + ""String_Node_Str"",e);
          }
        }
      }
;
      FileVisit.visit(PathUtil.getUserIgnoreDir().toFile(),predicate,visitor);
      FileVisit.visit(PathUtil.getWindupIgnoreDir().toFile(),predicate,visitor);
      WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
      javaConfiguration.setSourceMode(sourceMode == null ? false : sourceMode);
      javaConfiguration.setScanJavaPackageList(includeJavaPackages);
      javaConfiguration.setExcludeJavaPackageList(excludeJavaPackages);
      javaConfiguration.setClassNotFoundAnalysisEnabled(enableClassFoundFoundAnalysis == null ? false : enableClassFoundFoundAnalysis);
      List<File> additionalClasspaths=(List<File>)config.get(AdditionalClasspathOption.NAME);
      if (additionalClasspaths != null) {
        FileService fileService=new FileService(event.getGraphContext());
        for (        File file : additionalClasspaths) {
          FileModel fileModel=fileService.createByFilePath(file.getAbsolutePath());
          javaConfiguration.addAdditionalClasspath(fileModel);
        }
      }
    }
  }
;
  return ConfigurationBuilder.begin().addRule().perform(copyConfigToGraph);
}",0.8666043030869972
109434,"@Override public void perform(GraphRewrite event,EvaluationContext context){
  Map<String,Object> config=event.getGraphContext().getOptionMap();
  Boolean sourceMode=(Boolean)config.get(SourceModeOption.NAME);
  @SuppressWarnings(""String_Node_Str"") List<String> includeJavaPackages=(List<String>)config.get(ScanPackagesOption.NAME);
  @SuppressWarnings(""String_Node_Str"") final List<String> excludeJavaPackages;
  if (config.get(ExcludePackagesOption.NAME) == null)   excludeJavaPackages=new ArrayList<>();
 else   excludeJavaPackages=new ArrayList<>((List<String>)config.get(ExcludePackagesOption.NAME));
  Predicate<File> predicate=new FileSuffixPredicate(""String_Node_Str"");
  Visitor<File> visitor=new Visitor<File>(){
    @Override public void visit(    File file){
      try (FileInputStream inputStream=new FileInputStream(file)){
        LineIterator it=IOUtils.lineIterator(inputStream,""String_Node_Str"");
        while (it.hasNext()) {
          String line=it.next();
          if (!line.startsWith(""String_Node_Str"") && !line.trim().isEmpty()) {
            excludeJavaPackages.add(line);
          }
        }
      }
 catch (      Exception e) {
        throw new WindupException(""String_Node_Str"" + file.toString() + ""String_Node_Str"",e);
      }
    }
  }
;
  FileVisit.visit(PathUtil.getUserIgnoreDir().toFile(),predicate,visitor);
  FileVisit.visit(PathUtil.getWindupIgnoreDir().toFile(),predicate,visitor);
  WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
  javaConfiguration.setSourceMode(sourceMode == null ? false : sourceMode);
  javaConfiguration.setScanJavaPackageList(includeJavaPackages);
  javaConfiguration.setExcludeJavaPackageList(excludeJavaPackages);
  List<File> additionalClasspaths=(List<File>)config.get(AdditionalClasspathOption.NAME);
  if (additionalClasspaths != null) {
    FileService fileService=new FileService(event.getGraphContext());
    for (    File file : additionalClasspaths) {
      FileModel fileModel=fileService.createByFilePath(file.getAbsolutePath());
      javaConfiguration.addAdditionalClasspath(fileModel);
    }
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context){
  Map<String,Object> config=event.getGraphContext().getOptionMap();
  Boolean sourceMode=(Boolean)config.get(SourceModeOption.NAME);
  Boolean enableClassFoundFoundAnalysis=(Boolean)config.get(EnableClassNotFoundAnalysisOption.NAME);
  @SuppressWarnings(""String_Node_Str"") List<String> includeJavaPackages=(List<String>)config.get(ScanPackagesOption.NAME);
  @SuppressWarnings(""String_Node_Str"") final List<String> excludeJavaPackages;
  if (config.get(ExcludePackagesOption.NAME) == null)   excludeJavaPackages=new ArrayList<>();
 else   excludeJavaPackages=new ArrayList<>((List<String>)config.get(ExcludePackagesOption.NAME));
  Predicate<File> predicate=new FileSuffixPredicate(""String_Node_Str"");
  Visitor<File> visitor=new Visitor<File>(){
    @Override public void visit(    File file){
      try (FileInputStream inputStream=new FileInputStream(file)){
        LineIterator it=IOUtils.lineIterator(inputStream,""String_Node_Str"");
        while (it.hasNext()) {
          String line=it.next();
          if (!line.startsWith(""String_Node_Str"") && !line.trim().isEmpty()) {
            excludeJavaPackages.add(line);
          }
        }
      }
 catch (      Exception e) {
        throw new WindupException(""String_Node_Str"" + file.toString() + ""String_Node_Str"",e);
      }
    }
  }
;
  FileVisit.visit(PathUtil.getUserIgnoreDir().toFile(),predicate,visitor);
  FileVisit.visit(PathUtil.getWindupIgnoreDir().toFile(),predicate,visitor);
  WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
  javaConfiguration.setSourceMode(sourceMode == null ? false : sourceMode);
  javaConfiguration.setScanJavaPackageList(includeJavaPackages);
  javaConfiguration.setExcludeJavaPackageList(excludeJavaPackages);
  javaConfiguration.setClassNotFoundAnalysisEnabled(enableClassFoundFoundAnalysis == null ? false : enableClassFoundFoundAnalysis);
  List<File> additionalClasspaths=(List<File>)config.get(AdditionalClasspathOption.NAME);
  if (additionalClasspaths != null) {
    FileService fileService=new FileService(event.getGraphContext());
    for (    File file : additionalClasspaths) {
      FileModel fileModel=fileService.createByFilePath(file.getAbsolutePath());
      javaConfiguration.addAdditionalClasspath(fileModel);
    }
  }
}",0.8506906380179785
109435,"@Test public void testResolutionStatus() throws IOException, InstantiationException, IllegalAccessException {
  try (GraphContext context=factory.create(getDefaultPath())){
    final String inputDir=""String_Node_Str"";
    final Path outputPath=Paths.get(FileUtils.getTempDirectory().toString(),""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    Path rulesPath=FileUtils.getTempDirectory().toPath().resolve(""String_Node_Str"").resolve(""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    System.out.println(""String_Node_Str"" + rulesPath);
    Files.createDirectories(rulesPath);
    try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"" + METADATA_FILENAME);OutputStream os=new FileOutputStream(rulesPath.resolve(METADATA_FILENAME).toFile())){
      IOUtils.copy(is,os);
    }
     Path rulesLibPath=rulesPath.resolve(""String_Node_Str"");
    Files.createDirectories(rulesLibPath);
    try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"" + JAR_FILENAME);OutputStream os=new FileOutputStream(rulesLibPath.resolve(JAR_FILENAME).toFile())){
      IOUtils.copy(is,os);
    }
     WindupConfigurationModel windupConfigurationModel=WindupConfigurationService.getConfigurationModel(context);
    windupConfigurationModel.addUserRulesPath(new FileService(context).createByFilePath(rulesPath.toString()));
    processorConfig.setOptionValue(TargetOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    Assert.assertTrue(typeReferences.iterator().hasNext());
    boolean nioPathResolved=false;
    boolean fileUtilsResolved=false;
    boolean fileModelRecovered=false;
    for (    JavaTypeReferenceModel typeReference : typeReferences) {
      if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str""))       Assert.fail(""String_Node_Str"");
      if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() != ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         nioPathResolved=true;
      }
 else       if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() != ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         fileUtilsResolved=true;
      }
 else       if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() == ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         fileModelRecovered=true;
      }
    }
    Assert.assertTrue(nioPathResolved);
    Assert.assertTrue(fileUtilsResolved);
    Assert.assertTrue(fileModelRecovered);
  }
 }","@Test public void testResolutionStatus() throws IOException, InstantiationException, IllegalAccessException {
  try (GraphContext context=factory.create(getDefaultPath())){
    final String inputDir=""String_Node_Str"";
    final Path outputPath=Paths.get(FileUtils.getTempDirectory().toString(),""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    Path rulesPath=FileUtils.getTempDirectory().toPath().resolve(""String_Node_Str"").resolve(""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    System.out.println(""String_Node_Str"" + rulesPath);
    Files.createDirectories(rulesPath);
    try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"" + METADATA_FILENAME);OutputStream os=new FileOutputStream(rulesPath.resolve(METADATA_FILENAME).toFile())){
      IOUtils.copy(is,os);
    }
     Path rulesLibPath=rulesPath.resolve(""String_Node_Str"");
    Files.createDirectories(rulesLibPath);
    try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"" + JAR_FILENAME);OutputStream os=new FileOutputStream(rulesLibPath.resolve(JAR_FILENAME).toFile())){
      IOUtils.copy(is,os);
    }
     WindupConfigurationModel windupConfigurationModel=WindupConfigurationService.getConfigurationModel(context);
    windupConfigurationModel.addUserRulesPath(new FileService(context).createByFilePath(rulesPath.toString()));
    processorConfig.setOptionValue(TargetOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setOptionValue(EnableClassNotFoundAnalysisOption.NAME,true);
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    Assert.assertTrue(typeReferences.iterator().hasNext());
    boolean nioPathResolved=false;
    boolean fileUtilsResolved=false;
    boolean fileModelRecovered=false;
    for (    JavaTypeReferenceModel typeReference : typeReferences) {
      if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str""))       Assert.fail(""String_Node_Str"");
      if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() != ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         nioPathResolved=true;
      }
 else       if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() != ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         fileUtilsResolved=true;
      }
 else       if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() == ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         fileModelRecovered=true;
      }
    }
    Assert.assertTrue(nioPathResolved);
    Assert.assertTrue(fileUtilsResolved);
    Assert.assertTrue(fileModelRecovered);
  }
 }",0.9881526985519964
109436,"@Test public void testJavaClassCondition() throws IOException, InstantiationException, IllegalAccessException {
  final Path outputPath=getDefaultPath();
  try (GraphContext context=factory.create(outputPath)){
    final String inputDir=""String_Node_Str"";
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setRuleProviderFilter(new NotPredicate(new EnumeratedRuleProviderPredicate(FindUnboundJavaReferencesRuleProvider.class)));
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    int count=0;
    for (    JavaTypeReferenceModel ref : typeReferences) {
      String sourceSnippit=ref.getResolvedSourceSnippit();
      if (sourceSnippit.contains(""String_Node_Str""))       count++;
    }
    Assert.assertTrue(count > 9);
    GraphService<InlineHintModel> hintService=new GraphService<>(context,InlineHintModel.class);
    Iterable<InlineHintModel> hints=hintService.findAll();
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str""))       count++;
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        if (hint.getFileLocationReference().getSourceSnippit().contains(""String_Node_Str"")) {
          Assert.assertTrue(hint.getHint().contains(""String_Node_Str""));
          count++;
        }
 else         Assert.fail(""String_Node_Str"");
      }
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        if (hint.getFileLocationReference().getSourceSnippit().contains(""String_Node_Str""))         count++;
 else         Assert.fail(""String_Node_Str"");
      }
    }
    Assert.assertEquals(1,count);
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        Assert.fail(""String_Node_Str"");
      }
    }
  }
 }","@Test public void testJavaClassCondition() throws IOException, InstantiationException, IllegalAccessException {
  final Path outputPath=getDefaultPath();
  try (GraphContext context=factory.create(outputPath)){
    final String inputDir=""String_Node_Str"";
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setOptionValue(EnableClassNotFoundAnalysisOption.NAME,true);
    processorConfig.setRuleProviderFilter(new NotPredicate(new EnumeratedRuleProviderPredicate(FindUnboundJavaReferencesRuleProvider.class)));
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    int count=0;
    for (    JavaTypeReferenceModel ref : typeReferences) {
      String sourceSnippit=ref.getResolvedSourceSnippit();
      if (sourceSnippit.contains(""String_Node_Str""))       count++;
    }
    Assert.assertTrue(count > 9);
    GraphService<InlineHintModel> hintService=new GraphService<>(context,InlineHintModel.class);
    Iterable<InlineHintModel> hints=hintService.findAll();
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str""))       count++;
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        if (hint.getFileLocationReference().getSourceSnippit().contains(""String_Node_Str"")) {
          Assert.assertTrue(hint.getHint().contains(""String_Node_Str""));
          count++;
        }
 else         Assert.fail(""String_Node_Str"");
      }
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        if (hint.getFileLocationReference().getSourceSnippit().contains(""String_Node_Str""))         count++;
 else         Assert.fail(""String_Node_Str"");
      }
    }
    Assert.assertEquals(1,count);
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        Assert.fail(""String_Node_Str"");
      }
    }
  }
 }",0.984281001358432
109437,"private void setDefaultOutputPath(Map<String,Object> optionValues){
  if (!optionValues.containsKey(OutputPathOption.NAME)) {
    File inputFile=(File)optionValues.get(InputPathOption.NAME);
    if (inputFile != null) {
      File outputFile=new File(inputFile.getAbsoluteFile().getParentFile(),inputFile.getName() + ""String_Node_Str"");
      optionValues.put(OutputPathOption.NAME,outputFile);
    }
  }
}","private void setDefaultOutputPath(Map<String,Object> optionValues){
  if (!optionValues.containsKey(OutputPathOption.NAME)) {
    File inputFile=(File)optionValues.get(InputPathOption.NAME);
    if (inputFile != null) {
      try {
        File canonicalInputFile=inputFile.getCanonicalFile();
        File outputFile=new File(canonicalInputFile.getParentFile(),canonicalInputFile.getName() + ""String_Node_Str"");
        optionValues.put(OutputPathOption.NAME,outputFile);
      }
 catch (      IOException e) {
        throw new WindupException(""String_Node_Str"" + inputFile);
      }
    }
  }
}",0.7377866400797607
109438,"public boolean isRequired(){
  return false;
}","public boolean isRequired(){
  return true;
}",0.9230769230769232
109439,"@Override public ValidationResult validate(Object value){
  return ValidationResult.SUCCESS;
}","@Override public ValidationResult validate(Object value){
  if (value == null) {
    return new ValidationResult(ValidationResult.Level.ERROR,NAME + ""String_Node_Str"");
  }
  return ValidationResult.SUCCESS;
}",0.6204620462046204
109440,"/** 
 * Returns an appropriate output directory for the decompiled data based upon the provided   {@link JavaClassFileModel}. This should be the top-level directory for the package (eg, /tmp/project/foo for the file /tmp/project/foo/com/example/Foo.class). This could be the same directory as the file itself, if the file is already in the output directory. If the .class file is referencing a file in the input directory, then this will be a classes folder underneath the output directory.
 */
static File getOutputDirectoryForClass(GraphContext context,JavaClassFileModel fileModel){
  final File result;
  WindupConfigurationModel configuration=WindupConfigurationService.getConfigurationModel(context);
  String inputPath=configuration.getInputPath().getFilePath();
  if (fileModel.getFilePath().startsWith(inputPath)) {
    String outputPath=configuration.getOutputPath().getFilePath();
    result=Paths.get(outputPath).resolve(""String_Node_Str"").toFile();
  }
 else {
    String packageName=fileModel.getPackageName();
    if (StringUtils.isBlank(packageName))     return fileModel.asFile().getParentFile();
    String[] packageComponents=packageName.split(""String_Node_Str"");
    File rootFile=fileModel.asFile().getParentFile();
    for (int i=0; i < packageComponents.length; i++) {
      rootFile=rootFile.getParentFile();
    }
    result=rootFile;
  }
  return result;
}","/** 
 * Returns an appropriate output directory for the decompiled data based upon the provided   {@link JavaClassFileModel}. This should be the top-level directory for the package (eg, /tmp/project/foo for the file /tmp/project/foo/com/example/Foo.class). This could be the same directory as the file itself, if the file is already in the output directory. If the .class file is referencing a file in the input directory, then this will be a classes folder underneath the output directory.
 */
static File getOutputDirectoryForClass(GraphContext context,JavaClassFileModel fileModel){
  final File result;
  WindupConfigurationModel configuration=WindupConfigurationService.getConfigurationModel(context);
  File inputPath=configuration.getInputPath().asFile();
  if (PathUtil.isInSubDirectory(inputPath,fileModel.asFile())) {
    String outputPath=configuration.getOutputPath().getFilePath();
    result=Paths.get(outputPath).resolve(""String_Node_Str"").toFile();
  }
 else {
    String packageName=fileModel.getPackageName();
    if (StringUtils.isBlank(packageName))     return fileModel.asFile().getParentFile();
    String[] packageComponents=packageName.split(""String_Node_Str"");
    File rootFile=fileModel.asFile().getParentFile();
    for (int i=0; i < packageComponents.length; i++) {
      rootFile=rootFile.getParentFile();
    }
    result=rootFile;
  }
  return result;
}",0.93314058547163
109441,"public void perform(final GraphRewrite event,EvaluationContext context){
  ExecutionStatistics.get().begin(""String_Node_Str"");
  try {
    WindupJavaConfigurationService windupJavaConfigurationService=new WindupJavaConfigurationService(event.getGraphContext());
    WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
    GraphService<JavaSourceFileModel> service=new GraphService<>(event.getGraphContext(),JavaSourceFileModel.class);
    Iterable<JavaSourceFileModel> allJavaSourceModels=service.findAll();
    final Set<Path> allSourceFiles=new TreeSet<>();
    Set<String> sourcePaths=new HashSet<>();
    for (    JavaSourceFileModel javaFile : allJavaSourceModels) {
      FileModel rootSourceFolder=javaFile.getRootSourceFolder();
      if (rootSourceFolder != null) {
        sourcePaths.add(rootSourceFolder.getFilePath());
      }
      if (windupJavaConfigurationService.shouldScanPackage(javaFile.getPackageName())) {
        Path path=Paths.get(javaFile.getFilePath());
        allSourceFiles.add(path);
        sourcePathToFileModel.put(path,javaFile);
      }
    }
    GraphService<JarArchiveModel> libraryService=new GraphService<>(event.getGraphContext(),JarArchiveModel.class);
    Iterable<JarArchiveModel> libraries=libraryService.findAll();
    Set<String> libraryPaths=new HashSet<>();
    WindupConfigurationModel configurationModel=WindupConfigurationService.getConfigurationModel(event.getGraphContext());
    for (    TechnologyReferenceModel target : configurationModel.getTargetTechnologies()) {
      TechnologyMetadata technologyMetadata=technologyMetadataProvider.getMetadata(event.getGraphContext(),new TechnologyReference(target));
      if (technologyMetadata != null && technologyMetadata instanceof JavaTechnologyMetadata) {
        JavaTechnologyMetadata javaMetadata=(JavaTechnologyMetadata)technologyMetadata;
        for (        Path additionalClasspath : javaMetadata.getAdditionalClasspaths())         libraryPaths.add(additionalClasspath.toString());
      }
    }
    for (    FileModel additionalClasspath : javaConfiguration.getAdditionalClasspaths()) {
      libraryPaths.add(additionalClasspath.getFilePath());
    }
    for (    JarArchiveModel library : libraries) {
      if (library.getUnzippedDirectory() != null) {
        libraryPaths.add(library.getUnzippedDirectory().getFilePath());
      }
 else {
        libraryPaths.add(library.getFilePath());
      }
    }
    ExecutionStatistics.get().begin(""String_Node_Str"");
    try {
      WindupWildcardImportResolver.setContext(event.getGraphContext());
      final BlockingQueue<Pair<Path,List<ClassReference>>> processedPaths=new ArrayBlockingQueue<>(ANALYSIS_QUEUE_SIZE);
      final Set<Path> failedPaths=Sets.getConcurrentSet();
      BatchASTListener listener=new BatchASTListener(){
        @Override public void processed(        Path filePath,        List<ClassReference> references){
          try {
            processedPaths.put(new ImmutablePair<>(filePath,filterClassReferences(references)));
          }
 catch (          InterruptedException e) {
            throw new WindupException(e.getMessage(),e);
          }
        }
        @Override public void failed(        Path filePath,        Throwable cause){
          LOG.log(Level.WARNING,""String_Node_Str"" + filePath + ""String_Node_Str""+ cause.getMessage(),cause);
          failedPaths.add(filePath);
        }
      }
;
      Set<Path> filesToProcess=new TreeSet<>(allSourceFiles);
      BatchASTFuture future=BatchASTProcessor.analyze(listener,importResolver,libraryPaths,sourcePaths,filesToProcess);
      ProgressEstimate estimate=new ProgressEstimate(filesToProcess.size());
      while (!future.isDone() || !processedPaths.isEmpty()) {
        if (processedPaths.size() > (ANALYSIS_QUEUE_SIZE / 2))         LOG.info(""String_Node_Str"" + processedPaths.size() + ""String_Node_Str""+ ANALYSIS_QUEUE_SIZE);
        Pair<Path,List<ClassReference>> pair=processedPaths.poll(250,TimeUnit.MILLISECONDS);
        if (pair == null)         continue;
        processReferences(event.getGraphContext(),pair.getKey(),pair.getValue());
        estimate.addWork(1);
        printProgressEstimate(event,estimate);
        if (estimate.getWorked() % COMMIT_INTERVAL == 0) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        filesToProcess.remove(pair.getKey());
      }
      for (      Path path : failedPaths) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),path);
        classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
      }
      if (!filesToProcess.isEmpty()) {
        for (        Path unprocessed : new ArrayList<>(filesToProcess)) {
          try {
            List<ClassReference> references=ASTProcessor.analyze(importResolver,libraryPaths,sourcePaths,unprocessed);
            processReferences(event.getGraphContext(),unprocessed,filterClassReferences(references));
            filesToProcess.remove(unprocessed);
          }
 catch (          Exception e) {
            LOG.log(Level.WARNING,""String_Node_Str"" + unprocessed + ""String_Node_Str""+ e.getMessage(),e);
            ClassificationService classificationService=new ClassificationService(event.getGraphContext());
            JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
            classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
          }
          estimate.addWork(1);
          printProgressEstimate(event,estimate);
        }
      }
      if (!filesToProcess.isEmpty()) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        StringBuilder message=new StringBuilder();
        message.append(""String_Node_Str"" + filesToProcess.size() + ""String_Node_Str"");
        for (        Path unprocessed : filesToProcess) {
          JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
          message.append(""String_Node_Str"" + unprocessed + ""String_Node_Str"");
          classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
        }
        LOG.warning(message.toString());
      }
      ExecutionStatistics.get().end(""String_Node_Str"");
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,""String_Node_Str"" + e.getMessage(),e);
    }
 finally {
      WindupWildcardImportResolver.setContext(null);
    }
  }
  finally {
    ExecutionStatistics.get().end(""String_Node_Str"");
  }
}","public void perform(final GraphRewrite event,EvaluationContext context){
  ExecutionStatistics.get().begin(""String_Node_Str"");
  try {
    WindupJavaConfigurationService windupJavaConfigurationService=new WindupJavaConfigurationService(event.getGraphContext());
    final WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
    final boolean classNotFoundAnalysisEnabled=javaConfiguration.isClassNotFoundAnalysisEnabled();
    GraphService<JavaSourceFileModel> service=new GraphService<>(event.getGraphContext(),JavaSourceFileModel.class);
    Iterable<JavaSourceFileModel> allJavaSourceModels=service.findAll();
    final Set<Path> allSourceFiles=new TreeSet<>();
    Set<String> sourcePaths=new HashSet<>();
    for (    JavaSourceFileModel javaFile : allJavaSourceModels) {
      FileModel rootSourceFolder=javaFile.getRootSourceFolder();
      if (rootSourceFolder != null) {
        sourcePaths.add(rootSourceFolder.getFilePath());
      }
      if (windupJavaConfigurationService.shouldScanPackage(javaFile.getPackageName())) {
        Path path=Paths.get(javaFile.getFilePath());
        allSourceFiles.add(path);
        sourcePathToFileModel.put(path,javaFile);
      }
    }
    GraphService<JarArchiveModel> libraryService=new GraphService<>(event.getGraphContext(),JarArchiveModel.class);
    Iterable<JarArchiveModel> libraries=libraryService.findAll();
    Set<String> libraryPaths=new HashSet<>();
    WindupConfigurationModel configurationModel=WindupConfigurationService.getConfigurationModel(event.getGraphContext());
    for (    TechnologyReferenceModel target : configurationModel.getTargetTechnologies()) {
      TechnologyMetadata technologyMetadata=technologyMetadataProvider.getMetadata(event.getGraphContext(),new TechnologyReference(target));
      if (technologyMetadata != null && technologyMetadata instanceof JavaTechnologyMetadata) {
        JavaTechnologyMetadata javaMetadata=(JavaTechnologyMetadata)technologyMetadata;
        for (        Path additionalClasspath : javaMetadata.getAdditionalClasspaths())         libraryPaths.add(additionalClasspath.toString());
      }
    }
    for (    FileModel additionalClasspath : javaConfiguration.getAdditionalClasspaths()) {
      libraryPaths.add(additionalClasspath.getFilePath());
    }
    for (    JarArchiveModel library : libraries) {
      libraryPaths.add(library.getFilePath());
    }
    ExecutionStatistics.get().begin(""String_Node_Str"");
    try {
      WindupWildcardImportResolver.setContext(event.getGraphContext());
      final BlockingQueue<Pair<Path,List<ClassReference>>> processedPaths=new ArrayBlockingQueue<>(ANALYSIS_QUEUE_SIZE);
      final Set<Path> failedPaths=Sets.getConcurrentSet();
      BatchASTListener listener=new BatchASTListener(){
        @Override public void processed(        Path filePath,        List<ClassReference> references){
          try {
            processedPaths.put(new ImmutablePair<>(filePath,filterClassReferences(references,classNotFoundAnalysisEnabled)));
          }
 catch (          InterruptedException e) {
            throw new WindupException(e.getMessage(),e);
          }
        }
        @Override public void failed(        Path filePath,        Throwable cause){
          LOG.log(Level.WARNING,""String_Node_Str"" + filePath + ""String_Node_Str""+ cause.getMessage(),cause);
          failedPaths.add(filePath);
        }
      }
;
      Set<Path> filesToProcess=new TreeSet<>(allSourceFiles);
      BatchASTFuture future=BatchASTProcessor.analyze(listener,importResolver,libraryPaths,sourcePaths,filesToProcess);
      ProgressEstimate estimate=new ProgressEstimate(filesToProcess.size());
      while (!future.isDone() || !processedPaths.isEmpty()) {
        if (processedPaths.size() > (ANALYSIS_QUEUE_SIZE / 2))         LOG.info(""String_Node_Str"" + processedPaths.size() + ""String_Node_Str""+ ANALYSIS_QUEUE_SIZE);
        Pair<Path,List<ClassReference>> pair=processedPaths.poll(250,TimeUnit.MILLISECONDS);
        if (pair == null)         continue;
        processReferences(event.getGraphContext(),pair.getKey(),pair.getValue());
        estimate.addWork(1);
        printProgressEstimate(event,estimate);
        if (estimate.getWorked() % COMMIT_INTERVAL == 0) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        filesToProcess.remove(pair.getKey());
      }
      for (      Path path : failedPaths) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),path);
        classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
      }
      if (!filesToProcess.isEmpty()) {
        for (        Path unprocessed : new ArrayList<>(filesToProcess)) {
          try {
            List<ClassReference> references=ASTProcessor.analyze(importResolver,libraryPaths,sourcePaths,unprocessed);
            processReferences(event.getGraphContext(),unprocessed,filterClassReferences(references,classNotFoundAnalysisEnabled));
            filesToProcess.remove(unprocessed);
          }
 catch (          Exception e) {
            LOG.log(Level.WARNING,""String_Node_Str"" + unprocessed + ""String_Node_Str""+ e.getMessage(),e);
            ClassificationService classificationService=new ClassificationService(event.getGraphContext());
            JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
            classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
          }
          estimate.addWork(1);
          printProgressEstimate(event,estimate);
        }
      }
      if (!filesToProcess.isEmpty()) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        StringBuilder message=new StringBuilder();
        message.append(""String_Node_Str"" + filesToProcess.size() + ""String_Node_Str"");
        for (        Path unprocessed : filesToProcess) {
          JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
          message.append(""String_Node_Str"" + unprocessed + ""String_Node_Str"");
          classificationService.attachClassification(context,sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
        }
        LOG.warning(message.toString());
      }
      ExecutionStatistics.get().end(""String_Node_Str"");
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,""String_Node_Str"" + e.getMessage(),e);
    }
 finally {
      WindupWildcardImportResolver.setContext(null);
    }
  }
  finally {
    ExecutionStatistics.get().end(""String_Node_Str"");
  }
}",0.9755610972568578
109442,"@Override public void processed(Path filePath,List<ClassReference> references){
  try {
    processedPaths.put(new ImmutablePair<>(filePath,filterClassReferences(references)));
  }
 catch (  InterruptedException e) {
    throw new WindupException(e.getMessage(),e);
  }
}","@Override public void processed(Path filePath,List<ClassReference> references){
  try {
    processedPaths.put(new ImmutablePair<>(filePath,filterClassReferences(references,classNotFoundAnalysisEnabled)));
  }
 catch (  InterruptedException e) {
    throw new WindupException(e.getMessage(),e);
  }
}",0.9492119089316988
109443,"private List<ClassReference> filterClassReferences(List<ClassReference> references){
  List<ClassReference> results=new ArrayList<>(references.size());
  for (  ClassReference reference : references) {
    boolean shouldKeep=reference.getLocation() == TypeReferenceLocation.TYPE;
    shouldKeep|=reference.getResolutionStatus() != ResolutionStatus.RESOLVED;
    shouldKeep|=TypeInterestFactory.matchesAny(reference.getQualifiedName(),reference.getLocation());
    if (shouldKeep) {
      results.add(reference);
    }
  }
  return results;
}","private List<ClassReference> filterClassReferences(List<ClassReference> references,boolean classNotFoundAnalysisEnabled){
  List<ClassReference> results=new ArrayList<>(references.size());
  for (  ClassReference reference : references) {
    boolean shouldKeep=reference.getLocation() == TypeReferenceLocation.TYPE;
    shouldKeep|=classNotFoundAnalysisEnabled && reference.getResolutionStatus() != ResolutionStatus.RESOLVED;
    shouldKeep|=TypeInterestFactory.matchesAny(reference.getQualifiedName(),reference.getLocation());
    if (shouldKeep) {
      results.add(reference);
    }
  }
  return results;
}",0.94005212858384
109444,"@Override public Configuration getConfiguration(GraphContext context){
  return ConfigurationBuilder.begin().addRule().perform(new AttachHintOperation()).withId(RULE_ID);
}","@Override public Configuration getConfiguration(GraphContext context){
  return ConfigurationBuilder.begin().addRule().when(Query.fromType(WindupJavaConfigurationModel.class).withProperty(WindupJavaConfigurationModel.CLASS_NOT_FOUND_ANALYSIS_ENABLED,true)).perform(new AttachHintOperation()).withId(RULE_ID);
}",0.7136929460580913
109445,"@Override public Configuration getConfiguration(GraphContext context){
  GraphOperation copyConfigToGraph=new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      Map<String,Object> config=event.getGraphContext().getOptionMap();
      Boolean sourceMode=(Boolean)config.get(SourceModeOption.NAME);
      @SuppressWarnings(""String_Node_Str"") List<String> includeJavaPackages=(List<String>)config.get(ScanPackagesOption.NAME);
      @SuppressWarnings(""String_Node_Str"") final List<String> excludeJavaPackages;
      if (config.get(ExcludePackagesOption.NAME) == null)       excludeJavaPackages=new ArrayList<>();
 else       excludeJavaPackages=new ArrayList<>((List<String>)config.get(ExcludePackagesOption.NAME));
      Predicate<File> predicate=new FileSuffixPredicate(""String_Node_Str"");
      Visitor<File> visitor=new Visitor<File>(){
        @Override public void visit(        File file){
          try (FileInputStream inputStream=new FileInputStream(file)){
            LineIterator it=IOUtils.lineIterator(inputStream,""String_Node_Str"");
            while (it.hasNext()) {
              String line=it.next();
              if (!line.startsWith(""String_Node_Str"") && !line.trim().isEmpty()) {
                excludeJavaPackages.add(line);
              }
            }
          }
 catch (          Exception e) {
            throw new WindupException(""String_Node_Str"" + file.toString() + ""String_Node_Str"",e);
          }
        }
      }
;
      FileVisit.visit(PathUtil.getUserIgnoreDir().toFile(),predicate,visitor);
      FileVisit.visit(PathUtil.getWindupIgnoreDir().toFile(),predicate,visitor);
      WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
      javaConfiguration.setSourceMode(sourceMode == null ? false : sourceMode);
      javaConfiguration.setScanJavaPackageList(includeJavaPackages);
      javaConfiguration.setExcludeJavaPackageList(excludeJavaPackages);
      List<File> additionalClasspaths=(List<File>)config.get(AdditionalClasspathOption.NAME);
      if (additionalClasspaths != null) {
        FileService fileService=new FileService(event.getGraphContext());
        for (        File file : additionalClasspaths) {
          FileModel fileModel=fileService.createByFilePath(file.getAbsolutePath());
          javaConfiguration.addAdditionalClasspath(fileModel);
        }
      }
    }
  }
;
  return ConfigurationBuilder.begin().addRule().perform(copyConfigToGraph);
}","@Override public Configuration getConfiguration(GraphContext context){
  GraphOperation copyConfigToGraph=new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      Map<String,Object> config=event.getGraphContext().getOptionMap();
      Boolean sourceMode=(Boolean)config.get(SourceModeOption.NAME);
      Boolean enableClassFoundFoundAnalysis=(Boolean)config.get(EnableClassNotFoundAnalysisOption.NAME);
      @SuppressWarnings(""String_Node_Str"") List<String> includeJavaPackages=(List<String>)config.get(ScanPackagesOption.NAME);
      @SuppressWarnings(""String_Node_Str"") final List<String> excludeJavaPackages;
      if (config.get(ExcludePackagesOption.NAME) == null)       excludeJavaPackages=new ArrayList<>();
 else       excludeJavaPackages=new ArrayList<>((List<String>)config.get(ExcludePackagesOption.NAME));
      Predicate<File> predicate=new FileSuffixPredicate(""String_Node_Str"");
      Visitor<File> visitor=new Visitor<File>(){
        @Override public void visit(        File file){
          try (FileInputStream inputStream=new FileInputStream(file)){
            LineIterator it=IOUtils.lineIterator(inputStream,""String_Node_Str"");
            while (it.hasNext()) {
              String line=it.next();
              if (!line.startsWith(""String_Node_Str"") && !line.trim().isEmpty()) {
                excludeJavaPackages.add(line);
              }
            }
          }
 catch (          Exception e) {
            throw new WindupException(""String_Node_Str"" + file.toString() + ""String_Node_Str"",e);
          }
        }
      }
;
      FileVisit.visit(PathUtil.getUserIgnoreDir().toFile(),predicate,visitor);
      FileVisit.visit(PathUtil.getWindupIgnoreDir().toFile(),predicate,visitor);
      WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
      javaConfiguration.setSourceMode(sourceMode == null ? false : sourceMode);
      javaConfiguration.setScanJavaPackageList(includeJavaPackages);
      javaConfiguration.setExcludeJavaPackageList(excludeJavaPackages);
      javaConfiguration.setClassNotFoundAnalysisEnabled(enableClassFoundFoundAnalysis == null ? false : enableClassFoundFoundAnalysis);
      List<File> additionalClasspaths=(List<File>)config.get(AdditionalClasspathOption.NAME);
      if (additionalClasspaths != null) {
        FileService fileService=new FileService(event.getGraphContext());
        for (        File file : additionalClasspaths) {
          FileModel fileModel=fileService.createByFilePath(file.getAbsolutePath());
          javaConfiguration.addAdditionalClasspath(fileModel);
        }
      }
    }
  }
;
  return ConfigurationBuilder.begin().addRule().perform(copyConfigToGraph);
}",0.8666043030869972
109446,"@Override public void perform(GraphRewrite event,EvaluationContext context){
  Map<String,Object> config=event.getGraphContext().getOptionMap();
  Boolean sourceMode=(Boolean)config.get(SourceModeOption.NAME);
  @SuppressWarnings(""String_Node_Str"") List<String> includeJavaPackages=(List<String>)config.get(ScanPackagesOption.NAME);
  @SuppressWarnings(""String_Node_Str"") final List<String> excludeJavaPackages;
  if (config.get(ExcludePackagesOption.NAME) == null)   excludeJavaPackages=new ArrayList<>();
 else   excludeJavaPackages=new ArrayList<>((List<String>)config.get(ExcludePackagesOption.NAME));
  Predicate<File> predicate=new FileSuffixPredicate(""String_Node_Str"");
  Visitor<File> visitor=new Visitor<File>(){
    @Override public void visit(    File file){
      try (FileInputStream inputStream=new FileInputStream(file)){
        LineIterator it=IOUtils.lineIterator(inputStream,""String_Node_Str"");
        while (it.hasNext()) {
          String line=it.next();
          if (!line.startsWith(""String_Node_Str"") && !line.trim().isEmpty()) {
            excludeJavaPackages.add(line);
          }
        }
      }
 catch (      Exception e) {
        throw new WindupException(""String_Node_Str"" + file.toString() + ""String_Node_Str"",e);
      }
    }
  }
;
  FileVisit.visit(PathUtil.getUserIgnoreDir().toFile(),predicate,visitor);
  FileVisit.visit(PathUtil.getWindupIgnoreDir().toFile(),predicate,visitor);
  WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
  javaConfiguration.setSourceMode(sourceMode == null ? false : sourceMode);
  javaConfiguration.setScanJavaPackageList(includeJavaPackages);
  javaConfiguration.setExcludeJavaPackageList(excludeJavaPackages);
  List<File> additionalClasspaths=(List<File>)config.get(AdditionalClasspathOption.NAME);
  if (additionalClasspaths != null) {
    FileService fileService=new FileService(event.getGraphContext());
    for (    File file : additionalClasspaths) {
      FileModel fileModel=fileService.createByFilePath(file.getAbsolutePath());
      javaConfiguration.addAdditionalClasspath(fileModel);
    }
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context){
  Map<String,Object> config=event.getGraphContext().getOptionMap();
  Boolean sourceMode=(Boolean)config.get(SourceModeOption.NAME);
  Boolean enableClassFoundFoundAnalysis=(Boolean)config.get(EnableClassNotFoundAnalysisOption.NAME);
  @SuppressWarnings(""String_Node_Str"") List<String> includeJavaPackages=(List<String>)config.get(ScanPackagesOption.NAME);
  @SuppressWarnings(""String_Node_Str"") final List<String> excludeJavaPackages;
  if (config.get(ExcludePackagesOption.NAME) == null)   excludeJavaPackages=new ArrayList<>();
 else   excludeJavaPackages=new ArrayList<>((List<String>)config.get(ExcludePackagesOption.NAME));
  Predicate<File> predicate=new FileSuffixPredicate(""String_Node_Str"");
  Visitor<File> visitor=new Visitor<File>(){
    @Override public void visit(    File file){
      try (FileInputStream inputStream=new FileInputStream(file)){
        LineIterator it=IOUtils.lineIterator(inputStream,""String_Node_Str"");
        while (it.hasNext()) {
          String line=it.next();
          if (!line.startsWith(""String_Node_Str"") && !line.trim().isEmpty()) {
            excludeJavaPackages.add(line);
          }
        }
      }
 catch (      Exception e) {
        throw new WindupException(""String_Node_Str"" + file.toString() + ""String_Node_Str"",e);
      }
    }
  }
;
  FileVisit.visit(PathUtil.getUserIgnoreDir().toFile(),predicate,visitor);
  FileVisit.visit(PathUtil.getWindupIgnoreDir().toFile(),predicate,visitor);
  WindupJavaConfigurationModel javaConfiguration=WindupJavaConfigurationService.getJavaConfigurationModel(event.getGraphContext());
  javaConfiguration.setSourceMode(sourceMode == null ? false : sourceMode);
  javaConfiguration.setScanJavaPackageList(includeJavaPackages);
  javaConfiguration.setExcludeJavaPackageList(excludeJavaPackages);
  javaConfiguration.setClassNotFoundAnalysisEnabled(enableClassFoundFoundAnalysis == null ? false : enableClassFoundFoundAnalysis);
  List<File> additionalClasspaths=(List<File>)config.get(AdditionalClasspathOption.NAME);
  if (additionalClasspaths != null) {
    FileService fileService=new FileService(event.getGraphContext());
    for (    File file : additionalClasspaths) {
      FileModel fileModel=fileService.createByFilePath(file.getAbsolutePath());
      javaConfiguration.addAdditionalClasspath(fileModel);
    }
  }
}",0.8506906380179785
109447,"@Test public void testResolutionStatus() throws IOException, InstantiationException, IllegalAccessException {
  try (GraphContext context=factory.create(getDefaultPath())){
    final String inputDir=""String_Node_Str"";
    final Path outputPath=Paths.get(FileUtils.getTempDirectory().toString(),""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    Path rulesPath=FileUtils.getTempDirectory().toPath().resolve(""String_Node_Str"").resolve(""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    System.out.println(""String_Node_Str"" + rulesPath);
    Files.createDirectories(rulesPath);
    try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"" + METADATA_FILENAME);OutputStream os=new FileOutputStream(rulesPath.resolve(METADATA_FILENAME).toFile())){
      IOUtils.copy(is,os);
    }
     Path rulesLibPath=rulesPath.resolve(""String_Node_Str"");
    Files.createDirectories(rulesLibPath);
    try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"" + JAR_FILENAME);OutputStream os=new FileOutputStream(rulesLibPath.resolve(JAR_FILENAME).toFile())){
      IOUtils.copy(is,os);
    }
     WindupConfigurationModel windupConfigurationModel=WindupConfigurationService.getConfigurationModel(context);
    windupConfigurationModel.addUserRulesPath(new FileService(context).createByFilePath(rulesPath.toString()));
    processorConfig.setOptionValue(TargetOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    Assert.assertTrue(typeReferences.iterator().hasNext());
    boolean nioPathResolved=false;
    boolean fileUtilsResolved=false;
    boolean fileModelRecovered=false;
    for (    JavaTypeReferenceModel typeReference : typeReferences) {
      if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str""))       Assert.fail(""String_Node_Str"");
      if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() != ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         nioPathResolved=true;
      }
 else       if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() != ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         fileUtilsResolved=true;
      }
 else       if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() == ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         fileModelRecovered=true;
      }
    }
    Assert.assertTrue(nioPathResolved);
    Assert.assertTrue(fileUtilsResolved);
    Assert.assertTrue(fileModelRecovered);
  }
 }","@Test public void testResolutionStatus() throws IOException, InstantiationException, IllegalAccessException {
  try (GraphContext context=factory.create(getDefaultPath())){
    final String inputDir=""String_Node_Str"";
    final Path outputPath=Paths.get(FileUtils.getTempDirectory().toString(),""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    Path rulesPath=FileUtils.getTempDirectory().toPath().resolve(""String_Node_Str"").resolve(""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    System.out.println(""String_Node_Str"" + rulesPath);
    Files.createDirectories(rulesPath);
    try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"" + METADATA_FILENAME);OutputStream os=new FileOutputStream(rulesPath.resolve(METADATA_FILENAME).toFile())){
      IOUtils.copy(is,os);
    }
     Path rulesLibPath=rulesPath.resolve(""String_Node_Str"");
    Files.createDirectories(rulesLibPath);
    try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"" + JAR_FILENAME);OutputStream os=new FileOutputStream(rulesLibPath.resolve(JAR_FILENAME).toFile())){
      IOUtils.copy(is,os);
    }
     WindupConfigurationModel windupConfigurationModel=WindupConfigurationService.getConfigurationModel(context);
    windupConfigurationModel.addUserRulesPath(new FileService(context).createByFilePath(rulesPath.toString()));
    processorConfig.setOptionValue(TargetOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setOptionValue(EnableClassNotFoundAnalysisOption.NAME,true);
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    Assert.assertTrue(typeReferences.iterator().hasNext());
    boolean nioPathResolved=false;
    boolean fileUtilsResolved=false;
    boolean fileModelRecovered=false;
    for (    JavaTypeReferenceModel typeReference : typeReferences) {
      if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str""))       Assert.fail(""String_Node_Str"");
      if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() != ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         nioPathResolved=true;
      }
 else       if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() != ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         fileUtilsResolved=true;
      }
 else       if (typeReference.getResolvedSourceSnippit().equals(""String_Node_Str"")) {
        if (typeReference.getResolutionStatus() == ResolutionStatus.RESOLVED)         Assert.fail(""String_Node_Str"");
 else         fileModelRecovered=true;
      }
    }
    Assert.assertTrue(nioPathResolved);
    Assert.assertTrue(fileUtilsResolved);
    Assert.assertTrue(fileModelRecovered);
  }
 }",0.9881526985519964
109448,"@Test public void testJavaClassCondition() throws IOException, InstantiationException, IllegalAccessException {
  final Path outputPath=getDefaultPath();
  try (GraphContext context=factory.create(outputPath)){
    final String inputDir=""String_Node_Str"";
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setRuleProviderFilter(new NotPredicate(new EnumeratedRuleProviderPredicate(FindUnboundJavaReferencesRuleProvider.class)));
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    int count=0;
    for (    JavaTypeReferenceModel ref : typeReferences) {
      String sourceSnippit=ref.getResolvedSourceSnippit();
      if (sourceSnippit.contains(""String_Node_Str""))       count++;
    }
    Assert.assertTrue(count > 9);
    GraphService<InlineHintModel> hintService=new GraphService<>(context,InlineHintModel.class);
    Iterable<InlineHintModel> hints=hintService.findAll();
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str""))       count++;
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        if (hint.getFileLocationReference().getSourceSnippit().contains(""String_Node_Str"")) {
          Assert.assertTrue(hint.getHint().contains(""String_Node_Str""));
          count++;
        }
 else         Assert.fail(""String_Node_Str"");
      }
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        if (hint.getFileLocationReference().getSourceSnippit().contains(""String_Node_Str""))         count++;
 else         Assert.fail(""String_Node_Str"");
      }
    }
    Assert.assertEquals(1,count);
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        Assert.fail(""String_Node_Str"");
      }
    }
  }
 }","@Test public void testJavaClassCondition() throws IOException, InstantiationException, IllegalAccessException {
  final Path outputPath=getDefaultPath();
  try (GraphContext context=factory.create(outputPath)){
    final String inputDir=""String_Node_Str"";
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processorConfig.setOptionValue(EnableClassNotFoundAnalysisOption.NAME,true);
    processorConfig.setRuleProviderFilter(new NotPredicate(new EnumeratedRuleProviderPredicate(FindUnboundJavaReferencesRuleProvider.class)));
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    int count=0;
    for (    JavaTypeReferenceModel ref : typeReferences) {
      String sourceSnippit=ref.getResolvedSourceSnippit();
      if (sourceSnippit.contains(""String_Node_Str""))       count++;
    }
    Assert.assertTrue(count > 9);
    GraphService<InlineHintModel> hintService=new GraphService<>(context,InlineHintModel.class);
    Iterable<InlineHintModel> hints=hintService.findAll();
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str""))       count++;
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        if (hint.getFileLocationReference().getSourceSnippit().contains(""String_Node_Str"")) {
          Assert.assertTrue(hint.getHint().contains(""String_Node_Str""));
          count++;
        }
 else         Assert.fail(""String_Node_Str"");
      }
    }
    Assert.assertEquals(1,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        if (hint.getFileLocationReference().getSourceSnippit().contains(""String_Node_Str""))         count++;
 else         Assert.fail(""String_Node_Str"");
      }
    }
    Assert.assertEquals(1,count);
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str"")) {
        Assert.fail(""String_Node_Str"");
      }
    }
  }
 }",0.984281001358432
109449,"public Tag1SourceGlassfishRuleProvider(){
  super(MetadataBuilder.forProvider(Tag1SourceGlassfishRuleProvider.class).addTag(""String_Node_Str"").addSourceTechnology(new TechnologyReference(""String_Node_Str"",""String_Node_Str"")));
}","public Tag1SourceGlassfishRuleProvider(){
  super(MetadataBuilder.forProvider(Tag1SourceGlassfishRuleProvider.class).addTag(""String_Node_Str"").addSourceTechnology(new TechnologyReference(""String_Node_Str"",""String_Node_Str"")).addTargetTechnology(new TechnologyReference(""String_Node_Str"",""String_Node_Str"")));
}",0.8475836431226765
109450,"public Tag3SourceOrionServerRuleProvider(){
  super(MetadataBuilder.forProvider(Tag3SourceOrionServerRuleProvider.class).addTag(""String_Node_Str"").addSourceTechnology(new TechnologyReference(""String_Node_Str"",""String_Node_Str"")));
}","public Tag3SourceOrionServerRuleProvider(){
  super(MetadataBuilder.forProvider(Tag3SourceOrionServerRuleProvider.class).addTag(""String_Node_Str"").addSourceTechnology(new TechnologyReference(""String_Node_Str"",""String_Node_Str"")).addTargetTechnology(new TechnologyReference(""String_Node_Str"",""String_Node_Str"")));
}",0.8498168498168498
109451,"@Test public void testRuleFilteringExcludeTag3() throws Exception {
  setupAndRun(null,Collections.singleton(""String_Node_Str""),null,null);
  Assert.assertTrue(this.tag1SourceGlassfishRuleProvider.executed);
  Assert.assertTrue(this.tag1SourceGlassfishTargetFooRuleProvider.executed);
  Assert.assertTrue(this.tag2SourceGlassfishTargetJBossRuleProvider.executed);
  Assert.assertFalse(this.tag3SourceOrionServerRuleProvider.executed);
}","@Test public void testRuleFilteringExcludeTag3() throws Exception {
  setupAndRun(null,Collections.singleton(""String_Node_Str""),Collections.singleton(""String_Node_Str""),Collections.singleton(""String_Node_Str""));
  Assert.assertFalse(this.tag1SourceGlassfishRuleProvider.executed);
  Assert.assertTrue(this.tag1SourceGlassfishTargetFooRuleProvider.executed);
  Assert.assertFalse(this.tag2SourceGlassfishTargetJBossRuleProvider.executed);
  Assert.assertFalse(this.tag3SourceOrionServerRuleProvider.executed);
}",0.8921775898520085
109452,"private void setupAndRun(Set<String> includeTags,Set<String> excludeTags,Set<String> sources,Set<String> targets) throws Exception {
  Assert.assertNotNull(uiTestHarness);
  this.tag1SourceGlassfishRuleProvider.executed=false;
  this.tag1SourceGlassfishTargetFooRuleProvider.executed=false;
  this.tag2SourceGlassfishTargetJBossRuleProvider.executed=false;
  this.tag3SourceOrionServerRuleProvider.executed=false;
  try (CommandController controller=uiTestHarness.createCommandController(WindupCommand.class)){
    File outputFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    outputFile.deleteOnExit();
    File inputFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    inputFile.deleteOnExit();
    try (InputStream iStream=getClass().getResourceAsStream(""String_Node_Str"")){
      try (OutputStream oStream=new FileOutputStream(outputFile)){
        IOUtils.copy(iStream,oStream);
      }
     }
     File reportPath=new File(inputFile.getAbsoluteFile() + ""String_Node_Str"");
    try {
      reportPath.mkdirs();
      controller.initialize();
      Assert.assertTrue(controller.isEnabled());
      controller.setValueFor(""String_Node_Str"",inputFile);
      Assert.assertTrue(controller.canExecute());
      if (outputFile != null) {
        controller.setValueFor(""String_Node_Str"",outputFile);
      }
      Assert.assertTrue(controller.canExecute());
      if (includeTags != null) {
        controller.setValueFor(IncludeTagsOption.NAME,includeTags);
      }
      if (excludeTags != null) {
        controller.setValueFor(ExcludeTagsOption.NAME,excludeTags);
      }
      if (sources != null) {
        controller.setValueFor(SourceOption.NAME,sources);
      }
      if (targets != null) {
        controller.setValueFor(TargetOption.NAME,targets);
      }
      Result result=controller.execute();
      final String msg=""String_Node_Str"" + result.getMessage();
      Assert.assertFalse(msg,result instanceof Failed);
    }
  finally {
      inputFile.delete();
      FileUtils.deleteDirectory(reportPath);
    }
  }
 }","private void setupAndRun(Set<String> includeTags,Set<String> excludeTags,Set<String> sources,Set<String> targets) throws Exception {
  Assert.assertNotNull(uiTestHarness);
  this.tag1SourceGlassfishRuleProvider.executed=false;
  this.tag1SourceGlassfishTargetFooRuleProvider.executed=false;
  this.tag2SourceGlassfishTargetJBossRuleProvider.executed=false;
  this.tag3SourceOrionServerRuleProvider.executed=false;
  try (CommandController controller=uiTestHarness.createCommandController(WindupCommand.class)){
    File outputFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    outputFile.deleteOnExit();
    File inputFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    inputFile.deleteOnExit();
    try (InputStream iStream=getClass().getResourceAsStream(""String_Node_Str"")){
      try (OutputStream oStream=new FileOutputStream(outputFile)){
        IOUtils.copy(iStream,oStream);
      }
     }
     File reportPath=new File(inputFile.getAbsoluteFile() + ""String_Node_Str"");
    try {
      reportPath.mkdirs();
      controller.initialize();
      Assert.assertTrue(controller.isEnabled());
      controller.setValueFor(""String_Node_Str"",inputFile);
      if (outputFile != null) {
        controller.setValueFor(""String_Node_Str"",outputFile);
      }
      if (includeTags != null) {
        controller.setValueFor(IncludeTagsOption.NAME,includeTags);
      }
      if (excludeTags != null) {
        controller.setValueFor(ExcludeTagsOption.NAME,excludeTags);
      }
      if (sources != null) {
        controller.setValueFor(SourceOption.NAME,sources);
      }
      if (targets != null) {
        controller.setValueFor(TargetOption.NAME,targets);
      }
      Assert.assertTrue(controller.canExecute());
      Result result=controller.execute();
      final String msg=""String_Node_Str"" + result.getMessage();
      Assert.assertFalse(msg,result instanceof Failed);
    }
  finally {
      inputFile.delete();
      FileUtils.deleteDirectory(reportPath);
    }
  }
 }",0.9631449631449632
109453,"@Test public void testRuleFilteringSourceGlassfish() throws Exception {
  setupAndRun(null,null,Collections.singleton(""String_Node_Str""),null);
  Assert.assertTrue(this.tag1SourceGlassfishRuleProvider.executed);
  Assert.assertTrue(this.tag1SourceGlassfishTargetFooRuleProvider.executed);
  Assert.assertTrue(this.tag2SourceGlassfishTargetJBossRuleProvider.executed);
  Assert.assertFalse(this.tag3SourceOrionServerRuleProvider.executed);
}","@Test public void testRuleFilteringSourceGlassfish() throws Exception {
  setupAndRun(null,null,Collections.singleton(""String_Node_Str""),Collections.singleton(""String_Node_Str""));
  Assert.assertTrue(this.tag1SourceGlassfishRuleProvider.executed);
  Assert.assertFalse(this.tag1SourceGlassfishTargetFooRuleProvider.executed);
  Assert.assertTrue(this.tag2SourceGlassfishTargetJBossRuleProvider.executed);
  Assert.assertFalse(this.tag3SourceOrionServerRuleProvider.executed);
}",0.9443838604143948
109454,"@Test public void testRuleFilteringIncludeTag2() throws Exception {
  setupAndRun(Collections.singleton(""String_Node_Str""),null,null,null);
  Assert.assertFalse(this.tag1SourceGlassfishRuleProvider.executed);
  Assert.assertFalse(this.tag1SourceGlassfishTargetFooRuleProvider.executed);
  Assert.assertTrue(this.tag2SourceGlassfishTargetJBossRuleProvider.executed);
  Assert.assertFalse(this.tag3SourceOrionServerRuleProvider.executed);
}","@Test public void testRuleFilteringIncludeTag2() throws Exception {
  setupAndRun(Collections.singleton(""String_Node_Str""),null,null,Collections.singleton(""String_Node_Str""));
  Assert.assertFalse(this.tag1SourceGlassfishRuleProvider.executed);
  Assert.assertFalse(this.tag1SourceGlassfishTargetFooRuleProvider.executed);
  Assert.assertTrue(this.tag2SourceGlassfishTargetJBossRuleProvider.executed);
  Assert.assertFalse(this.tag3SourceOrionServerRuleProvider.executed);
}",0.9517543859649122
109455,"@Override public void perform(GraphRewrite event,EvaluationContext context,WindupConfigurationModel config){
  InlineHintService hintService=new InlineHintService(event.getGraphContext());
  ClassificationService classificationService=new ClassificationService(event.getGraphContext());
  ProjectService projectService=new ProjectService(event.getGraphContext());
  final Iterable<InlineHintModel> hints=hintService.findAll();
  final Iterable<ProjectModel> projects=projectService.findAll();
  final Iterable<ClassificationModel> classifications=classificationService.findAll();
  Map<String,CSVWriter> rootProjectWriters=new HashMap<>();
  for (  ProjectModel project : projects) {
    ProjectModel root=project.getRootProjectModel();
    if (!rootProjectWriters.containsKey(root.getName())) {
      try {
        CSVWriter writer=new CSVWriter(new FileWriter(config.getOutputPath().getFilePath() + File.separator + root.getName()+ ""String_Node_Str""),';');
        String[] headerLine=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        writer.writeNext(headerLine);
        rootProjectWriters.put(root.getName(),writer);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  try {
    for (    InlineHintModel hint : hints) {
      final ProjectModel parentRootProjectModel=hint.getFile().getProjectModel().getRootProjectModel();
      String links=buildLinkString(hint.getLinks());
      String ruleId=hint.getRuleID() != null ? hint.getRuleID() : ""String_Node_Str"";
      String title=hint.getTitle() != null ? hint.getTitle() : ""String_Node_Str"";
      String description=hint.getDescription() != null ? hint.getDescription() : ""String_Node_Str"";
      String projectNameString=""String_Node_Str"";
      String fileName=""String_Node_Str"";
      String filePath=""String_Node_Str"";
      if (hint.getFile() != null) {
        if (hint.getFile().getProjectModel() != null) {
          projectNameString=hint.getFile().getProjectModel().getName();
        }
        fileName=hint.getFile().getFileName();
        filePath=hint.getFile().getFilePath();
      }
      String[] strings=new String[]{ruleId,""String_Node_Str"",title,description,links,projectNameString,fileName,filePath,String.valueOf(hint.getLineNumber()),String.valueOf(hint.getEffort())};
      rootProjectWriters.get(parentRootProjectModel.getName()).writeNext(strings);
    }
    for (    ClassificationModel classification : classifications) {
      for (      FileModel fileModel : classification.getFileModels()) {
        final ProjectModel parentRootProjectModel=fileModel.getProjectModel().getRootProjectModel();
        String links=buildLinkString(classification.getLinks());
        String ruleId=classification.getRuleID() != null ? classification.getRuleID() : ""String_Node_Str"";
        String classifText=classification.getClassification() != null ? classification.getClassification() : ""String_Node_Str"";
        String description=classification.getDescription() != null ? classification.getDescription() : ""String_Node_Str"";
        String projectNameString=""String_Node_Str"";
        String fileName=""String_Node_Str"";
        String filePath=""String_Node_Str"";
        if (fileModel.getProjectModel() != null) {
          projectNameString=fileModel.getProjectModel().getName();
        }
        fileName=fileModel.getFileName();
        filePath=fileModel.getFilePath();
        String[] strings=new String[]{ruleId,""String_Node_Str"",classifText,description,links,projectNameString,fileName,filePath,""String_Node_Str"",String.valueOf(classification.getEffort())};
        rootProjectWriters.get(parentRootProjectModel.getName()).writeNext(strings);
      }
    }
  }
  finally {
    for (    CSVWriter csvWriter : rootProjectWriters.values()) {
      try {
        csvWriter.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,WindupConfigurationModel config){
  projectToFile=new HashMap<>();
  InlineHintService hintService=new InlineHintService(event.getGraphContext());
  String outputFolderPath=config.getOutputPath().getFilePath() + File.separator;
  ClassificationService classificationService=new ClassificationService(event.getGraphContext());
  ProjectService projectService=new ProjectService(event.getGraphContext());
  final Iterable<InlineHintModel> hints=hintService.findAll();
  final Iterable<ProjectModel> projects=projectService.findAll();
  final Iterable<ClassificationModel> classifications=classificationService.findAll();
  try {
    for (    InlineHintModel hint : hints) {
      final ProjectModel parentRootProjectModel=hint.getFile().getProjectModel().getRootProjectModel();
      String links=buildLinkString(hint.getLinks());
      String ruleId=hint.getRuleID() != null ? hint.getRuleID() : ""String_Node_Str"";
      String title=hint.getTitle() != null ? hint.getTitle() : ""String_Node_Str"";
      String description=hint.getDescription() != null ? hint.getDescription() : ""String_Node_Str"";
      String projectNameString=""String_Node_Str"";
      String fileName=""String_Node_Str"";
      String filePath=""String_Node_Str"";
      if (hint.getFile() != null) {
        if (hint.getFile().getProjectModel() != null) {
          projectNameString=hint.getFile().getProjectModel().getName();
        }
        fileName=hint.getFile().getFileName();
        filePath=hint.getFile().getFilePath();
      }
      String[] strings=new String[]{ruleId,""String_Node_Str"",title,description,links,projectNameString,fileName,filePath,String.valueOf(hint.getLineNumber()),String.valueOf(hint.getEffort())};
      writeCsvRecordForProject(outputFolderPath,parentRootProjectModel,strings);
    }
    for (    ClassificationModel classification : classifications) {
      for (      FileModel fileModel : classification.getFileModels()) {
        final ProjectModel parentRootProjectModel=fileModel.getProjectModel().getRootProjectModel();
        String links=buildLinkString(classification.getLinks());
        String ruleId=classification.getRuleID() != null ? classification.getRuleID() : ""String_Node_Str"";
        String classifText=classification.getClassification() != null ? classification.getClassification() : ""String_Node_Str"";
        String description=classification.getDescription() != null ? classification.getDescription() : ""String_Node_Str"";
        String projectNameString=""String_Node_Str"";
        String fileName=""String_Node_Str"";
        String filePath=""String_Node_Str"";
        if (fileModel.getProjectModel() != null) {
          projectNameString=fileModel.getProjectModel().getName();
        }
        fileName=fileModel.getFileName();
        filePath=fileModel.getFilePath();
        String[] strings=new String[]{ruleId,""String_Node_Str"",classifText,description,links,projectNameString,fileName,filePath,""String_Node_Str"",String.valueOf(classification.getEffort())};
        writeCsvRecordForProject(outputFolderPath,parentRootProjectModel,strings);
      }
    }
  }
  finally {
    for (    CSVWriter csvWriter : projectToFile.values()) {
      try {
        csvWriter.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}",0.2254319654427646
109456,"/** 
 * Conservative approach to insuring that a given filename only contains characters that are legal for use in filenames on the disk. Other characters are replaced with underscore _ .
 */
public static String cleanFileName(String badFileName){
  if (badFileName == null)   return null;
  StringBuilder cleanName=new StringBuilder();
  for (int i=0; i < badFileName.length(); i++) {
    int c=(int)badFileName.charAt(i);
    if (Character.isJavaIdentifierPart(c))     cleanName.append((char)c);
 else     cleanName.append('_');
  }
  return cleanName.toString();
}","/** 
 * Conservative approach to insuring that a given filename only contains characters that are legal for use in filenames on the disk. Other characters are replaced with underscore _ . Note that this should only be used with the filename itself, not the entire path, because it removes the '/' characters as well.
 */
public static String cleanFileName(String badFileName){
  if (badFileName == null)   return null;
  StringBuilder cleanName=new StringBuilder();
  for (int i=0; i < badFileName.length(); i++) {
    int c=(int)badFileName.charAt(i);
    if (Character.isJavaIdentifierPart(c))     cleanName.append((char)c);
 else     cleanName.append('_');
  }
  return cleanName.toString();
}",0.8978622327790974
109457,"@Override public void setParameterStore(ParameterStore store){
  hintTextPattern.setParameterStore(store);
}","@Override public void setParameterStore(ParameterStore store){
  hintTextPattern.setParameterStore(store);
  if (hintTitlePattern != null)   hintTitlePattern.setParameterStore(store);
}",0.7372013651877133
109458,"@Override public Set<String> getRequiredParameterNames(){
  return hintTextPattern.getRequiredParameterNames();
}","@Override public Set<String> getRequiredParameterNames(){
  final Set<String> result=new LinkedHashSet<String>();
  result.addAll(hintTextPattern.getRequiredParameterNames());
  if (hintTitlePattern != null)   result.addAll(hintTitlePattern.getRequiredParameterNames());
  return result;
}",0.527363184079602
109459,"public GraphRewrite(GraphContext context){
  this.graphContext=context;
}","public GraphRewrite(Iterable<RuleLifecycleListener> listeners,GraphContext context){
  this.listeners=listeners;
  this.graphContext=context;
}",0.6759259259259259
109460,"/** 
 * Called immediately after a a   {@link Rule} has thrown an exception, to indicate a failure of some kind
 */
public void afterRuleExecutionFailed(GraphRewrite event,EvaluationContext context,Rule rule,Throwable failureCause);","/** 
 * Called immediately after a a   {@link Rule} has thrown an exception, to indicate a failure of some kind
 */
void afterRuleExecutionFailed(GraphRewrite event,EvaluationContext context,Rule rule,Throwable failureCause);",0.9846827133479212
109461,"/** 
 * Called immediately before the given   {@link Rule} is executed.
 */
public void beforeRuleEvaluation(GraphRewrite event,Rule rule,EvaluationContext context);","/** 
 * Called immediately before the given   {@link Rule} is executed.
 */
void beforeRuleEvaluation(GraphRewrite event,Rule rule,EvaluationContext context);",0.978328173374613
109462,"/** 
 * Called immediately before   {@link Rule} operations are performed (Only called if{@link Rule#evaluate(org.ocpsoft.rewrite.event.Rewrite,EvaluationContext)} returned <code>true</code>).
 */
public void beforeRuleOperationsPerformed(GraphRewrite event,EvaluationContext context,Rule rule);","/** 
 * Called immediately before   {@link Rule} operations are performed (Only called if{@link Rule#evaluate(org.ocpsoft.rewrite.event.Rewrite,EvaluationContext)} returned <code>true</code>).
 */
void beforeRuleOperationsPerformed(GraphRewrite event,EvaluationContext context,Rule rule);",0.9879931389365352
109463,"/** 
 * Called immediately after   {@link Rule} operations are performed (Only called if{@link Rule#evaluate(org.ocpsoft.rewrite.event.Rewrite,EvaluationContext)} returned <code>true</code>).
 */
public void afterRuleOperationsPerformed(GraphRewrite event,EvaluationContext context,Rule rule);","/** 
 * Called immediately after   {@link Rule} operations are performed (Only called if{@link Rule#evaluate(org.ocpsoft.rewrite.event.Rewrite,EvaluationContext)} returned <code>true</code>).
 */
void afterRuleOperationsPerformed(GraphRewrite event,EvaluationContext context,Rule rule);",0.9879101899827288
109464,"/** 
 * Called immediately after any   {@link Rule} instances are executed.
 */
public void afterExecution(GraphRewrite event);","/** 
 * Called immediately after any   {@link Rule} instances are executed.
 */
void afterExecution(GraphRewrite event);",0.97165991902834
109465,"/** 
 * Called immediately after execution of the each   {@link Rule}.
 */
public void afterRuleConditionEvaluation(GraphRewrite event,EvaluationContext context,Rule rule,boolean result);","/** 
 * Called immediately after execution of the each   {@link Rule}.
 */
void afterRuleConditionEvaluation(GraphRewrite event,EvaluationContext context,Rule rule,boolean result);",0.9809264305177112
109466,"/** 
 * Called immediately before any   {@link Rule} instances are executed.
 */
public void beforeExecution(GraphRewrite event);","/** 
 * Called immediately before any   {@link Rule} instances are executed.
 */
void beforeExecution(GraphRewrite event);",0.9721115537848606
109467,"@Override public void perform(GraphRewrite event,EvaluationContext context,WindupVertexFrame payload){
  if (totalIterations == -1) {
    @SuppressWarnings(""String_Node_Str"") Iterable<WindupVertexFrame> frames=(Iterable<WindupVertexFrame>)event.getRewriteContext().get(Iteration.DEFAULT_VARIABLE_LIST_STRING);
    totalIterations=Iterators.asList(frames).size();
  }
  currentIteration++;
  if (currentIteration % interval == 0) {
    LOG.info(messagePrefix + currentIteration + ""String_Node_Str""+ totalIterations);
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,WindupVertexFrame payload){
  if (totalIterations == -1) {
    @SuppressWarnings(""String_Node_Str"") Iterable<WindupVertexFrame> frames=(Iterable<WindupVertexFrame>)event.getRewriteContext().get(Iteration.DEFAULT_VARIABLE_LIST_STRING);
    totalIterations=Iterators.asList(frames).size();
    progressEstimate=new ProgressEstimate(totalIterations);
  }
  progressEstimate.addWork(1);
  if (progressEstimate.getWorked() % interval == 0) {
    if (estimateTimeRemaining) {
      long remainingTimeMillis=progressEstimate.getTimeRemainingInMillis();
      if (remainingTimeMillis > 1000)       event.ruleEvaluationProgress(messagePrefix,progressEstimate.getWorked(),totalIterations,(int)remainingTimeMillis / 1000);
    }
    LOG.info(messagePrefix + ""String_Node_Str"" + progressEstimate.getWorked()+ ""String_Node_Str""+ totalIterations);
  }
}",0.6522648083623693
109468,"/** 
 * Indicates that the file at inputPath has been decompiled to outputPath
 */
public void fileDecompiled(String inputPath,String outputPath);","/** 
 * Indicates that the file at inputPath has been decompiled to outputPath
 */
void fileDecompiled(String inputPath,String outputPath);",0.975438596491228
109469,"/** 
 * Indicates that the decompilation process is complete for all files within the archive (or directory). This allows for cleanup, such as committing all results to disk.
 */
public void decompilationProcessComplete();","/** 
 * Indicates that the decompilation process is complete for all files within the archive (or directory). This allows for cleanup, such as committing all results to disk.
 */
void decompilationProcessComplete();",0.9839816933638444
109470,"/** 
 * Decompiles all .class files and nested archives in the given archive. <p> Nested archives will be decompiled into directories matching the name of the archive, e.g. <code>foo.ear/bar.jar/src/com/foo/bar/Baz.java</code>. <p> Required directories will be created as needed.
 * @param archive The archive containing source files and archives.
 * @param outputDir The directory where decompiled .java files will be placed.
 * @param filter Decides what files from the archive to decompile.
 * @param listener This is called after each successful decompilation
 */
public DecompilationResult decompileArchive(File archive,File outputDir,Filter<ZipEntry> filter,DecompilationListener listener) throws DecompilationException ;","/** 
 * Decompiles all .class files and nested archives in the given archive. <p> Nested archives will be decompiled into directories matching the name of the archive, e.g. <code>foo.ear/bar.jar/src/com/foo/bar/Baz.java</code>. <p> Required directories will be created as needed.
 * @param archive The archive containing source files and archives.
 * @param outputDir The directory where decompiled .java files will be placed.
 * @param filter Decides what files from the archive to decompile.
 * @param listener This is called after each successful decompilation
 */
public DecompilationResult decompileArchive(Path archive,Path outputDir,Filter<ZipEntry> filter,DecompilationListener listener) throws DecompilationException ;",0.9628610729023384
109471,"/** 
 * Decompiles all .class files and archives in the given directory and places results in the specified output directory. <p> Discovered archives will be decompiled into directories matching the name of the archive, e.g. <code>foo.ear/bar.jar/src/com/foo/bar/Baz.java</code>. <p> Required directories will be created as needed.
 * @param classesDir The directory containing source files and archives.
 * @param outputDir The directory where decompiled .java files will be placed.
 */
public DecompilationResult decompileDirectory(File classesDir,File outputDir) throws DecompilationException ;","/** 
 * Decompiles all .class files and archives in the given directory and places results in the specified output directory. <p> Discovered archives will be decompiled into directories matching the name of the archive, e.g. <code>foo.ear/bar.jar/src/com/foo/bar/Baz.java</code>. <p> Required directories will be created as needed.
 * @param classesDir The directory containing source files and archives.
 * @param outputDir The directory where decompiled .java files will be placed.
 */
public DecompilationResult decompileDirectory(Path classesDir,Path outputDir) throws DecompilationException ;",0.9865996649916248
109472,"/** 
 * Decompiles the given .class file and creates the specified output source file in the given output dir under appropriate package subdirectories, like $outputDir/org/jboss/Foo.java. Decompilation may need multiple .class files for one .java file, e.g. for inner classes.
 * @param classFile the .class file to be decompiled.
 * @param outputDir The directory where decompiled .java files will be placed.
 */
public DecompilationResult decompileClassFile(File rootDir,Path classFilePath,File outputDir) throws DecompilationException ;","/** 
 * Decompiles the given .class file and creates the specified output source file in the given output dir under appropriate package subdirectories, like $outputDir/org/jboss/Foo.java. Decompilation may need multiple .class files for one .java file, e.g. for inner classes.
 * @param classFile the .class file to be decompiled.
 * @param outputDir The directory where decompiled .java files will be placed.
 */
public DecompilationResult decompileClassFile(Path rootDir,Path classFilePath,Path outputDir) throws DecompilationException ;",0.9851576994434136
109473,"/** 
 * Single class.
 */
@Test public void testDecompileSingleClass() throws DecompilationException, IOException {
  final Decompiler dec=this.getDecompiler();
  File archive=new File(""String_Node_Str"");
  File decompDir=new File(testTempDir,""String_Node_Str"");
  File unzipDir=new File(testTempDir,""String_Node_Str"");
  ZipUtil.unzip(archive,unzipDir);
  Path clsFile=Paths.get(""String_Node_Str"");
  final DecompilationResult res=dec.decompileClassFile(unzipDir,clsFile,decompDir);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure e : res.getFailures()) {
      sb.append(""String_Node_Str"").append(e.getMessage());
      final Throwable cause=e.getCause();
      cause.printStackTrace();
      if (cause instanceof NullPointerException)       sb.append(""String_Node_Str"").append(cause.getStackTrace()[0]);
 else       sb.append(""String_Node_Str"").append(cause);
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.severe(sb.toString());
  }
  log.info(""String_Node_Str"" + res.getDecompiledFiles().size() + ""String_Node_Str""+ res.getFailures().size()+ ""String_Node_Str"");
  final File sampleFile=new File(decompDir,""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.getAbsolutePath(),sampleFile.exists());
  dec.close();
}","/** 
 * Single class.
 */
@Test public void testDecompileSingleClass() throws DecompilationException, IOException {
  final Decompiler dec=this.getDecompiler();
  Path archive=Paths.get(""String_Node_Str"");
  Path decompDir=testTempDir.resolve(""String_Node_Str"");
  Path unzipDir=testTempDir.resolve(""String_Node_Str"");
  ZipUtil.unzip(archive.toFile(),unzipDir.toFile());
  Path clsFile=unzipDir.resolve(""String_Node_Str"");
  final DecompilationResult res=dec.decompileClassFile(unzipDir,clsFile,decompDir);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure e : res.getFailures()) {
      sb.append(""String_Node_Str"").append(e.getMessage());
      final Throwable cause=e.getCause();
      cause.printStackTrace();
      if (cause instanceof NullPointerException)       sb.append(""String_Node_Str"").append(cause.getStackTrace()[0]);
 else       sb.append(""String_Node_Str"").append(cause);
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.severe(sb.toString());
  }
  log.info(""String_Node_Str"" + res.getDecompiledFiles().size() + ""String_Node_Str""+ res.getFailures().size()+ ""String_Node_Str"");
  final Path sampleFile=decompDir.resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.toString(),Files.exists(sampleFile));
  dec.close();
}",0.751374070481733
109474,"@Before public void setUp() throws IOException {
  this.testTempDir=new File(""String_Node_Str"");
  FileUtils.deleteQuietly(testTempDir);
  Files.createDirectory(this.testTempDir.toPath());
}","@Before public void setUp() throws IOException {
  this.testTempDir=Paths.get(""String_Node_Str"").resolve(""String_Node_Str"");
  FileUtils.deleteQuietly(testTempDir.toFile());
  Files.createDirectory(this.testTempDir);
}",0.8480392156862745
109475,"/** 
 * Decompile test .jar.
 */
@Test public void testDecompileWicketJar() throws DecompilationException {
  File archive=new File(""String_Node_Str"");
  File decompDir=new File(testTempDir,""String_Node_Str"");
  final Decompiler dec=this.getDecompiler();
  final DecompilationResult res=dec.decompileArchive(archive,decompDir,new CountClassesFilter(100),new DecompilationListener(){
    @Override public void decompilationProcessComplete(){
    }
    @Override public void fileDecompiled(    String inputPath,    String outputPath){
    }
  }
);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure dex : res.getFailures()) {
      sb.append(""String_Node_Str"").append(dex.getMessage());
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.severe(sb.toString());
  }
  log.info(""String_Node_Str"" + res.getDecompiledFiles().size() + ""String_Node_Str""+ res.getFailures().size()+ ""String_Node_Str"");
  final File sampleFile=new File(decompDir,""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.getAbsolutePath(),sampleFile.exists());
  dec.close();
}","/** 
 * Decompile test .jar.
 */
@Test public void testDecompileWicketJar() throws DecompilationException {
  Path archive=Paths.get(""String_Node_Str"");
  Path decompDir=testTempDir.resolve(""String_Node_Str"");
  final Decompiler dec=this.getDecompiler();
  final DecompilationResult res=dec.decompileArchive(archive,decompDir,new CountClassesFilter(100),new DecompilationListener(){
    @Override public void decompilationProcessComplete(){
    }
    @Override public void decompilationFailed(    String inputPath,    String message){
    }
    @Override public void fileDecompiled(    String inputPath,    String outputPath){
    }
  }
);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure dex : res.getFailures()) {
      sb.append(""String_Node_Str"").append(dex.getMessage());
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.severe(sb.toString());
  }
  log.info(""String_Node_Str"" + res.getDecompiledFiles().size() + ""String_Node_Str""+ res.getFailures().size()+ ""String_Node_Str"");
  final Path sampleFile=decompDir.resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.toString(),Files.exists(sampleFile));
  dec.close();
}",0.8047126026419136
109476,"@Test @Ignore(""String_Node_Str"") public void testDecompileWicketJarDirectory() throws DecompilationException, IOException {
  final Decompiler dec=this.getDecompiler();
  File archive=new File(""String_Node_Str"");
  File decompDir=new File(testTempDir,""String_Node_Str"");
  File unzipDir=new File(testTempDir,""String_Node_Str"");
  ZipUtil.unzipWithFilter(archive,unzipDir,new CountClassesFilter(100));
  final DecompilationResult res=dec.decompileDirectory(unzipDir,decompDir);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure dex : res.getFailures()) {
      sb.append(""String_Node_Str"").append(dex.getMessage());
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.severe(sb.toString());
  }
  log.info(""String_Node_Str"" + res.getDecompiledFiles().size() + ""String_Node_Str""+ res.getFailures().size()+ ""String_Node_Str"");
  final File sampleFile=new File(decompDir,""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.getAbsolutePath(),sampleFile.exists());
  dec.close();
}","@Test @Ignore(""String_Node_Str"") public void testDecompileWicketJarDirectory() throws DecompilationException, IOException {
  final Decompiler dec=this.getDecompiler();
  Path archive=Paths.get(""String_Node_Str"");
  Path decompDir=testTempDir.resolve(""String_Node_Str"");
  Path unzipDir=testTempDir.resolve(""String_Node_Str"");
  ZipUtil.unzipWithFilter(archive.toFile(),unzipDir.toFile(),new CountClassesFilter(100));
  final DecompilationResult res=dec.decompileDirectory(unzipDir,decompDir);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure dex : res.getFailures()) {
      sb.append(""String_Node_Str"").append(dex.getMessage());
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.severe(sb.toString());
  }
  log.info(""String_Node_Str"" + res.getDecompiledFiles().size() + ""String_Node_Str""+ res.getFailures().size()+ ""String_Node_Str"");
  final Path sampleFile=decompDir.resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"").resolve(""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile,Files.exists(sampleFile));
  dec.close();
}",0.8
109477,"private void initializeTitanIndexes(TitanGraph titanGraph){
  Set<String> defaultIndexKeys=new HashSet<>();
  Set<String> searchIndexKeys=new HashSet<>();
  Set<String> listIndexKeys=new HashSet<>();
  Set<Class<? extends WindupVertexFrame>> modelTypes=graphTypeManager.getRegisteredTypes();
  for (  Class<? extends WindupVertexFrame> type : modelTypes) {
    for (    Method method : type.getDeclaredMethods()) {
      Indexed index=method.getAnnotation(Indexed.class);
      if (index != null) {
        Property property=Annotations.getAnnotation(method,Property.class);
        if (property != null) {
switch (index.value()) {
case DEFAULT:
            defaultIndexKeys.add(property.value());
          break;
case SEARCH:
        searchIndexKeys.add(property.value());
      break;
case LIST:
    listIndexKeys.add(property.value());
  break;
default :
break;
}
}
}
}
}
listIndexKeys.add(WindupVertexFrame.TYPE_PROP);
log.info(""String_Node_Str"" + defaultIndexKeys.size() + ""String_Node_Str""+ defaultIndexKeys);
TitanManagement titan=titanGraph.getManagementSystem();
for (String key : defaultIndexKeys) {
PropertyKey propKey=titan.makePropertyKey(key).dataType(String.class).cardinality(Cardinality.SINGLE).make();
titan.buildIndex(key,Vertex.class).addKey(propKey).buildCompositeIndex();
}
for (String key : searchIndexKeys) {
PropertyKey propKey=titan.makePropertyKey(key).dataType(String.class).cardinality(Cardinality.SINGLE).make();
titan.buildIndex(key,Vertex.class).addKey(propKey).buildMixedIndex(""String_Node_Str"");
}
for (String key : listIndexKeys) {
PropertyKey propKey=titan.makePropertyKey(key).dataType(String.class).cardinality(Cardinality.LIST).make();
titan.buildIndex(key,Vertex.class).addKey(propKey).buildCompositeIndex();
}
titan.commit();
}","private void initializeTitanIndexes(TitanGraph titanGraph){
  Set<String> defaultIndexKeys=new HashSet<>();
  Set<String> searchIndexKeys=new HashSet<>();
  Set<String> listIndexKeys=new HashSet<>();
  Set<Class<? extends WindupVertexFrame>> modelTypes=graphTypeManager.getRegisteredTypes();
  for (  Class<? extends WindupVertexFrame> type : modelTypes) {
    for (    Method method : type.getDeclaredMethods()) {
      Indexed index=method.getAnnotation(Indexed.class);
      if (index != null) {
        Property property=Annotations.getAnnotation(method,Property.class);
        if (property != null) {
switch (index.value()) {
case DEFAULT:
            defaultIndexKeys.add(property.value());
          break;
case SEARCH:
        searchIndexKeys.add(property.value());
      break;
case LIST:
    listIndexKeys.add(property.value());
  break;
default :
break;
}
}
}
}
}
listIndexKeys.add(WindupVertexFrame.TYPE_PROP);
log.info(""String_Node_Str"" + defaultIndexKeys.size() + ""String_Node_Str""+ defaultIndexKeys);
log.info(""String_Node_Str"" + searchIndexKeys.size() + ""String_Node_Str""+ searchIndexKeys);
log.info(""String_Node_Str"" + listIndexKeys.size() + ""String_Node_Str""+ listIndexKeys);
TitanManagement titan=titanGraph.getManagementSystem();
for (String key : defaultIndexKeys) {
PropertyKey propKey=titan.makePropertyKey(key).dataType(String.class).cardinality(Cardinality.SINGLE).make();
titan.buildIndex(key,Vertex.class).addKey(propKey).buildCompositeIndex();
}
for (String key : searchIndexKeys) {
PropertyKey propKey=titan.makePropertyKey(key).dataType(String.class).cardinality(Cardinality.SINGLE).make();
titan.buildIndex(key,Vertex.class).addKey(propKey,Mapping.STRING.getParameter()).buildMixedIndex(""String_Node_Str"");
}
for (String key : listIndexKeys) {
PropertyKey propKey=titan.makePropertyKey(key).dataType(String.class).cardinality(Cardinality.LIST).make();
titan.buildIndex(key,Vertex.class).addKey(propKey).buildCompositeIndex();
}
titan.commit();
}",0.9444741057127602
109478,"/** 
 * Gets the snippit referenced by this   {@link FileLocationModel}.
 */
@Indexed(IndexType.SEARCH) @Property(SOURCE_SNIPPIT) void setSourceSnippit(String source);","/** 
 * Gets the snippit referenced by this   {@link FileLocationModel}.
 */
@Property(SOURCE_SNIPPIT) void setSourceSnippit(String source);",0.9120521172638436
109479,"@Override public void perform(GraphRewrite event,EvaluationContext context,ProjectModel payload){
  GraphContext graphContext=event.getGraphContext();
  GraphService<OverviewReportLineMessageModel> overviewLineService=new GraphService<OverviewReportLineMessageModel>(graphContext,OverviewReportLineMessageModel.class);
  OverviewReportLineMessageModel overviewLine=overviewLineService.create();
  overviewLine.setMessage(message);
  overviewLine.setProject(payload);
  overviewLine.setRuleID(((Rule)context.get(Rule.class)).getId());
}","@Override public void perform(GraphRewrite event,EvaluationContext context,ProjectModel payload){
  GraphContext graphContext=event.getGraphContext();
  GraphService<OverviewReportLineMessageModel> overviewLineService=new GraphService<>(graphContext,OverviewReportLineMessageModel.class);
  OverviewReportLineMessageModel overviewLine=overviewLineService.create();
  overviewLine.setMessage(message);
  overviewLine.setProject(payload);
  overviewLine.setRuleID(((Rule)context.get(Rule.class)).getId());
}",0.971153846153846
109480,"private ApplicationReportModel createApplicationReport(GraphContext context,ProjectModel projectModel){
  ApplicationReportModel applicationReportModel=context.getFramed().addVertex(null,ApplicationReportModel.class);
  applicationReportModel.setReportPriority(100);
  applicationReportModel.setDisplayInApplicationReportIndex(true);
  applicationReportModel.setReportName(OVERVIEW);
  applicationReportModel.setReportIconClass(""String_Node_Str"");
  applicationReportModel.setMainApplicationReport(true);
  applicationReportModel.setProjectModel(projectModel);
  applicationReportModel.setTemplatePath(TEMPLATE_APPLICATION_REPORT);
  applicationReportModel.setTemplateType(TemplateType.FREEMARKER);
  applicationReportModel.setDisplayInApplicationList(true);
  GraphService<OverviewReportLineMessageModel> lineNotesService=new GraphService<OverviewReportLineMessageModel>(context,OverviewReportLineMessageModel.class);
  Iterable<OverviewReportLineMessageModel> findAll=lineNotesService.findAll();
  for (  OverviewReportLineMessageModel find : findAll) {
    String projectPrettyPath=projectModel.getRootFileModel().getPrettyPath();
    if (projectPrettyPath == null) {
      throw new WindupException(""String_Node_Str"" + projectModel + ""String_Node_Str"");
    }
    ProjectModel project=find.getProject();
    boolean found=false;
    while (project != null && !found) {
      if (project.getRootFileModel() == null) {
        throw new WindupException(""String_Node_Str"" + project + ""String_Node_Str"");
      }
      if (projectPrettyPath.equals(project.getRootFileModel().getPrettyPath())) {
        applicationReportModel.addApplicationReportLine(find);
        found=true;
      }
 else {
        project=project.getParentProject();
      }
    }
  }
  ReportService reportService=new ReportService(context);
  reportService.setUniqueFilename(applicationReportModel,projectModel.getName(),""String_Node_Str"");
  return applicationReportModel;
}","private ApplicationReportModel createApplicationReport(GraphContext context,ProjectModel projectModel){
  ApplicationReportModel applicationReportModel=context.getFramed().addVertex(null,ApplicationReportModel.class);
  applicationReportModel.setReportPriority(100);
  applicationReportModel.setDisplayInApplicationReportIndex(true);
  applicationReportModel.setReportName(OVERVIEW);
  applicationReportModel.setReportIconClass(""String_Node_Str"");
  applicationReportModel.setMainApplicationReport(true);
  applicationReportModel.setProjectModel(projectModel);
  applicationReportModel.setTemplatePath(TEMPLATE_APPLICATION_REPORT);
  applicationReportModel.setTemplateType(TemplateType.FREEMARKER);
  applicationReportModel.setDisplayInApplicationList(true);
  GraphService<OverviewReportLineMessageModel> lineNotesService=new GraphService<>(context,OverviewReportLineMessageModel.class);
  Iterable<OverviewReportLineMessageModel> allLines=lineNotesService.findAll();
  Set<String> dupeCheck=new HashSet<>();
  for (  OverviewReportLineMessageModel line : allLines) {
    if (dupeCheck.contains(line.getMessage()))     continue;
    String projectPrettyPath=projectModel.getRootFileModel().getPrettyPath();
    if (projectPrettyPath == null) {
      throw new WindupException(""String_Node_Str"" + projectModel + ""String_Node_Str"");
    }
    ProjectModel project=line.getProject();
    boolean found=false;
    while (project != null && !found) {
      if (project.getRootFileModel() == null) {
        throw new WindupException(""String_Node_Str"" + project + ""String_Node_Str"");
      }
      if (projectPrettyPath.equals(project.getRootFileModel().getPrettyPath())) {
        dupeCheck.add(line.getMessage());
        applicationReportModel.addApplicationReportLine(line);
        found=true;
      }
 else {
        project=project.getParentProject();
      }
    }
  }
  ReportService reportService=new ReportService(context);
  reportService.setUniqueFilename(applicationReportModel,projectModel.getName(),""String_Node_Str"");
  return applicationReportModel;
}",0.9322033898305084
109481,"/** 
 * Contains the   {@link TypeReferenceLocation} location referred to by this {@link Vertex}.
 */
@Property(REFERENCE_TYPE) void setReferenceLocation(TypeReferenceLocation type);","/** 
 * Contains the   {@link TypeReferenceLocation} location referred to by this {@link Vertex}.
 */
@Property(REFERENCE_TYPE) @Indexed(IndexType.SEARCH) void setReferenceLocation(TypeReferenceLocation type);",0.9309462915601024
109482,"/** 
 * Gets the snippit referenced by this   {@link FileLocationModel}.
 */
@Property(RESOLVED_SOURCE_SNIPPIT) void setResolvedSourceSnippit(String source);","/** 
 * Gets the snippit referenced by this   {@link FileLocationModel}.
 */
@Property(RESOLVED_SOURCE_SNIPPIT) @Indexed(IndexType.SEARCH) void setResolvedSourceSnippit(String source);",0.9208211143695014
109483,"@Deployment @Dependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static ForgeArchive getDeployment(){
  final ForgeArchive archive=ShrinkWrap.create(ForgeArchive.class).addBeansXML().addAsAddonDependencies(AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""));
  return archive;
}","@Deployment @AddonDependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static AddonArchive getDeployment(){
  return ShrinkWrap.create(AddonArchive.class).addBeansXML();
}",0.6537842190016103
109484,"@Test public void testSkippedArchivesFound() throws Exception {
  try (GraphContext graphContext=contextFactory.create()){
    FileUtils.deleteDirectory(OUTPUT_PATH.toFile());
    InMemoryArchiveIdentificationService inMemoryIdentifier=new InMemoryArchiveIdentificationService();
    inMemoryIdentifier.addMapping(""String_Node_Str"",LOG4J_COORDINATE);
    InMemoryArchiveIdentificationService identificationService=new InMemoryArchiveIdentificationService();
    identificationService.addMappingsFrom(new File(""String_Node_Str""));
    identifier.addIdentifier(inMemoryIdentifier);
    identifier.addIdentifier(identificationService);
    SkippedArchives.add(""String_Node_Str"");
    WindupConfiguration config=new WindupConfiguration();
    config.setGraphContext(graphContext);
    config.setInputPath(INPUT_PATH);
    config.setOutputDirectory(OUTPUT_PATH);
    config.setOptionValue(OverwriteOption.NAME,true);
    config.setRuleProviderFilter(new NotPredicate(new RuleProviderPhasePredicate(DecompilationPhase.class,MigrationRulesPhase.class,ReportGenerationPhase.class,ReportRenderingPhase.class)));
    processor.execute(config);
    GraphService<IgnoredArchiveModel> archiveService=new GraphService<>(graphContext,IgnoredArchiveModel.class);
    Iterable<IgnoredArchiveModel> archives=archiveService.findAllByProperty(IgnoredArchiveModel.FILE_NAME,""String_Node_Str"");
    Assert.assertTrue(archives.iterator().hasNext());
    for (    IgnoredArchiveModel archive : archives) {
      Assert.assertNotNull(archive);
      Assert.assertTrue(archive instanceof IdentifiedArchiveModel);
      ArchiveCoordinateModel archiveCoordinate=((IdentifiedArchiveModel)archive).getCoordinate();
      Assert.assertNotNull(archiveCoordinate);
      final Coordinate expected=CoordinateBuilder.create(LOG4J_COORDINATE);
      final CoordinateBuilder actual=CoordinateBuilder.create().setGroupId(archiveCoordinate.getGroupId()).setArtifactId(archiveCoordinate.getArtifactId()).setPackaging(archiveCoordinate.getPackaging()).setClassifier(archiveCoordinate.getClassifier()).setVersion(archiveCoordinate.getVersion());
      Assert.assertEquals(expected.toString(),actual.toString());
    }
  }
 }","@Test public void testSkippedArchivesFound() throws Exception {
  try (GraphContext graphContext=contextFactory.create()){
    FileUtils.deleteDirectory(OUTPUT_PATH.toFile());
    InMemoryArchiveIdentificationService inMemoryIdentifier=new InMemoryArchiveIdentificationService();
    inMemoryIdentifier.addMapping(""String_Node_Str"",LOG4J_COORDINATE);
    InMemoryArchiveIdentificationService identificationService=new InMemoryArchiveIdentificationService();
    identificationService.addMappingsFrom(new File(""String_Node_Str""));
    identifier.addIdentifier(inMemoryIdentifier);
    identifier.addIdentifier(identificationService);
    SkippedArchives.add(""String_Node_Str"");
    WindupConfiguration config=new WindupConfiguration();
    config.setGraphContext(graphContext);
    config.setInputPath(INPUT_PATH);
    config.setOutputDirectory(OUTPUT_PATH);
    config.setOptionValue(OverwriteOption.NAME,true);
    config.setRuleProviderFilter(new NotPredicate(new RuleProviderPhasePredicate(DecompilationPhase.class,MigrationRulesPhase.class,ReportGenerationPhase.class,ReportRenderingPhase.class)));
    processor.execute(config);
    GraphService<IgnoredArchiveModel> archiveService=new GraphService<>(graphContext,IgnoredArchiveModel.class);
    Iterable<IgnoredArchiveModel> archives=archiveService.findAllByProperty(IgnoredArchiveModel.FILE_NAME,""String_Node_Str"");
    Assert.assertTrue(archives.iterator().hasNext());
    for (    IgnoredArchiveModel archive : archives) {
      if (archive.isDirectory())       continue;
      Assert.assertNotNull(archive);
      Assert.assertTrue(archive instanceof IdentifiedArchiveModel);
      ArchiveCoordinateModel archiveCoordinate=((IdentifiedArchiveModel)archive).getCoordinate();
      Assert.assertNotNull(archiveCoordinate);
      final Coordinate expected=CoordinateBuilder.create(LOG4J_COORDINATE);
      final CoordinateBuilder actual=CoordinateBuilder.create().setGroupId(archiveCoordinate.getGroupId()).setArtifactId(archiveCoordinate.getArtifactId()).setPackaging(archiveCoordinate.getPackaging()).setClassifier(archiveCoordinate.getClassifier()).setVersion(archiveCoordinate.getVersion());
      Assert.assertEquals(expected.toString(),actual.toString());
    }
  }
 }",0.988896442329481
109485,"@Override public void perform(GraphRewrite event,EvaluationContext context,ArchiveModel payload){
  List<FileModel> licenseFiles=findLicense(payload);
  if (licenseFiles.size() == 0) {
    return;
  }
  TechnologyTagService technologyTagService=new TechnologyTagService(event.getGraphContext());
  ClassificationService classificationService=new ClassificationService(event.getGraphContext());
  GraphService<LicenseModel> licenseService=new GraphService<LicenseModel>(event.getGraphContext(),LicenseModel.class);
  for (  FileModel license : licenseFiles) {
    LOG.info(""String_Node_Str"" + license.getFileName() + ""String_Node_Str""+ payload.getArchiveName());
    classificationService.attachClassification(license,""String_Node_Str"",""String_Node_Str"");
    try (InputStream stream=license.asInputStream()){
      String content=IOUtils.toString(stream);
      if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else {
        LOG.warning(""String_Node_Str"" + license.getFileName());
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
    }
 catch (    IOException e) {
    }
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,ArchiveModel payload){
  List<FileModel> licenseFiles=findLicense(payload);
  if (licenseFiles.size() == 0) {
    return;
  }
  TechnologyTagService technologyTagService=new TechnologyTagService(event.getGraphContext());
  ClassificationService classificationService=new ClassificationService(event.getGraphContext());
  GraphService<LicenseModel> licenseService=new GraphService<>(event.getGraphContext(),LicenseModel.class);
  for (  FileModel license : licenseFiles) {
    LOG.info(""String_Node_Str"" + license.getFileName() + ""String_Node_Str""+ payload.getArchiveName());
    classificationService.attachClassification(license,""String_Node_Str"",""String_Node_Str"");
    try (InputStream stream=license.asInputStream()){
      String content=IOUtils.toString(stream);
      if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else       if (StringUtils.containsIgnoreCase(content,""String_Node_Str"")) {
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
 else {
        LOG.warning(""String_Node_Str"" + license.getFileName());
        tagLicense(licenseService,technologyTagService,license,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
    }
 catch (    IOException e) {
    }
  }
}",0.99761620977354
109486,"private List<FileModel> findLicense(ArchiveModel archive){
  List<FileModel> licenses=new LinkedList<>();
  Iterable<FileModel> files=archive.getContainedFileModels();
  for (  FileModel model : files) {
    String fileName=model.getFileName();
    fileName=StringUtils.lowerCase(fileName);
    if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")|| fileName.endsWith(""String_Node_Str"")|| fileName.endsWith(""String_Node_Str"")|| fileName.endsWith(""String_Node_Str"")) {
      licenses.add(model);
    }
  }
  return licenses;
}","private List<FileModel> findLicense(ArchiveModel archive){
  List<FileModel> licenses=new LinkedList<>();
  Iterable<FileModel> files=archive.getContainedFileModels();
  for (  FileModel model : files) {
    if (model.isDirectory())     continue;
    String fileName=model.getFileName();
    fileName=StringUtils.lowerCase(fileName);
    if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")|| fileName.endsWith(""String_Node_Str"")|| fileName.endsWith(""String_Node_Str"")|| fileName.endsWith(""String_Node_Str"")) {
      licenses.add(model);
    }
  }
  return licenses;
}",0.9650122050447518
109487,"private ApplicationReportModel createApplicationReport(GraphContext context,ProjectModel projectModel){
  ApplicationReportModel applicationReportModel=context.getFramed().addVertex(null,ApplicationReportModel.class);
  applicationReportModel.setReportPriority(100);
  applicationReportModel.setDisplayInApplicationReportIndex(true);
  applicationReportModel.setReportName(OVERVIEW);
  applicationReportModel.setReportIconClass(""String_Node_Str"");
  applicationReportModel.setMainApplicationReport(true);
  applicationReportModel.setProjectModel(projectModel);
  applicationReportModel.setTemplatePath(TEMPLATE_APPLICATION_REPORT);
  applicationReportModel.setTemplateType(TemplateType.FREEMARKER);
  applicationReportModel.setDisplayInApplicationList(true);
  GraphService<OverviewReportLineMessageModel> lineNotesService=new GraphService<OverviewReportLineMessageModel>(context,OverviewReportLineMessageModel.class);
  Iterable<OverviewReportLineMessageModel> findAll=lineNotesService.findAll();
  for (  OverviewReportLineMessageModel find : findAll) {
    String projectPrettyPath=projectModel.getRootFileModel().getPrettyPath();
    ProjectModel project=find.getProject();
    boolean found=false;
    while (project != null && !found) {
      if (projectPrettyPath.equals(project.getRootFileModel().getPrettyPath())) {
        applicationReportModel.addApplicationReportLine(find);
        found=true;
      }
 else {
        project=project.getParentProject();
      }
    }
  }
  ReportService reportService=new ReportService(context);
  reportService.setUniqueFilename(applicationReportModel,projectModel.getName(),""String_Node_Str"");
  return applicationReportModel;
}","private ApplicationReportModel createApplicationReport(GraphContext context,ProjectModel projectModel){
  ApplicationReportModel applicationReportModel=context.getFramed().addVertex(null,ApplicationReportModel.class);
  applicationReportModel.setReportPriority(100);
  applicationReportModel.setDisplayInApplicationReportIndex(true);
  applicationReportModel.setReportName(OVERVIEW);
  applicationReportModel.setReportIconClass(""String_Node_Str"");
  applicationReportModel.setMainApplicationReport(true);
  applicationReportModel.setProjectModel(projectModel);
  applicationReportModel.setTemplatePath(TEMPLATE_APPLICATION_REPORT);
  applicationReportModel.setTemplateType(TemplateType.FREEMARKER);
  applicationReportModel.setDisplayInApplicationList(true);
  GraphService<OverviewReportLineMessageModel> lineNotesService=new GraphService<OverviewReportLineMessageModel>(context,OverviewReportLineMessageModel.class);
  Iterable<OverviewReportLineMessageModel> findAll=lineNotesService.findAll();
  for (  OverviewReportLineMessageModel find : findAll) {
    String projectPrettyPath=projectModel.getRootFileModel().getPrettyPath();
    if (projectPrettyPath == null) {
      throw new WindupException(""String_Node_Str"" + projectModel + ""String_Node_Str"");
    }
    ProjectModel project=find.getProject();
    boolean found=false;
    while (project != null && !found) {
      if (project.getRootFileModel() == null) {
        throw new WindupException(""String_Node_Str"" + project + ""String_Node_Str"");
      }
      if (projectPrettyPath.equals(project.getRootFileModel().getPrettyPath())) {
        applicationReportModel.addApplicationReportLine(find);
        found=true;
      }
 else {
        project=project.getParentProject();
      }
    }
  }
  ReportService reportService=new ReportService(context);
  reportService.setUniqueFilename(applicationReportModel,projectModel.getName(),""String_Node_Str"");
  return applicationReportModel;
}",0.9255377826806398
109488,"private void processReferences(GraphContext context,Path filePath,List<ClassReference> references){
  TypeReferenceService typeReferenceService=new TypeReferenceService(context);
  for (  ClassReference reference : references) {
    if (reference.getLocation() == TypeReferenceLocation.TYPE || TypeInterestFactory.matchesAny(reference.getQualifiedName(),reference.getLocation())) {
      JavaSourceFileModel javaSourceModel=getJavaSourceFileModel(context,filePath);
      JavaTypeReferenceModel typeReference=typeReferenceService.createTypeReference(javaSourceModel,reference.getLocation(),reference.getLineNumber(),reference.getColumn(),reference.getLength(),reference.getQualifiedName(),reference.getLine());
      if (reference instanceof AnnotationClassReference) {
        Map<String,AnnotationValue> annotationValues=((AnnotationClassReference)reference).getAnnotationValues();
        addAnnotationValues(context,typeReference,annotationValues);
      }
    }
  }
}","private void processReferences(GraphContext context,Path filePath,List<ClassReference> references){
  TypeReferenceService typeReferenceService=new TypeReferenceService(context);
  for (  ClassReference reference : references) {
    JavaSourceFileModel javaSourceModel=getJavaSourceFileModel(context,filePath);
    JavaTypeReferenceModel typeReference=typeReferenceService.createTypeReference(javaSourceModel,reference.getLocation(),reference.getLineNumber(),reference.getColumn(),reference.getLength(),reference.getQualifiedName(),reference.getLine());
    if (reference instanceof AnnotationClassReference) {
      Map<String,AnnotationValue> annotationValues=((AnnotationClassReference)reference).getAnnotationValues();
      addAnnotationValues(context,typeReference,annotationValues);
    }
  }
}",0.5549915397631133
109489,"public void perform(final GraphRewrite event,EvaluationContext context){
  ExecutionStatistics.get().begin(""String_Node_Str"");
  try {
    WindupJavaConfigurationService windupJavaConfigurationService=new WindupJavaConfigurationService(event.getGraphContext());
    GraphService<JavaSourceFileModel> service=new GraphService<>(event.getGraphContext(),JavaSourceFileModel.class);
    Iterable<JavaSourceFileModel> allJavaSourceModels=service.findAll();
    final Set<Path> allSourceFiles=new TreeSet<>();
    Set<String> sourcePaths=new HashSet<>();
    for (    JavaSourceFileModel javaFile : allJavaSourceModels) {
      FileModel rootSourceFolder=javaFile.getRootSourceFolder();
      if (rootSourceFolder != null) {
        sourcePaths.add(rootSourceFolder.getFilePath());
      }
      if (windupJavaConfigurationService.shouldScanPackage(javaFile.getPackageName())) {
        Path path=Paths.get(javaFile.getFilePath());
        allSourceFiles.add(path);
        sourcePathToFileModel.put(path,javaFile);
      }
    }
    GraphService<JarArchiveModel> libraryService=new GraphService<JarArchiveModel>(event.getGraphContext(),JarArchiveModel.class);
    Iterable<JarArchiveModel> libraries=libraryService.findAll();
    Set<String> libraryPaths=new HashSet<>();
    for (    JarArchiveModel library : libraries) {
      if (library.getUnzippedDirectory() != null) {
        libraryPaths.add(library.getUnzippedDirectory().getFilePath());
      }
 else {
        libraryPaths.add(library.getFilePath());
      }
    }
    ExecutionStatistics.get().begin(""String_Node_Str"");
    try {
      WindupWildcardImportResolver.setGraphContext(event.getGraphContext());
      final int totalToProcess=allSourceFiles.size();
      final AtomicInteger numberProcessed=new AtomicInteger(0);
      final BlockingQueue<Pair<Path,List<ClassReference>>> processedPaths=new ArrayBlockingQueue<>(1000);
      final Set<Path> failedPaths=Sets.getConcurrentSet();
      BatchASTListener listener=new BatchASTListener(){
        @Override public void processed(        Path filePath,        List<ClassReference> references){
          try {
            processedPaths.put(new ImmutablePair<Path,List<ClassReference>>(filePath,references));
          }
 catch (          InterruptedException e) {
            throw new WindupException(e.getMessage(),e);
          }
          numberProcessed.incrementAndGet();
        }
        @Override public void failed(        Path filePath,        Throwable cause){
          LOG.log(Level.WARNING,""String_Node_Str"" + filePath + ""String_Node_Str""+ cause.getMessage(),cause);
          failedPaths.add(filePath);
        }
      }
;
      Set<Path> filesToProcess=new TreeSet<>(allSourceFiles);
      BatchASTFuture future=BatchASTProcessor.analyze(listener,importResolver,libraryPaths,sourcePaths,filesToProcess);
      while (!future.isDone() || !processedPaths.isEmpty()) {
        Pair<Path,List<ClassReference>> pair=processedPaths.poll(1000,TimeUnit.SECONDS);
        processReferences(event.getGraphContext(),pair.getKey(),pair.getValue());
        if (numberProcessed.get() % LOG_INTERVAL == 0) {
          LOG.info(""String_Node_Str"" + numberProcessed.get() + ""String_Node_Str""+ totalToProcess);
        }
        if (numberProcessed.get() % COMMIT_INTERVAL == 0) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        filesToProcess.remove(pair.getKey());
      }
      for (      Path path : failedPaths) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),path);
        classificationService.attachClassification(sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
      }
      if (!filesToProcess.isEmpty()) {
        for (        Path unprocessed : new ArrayList<>(filesToProcess)) {
          try {
            List<ClassReference> references=ASTProcessor.analyze(importResolver,libraryPaths,sourcePaths,unprocessed);
            processReferences(event.getGraphContext(),unprocessed,references);
            filesToProcess.remove(unprocessed);
          }
 catch (          Exception e) {
            LOG.log(Level.WARNING,""String_Node_Str"" + unprocessed + ""String_Node_Str""+ e.getMessage(),e);
            ClassificationService classificationService=new ClassificationService(event.getGraphContext());
            JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
            classificationService.attachClassification(sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
          }
        }
      }
      if (!filesToProcess.isEmpty()) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        StringBuilder message=new StringBuilder();
        message.append(""String_Node_Str"" + filesToProcess.size() + ""String_Node_Str"");
        for (        Path unprocessed : filesToProcess) {
          JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
          message.append(""String_Node_Str"" + unprocessed + ""String_Node_Str"");
          classificationService.attachClassification(sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
        }
        LOG.warning(message.toString());
      }
      ExecutionStatistics.get().end(""String_Node_Str"");
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,""String_Node_Str"" + e.getMessage(),e);
    }
 finally {
      WindupWildcardImportResolver.setGraphContext(null);
    }
  }
  finally {
    ExecutionStatistics.get().end(""String_Node_Str"");
  }
}","public void perform(final GraphRewrite event,EvaluationContext context){
  ExecutionStatistics.get().begin(""String_Node_Str"");
  try {
    WindupJavaConfigurationService windupJavaConfigurationService=new WindupJavaConfigurationService(event.getGraphContext());
    GraphService<JavaSourceFileModel> service=new GraphService<>(event.getGraphContext(),JavaSourceFileModel.class);
    Iterable<JavaSourceFileModel> allJavaSourceModels=service.findAll();
    final Set<Path> allSourceFiles=new TreeSet<>();
    Set<String> sourcePaths=new HashSet<>();
    for (    JavaSourceFileModel javaFile : allJavaSourceModels) {
      FileModel rootSourceFolder=javaFile.getRootSourceFolder();
      if (rootSourceFolder != null) {
        sourcePaths.add(rootSourceFolder.getFilePath());
      }
      if (windupJavaConfigurationService.shouldScanPackage(javaFile.getPackageName())) {
        Path path=Paths.get(javaFile.getFilePath());
        allSourceFiles.add(path);
        sourcePathToFileModel.put(path,javaFile);
      }
    }
    GraphService<JarArchiveModel> libraryService=new GraphService<JarArchiveModel>(event.getGraphContext(),JarArchiveModel.class);
    Iterable<JarArchiveModel> libraries=libraryService.findAll();
    Set<String> libraryPaths=new HashSet<>();
    for (    JarArchiveModel library : libraries) {
      if (library.getUnzippedDirectory() != null) {
        libraryPaths.add(library.getUnzippedDirectory().getFilePath());
      }
 else {
        libraryPaths.add(library.getFilePath());
      }
    }
    ExecutionStatistics.get().begin(""String_Node_Str"");
    try {
      WindupWildcardImportResolver.setGraphContext(event.getGraphContext());
      final int totalToProcess=allSourceFiles.size();
      final AtomicInteger numberProcessed=new AtomicInteger(0);
      final BlockingQueue<Pair<Path,List<ClassReference>>> processedPaths=new ArrayBlockingQueue<>(1000);
      final Set<Path> failedPaths=Sets.getConcurrentSet();
      BatchASTListener listener=new BatchASTListener(){
        @Override public void processed(        Path filePath,        List<ClassReference> references){
          try {
            processedPaths.put(new ImmutablePair<Path,List<ClassReference>>(filePath,references));
          }
 catch (          InterruptedException e) {
            throw new WindupException(e.getMessage(),e);
          }
          numberProcessed.incrementAndGet();
        }
        @Override public void failed(        Path filePath,        Throwable cause){
          LOG.log(Level.WARNING,""String_Node_Str"" + filePath + ""String_Node_Str""+ cause.getMessage(),cause);
          failedPaths.add(filePath);
        }
      }
;
      Set<Path> filesToProcess=new TreeSet<>(allSourceFiles);
      BatchASTFuture future=BatchASTProcessor.analyze(listener,importResolver,libraryPaths,sourcePaths,filesToProcess);
      while (!future.isDone() || !processedPaths.isEmpty()) {
        Pair<Path,List<ClassReference>> pair=processedPaths.poll(250,TimeUnit.MILLISECONDS);
        processReferences(event.getGraphContext(),pair.getKey(),pair.getValue());
        if (numberProcessed.get() % LOG_INTERVAL == 0) {
          LOG.info(""String_Node_Str"" + numberProcessed.get() + ""String_Node_Str""+ totalToProcess);
        }
        if (numberProcessed.get() % COMMIT_INTERVAL == 0) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        filesToProcess.remove(pair.getKey());
      }
      for (      Path path : failedPaths) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),path);
        classificationService.attachClassification(sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
      }
      if (!filesToProcess.isEmpty()) {
        for (        Path unprocessed : new ArrayList<>(filesToProcess)) {
          try {
            List<ClassReference> references=ASTProcessor.analyze(importResolver,libraryPaths,sourcePaths,unprocessed);
            processReferences(event.getGraphContext(),unprocessed,references);
            filesToProcess.remove(unprocessed);
          }
 catch (          Exception e) {
            LOG.log(Level.WARNING,""String_Node_Str"" + unprocessed + ""String_Node_Str""+ e.getMessage(),e);
            ClassificationService classificationService=new ClassificationService(event.getGraphContext());
            JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
            classificationService.attachClassification(sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
          }
        }
      }
      if (!filesToProcess.isEmpty()) {
        ClassificationService classificationService=new ClassificationService(event.getGraphContext());
        StringBuilder message=new StringBuilder();
        message.append(""String_Node_Str"" + filesToProcess.size() + ""String_Node_Str"");
        for (        Path unprocessed : filesToProcess) {
          JavaSourceFileModel sourceFileModel=getJavaSourceFileModel(event.getGraphContext(),unprocessed);
          message.append(""String_Node_Str"" + unprocessed + ""String_Node_Str"");
          classificationService.attachClassification(sourceFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
        }
        LOG.warning(message.toString());
      }
      ExecutionStatistics.get().end(""String_Node_Str"");
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,""String_Node_Str"" + e.getMessage(),e);
    }
 finally {
      WindupWildcardImportResolver.setGraphContext(null);
    }
  }
  finally {
    ExecutionStatistics.get().end(""String_Node_Str"");
  }
}",0.9991482112436116
109490,"@Override public Configuration getConfiguration(GraphContext context){
  ConditionBuilder fileWhen=Query.fromType(XmlFileModel.class).withProperty(FileModel.FILE_NAME,""String_Node_Str"");
  AbstractIterationOperation<XmlFileModel> evaluatePomFiles=new AbstractIterationOperation<XmlFileModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    XmlFileModel payload){
      String defaultName=payload.getParentArchive() == null ? payload.asFile().getParentFile().getName() : payload.getParentArchive().getFileName();
      MavenProjectModel mavenProjectModel=extractMavenProjectModel(event,defaultName,payload);
      if (mavenProjectModel != null) {
        ArchiveModel archiveModel=payload.getParentArchive();
        if (archiveModel != null && !isAlreadyMavenProject(archiveModel)) {
          archiveModel.setProjectModel(mavenProjectModel);
          mavenProjectModel.setRootFileModel(archiveModel);
          for (          FileModel f : archiveModel.getContainedFileModels()) {
            if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
              f.setProjectModel(mavenProjectModel);
              mavenProjectModel.addFileModel(f);
            }
          }
        }
 else {
          File parentFile=payload.asFile().getParentFile();
          FileModel parentFileModel=new FileService(event.getGraphContext()).findByPath(parentFile.getAbsolutePath());
          if (parentFileModel != null && !isAlreadyMavenProject(parentFileModel)) {
            parentFileModel.setProjectModel(mavenProjectModel);
            mavenProjectModel.addFileModel(parentFileModel);
            mavenProjectModel.setRootFileModel(parentFileModel);
            for (            FileModel childFile : parentFileModel.getFilesInDirectory()) {
              addFilesToModel(mavenProjectModel,childFile);
            }
          }
        }
      }
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  return ConfigurationBuilder.begin().addRule().when(fileWhen).perform(evaluatePomFiles);
}","@Override public Configuration getConfiguration(GraphContext context){
  ConditionBuilder fileWhen=Query.fromType(XmlFileModel.class).withProperty(FileModel.FILE_NAME,""String_Node_Str"");
  AbstractIterationOperation<XmlFileModel> evaluatePomFiles=new AbstractIterationOperation<XmlFileModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    XmlFileModel payload){
      if (payload.getProjectModel() != null)       return;
      String defaultName=payload.getParentArchive() == null ? payload.asFile().getParentFile().getName() : payload.getParentArchive().getFileName();
      MavenProjectModel mavenProjectModel=extractMavenProjectModel(event,defaultName,payload);
      if (mavenProjectModel != null) {
        ArchiveModel archiveModel=payload.getParentArchive();
        if (archiveModel != null && !isAlreadyMavenProject(archiveModel)) {
          archiveModel.setProjectModel(mavenProjectModel);
          mavenProjectModel.setRootFileModel(archiveModel);
          for (          FileModel f : archiveModel.getContainedFileModels()) {
            if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
              f.setProjectModel(mavenProjectModel);
              mavenProjectModel.addFileModel(f);
            }
          }
        }
 else {
          File parentFile=payload.asFile().getParentFile();
          FileModel parentFileModel=new FileService(event.getGraphContext()).findByPath(parentFile.getAbsolutePath());
          if (parentFileModel != null && !isAlreadyMavenProject(parentFileModel)) {
            parentFileModel.setProjectModel(mavenProjectModel);
            mavenProjectModel.addFileModel(parentFileModel);
            mavenProjectModel.setRootFileModel(parentFileModel);
            for (            FileModel childFile : parentFileModel.getFilesInDirectory()) {
              addFilesToModel(mavenProjectModel,childFile);
            }
          }
        }
      }
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  return ConfigurationBuilder.begin().addRule().when(fileWhen).perform(evaluatePomFiles);
}",0.98603550295858
109491,"@Override public void perform(GraphRewrite event,EvaluationContext context,XmlFileModel payload){
  String defaultName=payload.getParentArchive() == null ? payload.asFile().getParentFile().getName() : payload.getParentArchive().getFileName();
  MavenProjectModel mavenProjectModel=extractMavenProjectModel(event,defaultName,payload);
  if (mavenProjectModel != null) {
    ArchiveModel archiveModel=payload.getParentArchive();
    if (archiveModel != null && !isAlreadyMavenProject(archiveModel)) {
      archiveModel.setProjectModel(mavenProjectModel);
      mavenProjectModel.setRootFileModel(archiveModel);
      for (      FileModel f : archiveModel.getContainedFileModels()) {
        if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
          f.setProjectModel(mavenProjectModel);
          mavenProjectModel.addFileModel(f);
        }
      }
    }
 else {
      File parentFile=payload.asFile().getParentFile();
      FileModel parentFileModel=new FileService(event.getGraphContext()).findByPath(parentFile.getAbsolutePath());
      if (parentFileModel != null && !isAlreadyMavenProject(parentFileModel)) {
        parentFileModel.setProjectModel(mavenProjectModel);
        mavenProjectModel.addFileModel(parentFileModel);
        mavenProjectModel.setRootFileModel(parentFileModel);
        for (        FileModel childFile : parentFileModel.getFilesInDirectory()) {
          addFilesToModel(mavenProjectModel,childFile);
        }
      }
    }
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,XmlFileModel payload){
  if (payload.getProjectModel() != null)   return;
  String defaultName=payload.getParentArchive() == null ? payload.asFile().getParentFile().getName() : payload.getParentArchive().getFileName();
  MavenProjectModel mavenProjectModel=extractMavenProjectModel(event,defaultName,payload);
  if (mavenProjectModel != null) {
    ArchiveModel archiveModel=payload.getParentArchive();
    if (archiveModel != null && !isAlreadyMavenProject(archiveModel)) {
      archiveModel.setProjectModel(mavenProjectModel);
      mavenProjectModel.setRootFileModel(archiveModel);
      for (      FileModel f : archiveModel.getContainedFileModels()) {
        if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
          f.setProjectModel(mavenProjectModel);
          mavenProjectModel.addFileModel(f);
        }
      }
    }
 else {
      File parentFile=payload.asFile().getParentFile();
      FileModel parentFileModel=new FileService(event.getGraphContext()).findByPath(parentFile.getAbsolutePath());
      if (parentFileModel != null && !isAlreadyMavenProject(parentFileModel)) {
        parentFileModel.setProjectModel(mavenProjectModel);
        mavenProjectModel.addFileModel(parentFileModel);
        mavenProjectModel.setRootFileModel(parentFileModel);
        for (        FileModel childFile : parentFileModel.getFilesInDirectory()) {
          addFilesToModel(mavenProjectModel,childFile);
        }
      }
    }
  }
}",0.9830621056127532
109492,"@Override public XSLTTransformation processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String description=$(element).attr(""String_Node_Str"");
  String extension=$(element).attr(""String_Node_Str"");
  String template=$(element).attr(""String_Node_Str"");
  String of=$(element).attr(""String_Node_Str"");
  if (StringUtils.isBlank(description)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(template)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(extension)) {
    throw new WindupException(""String_Node_Str"");
  }
  Map<String,String> parameters=new HashMap<String,String>();
  List<Element> children=$(element).children(""String_Node_Str"").get();
  for (  Element child : children) {
    XSLTParameter param=handlerManager.processElement(child);
    parameters.put(param.getKey(),param.getValue());
  }
  Path pathContainingXml=handlerManager.getXmlInputRootPath();
  if (pathContainingXml != null) {
    String fullPath;
    if (template.startsWith(""String_Node_Str"") || template.startsWith(""String_Node_Str"")) {
      fullPath=template;
    }
 else {
      Path path=pathContainingXml.resolve(template).toAbsolutePath();
      if (!Files.exists(path)) {
        Path rulesParentPath=handlerManager.getXmlInputPath().getParent();
        fullPath=rulesParentPath.resolve(template).normalize().toAbsolutePath().toString();
      }
 else {
        fullPath=path.normalize().toString();
      }
    }
    if (of != null) {
      return (XSLTTransformation)XSLTTransformation.of(of).usingFilesystem(fullPath).withDescription(description).withExtension(extension).withParameters(parameters);
    }
    return (XSLTTransformation)XSLTTransformation.usingFilesystem(fullPath).withDescription(description).withExtension(extension).withParameters(parameters);
  }
 else {
    ClassLoader xmlFileAddonClassLoader=handlerManager.getAddonContainingInputXML().getClassLoader();
    if (of != null) {
      return (XSLTTransformation)XSLTTransformation.of(of).using(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension).withParameters(parameters);
    }
    return (XSLTTransformation)XSLTTransformation.using(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension).withParameters(parameters);
  }
}","@Override public XSLTTransformation processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String description=$(element).attr(""String_Node_Str"");
  String extension=$(element).attr(""String_Node_Str"");
  String effort=$(element).attr(""String_Node_Str"");
  String template=$(element).attr(""String_Node_Str"");
  String of=$(element).attr(""String_Node_Str"");
  if (StringUtils.isBlank(description)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(template)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(extension)) {
    throw new WindupException(""String_Node_Str"");
  }
  Map<String,String> parameters=new HashMap<String,String>();
  List<Element> children=$(element).children(""String_Node_Str"").get();
  for (  Element child : children) {
    XSLTParameter param=handlerManager.processElement(child);
    parameters.put(param.getKey(),param.getValue());
  }
  Path pathContainingXml=handlerManager.getXmlInputRootPath();
  if (pathContainingXml != null) {
    String fullPath;
    if (template.startsWith(""String_Node_Str"") || template.startsWith(""String_Node_Str"")) {
      fullPath=template;
    }
 else {
      Path path=pathContainingXml.resolve(template).toAbsolutePath();
      if (!Files.exists(path)) {
        Path rulesParentPath=handlerManager.getXmlInputPath().getParent();
        fullPath=rulesParentPath.resolve(template).normalize().toAbsolutePath().toString();
      }
 else {
        fullPath=path.normalize().toString();
      }
    }
    XSLTTransformation transformation=(XSLTTransformation)XSLTTransformation.usingFilesystem(fullPath).withDescription(description).withExtension(extension).withParameters(parameters);
    if (of != null) {
      transformation=(XSLTTransformation)XSLTTransformation.of(of).usingTemplate(fullPath).withDescription(description).withExtension(extension).withParameters(parameters);
      return transformation;
    }
    return transformation.withEffort(effort == null ? 0 : Integer.valueOf(effort));
  }
 else {
    ClassLoader xmlFileAddonClassLoader=handlerManager.getAddonContainingInputXML().getClassLoader();
    if (of != null) {
      return (XSLTTransformation)XSLTTransformation.of(of).usingTemplate(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension).withParameters(parameters);
    }
    return (XSLTTransformation)XSLTTransformation.using(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension).withParameters(parameters);
  }
}",0.883664369679773
109493,"/** 
 * Set the location of the source XSLT file and set it to use the provided   {@link ClassLoader} for resource lookup.
 */
public static XSLTTransformationLocation using(String location,ClassLoader classLoader){
  XSLTTransformation tansformation=new XSLTTransformation();
  tansformation.contextClassLoader=classLoader;
  tansformation.template=location;
  return tansformation;
}","/** 
 * Create a new   {@link XSLTTransformation} using the given location of the source XSLT file within the given{@link ClassLoader}.
 */
public static XSLTTransformationLocation using(String location,ClassLoader classLoader){
  XSLTTransformation tansformation=new XSLTTransformation();
  tansformation.contextClassLoader=classLoader;
  tansformation.template=location;
  return tansformation;
}",0.7509578544061303
109494,"@Override public void perform(GraphRewrite event,EvaluationContext context,XmlFileModel payload){
  setup();
  GraphContext graphContext=event.getGraphContext();
  GraphService<XsltTransformationModel> transformationService=new GraphService<>(graphContext,XsltTransformationModel.class);
  String fileName=payload.getFileName();
  fileName=StringUtils.replace(fileName,""String_Node_Str"",""String_Node_Str"");
  fileName=fileName + extension;
  XsltTransformationService xsltTransformationService=new XsltTransformationService(graphContext);
  Path outputPath=xsltTransformationService.getTransformedXSLTPath();
  Path resultPath=outputPath.resolve(fileName);
  Source xmlSource=new DOMSource(payload.asDocument());
  Result xmlResult=new StreamResult(resultPath.toFile());
  try {
    xsltTransformer.transform(xmlSource,xmlResult);
    XsltTransformationModel transformation=transformationService.create();
    transformation.setDescription(description);
    transformation.setExtension(extension);
    transformation.setSourceLocation(template);
    transformation.setSourceFile(payload);
    transformation.setResult(fileName);
    ClassificationService classificationService=new ClassificationService(graphContext);
    ClassificationModel classificationModel=classificationService.create();
    classificationModel.setClassifiation(""String_Node_Str"" + description);
    classificationModel.addFileModel(payload);
    GraphService<LinkModel> linkService=new GraphService<>(graphContext,LinkModel.class);
    LinkModel linkModel=linkService.create();
    linkModel.setDescription(description);
    linkModel.setLink(XsltTransformationService.TRANSFORMEDXML_DIR_NAME + ""String_Node_Str"" + fileName);
    classificationModel.addLink(linkModel);
  }
 catch (  TransformerException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,XmlFileModel payload){
  setup();
  GraphContext graphContext=event.getGraphContext();
  GraphService<XsltTransformationModel> transformationService=new GraphService<>(graphContext,XsltTransformationModel.class);
  String fileName=payload.getFileName();
  fileName=StringUtils.replace(fileName,""String_Node_Str"",""String_Node_Str"");
  fileName=fileName + extension;
  XsltTransformationService xsltTransformationService=new XsltTransformationService(graphContext);
  Path outputPath=xsltTransformationService.getTransformedXSLTPath();
  Path resultPath=outputPath.resolve(fileName);
  Source xmlSource=new DOMSource(payload.asDocument());
  Result xmlResult=new StreamResult(resultPath.toFile());
  try {
    xsltTransformer.transform(xmlSource,xmlResult);
    XsltTransformationModel transformation=transformationService.create();
    transformation.setDescription(description);
    transformation.setEffort(effort);
    transformation.setExtension(extension);
    transformation.setSourceLocation(template);
    transformation.setSourceFile(payload);
    transformation.setResult(fileName);
    ClassificationService classificationService=new ClassificationService(graphContext);
    ClassificationModel classificationModel=classificationService.create();
    classificationModel.setClassifiation(""String_Node_Str"" + description);
    classificationModel.setEffort(effort);
    classificationModel.addFileModel(payload);
    GraphService<LinkModel> linkService=new GraphService<>(graphContext,LinkModel.class);
    LinkModel linkModel=linkService.create();
    linkModel.setDescription(description);
    linkModel.setLink(XsltTransformationService.TRANSFORMEDXML_DIR_NAME + ""String_Node_Str"" + fileName);
    classificationModel.addLink(linkModel);
  }
 catch (  TransformerException e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}",0.9784172661870504
109495,"/** 
 * Set the description of this   {@link XSLTTransformation}.
 */
public XSLTTransformationDescription withDescription(String description){
  this.description=description;
  return this;
}","@Override public XSLTTransformationDescription withDescription(String description){
  this.description=description;
  return this;
}",0.7716049382716049
109496,"/** 
 * Set the extension of this   {@link XSLTTransformation}.
 */
public XSLTTransformationExtension withExtension(String extension){
  this.extension=extension;
  return this;
}","@Override public XSLTTransformationExtension withExtension(String extension){
  this.extension=extension;
  return this;
}",0.7615894039735099
109497,"/** 
 * Create a new transformation for the given ref.
 */
public static XSLTTransformationOf of(String variable){
  return new XSLTTransformationOf(variable);
}","/** 
 * Create a new transformation for the given ref.
 */
public static XSLTTransformationOf of(String variable){
  return new XSLTTransformation(variable);
}",0.99375
109498,"public XSLTTransformationParams withParameters(Map<String,String> parameters){
  this.xsltParameters=parameters;
  return this;
}","/** 
 * Set the parameters associated with this   {@link XSLTTransformation};
 */
public XSLTTransformationEffort withParameters(Map<String,String> parameters){
  this.xsltParameters.putAll(parameters);
  return this;
}",0.6436781609195402
109499,"/** 
 * Set the location of the source XSLT file to a absolute path on the filesystem
 */
public static XSLTTransformationFileSystem usingFilesystem(String location){
  XSLTTransformation tansformation=new XSLTTransformation();
  tansformation.template=location;
  return tansformation;
}","/** 
 * Create a new   {@link XSLTTransformation} using the given location of the source XSLT file path on the file-system.
 */
public static XSLTTransformationFileSystem usingFilesystem(String location){
  XSLTTransformation tansformation=new XSLTTransformation();
  tansformation.template=location;
  return tansformation;
}",0.8827361563517915
109500,"XSLTTransformation(){
  super();
}","private XSLTTransformation(){
  super();
}",0.8947368421052632
109501,"/** 
 * Extension that is going to be added to the result file.
 * @param extension Examples are .xml,.result etc.
 * @return
 */
XSLTTransformationExtension withExtension(String extension);","/** 
 * Extension to be appended to the result file.
 */
XSLTTransformationExtension withExtension(String extension);",0.7361563517915309
109502,"/** 
 * Specify   {@link XSLTTransformation} parameters.
 * @param parameters parameters for the xslt transformer factory
 * @return
 */
XSLTTransformationParams withParameters(Map<String,String> parameters);","/** 
 * Specify   {@link XSLTTransformation} parameters to be passed to the XSLT template.
 */
XSLTTransformationEffort withParameters(Map<String,String> parameters);",0.7647058823529411
109503,"public WindupConfiguration setOffline(boolean offline){
  setOptionValue(OfflineModeOption.NAME,offline);
  return this;
}","/** 
 * Set Windup to run online or offline (with respect to an internet connection).
 */
public WindupConfiguration setOffline(boolean offline){
  setOptionValue(OfflineModeOption.NAME,offline);
  return this;
}",0.7305389221556886
109504,"public boolean isOffline(){
  Boolean offline=getOptionValue(OfflineModeOption.NAME);
  return offline == null ? false : offline;
}","/** 
 * Returns true if Windup is operating in   {@link OfflineModeOption} == true. (with respect to an internetconnection)
 */
public boolean isOffline(){
  Boolean offline=getOptionValue(OfflineModeOption.NAME);
  return offline == null ? false : offline;
}",0.6717948717948717
109505,"public void getOptionMap(String NAME){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","/** 
 * Returns all configuration options as an immutable   {@link Map}.
 */
public Map<String,Object> getOptionMap(){
  return Collections.unmodifiableMap(configurationOptions);
}",0.3617021276595745
109506,"/** 
 * Creates the   {@link AndPredicate} that returns true only if all of the given conditions are met.
 */
public AndPredicate(Predicate<RuleProvider>... predicates){
  this.predicates=new HashSet(Arrays.asList(predicates));
}","/** 
 * Creates the   {@link AndPredicate} that returns true only if all of the given conditions are met.
 */
@SafeVarargs public AndPredicate(Predicate<RuleProvider>... predicates){
  this.predicates=new HashSet<>(Arrays.asList(predicates));
}",0.9682875264270612
109507,"@Override public boolean accept(RuleProvider provider){
  boolean result=true;
  if (this.predicates.isEmpty())   return false;
  for (  Predicate predicate : this.predicates) {
    if (!predicate.accept(provider))     return false;
  }
  return result;
}","@Override public boolean accept(RuleProvider provider){
  boolean result=true;
  if (this.predicates.isEmpty())   return false;
  for (  Predicate<RuleProvider> predicate : this.predicates) {
    if (!predicate.accept(provider))     return false;
  }
  return result;
}",0.9732824427480916
109508,"/** 
 * Creates the   {@link RuleProviderPhasePredicate} with the given phase types.
 */
public RuleProviderPhasePredicate(Class<? extends RulePhase>... phases){
  this.phases=new HashSet(Arrays.asList(phases));
}","/** 
 * Creates the   {@link RuleProviderPhasePredicate} with the given phase types.
 */
@SafeVarargs public RuleProviderPhasePredicate(Class<? extends RulePhase>... phases){
  this.phases=new HashSet<>(Arrays.asList(phases));
}",0.9659863945578232
109509,"/** 
 * Sets the rule to require all of the include tags. If this value is true, then a   {@link RuleProvider} must have all of the tags in the includelist in order to be matched. If it is false, then having a single tag match is sufficient. The default value is false.
 */
public TaggedRuleProviderPredicate setRequireAllIncludeTags(boolean requireAll){
  this.requireAllIncludeTags=requireAll;
  return this;
}","/** 
 * Sets the rule to require all of the include tags. If this value is true, then a   {@link RuleProvider} must haveall of the tags in the include list in order to be matched. If it is false, then having a single tag match is sufficient. The default value is false.
 */
public TaggedRuleProviderPredicate setRequireAllIncludeTags(boolean requireAll){
  this.requireAllIncludeTags=requireAll;
  return this;
}",0.924757281553398
109510,"/** 
 * <p> Sets the rule to require all of the exclude tags. If this value is false (the default), then this   {@link Predicate} will reject any{@link RuleProvider}s that have a tag that is also in the excludeTags list. </p> <p> If this value is true, then it will reject only providers that have all of the tags in the exclude list. </p>
 */
public TaggedRuleProviderPredicate setRequireAllExcludeTags(boolean requireAll){
  this.requireAllExcludeTags=requireAll;
  return this;
}","/** 
 * <p> Sets the rule to require all of the exclude tags. If this value is false (the default), then this  {@link Predicate} will reject any {@link RuleProvider}s that have a tag that is also in the excludeTags list. </p> <p> If this value is true, then it will reject only providers that have all of the tags in the exclude list. </p>
 */
public TaggedRuleProviderPredicate setRequireAllExcludeTags(boolean requireAll){
  this.requireAllExcludeTags=requireAll;
  return this;
}",0.9979253112033196
109511,"@Override public boolean accept(RuleProvider provider){
  Set<String> tags=provider.getMetadata().getTags();
  boolean includeMatches=(this.includeTags.isEmpty()) || (this.requireAllIncludeTags ? tags.containsAll(this.includeTags) : CollectionUtils.containsAny(tags,this.includeTags));
  if (!includeMatches)   return false;
  boolean excludeMatches=(this.excludeTags.isEmpty()) || (this.requireAllExcludeTags ? !tags.containsAll(this.excludeTags) : !CollectionUtils.containsAny(tags,this.excludeTags));
  return includeMatches && excludeMatches;
}","@Override public boolean accept(RuleProvider provider){
  Set<String> tags=provider.getMetadata().getTags();
  boolean result=true;
  if (!includeTags.isEmpty()) {
    if (requireAllIncludeTags)     result=tags.containsAll(includeTags);
 else     result=CollectionUtils.containsAny(tags,includeTags);
  }
  if (result && !excludeTags.isEmpty()) {
    if (requireAllExcludeTags)     result=!tags.containsAll(excludeTags);
 else     result=!CollectionUtils.containsAny(tags,excludeTags);
  }
  return result;
}",0.6496212121212122
109512,"@Test public void testAccept(){
  TestTagsARules rulesA=new TestTagsARules();
  TestTagsBRules rulesB=new TestTagsBRules();
  TestTagsA1B1Rules rulesA1B1=new TestTagsA1B1Rules();
  Assert.assertEquals(true,tryFilter(""String_Node_Str"",null,rulesA,false,false));
  Assert.assertEquals(false,tryFilter(""String_Node_Str"",null,rulesB,false,false));
  Assert.assertEquals(true,tryFilter(""String_Node_Str"",null,rulesB,false,false));
  Assert.assertEquals(false,tryFilter(""String_Node_Str"",null,rulesB,true,false));
  Assert.assertEquals(true,tryFilter(""String_Node_Str"",null,rulesB,false,false));
  Assert.assertEquals(false,tryFilter(""String_Node_Str"",null,rulesB,true,false));
  Assert.assertEquals(true,tryFilter(""String_Node_Str"",""String_Node_Str"",rulesA1B1,false,false));
  Assert.assertEquals(false,tryFilter(""String_Node_Str"",""String_Node_Str"",rulesA1B1,false,false));
  Assert.assertEquals(false,tryFilter(""String_Node_Str"",""String_Node_Str"",rulesA1B1,false,false));
  Assert.assertEquals(true,tryFilter(""String_Node_Str"",""String_Node_Str"",rulesA1B1,false,true));
}","@Test public void testAccept(){
  TestTagsARules rulesA=new TestTagsARules();
  TestTagsBRules rulesB=new TestTagsBRules();
  TestTagsA1B1Rules rulesA1B1=new TestTagsA1B1Rules();
  Assert.assertEquals(true,isProviderAcceptedByTags(rulesA,Arrays.asList(""String_Node_Str""),false,null,false));
  Assert.assertEquals(false,isProviderAcceptedByTags(rulesB,Arrays.asList(""String_Node_Str""),false,null,false));
  Assert.assertEquals(true,isProviderAcceptedByTags(rulesB,Arrays.asList(""String_Node_Str"",""String_Node_Str""),false,null,false));
  Assert.assertEquals(false,isProviderAcceptedByTags(rulesB,Arrays.asList(""String_Node_Str"",""String_Node_Str""),true,null,false));
  Assert.assertEquals(true,isProviderAcceptedByTags(rulesB,Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),false,null,false));
  Assert.assertEquals(false,isProviderAcceptedByTags(rulesB,Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),true,null,false));
  Assert.assertEquals(true,isProviderAcceptedByTags(rulesA1B1,Arrays.asList(""String_Node_Str"",""String_Node_Str""),false,Arrays.asList(""String_Node_Str""),false));
  Assert.assertEquals(false,isProviderAcceptedByTags(rulesA1B1,Arrays.asList(""String_Node_Str"",""String_Node_Str""),false,Arrays.asList(""String_Node_Str""),false));
  Assert.assertEquals(false,isProviderAcceptedByTags(rulesA1B1,Arrays.asList(""String_Node_Str""),false,Arrays.asList(""String_Node_Str"",""String_Node_Str""),false));
  Assert.assertEquals(true,isProviderAcceptedByTags(rulesA1B1,Arrays.asList(""String_Node_Str""),false,Arrays.asList(""String_Node_Str"",""String_Node_Str""),true));
}",0.4446107784431137
109513,"@Test public void testSkippedArchivesFound() throws Exception {
}","@Test public void testSkippedArchivesFound() throws Exception {
  try (GraphContext graphContext=contextFactory.create()){
    FileUtils.deleteDirectory(OUTPUT_PATH.toFile());
    InMemoryChecksumIdentifier inMemoryIdentifier=new InMemoryChecksumIdentifier();
    inMemoryIdentifier.addMapping(""String_Node_Str"",LOG4J_COORDINATE);
    SortedFileChecksumIdentifier sortedFileIdentifier=new SortedFileChecksumIdentifier(new File(""String_Node_Str""));
    identifier.addIdentifier(inMemoryIdentifier);
    identifier.addIdentifier(sortedFileIdentifier);
    SkippedArchives.add(""String_Node_Str"");
    WindupConfiguration config=new WindupConfiguration();
    config.setGraphContext(graphContext);
    config.setInputPath(INPUT_PATH);
    config.setOutputDirectory(OUTPUT_PATH);
    config.setOptionValue(OverwriteOption.NAME,true);
    config.setRuleProviderFilter(new Predicate<WindupRuleProvider>(){
      private RuleProviderWithDependenciesPredicate discoverRuleDeps=new RuleProviderWithDependenciesPredicate(DiscoverFilesAndTypesRuleProvider.class);
      @Override public boolean accept(      WindupRuleProvider provider){
        return !(provider.getPhase().isAssignableFrom(ReportGenerationPhase.class)) && !(provider.getPhase().isAssignableFrom(ReportRenderingPhase.class)) && !(provider.getPhase().isAssignableFrom(DecompilationPhase.class))&& !(provider.getPhase().isAssignableFrom(MigrationRulesPhase.class));
      }
    }
);
    processor.execute(config);
    GraphService<IgnoredArchiveModel> archiveService=new GraphService<>(graphContext,IgnoredArchiveModel.class);
    Iterable<IgnoredArchiveModel> archives=archiveService.findAllByProperty(IgnoredArchiveModel.FILE_NAME,""String_Node_Str"");
    Assert.assertTrue(archives.iterator().hasNext());
    for (    IgnoredArchiveModel archive : archives) {
      Assert.assertNotNull(archive);
      Assert.assertTrue(archive instanceof IdentifiedArchiveModel);
      ArchiveCoordinateModel archiveCoordinate=((IdentifiedArchiveModel)archive).getCoordinate();
      Assert.assertNotNull(archiveCoordinate);
      final Coordinate expected=CoordinateBuilder.create(LOG4J_COORDINATE);
      final CoordinateBuilder actual=CoordinateBuilder.create().setGroupId(archiveCoordinate.getGroupId()).setArtifactId(archiveCoordinate.getArtifactId()).setPackaging(archiveCoordinate.getPackaging()).setClassifier(archiveCoordinate.getClassifier()).setVersion(archiveCoordinate.getVersion());
      Assert.assertEquals(expected.toString(),actual.toString());
    }
  }
 }",0.0503680743897714
109514,"@Test public void testXmlAndJavaSearchParams() throws IOException {
  try (GraphContext context=factory.create()){
    ProjectModel pm=context.getFramed().addVertex(null,ProjectModel.class);
    pm.setName(""String_Node_Str"");
    FileModel inputPath=context.getFramed().addVertex(null,FileModel.class);
    inputPath.setFilePath(""String_Node_Str"");
    Path outputPath=Paths.get(FileUtils.getTempDirectory().toString(),""String_Node_Str"" + UUID.randomUUID().toString());
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    inputPath.setProjectModel(pm);
    pm.setRootFileModel(inputPath);
    Predicate<WindupRuleProvider> predicate=new Predicate<WindupRuleProvider>(){
      @Override public boolean accept(      WindupRuleProvider provider){
        return (provider.getPhase() != ReportGeneration.class) && (provider.getPhase() != MigrationRules.class);
      }
    }
;
    WindupConfiguration windupConfiguration=new WindupConfiguration().setRuleProviderFilter(predicate).setGraphContext(context);
    windupConfiguration.setInputPath(Paths.get(inputPath.getFilePath()));
    windupConfiguration.setOutputDirectory(outputPath);
    processor.execute(windupConfiguration);
    GraphService<InlineHintModel> hintService=new GraphService<>(context,InlineHintModel.class);
    int count=0;
    for (    InlineHintModel model : hintService.findAll()) {
      String text=model.getHint();
      System.out.println(""String_Node_Str"" + text + ""String_Node_Str""+ model);
      Assert.assertNotNull(text);
      Assert.assertEquals(""String_Node_Str"",text);
      count++;
    }
    Assert.assertEquals(1,count);
  }
 }","@Test public void testXmlAndJavaSearchParams() throws IOException {
  try (GraphContext context=factory.create()){
    ProjectModel pm=context.getFramed().addVertex(null,ProjectModel.class);
    pm.setName(""String_Node_Str"");
    FileModel inputPath=context.getFramed().addVertex(null,FileModel.class);
    inputPath.setFilePath(""String_Node_Str"");
    Path outputPath=Paths.get(FileUtils.getTempDirectory().toString(),""String_Node_Str"" + UUID.randomUUID().toString());
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    inputPath.setProjectModel(pm);
    pm.setRootFileModel(inputPath);
    Predicate<WindupRuleProvider> predicate=new Predicate<WindupRuleProvider>(){
      @Override public boolean accept(      WindupRuleProvider provider){
        return (provider.getPhase() != ReportGenerationPhase.class) && (provider.getPhase() != MigrationRulesPhase.class);
      }
    }
;
    WindupConfiguration windupConfiguration=new WindupConfiguration().setRuleProviderFilter(predicate).setGraphContext(context);
    windupConfiguration.setInputPath(Paths.get(inputPath.getFilePath()));
    windupConfiguration.setOutputDirectory(outputPath);
    processor.execute(windupConfiguration);
    GraphService<InlineHintModel> hintService=new GraphService<>(context,InlineHintModel.class);
    int count=0;
    for (    InlineHintModel model : hintService.findAll()) {
      String text=model.getHint();
      System.out.println(""String_Node_Str"" + text + ""String_Node_Str""+ model);
      Assert.assertNotNull(text);
      Assert.assertEquals(""String_Node_Str"",text);
      count++;
    }
    Assert.assertEquals(1,count);
  }
 }",0.9969915764139592
109515,"@Override public Class<? extends RulePhase> getPhase(){
  return PostMigrationRules.class;
}","@Override public Class<? extends RulePhase> getPhase(){
  return PostMigrationRulesPhase.class;
}",0.9735449735449736
109516,"@Override public boolean accept(WindupRuleProvider provider){
  return (provider.getPhase() != ReportGeneration.class) && (provider.getPhase() != MigrationRules.class);
}","@Override public boolean accept(WindupRuleProvider provider){
  return (provider.getPhase() != ReportGenerationPhase.class) && (provider.getPhase() != MigrationRulesPhase.class);
}",0.9714285714285714
109517,"/** 
 * The folder containing the xml file currently being parse. This should be the root folder from which any other resource lookups should be based. Eg, it may be the user scripts folder. If this is set, it should take precedent over the Addon for resource lookups.
 */
public Path getXmlInputPath(){
  return xmlInputPath;
}","/** 
 * The path to the rule xml file itself (eg, /path/to/rule.windup.xml).
 */
public Path getXmlInputPath(){
  return this.xmlInputPath;
}",0.4477611940298507
109518,"/** 
 * The folder containing the xml file currently being parse. This should be the root folder from which any other resource lookups should be based. Eg, it may be the user scripts folder. If this is set, it should take precedent over the Addon for resource lookups.
 */
public void setXmlInputPath(Path xmlInputPath){
  this.xmlInputPath=xmlInputPath;
}","/** 
 * The path to the rule xml file itself (eg, /path/to/rule.windup.xml).
 */
public void setXmlInputPath(Path xmlInputPath){
  this.xmlInputPath=xmlInputPath;
}",0.5115384615384615
109519,"@Override public List<WindupRuleProvider> getProviders(GraphContext context){
  List<WindupRuleProvider> providers=new ArrayList<>();
  DocumentBuilderFactory dbFactory=DocumentBuilderFactory.newInstance();
  dbFactory.setNamespaceAware(true);
  DocumentBuilder dBuilder=null;
  try {
    dBuilder=dbFactory.newDocumentBuilder();
  }
 catch (  Exception e) {
    throw new WindupException(""String_Node_Str"" + e.getMessage(),e);
  }
  for (  Map.Entry<Addon,List<URL>> addonFiles : getAddonWindupXmlFiles().entrySet()) {
    Addon addon=addonFiles.getKey();
    List<URL> urls=addonFiles.getValue();
    for (    URL resource : urls) {
      try {
        Document doc=dBuilder.parse(resource.toURI().toString());
        ParserContext parser=new ParserContext(furnace);
        parser.setAddonContainingInputXML(addon);
        parser.processElement(doc.getDocumentElement());
        List<WindupRuleProvider> parsedProviders=parser.getRuleProviders();
        setOrigin(parsedProviders,resource);
        providers.addAll(parsedProviders);
      }
 catch (      Exception e) {
        throw new WindupException(""String_Node_Str"" + resource.toString() + ""String_Node_Str""+ e.getMessage(),e);
      }
    }
  }
  WindupConfigurationModel cfg=WindupConfigurationService.getConfigurationModel(context);
  for (  FileModel userRulesFileModel : cfg.getUserRulesPaths()) {
    for (    URL resource : getWindupUserDirectoryXmlFiles(userRulesFileModel)) {
      try {
        Document doc=dBuilder.parse(resource.toURI().toString());
        ParserContext parser=new ParserContext(furnace);
        String userRulesPath=userRulesFileModel.getFilePath();
        parser.setXmlInputPath(Paths.get(userRulesPath));
        parser.processElement(doc.getDocumentElement());
        List<WindupRuleProvider> parsedProviders=parser.getRuleProviders();
        setOrigin(parsedProviders,resource);
        providers.addAll(parsedProviders);
      }
 catch (      Exception e) {
        throw new WindupException(""String_Node_Str"" + resource.toString() + ""String_Node_Str""+ e.getMessage(),e);
      }
    }
  }
  return providers;
}","@Override public List<WindupRuleProvider> getProviders(GraphContext context){
  List<WindupRuleProvider> providers=new ArrayList<>();
  DocumentBuilderFactory dbFactory=DocumentBuilderFactory.newInstance();
  dbFactory.setNamespaceAware(true);
  DocumentBuilder dBuilder=null;
  try {
    dBuilder=dbFactory.newDocumentBuilder();
  }
 catch (  Exception e) {
    throw new WindupException(""String_Node_Str"" + e.getMessage(),e);
  }
  for (  Map.Entry<Addon,List<URL>> addonFiles : getAddonWindupXmlFiles().entrySet()) {
    Addon addon=addonFiles.getKey();
    List<URL> urls=addonFiles.getValue();
    for (    URL resource : urls) {
      try {
        Document doc=dBuilder.parse(resource.toURI().toString());
        ParserContext parser=new ParserContext(furnace);
        parser.setAddonContainingInputXML(addon);
        parser.processElement(doc.getDocumentElement());
        List<WindupRuleProvider> parsedProviders=parser.getRuleProviders();
        setOrigin(parsedProviders,resource);
        providers.addAll(parsedProviders);
      }
 catch (      Exception e) {
        throw new WindupException(""String_Node_Str"" + resource.toString() + ""String_Node_Str""+ e.getMessage(),e);
      }
    }
  }
  WindupConfigurationModel cfg=WindupConfigurationService.getConfigurationModel(context);
  for (  FileModel userRulesFileModel : cfg.getUserRulesPaths()) {
    for (    URL resource : getWindupUserDirectoryXmlFiles(userRulesFileModel)) {
      try {
        Document doc=dBuilder.parse(resource.toURI().toString());
        ParserContext parser=new ParserContext(furnace);
        String userRulesPath=userRulesFileModel.getFilePath();
        parser.setXmlInputPath(Paths.get(resource.toURI()));
        parser.setXmlInputRootPath(Paths.get(userRulesPath));
        parser.processElement(doc.getDocumentElement());
        List<WindupRuleProvider> parsedProviders=parser.getRuleProviders();
        setOrigin(parsedProviders,resource);
        providers.addAll(parsedProviders);
      }
 catch (      Exception e) {
        throw new WindupException(""String_Node_Str"" + resource.toString() + ""String_Node_Str""+ e.getMessage(),e);
      }
    }
  }
  return providers;
}",0.9848731673260416
109520,"private void checkForDuplicates(List<WindupRuleProvider> providers){
  Map<WindupRuleProvider,WindupRuleProvider> dupeSet=new HashMap<>(providers.size());
  for (  WindupRuleProvider provider : providers) {
    WindupRuleProvider previousProvider=dupeSet.get(provider);
    if (previousProvider != null) {
      String typeMessage;
      if (previousProvider.getClass().equals(provider.getClass())) {
        typeMessage=""String_Node_Str"" + Proxies.unwrapProxyClassName(provider.getClass()) + ""String_Node_Str"";
      }
 else {
        typeMessage=""String_Node_Str"" + Proxies.unwrapProxyClassName(previousProvider.getClass()) + ""String_Node_Str""+ Proxies.unwrapProxyClassName(provider.getClass())+ ""String_Node_Str"";
      }
      throw new WindupException(""String_Node_Str"" + provider.getID() + typeMessage);
    }
    dupeSet.put(provider,provider);
  }
}","private void checkForDuplicates(List<WindupRuleProvider> providers){
  Map<WindupRuleProvider,WindupRuleProvider> dupeSet=new HashMap<>(providers.size());
  for (  WindupRuleProvider provider : providers) {
    WindupRuleProvider previousProvider=dupeSet.get(provider);
    if (previousProvider != null) {
      String typeMessage;
      if (previousProvider.getClass().equals(provider.getClass())) {
        typeMessage=""String_Node_Str"" + previousProvider.getOrigin() + ""String_Node_Str""+ provider.getOrigin()+ ""String_Node_Str"";
      }
 else {
        typeMessage=""String_Node_Str"" + Proxies.unwrapProxyClassName(previousProvider.getClass()) + ""String_Node_Str""+ previousProvider.getOrigin()+ ""String_Node_Str""+ Proxies.unwrapProxyClassName(provider.getClass())+ ""String_Node_Str""+ provider.getOrigin()+ ""String_Node_Str"";
      }
      throw new WindupException(""String_Node_Str"" + provider.getID() + typeMessage);
    }
    dupeSet.put(provider,provider);
  }
}",0.7927631578947368
109521,"@Override public XSLTTransformation processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String description=$(element).attr(""String_Node_Str"");
  String extension=$(element).attr(""String_Node_Str"");
  String template=$(element).attr(""String_Node_Str"");
  String of=$(element).attr(""String_Node_Str"");
  if (StringUtils.isBlank(description)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(template)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(extension)) {
    throw new WindupException(""String_Node_Str"");
  }
  Map<String,String> parameters=new HashMap<String,String>();
  List<Element> children=$(element).children(""String_Node_Str"").get();
  for (  Element child : children) {
    XSLTParameter param=handlerManager.processElement(child);
    parameters.put(param.getKey(),param.getValue());
  }
  Path pathContainingXml=handlerManager.getXmlInputPath();
  if (pathContainingXml != null) {
    String fullPath;
    if (template.startsWith(""String_Node_Str"") || template.startsWith(""String_Node_Str"")) {
      fullPath=template;
    }
 else {
      fullPath=pathContainingXml.resolve(template).toAbsolutePath().toString();
    }
    if (of != null) {
      return (XSLTTransformation)XSLTTransformation.of(of).usingFilesystem(fullPath).withDescription(description).withExtension(extension).withParameters(parameters);
    }
    return (XSLTTransformation)XSLTTransformation.usingFilesystem(fullPath).withDescription(description).withExtension(extension).withParameters(parameters);
  }
 else {
    ClassLoader xmlFileAddonClassLoader=handlerManager.getAddonContainingInputXML().getClassLoader();
    if (of != null) {
      return (XSLTTransformation)XSLTTransformation.of(of).using(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension).withParameters(parameters);
    }
    return (XSLTTransformation)XSLTTransformation.using(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension).withParameters(parameters);
  }
}","@Override public XSLTTransformation processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String description=$(element).attr(""String_Node_Str"");
  String extension=$(element).attr(""String_Node_Str"");
  String template=$(element).attr(""String_Node_Str"");
  String of=$(element).attr(""String_Node_Str"");
  if (StringUtils.isBlank(description)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(template)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(extension)) {
    throw new WindupException(""String_Node_Str"");
  }
  Map<String,String> parameters=new HashMap<String,String>();
  List<Element> children=$(element).children(""String_Node_Str"").get();
  for (  Element child : children) {
    XSLTParameter param=handlerManager.processElement(child);
    parameters.put(param.getKey(),param.getValue());
  }
  Path pathContainingXml=handlerManager.getXmlInputRootPath();
  if (pathContainingXml != null) {
    String fullPath;
    if (template.startsWith(""String_Node_Str"") || template.startsWith(""String_Node_Str"")) {
      fullPath=template;
    }
 else {
      Path path=pathContainingXml.resolve(template).toAbsolutePath();
      if (!Files.exists(path)) {
        Path rulesParentPath=handlerManager.getXmlInputPath().getParent();
        fullPath=rulesParentPath.resolve(template).normalize().toAbsolutePath().toString();
      }
 else {
        fullPath=path.normalize().toString();
      }
    }
    if (of != null) {
      return (XSLTTransformation)XSLTTransformation.of(of).usingFilesystem(fullPath).withDescription(description).withExtension(extension).withParameters(parameters);
    }
    return (XSLTTransformation)XSLTTransformation.usingFilesystem(fullPath).withDescription(description).withExtension(extension).withParameters(parameters);
  }
 else {
    ClassLoader xmlFileAddonClassLoader=handlerManager.getAddonContainingInputXML().getClassLoader();
    if (of != null) {
      return (XSLTTransformation)XSLTTransformation.of(of).using(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension).withParameters(parameters);
    }
    return (XSLTTransformation)XSLTTransformation.using(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension).withParameters(parameters);
  }
}",0.9341397849462364
109522,"XmlFilePersistXPathFunction(GraphContext graphContext,XmlFileModel xml,XmlFileEvaluationStrategy evaluationStrategy,ParameterStore store,XmlFileParameterMatchCache paramMatchCache,List<WindupVertexFrame> resultLocations){
  this.graphContext=graphContext;
  this.xml=xml;
  this.evaluationStrategy=evaluationStrategy;
  this.store=store;
  this.paramMatchCache=paramMatchCache;
  this.resultLocations=resultLocations;
}","XmlFilePersistXPathFunction(GraphRewrite event,EvaluationContext context,XmlFileModel xml,XmlFileEvaluationStrategy evaluationStrategy,ParameterStore store,XmlFileParameterMatchCache paramMatchCache,List<WindupVertexFrame> resultLocations){
  this.event=event;
  this.context=context;
  this.xml=xml;
  this.evaluationStrategy=evaluationStrategy;
  this.store=store;
  this.paramMatchCache=paramMatchCache;
  this.resultLocations=resultLocations;
}",0.908881199538639
109523,"@Override public Object evaluate(@SuppressWarnings(""String_Node_Str"") List args) throws XPathFunctionException {
  int frameIdx=((Double)args.get(0)).intValue();
  NodeList arg1=(NodeList)args.get(1);
  String nodeText=XmlUtil.nodeListToString(arg1);
  LOG.fine(""String_Node_Str"" + frameIdx + ""String_Node_Str""+ nodeText+ ""String_Node_Str"");
  for (int i=0; i < arg1.getLength(); i++) {
    Node node=arg1.item(i);
    if (xpathResultMatch != null) {
      if (!node.toString().matches(xpathResultMatch)) {
        continue;
      }
    }
    int lineNumber=(int)node.getUserData(LocationAwareContentHandler.LINE_NUMBER_KEY_NAME);
    int columnNumber=(int)node.getUserData(LocationAwareContentHandler.COLUMN_NUMBER_KEY_NAME);
    GraphService<XmlTypeReferenceModel> fileLocationService=new GraphService<XmlTypeReferenceModel>(graphContext,XmlTypeReferenceModel.class);
    XmlTypeReferenceModel fileLocation=fileLocationService.create();
    String sourceSnippit=XmlUtil.nodeToString(node);
    fileLocation.setSourceSnippit(sourceSnippit);
    fileLocation.setLineNumber(lineNumber);
    fileLocation.setColumnNumber(columnNumber);
    fileLocation.setLength(node.toString().length());
    fileLocation.setFile(xml);
    fileLocation.setXpath(xpathString);
    GraphService<NamespaceMetaModel> metaModelService=new GraphService<NamespaceMetaModel>(graphContext,NamespaceMetaModel.class);
    for (    Map.Entry<String,String> namespace : namespaces.entrySet()) {
      NamespaceMetaModel metaModel=metaModelService.create();
      metaModel.setSchemaLocation(namespace.getKey());
      metaModel.setSchemaLocation(namespace.getValue());
      metaModel.addXmlResource(xml);
      fileLocation.addNamespace(metaModel);
    }
    resultLocations.add(fileLocation);
    evaluationStrategy.modelSubmissionRejected();
    evaluationStrategy.modelMatched();
    for (    Map.Entry<String,String> entry : paramMatchCache.getVariables(frameIdx).entrySet()) {
      Parameter<?> param=store.get(entry.getKey());
      String value=entry.getValue();
      if (!evaluationStrategy.submitValue(param,value)) {
        evaluationStrategy.modelSubmissionRejected();
        return false;
      }
    }
    evaluationStrategy.modelSubmitted(fileLocation);
    evaluationStrategy.modelMatched();
  }
  return true;
}","@Override public Object evaluate(@SuppressWarnings(""String_Node_Str"") List args) throws XPathFunctionException {
  int frameIdx=((Double)args.get(0)).intValue();
  NodeList arg1=(NodeList)args.get(1);
  String nodeText=XmlUtil.nodeListToString(arg1);
  LOG.fine(""String_Node_Str"" + frameIdx + ""String_Node_Str""+ nodeText+ ""String_Node_Str"");
  for (int i=0; i < arg1.getLength(); i++) {
    Node node=arg1.item(i);
    if (xpathResultMatch != null) {
      if (!node.toString().matches(xpathResultMatch)) {
        continue;
      }
    }
    int lineNumber=(int)node.getUserData(LocationAwareContentHandler.LINE_NUMBER_KEY_NAME);
    int columnNumber=(int)node.getUserData(LocationAwareContentHandler.COLUMN_NUMBER_KEY_NAME);
    GraphService<XmlTypeReferenceModel> fileLocationService=new GraphService<XmlTypeReferenceModel>(event.getGraphContext(),XmlTypeReferenceModel.class);
    XmlTypeReferenceModel fileLocation=fileLocationService.create();
    String sourceSnippit=XmlUtil.nodeToString(node);
    fileLocation.setSourceSnippit(sourceSnippit);
    fileLocation.setLineNumber(lineNumber);
    fileLocation.setColumnNumber(columnNumber);
    fileLocation.setLength(node.toString().length());
    fileLocation.setFile(xml);
    fileLocation.setXpath(xpathString);
    GraphService<NamespaceMetaModel> metaModelService=new GraphService<NamespaceMetaModel>(event.getGraphContext(),NamespaceMetaModel.class);
    for (    Map.Entry<String,String> namespace : namespaces.entrySet()) {
      NamespaceMetaModel metaModel=metaModelService.create();
      metaModel.setSchemaLocation(namespace.getKey());
      metaModel.setSchemaLocation(namespace.getValue());
      metaModel.addXmlResource(xml);
      fileLocation.addNamespace(metaModel);
    }
    resultLocations.add(fileLocation);
    evaluationStrategy.modelSubmissionRejected();
    evaluationStrategy.modelMatched();
    if (fileNamePattern != null) {
      if (!fileNamePattern.parse(xml.getFileName()).submit(event,context)) {
        evaluationStrategy.modelSubmissionRejected();
        continue;
      }
    }
    for (    Map.Entry<String,String> entry : paramMatchCache.getVariables(frameIdx).entrySet()) {
      Parameter<?> param=store.get(entry.getKey());
      String value=entry.getValue();
      if (!evaluationStrategy.submitValue(param,value)) {
        evaluationStrategy.modelSubmissionRejected();
        return false;
      }
    }
    evaluationStrategy.modelSubmitted(fileLocation);
    evaluationStrategy.modelMatched();
  }
  return true;
}",0.9535655058043118
109524,"@Override public Configuration getConfiguration(GraphContext context){
  return ConfigurationBuilder.begin().addRule().when(Query.fromType(FileModel.class).withProperty(FileModel.IS_DIRECTORY,true)).perform(new RecurseDirectoryAndAddFiles()).addRule().when(Query.fromType(FileModel.class).withProperty(FileModel.IS_DIRECTORY,false).withProperty(FileModel.FILE_PATH,QueryPropertyComparisonType.REGEX,ZipUtil.getEndsWithZipRegularExpression())).perform(new AddArchiveReferenceInformation());
}","@Override public Configuration getConfiguration(GraphContext context){
  return ConfigurationBuilder.begin().addRule().when(Query.fromType(WindupConfigurationModel.class).piped(new QueryGremlinCriterion(){
    @Override public void query(    GraphRewrite event,    GremlinPipeline<Vertex,Vertex> pipeline){
      pipeline.out(WindupConfigurationModel.INPUT_PATH);
      pipeline.has(FileModel.IS_DIRECTORY,true);
    }
  }
)).perform(new RecurseDirectoryAndAddFiles()).addRule().when(Query.fromType(FileModel.class).withProperty(FileModel.IS_DIRECTORY,false).withProperty(FileModel.FILE_PATH,QueryPropertyComparisonType.REGEX,ZipUtil.getEndsWithZipRegularExpression())).perform(new AddArchiveReferenceInformation());
}",0.7890818858560794
109525,"@Override public Configuration getConfiguration(GraphContext context){
  ConditionBuilder fileWhen=Query.fromType(XmlFileModel.class).withProperty(FileModel.FILE_NAME,""String_Node_Str"");
  AbstractIterationOperation<XmlFileModel> evaluatePomFiles=new AbstractIterationOperation<XmlFileModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    XmlFileModel payload){
      MavenProjectModel mavenProjectModel=extractMavenProjectModel(event,payload);
      if (mavenProjectModel != null) {
        ArchiveModel archiveModel=payload.getParentArchive();
        if (archiveModel != null) {
          archiveModel.setProjectModel(mavenProjectModel);
          mavenProjectModel.setRootFileModel(archiveModel);
          for (          FileModel f : archiveModel.getContainedFileModels()) {
            if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
              f.setProjectModel(mavenProjectModel);
              mavenProjectModel.addFileModel(f);
            }
          }
        }
 else {
          File parentFile=payload.asFile().getParentFile();
          FileModel parentFileModel=new FileService(event.getGraphContext()).findByPath(parentFile.getAbsolutePath());
          if (parentFileModel != null) {
            parentFileModel.setProjectModel(mavenProjectModel);
            mavenProjectModel.addFileModel(parentFileModel);
            mavenProjectModel.setRootFileModel(parentFileModel);
            for (            FileModel childFile : parentFileModel.getFilesInDirectory()) {
              addFilesToModel(mavenProjectModel,childFile);
            }
          }
        }
      }
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  return ConfigurationBuilder.begin().addRule().when(fileWhen).perform(evaluatePomFiles);
}","@Override public Configuration getConfiguration(GraphContext context){
  ConditionBuilder fileWhen=Query.fromType(XmlFileModel.class).withProperty(FileModel.FILE_NAME,""String_Node_Str"");
  AbstractIterationOperation<XmlFileModel> evaluatePomFiles=new AbstractIterationOperation<XmlFileModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    XmlFileModel payload){
      MavenProjectModel mavenProjectModel=extractMavenProjectModel(event,payload);
      if (mavenProjectModel != null) {
        ArchiveModel archiveModel=payload.getParentArchive();
        if (archiveModel != null && !isAlreadyMavenProject(archiveModel)) {
          archiveModel.setProjectModel(mavenProjectModel);
          mavenProjectModel.setRootFileModel(archiveModel);
          for (          FileModel f : archiveModel.getContainedFileModels()) {
            if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
              f.setProjectModel(mavenProjectModel);
              mavenProjectModel.addFileModel(f);
            }
          }
        }
 else {
          File parentFile=payload.asFile().getParentFile();
          FileModel parentFileModel=new FileService(event.getGraphContext()).findByPath(parentFile.getAbsolutePath());
          if (parentFileModel != null && !isAlreadyMavenProject(parentFileModel)) {
            parentFileModel.setProjectModel(mavenProjectModel);
            mavenProjectModel.addFileModel(parentFileModel);
            mavenProjectModel.setRootFileModel(parentFileModel);
            for (            FileModel childFile : parentFileModel.getFilesInDirectory()) {
              addFilesToModel(mavenProjectModel,childFile);
            }
          }
        }
      }
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  return ConfigurationBuilder.begin().addRule().when(fileWhen).perform(evaluatePomFiles);
}",0.977931401223079
109526,"@Override public void perform(GraphRewrite event,EvaluationContext context,XmlFileModel payload){
  MavenProjectModel mavenProjectModel=extractMavenProjectModel(event,payload);
  if (mavenProjectModel != null) {
    ArchiveModel archiveModel=payload.getParentArchive();
    if (archiveModel != null) {
      archiveModel.setProjectModel(mavenProjectModel);
      mavenProjectModel.setRootFileModel(archiveModel);
      for (      FileModel f : archiveModel.getContainedFileModels()) {
        if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
          f.setProjectModel(mavenProjectModel);
          mavenProjectModel.addFileModel(f);
        }
      }
    }
 else {
      File parentFile=payload.asFile().getParentFile();
      FileModel parentFileModel=new FileService(event.getGraphContext()).findByPath(parentFile.getAbsolutePath());
      if (parentFileModel != null) {
        parentFileModel.setProjectModel(mavenProjectModel);
        mavenProjectModel.addFileModel(parentFileModel);
        mavenProjectModel.setRootFileModel(parentFileModel);
        for (        FileModel childFile : parentFileModel.getFilesInDirectory()) {
          addFilesToModel(mavenProjectModel,childFile);
        }
      }
    }
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,XmlFileModel payload){
  MavenProjectModel mavenProjectModel=extractMavenProjectModel(event,payload);
  if (mavenProjectModel != null) {
    ArchiveModel archiveModel=payload.getParentArchive();
    if (archiveModel != null && !isAlreadyMavenProject(archiveModel)) {
      archiveModel.setProjectModel(mavenProjectModel);
      mavenProjectModel.setRootFileModel(archiveModel);
      for (      FileModel f : archiveModel.getContainedFileModels()) {
        if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
          f.setProjectModel(mavenProjectModel);
          mavenProjectModel.addFileModel(f);
        }
      }
    }
 else {
      File parentFile=payload.asFile().getParentFile();
      FileModel parentFileModel=new FileService(event.getGraphContext()).findByPath(parentFile.getAbsolutePath());
      if (parentFileModel != null && !isAlreadyMavenProject(parentFileModel)) {
        parentFileModel.setProjectModel(mavenProjectModel);
        mavenProjectModel.addFileModel(parentFileModel);
        mavenProjectModel.setRootFileModel(parentFileModel);
        for (        FileModel childFile : parentFileModel.getFilesInDirectory()) {
          addFilesToModel(mavenProjectModel,childFile);
        }
      }
    }
  }
}",0.9676160749122122
109527,"@Override public Iteration processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String overVar=$(element).attr(""String_Node_Str"");
  IterationBuilderOver iterationOver=StringUtils.isEmpty(overVar) ? Iteration.over() : Iteration.over(overVar);
  List<Element> children=$(element).children().get();
  List<Operation> operations=new ArrayList<>(children.size());
  List<Operation> otherwise=new ArrayList<>();
  for (  Element child : children) {
    if (""String_Node_Str"".equals(child.getNodeName())) {
      List<Element> whenElements=$(child).children().get();
      for (      Element whenElement : whenElements) {
        Object object=handlerManager.processElement(whenElement);
        if (object instanceof Condition) {
          iterationOver.when((Condition)object);
        }
      }
    }
 else     if (""String_Node_Str"".equals(child.getNodeName())) {
      List<Element> performElements=$(child).children().get();
      for (      Element performElement : performElements) {
        Object object=handlerManager.processElement(performElement);
        if (object instanceof Operation) {
          operations.add((Operation)object);
        }
      }
    }
 else     if (""String_Node_Str"".equals(child.getNodeName())) {
      List<Element> otherwiseElements=$(child).children().get();
      for (      Element otherwiseElement : otherwiseElements) {
        Object object=handlerManager.processElement(otherwiseElement);
        if (object instanceof Operation) {
          otherwise.add((Operation)object);
        }
      }
    }
 else {
      Object object=handlerManager.processElement(child);
      if (object instanceof Operation) {
        operations.add((Operation)object);
      }
    }
  }
  IterationBuilderPerform iterationBuilderPerform=iterationOver.perform(operations.toArray(new Operation[operations.size()]));
  if (otherwise.size() > 0) {
    IterationBuilderOtherwise iterationBuilderOtherwise=iterationBuilderPerform.otherwise(Perform.all(otherwise.toArray(new Operation[otherwise.size()])));
    return (Iteration)iterationBuilderOtherwise;
  }
  return (Iteration)iterationBuilderPerform;
}","@Override public Iteration processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String overVar=$(element).attr(""String_Node_Str"");
  IterationBuilderOver iterationOver=StringUtils.isEmpty(overVar) ? Iteration.over() : Iteration.over(overVar);
  List<Element> children=$(element).children().get();
  List<Operation> operations=new ArrayList<>(children.size());
  List<Operation> otherwise=new ArrayList<>();
  for (  Element child : children) {
    if (""String_Node_Str"".equals(child.getNodeName())) {
      List<Element> whenElements=$(child).children().get();
      for (      Element whenElement : whenElements) {
        Object object=handlerManager.processElement(whenElement);
        if (object instanceof Condition) {
          iterationOver.when((Condition)object);
        }
      }
    }
 else     if (""String_Node_Str"".equals(child.getNodeName())) {
      List<Element> performElements=$(child).children().get();
      for (      Element performElement : performElements) {
        Object object=handlerManager.processElement(performElement);
        if (object instanceof Operation) {
          operations.add((Operation)object);
        }
      }
    }
 else     if (""String_Node_Str"".equals(child.getNodeName())) {
      List<Element> otherwiseElements=$(child).children().get();
      for (      Element otherwiseElement : otherwiseElements) {
        Object object=handlerManager.processElement(otherwiseElement);
        if (object instanceof Operation) {
          otherwise.add((Operation)object);
        }
      }
    }
 else {
      Object object=handlerManager.processElement(child);
      if (object instanceof Operation) {
        operations.add((Operation)object);
      }
 else       if (object instanceof Condition) {
        iterationOver.when((Condition)object);
      }
    }
  }
  IterationBuilderPerform iterationBuilderPerform=iterationOver.perform(operations.toArray(new Operation[operations.size()]));
  if (otherwise.size() > 0) {
    IterationBuilderOtherwise iterationBuilderOtherwise=iterationBuilderPerform.otherwise(Perform.all(otherwise.toArray(new Operation[otherwise.size()])));
    return (Iteration)iterationBuilderOtherwise;
  }
  return (Iteration)iterationBuilderPerform;
}",0.9769647696476964
109528,"@Test public void testJavaClassCondition() throws IOException, InstantiationException, IllegalAccessException {
  try (GraphContext context=factory.create(getDefaultPath())){
    final String inputDir=""String_Node_Str"";
    final Path outputPath=Paths.get(FileUtils.getTempDirectory().toString(),""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    ProjectModel pm=context.getFramed().addVertex(null,ProjectModel.class);
    pm.setName(""String_Node_Str"");
    FileModel inputPathFrame=context.getFramed().addVertex(null,FileModel.class);
    inputPathFrame.setFilePath(inputDir);
    inputPathFrame.setProjectModel(pm);
    pm.addFileModel(inputPathFrame);
    pm.setRootFileModel(inputPathFrame);
    FileModel fileModel=context.getFramed().addVertex(null,FileModel.class);
    fileModel.setFilePath(inputDir + ""String_Node_Str"");
    fileModel.setProjectModel(pm);
    pm.addFileModel(fileModel);
    fileModel=context.getFramed().addVertex(null,FileModel.class);
    fileModel.setFilePath(inputDir + ""String_Node_Str"");
    fileModel.setProjectModel(pm);
    pm.addFileModel(fileModel);
    context.getGraph().getBaseGraph().commit();
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    int count=0;
    for (    JavaTypeReferenceModel ref : typeReferences) {
      Assert.assertTrue(ref.getSourceSnippit().contains(""String_Node_Str""));
      count++;
    }
    Assert.assertEquals(5,count);
    GraphService<InlineHintModel> hintService=new GraphService<>(context,InlineHintModel.class);
    Iterable<InlineHintModel> hints=hintService.findAll();
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str""))       count++;
    }
    Assert.assertEquals(3,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str""))       count++;
    }
    Assert.assertEquals(1,count);
  }
 }","@Test public void testJavaClassCondition() throws IOException, InstantiationException, IllegalAccessException {
  try (GraphContext context=factory.create(getDefaultPath())){
    final String inputDir=""String_Node_Str"";
    final Path outputPath=Paths.get(FileUtils.getTempDirectory().toString(),""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
    FileUtils.deleteDirectory(outputPath.toFile());
    Files.createDirectories(outputPath);
    ProjectModel pm=context.getFramed().addVertex(null,ProjectModel.class);
    pm.setName(""String_Node_Str"");
    FileModel inputPathFrame=context.getFramed().addVertex(null,FileModel.class);
    inputPathFrame.setFilePath(inputDir);
    inputPathFrame.setProjectModel(pm);
    pm.addFileModel(inputPathFrame);
    pm.setRootFileModel(inputPathFrame);
    FileModel fileModel=context.getFramed().addVertex(null,FileModel.class);
    fileModel.setFilePath(inputDir + ""String_Node_Str"");
    fileModel.setProjectModel(pm);
    pm.addFileModel(fileModel);
    fileModel=context.getFramed().addVertex(null,FileModel.class);
    fileModel.setFilePath(inputDir + ""String_Node_Str"");
    fileModel.setProjectModel(pm);
    pm.addFileModel(fileModel);
    context.getGraph().getBaseGraph().commit();
    final WindupConfiguration processorConfig=new WindupConfiguration().setOutputDirectory(outputPath);
    processorConfig.setGraphContext(context);
    processorConfig.setInputPath(Paths.get(inputDir));
    processorConfig.setOutputDirectory(outputPath);
    processorConfig.setOptionValue(ScanPackagesOption.NAME,Collections.singletonList(""String_Node_Str""));
    processor.execute(processorConfig);
    GraphService<JavaTypeReferenceModel> typeRefService=new GraphService<>(context,JavaTypeReferenceModel.class);
    Iterable<JavaTypeReferenceModel> typeReferences=typeRefService.findAll();
    int count=0;
    for (    JavaTypeReferenceModel ref : typeReferences) {
      String sourceSnippit=ref.getSourceSnippit();
      Assert.assertTrue(sourceSnippit.contains(""String_Node_Str"") || sourceSnippit.contains(""String_Node_Str""));
      count++;
    }
    Assert.assertEquals(7,count);
    GraphService<InlineHintModel> hintService=new GraphService<>(context,InlineHintModel.class);
    Iterable<InlineHintModel> hints=hintService.findAll();
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str""))       count++;
    }
    Assert.assertEquals(3,count);
    count=0;
    for (    InlineHintModel hint : hints) {
      if (hint.getHint().contains(""String_Node_Str""))       count++;
    }
    Assert.assertEquals(1,count);
  }
 }",0.9742995169082126
109529,"@Override public JavaClassBuilderAt processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String type=$(element).attr(""String_Node_Str"");
  String as=$(element).attr(""String_Node_Str"");
  if (as == null) {
    as=Iteration.DEFAULT_VARIABLE_LIST_STRING;
  }
  if (StringUtils.isBlank(type)) {
    throw new WindupException(""String_Node_Str"");
  }
  List<TypeReferenceLocation> locations=new ArrayList<TypeReferenceLocation>();
  List<Element> children=$(element).children(""String_Node_Str"").get();
  for (  Element child : children) {
    TypeReferenceLocation location=handlerManager.processElement(child);
    locations.add(location);
  }
  JavaClassBuilder javaClassReferences=JavaClass.references(type);
  String namePattern=$(element).attr(""String_Node_Str"");
  if (!StringUtils.isBlank(namePattern)) {
    javaClassReferences.inType(namePattern);
  }
  JavaClassBuilderAt javaClass=javaClassReferences.at(locations.toArray(new TypeReferenceLocation[locations.size()]));
  javaClass.as(as);
  return javaClass;
}","@Override public JavaClassBuilderAt processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String type=$(element).attr(ATTR_REFERENCES);
  String as=$(element).attr(""String_Node_Str"");
  if (as == null) {
    as=Iteration.DEFAULT_VARIABLE_LIST_STRING;
  }
  if (StringUtils.isBlank(type)) {
    throw new WindupException(""String_Node_Str"" + ELEM_NAME + ""String_Node_Str""+ ATTR_REFERENCES+ ""String_Node_Str"");
  }
  List<TypeReferenceLocation> locations=new ArrayList<TypeReferenceLocation>();
  List<Element> children=$(element).children(""String_Node_Str"").get();
  for (  Element child : children) {
    TypeReferenceLocation location=handlerManager.processElement(child);
    locations.add(location);
  }
  JavaClassBuilder javaClassReferences=JavaClass.references(type);
  String namePattern=$(element).attr(""String_Node_Str"");
  if (!StringUtils.isBlank(namePattern)) {
    javaClassReferences.inType(namePattern);
  }
  JavaClassBuilderAt javaClass=javaClassReferences.at(locations.toArray(new TypeReferenceLocation[locations.size()]));
  javaClass.as(as);
  return javaClass;
}",0.955045871559633
109530,"@Override public synchronized void fileDecompiled(final String inputPath,final String decompiledOutputFile){
  executorService.submit(new Runnable(){
    @Override public void run(){
      ArchiveService archiveService=new ArchiveService(context);
      ArchiveModel archiveModel=archiveService.getById(archiveModelID);
      String[] classFilePathTokens=inputPath.split(""String_Node_Str"");
      Path classFilePath=Paths.get(archiveModel.getUnzippedDirectory().getFilePath());
      for (      String pathToken : classFilePathTokens) {
        classFilePath=classFilePath.resolve(pathToken);
      }
      FileModel decompiledFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,decompiledOutputFile);
      if (decompiledFileModel == null) {
        FileModel parentFileModel=fileService.findByPath(Paths.get(decompiledOutputFile).getParent().toString());
        decompiledFileModel=fileService.createByFilePath(parentFileModel,decompiledOutputFile);
        decompiledFileModel.setParentArchive(archiveModel);
      }
      ProjectModel projectModel=archiveModel.getProjectModel();
      decompiledFileModel.setProjectModel(projectModel);
      projectModel.addFileModel(decompiledFileModel);
      if (decompiledOutputFile.endsWith(""String_Node_Str"")) {
        if (!(decompiledFileModel instanceof JavaSourceFileModel)) {
          decompiledFileModel=new GraphService<JavaSourceFileModel>(context,JavaSourceFileModel.class).addTypeToModel(decompiledFileModel);
        }
        JavaSourceFileModel decompiledSourceFileModel=(JavaSourceFileModel)decompiledFileModel;
        TechnologyTagService techTagService=new TechnologyTagService(context);
        techTagService.addTagToFileModel(decompiledSourceFileModel,TECH_TAG,TECH_TAG_LEVEL);
        FileModel classFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,classFilePath.toAbsolutePath().toString());
        if (classFileModel != null && classFileModel instanceof JavaClassFileModel) {
          JavaClassFileModel classModel=(JavaClassFileModel)classFileModel;
          classModel.getJavaClass().setDecompiledSource(decompiledSourceFileModel);
          decompiledSourceFileModel.setPackageName(classModel.getPackageName());
        }
 else {
          throw new WindupException(""String_Node_Str"" + decompiledOutputFile + ""String_Node_Str""+ classFilePath.toString());
        }
      }
      archiveModel.addDecompiledFileModel(decompiledFileModel);
      if (atomicInteger.incrementAndGet() % 100 == 0) {
        LOG.info(""String_Node_Str"" + atomicInteger.get() + ""String_Node_Str""+ archiveModelID);
        context.getGraph().getBaseGraph().commit();
      }
    }
  }
);
}","@Override public synchronized void fileDecompiled(final String inputPath,final String decompiledOutputFile){
  executorService.submit(new Runnable(){
    @Override public void run(){
      ArchiveService archiveService=new ArchiveService(context);
      ArchiveModel archiveModel=archiveService.getById(archiveModelID);
      String[] classFilePathTokens=inputPath.split(""String_Node_Str"");
      Path classFilePath=Paths.get(archiveModel.getUnzippedDirectory().getFilePath());
      for (      String pathToken : classFilePathTokens) {
        classFilePath=classFilePath.resolve(pathToken);
      }
      FileModel decompiledFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,decompiledOutputFile);
      if (decompiledFileModel == null) {
        FileModel parentFileModel=fileService.findByPath(Paths.get(decompiledOutputFile).getParent().toString());
        if (parentFileModel == null) {
          List<Path> lineage=new LinkedList<>();
          Path parentPath=Paths.get(decompiledOutputFile).getParent();
          FileModel existingParentFM=parentFileModel;
          while (existingParentFM == null) {
            lineage.add(0,parentPath);
            parentPath=parentPath.getParent();
            existingParentFM=fileService.findByPath(parentPath.toString());
          }
          FileModel currentParent=existingParentFM;
          for (          Path p : lineage) {
            currentParent=fileService.createByFilePath(currentParent,p.toString());
          }
          parentFileModel=currentParent;
        }
        decompiledFileModel=fileService.createByFilePath(parentFileModel,decompiledOutputFile);
        decompiledFileModel.setParentArchive(archiveModel);
      }
      ProjectModel projectModel=archiveModel.getProjectModel();
      decompiledFileModel.setProjectModel(projectModel);
      projectModel.addFileModel(decompiledFileModel);
      if (decompiledOutputFile.endsWith(""String_Node_Str"")) {
        if (!(decompiledFileModel instanceof JavaSourceFileModel)) {
          decompiledFileModel=new GraphService<JavaSourceFileModel>(context,JavaSourceFileModel.class).addTypeToModel(decompiledFileModel);
        }
        JavaSourceFileModel decompiledSourceFileModel=(JavaSourceFileModel)decompiledFileModel;
        TechnologyTagService techTagService=new TechnologyTagService(context);
        techTagService.addTagToFileModel(decompiledSourceFileModel,TECH_TAG,TECH_TAG_LEVEL);
        FileModel classFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,classFilePath.toAbsolutePath().toString());
        if (classFileModel != null && classFileModel instanceof JavaClassFileModel) {
          JavaClassFileModel classModel=(JavaClassFileModel)classFileModel;
          classModel.getJavaClass().setDecompiledSource(decompiledSourceFileModel);
          decompiledSourceFileModel.setPackageName(classModel.getPackageName());
        }
 else {
          throw new WindupException(""String_Node_Str"" + decompiledOutputFile + ""String_Node_Str""+ classFilePath.toString());
        }
      }
      archiveModel.addDecompiledFileModel(decompiledFileModel);
      if (atomicInteger.incrementAndGet() % 100 == 0) {
        LOG.info(""String_Node_Str"" + atomicInteger.get() + ""String_Node_Str""+ archiveModelID);
        context.getGraph().getBaseGraph().commit();
      }
    }
  }
);
}",0.887295765255085
109531,"@Override public void run(){
  ArchiveService archiveService=new ArchiveService(context);
  ArchiveModel archiveModel=archiveService.getById(archiveModelID);
  String[] classFilePathTokens=inputPath.split(""String_Node_Str"");
  Path classFilePath=Paths.get(archiveModel.getUnzippedDirectory().getFilePath());
  for (  String pathToken : classFilePathTokens) {
    classFilePath=classFilePath.resolve(pathToken);
  }
  FileModel decompiledFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,decompiledOutputFile);
  if (decompiledFileModel == null) {
    FileModel parentFileModel=fileService.findByPath(Paths.get(decompiledOutputFile).getParent().toString());
    decompiledFileModel=fileService.createByFilePath(parentFileModel,decompiledOutputFile);
    decompiledFileModel.setParentArchive(archiveModel);
  }
  ProjectModel projectModel=archiveModel.getProjectModel();
  decompiledFileModel.setProjectModel(projectModel);
  projectModel.addFileModel(decompiledFileModel);
  if (decompiledOutputFile.endsWith(""String_Node_Str"")) {
    if (!(decompiledFileModel instanceof JavaSourceFileModel)) {
      decompiledFileModel=new GraphService<JavaSourceFileModel>(context,JavaSourceFileModel.class).addTypeToModel(decompiledFileModel);
    }
    JavaSourceFileModel decompiledSourceFileModel=(JavaSourceFileModel)decompiledFileModel;
    TechnologyTagService techTagService=new TechnologyTagService(context);
    techTagService.addTagToFileModel(decompiledSourceFileModel,TECH_TAG,TECH_TAG_LEVEL);
    FileModel classFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,classFilePath.toAbsolutePath().toString());
    if (classFileModel != null && classFileModel instanceof JavaClassFileModel) {
      JavaClassFileModel classModel=(JavaClassFileModel)classFileModel;
      classModel.getJavaClass().setDecompiledSource(decompiledSourceFileModel);
      decompiledSourceFileModel.setPackageName(classModel.getPackageName());
    }
 else {
      throw new WindupException(""String_Node_Str"" + decompiledOutputFile + ""String_Node_Str""+ classFilePath.toString());
    }
  }
  archiveModel.addDecompiledFileModel(decompiledFileModel);
  if (atomicInteger.incrementAndGet() % 100 == 0) {
    LOG.info(""String_Node_Str"" + atomicInteger.get() + ""String_Node_Str""+ archiveModelID);
    context.getGraph().getBaseGraph().commit();
  }
}","@Override public void run(){
  ArchiveService archiveService=new ArchiveService(context);
  ArchiveModel archiveModel=archiveService.getById(archiveModelID);
  String[] classFilePathTokens=inputPath.split(""String_Node_Str"");
  Path classFilePath=Paths.get(archiveModel.getUnzippedDirectory().getFilePath());
  for (  String pathToken : classFilePathTokens) {
    classFilePath=classFilePath.resolve(pathToken);
  }
  FileModel decompiledFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,decompiledOutputFile);
  if (decompiledFileModel == null) {
    FileModel parentFileModel=fileService.findByPath(Paths.get(decompiledOutputFile).getParent().toString());
    if (parentFileModel == null) {
      List<Path> lineage=new LinkedList<>();
      Path parentPath=Paths.get(decompiledOutputFile).getParent();
      FileModel existingParentFM=parentFileModel;
      while (existingParentFM == null) {
        lineage.add(0,parentPath);
        parentPath=parentPath.getParent();
        existingParentFM=fileService.findByPath(parentPath.toString());
      }
      FileModel currentParent=existingParentFM;
      for (      Path p : lineage) {
        currentParent=fileService.createByFilePath(currentParent,p.toString());
      }
      parentFileModel=currentParent;
    }
    decompiledFileModel=fileService.createByFilePath(parentFileModel,decompiledOutputFile);
    decompiledFileModel.setParentArchive(archiveModel);
  }
  ProjectModel projectModel=archiveModel.getProjectModel();
  decompiledFileModel.setProjectModel(projectModel);
  projectModel.addFileModel(decompiledFileModel);
  if (decompiledOutputFile.endsWith(""String_Node_Str"")) {
    if (!(decompiledFileModel instanceof JavaSourceFileModel)) {
      decompiledFileModel=new GraphService<JavaSourceFileModel>(context,JavaSourceFileModel.class).addTypeToModel(decompiledFileModel);
    }
    JavaSourceFileModel decompiledSourceFileModel=(JavaSourceFileModel)decompiledFileModel;
    TechnologyTagService techTagService=new TechnologyTagService(context);
    techTagService.addTagToFileModel(decompiledSourceFileModel,TECH_TAG,TECH_TAG_LEVEL);
    FileModel classFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,classFilePath.toAbsolutePath().toString());
    if (classFileModel != null && classFileModel instanceof JavaClassFileModel) {
      JavaClassFileModel classModel=(JavaClassFileModel)classFileModel;
      classModel.getJavaClass().setDecompiledSource(decompiledSourceFileModel);
      decompiledSourceFileModel.setPackageName(classModel.getPackageName());
    }
 else {
      throw new WindupException(""String_Node_Str"" + decompiledOutputFile + ""String_Node_Str""+ classFilePath.toString());
    }
  }
  archiveModel.addDecompiledFileModel(decompiledFileModel);
  if (atomicInteger.incrementAndGet() % 100 == 0) {
    LOG.info(""String_Node_Str"" + atomicInteger.get() + ""String_Node_Str""+ archiveModelID);
    context.getGraph().getBaseGraph().commit();
  }
}",0.8844410876132931
109532,"public void init(CompilationUnit cu,FileModel fileModel){
  this.cu=cu;
  this.fileModel=fileModel;
  this.wildcardImports.clear();
  this.classNameLookedUp.clear();
  this.classNameToFQCN.clear();
  this.names.clear();
  this.nameInstance.clear();
  PackageDeclaration packageDeclaration=cu.getPackage();
  String packageName=packageDeclaration == null ? ""String_Node_Str"" : packageDeclaration.getName().getFullyQualifiedName();
  @SuppressWarnings(""String_Node_Str"") List<TypeDeclaration> types=cu.types();
  if (!types.isEmpty()) {
    TypeDeclaration typeDeclaration=(TypeDeclaration)types.get(0);
    String className=typeDeclaration.getName().getFullyQualifiedName();
    String fqcn=packageName + ""String_Node_Str"" + className;
    this.names.add(""String_Node_Str"");
    this.nameInstance.put(""String_Node_Str"",fqcn);
  }
}","public void init(CompilationUnit cu,FileModel fileModel){
  this.cu=cu;
  this.fileModel=fileModel;
  this.wildcardImports.clear();
  this.classNameLookedUp.clear();
  this.classNameToFQCN.clear();
  this.names.clear();
  this.nameInstance.clear();
  PackageDeclaration packageDeclaration=cu.getPackage();
  String packageName=packageDeclaration == null ? ""String_Node_Str"" : packageDeclaration.getName().getFullyQualifiedName();
  @SuppressWarnings(""String_Node_Str"") List<TypeDeclaration> types=cu.types();
  if (!types.isEmpty()) {
    TypeDeclaration typeDeclaration=(TypeDeclaration)types.get(0);
    String className=typeDeclaration.getName().getFullyQualifiedName();
    if (packageName.equals(""String_Node_Str"")) {
      this.fqcn=className;
    }
 else {
      this.fqcn=packageName + ""String_Node_Str"" + className;
    }
    if (windupJavaCfgService.shouldScanPackage(packageName)) {
      typeRefService.createTypeReference(fileModel,TypeReferenceLocation.TYPE,cu.getLineNumber(typeDeclaration.getStartPosition()),cu.getColumnNumber(cu.getStartPosition()),cu.getLength(),this.fqcn);
    }
    this.names.add(""String_Node_Str"");
    this.nameInstance.put(""String_Node_Str"",fqcn);
  }
}",0.8118518518518518
109533,"public VariableResolvingASTVisitor(GraphContext context){
  this.javaClassService=new JavaClassService(context);
  this.typeRefService=new TypeReferenceService(context);
}","public VariableResolvingASTVisitor(GraphContext context){
  this.javaClassService=new JavaClassService(context);
  this.typeRefService=new TypeReferenceService(context);
  this.windupJavaCfgService=new WindupJavaConfigurationService(context);
}",0.8240963855421687
109534,"@Override public void perform(GraphRewrite event,EvaluationContext context,FileModel payload){
  WindupRoasterWildcardImportResolver.setGraphContext(event.getGraphContext());
  try {
    TechnologyTagService technologyTagService=new TechnologyTagService(event.getGraphContext());
    GraphContext graphContext=event.getGraphContext();
    WindupConfigurationModel configuration=new GraphService<>(graphContext,WindupConfigurationModel.class).getUnique();
    String inputDir=configuration.getInputPath().getFilePath();
    inputDir=Paths.get(inputDir).toAbsolutePath().toString();
    String filepath=payload.getFilePath();
    filepath=Paths.get(filepath).toAbsolutePath().toString();
    if (!filepath.startsWith(inputDir)) {
      return;
    }
    String classFilePath=filepath.substring(inputDir.length() + 1);
    String qualifiedName=classFilePath.replace(File.separatorChar,'.').substring(0,classFilePath.length() - JAVA_SUFFIX_LEN);
    String packageName=""String_Node_Str"";
    if (qualifiedName.contains(""String_Node_Str""))     packageName=qualifiedName.substring(0,qualifiedName.lastIndexOf(""String_Node_Str""));
    if (packageName.startsWith(""String_Node_Str"")) {
      packageName=packageName.substring(""String_Node_Str"".length());
    }
    JavaSourceFileModel javaFileModel=GraphService.addTypeToModel(graphContext,payload,JavaSourceFileModel.class);
    technologyTagService.addTagToFileModel(javaFileModel,TECH_TAG,TECH_TAG_LEVEL);
    javaFileModel.setPackageName(packageName);
    try (FileInputStream fis=new FileInputStream(payload.getFilePath())){
      addParsedClassToFile(fis,event.getGraphContext(),javaFileModel);
    }
 catch (    FileNotFoundException e) {
      throw new WindupException(""String_Node_Str"" + payload.getFilePath() + ""String_Node_Str"",e);
    }
catch (    IOException e) {
      throw new WindupException(""String_Node_Str"" + payload.getFilePath(),e);
    }
catch (    Exception e) {
      LOG.log(Level.WARNING,""String_Node_Str"" + payload.getFilePath() + ""String_Node_Str""+ e.getMessage(),e);
      ClassificationService classificationService=new ClassificationService(graphContext);
      classificationService.attachClassification(javaFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
      return;
    }
  }
  finally {
    WindupRoasterWildcardImportResolver.setGraphContext(null);
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,FileModel payload){
  WindupRoasterWildcardImportResolver.setGraphContext(event.getGraphContext());
  try {
    TechnologyTagService technologyTagService=new TechnologyTagService(event.getGraphContext());
    GraphContext graphContext=event.getGraphContext();
    WindupConfigurationModel configuration=new GraphService<>(graphContext,WindupConfigurationModel.class).getUnique();
    String inputDir=configuration.getInputPath().getFilePath();
    inputDir=Paths.get(inputDir).toAbsolutePath().toString();
    String filepath=payload.getFilePath();
    filepath=Paths.get(filepath).toAbsolutePath().toString();
    String classFilePath;
    if (filepath.startsWith(inputDir)) {
      classFilePath=filepath.substring(inputDir.length() + 1);
    }
 else {
      classFilePath=payload.getPrettyPathWithinProject();
    }
    String qualifiedName=classFilePath.replace(File.separatorChar,'.').substring(0,classFilePath.length() - JAVA_SUFFIX_LEN);
    String packageName=""String_Node_Str"";
    if (qualifiedName.contains(""String_Node_Str""))     packageName=qualifiedName.substring(0,qualifiedName.lastIndexOf(""String_Node_Str""));
    if (packageName.startsWith(""String_Node_Str"")) {
      packageName=packageName.substring(""String_Node_Str"".length());
    }
    JavaSourceFileModel javaFileModel=GraphService.addTypeToModel(graphContext,payload,JavaSourceFileModel.class);
    technologyTagService.addTagToFileModel(javaFileModel,TECH_TAG,TECH_TAG_LEVEL);
    javaFileModel.setPackageName(packageName);
    try (FileInputStream fis=new FileInputStream(payload.getFilePath())){
      addParsedClassToFile(fis,event.getGraphContext(),javaFileModel);
    }
 catch (    FileNotFoundException e) {
      throw new WindupException(""String_Node_Str"" + payload.getFilePath() + ""String_Node_Str"",e);
    }
catch (    IOException e) {
      throw new WindupException(""String_Node_Str"" + payload.getFilePath(),e);
    }
catch (    Exception e) {
      LOG.log(Level.WARNING,""String_Node_Str"" + payload.getFilePath() + ""String_Node_Str""+ e.getMessage(),e);
      ClassificationService classificationService=new ClassificationService(graphContext);
      classificationService.attachClassification(javaFileModel,JavaSourceFileModel.UNPARSEABLE_JAVA_CLASSIFICATION,JavaSourceFileModel.UNPARSEABLE_JAVA_DESCRIPTION);
      return;
    }
  }
  finally {
    WindupRoasterWildcardImportResolver.setGraphContext(null);
  }
}",0.958589585895859
109535,"@Override public RulePhase getPhase(){
  return RulePhase.POST_DISCOVERY;
}","@Override public RulePhase getPhase(){
  return RulePhase.INITIAL_ANALYSIS;
}",0.8421052631578947
109536,"/** 
 * Serializes the timing data to a ""~"" delimited file at outputPath.
 */
public void serializeTimingData(Path outputPath){
  try (FileWriter fw=new FileWriter(outputPath.toFile())){
    for (    Map.Entry<String,TimingData> timing : executionInfo.entrySet()) {
      TimingData data=timing.getValue();
      long totalMillis=(data.totalNanos / 1000000);
      double millisPerExecution=(double)totalMillis / (double)data.numberOfExecutions;
      fw.write(timing.getKey() + ""String_Node_Str"" + data.numberOfExecutions+ ""String_Node_Str""+ totalMillis+ ""String_Node_Str""+ millisPerExecution);
      fw.write(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Serializes the timing data to a ""~"" delimited file at outputPath.
 */
public void serializeTimingData(Path outputPath){
  try (FileWriter fw=new FileWriter(outputPath.toFile())){
    fw.write(""String_Node_Str"");
    for (    Map.Entry<String,TimingData> timing : executionInfo.entrySet()) {
      TimingData data=timing.getValue();
      long totalMillis=(data.totalNanos / 1000000);
      double millisPerExecution=(double)totalMillis / (double)data.numberOfExecutions;
      fw.write(timing.getKey() + ""String_Node_Str"" + data.numberOfExecutions+ ""String_Node_Str""+ totalMillis+ ""String_Node_Str""+ millisPerExecution);
      fw.write(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9768421052631578
109537,"@Override public JavaClassBuilderAt processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String type=$(element).attr(""String_Node_Str"");
  String as=$(element).attr(""String_Node_Str"");
  if (as == null) {
    as=Iteration.DEFAULT_VARIABLE_LIST_STRING;
  }
  if (StringUtils.isBlank(type)) {
    throw new WindupException(""String_Node_Str"");
  }
  List<TypeReferenceLocation> locations=new ArrayList<TypeReferenceLocation>();
  List<Element> children=$(element).children(""String_Node_Str"").get();
  for (  Element child : children) {
    TypeReferenceLocation location=handlerManager.processElement(child);
    locations.add(location);
  }
  JavaClassBuilder javaClassReferences=JavaClass.references(type);
  String namePattern=$(element).attr(""String_Node_Str"");
  if (!StringUtils.isBlank(namePattern)) {
    javaClassReferences.inType(namePattern);
  }
  JavaClassBuilderAt javaClass=javaClassReferences.at(locations.toArray(new TypeReferenceLocation[locations.size()]));
  javaClass.as(as);
  return javaClass;
}","@Override public JavaClassBuilderAt processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String type=$(element).attr(ATTR_REFERENCES);
  String as=$(element).attr(""String_Node_Str"");
  if (as == null) {
    as=Iteration.DEFAULT_VARIABLE_LIST_STRING;
  }
  if (StringUtils.isBlank(type)) {
    throw new WindupException(""String_Node_Str"" + ELEM_NAME + ""String_Node_Str""+ ATTR_REFERENCES+ ""String_Node_Str"");
  }
  List<TypeReferenceLocation> locations=new ArrayList<TypeReferenceLocation>();
  List<Element> children=$(element).children(""String_Node_Str"").get();
  for (  Element child : children) {
    TypeReferenceLocation location=handlerManager.processElement(child);
    locations.add(location);
  }
  JavaClassBuilder javaClassReferences=JavaClass.references(type);
  String namePattern=$(element).attr(""String_Node_Str"");
  if (!StringUtils.isBlank(namePattern)) {
    javaClassReferences.inType(namePattern);
  }
  JavaClassBuilderAt javaClass=javaClassReferences.at(locations.toArray(new TypeReferenceLocation[locations.size()]));
  javaClass.as(as);
  return javaClass;
}",0.955045871559633
109538,"/** 
 * Decompiles .class files and nested archives in the given archive, as allowed by the given filter. <p> Nested archives will be decompiled into directories matching the name of the archive, e.g. <code>foo.ear/bar.jar/src/com/foo/bar/Baz.java</code>. <p> Required directories will be created as needed.
 * @param archive The archive containing source files and archives.
 * @param outputDir The directory where decompiled .java files will be placed.
 * @param filter Decides which classes will be decompiled.
 * @returns Result with all decompilation failures. Never throws.
 */
public DecompilationResult decompileArchive(final File archive,File outputDir,Filter<ZipEntry> filter,final DecompilationListener listener) throws DecompilationException {
  Checks.checkFileToBeRead(archive,""String_Node_Str"");
  Checks.checkDirectoryToBeFilled(outputDir,""String_Node_Str"");
  log.info(""String_Node_Str"" + archive.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath()+ ""String_Node_Str"");
  JarFile jar=loadJar(archive);
  final AtomicInteger jarEntryCount=new AtomicInteger(0);
  Enumeration<JarEntry> countEnum=jar.entries();
  while (countEnum.hasMoreElements()) {
    countEnum.nextElement();
    jarEntryCount.incrementAndGet();
  }
  final DecompilerSettings settings=getDefaultSettings(outputDir);
  settings.setTypeLoader(new CompositeTypeLoader(new JarTypeLoader(jar),settings.getTypeLoader()));
  final DecompilationResult res=new DecompilationResult();
  Filter.Result filterRes=Filter.Result.ACCEPT;
  final AtomicInteger current=new AtomicInteger(0);
  final Enumeration<JarEntry> entries=jar.entries();
  Collection<Callable<File>> tasks=new ArrayList<Callable<File>>();
  final Queue<MetadataSystem> metadataSystemCache=new LinkedList<>();
  refreshMetadataCache(metadataSystemCache,settings);
  while (entries.hasMoreElements()) {
    final JarEntry entry=entries.nextElement();
    if (filter != null)     filterRes=filter.decide(entry);
    if (filterRes == Filter.Result.REJECT) {
      jarEntryCount.decrementAndGet();
      continue;
    }
    if (filterRes == Filter.Result.STOP)     break;
    final String name=entry.getName();
    if (!name.endsWith(""String_Node_Str"")) {
      jarEntryCount.decrementAndGet();
      continue;
    }
    final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
    Callable<File> callable=new Callable<File>(){
      @Override public File call() throws Exception {
        MetadataSystem metadataSystem=null;
        try {
synchronized (metadataSystemCache) {
            if (current.incrementAndGet() % 50 == 0) {
              log.info(""String_Node_Str"" + current + ""String_Node_Str""+ jarEntryCount);
              refreshMetadataCache(metadataSystemCache,settings);
            }
            metadataSystem=metadataSystemCache.remove();
          }
          ExecutionStatistics.get().begin(""String_Node_Str"");
          final DecompileExecutor t=new DecompileExecutor(metadataSystem,typeName);
          t.start();
          t.join(60000L);
          if (!t.success) {
            if (t.e == null) {
              t.cancelDecompilation();
              throw new RuntimeException(""String_Node_Str"",t.e);
            }
 else {
              throw new RuntimeException(t.e);
            }
          }
          File outputFile=t.outputFile;
          if (outputFile != null) {
            listener.fileDecompiled(name,outputFile.getAbsolutePath());
            res.addDecompiled(name,outputFile.getAbsolutePath());
          }
          return outputFile;
        }
 catch (        Throwable th) {
          String msg=""String_Node_Str"" + archive.getPath() + ""String_Node_Str""+ name+ ""String_Node_Str""+ th.getMessage();
          DecompilationFailure ex=new DecompilationFailure(msg,name,th);
          log.log(Level.SEVERE,msg,ex);
          res.addFailure(ex);
        }
 finally {
          if (metadataSystem != null) {
synchronized (metadataSystemCache) {
              metadataSystemCache.add(metadataSystem);
            }
          }
          ExecutionStatistics.get().end(""String_Node_Str"");
        }
        return null;
      }
    }
;
    tasks.add(callable);
  }
  try {
    exService.invokeAll(tasks);
  }
 catch (  InterruptedException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 finally {
    listener.decompilationProcessComplete();
  }
  return res;
}","/** 
 * Decompiles .class files and nested archives in the given archive, as allowed by the given filter. <p> Nested archives will be decompiled into directories matching the name of the archive, e.g. <code>foo.ear/bar.jar/src/com/foo/bar/Baz.java</code>. <p> Required directories will be created as needed.
 * @param archive The archive containing source files and archives.
 * @param outputDir The directory where decompiled .java files will be placed.
 * @param filter Decides which classes will be decompiled.
 * @returns Result with all decompilation failures. Never throws.
 */
public DecompilationResult decompileArchive(final File archive,File outputDir,Filter<ZipEntry> filter,final DecompilationListener listener) throws DecompilationException {
  Checks.checkFileToBeRead(archive,""String_Node_Str"");
  Checks.checkDirectoryToBeFilled(outputDir,""String_Node_Str"");
  log.info(""String_Node_Str"" + archive.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath()+ ""String_Node_Str"");
  JarFile jar=loadJar(archive);
  try {
    final AtomicInteger jarEntryCount=new AtomicInteger(0);
    Enumeration<JarEntry> countEnum=jar.entries();
    while (countEnum.hasMoreElements()) {
      countEnum.nextElement();
      jarEntryCount.incrementAndGet();
    }
    final DecompilerSettings settings=getDefaultSettings(outputDir);
    settings.setTypeLoader(new CompositeTypeLoader(new WindupJarTypeLoader(jar),settings.getTypeLoader()));
    final DecompilationResult res=new DecompilationResult();
    Filter.Result filterRes=Filter.Result.ACCEPT;
    final AtomicInteger current=new AtomicInteger(0);
    final Enumeration<JarEntry> entries=jar.entries();
    Collection<Callable<File>> tasks=new ArrayList<Callable<File>>();
    final Queue<MetadataSystem> metadataSystemCache=new LinkedList<>();
    refreshMetadataCache(metadataSystemCache,settings);
    while (entries.hasMoreElements()) {
      final JarEntry entry=entries.nextElement();
      if (filter != null)       filterRes=filter.decide(entry);
      if (filterRes == Filter.Result.REJECT) {
        jarEntryCount.decrementAndGet();
        continue;
      }
      if (filterRes == Filter.Result.STOP)       break;
      final String name=entry.getName();
      if (!name.endsWith(""String_Node_Str"")) {
        jarEntryCount.decrementAndGet();
        continue;
      }
      final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
      Callable<File> callable=new Callable<File>(){
        @Override public File call() throws Exception {
          MetadataSystem metadataSystem=null;
          try {
synchronized (metadataSystemCache) {
              if (current.incrementAndGet() % 50 == 0) {
                log.info(""String_Node_Str"" + current + ""String_Node_Str""+ jarEntryCount);
                refreshMetadataCache(metadataSystemCache,settings);
              }
              metadataSystem=metadataSystemCache.remove();
            }
            ExecutionStatistics.get().begin(""String_Node_Str"");
            final DecompileExecutor t=new DecompileExecutor(metadataSystem,typeName);
            t.start();
            t.join(60000L);
            if (!t.success) {
              if (t.e == null) {
                t.cancelDecompilation();
                throw new RuntimeException(""String_Node_Str"",t.e);
              }
 else {
                throw new RuntimeException(t.e);
              }
            }
            File outputFile=t.outputFile;
            if (outputFile != null) {
              listener.fileDecompiled(name,outputFile.getAbsolutePath());
              res.addDecompiled(name,outputFile.getAbsolutePath());
            }
            return outputFile;
          }
 catch (          Throwable th) {
            String msg=""String_Node_Str"" + archive.getPath() + ""String_Node_Str""+ name+ ""String_Node_Str""+ th.getMessage();
            DecompilationFailure ex=new DecompilationFailure(msg,name,th);
            log.log(Level.SEVERE,msg,ex);
            res.addFailure(ex);
          }
 finally {
            if (metadataSystem != null) {
synchronized (metadataSystemCache) {
                metadataSystemCache.add(metadataSystem);
              }
            }
            ExecutionStatistics.get().end(""String_Node_Str"");
          }
          return null;
        }
      }
;
      tasks.add(callable);
    }
    try {
      exService.invokeAll(tasks);
    }
 catch (    InterruptedException e) {
      throw new IllegalStateException(""String_Node_Str"");
    }
 finally {
      listener.decompilationProcessComplete();
    }
    return res;
  }
  finally {
    try {
      jar.close();
    }
 catch (    IOException e) {
      log.warning(""String_Node_Str"" + jar.getName());
    }
  }
}",0.951353731014748
109539,"@Override public XSLTTransformation processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String description=$(element).attr(""String_Node_Str"");
  String extension=$(element).attr(""String_Node_Str"");
  String xsltFile=$(element).attr(""String_Node_Str"");
  Path pathContainingXml=handlerManager.getXmlInputPath();
  if (pathContainingXml != null) {
    String fullPath;
    if (xsltFile.startsWith(""String_Node_Str"") || xsltFile.startsWith(""String_Node_Str"")) {
      fullPath=xsltFile;
    }
 else {
      fullPath=pathContainingXml.resolve(xsltFile).toAbsolutePath().toString();
    }
    return XSLTTransformation.usingFilesystem(fullPath).withDescription(description).withExtension(extension);
  }
 else {
    ClassLoader xmlFileAddonClassLoader=handlerManager.getAddonContainingInputXML().getClassLoader();
    return XSLTTransformation.using(xsltFile,xmlFileAddonClassLoader).withDescription(description).withExtension(extension);
  }
}","@Override public XSLTTransformation processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String description=$(element).attr(""String_Node_Str"");
  String extension=$(element).attr(""String_Node_Str"");
  String template=$(element).attr(""String_Node_Str"");
  if (StringUtils.isBlank(description)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(template)) {
    throw new WindupException(""String_Node_Str"");
  }
  if (StringUtils.isBlank(extension)) {
    throw new WindupException(""String_Node_Str"");
  }
  Path pathContainingXml=handlerManager.getXmlInputPath();
  if (pathContainingXml != null) {
    String fullPath;
    if (template.startsWith(""String_Node_Str"") || template.startsWith(""String_Node_Str"")) {
      fullPath=template;
    }
 else {
      fullPath=pathContainingXml.resolve(template).toAbsolutePath().toString();
    }
    return XSLTTransformation.usingFilesystem(fullPath).withDescription(description).withExtension(extension);
  }
 else {
    ClassLoader xmlFileAddonClassLoader=handlerManager.getAddonContainingInputXML().getClassLoader();
    return XSLTTransformation.using(template,xmlFileAddonClassLoader).withDescription(description).withExtension(extension);
  }
}",0.8366711170449488
109540,"@Override public XmlFile processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String xpath=$(element).attr(""String_Node_Str"");
  String publicId=$(element).attr(""String_Node_Str"");
  Map<String,String> namespaceMappings=new HashMap<>();
  List<Element> children=$(element).children().get();
  for (  Element child : children) {
    NamespaceEntry namespaceEntry=handlerManager.processElement(child);
    namespaceMappings.put(namespaceEntry.getPrefix(),namespaceEntry.getNamespaceURI());
  }
  XmlFile xmlFile=XmlFile.matchesXpath(xpath);
  xmlFile.setPublicId(publicId);
  for (  Map.Entry<String,String> nsMapping : namespaceMappings.entrySet()) {
    xmlFile.namespace(nsMapping.getKey(),nsMapping.getValue());
  }
  return xmlFile;
}","@Override public XmlFile processElement(ParserContext handlerManager,Element element) throws ConfigurationException {
  String xpath=$(element).attr(""String_Node_Str"");
  if (StringUtils.isBlank(xpath)) {
    throw new WindupException(""String_Node_Str"");
  }
  String publicId=$(element).attr(""String_Node_Str"");
  Map<String,String> namespaceMappings=new HashMap<>();
  List<Element> children=$(element).children().get();
  for (  Element child : children) {
    NamespaceEntry namespaceEntry=handlerManager.processElement(child);
    namespaceMappings.put(namespaceEntry.getPrefix(),namespaceEntry.getNamespaceURI());
  }
  XmlFile xmlFile=XmlFile.matchesXpath(xpath);
  xmlFile.setPublicId(publicId);
  for (  Map.Entry<String,String> nsMapping : namespaceMappings.entrySet()) {
    xmlFile.namespace(nsMapping.getKey(),nsMapping.getValue());
  }
  return xmlFile;
}",0.9453883495145632
109541,"private Collection<URL> getScripts(FileModel userRulesFileModel){
  String userRulesPath=userRulesFileModel == null ? null : userRulesFileModel.getFilePath();
  List<URL> scripts=scanner.scan(GROOVY_RULES_EXTENSION);
  if (userRulesPath == null) {
    return scripts;
  }
  final List<URL> results=new ArrayList<>(scripts);
  try {
    Files.walkFileTree(Paths.get(userRulesPath),new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        if (file.getFileName().toString().endsWith(GROOVY_RULES_EXTENSION)) {
          results.add(file.toUri().toURL());
        }
        return FileVisitResult.CONTINUE;
      }
    }
);
  }
 catch (  IOException e) {
    throw new WindupException(""String_Node_Str"" + userRulesPath + ""String_Node_Str""+ e.getMessage(),e);
  }
  return results;
}","private Collection<URL> getScripts(FileModel userRulesFileModel){
  String userRulesDirectory=userRulesFileModel == null ? null : userRulesFileModel.getFilePath();
  List<URL> scripts=scanner.scan(GROOVY_RULES_EXTENSION);
  if (userRulesDirectory == null) {
    return scripts;
  }
  Path userRulesPath=Paths.get(userRulesDirectory);
  if (!Files.isDirectory(userRulesPath)) {
    LOG.warning(""String_Node_Str"" + userRulesPath.normalize().toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  if (!Files.isDirectory(userRulesPath)) {
    LOG.warning(""String_Node_Str"" + userRulesPath.normalize().toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  final List<URL> results=new ArrayList<>(scripts);
  try {
    Files.walkFileTree(userRulesPath,new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        if (file.getFileName().toString().endsWith(GROOVY_RULES_EXTENSION)) {
          results.add(file.toUri().toURL());
        }
        return FileVisitResult.CONTINUE;
      }
    }
);
  }
 catch (  IOException e) {
    throw new WindupException(""String_Node_Str"" + userRulesPath + ""String_Node_Str""+ e.getMessage(),e);
  }
  return results;
}",0.7861431870669746
109542,"private Collection<URL> getWindupUserDirectoryXmlFiles(FileModel userRulesFileModel){
  String userRulesPath=userRulesFileModel == null ? null : userRulesFileModel.getFilePath();
  if (userRulesPath == null) {
    return Collections.emptyList();
  }
  final List<URL> results=new ArrayList<>();
  try {
    Files.walkFileTree(Paths.get(userRulesPath),new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        if (file.getFileName().toString().toLowerCase().endsWith(""String_Node_Str"" + XML_RULES_EXTENSION)) {
          results.add(file.toUri().toURL());
        }
        return FileVisitResult.CONTINUE;
      }
    }
);
  }
 catch (  IOException e) {
    throw new WindupException(""String_Node_Str"" + userRulesPath + ""String_Node_Str""+ e.getMessage(),e);
  }
  return results;
}","private Collection<URL> getWindupUserDirectoryXmlFiles(FileModel userRulesFileModel){
  String userRulesDirectory=userRulesFileModel == null ? null : userRulesFileModel.getFilePath();
  if (userRulesDirectory == null) {
    return Collections.emptyList();
  }
  Path userRulesPath=Paths.get(userRulesDirectory);
  if (!Files.isDirectory(userRulesPath)) {
    LOG.warning(""String_Node_Str"" + userRulesPath.normalize().toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  if (!Files.isDirectory(userRulesPath)) {
    LOG.warning(""String_Node_Str"" + userRulesPath.normalize().toString() + ""String_Node_Str"");
    return Collections.emptyList();
  }
  final List<URL> results=new ArrayList<>();
  try {
    Files.walkFileTree(userRulesPath,new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        if (file.getFileName().toString().toLowerCase().endsWith(""String_Node_Str"" + XML_RULES_EXTENSION)) {
          results.add(file.toUri().toURL());
        }
        return FileVisitResult.CONTINUE;
      }
    }
);
  }
 catch (  IOException e) {
    throw new WindupException(""String_Node_Str"" + userRulesDirectory + ""String_Node_Str""+ e.getMessage(),e);
  }
  return results;
}",0.781048758049678
109543,"@Override public void execute(WindupConfiguration windupConfiguration){
  validateConfig(windupConfiguration);
  GraphContext context=windupConfiguration.getGraphContext();
  context.setOptions(windupConfiguration.getOptionMap());
  WindupConfigurationModel configModel=WindupConfigurationService.getConfigurationModel(context);
  configModel.setInputPath(getFileModel(context,windupConfiguration.getInputPath()));
  configModel.setOutputPath(getFileModel(context,windupConfiguration.getOutputDirectory()));
  configModel.setOfflineMode(windupConfiguration.isOffline());
  for (  Path path : windupConfiguration.getUserRulesDirectories()) {
    configModel.addUserRulesPath(getFileModel(context,path));
  }
  GraphRewrite event=new GraphRewrite(context);
  WindupRuleMetadata ruleMetadata=windupConfigurationLoader.loadConfiguration(context,windupConfiguration.getRuleProviderFilter());
  event.getRewriteContext().put(WindupRuleMetadata.class,ruleMetadata);
  Configuration rules=ruleMetadata.getConfiguration();
  RuleSubset ruleSubset=RuleSubset.create(rules);
  if (windupConfiguration.getProgressMonitor() != null)   ruleSubset.addLifecycleListener(new DefaultRuleLifecycleListener(windupConfiguration.getProgressMonitor(),rules));
  for (  RuleLifecycleListener listener : listeners) {
    ruleSubset.addLifecycleListener(listener);
  }
  ruleSubset.perform(event,createEvaluationContext());
}","@Override public void execute(WindupConfiguration windupConfiguration){
  validateConfig(windupConfiguration);
  GraphContext context=windupConfiguration.getGraphContext();
  context.setOptions(windupConfiguration.getOptionMap());
  WindupConfigurationModel configModel=WindupConfigurationService.getConfigurationModel(context);
  configModel.setInputPath(getFileModel(context,windupConfiguration.getInputPath()));
  configModel.setOutputPath(getFileModel(context,windupConfiguration.getOutputDirectory()));
  configModel.setOfflineMode(windupConfiguration.isOffline());
  for (  Path path : windupConfiguration.getAllUserRulesDirectories()) {
    configModel.addUserRulesPath(getFileModel(context,path));
  }
  GraphRewrite event=new GraphRewrite(context);
  WindupRuleMetadata ruleMetadata=windupConfigurationLoader.loadConfiguration(context,windupConfiguration.getRuleProviderFilter());
  event.getRewriteContext().put(WindupRuleMetadata.class,ruleMetadata);
  Configuration rules=ruleMetadata.getConfiguration();
  RuleSubset ruleSubset=RuleSubset.create(rules);
  if (windupConfiguration.getProgressMonitor() != null)   ruleSubset.addLifecycleListener(new DefaultRuleLifecycleListener(windupConfiguration.getProgressMonitor(),rules));
  for (  RuleLifecycleListener listener : listeners) {
    ruleSubset.addLifecycleListener(listener);
  }
  ruleSubset.perform(event,createEvaluationContext());
}",0.9989289539450196
109544,"@Test public void testRunWindupSourceMode() throws Exception {
  Path userPath=FileUtils.getTempDirectory().toPath().resolve(""String_Node_Str"").resolve(""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
  try {
    Files.createDirectories(userPath);
    try (InputStream is=getClass().getResourceAsStream(EXAMPLE_USERSCRIPT_INPUT);OutputStream os=new FileOutputStream(userPath.resolve(EXAMPLE_USERSCRIPT_OUTPUT).toFile())){
      IOUtils.copy(is,os);
    }
     try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"");OutputStream os=new FileOutputStream(userPath.resolve(XSLT_OUTPUT_NAME).toFile())){
      IOUtils.copy(is,os);
    }
     try (GraphContext context=createGraphContext()){
      List<String> includeList=Collections.emptyList();
      List<String> excludeList=Collections.emptyList();
      super.runTest(context,""String_Node_Str"",Collections.singletonList(userPath),true,includeList,excludeList);
      validateWebXmlReferences(context);
      validatePropertiesModels(context);
      validateReports(context);
    }
   }
  finally {
    FileUtils.deleteDirectory(userPath.toFile());
  }
}","@Test public void testRunWindupSourceMode() throws Exception {
  Path userPath=FileUtils.getTempDirectory().toPath().resolve(""String_Node_Str"").resolve(""String_Node_Str"" + RandomStringUtils.randomAlphanumeric(6));
  try {
    Files.createDirectories(userPath);
    try (InputStream is=getClass().getResourceAsStream(EXAMPLE_USERSCRIPT_INPUT);OutputStream os=new FileOutputStream(userPath.resolve(EXAMPLE_USERSCRIPT_OUTPUT).toFile())){
      IOUtils.copy(is,os);
    }
     try (InputStream is=getClass().getResourceAsStream(""String_Node_Str"");OutputStream os=new FileOutputStream(userPath.resolve(XSLT_OUTPUT_NAME).toFile())){
      IOUtils.copy(is,os);
    }
     try (GraphContext context=createGraphContext()){
      List<String> includeList=Collections.emptyList();
      List<String> excludeList=Collections.emptyList();
      super.runTest(context,""String_Node_Str"",userPath.toFile(),true,includeList,excludeList);
      validateWebXmlReferences(context);
      validatePropertiesModels(context);
      validateReports(context);
    }
   }
  finally {
    FileUtils.deleteDirectory(userPath.toFile());
  }
}",0.9848484848484848
109545,"void runTest(final GraphContext graphContext,final String inputPath,final List<Path> userRulesDirs,final boolean sourceMode,final List<String> includePackages,final List<String> excludePackages) throws Exception {
  WindupConfiguration wpc=new WindupConfiguration().setGraphContext(graphContext);
  wpc.setInputPath(Paths.get(inputPath));
  wpc.setOutputDirectory(graphContext.getGraphDirectory());
  if (userRulesDirs != null) {
    wpc.setUserRulesDirectories(userRulesDirs);
  }
  wpc.setOptionValue(SourceModeOption.NAME,sourceMode);
  wpc.setOptionValue(ScanPackagesOption.NAME,includePackages);
  wpc.setOptionValue(ExcludePackagesOption.NAME,excludePackages);
  RecordingWindupProgressMonitor progressMonitor=new RecordingWindupProgressMonitor();
  wpc.setProgressMonitor(progressMonitor);
  processor.execute(wpc);
  Assert.assertFalse(progressMonitor.isCancelled());
  Assert.assertTrue(progressMonitor.isDone());
  Assert.assertFalse(progressMonitor.getSubTaskNames().isEmpty());
  Assert.assertTrue(progressMonitor.getTotalWork() > 0);
  Assert.assertTrue(progressMonitor.getCompletedWork() > 0);
  Assert.assertEquals(progressMonitor.getTotalWork(),progressMonitor.getCompletedWork());
}","void runTest(final GraphContext graphContext,final String inputPath,final File userRulesDir,final boolean sourceMode,final List<String> includePackages,final List<String> excludePackages) throws Exception {
  WindupConfiguration wpc=new WindupConfiguration().setGraphContext(graphContext);
  wpc.setInputPath(Paths.get(inputPath));
  wpc.setOutputDirectory(graphContext.getGraphDirectory());
  if (userRulesDir != null) {
    wpc.setOptionValue(UserRulesDirectoryOption.NAME,userRulesDir);
  }
  wpc.setOptionValue(SourceModeOption.NAME,sourceMode);
  wpc.setOptionValue(ScanPackagesOption.NAME,includePackages);
  wpc.setOptionValue(ExcludePackagesOption.NAME,excludePackages);
  RecordingWindupProgressMonitor progressMonitor=new RecordingWindupProgressMonitor();
  wpc.setProgressMonitor(progressMonitor);
  processor.execute(wpc);
  Assert.assertFalse(progressMonitor.isCancelled());
  Assert.assertTrue(progressMonitor.isDone());
  Assert.assertFalse(progressMonitor.getSubTaskNames().isEmpty());
  Assert.assertTrue(progressMonitor.getTotalWork() > 0);
  Assert.assertTrue(progressMonitor.getCompletedWork() > 0);
  Assert.assertEquals(progressMonitor.getTotalWork(),progressMonitor.getCompletedWork());
}",0.9203319502074688
109546,"@Override public Result execute(UIExecutionContext context) throws Exception {
  WindupConfiguration windupConfiguration=new WindupConfiguration();
  for (  WindupOptionAndInput pair : this.inputOptions) {
    String key=pair.option.getName();
    Object value=getValueForInput(pair.input);
    windupConfiguration.setOptionValue(key,value);
  }
  Path userRulesDir=WindupPathUtil.getWindupUserRulesDir();
  windupConfiguration.addUserRulesDirectory(userRulesDir);
  Path windupHomeRulesDir=WindupPathUtil.getWindupHomeRules();
  windupConfiguration.addUserRulesDirectory(windupHomeRulesDir);
  boolean overwrite=this.overwrite.getValue();
  if (!overwrite && pathNotEmpty(windupConfiguration.getOutputDirectory().toFile())) {
    String promptMsg=""String_Node_Str"" + windupConfiguration.getOutputDirectory().toString() + ""String_Node_Str"";
    if (!context.getPrompt().promptBoolean(promptMsg)) {
      return Results.fail(""String_Node_Str"");
    }
  }
  FileUtils.deleteQuietly(windupConfiguration.getOutputDirectory().toFile());
  Path graphPath=windupConfiguration.getOutputDirectory().resolve(""String_Node_Str"");
  try (GraphContext graphContext=graphContextFactory.create(graphPath)){
    UIProgressMonitor uiProgressMonitor=context.getProgressMonitor();
    WindupProgressMonitor progressMonitor=new WindupProgressMonitorAdapter(uiProgressMonitor);
    windupConfiguration.setProgressMonitor(progressMonitor).setGraphContext(graphContext);
    processor.execute(windupConfiguration);
    uiProgressMonitor.done();
    return Results.success(""String_Node_Str"" + windupConfiguration.getOutputDirectory().toAbsolutePath() + ""String_Node_Str"");
  }
 }","@Override public Result execute(UIExecutionContext context) throws Exception {
  WindupConfiguration windupConfiguration=new WindupConfiguration();
  for (  WindupOptionAndInput pair : this.inputOptions) {
    String key=pair.option.getName();
    Object value=getValueForInput(pair.input);
    windupConfiguration.setOptionValue(key,value);
  }
  Path userRulesDir=WindupPathUtil.getWindupUserRulesDir();
  if (!Files.isDirectory(userRulesDir)) {
    Files.createDirectories(userRulesDir);
  }
  windupConfiguration.addDefaultUserRulesDirectory(userRulesDir);
  Path windupHomeRulesDir=WindupPathUtil.getWindupHomeRules();
  if (!Files.isDirectory(windupHomeRulesDir)) {
    Files.createDirectories(windupHomeRulesDir);
  }
  windupConfiguration.addDefaultUserRulesDirectory(windupHomeRulesDir);
  boolean overwrite=this.overwrite.getValue();
  if (!overwrite && pathNotEmpty(windupConfiguration.getOutputDirectory().toFile())) {
    String promptMsg=""String_Node_Str"" + windupConfiguration.getOutputDirectory().toString() + ""String_Node_Str"";
    if (!context.getPrompt().promptBoolean(promptMsg)) {
      return Results.fail(""String_Node_Str"");
    }
  }
  context.getUIContext().getAttributeMap().put(WindupConfiguration.class,windupConfiguration);
  FileUtils.deleteQuietly(windupConfiguration.getOutputDirectory().toFile());
  Path graphPath=windupConfiguration.getOutputDirectory().resolve(""String_Node_Str"");
  try (GraphContext graphContext=graphContextFactory.create(graphPath)){
    UIProgressMonitor uiProgressMonitor=context.getProgressMonitor();
    WindupProgressMonitor progressMonitor=new WindupProgressMonitorAdapter(uiProgressMonitor);
    windupConfiguration.setProgressMonitor(progressMonitor).setGraphContext(graphContext);
    processor.execute(windupConfiguration);
    uiProgressMonitor.done();
    return Results.success(""String_Node_Str"" + windupConfiguration.getOutputDirectory().toAbsolutePath() + ""String_Node_Str"");
  }
 }",0.891599667313557
109547,"/** 
 * Called internally to actually process the Iteration. Loops over the frames to iterate, and performs their .perform( ... ) or .otherwise( ... ) parts.
 */
public void perform(GraphRewrite event,EvaluationContext context){
  Variables variables=Variables.instance(event);
  Iterable<WindupVertexFrame> frames=getSelectionManager().getFrames(event,context);
  for (  WindupVertexFrame frame : frames) {
    variables.push();
    getPayloadManager().setCurrentPayload(variables,frame);
    boolean conditionResult=true;
    if (condition != null) {
      if (condition instanceof GraphCondition) {
        ((GraphCondition)condition).setInputVariablesName(getPayloadVariableName(event,context));
      }
      conditionResult=condition.evaluate(event,context);
      variables.push();
      getPayloadManager().setCurrentPayload(variables,frame);
    }
    if (conditionResult) {
      if (operationPerform != null) {
        operationPerform.perform(event,context);
      }
    }
 else     if (condition != null) {
      if (operationOtherwise != null) {
        operationOtherwise.perform(event,context);
      }
    }
    getPayloadManager().removeCurrentPayload(variables);
    variables.pop();
    if (condition != null) {
      variables.pop();
    }
  }
}","/** 
 * Called internally to actually process the Iteration. Loops over the frames to iterate, and performs their .perform( ... ) or .otherwise( ... ) parts.
 */
public void perform(GraphRewrite event,EvaluationContext context){
  Variables variables=Variables.instance(event);
  Iterable<WindupVertexFrame> frames=getSelectionManager().getFrames(event,context);
  event.getRewriteContext().put(DEFAULT_VARIABLE_LIST_STRING,frames);
  for (  WindupVertexFrame frame : frames) {
    variables.push();
    getPayloadManager().setCurrentPayload(variables,frame);
    boolean conditionResult=true;
    if (condition != null) {
      if (condition instanceof GraphCondition) {
        ((GraphCondition)condition).setInputVariablesName(getPayloadVariableName(event,context));
      }
      conditionResult=condition.evaluate(event,context);
      variables.push();
      getPayloadManager().setCurrentPayload(variables,frame);
    }
    if (conditionResult) {
      if (operationPerform != null) {
        operationPerform.perform(event,context);
      }
    }
 else     if (condition != null) {
      if (operationOtherwise != null) {
        operationOtherwise.perform(event,context);
      }
    }
    getPayloadManager().removeCurrentPayload(variables);
    variables.pop();
    if (condition != null) {
      variables.pop();
    }
  }
}",0.973097617217525
109548,"/** 
 * Decompiles .class files and nested archives in the given archive, as allowed by the given filter. <p> Nested archives will be decompiled into directories matching the name of the archive, e.g. <code>foo.ear/bar.jar/src/com/foo/bar/Baz.java</code>. <p> Required directories will be created as needed.
 * @param archive The archive containing source files and archives.
 * @param outputDir The directory where decompiled .java files will be placed.
 * @param filter Decides which classes will be decompiled.
 * @returns Result with all decompilation failures. Never throws.
 */
public DecompilationResult decompileArchive(File archive,File outputDir,Filter<ZipEntry> filter) throws DecompilationException {
  Checks.checkFileToBeRead(archive,""String_Node_Str"");
  Checks.checkDirectoryToBeFilled(outputDir,""String_Node_Str"");
  log.info(""String_Node_Str"" + archive.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath()+ ""String_Node_Str"");
  JarFile jar=loadJar(archive);
  DecompilerSettings settings=getDefaultSettings(outputDir);
  settings.setTypeLoader(new CompositeTypeLoader(new JarTypeLoader(jar),settings.getTypeLoader()));
  MetadataSystem metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
  int classesDecompiled=0;
  DecompilationResult res=new DecompilationResult();
  Filter.Result filterRes=Filter.Result.ACCEPT;
  final Enumeration<JarEntry> entries=jar.entries();
  while (entries.hasMoreElements()) {
    final JarEntry entry=entries.nextElement();
    if (filter != null)     filterRes=filter.decide(entry);
    if (filterRes == Filter.Result.REJECT)     continue;
    if (filterRes == Filter.Result.STOP)     break;
    final String name=entry.getName();
    if (!name.endsWith(""String_Node_Str""))     continue;
    final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
    try {
      File outputFile=this.decompileType(metadataSystem,typeName);
      if (outputFile != null)       res.addDecompiled(name,outputFile.getAbsolutePath());
      if (++classesDecompiled % 100 == 0)       metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
    }
 catch (    Throwable th) {
      String msg=""String_Node_Str"" + archive.getPath() + ""String_Node_Str""+ name+ ""String_Node_Str""+ th.getMessage();
      DecompilationFailure ex=new DecompilationFailure(msg,name,th);
      log.log(Level.SEVERE,msg,ex);
      res.addFailure(ex);
    }
  }
  return res;
}","/** 
 * Decompiles .class files and nested archives in the given archive, as allowed by the given filter. <p> Nested archives will be decompiled into directories matching the name of the archive, e.g. <code>foo.ear/bar.jar/src/com/foo/bar/Baz.java</code>. <p> Required directories will be created as needed.
 * @param archive The archive containing source files and archives.
 * @param outputDir The directory where decompiled .java files will be placed.
 * @param filter Decides which classes will be decompiled.
 * @returns Result with all decompilation failures. Never throws.
 */
public DecompilationResult decompileArchive(File archive,File outputDir,Filter<ZipEntry> filter) throws DecompilationException {
  Checks.checkFileToBeRead(archive,""String_Node_Str"");
  Checks.checkDirectoryToBeFilled(outputDir,""String_Node_Str"");
  log.info(""String_Node_Str"" + archive.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath()+ ""String_Node_Str"");
  JarFile jar=loadJar(archive);
  int jarEntryCount=0;
  Enumeration<JarEntry> countEnum=jar.entries();
  while (countEnum.hasMoreElements()) {
    countEnum.nextElement();
    jarEntryCount++;
  }
  DecompilerSettings settings=getDefaultSettings(outputDir);
  settings.setTypeLoader(new CompositeTypeLoader(new JarTypeLoader(jar),settings.getTypeLoader()));
  MetadataSystem metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
  int classesDecompiled=0;
  DecompilationResult res=new DecompilationResult();
  Filter.Result filterRes=Filter.Result.ACCEPT;
  int current=0;
  final Enumeration<JarEntry> entries=jar.entries();
  while (entries.hasMoreElements()) {
    final JarEntry entry=entries.nextElement();
    current++;
    if (current % 100 == 0) {
      log.info(""String_Node_Str"" + current + ""String_Node_Str""+ jarEntryCount);
    }
    if (filter != null)     filterRes=filter.decide(entry);
    if (filterRes == Filter.Result.REJECT)     continue;
    if (filterRes == Filter.Result.STOP)     break;
    final String name=entry.getName();
    if (!name.endsWith(""String_Node_Str""))     continue;
    final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
    try {
      DecompileExecutor t=new DecompileExecutor(metadataSystem,typeName);
      t.start();
      t.join(60000L);
      if (!t.success) {
        t.cancelDecompilation();
        throw new RuntimeException(""String_Node_Str"",t.e);
      }
      File outputFile=t.outputFile;
      if (outputFile != null)       res.addDecompiled(name,outputFile.getAbsolutePath());
      if (++classesDecompiled % 100 == 0)       metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
    }
 catch (    Throwable th) {
      String msg=""String_Node_Str"" + archive.getPath() + ""String_Node_Str""+ name+ ""String_Node_Str""+ th.getMessage();
      DecompilationFailure ex=new DecompilationFailure(msg,name,th);
      log.log(Level.SEVERE,msg,ex);
      res.addFailure(ex);
    }
  }
  return res;
}",0.8878574080950613
109549,"@Override public Configuration getConfiguration(GraphContext context){
  QueryGremlinCriterion shouldDecompileCriterion=new ShouldDecompileCriterion();
  return ConfigurationBuilder.begin().addRule().when(Query.find(ArchiveModel.class).piped(shouldDecompileCriterion)).perform(new ProcyonDecompilerOperation()).otherwise(Log.message(Level.WARN,""String_Node_Str""));
}","@Override public Configuration getConfiguration(GraphContext context){
  QueryGremlinCriterion shouldDecompileCriterion=new ShouldDecompileCriterion();
  return ConfigurationBuilder.begin().addRule().when(Query.find(ArchiveModel.class).piped(shouldDecompileCriterion)).perform(new ProcyonDecompilerOperation().and(IterationProgress.monitoring(""String_Node_Str"",1))).otherwise(Log.message(Level.WARN,""String_Node_Str""));
}",0.9301143583227446
109550,"@Override public Configuration getConfiguration(GraphContext context){
  ConditionBuilder javaSourceAvailable=Query.find(JavaSourceFileModel.class);
  return ConfigurationBuilder.begin().addRule().when(javaSourceAvailable).perform(new ParseSourceOperation());
}","@Override public Configuration getConfiguration(GraphContext context){
  ConditionBuilder javaSourceAvailable=Query.find(JavaSourceFileModel.class);
  return ConfigurationBuilder.begin().addRule().when(javaSourceAvailable).perform(new ParseSourceOperation().and(IterationProgress.monitoring(""String_Node_Str"",250)));
}",0.9015544041450776
109551,"@Override public Configuration getConfiguration(GraphContext arg0){
  return ConfigurationBuilder.begin().addRule().when(Query.find(ArchiveModel.class)).perform(Iteration.over(ArchiveModel.class).when(new AbstractIterationFilter<ArchiveModel>(){
    @Override public boolean evaluate(    GraphRewrite event,    EvaluationContext context,    ArchiveModel payload){
      return payload.getProjectModel() == null;
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
).perform(new AbstractIterationOperation<ArchiveModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    ArchiveModel payload){
      List<ArchiveModel> hierarchy=new ArrayList<>();
      ArchiveModel parentArchive=payload;
      while (parentArchive != null) {
        hierarchy.add(parentArchive);
        if (parentArchive.getProjectModel() != null) {
          break;
        }
        parentArchive=parentArchive.getParentArchive();
      }
      ProjectModel childProjectModel=null;
      ProjectModelService projectModelService=new ProjectModelService(event.getGraphContext());
      for (      ArchiveModel archiveModel : hierarchy) {
        ProjectModel projectModel=archiveModel.getProjectModel();
        if (projectModel == null) {
          projectModel=projectModelService.create();
          projectModel.setName(archiveModel.getArchiveName());
          projectModel.setRootFileModel(archiveModel);
          projectModel.setDescription(""String_Node_Str"");
          if (ZipUtil.endsWithZipExtension(archiveModel.getArchiveName())) {
            for (            String extension : ZipUtil.getZipExtensions()) {
              if (archiveModel.getArchiveName().endsWith(extension))               projectModel.setProjectType(extension);
            }
          }
          archiveModel.setProjectModel(projectModel);
          for (          FileModel f : archiveModel.getContainedFileModels()) {
            if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
              f.setProjectModel(projectModel);
              projectModel.addFileModel(f);
            }
          }
        }
        if (childProjectModel != null) {
          childProjectModel.setParentProject(projectModel);
        }
        childProjectModel=projectModel;
      }
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
).endIteration());
}","@Override public Configuration getConfiguration(GraphContext arg0){
  return ConfigurationBuilder.begin().addRule().when(Query.find(ArchiveModel.class)).perform(Iteration.over(ArchiveModel.class).when(new AbstractIterationFilter<ArchiveModel>(){
    @Override public boolean evaluate(    GraphRewrite event,    EvaluationContext context,    ArchiveModel payload){
      return payload.getProjectModel() == null;
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
).perform(new AbstractIterationOperation<ArchiveModel>(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context,    ArchiveModel payload){
      List<ArchiveModel> hierarchy=new ArrayList<>();
      ArchiveModel parentArchive=payload;
      while (parentArchive != null) {
        hierarchy.add(parentArchive);
        if (parentArchive.getProjectModel() != null) {
          break;
        }
        parentArchive=parentArchive.getParentArchive();
      }
      ProjectModel childProjectModel=null;
      ProjectModelService projectModelService=new ProjectModelService(event.getGraphContext());
      for (      ArchiveModel archiveModel : hierarchy) {
        ProjectModel projectModel=archiveModel.getProjectModel();
        if (projectModel == null) {
          projectModel=projectModelService.create();
          projectModel.setName(archiveModel.getArchiveName());
          projectModel.setRootFileModel(archiveModel);
          projectModel.setDescription(""String_Node_Str"");
          if (ZipUtil.endsWithZipExtension(archiveModel.getArchiveName())) {
            for (            String extension : ZipUtil.getZipExtensions()) {
              if (archiveModel.getArchiveName().endsWith(extension))               projectModel.setProjectType(extension);
            }
          }
          archiveModel.setProjectModel(projectModel);
          for (          FileModel f : archiveModel.getContainedFileModels()) {
            if (!(f instanceof ArchiveModel) && f.getProjectModel() == null) {
              f.setProjectModel(projectModel);
              projectModel.addFileModel(f);
            }
          }
        }
        if (childProjectModel != null) {
          childProjectModel.setParentProject(projectModel);
        }
        childProjectModel=projectModel;
      }
    }
    public String toString(){
      return ""String_Node_Str"";
    }
  }
.and(IterationProgress.monitoring(""String_Node_Str"",1))).endIteration());
}",0.9867157163294502
109552,"@Override public ConditionBuilder when(){
  return Query.find(FileModel.class).withProperty(FileModel.FILE_NAME,QueryPropertyComparisonType.REGEX,""String_Node_Str"");
}","@Override public ConditionBuilder when(){
  return Query.find(FileModel.class).withProperty(FileModel.FILE_NAME,QueryPropertyComparisonType.REGEX,""String_Node_Str"").withProperty(FileModel.IS_DIRECTORY,false);
}",0.8859416445623343
109553,"@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attrs) throws IOException {
  String relativePath=StringUtils.substringAfter(file.toString(),path.toString());
  relativePath=StringUtils.removeStart(relativePath,File.separator);
  Path resultFile=resultPath.resolve(relativePath);
  FileUtils.forceMkdir(resultFile.getParent().toFile());
  Files.copy(file,resultFile,StandardCopyOption.REPLACE_EXISTING);
  return FileVisitResult.CONTINUE;
}","@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attrs) throws IOException {
  String relativePath=StringUtils.substringAfter(file.toString(),path.toString());
  relativePath=FilenameUtils.separatorsToSystem(relativePath);
  relativePath=StringUtils.removeStart(relativePath,File.separator);
  Path resultFile=resultPath.resolve(relativePath);
  FileUtils.forceMkdir(resultFile.getParent().toFile());
  Files.copy(file,resultFile,StandardCopyOption.REPLACE_EXISTING);
  return FileVisitResult.CONTINUE;
}",0.9365558912386708
109554,"private void recursePath(final Path path,final Path resultPath) throws IOException {
  Files.walkFileTree(path,new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      String relativePath=StringUtils.substringAfter(file.toString(),path.toString());
      relativePath=StringUtils.removeStart(relativePath,File.separator);
      Path resultFile=resultPath.resolve(relativePath);
      FileUtils.forceMkdir(resultFile.getParent().toFile());
      Files.copy(file,resultFile,StandardCopyOption.REPLACE_EXISTING);
      return FileVisitResult.CONTINUE;
    }
  }
);
}","private void recursePath(final Path path,final Path resultPath) throws IOException {
  Files.walkFileTree(path,new SimpleFileVisitor<Path>(){
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      String relativePath=StringUtils.substringAfter(file.toString(),path.toString());
      relativePath=FilenameUtils.separatorsToSystem(relativePath);
      relativePath=StringUtils.removeStart(relativePath,File.separator);
      Path resultFile=resultPath.resolve(relativePath);
      FileUtils.forceMkdir(resultFile.getParent().toFile());
      Files.copy(file,resultFile,StandardCopyOption.REPLACE_EXISTING);
      return FileVisitResult.CONTINUE;
    }
  }
);
}",0.9514140681653372
109555,"@Override public void perform(Rewrite rewrite,EvaluationContext context){
  if (!(rewrite instanceof GraphRewrite))   throw new IllegalArgumentException(""String_Node_Str"");
  GraphRewrite event=(GraphRewrite)rewrite;
  for (  RuleLifecycleListener listener : listeners) {
    listener.beforeExecution();
  }
  final EvaluationContextImpl subContext=new EvaluationContextImpl();
  for (int i=0; i < rules.size(); i++) {
    Rule rule=rules.get(i);
    Context ruleContext=rule instanceof Context ? (Context)rule : null;
    long ruleTimeStarted=System.currentTimeMillis();
    try {
      subContext.clear();
      subContext.put(ParameterStore.class,context.get(ParameterStore.class));
      ParameterValueStore values=(ParameterValueStore)context.get(ParameterValueStore.class);
      subContext.put(ParameterValueStore.class,values);
      subContext.setState(RewriteState.EVALUATING);
      subContext.put(Rule.class,rule);
      event.selectionPush();
      try {
        for (        RuleLifecycleListener listener : listeners) {
          listener.beforeRuleEvaluation(rule,subContext);
        }
        if (rule.evaluate(event,subContext)) {
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleConditionEvaluation(event,subContext,rule,true);
          }
          if (!handleBindings(event,subContext,values))           continue;
          subContext.setState(RewriteState.PERFORMING);
          final Object ruleProviderDesc=((RuleBuilder)rule).get(RuleMetadata.RULE_PROVIDER);
          log.info(""String_Node_Str"" + ruleProviderDesc + ""String_Node_Str"");
          for (          RuleLifecycleListener listener : listeners) {
            listener.beforeRuleOperationsPerformed(event,subContext,rule);
          }
          List<Operation> preOperations=subContext.getPreOperations();
          for (          Operation preOperation : preOperations) {
            preOperation.perform(event,subContext);
          }
          if (event.getFlow().isHandled())           break;
          rule.perform(event,subContext);
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleOperationsPerformed(event,subContext,rule);
          }
          if (event.getFlow().isHandled())           break;
          List<Operation> postOperations=subContext.getPostOperations();
          for (          Operation postOperation : postOperations) {
            postOperation.perform(event,subContext);
          }
          if (event.getFlow().isHandled())           break;
        }
 else {
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleConditionEvaluation(event,subContext,rule,false);
          }
        }
      }
  finally {
        boolean autocommit=true;
        if (ruleContext != null && ruleContext.containsKey(RuleMetadata.AUTO_COMMIT)) {
          autocommit=(Boolean)ruleContext.get(RuleMetadata.AUTO_COMMIT);
        }
        if (autocommit) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        event.selectionPop();
        long ruleTimeCompleted=System.currentTimeMillis();
        if (ruleContext != null) {
          int timeTaken=(int)(ruleTimeCompleted - ruleTimeStarted);
          logTimeTakenByRuleProvider(event.getGraphContext(),ruleContext,i,timeTaken);
        }
      }
    }
 catch (    RuntimeException ex) {
      String exMsg=""String_Node_Str"" + rule;
      String logMsg=exMsg + ""String_Node_Str"" + ex.getMessage();
      log.severe(logMsg);
      if (ruleContext != null) {
        Object origin=ruleContext.get(RuleMetadata.ORIGIN);
        if (origin != null)         exMsg+=""String_Node_Str"" + origin;
        Object location=ruleContext.get(org.ocpsoft.rewrite.config.RuleMetadata.PROVIDER_LOCATION);
        if (location != null)         exMsg+=""String_Node_Str"" + location;
      }
      throw new WindupException(exMsg,ex);
    }
  }
  for (  RuleLifecycleListener listener : listeners) {
    listener.afterExecution();
  }
}","@Override public void perform(Rewrite rewrite,EvaluationContext context){
  if (!(rewrite instanceof GraphRewrite))   throw new IllegalArgumentException(""String_Node_Str"");
  GraphRewrite event=(GraphRewrite)rewrite;
  List<Rule> rules=config.getRules();
  for (  RuleLifecycleListener listener : listeners) {
    listener.beforeExecution();
  }
  final EvaluationContextImpl subContext=new EvaluationContextImpl();
  for (int i=0; i < rules.size(); i++) {
    Rule rule=rules.get(i);
    Context ruleContext=rule instanceof Context ? (Context)rule : null;
    long ruleTimeStarted=System.currentTimeMillis();
    try {
      subContext.clear();
      subContext.put(ParameterStore.class,context.get(ParameterStore.class));
      ParameterValueStore values=(ParameterValueStore)context.get(ParameterValueStore.class);
      subContext.put(ParameterValueStore.class,values);
      subContext.setState(RewriteState.EVALUATING);
      subContext.put(Rule.class,rule);
      event.selectionPush();
      try {
        for (        RuleLifecycleListener listener : listeners) {
          listener.beforeRuleEvaluation(rule,subContext);
        }
        if (rule.evaluate(event,subContext)) {
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleConditionEvaluation(event,subContext,rule,true);
          }
          if (!handleBindings(event,subContext,values))           continue;
          subContext.setState(RewriteState.PERFORMING);
          final Object ruleProviderDesc=((RuleBuilder)rule).get(RuleMetadata.RULE_PROVIDER);
          log.info(""String_Node_Str"" + ruleProviderDesc + ""String_Node_Str"");
          for (          RuleLifecycleListener listener : listeners) {
            listener.beforeRuleOperationsPerformed(event,subContext,rule);
          }
          List<Operation> preOperations=subContext.getPreOperations();
          for (          Operation preOperation : preOperations) {
            preOperation.perform(event,subContext);
          }
          if (event.getFlow().isHandled())           break;
          rule.perform(event,subContext);
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleOperationsPerformed(event,subContext,rule);
          }
          if (event.getFlow().isHandled())           break;
          List<Operation> postOperations=subContext.getPostOperations();
          for (          Operation postOperation : postOperations) {
            postOperation.perform(event,subContext);
          }
          if (event.getFlow().isHandled())           break;
        }
 else {
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleConditionEvaluation(event,subContext,rule,false);
          }
        }
      }
  finally {
        boolean autocommit=true;
        if (ruleContext != null && ruleContext.containsKey(RuleMetadata.AUTO_COMMIT)) {
          autocommit=(Boolean)ruleContext.get(RuleMetadata.AUTO_COMMIT);
        }
        if (autocommit) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        event.selectionPop();
        long ruleTimeCompleted=System.currentTimeMillis();
        if (ruleContext != null) {
          int timeTaken=(int)(ruleTimeCompleted - ruleTimeStarted);
          logTimeTakenByRuleProvider(event.getGraphContext(),ruleContext,i,timeTaken);
        }
      }
    }
 catch (    RuntimeException ex) {
      String exMsg=""String_Node_Str"" + rule;
      String logMsg=exMsg + ""String_Node_Str"" + ex.getMessage();
      log.severe(logMsg);
      if (ruleContext != null) {
        Object origin=ruleContext.get(RuleMetadata.ORIGIN);
        if (origin != null)         exMsg+=""String_Node_Str"" + origin;
        Object location=ruleContext.get(org.ocpsoft.rewrite.config.RuleMetadata.PROVIDER_LOCATION);
        if (location != null)         exMsg+=""String_Node_Str"" + location;
      }
      throw new WindupException(exMsg,ex);
    }
  }
  for (  RuleLifecycleListener listener : listeners) {
    listener.afterExecution();
  }
}",0.9953271028037384
109556,"/** 
 * Default settings set type loader to ClasspathTypeLoader if not set before.
 */
private DecompilerSettings getDefaultSettings(File outputDir){
  DecompilerSettings settings=this.procyonConf.getDecompilerSettings();
  if (settings == null) {
    settings=new DecompilerSettings();
    configuration.setDecompilerSettings(settings);
  }
  settings.setOutputDirectory(outputDir.getPath());
  settings.setShowSyntheticMembers(false);
  settings.setForceExplicitImports(true);
  if (settings.getTypeLoader() == null)   settings.setTypeLoader(new ClasspathTypeLoader());
  return settings;
}","/** 
 * Default settings set type loader to ClasspathTypeLoader if not set before.
 */
private DecompilerSettings getDefaultSettings(File outputDir){
  DecompilerSettings settings=this.procyonConf.getDecompilerSettings();
  if (settings == null) {
    settings=new DecompilerSettings();
    procyonConf.setDecompilerSettings(settings);
  }
  settings.setOutputDirectory(outputDir.getPath());
  settings.setShowSyntheticMembers(false);
  settings.setForceExplicitImports(true);
  if (settings.getTypeLoader() == null)   settings.setTypeLoader(new ClasspathTypeLoader());
  return settings;
}",0.9796954314720812
109557,"/** 
 * Specify the name of the variables to base this query on.
 * @param fromVariables
 * @return
 */
public static XmlFileBeing from(String fromVariables){
  return new XmlFileBeing(fromVariables);
}","/** 
 * Specify the name of the variables to base this query on.
 * @param fromVariable
 * @return
 */
public static XmlFileFrom from(String fromVariable){
  return new XmlFileFrom(fromVariable);
}",0.9473684210526316
109558,"@Override public boolean evaluate(final GraphRewrite event,final EvaluationContext context){
  List<WindupVertexFrame> resultLocations=new ArrayList<WindupVertexFrame>();
  GraphContext graphContext=event.getGraphContext();
  GraphService<XmlFileModel> xmlResourceService=new GraphService<XmlFileModel>(graphContext,XmlFileModel.class);
  Iterable<? extends WindupVertexFrame> allXmls;
  if (fromVariables == null || fromVariables.equals(""String_Node_Str"")) {
    allXmls=xmlResourceService.findAll();
  }
 else {
    allXmls=Variables.instance(event).findVariable(fromVariables);
  }
  for (  WindupVertexFrame iterated : allXmls) {
    XmlFileModel xml=null;
    if (iterated instanceof FileReferenceModel) {
      xml=(XmlFileModel)((FileReferenceModel)iterated).getFile();
    }
 else     if (iterated instanceof XmlFileModel) {
      xml=(XmlFileModel)iterated;
    }
 else {
      throw new WindupException(""String_Node_Str"" + iterated.toPrettyString() + ""String_Node_Str"");
    }
    if (fileName != null && !fileName.equals(""String_Node_Str"")) {
      if (!xml.getFileName().equals(fileName)) {
        continue;
      }
    }
    if (publicId != null && !publicId.equals(""String_Node_Str"")) {
      if (xml.getDoctype() == null || xml.getDoctype().getPublicId() == null || !xml.getDoctype().getPublicId().matches(publicId)) {
        continue;
      }
    }
    if (xpath != null) {
      try {
        Document document=xml.asDocument();
        NodeList result=XmlUtil.xpathNodeList(document,xpath,namespaces);
        List<String> lines=Files.readAllLines(Paths.get(xml.getFilePath()),Charset.defaultCharset());
        if (result != null && (result.getLength() != 0)) {
          for (int i=0; i < result.getLength(); i++) {
            Node node=result.item(i);
            if (xpathResultMatch != null) {
              if (!node.toString().matches(xpathResultMatch)) {
                continue;
              }
            }
            int lineNumber=(int)node.getUserData(LocationAwareContentHandler.LINE_NUMBER_KEY_NAME);
            int columnNumber=(int)node.getUserData(LocationAwareContentHandler.COLUMN_NUMBER_KEY_NAME);
            int lineLength=lines.get(lineNumber - 1).length();
            graphContext=event.getGraphContext();
            GraphService<XmlTypeReferenceModel> fileLocationService=new GraphService<XmlTypeReferenceModel>(graphContext,XmlTypeReferenceModel.class);
            XmlTypeReferenceModel fileLocation=fileLocationService.create();
            fileLocation.setLineNumber(lineNumber);
            fileLocation.setColumnNumber(columnNumber);
            fileLocation.setLength(lineLength);
            fileLocation.setFile(xml);
            fileLocation.setXpath(xpath);
            GraphService<NamespaceMetaModel> metaModelService=new GraphService<NamespaceMetaModel>(graphContext,NamespaceMetaModel.class);
            for (            Map.Entry<String,String> namespace : namespaces.entrySet()) {
              NamespaceMetaModel metaModel=metaModelService.create();
              metaModel.setSchemaLocation(namespace.getKey());
              metaModel.setSchemaLocation(namespace.getValue());
              metaModel.addXmlResource(xml);
              fileLocation.addNamespace(metaModel);
            }
            resultLocations.add(fileLocation);
          }
        }
      }
 catch (      MarshallingException e) {
        GraphService<ClassificationModel> classificationService=new GraphService<>(event.getGraphContext(),ClassificationModel.class);
        ClassificationModel classification=classificationService.getUniqueByProperty(ClassificationModel.PROPERTY_CLASSIFICATION,XmlFile.UNPARSEABLE_XML_CLASSIFICATION);
        if (classification == null) {
          classification=classificationService.create();
          classification.setDescription(XmlFile.UNPARSEABLE_XML_DESCRIPTION);
          classification.setClassifiation(XmlFile.UNPARSEABLE_XML_CLASSIFICATION);
          classification.setRuleID(((Rule)context.get(Rule.class)).getId());
        }
        classification.addFileModel(xml);
      }
catch (      IOException e) {
        throw new WindupException(""String_Node_Str"",e);
      }
    }
  }
  Variables.instance(event).setVariable(variable,resultLocations);
  return !resultLocations.isEmpty();
}","@Override public boolean evaluate(final GraphRewrite event,final EvaluationContext context){
  List<WindupVertexFrame> resultLocations=new ArrayList<WindupVertexFrame>();
  GraphContext graphContext=event.getGraphContext();
  GraphService<XmlFileModel> xmlResourceService=new GraphService<XmlFileModel>(graphContext,XmlFileModel.class);
  Iterable<? extends WindupVertexFrame> allXmls;
  if (fromVariable == null || fromVariable.equals(""String_Node_Str"")) {
    allXmls=xmlResourceService.findAll();
  }
 else {
    allXmls=Variables.instance(event).findVariable(fromVariable);
  }
  for (  WindupVertexFrame iterated : allXmls) {
    XmlFileModel xml=null;
    if (iterated instanceof FileReferenceModel) {
      xml=(XmlFileModel)((FileReferenceModel)iterated).getFile();
    }
 else     if (iterated instanceof XmlFileModel) {
      xml=(XmlFileModel)iterated;
    }
 else {
      throw new WindupException(""String_Node_Str"" + iterated.toPrettyString() + ""String_Node_Str"");
    }
    if (fileName != null && !fileName.equals(""String_Node_Str"")) {
      if (!xml.getFileName().equals(fileName)) {
        continue;
      }
    }
    if (publicId != null && !publicId.equals(""String_Node_Str"")) {
      if (xml.getDoctype() == null || xml.getDoctype().getPublicId() == null || !xml.getDoctype().getPublicId().matches(publicId)) {
        continue;
      }
    }
    if (xpath != null) {
      try {
        Document document=xml.asDocument();
        NodeList result=XmlUtil.xpathNodeList(document,xpath,namespaces);
        List<String> lines=Files.readAllLines(Paths.get(xml.getFilePath()),Charset.defaultCharset());
        if (result != null && (result.getLength() != 0)) {
          for (int i=0; i < result.getLength(); i++) {
            Node node=result.item(i);
            if (xpathResultMatch != null) {
              if (!node.toString().matches(xpathResultMatch)) {
                continue;
              }
            }
            int lineNumber=(int)node.getUserData(LocationAwareContentHandler.LINE_NUMBER_KEY_NAME);
            int columnNumber=(int)node.getUserData(LocationAwareContentHandler.COLUMN_NUMBER_KEY_NAME);
            int lineLength=lines.get(lineNumber - 1).length();
            graphContext=event.getGraphContext();
            GraphService<XmlTypeReferenceModel> fileLocationService=new GraphService<XmlTypeReferenceModel>(graphContext,XmlTypeReferenceModel.class);
            XmlTypeReferenceModel fileLocation=fileLocationService.create();
            fileLocation.setLineNumber(lineNumber);
            fileLocation.setColumnNumber(columnNumber);
            fileLocation.setLength(lineLength);
            fileLocation.setFile(xml);
            fileLocation.setXpath(xpath);
            GraphService<NamespaceMetaModel> metaModelService=new GraphService<NamespaceMetaModel>(graphContext,NamespaceMetaModel.class);
            for (            Map.Entry<String,String> namespace : namespaces.entrySet()) {
              NamespaceMetaModel metaModel=metaModelService.create();
              metaModel.setSchemaLocation(namespace.getKey());
              metaModel.setSchemaLocation(namespace.getValue());
              metaModel.addXmlResource(xml);
              fileLocation.addNamespace(metaModel);
            }
            resultLocations.add(fileLocation);
          }
        }
      }
 catch (      MarshallingException e) {
        GraphService<ClassificationModel> classificationService=new GraphService<>(event.getGraphContext(),ClassificationModel.class);
        ClassificationModel classification=classificationService.getUniqueByProperty(ClassificationModel.PROPERTY_CLASSIFICATION,XmlFile.UNPARSEABLE_XML_CLASSIFICATION);
        if (classification == null) {
          classification=classificationService.create();
          classification.setDescription(XmlFile.UNPARSEABLE_XML_DESCRIPTION);
          classification.setClassifiation(XmlFile.UNPARSEABLE_XML_CLASSIFICATION);
          classification.setRuleID(((Rule)context.get(Rule.class)).getId());
        }
        classification.addFileModel(xml);
      }
catch (      IOException e) {
        throw new WindupException(""String_Node_Str"",e);
      }
    }
  }
  Variables.instance(event).setVariable(variable,resultLocations);
  return !resultLocations.isEmpty();
}",0.9996498190731878
109559,"@Override public void perform(Rewrite rewrite,EvaluationContext context){
  if (!(rewrite instanceof GraphRewrite))   throw new IllegalArgumentException(""String_Node_Str"");
  GraphRewrite event=(GraphRewrite)rewrite;
  List<Rule> rules=config.getRules();
  for (  RuleLifecycleListener listener : listeners) {
    listener.beforeExecution();
  }
  final EvaluationContextImpl subContext=new EvaluationContextImpl();
  for (int i=0; i < rules.size(); i++) {
    Rule rule=rules.get(i);
    Context ruleContext=rule instanceof Context ? (Context)rule : null;
    long ruleTimeStarted=System.currentTimeMillis();
    try {
      subContext.clear();
      subContext.put(ParameterStore.class,context.get(ParameterStore.class));
      ParameterValueStore values=(ParameterValueStore)context.get(ParameterValueStore.class);
      subContext.put(ParameterValueStore.class,values);
      subContext.setState(RewriteState.EVALUATING);
      subContext.put(Rule.class,rule);
      event.selectionPush();
      try {
        for (        RuleLifecycleListener listener : listeners) {
          listener.beforeRuleEvaluation(rule,subContext);
        }
        if (rule.evaluate(event,subContext)) {
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleConditionEvaluation(event,subContext,rule,true);
          }
          if (!handleBindings(event,subContext,values))           continue;
          subContext.setState(RewriteState.PERFORMING);
          final Object ruleProviderDesc=((RuleBuilder)rule).get(RuleMetadata.RULE_PROVIDER);
          log.info(""String_Node_Str"" + ruleProviderDesc + ""String_Node_Str"");
          for (          RuleLifecycleListener listener : listeners) {
            listener.beforeRuleOperationsPerformed(event,subContext,rule);
          }
          List<Operation> preOperations=subContext.getPreOperations();
          for (          Operation preOperation : preOperations) {
            preOperation.perform(event,subContext);
          }
          if (event.getFlow().isHandled())           break;
          rule.perform(event,subContext);
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleOperationsPerformed(event,subContext,rule);
          }
          if (event.getFlow().isHandled())           break;
          List<Operation> postOperations=subContext.getPostOperations();
          for (          Operation postOperation : postOperations) {
            postOperation.perform(event,subContext);
          }
          if (event.getFlow().isHandled())           break;
        }
 else {
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleConditionEvaluation(event,subContext,rule,false);
          }
        }
      }
  finally {
        boolean autocommit=true;
        if (ruleContext != null && ruleContext.containsKey(RuleMetadata.AUTO_COMMIT)) {
          autocommit=(Boolean)ruleContext.get(RuleMetadata.AUTO_COMMIT);
        }
        if (autocommit) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        event.selectionPop();
        long ruleTimeCompleted=System.currentTimeMillis();
        if (ruleContext != null) {
          int timeTaken=(int)(ruleTimeCompleted - ruleTimeStarted);
          logTimeTakenByRuleProvider(event.getGraphContext(),ruleContext,i,timeTaken);
        }
      }
    }
 catch (    RuntimeException ex) {
      String message=""String_Node_Str"" + rule;
      message=""String_Node_Str"" + ex.getMessage();
      if (ruleContext != null) {
        Object origin=ruleContext.get(RuleMetadata.ORIGIN);
        if (origin != null)         message+=""String_Node_Str"" + origin;
        Object location=ruleContext.get(org.ocpsoft.rewrite.config.RuleMetadata.PROVIDER_LOCATION);
        if (location != null)         message+=""String_Node_Str"" + location;
      }
      throw new WindupException(message,ex);
    }
  }
  for (  RuleLifecycleListener listener : listeners) {
    listener.afterExecution();
  }
}","@Override public void perform(Rewrite rewrite,EvaluationContext context){
  if (!(rewrite instanceof GraphRewrite))   throw new IllegalArgumentException(""String_Node_Str"");
  GraphRewrite event=(GraphRewrite)rewrite;
  List<Rule> rules=config.getRules();
  for (  RuleLifecycleListener listener : listeners) {
    listener.beforeExecution();
  }
  final EvaluationContextImpl subContext=new EvaluationContextImpl();
  for (int i=0; i < rules.size(); i++) {
    Rule rule=rules.get(i);
    Context ruleContext=rule instanceof Context ? (Context)rule : null;
    long ruleTimeStarted=System.currentTimeMillis();
    try {
      subContext.clear();
      subContext.put(ParameterStore.class,context.get(ParameterStore.class));
      ParameterValueStore values=(ParameterValueStore)context.get(ParameterValueStore.class);
      subContext.put(ParameterValueStore.class,values);
      subContext.setState(RewriteState.EVALUATING);
      subContext.put(Rule.class,rule);
      event.selectionPush();
      try {
        for (        RuleLifecycleListener listener : listeners) {
          listener.beforeRuleEvaluation(rule,subContext);
        }
        if (rule.evaluate(event,subContext)) {
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleConditionEvaluation(event,subContext,rule,true);
          }
          if (!handleBindings(event,subContext,values))           continue;
          subContext.setState(RewriteState.PERFORMING);
          final Object ruleProviderDesc=((RuleBuilder)rule).get(RuleMetadata.RULE_PROVIDER);
          log.info(""String_Node_Str"" + ruleProviderDesc + ""String_Node_Str"");
          for (          RuleLifecycleListener listener : listeners) {
            listener.beforeRuleOperationsPerformed(event,subContext,rule);
          }
          List<Operation> preOperations=subContext.getPreOperations();
          for (          Operation preOperation : preOperations) {
            preOperation.perform(event,subContext);
          }
          if (event.getFlow().isHandled())           break;
          rule.perform(event,subContext);
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleOperationsPerformed(event,subContext,rule);
          }
          if (event.getFlow().isHandled())           break;
          List<Operation> postOperations=subContext.getPostOperations();
          for (          Operation postOperation : postOperations) {
            postOperation.perform(event,subContext);
          }
          if (event.getFlow().isHandled())           break;
        }
 else {
          for (          RuleLifecycleListener listener : listeners) {
            listener.afterRuleConditionEvaluation(event,subContext,rule,false);
          }
        }
      }
  finally {
        boolean autocommit=true;
        if (ruleContext != null && ruleContext.containsKey(RuleMetadata.AUTO_COMMIT)) {
          autocommit=(Boolean)ruleContext.get(RuleMetadata.AUTO_COMMIT);
        }
        if (autocommit) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        event.selectionPop();
        long ruleTimeCompleted=System.currentTimeMillis();
        if (ruleContext != null) {
          int timeTaken=(int)(ruleTimeCompleted - ruleTimeStarted);
          logTimeTakenByRuleProvider(event.getGraphContext(),ruleContext,i,timeTaken);
        }
      }
    }
 catch (    RuntimeException ex) {
      String exMsg=""String_Node_Str"" + rule;
      String logMsg=exMsg + ""String_Node_Str"" + ex.getMessage();
      log.severe(logMsg);
      if (ruleContext != null) {
        Object origin=ruleContext.get(RuleMetadata.ORIGIN);
        if (origin != null)         exMsg+=""String_Node_Str"" + origin;
        Object location=ruleContext.get(org.ocpsoft.rewrite.config.RuleMetadata.PROVIDER_LOCATION);
        if (location != null)         exMsg+=""String_Node_Str"" + location;
      }
      throw new WindupException(exMsg,ex);
    }
  }
  for (  RuleLifecycleListener listener : listeners) {
    listener.afterExecution();
  }
}",0.9874662079134924
109560,"public void addDecompiled(String path){
  this.decompiled.add(path);
}","public void addDecompiled(String inputPath,String path){
  this.decompiledFiles.put(inputPath,path);
}",0.7790697674418605
109561,"@Test public void testDecompileWicketJar() throws DecompilationException {
  File archive=new File(""String_Node_Str"");
  File outputFolder=new File(testTempDir,""String_Node_Str"");
  final Decompiler dec=this.getDecompiler();
  final DecompilationResult res=dec.decompileArchive(archive,outputFolder);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure dex : res.getFailures()) {
      sb.append(""String_Node_Str"").append(dex.getMessage());
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.error(sb.toString());
  }
  log.info(""String_Node_Str"",res.getDecompiled().size(),res.getFailures().size());
  final File sampleFile=new File(outputFolder,""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.getAbsolutePath(),sampleFile.exists());
}","@Test public void testDecompileWicketJar() throws DecompilationException {
  File archive=new File(""String_Node_Str"");
  File outputFolder=new File(testTempDir,""String_Node_Str"");
  final Decompiler dec=this.getDecompiler();
  final DecompilationResult res=dec.decompileArchive(archive,outputFolder);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure dex : res.getFailures()) {
      sb.append(""String_Node_Str"").append(dex.getMessage());
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.error(sb.toString());
  }
  log.info(""String_Node_Str"",res.getDecompiledFiles().size(),res.getFailures().size());
  final File sampleFile=new File(outputFolder,""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.getAbsolutePath(),sampleFile.exists());
}",0.9974962443665498
109562,"@Test @Ignore(""String_Node_Str"") public void testDecompileWicketJarDirectory() throws DecompilationException, IOException {
  final Decompiler dec=this.getDecompiler();
  File archive=new File(""String_Node_Str"");
  File outputFolder=new File(testTempDir,""String_Node_Str"");
  File unzippedDir=new File(outputFolder,""String_Node_Str"");
  ZipUtil.unzip(archive,unzippedDir);
  final DecompilationResult res=dec.decompileDirectory(unzippedDir,outputFolder);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure dex : res.getFailures()) {
      sb.append(""String_Node_Str"").append(dex.getMessage());
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.error(sb.toString());
  }
  log.info(""String_Node_Str"",res.getDecompiled().size(),res.getFailures().size());
  final File sampleFile=new File(outputFolder,""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.getAbsolutePath(),sampleFile.exists());
}","@Test @Ignore(""String_Node_Str"") public void testDecompileWicketJarDirectory() throws DecompilationException, IOException {
  final Decompiler dec=this.getDecompiler();
  File archive=new File(""String_Node_Str"");
  File outputFolder=new File(testTempDir,""String_Node_Str"");
  File unzippedDir=new File(outputFolder,""String_Node_Str"");
  ZipUtil.unzip(archive,unzippedDir);
  final DecompilationResult res=dec.decompileDirectory(unzippedDir,outputFolder);
  Assert.assertNotNull(""String_Node_Str"",res);
  if (!res.getFailures().isEmpty()) {
    final StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"" + res.getFailures().size() + ""String_Node_Str"");
    for (    final DecompilationFailure dex : res.getFailures()) {
      sb.append(""String_Node_Str"").append(dex.getMessage());
    }
    if (!this.isResultValid(res))     Assert.fail(sb.toString());
 else     log.error(sb.toString());
  }
  log.info(""String_Node_Str"",res.getDecompiledFiles().size(),res.getFailures().size());
  final File sampleFile=new File(outputFolder,""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"" + sampleFile.getAbsolutePath(),sampleFile.exists());
}",0.9978308026030368
109563,"@Override public DecompilationResult decompileArchive(File archive,File outputDir) throws DecompilationException {
  if (archive == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (!archive.exists())   throw new IllegalArgumentException(""String_Node_Str"" + archive.getPath());
  if (archive.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + archive.getPath());
  if (outputDir == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (outputDir.exists() && !outputDir.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + outputDir.getAbsolutePath());
  log.info(""String_Node_Str"" + archive.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath());
  final JarFile jar;
  try {
    jar=new JarFile(archive);
  }
 catch (  IOException ex) {
    throw new DecompilationException(""String_Node_Str"" + archive.getPath(),ex);
  }
  DecompilerSettings settings=getDefaultSettings(outputDir);
  settings.setTypeLoader(new CompositeTypeLoader(new JarTypeLoader(jar),settings.getTypeLoader()));
  MetadataSystem metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
  int classesDecompiled=0;
  DecompilationResult res=new DecompilationResult();
  final Enumeration<JarEntry> entries=jar.entries();
  while (entries.hasMoreElements()) {
    final JarEntry entry=entries.nextElement();
    final String name=entry.getName();
    if (!name.endsWith(""String_Node_Str""))     continue;
    final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
    try {
      File outputFile=this.decompileType(metadataSystem,typeName);
      if (outputFile != null) {
        res.addDecompiled(name);
        res.addDecompiledOutputFile(outputFile.getAbsolutePath());
      }
      if (++classesDecompiled % 100 == 0)       metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
    }
 catch (    Throwable th) {
      String msg=""String_Node_Str"" + archive.getPath() + ""String_Node_Str""+ name+ ""String_Node_Str""+ th.getMessage();
      DecompilationFailure ex=new DecompilationFailure(msg,name,th);
      log.error(msg,ex);
      res.addFailure(ex);
    }
  }
  return res;
}","@Override public DecompilationResult decompileArchive(File archive,File outputDir) throws DecompilationException {
  if (archive == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (!archive.exists())   throw new IllegalArgumentException(""String_Node_Str"" + archive.getPath());
  if (archive.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + archive.getPath());
  if (outputDir == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (outputDir.exists() && !outputDir.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + outputDir.getAbsolutePath());
  log.info(""String_Node_Str"" + archive.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath());
  final JarFile jar;
  try {
    jar=new JarFile(archive);
  }
 catch (  IOException ex) {
    throw new DecompilationException(""String_Node_Str"" + archive.getPath(),ex);
  }
  DecompilerSettings settings=getDefaultSettings(outputDir);
  settings.setTypeLoader(new CompositeTypeLoader(new JarTypeLoader(jar),settings.getTypeLoader()));
  MetadataSystem metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
  int classesDecompiled=0;
  DecompilationResult res=new DecompilationResult();
  final Enumeration<JarEntry> entries=jar.entries();
  while (entries.hasMoreElements()) {
    final JarEntry entry=entries.nextElement();
    final String name=entry.getName();
    if (!name.endsWith(""String_Node_Str""))     continue;
    final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
    try {
      File outputFile=this.decompileType(metadataSystem,typeName);
      if (outputFile != null) {
        res.addDecompiled(name,outputFile.getAbsolutePath());
      }
      if (++classesDecompiled % 100 == 0)       metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
    }
 catch (    Throwable th) {
      String msg=""String_Node_Str"" + archive.getPath() + ""String_Node_Str""+ name+ ""String_Node_Str""+ th.getMessage();
      DecompilationFailure ex=new DecompilationFailure(msg,name,th);
      log.error(msg,ex);
      res.addFailure(ex);
    }
  }
  return res;
}",0.9907149489322192
109564,"@Override public DecompilationResult decompileDirectory(File classesDir,File outputDir) throws DecompilationException {
  if (classesDir == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (!classesDir.exists())   throw new IllegalArgumentException(""String_Node_Str"" + classesDir.getPath());
  if (!classesDir.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + classesDir.getPath());
  if (outputDir == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (outputDir.exists() && !outputDir.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + outputDir.getAbsolutePath());
  log.info(""String_Node_Str"" + classesDir.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath());
  DecompilerSettings settings=getDefaultSettings(outputDir);
  MetadataSystem metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
  DecompilationResult result=new DecompilationResult();
  final List<File> files=Arrays.asList(classesDir.listFiles());
  for (  File file : files) {
    if (file.isDirectory()) {
      DecompilationResult intermediateResult=decompileDirectory(file,new File(outputDir,file.getName()));
      for (      String decompiled : intermediateResult.getDecompiled()) {
        result.addDecompiled(decompiled);
      }
      for (      DecompilationFailure failure : intermediateResult.getFailures()) {
        result.addFailure(failure);
      }
      continue;
    }
    String name=file.getName();
    if (!name.endsWith(""String_Node_Str""))     continue;
    final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
    try {
      this.decompileType(metadataSystem,typeName);
      result.addDecompiled(name);
    }
 catch (    Throwable e) {
      DecompilationFailure failure=new DecompilationFailure(""String_Node_Str"" + classesDir.getPath() + ""String_Node_Str""+ name+ ""String_Node_Str""+ e.getMessage(),name,e);
      log.error(failure.getMessage(),failure);
      result.addFailure(failure);
    }
  }
  return result;
}","public void decompileDirectory(File classesDir,File outputDir,DecompilationResult result) throws DecompilationException {
  if (classesDir == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (!classesDir.exists())   throw new IllegalArgumentException(""String_Node_Str"" + classesDir.getPath());
  if (!classesDir.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + classesDir.getPath());
  if (outputDir == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (outputDir.exists() && !outputDir.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + outputDir.getAbsolutePath());
  log.info(""String_Node_Str"" + classesDir.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath());
  DecompilerSettings settings=getDefaultSettings(outputDir);
  MetadataSystem metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
  final List<File> files=Arrays.asList(classesDir.listFiles());
  for (  File file : files) {
    if (file.isDirectory()) {
      decompileDirectory(file,new File(outputDir,file.getName()),result);
      continue;
    }
    String name=file.getName();
    if (!name.endsWith(""String_Node_Str""))     continue;
    final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
    try {
      File outputFile=this.decompileType(metadataSystem,typeName);
      result.addDecompiled(file.getAbsolutePath(),outputFile.getAbsolutePath());
    }
 catch (    Throwable e) {
      DecompilationFailure failure=new DecompilationFailure(""String_Node_Str"" + classesDir.getPath() + ""String_Node_Str""+ name+ ""String_Node_Str""+ e.getMessage(),name,e);
      log.error(failure.getMessage(),failure);
      result.addFailure(failure);
    }
  }
}",0.7317977230606302
109565,"@Override public DecompilationResult decompileClassFile(File classFile,File outputDir) throws DecompilationException {
  if (classFile == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (!classFile.exists())   throw new IllegalArgumentException(""String_Node_Str"" + classFile.getAbsolutePath());
  if (outputDir == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (outputDir.exists() && !outputDir.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + outputDir.getAbsolutePath());
  log.info(""String_Node_Str"" + classFile.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath());
  String name=classFile.getName();
  final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
  DecompilationResult res=new DecompilationResult();
  try {
    DecompilerSettings settings=getDefaultSettings(outputDir);
    MetadataSystem metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
    this.decompileType(metadataSystem,typeName);
    res.addDecompiled(name);
  }
 catch (  Throwable e) {
    DecompilationFailure failure=new DecompilationFailure(""String_Node_Str"" + classFile.getAbsolutePath() + ""String_Node_Str""+ e.getMessage(),name,e);
    log.error(failure.getMessage());
    res.addFailure(failure);
  }
  return res;
}","@Override public DecompilationResult decompileClassFile(File classFile,File outputDir) throws DecompilationException {
  if (classFile == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (!classFile.exists())   throw new IllegalArgumentException(""String_Node_Str"" + classFile.getAbsolutePath());
  if (outputDir == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (outputDir.exists() && !outputDir.isDirectory())   throw new IllegalArgumentException(""String_Node_Str"" + outputDir.getAbsolutePath());
  log.info(""String_Node_Str"" + classFile.getAbsolutePath() + ""String_Node_Str""+ outputDir.getAbsolutePath());
  String name=classFile.getName();
  final String typeName=StringUtils.removeEnd(name,""String_Node_Str"");
  DecompilationResult res=new DecompilationResult();
  try {
    DecompilerSettings settings=getDefaultSettings(outputDir);
    MetadataSystem metadataSystem=new NoRetryMetadataSystem(settings.getTypeLoader());
    File outputFile=this.decompileType(metadataSystem,typeName);
    res.addDecompiled(classFile.getAbsolutePath(),outputFile.getAbsolutePath());
  }
 catch (  Throwable e) {
    DecompilationFailure failure=new DecompilationFailure(""String_Node_Str"" + classFile.getAbsolutePath() + ""String_Node_Str""+ e.getMessage(),name,e);
    log.error(failure.getMessage());
    res.addFailure(failure);
  }
  return res;
}",0.8897168405365127
109566,"@Override public void perform(final GraphRewrite event,final EvaluationContext context,final ArchiveModel payload){
  if (payload.getUnzippedDirectory() != null) {
    Decompiler decompiler=new ProcyonDecompiler(new ProcyonConfiguration().setIncludeNested(false));
    String archivePath=((FileModel)payload).getFilePath();
    File archive=new File(archivePath);
    File outputDir=new File(payload.getUnzippedDirectory().getFilePath());
    if (payload instanceof WarArchiveModel) {
      outputDir=outputDir.toPath().resolve(""String_Node_Str"").resolve(""String_Node_Str"").toFile();
    }
    try {
      DecompilationResult result=decompiler.decompileArchive(archive,outputDir);
      Set<String> decompiledOutputFileSet=result.getDecompiledOutputFiles();
      FileModelService fileService=new FileModelService(event.getGraphContext());
      for (      String decompiledOutputFile : decompiledOutputFileSet) {
        FileModel decompiledFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,decompiledOutputFile);
        if (decompiledFileModel == null) {
          FileModel parentFileModel=fileService.findByPath(Paths.get(decompiledOutputFile).getParent().toString());
          decompiledFileModel=fileService.createByFilePath(parentFileModel,decompiledOutputFile);
          decompiledFileModel.setParentArchive(payload);
        }
        ProjectModel projectModel=payload.getProjectModel();
        decompiledFileModel.setProjectModel(projectModel);
        projectModel.addFileModel(decompiledFileModel);
        if (decompiledOutputFile.endsWith(""String_Node_Str"")) {
          if (!(decompiledFileModel instanceof JavaSourceFileModel)) {
            decompiledFileModel=GraphService.addTypeToModel(event.getGraphContext(),decompiledFileModel,JavaSourceFileModel.class);
          }
          JavaSourceFileModel decompiledSourceFileModel=(JavaSourceFileModel)decompiledFileModel;
          Path classFilepath=Paths.get(decompiledOutputFile.substring(0,decompiledOutputFile.length() - 5) + ""String_Node_Str"");
          FileModel classFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,classFilepath);
          if (classFileModel != null && classFileModel instanceof JavaClassFileModel) {
            JavaClassFileModel classModel=(JavaClassFileModel)classFileModel;
            classModel.getJavaClass().setDecompiledSource(decompiledSourceFileModel);
            decompiledSourceFileModel.setPackageName(classModel.getPackageName());
          }
        }
        payload.addDecompiledFileModel(decompiledFileModel);
      }
    }
 catch (    final DecompilationException exc) {
      throw new WindupException(""String_Node_Str"" + archivePath + ""String_Node_Str""+ exc.getMessage(),exc);
    }
  }
}","@Override public void perform(final GraphRewrite event,final EvaluationContext context,final ArchiveModel payload){
  if (payload.getUnzippedDirectory() != null) {
    Decompiler decompiler=new ProcyonDecompiler(new ProcyonConfiguration().setIncludeNested(false));
    String archivePath=((FileModel)payload).getFilePath();
    File archive=new File(archivePath);
    File outputDir=new File(payload.getUnzippedDirectory().getFilePath());
    if (payload instanceof WarArchiveModel) {
      outputDir=outputDir.toPath().resolve(""String_Node_Str"").resolve(""String_Node_Str"").toFile();
    }
    try {
      DecompilationResult result=decompiler.decompileArchive(archive,outputDir);
      Map<String,String> decompiledOutputFiles=result.getDecompiledFiles();
      FileModelService fileService=new FileModelService(event.getGraphContext());
      for (      Map.Entry<String,String> decompiledEntry : decompiledOutputFiles.entrySet()) {
        String[] classFilePathTokens=decompiledEntry.getKey().split(""String_Node_Str"");
        Path classFilePath=Paths.get(payload.getUnzippedDirectory().getFilePath());
        for (        String pathToken : classFilePathTokens) {
          classFilePath=classFilePath.resolve(pathToken);
        }
        String decompiledOutputFile=decompiledEntry.getValue();
        FileModel decompiledFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,decompiledOutputFile);
        if (decompiledFileModel == null) {
          FileModel parentFileModel=fileService.findByPath(Paths.get(decompiledOutputFile).getParent().toString());
          decompiledFileModel=fileService.createByFilePath(parentFileModel,decompiledOutputFile);
          decompiledFileModel.setParentArchive(payload);
        }
        ProjectModel projectModel=payload.getProjectModel();
        decompiledFileModel.setProjectModel(projectModel);
        projectModel.addFileModel(decompiledFileModel);
        if (decompiledOutputFile.endsWith(""String_Node_Str"")) {
          if (!(decompiledFileModel instanceof JavaSourceFileModel)) {
            decompiledFileModel=GraphService.addTypeToModel(event.getGraphContext(),decompiledFileModel,JavaSourceFileModel.class);
          }
          JavaSourceFileModel decompiledSourceFileModel=(JavaSourceFileModel)decompiledFileModel;
          FileModel classFileModel=fileService.getUniqueByProperty(FileModel.FILE_PATH,classFilePath.toAbsolutePath().toString());
          if (classFileModel != null && classFileModel instanceof JavaClassFileModel) {
            JavaClassFileModel classModel=(JavaClassFileModel)classFileModel;
            classModel.getJavaClass().setDecompiledSource(decompiledSourceFileModel);
            decompiledSourceFileModel.setPackageName(classModel.getPackageName());
          }
 else {
            throw new WindupException(""String_Node_Str"" + decompiledOutputFile + ""String_Node_Str""+ classFilePath.toString());
          }
        }
        payload.addDecompiledFileModel(decompiledFileModel);
      }
    }
 catch (    final DecompilationException exc) {
      throw new WindupException(""String_Node_Str"" + archivePath + ""String_Node_Str""+ exc.getMessage(),exc);
    }
  }
}",0.7947154471544715
109567,"public GraphContextImpl(Imported<Service<? extends VertexFrame>> graphServices,File diskCache,GraphTypeRegistry graphTypeRegistry,GraphApiCompositeClassLoaderProvider classLoaderProvider){
  this.graphServices=graphServices;
  this.graphTypeRegistry=graphTypeRegistry;
  this.classLoaderProvider=classLoaderProvider;
  FileUtils.deleteQuietly(diskCache);
  this.diskCacheDir=diskCache;
  File lucene=new File(diskCache,""String_Node_Str"");
  File berkeley=new File(diskCache,""String_Node_Str"");
  Configuration conf=new BaseConfiguration();
  conf.setProperty(""String_Node_Str"",berkeley.getAbsolutePath());
  conf.setProperty(""String_Node_Str"",""String_Node_Str"");
  conf.setProperty(""String_Node_Str"",""String_Node_Str"");
  conf.setProperty(""String_Node_Str"",lucene.getAbsolutePath());
  conf.setProperty(""String_Node_Str"",""String_Node_Str"");
  conf.setProperty(""String_Node_Str"",""String_Node_Str"");
  this.titanGraph=TitanFactory.open(conf);
  this.eventGraph=new EventGraph<TitanGraph>(this.titanGraph);
  String[] keys=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String key : keys) {
    this.titanGraph.makeKey(key).dataType(String.class).indexed(Vertex.class).make();
  }
  for (  String key : new String[]{""String_Node_Str""}) {
    this.titanGraph.makeKey(key).dataType(String.class).indexed(""String_Node_Str"",Vertex.class).make();
  }
  for (  String key : new String[]{WindupVertexFrame.TYPE_PROP}) {
    this.titanGraph.makeKey(key).list().dataType(String.class).indexed(""String_Node_Str"",Vertex.class).make();
  }
  batch=new BatchGraph<TitanGraph>(this.titanGraph,1000L);
  final ClassLoader compositeClassLoader=classLoaderProvider.getCompositeClassLoader();
  final AdjacentMapHandler frameMapHandler=new AdjacentMapHandler();
  final FrameClassLoaderResolver fclr=new FrameClassLoaderResolver(){
    public ClassLoader resolveClassLoader(    Class<?> frameType){
      return compositeClassLoader;
    }
  }
;
  final Module addModules=new Module(){
    @Override public Graph configure(    Graph baseGraph,    FramedGraphConfiguration config){
      config.setFrameClassLoaderResolver(fclr);
      config.addMethodHandler(frameMapHandler);
      config.addMethodHandler(new WindupPropertyMethodHandler());
      return baseGraph;
    }
  }
;
  FramedGraphFactory factory=new FramedGraphFactory(addModules,new JavaHandlerModule(),graphTypeRegistry.build(),new GremlinGroovyModule());
  framed=factory.create(eventGraph);
}","public GraphContextImpl(Imported<Service<? extends VertexFrame>> graphServices,File diskCache,GraphTypeRegistry graphTypeRegistry,GraphApiCompositeClassLoaderProvider classLoaderProvider){
  this.graphServices=graphServices;
  this.graphTypeRegistry=graphTypeRegistry;
  this.classLoaderProvider=classLoaderProvider;
  FileUtils.deleteQuietly(diskCache);
  this.diskCacheDir=diskCache;
  File lucene=new File(diskCache,""String_Node_Str"");
  File berkeley=new File(diskCache,""String_Node_Str"");
  Configuration conf=new BaseConfiguration();
  conf.setProperty(""String_Node_Str"",berkeley.getAbsolutePath());
  conf.setProperty(""String_Node_Str"",""String_Node_Str"");
  conf.setProperty(""String_Node_Str"",""String_Node_Str"");
  conf.setProperty(""String_Node_Str"",lucene.getAbsolutePath());
  conf.setProperty(""String_Node_Str"",""String_Node_Str"");
  conf.setProperty(""String_Node_Str"",""String_Node_Str"");
  this.titanGraph=TitanFactory.open(conf);
  String[] keys=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String key : keys) {
    this.titanGraph.makeKey(key).dataType(String.class).indexed(Vertex.class).make();
  }
  for (  String key : new String[]{""String_Node_Str""}) {
    this.titanGraph.makeKey(key).dataType(String.class).indexed(""String_Node_Str"",Vertex.class).make();
  }
  for (  String key : new String[]{WindupVertexFrame.TYPE_PROP}) {
    this.titanGraph.makeKey(key).list().dataType(String.class).indexed(Vertex.class).make();
  }
  this.eventGraph=new EventGraph<TitanGraph>(this.titanGraph);
  batch=new BatchGraph<TitanGraph>(this.titanGraph,1000L);
  final ClassLoader compositeClassLoader=classLoaderProvider.getCompositeClassLoader();
  final AdjacentMapHandler frameMapHandler=new AdjacentMapHandler();
  final FrameClassLoaderResolver fclr=new FrameClassLoaderResolver(){
    public ClassLoader resolveClassLoader(    Class<?> frameType){
      return compositeClassLoader;
    }
  }
;
  final Module addModules=new Module(){
    @Override public Graph configure(    Graph baseGraph,    FramedGraphConfiguration config){
      config.setFrameClassLoaderResolver(fclr);
      config.addMethodHandler(frameMapHandler);
      config.addMethodHandler(new WindupPropertyMethodHandler());
      return baseGraph;
    }
  }
;
  FramedGraphFactory factory=new FramedGraphFactory(addModules,new JavaHandlerModule(),graphTypeRegistry.build(),new GremlinGroovyModule());
  framed=factory.create(eventGraph);
}",0.9717536288740682
109568,"@Override public void perform(Rewrite rewrite,EvaluationContext context){
  if (!(rewrite instanceof GraphRewrite))   throw new IllegalArgumentException(""String_Node_Str"");
  GraphRewrite event=(GraphRewrite)rewrite;
  List<Rule> rules=config.getRules();
  final EvaluationContextImpl subContext=new EvaluationContextImpl();
  for (int i=0; i < rules.size(); i++) {
    Rule rule=rules.get(i);
    try {
      subContext.clear();
      subContext.put(ParameterStore.class,context.get(ParameterStore.class));
      ParameterValueStore values=(ParameterValueStore)context.get(ParameterValueStore.class);
      subContext.put(ParameterValueStore.class,values);
      subContext.setState(RewriteState.EVALUATING);
      subContext.put(Rule.class,rule);
      event.selectionPush();
      try {
        if (!rule.evaluate(event,subContext))         continue;
        if (!handleBindings(event,subContext,values))         continue;
        subContext.setState(RewriteState.PERFORMING);
        log.debug(""String_Node_Str"" + rule + ""String_Node_Str"");
        List<Operation> preOperations=subContext.getPreOperations();
        for (        Operation preOperation : preOperations) {
          preOperation.perform(event,subContext);
        }
        if (event.getFlow().isHandled())         break;
        rule.perform(event,subContext);
        if (event.getFlow().isHandled())         break;
        List<Operation> postOperations=subContext.getPostOperations();
        for (        Operation postOperation : postOperations) {
          postOperation.perform(event,subContext);
        }
        if (event.getFlow().isHandled())         break;
      }
  finally {
        boolean autocommit=true;
        if (rule instanceof Context) {
          Context ruleContext=(Context)rule;
          if (ruleContext.containsKey(RuleMetadata.AUTO_COMMIT)) {
            autocommit=(Boolean)ruleContext.get(RuleMetadata.AUTO_COMMIT);
          }
        }
        if (autocommit) {
          event.getGraphContext().getGraph().commit();
        }
        event.selectionPop();
      }
    }
 catch (    RuntimeException e) {
      String message=""String_Node_Str"" + rule;
      if (rule instanceof Context) {
        Object origin=((Context)rule).get(RuleMetadata.ORIGIN);
        if (origin != null)         message+=""String_Node_Str"" + origin;
        Object location=((Context)rule).get(org.ocpsoft.rewrite.config.RuleMetadata.PROVIDER_LOCATION);
        if (location != null)         message+=""String_Node_Str"" + location;
      }
      throw new WindupException(message,e);
    }
  }
}","@Override public void perform(Rewrite rewrite,EvaluationContext context){
  if (!(rewrite instanceof GraphRewrite))   throw new IllegalArgumentException(""String_Node_Str"");
  GraphRewrite event=(GraphRewrite)rewrite;
  List<Rule> rules=config.getRules();
  final EvaluationContextImpl subContext=new EvaluationContextImpl();
  for (int i=0; i < rules.size(); i++) {
    Rule rule=rules.get(i);
    try {
      subContext.clear();
      subContext.put(ParameterStore.class,context.get(ParameterStore.class));
      ParameterValueStore values=(ParameterValueStore)context.get(ParameterValueStore.class);
      subContext.put(ParameterValueStore.class,values);
      subContext.setState(RewriteState.EVALUATING);
      subContext.put(Rule.class,rule);
      event.selectionPush();
      try {
        if (!rule.evaluate(event,subContext))         continue;
        if (!handleBindings(event,subContext,values))         continue;
        subContext.setState(RewriteState.PERFORMING);
        log.debug(""String_Node_Str"" + rule + ""String_Node_Str"");
        List<Operation> preOperations=subContext.getPreOperations();
        for (        Operation preOperation : preOperations) {
          preOperation.perform(event,subContext);
        }
        if (event.getFlow().isHandled())         break;
        rule.perform(event,subContext);
        if (event.getFlow().isHandled())         break;
        List<Operation> postOperations=subContext.getPostOperations();
        for (        Operation postOperation : postOperations) {
          postOperation.perform(event,subContext);
        }
        if (event.getFlow().isHandled())         break;
      }
  finally {
        boolean autocommit=true;
        if (rule instanceof Context) {
          Context ruleContext=(Context)rule;
          if (ruleContext.containsKey(RuleMetadata.AUTO_COMMIT)) {
            autocommit=(Boolean)ruleContext.get(RuleMetadata.AUTO_COMMIT);
          }
        }
        if (autocommit) {
          event.getGraphContext().getGraph().getBaseGraph().commit();
        }
        event.selectionPop();
      }
    }
 catch (    RuntimeException e) {
      String message=""String_Node_Str"" + rule;
      if (rule instanceof Context) {
        Object origin=((Context)rule).get(RuleMetadata.ORIGIN);
        if (origin != null)         message+=""String_Node_Str"" + origin;
        Object location=((Context)rule).get(org.ocpsoft.rewrite.config.RuleMetadata.PROVIDER_LOCATION);
        if (location != null)         message+=""String_Node_Str"" + location;
      }
      throw new WindupException(message,e);
    }
  }
}",0.9970980847359258
109569,"@Deployment @Dependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static ForgeArchive getDeployment(){
  ForgeArchive archive=ShrinkWrap.create(ForgeArchive.class).addBeansXML().addClasses(FooModel.class,FooSubModel.class).addAsAddonDependencies(AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""));
  return archive;
}","@Deployment @Dependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static ForgeArchive getDeployment(){
  ForgeArchive archive=ShrinkWrap.create(ForgeArchive.class).addBeansXML().addClasses(TestFooModel.class,TestFooSubModel.class).addAsAddonDependencies(AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""));
  return archive;
}",0.9904076738609112
109570,"@Test public void testEventGraph() throws Exception {
  Assert.assertNotNull(context);
  StubGraphChangedListener stubGraphListener=new StubGraphChangedListener();
  context.getGraph().addListener(stubGraphListener);
  FooModel initialModelType=context.getFramed().addVertex(null,FooModel.class);
  Assert.assertEquals(1,stubGraphListener.addVertexEventRecorded());
  stubGraphListener.reset();
  GraphService.addTypeToModel(context,initialModelType,FooSubModel.class);
  Assert.assertEquals(1,stubGraphListener.vertexPropertyChangedEventRecorded());
}","@Test public void testEventGraph() throws Exception {
  Assert.assertNotNull(context);
  StubGraphChangedListener stubGraphListener=new StubGraphChangedListener();
  context.getGraph().addListener(stubGraphListener);
  TestFooModel initialModelType=context.getFramed().addVertex(null,TestFooModel.class);
  Assert.assertEquals(1,stubGraphListener.addVertexEventRecorded());
  stubGraphListener.reset();
  GraphService.addTypeToModel(context,initialModelType,TestFooSubModel.class);
  Assert.assertEquals(1,stubGraphListener.vertexPropertyChangedEventRecorded());
}",0.989247311827957
109571,"@Deployment @Dependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static ForgeArchive getDeployment(){
  ForgeArchive archive=ShrinkWrap.create(ForgeArchive.class).addBeansXML().addClasses(FooModel.class,FooSubModel.class).addAsAddonDependencies(AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""));
  return archive;
}","@Deployment @Dependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static ForgeArchive getDeployment(){
  ForgeArchive archive=ShrinkWrap.create(ForgeArchive.class).addBeansXML().addClasses(TestFooModel.class,TestFooSubModel.class).addAsAddonDependencies(AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""));
  return archive;
}",0.9904076738609112
109572,"@Test public void testInMemoryFrame() throws Exception {
  Assert.assertNotNull(context);
  GraphService<FooModel> fooModelService=context.getService(FooModel.class);
  FooModel inMemoryModel=fooModelService.createInMemory();
  inMemoryModel.setProp1(""String_Node_Str"");
  inMemoryModel.setProp2(""String_Node_Str"");
  inMemoryModel.setProp3(""String_Node_Str"");
  Iterable<Vertex> vertices=context.getFramed().query().has(""String_Node_Str"",Text.CONTAINS,FooModel.class.getAnnotation(TypeValue.class).value()).vertices();
  Assert.assertFalse(vertices.iterator().hasNext());
  InMemoryVertexFrame inMemoryFrame=(InMemoryVertexFrame)inMemoryModel;
  inMemoryFrame.attachToGraph();
  vertices=context.getFramed().query().has(""String_Node_Str"",Text.CONTAINS,FooModel.class.getAnnotation(TypeValue.class).value()).vertices();
  int numberFound=0;
  for (  Vertex v : vertices) {
    numberFound++;
    FooModel framed=(FooModel)context.getFramed().frame(v,WindupVertexFrame.class);
    Assert.assertTrue(framed instanceof FooModel);
    Assert.assertEquals(""String_Node_Str"",framed.getProp1());
    Assert.assertEquals(""String_Node_Str"",framed.getProp2());
    Assert.assertEquals(""String_Node_Str"",framed.getProp3());
  }
  Assert.assertEquals(1,numberFound);
}","@Test public void testInMemoryFrame() throws Exception {
  Assert.assertNotNull(context);
  GraphService<TestFooModel> fooModelService=context.getService(TestFooModel.class);
  TestFooModel inMemoryModel=fooModelService.createInMemory();
  inMemoryModel.setProp1(""String_Node_Str"");
  inMemoryModel.setProp2(""String_Node_Str"");
  inMemoryModel.setProp3(""String_Node_Str"");
  Iterable<Vertex> vertices=context.getFramed().query().has(""String_Node_Str"",Text.CONTAINS,TestFooModel.class.getAnnotation(TypeValue.class).value()).vertices();
  Assert.assertFalse(vertices.iterator().hasNext());
  InMemoryVertexFrame inMemoryFrame=(InMemoryVertexFrame)inMemoryModel;
  inMemoryFrame.attachToGraph();
  vertices=context.getFramed().query().has(""String_Node_Str"",Text.CONTAINS,TestFooModel.class.getAnnotation(TypeValue.class).value()).vertices();
  int numberFound=0;
  for (  Vertex v : vertices) {
    numberFound++;
    TestFooModel framed=(TestFooModel)context.getFramed().frame(v,WindupVertexFrame.class);
    Assert.assertTrue(framed instanceof TestFooModel);
    Assert.assertEquals(""String_Node_Str"",framed.getProp1());
    Assert.assertEquals(""String_Node_Str"",framed.getProp2());
    Assert.assertEquals(""String_Node_Str"",framed.getProp3());
  }
  Assert.assertEquals(1,numberFound);
}",0.9724842767295596
109573,"@Property(""String_Node_Str"") public FooModel setProp3(String prop);","@Property(""String_Node_Str"") public TestFooModel setProp3(String prop);",0.9710144927536232
109574,"@Property(""String_Node_Str"") public FooModel setProp2(String prop);","@Property(""String_Node_Str"") public TestFooModel setProp2(String prop);",0.9710144927536232
109575,"@Property(""String_Node_Str"") public FooModel setProp1(String prop);","@Property(""String_Node_Str"") public TestFooModel setProp1(String prop);",0.9710144927536232
109576,"@Deployment @Dependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static ForgeArchive getDeployment(){
  ForgeArchive archive=ShrinkWrap.create(ForgeArchive.class).addBeansXML().addClasses(FooModel.class,FooSubModel.class).addAsAddonDependencies(AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""));
  return archive;
}","@Deployment @Dependencies({@AddonDependency(name=""String_Node_Str""),@AddonDependency(name=""String_Node_Str"")}) public static ForgeArchive getDeployment(){
  ForgeArchive archive=ShrinkWrap.create(ForgeArchive.class).addBeansXML().addClasses(TestFooModel.class,TestFooSubModel.class).addAsAddonDependencies(AddonDependencyEntry.create(""String_Node_Str""),AddonDependencyEntry.create(""String_Node_Str""));
  return archive;
}",0.9904076738609112
109577,"@Test public void testInMemoryFrame() throws Exception {
  Assert.assertNotNull(context);
  GraphService<FooModel> fooModelService=context.getService(FooModel.class);
  FooModel inMemoryModel=fooModelService.create();
  inMemoryModel.setProp1(""String_Node_Str"").setProp2(""String_Node_Str"").setProp3(""String_Node_Str"");
  Iterable<Vertex> vertices=context.getFramed().query().has(""String_Node_Str"",Text.CONTAINS,FooModel.class.getAnnotation(TypeValue.class).value()).vertices();
  int numberFound=0;
  for (  Vertex v : vertices) {
    numberFound++;
    FooModel framed=(FooModel)context.getFramed().frame(v,WindupVertexFrame.class);
    Assert.assertTrue(framed instanceof FooModel);
    Assert.assertEquals(""String_Node_Str"",framed.getProp1());
    Assert.assertEquals(""String_Node_Str"",framed.getProp2());
    Assert.assertEquals(""String_Node_Str"",framed.getProp3());
  }
  Assert.assertEquals(1,numberFound);
}","@Test public void testInMemoryFrame() throws Exception {
  Assert.assertNotNull(context);
  GraphService<TestFooModel> fooModelService=context.getService(TestFooModel.class);
  TestFooModel inMemoryModel=fooModelService.create();
  inMemoryModel.setProp1(""String_Node_Str"").setProp2(""String_Node_Str"").setProp3(""String_Node_Str"");
  Iterable<Vertex> vertices=context.getFramed().query().has(""String_Node_Str"",Text.CONTAINS,TestFooModel.class.getAnnotation(TypeValue.class).value()).vertices();
  int numberFound=0;
  for (  Vertex v : vertices) {
    numberFound++;
    TestFooModel framed=(TestFooModel)context.getFramed().frame(v,WindupVertexFrame.class);
    Assert.assertTrue(framed instanceof TestFooModel);
    Assert.assertEquals(""String_Node_Str"",framed.getProp1());
    Assert.assertEquals(""String_Node_Str"",framed.getProp2());
    Assert.assertEquals(""String_Node_Str"",framed.getProp3());
  }
  Assert.assertEquals(1,numberFound);
}",0.9644396551724138
109578,"@Override public Configuration getConfiguration(GraphContext context){
  FreeMarkerOperation generateReportOperation=FreeMarkerOperation.create(TEMPLATE_PATH,OUTPUT_FILENAME,VAR_APPLICATION_REPORTS);
  return ConfigurationBuilder.begin().addRule().when(Query.find(ApplicationReportModel.class).as(VAR_APPLICATION_REPORTS)).perform(generateReportOperation);
}","@Override public Configuration getConfiguration(GraphContext context){
  FreeMarkerOperation generateReportOperation=FreeMarkerOperation.create(furnace,TEMPLATE_PATH,OUTPUT_FILENAME,VAR_APPLICATION_REPORTS);
  return ConfigurationBuilder.begin().addRule().when(Query.find(ApplicationReportModel.class).as(VAR_APPLICATION_REPORTS)).perform(generateReportOperation);
}",0.988950276243094
109579,"private String resolveClassname(String sourceClassname){
  if (!StringUtils.contains(sourceClassname,""String_Node_Str"")) {
    if (classNameLookedUp.contains(sourceClassname)) {
      String qualifiedName=classNameToFQCN.get(sourceClassname);
      if (qualifiedName != null) {
        return qualifiedName;
      }
 else {
        return sourceClassname;
      }
    }
 else {
      classNameLookedUp.add(sourceClassname);
      for (      String wildcardImport : wildcardImports) {
        String candidateQualifiedName=wildcardImport + ""String_Node_Str"" + sourceClassname;
        Iterable<JavaClassModel> models=javaClassDao.findAllByProperty(JavaClassModel.PROPERTY_QUALIFIED_NAME,candidateQualifiedName);
        if (models.iterator().hasNext()) {
          classNameToFQCN.put(sourceClassname,candidateQualifiedName);
          return candidateQualifiedName;
        }
 else {
          javaClassDao.getOrCreate(candidateQualifiedName);
        }
      }
      return sourceClassname;
    }
  }
 else {
    return sourceClassname;
  }
}","private String resolveClassname(String sourceClassname){
  if (!StringUtils.contains(sourceClassname,""String_Node_Str"")) {
    if (classNameLookedUp.contains(sourceClassname)) {
      String qualifiedName=classNameToFQCN.get(sourceClassname);
      if (qualifiedName != null) {
        return qualifiedName;
      }
 else {
        return sourceClassname;
      }
    }
 else {
      classNameLookedUp.add(sourceClassname);
      for (      String wildcardImport : wildcardImports) {
        String candidateQualifiedName=wildcardImport + ""String_Node_Str"" + sourceClassname;
        Iterable<JavaClassModel> models=javaClassService.findAllByProperty(JavaClassModel.PROPERTY_QUALIFIED_NAME,candidateQualifiedName);
        if (models.iterator().hasNext()) {
          classNameToFQCN.put(sourceClassname,candidateQualifiedName);
          return candidateQualifiedName;
        }
      }
      return sourceClassname;
    }
  }
 else {
    return sourceClassname;
  }
}",0.8866799204771372
109580,"@Override public void perform(GraphRewrite event,EvaluationContext context,FileModel payload){
  try {
    try (FileInputStream fis=new FileInputStream(payload.getFilePath())){
      ClassParser parser=new ClassParser(fis,payload.getFilePath());
      JavaClass javaClass=parser.parse();
      String packageName=javaClass.getPackageName();
      String qualifiedName=javaClass.getClassName();
      String simpleName=qualifiedName;
      if (packageName != null && !packageName.equals(""String_Node_Str"") && simpleName != null) {
        simpleName=simpleName.substring(packageName.length() + 1);
      }
      JavaFileModel classFileModel=GraphService.addTypeToModel(event.getGraphContext(),payload,JavaFileModel.class);
      classFileModel.setPackageName(packageName);
      GraphService<JavaClassModel> javaClassModelService=new GraphService<>(event.getGraphContext(),JavaClassModel.class);
      JavaClassModel javaClassModel=javaClassModelService.create();
      javaClassModel.setSimpleName(simpleName);
      javaClassModel.setPackageName(packageName);
      javaClassModel.setQualifiedName(qualifiedName);
      javaClassModel.setClassFile(classFileModel);
      for (      JavaClass iface : javaClass.getAllInterfaces()) {
        JavaClassService javaClassService=new JavaClassService(event.getGraphContext());
        JavaClassModel interfaceModel=javaClassService.getOrCreate(iface.getClassName());
        javaClassModel.addImplements(interfaceModel);
      }
      classFileModel.addJavaClass(javaClassModel);
    }
   }
 catch (  Exception e) {
    throw new WindupException(""String_Node_Str"" + payload.getFilePath() + ""String_Node_Str""+ e.getMessage(),e);
  }
}","@Override public void perform(GraphRewrite event,EvaluationContext context,FileModel payload){
  try {
    try (FileInputStream fis=new FileInputStream(payload.getFilePath())){
      ClassParser parser=new ClassParser(fis,payload.getFilePath());
      JavaClass javaClass=parser.parse();
      String packageName=javaClass.getPackageName();
      String qualifiedName=javaClass.getClassName();
      String simpleName=qualifiedName;
      if (packageName != null && !packageName.equals(""String_Node_Str"") && simpleName != null) {
        simpleName=simpleName.substring(packageName.length() + 1);
      }
      JavaFileModel classFileModel=GraphService.addTypeToModel(event.getGraphContext(),payload,JavaFileModel.class);
      classFileModel.setPackageName(packageName);
      JavaClassService javaClassService=new JavaClassService(event.getGraphContext());
      JavaClassModel javaClassModel=javaClassService.getOrCreate(qualifiedName);
      javaClassModel.setSimpleName(simpleName);
      javaClassModel.setPackageName(packageName);
      javaClassModel.setQualifiedName(qualifiedName);
      javaClassModel.setClassFile(classFileModel);
      String[] interfaceNames=javaClass.getInterfaceNames();
      if (interfaceNames != null) {
        for (        String iface : interfaceNames) {
          JavaClassModel interfaceModel=javaClassService.getOrCreate(iface);
          javaClassModel.addImplements(interfaceModel);
        }
      }
      String superclassName=javaClass.getSuperclassName();
      if (Strings.isNullOrEmpty(superclassName))       javaClassModel.setExtends(javaClassService.getOrCreate(superclassName));
      classFileModel.addJavaClass(javaClassModel);
    }
   }
 catch (  Exception e) {
    throw new WindupException(""String_Node_Str"" + payload.getFilePath() + ""String_Node_Str""+ e.getMessage(),e);
  }
}",0.7194080819578828
109581,"@Override public URL getResource(String name){
  for (  ClassLoader classLoader : loaders) {
    return classLoader.getResource(name);
  }
  ClassLoader contextLoader=Thread.currentThread().getContextClassLoader();
  if (contextLoader != null) {
    return contextLoader.getResource(name);
  }
 else {
    return super.getResource(name);
  }
}","@Override public URL getResource(String name){
  for (  ClassLoader classLoader : loaders) {
    URL resource=classLoader.getResource(name);
    if (resource != null) {
      return resource;
    }
  }
  ClassLoader contextLoader=Thread.currentThread().getContextClassLoader();
  if (contextLoader != null) {
    return contextLoader.getResource(name);
  }
 else {
    return super.getResource(name);
  }
}",0.897196261682243
109582,"@Override public Configuration getConfiguration(GraphContext context){
  Configuration configuration=ConfigurationBuilder.begin().addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").ofType(XmlMetaFacetModel.class)).perform(Iteration.over(XmlMetaFacetModel.class,""String_Node_Str"").as(""String_Node_Str"").perform(TypeOperation.addType(""String_Node_Str"",MavenProjectModel.class)).endIteration()).addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").ofType(MavenProjectModel.class)).perform(Iteration.over(MavenProjectModel.class,""String_Node_Str"").as(""String_Node_Str"").perform(new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      VarStack varStack=VarStack.instance(event);
      MavenProjectModel mavenFacetModel=varStack.getCurrentPayload(MavenProjectModel.class,""String_Node_Str"");
      results.add(mavenFacetModel);
    }
  }
).endIteration());
  return configuration;
}","@Override public Configuration getConfiguration(GraphContext context){
  Configuration configuration=ConfigurationBuilder.begin().addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").ofType(XmlMetaFacetModel.class)).perform(Iteration.over(XmlMetaFacetModel.class,""String_Node_Str"").as(""String_Node_Str"").perform(TypeOperation.addType(""String_Node_Str"",MavenProjectModel.class)).endIteration()).addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").ofType(MavenProjectModel.class)).perform(Iteration.over(MavenProjectModel.class,""String_Node_Str"").as(""String_Node_Str"").perform(new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      VarStack varStack=VarStack.instance(event);
      MavenProjectModel mavenFacetModel=Iteration.getCurrentPayload(varStack,MavenProjectModel.class,""String_Node_Str"");
      results.add(mavenFacetModel);
    }
  }
).endIteration());
  return configuration;
}",0.9753846153846154
109583,"@Override public void perform(GraphRewrite event,EvaluationContext context){
  VarStack varStack=VarStack.instance(event);
  MavenProjectModel mavenFacetModel=varStack.getCurrentPayload(MavenProjectModel.class,""String_Node_Str"");
  results.add(mavenFacetModel);
}","@Override public void perform(GraphRewrite event,EvaluationContext context){
  VarStack varStack=VarStack.instance(event);
  MavenProjectModel mavenFacetModel=Iteration.getCurrentPayload(varStack,MavenProjectModel.class,""String_Node_Str"");
  results.add(mavenFacetModel);
}",0.9514925373134328
109584,"@Override public Configuration getConfiguration(GraphContext context){
  Configuration configuration=ConfigurationBuilder.begin().addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").withProperty(XmlMetaFacetModel.PROPERTY_ROOT_TAG_NAME,GraphSearchPropertyComparisonType.EQUALS,""String_Node_Str"")).perform(Iteration.over(XmlMetaFacetModel.class,""String_Node_Str"").as(""String_Node_Str"").perform(new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      VarStack varStack=VarStack.instance(event);
      XmlMetaFacetModel xmlFacetModel=varStack.getCurrentPayload(XmlMetaFacetModel.class,""String_Node_Str"");
      typeSearchResults.add(xmlFacetModel);
    }
  }
).endIteration());
  return configuration;
}","@Override public Configuration getConfiguration(GraphContext context){
  Configuration configuration=ConfigurationBuilder.begin().addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").withProperty(XmlMetaFacetModel.PROPERTY_ROOT_TAG_NAME,GraphSearchPropertyComparisonType.EQUALS,""String_Node_Str"")).perform(Iteration.over(XmlMetaFacetModel.class,""String_Node_Str"").as(""String_Node_Str"").perform(new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      VarStack varStack=org.jboss.windup.config.runner.VarStack.instance(event);
      XmlMetaFacetModel xmlFacetModel=Iteration.getCurrentPayload(varStack,XmlMetaFacetModel.class,""String_Node_Str"");
      typeSearchResults.add(xmlFacetModel);
    }
  }
).endIteration());
  return configuration;
}",0.8027551659361303
109585,"@Override public void perform(GraphRewrite event,EvaluationContext context){
  VarStack varStack=VarStack.instance(event);
  XmlMetaFacetModel xmlFacetModel=varStack.getCurrentPayload(XmlMetaFacetModel.class,""String_Node_Str"");
  typeSearchResults.add(xmlFacetModel);
}","@Override public void perform(GraphRewrite event,EvaluationContext context){
  VarStack varStack=org.jboss.windup.config.runner.VarStack.instance(event);
  XmlMetaFacetModel xmlFacetModel=Iteration.getCurrentPayload(varStack,XmlMetaFacetModel.class,""String_Node_Str"");
  typeSearchResults.add(xmlFacetModel);
}",0.8635578583765112
109586,"@Override public Configuration getConfiguration(GraphContext context){
  Configuration configuration=ConfigurationBuilder.begin().addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").ofType(XmlMetaFacetModel.class).withProperty(XmlMetaFacetModel.PROPERTY_ROOT_TAG_NAME,GraphSearchPropertyComparisonType.EQUALS,""String_Node_Str"")).perform(Iteration.over(XmlMetaFacetModel.class,""String_Node_Str"").as(""String_Node_Str"").perform(new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      VarStack varStack=VarStack.instance(event);
      XmlMetaFacetModel xmlFacetModel=varStack.getCurrentPayload(XmlMetaFacetModel.class,""String_Node_Str"");
      typeSearchResults.add(xmlFacetModel);
    }
  }
).endIteration());
  return configuration;
}","@Override public Configuration getConfiguration(GraphContext context){
  Configuration configuration=ConfigurationBuilder.begin().addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").ofType(XmlMetaFacetModel.class).withProperty(XmlMetaFacetModel.PROPERTY_ROOT_TAG_NAME,GraphSearchPropertyComparisonType.EQUALS,""String_Node_Str"")).perform(Iteration.over(XmlMetaFacetModel.class,""String_Node_Str"").as(""String_Node_Str"").perform(new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      VarStack varStack=VarStack.instance(event);
      XmlMetaFacetModel xmlFacetModel=Iteration.getCurrentPayload(varStack,XmlMetaFacetModel.class,""String_Node_Str"");
      typeSearchResults.add(xmlFacetModel);
    }
  }
).endIteration());
  return configuration;
}",0.8257668711656442
109587,"@Override public void perform(GraphRewrite event,EvaluationContext context){
  VarStack varStack=VarStack.instance(event);
  XmlMetaFacetModel xmlFacetModel=varStack.getCurrentPayload(XmlMetaFacetModel.class,""String_Node_Str"");
  typeSearchResults.add(xmlFacetModel);
}","@Override public void perform(GraphRewrite event,EvaluationContext context){
  VarStack varStack=VarStack.instance(event);
  XmlMetaFacetModel xmlFacetModel=Iteration.getCurrentPayload(varStack,XmlMetaFacetModel.class,""String_Node_Str"");
  typeSearchResults.add(xmlFacetModel);
}",0.9525547445255474
109588,"public void init(CompilationUnit cu,FileModel fileModel){
  this.cu=cu;
  this.fileModel=fileModel;
  this.wildcardImports.clear();
  this.classNameLookedUp.clear();
  this.classNameToFQCN.clear();
  this.names.clear();
  this.nameInstance.clear();
  String packageName=cu.getPackage().getName().getFullyQualifiedName();
  List types=cu.types();
  if (!types.isEmpty()) {
    TypeDeclaration typeDeclaration=(TypeDeclaration)types.get(0);
    String className=typeDeclaration.getName().getFullyQualifiedName();
    String fqcn=packageName + ""String_Node_Str"" + className;
    this.names.add(""String_Node_Str"");
    this.nameInstance.put(""String_Node_Str"",fqcn);
  }
}","public void init(CompilationUnit cu,FileModel fileModel){
  this.cu=cu;
  this.fileModel=fileModel;
  this.wildcardImports.clear();
  this.classNameLookedUp.clear();
  this.classNameToFQCN.clear();
  this.names.clear();
  this.nameInstance.clear();
  String packageName=cu.getPackage().getName().getFullyQualifiedName();
  @SuppressWarnings(""String_Node_Str"") List<TypeDeclaration> types=cu.types();
  if (!types.isEmpty()) {
    TypeDeclaration typeDeclaration=(TypeDeclaration)types.get(0);
    String className=typeDeclaration.getName().getFullyQualifiedName();
    String fqcn=packageName + ""String_Node_Str"" + className;
    this.names.add(""String_Node_Str"");
    this.nameInstance.put(""String_Node_Str"",fqcn);
  }
}",0.9610951008645532
109589,"private String resolveClassname(String sourceClassname){
  if (!StringUtils.contains(sourceClassname,""String_Node_Str"")) {
    if (classNameLookedUp.contains(sourceClassname)) {
      String qualifiedName=classNameToFQCN.get(sourceClassname);
      if (qualifiedName != null) {
        return qualifiedName;
      }
 else {
        return sourceClassname;
      }
    }
 else {
      classNameLookedUp.add(sourceClassname);
      for (      String wildcardImport : wildcardImports) {
        String candidateQualifiedName=wildcardImport + ""String_Node_Str"" + sourceClassname;
        Iterable<JavaClassModel> javaClassModels=javaClassDao.findByJavaPackage(wildcardImport);
        for (        JavaClassModel javaClassModel : javaClassModels) {
          if (candidateQualifiedName.equals(javaClassModel.getQualifiedName())) {
            classNameToFQCN.put(sourceClassname,candidateQualifiedName);
            return candidateQualifiedName;
          }
        }
      }
      return sourceClassname;
    }
  }
 else {
    return sourceClassname;
  }
}","private String resolveClassname(String sourceClassname){
  if (!StringUtils.contains(sourceClassname,""String_Node_Str"")) {
    if (classNameLookedUp.contains(sourceClassname)) {
      String qualifiedName=classNameToFQCN.get(sourceClassname);
      if (qualifiedName != null) {
        return qualifiedName;
      }
 else {
        return sourceClassname;
      }
    }
 else {
      classNameLookedUp.add(sourceClassname);
      for (      String wildcardImport : wildcardImports) {
        String candidateQualifiedName=wildcardImport + ""String_Node_Str"" + sourceClassname;
        JavaClassModel jcm=javaClassDao.getJavaClass(candidateQualifiedName);
        if (jcm != null) {
          classNameToFQCN.put(sourceClassname,candidateQualifiedName);
          return candidateQualifiedName;
        }
      }
      return sourceClassname;
    }
  }
 else {
    return sourceClassname;
  }
}",0.7913669064748201
109590,"@Test public void testGraphTypeHandling() throws Exception {
  Assert.assertNotNull(context);
  BaseMetaModel baseMetaModel=context.getFramed().addVertex(null,BaseMetaModel.class);
  GraphUtil.addTypeToModel(context,baseMetaModel,XmlResourceModel.class);
  Iterable<Vertex> vertices=context.getFramed().query().has(""String_Node_Str"",Text.CONTAINS,BaseMetaModel.class.getAnnotation(TypeValue.class).value()).vertices();
  for (  Vertex v : vertices) {
    WindupVertexFrame framed=context.getFramed().frame(v,WindupVertexFrame.class);
    Assert.assertTrue(framed instanceof BaseMetaModel);
    Assert.assertTrue(framed instanceof XmlResourceModel);
  }
}","@Test public void testGraphTypeHandling() throws Exception {
  Assert.assertNotNull(context);
  BaseMetaModel baseMetaModel=context.getFramed().addVertex(null,BaseMetaModel.class);
  GraphUtil.addTypeToModel(context,baseMetaModel,XmlResourceModel.class);
  Iterable<Vertex> vertices=context.getFramed().query().has(""String_Node_Str"",Text.CONTAINS,BaseMetaModel.class.getAnnotation(TypeValue.class).value()).vertices();
  int numberFound=0;
  for (  Vertex v : vertices) {
    numberFound++;
    WindupVertexFrame framed=context.getFramed().frame(v,WindupVertexFrame.class);
    Assert.assertTrue(framed instanceof BaseMetaModel);
    Assert.assertTrue(framed instanceof XmlResourceModel);
  }
  Assert.assertEquals(1,numberFound);
}",0.9437229437229436
109591,"public void addTypeToElement(Class<? extends VertexFrame> kind,Element element){
  Class<?> typeHoldingTypeField=typeRegistry.getTypeHoldingTypeField(kind);
  if (typeHoldingTypeField != null) {
    TypeValue typeValueAnnotation=kind.getAnnotation(TypeValue.class);
    if (typeValueAnnotation != null) {
      String typeFieldName=typeHoldingTypeField.getAnnotation(TypeField.class).value();
      String typeValue=typeValueAnnotation.value();
      if (typeValue.contains(DELIMITER)) {
        throw new IllegalArgumentException(""String_Node_Str"" + kind.getCanonicalName() + ""String_Node_Str""+ typeValue+ ""String_Node_Str""+ DELIMITER+ ""String_Node_Str"");
      }
 else {
        for (int p=0; p < typeValue.length(); p++) {
          if (!Character.isLetterOrDigit(typeValue.charAt(p))) {
            throw new IllegalArgumentException(""String_Node_Str"" + kind.getCanonicalName() + ""String_Node_Str""+ typeValue+ ""String_Node_Str"");
          }
        }
      }
      String currentPropertyValue=element.getProperty(typeValue);
      if (currentPropertyValue == null) {
        element.setProperty(typeFieldName,DELIMITER + typeValue + DELIMITER);
      }
 else       if (!currentPropertyValue.contains(DELIMITER + typeValue + DELIMITER)) {
        element.setProperty(typeFieldName,currentPropertyValue + typeValue + DELIMITER);
      }
    }
  }
}","public void addTypeToElement(Class<? extends VertexFrame> kind,Element element){
  Class<?> typeHoldingTypeField=typeRegistry.getTypeHoldingTypeField(kind);
  if (typeHoldingTypeField != null) {
    TypeValue typeValueAnnotation=kind.getAnnotation(TypeValue.class);
    if (typeValueAnnotation != null) {
      String typeFieldName=typeHoldingTypeField.getAnnotation(TypeField.class).value();
      String typeValue=typeValueAnnotation.value();
      if (typeValue.contains(DELIMITER)) {
        throw new IllegalArgumentException(""String_Node_Str"" + kind.getCanonicalName() + ""String_Node_Str""+ typeValue+ ""String_Node_Str""+ DELIMITER+ ""String_Node_Str"");
      }
 else {
        for (int p=0; p < typeValue.length(); p++) {
          if (!Character.isLetterOrDigit(typeValue.charAt(p))) {
            throw new IllegalArgumentException(""String_Node_Str"" + kind.getCanonicalName() + ""String_Node_Str""+ typeValue+ ""String_Node_Str"");
          }
        }
      }
      String currentPropertyValue=element.getProperty(typeFieldName);
      if (currentPropertyValue == null) {
        element.setProperty(typeFieldName,DELIMITER + typeValue + DELIMITER);
      }
 else       if (!currentPropertyValue.contains(DELIMITER + typeValue + DELIMITER)) {
        element.setProperty(typeFieldName,currentPropertyValue + typeValue + DELIMITER);
      }
    }
  }
}",0.9955654101995566
109592,"/** 
 * Asks given IServerType what version is in the given directory. TODO: Make method of IServerType?
 * @deprecated  Use IServerType.recognizeVersion();
 */
private VersionRange recognizeVersion(Class<? extends IServerType> typeClass,File serverRootDir) throws WindupException {
  IServerType type=instantiate(typeClass);
  return type.recognizeVersion(serverRootDir);
}","/** 
 * Asks given IServerType what version is in the given directory. TODO: Make method of IServerType?
 * @deprecated Use IServerType.recognizeVersion();
 */
private VersionRange recognizeVersion(Class<? extends IServerType> typeClass,File serverRootDir) throws WindupException {
  IServerType type=instantiate(typeClass);
  return type.recognizeVersion(serverRootDir);
}",0.998661311914324
109593,"@Override public void query(FramedGraphQuery q){
switch (searchType) {
case EQUALS:
    q.has(this.propertyName,this.searchValue);
  break;
case CONTAINS_TOKEN:
q.has(this.propertyName,Text.CONTAINS,searchValue);
break;
case REGEX:
q.has(this.propertyName,Text.REGEX,searchValue);
default :
throw new IllegalArgumentException(""String_Node_Str"" + q);
}
}","@Override public void query(FramedGraphQuery q){
switch (searchType) {
case EQUALS:
    q.has(this.propertyName,this.searchValue);
  break;
case CONTAINS_TOKEN:
q.has(this.propertyName,Text.CONTAINS,searchValue);
break;
case REGEX:
q.has(this.propertyName,Text.REGEX,searchValue);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + searchType);
}
}",0.9750692520775625
109594,"@Test public void testJavaMethodModel(){
  ConfigurationBuilder.begin().addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").has(JavaClassModel.class).withProperty(""String_Node_Str"",GraphSearchPropertyComparisonType.REGEX,""String_Node_Str"")).perform(Iteration.query(GraphSearchConditionBuilderGremlin.create().withCriterion(new GraphSearchGremlinCriterion(){
    @Override public void query(    GremlinPipeline<Vertex,Vertex> pipeline){
      pipeline.out(""String_Node_Str"").has(""String_Node_Str"",""String_Node_Str"");
    }
  }
),""String_Node_Str"",""String_Node_Str"").perform(new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      SelectionFactory selection=SelectionFactory.instance(event);
      JavaMethodModel methodModel=selection.getCurrentPayload(JavaMethodModel.class);
      LOG.info(""String_Node_Str"" + methodModel.getMethodName() + ""String_Node_Str""+ methodModel.getJavaClass().getQualifiedName());
    }
  }
));
}","@Test public void testJavaMethodModel(){
  final File folder=OperatingSystemUtils.createTempDir();
  final GraphContext context=new GraphContextImpl(folder,graphTypeRegistry);
  GraphRewrite event=new GraphRewrite(context);
  final DefaultEvaluationContext evaluationContext=new DefaultEvaluationContext();
  final DefaultParameterValueStore values=new DefaultParameterValueStore();
  evaluationContext.put(ParameterValueStore.class,values);
  event.getRewriteContext().put(SelectionFactory.class,selectionFactory);
  JavaClassModel classModel1=context.getFramed().addVertex(null,JavaClassModel.class);
  classModel1.setQualifiedName(""String_Node_Str"");
  JavaClassModel classModel2=context.getFramed().addVertex(null,JavaClassModel.class);
  classModel2.setQualifiedName(""String_Node_Str"");
  JavaMethodModel methodModelSomeMethod=context.getFramed().addVertex(null,JavaMethodModel.class);
  methodModelSomeMethod.setJavaClass(classModel2);
  methodModelSomeMethod.setMethodName(""String_Node_Str"");
  JavaMethodModel methodModelToString=context.getFramed().addVertex(null,JavaMethodModel.class);
  methodModelToString.setJavaClass(classModel2);
  methodModelToString.setMethodName(""String_Node_Str"");
  final List<MavenFacetModel> typeSearchResults=new ArrayList<>();
  Configuration configuration=ConfigurationBuilder.begin().addRule().when(GraphSearchConditionBuilder.create(""String_Node_Str"").has(JavaClassModel.class).withProperty(""String_Node_Str"",GraphSearchPropertyComparisonType.REGEX,""String_Node_Str"")).perform(Iteration.query(GraphSearchConditionBuilderGremlin.create().withCriterion(new GraphSearchGremlinCriterion(){
    @Override public void query(    GremlinPipeline<Vertex,Vertex> pipeline){
      pipeline.out(""String_Node_Str"").has(""String_Node_Str"",""String_Node_Str"");
    }
  }
),""String_Node_Str"",""String_Node_Str"").perform(new GraphOperation(){
    @Override public void perform(    GraphRewrite event,    EvaluationContext context){
      SelectionFactory selection=SelectionFactory.instance(event);
      JavaMethodModel methodModel=selection.getCurrentPayload(JavaMethodModel.class);
      LOG.info(""String_Node_Str"" + methodModel.getMethodName() + ""String_Node_Str""+ methodModel.getJavaClass().getQualifiedName());
    }
  }
));
  Subset.evaluate(configuration).perform(event,evaluationContext);
}",0.6021052631578947
109595,"@Override public List<Class<? extends GraphVisitor>> getDependencies(){
  return super.generateDependencies(ZipArchiveGraphVisitor.class);
}","@Override public List<Class<? extends GraphVisitor>> getDependencies(){
  return super.generateDependencies(ZipArchiveGraphVisitor.class,DirectoryVisitor.class);
}",0.924092409240924
109596,"public void populateMeta(JavaMetadata meta){
  ASTParser parser=ASTParser.newParser(AST.JLS3);
  parser.setBindingsRecovery(true);
  parser.setResolveBindings(true);
  try {
    parser.setSource(FileUtils.readFileToString(meta.getFilePointer()).toCharArray());
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    return;
  }
  parser.setKind(ASTParser.K_COMPILATION_UNIT);
  final CompilationUnit cu=(CompilationUnit)parser.createAST(null);
  @SuppressWarnings(""String_Node_Str"") List<ImportDeclaration> imports=cu.imports();
  Set<String> clzDependencies=new HashSet<String>();
  for (  ImportDeclaration id : imports) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + id.getName());
    }
    clzDependencies.add(id.getName().getFullyQualifiedName());
  }
  meta.setClassDependencies(clzDependencies);
  meta.setBlackListedDependencies(blacklistPackageResolver.extractBlacklist(clzDependencies));
  if (LOG.isDebugEnabled()) {
    for (    String id : meta.getBlackListedDependencies()) {
      LOG.debug(""String_Node_Str"" + id);
    }
  }
  @SuppressWarnings(""String_Node_Str"") List<TypeDeclaration> types=cu.types();
  for (  TypeDeclaration type : types) {
    PackageDeclaration packageDeclaration=cu.getPackage();
    String packageName=""String_Node_Str"";
    if (packageDeclaration != null) {
      packageName=cu.getPackage().getName().getFullyQualifiedName() + ""String_Node_Str"";
    }
    String fullPackage=packageName + type.getName().getFullyQualifiedName();
    meta.setQualifiedClassName(fullPackage);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + fullPackage);
    }
    break;
  }
}","public void populateMeta(JavaMetadata meta){
  ASTParser parser=ASTParser.newParser(AST.JLS3);
  parser.setBindingsRecovery(true);
  parser.setResolveBindings(true);
  try {
    parser.setSource(FileUtils.readFileToString(meta.getFilePointer()).toCharArray());
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    return;
  }
  parser.setKind(ASTParser.K_COMPILATION_UNIT);
  final CompilationUnit cu=(CompilationUnit)parser.createAST(null);
  @SuppressWarnings(""String_Node_Str"") List<ImportDeclaration> imports=cu.imports();
  Set<String> clzDependencies=new HashSet<String>();
  if (imports != null) {
    for (    ImportDeclaration id : imports) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + id.getName());
      }
      clzDependencies.add(id.getName().getFullyQualifiedName());
    }
  }
  meta.setClassDependencies(clzDependencies);
  meta.setBlackListedDependencies(blacklistPackageResolver.extractBlacklist(clzDependencies));
  if (LOG.isDebugEnabled()) {
    for (    String id : meta.getBlackListedDependencies()) {
      LOG.debug(""String_Node_Str"" + id);
    }
  }
  @SuppressWarnings(""String_Node_Str"") List<TypeDeclaration> types=cu.types();
  if (types != null) {
    for (    TypeDeclaration type : types) {
      PackageDeclaration packageDeclaration=cu.getPackage();
      String packageName=""String_Node_Str"";
      if (packageDeclaration != null) {
        packageName=cu.getPackage().getName().getFullyQualifiedName() + ""String_Node_Str"";
      }
      String fullPackage=packageName + type.getName().getFullyQualifiedName();
      meta.setQualifiedClassName(fullPackage);
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + fullPackage);
      }
      break;
    }
  }
 else {
    LOG.warn(""String_Node_Str"" + meta.getPathRelativeToArchive());
  }
}",0.9448413832523578
109597,"protected Collection<ModuleVO> findModulesContainingArchive(ArchiveVO archive) throws ModuleIndexReaderException {
  Set<ModuleVO> modules=new HashSet<ModuleVO>();
  IndexReader reader=null;
  try {
    reader=DirectoryReader.open(moduleIndexDir);
    IndexSearcher searcher=new IndexSearcher(reader);
    BooleanQuery query=new BooleanQuery();
    query.add(new TermQuery(new Term(ModuleTransformer.MODULE_ARCHIVE,archive.getSha1())),BooleanClause.Occur.MUST);
    int numResults=100;
    ScoreDoc[] hits=searcher.search(query,numResults).scoreDocs;
    for (int i=0; i < hits.length; i++) {
      Document doc=searcher.doc(hits[i].doc);
      modules.add(ModuleTransformer.fromDocument(doc));
    }
  }
 catch (  Exception e) {
    throw new ModuleIndexReaderException(""String_Node_Str"" + archive.toString(),e);
  }
 finally {
    IOUtils.closeQuietly(reader);
  }
  return modules;
}","protected Collection<ModuleVO> findModulesContainingArchive(Collection<ArchiveVO> archives) throws ModuleIndexReaderException {
  Set<ModuleVO> modules=new HashSet<ModuleVO>();
  IndexReader reader=null;
  try {
    reader=DirectoryReader.open(moduleIndexDir);
    IndexSearcher searcher=new IndexSearcher(reader);
    BooleanQuery query=new BooleanQuery();
    for (    ArchiveVO archive : archives) {
      query.add(new TermQuery(new Term(ModuleTransformer.MODULE_ARCHIVE,archive.getSha1())),BooleanClause.Occur.SHOULD);
    }
    query.setMinimumNumberShouldMatch(1);
    int numResults=100;
    ScoreDoc[] hits=searcher.search(query,numResults).scoreDocs;
    for (int i=0; i < hits.length; i++) {
      Document doc=searcher.doc(hits[i].doc);
      modules.add(ModuleTransformer.fromDocument(doc));
    }
  }
 catch (  Exception e) {
    throw new ModuleIndexReaderException(""String_Node_Str"",e);
  }
 finally {
    IOUtils.closeQuietly(reader);
  }
  return modules;
}",0.846856528747985
109598,"@Override public Collection<ModuleVO> findModuleProvidingClass(String clz) throws ModuleIndexReaderException {
  Set<ModuleVO> modules=new HashSet<ModuleVO>();
  try {
    Collection<ArchiveVO> archives=archiveIndexer.findArchiveByQualifiedClassName(clz);
    for (    ArchiveVO archive : archives) {
      modules.addAll(findModulesContainingArchive(archive));
    }
  }
 catch (  ArchiveIndexReaderException e) {
    throw new ModuleIndexReaderException(""String_Node_Str"" + clz,e);
  }
  return modules;
}","@Override public Collection<ModuleVO> findModuleProvidingClass(String clz) throws ModuleIndexReaderException {
  Set<ModuleVO> modules=new HashSet<ModuleVO>();
  try {
    Collection<ArchiveVO> archives=archiveIndexer.findArchiveByQualifiedClassName(clz);
    modules.addAll(findModulesContainingArchive(archives));
  }
 catch (  ArchiveIndexReaderException e) {
    throw new ModuleIndexReaderException(""String_Node_Str"" + clz,e);
  }
  return modules;
}",0.943866943866944
109599,"@Override public void addModule(ModuleVO module) throws ModuleIndexWriteException {
  Document document=ModuleTransformer.toDocument(module);
  IndexWriter writer=null;
  try {
    writer=new IndexWriter(moduleIndexDir,iwc);
    writer.updateDocument(new Term(ModuleTransformer.MODULE_ID),document);
    writer.commit();
  }
 catch (  Exception e) {
    throw new ModuleIndexWriteException(""String_Node_Str"" + module.toString(),e);
  }
 finally {
    IOUtils.closeQuietly(writer);
  }
}","@Override public void addModule(ModuleVO module) throws ModuleIndexWriteException {
  Document document=ModuleTransformer.toDocument(module);
  IndexWriter writer=null;
  try {
    writer=new IndexWriter(moduleIndexDir,iwc);
    writer.updateDocument(new Term(ModuleTransformer.MODULE_ID,document.get(ModuleTransformer.MODULE_ID)),document);
    writer.commit();
  }
 catch (  Exception e) {
    throw new ModuleIndexWriteException(""String_Node_Str"" + module.toString(),e);
  }
 finally {
    IOUtils.closeQuietly(writer);
  }
}",0.9585798816568049
109600,"public static ModuleVO fromDocument(Document doc){
  ModuleVO module=new ModuleVO();
  module.setName(doc.get(MODULE_NAME));
  module.setSlot(doc.get(MODULE_SLOT));
  for (  IndexableField field : doc.getFields(MODULE_DEPENDENCY)) {
    String[] vals=StringUtils.split(field.stringValue(),""String_Node_Str"");
    ModuleVO dep=new ModuleVO();
    dep.setName(vals[0]);
    dep.setSlot(vals[1]);
    module.getDependencies().add(dep);
  }
  return module;
}","public static ModuleVO fromDocument(Document doc){
  ModuleVO module=new ModuleVO();
  module.setName(doc.get(MODULE_NAME));
  module.setSlot(doc.get(MODULE_SLOT));
  PlatformVO platform=new PlatformVO();
  platform.setName(doc.get(PLATFORM_NAME));
  platform.setVersion(doc.get(PLATFORM_VERSION));
  module.setPlatform(platform);
  for (  IndexableField field : doc.getFields(MODULE_DEPENDENCY)) {
    String[] vals=StringUtils.split(field.stringValue(),""String_Node_Str"");
    ModuleVO dep=new ModuleVO();
    dep.setName(vals[0]);
    dep.setSlot(vals[1]);
    module.getDependencies().add(dep);
  }
  return module;
}",0.845724907063197
109601,"@Override public String toString(){
  return ""String_Node_Str"" + name + ""String_Node_Str""+ slot+ ""String_Node_Str""+ dependencies+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + platform + ""String_Node_Str""+ name+ ""String_Node_Str""+ slot+ ""String_Node_Str""+ dependencies+ ""String_Node_Str""+ archives+ ""String_Node_Str"";
}",0.8324022346368715
109602,"public void populateMeta(JavaMetadata meta){
  ASTParser parser=ASTParser.newParser(AST.JLS3);
  parser.setBindingsRecovery(true);
  parser.setResolveBindings(true);
  try {
    parser.setSource(FileUtils.readFileToString(meta.getFilePointer()).toCharArray());
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    return;
  }
  parser.setKind(ASTParser.K_COMPILATION_UNIT);
  final CompilationUnit cu=(CompilationUnit)parser.createAST(null);
  @SuppressWarnings(""String_Node_Str"") List<ImportDeclaration> imports=cu.imports();
  Set<String> clzDependencies=new HashSet<String>();
  for (  ImportDeclaration id : imports) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + id.getName());
    }
    clzDependencies.add(id.getName().getFullyQualifiedName());
  }
  meta.setClassDependencies(clzDependencies);
  meta.setBlackListedDependencies(blacklistPackageResolver.extractBlacklist(clzDependencies));
  if (LOG.isDebugEnabled()) {
    for (    String id : meta.getBlackListedDependencies()) {
      LOG.debug(""String_Node_Str"" + id);
    }
  }
  @SuppressWarnings(""String_Node_Str"") List<TypeDeclaration> types=cu.types();
  for (  TypeDeclaration type : types) {
    String fullPackage=cu.getPackage().getName().getFullyQualifiedName();
    fullPackage=fullPackage + ""String_Node_Str"" + type.getName().getFullyQualifiedName();
    meta.setQualifiedClassName(fullPackage);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + fullPackage);
    }
    break;
  }
}","public void populateMeta(JavaMetadata meta){
  ASTParser parser=ASTParser.newParser(AST.JLS3);
  parser.setBindingsRecovery(true);
  parser.setResolveBindings(true);
  try {
    parser.setSource(FileUtils.readFileToString(meta.getFilePointer()).toCharArray());
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
    return;
  }
  parser.setKind(ASTParser.K_COMPILATION_UNIT);
  final CompilationUnit cu=(CompilationUnit)parser.createAST(null);
  @SuppressWarnings(""String_Node_Str"") List<ImportDeclaration> imports=cu.imports();
  Set<String> clzDependencies=new HashSet<String>();
  for (  ImportDeclaration id : imports) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + id.getName());
    }
    clzDependencies.add(id.getName().getFullyQualifiedName());
  }
  meta.setClassDependencies(clzDependencies);
  meta.setBlackListedDependencies(blacklistPackageResolver.extractBlacklist(clzDependencies));
  if (LOG.isDebugEnabled()) {
    for (    String id : meta.getBlackListedDependencies()) {
      LOG.debug(""String_Node_Str"" + id);
    }
  }
  @SuppressWarnings(""String_Node_Str"") List<TypeDeclaration> types=cu.types();
  for (  TypeDeclaration type : types) {
    PackageDeclaration packageDeclaration=cu.getPackage();
    String packageName=""String_Node_Str"";
    if (packageDeclaration != null) {
      packageName=cu.getPackage().getName().getFullyQualifiedName() + ""String_Node_Str"";
    }
    String fullPackage=packageName + type.getName().getFullyQualifiedName();
    meta.setQualifiedClassName(fullPackage);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + fullPackage);
    }
    break;
  }
}",0.9278740157480316
109603,"/** 
 * This method creates a number of custom New Relic Metrics, that are derived from raw MySQL status metrics
 * @param Map existing Gathered MySQL metrics
 * @param metrics  String of the Metric Categories to capture
 * @return Map  Additional derived metrics
 */
protected Map<String,Number> newRelicMetrics(Map<String,Number> existing,String metrics){
  Map<String,Number> derived=new HashMap<String,Number>();
  if (!metrics.contains(""String_Node_Str"" + COMMA))   return derived;
  if (!metrics.contains(""String_Node_Str"" + COMMA))   return derived;
  logger.fine(""String_Node_Str"");
  try {
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue() + existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue() + existing.get(""String_Node_Str"").intValue() + existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue());
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    float threads_connected=existing.get(""String_Node_Str"").floatValue();
    float threads_running=existing.get(""String_Node_Str"").floatValue();
    derived.put(""String_Node_Str"",(int)threads_connected);
    derived.put(""String_Node_Str"",(int)threads_running);
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",(threads_running / threads_connected) * 100.0);
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    float innodb_read_requests=existing.get(""String_Node_Str"").floatValue();
    float innodb_reads=existing.get(""String_Node_Str"").floatValue();
    derived.put(""String_Node_Str"",(innodb_read_requests / (innodb_read_requests + innodb_reads)) * 100.0);
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    int pages_total=existing.get(""String_Node_Str"").intValue();
    int pages_data=existing.get(""String_Node_Str"").intValue();
    int pages_misc=existing.get(""String_Node_Str"").intValue();
    int pages_dirty=existing.get(""String_Node_Str"").intValue();
    int pages_free=existing.get(""String_Node_Str"").intValue();
    derived.put(""String_Node_Str"",pages_data - pages_dirty);
    derived.put(""String_Node_Str"",pages_dirty);
    derived.put(""String_Node_Str"",pages_misc);
    derived.put(""String_Node_Str"",pages_free);
    derived.put(""String_Node_Str"",pages_total - pages_data - pages_free- pages_misc);
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    float qc_hits=existing.get(""String_Node_Str"").floatValue();
    float reads=existing.get(""String_Node_Str"").floatValue();
    float free=existing.get(""String_Node_Str"").floatValue();
    float total=existing.get(""String_Node_Str"").floatValue();
    derived.put(""String_Node_Str"",(int)qc_hits);
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",(qc_hits / (qc_hits + reads)) * 100.0);
    derived.put(""String_Node_Str"",100 - ((free / total) * 100.0));
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    float tmp_tables=existing.get(""String_Node_Str"").floatValue();
    float tmp_tables_disk=existing.get(""String_Node_Str"").floatValue();
    derived.put(""String_Node_Str"",(tmp_tables_disk / tmp_tables) * 100.0);
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    if (metrics.contains(""String_Node_Str"" + COMMA)) {
      derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
      int slave_io_thread_running=existing.get(""String_Node_Str"").intValue();
      int slave_sql_thread_running=existing.get(""String_Node_Str"").intValue();
      int replication_status=1;
      if (slave_io_thread_running + slave_sql_thread_running == 2)       replication_status=0;
      derived.put(""String_Node_Str"",replication_status);
      derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
      derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue() - existing.get(""String_Node_Str"").intValue());
    }
 else {
      derived.put(""String_Node_Str"",0);
      derived.put(""String_Node_Str"",0);
      derived.put(""String_Node_Str"",0);
      derived.put(""String_Node_Str"",0);
    }
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  return derived;
}","/** 
 * This method creates a number of custom New Relic Metrics, that are derived from raw MySQL status metrics
 * @param Map existing Gathered MySQL metrics
 * @param metrics  String of the Metric Categories to capture
 * @return Map  Additional derived metrics
 */
protected Map<String,Number> newRelicMetrics(Map<String,Number> existing,String metrics){
  Map<String,Number> derived=new HashMap<String,Number>();
  if (!metrics.contains(""String_Node_Str"" + COMMA))   return derived;
  if (!metrics.contains(""String_Node_Str"" + COMMA))   return derived;
  logger.fine(""String_Node_Str"");
  try {
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue() + existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue() + existing.get(""String_Node_Str"").intValue() + existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue()+ existing.get(""String_Node_Str"").intValue());
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    float threads_connected=existing.get(""String_Node_Str"").floatValue();
    float threads_running=existing.get(""String_Node_Str"").floatValue();
    derived.put(""String_Node_Str"",(int)threads_connected);
    derived.put(""String_Node_Str"",(int)threads_running);
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",(threads_running / threads_connected) * 100.0);
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    float innodb_read_requests=existing.get(""String_Node_Str"").floatValue();
    float innodb_reads=existing.get(""String_Node_Str"").floatValue();
    derived.put(""String_Node_Str"",(innodb_read_requests / (innodb_read_requests + innodb_reads)) * 100.0);
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    int pages_total=existing.get(""String_Node_Str"").intValue();
    int pages_data=existing.get(""String_Node_Str"").intValue();
    int pages_misc=existing.get(""String_Node_Str"").intValue();
    int pages_dirty=existing.get(""String_Node_Str"").intValue();
    int pages_free=existing.get(""String_Node_Str"").intValue();
    derived.put(""String_Node_Str"",pages_data - pages_dirty);
    derived.put(""String_Node_Str"",pages_dirty);
    derived.put(""String_Node_Str"",pages_misc);
    derived.put(""String_Node_Str"",pages_free);
    derived.put(""String_Node_Str"",pages_total - pages_data - pages_free- pages_misc);
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    float qc_hits=existing.get(""String_Node_Str"").floatValue();
    float reads=existing.get(""String_Node_Str"").floatValue();
    float free=existing.get(""String_Node_Str"").floatValue();
    float total=existing.get(""String_Node_Str"").floatValue();
    derived.put(""String_Node_Str"",(int)qc_hits);
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
    derived.put(""String_Node_Str"",(qc_hits / (qc_hits + reads)) * 100.0);
    derived.put(""String_Node_Str"",100 - ((free / total) * 100.0));
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    float tmp_tables=existing.get(""String_Node_Str"").floatValue();
    float tmp_tables_disk=existing.get(""String_Node_Str"").floatValue();
    derived.put(""String_Node_Str"",(tmp_tables_disk / tmp_tables) * 100.0);
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  try {
    if (metrics.contains(""String_Node_Str"" + COMMA)) {
      if (existing.containsKey(""String_Node_Str"")) {
        derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
      }
      if (existing.containsKey(""String_Node_Str"") && existing.containsKey(""String_Node_Str"")) {
        int slave_io_thread_running=existing.get(""String_Node_Str"").intValue();
        int slave_sql_thread_running=existing.get(""String_Node_Str"").intValue();
        int replication_status=1;
        if (slave_io_thread_running + slave_sql_thread_running == 2)         replication_status=0;
        derived.put(""String_Node_Str"",replication_status);
      }
      if (existing.containsKey(""String_Node_Str"")) {
        derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue());
      }
      if (existing.containsKey(""String_Node_Str"") && existing.containsKey(""String_Node_Str"")) {
        derived.put(""String_Node_Str"",existing.get(""String_Node_Str"").intValue() - existing.get(""String_Node_Str"").intValue());
      }
    }
 else {
      derived.put(""String_Node_Str"",0);
      derived.put(""String_Node_Str"",0);
      derived.put(""String_Node_Str"",0);
      derived.put(""String_Node_Str"",0);
    }
  }
 catch (  Exception e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
  return derived;
}",0.9687892376681614
109604,"public void onDateSet(DatePicker view,int year,int month,int day){
  Log.v(TAG,""String_Node_Str"" + year + ""String_Node_Str""+ month+ ""String_Node_Str""+ day);
  mInputEditText.setText(""String_Node_Str"" + day + ""String_Node_Str""+ (month + 1)+ ""String_Node_Str""+ year);
  mPickableInstance.onPickerDismissed();
}","public void onDateSet(DatePicker view,int year,int month,int day){
  Log.v(TAG,""String_Node_Str"" + year + ""String_Node_Str""+ month+ ""String_Node_Str""+ day);
  month=month + 1;
  mInputEditText.setText(""String_Node_Str"" + (day < 10 ? ""String_Node_Str"" + day : day) + ""String_Node_Str""+ (month < 10 ? ""String_Node_Str"" + month : month)+ ""String_Node_Str""+ year);
  mPickableInstance.onPickerDismissed();
}",0.7735583684950773
109605,"public void onTimeSet(TimePicker view,int hour,int minute){
  Log.v(TAG,""String_Node_Str"" + hour + ""String_Node_Str""+ minute);
  mInputEditText.setText(""String_Node_Str"" + hour + ""String_Node_Str""+ minute);
  mPickableInstance.onPickerDismissed();
}","public void onTimeSet(TimePicker view,int hour,int minute){
  Log.v(TAG,""String_Node_Str"" + (hour < 10 ? ""String_Node_Str"" + hour : hour) + ""String_Node_Str""+ (minute < 10 ? ""String_Node_Str"" + minute : minute));
  mInputEditText.setText(""String_Node_Str"" + (hour < 10 ? ""String_Node_Str"" + hour : hour) + ""String_Node_Str""+ (minute < 10 ? ""String_Node_Str"" + minute : minute));
  mPickableInstance.onPickerDismissed();
}",0.5522388059701493
109606,"@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.a_provider_credentials);
  providerAPIBroadcastReceiver=new ProviderAPIBroadcastReceiver();
  IntentFilter updateIntentFilter=new IntentFilter(BROADCAST_PROVIDER_API_EVENT);
  updateIntentFilter.addCategory(Intent.CATEGORY_DEFAULT);
  LocalBroadcastManager.getInstance(this).registerReceiver(providerAPIBroadcastReceiver,updateIntentFilter);
  setUpListeners();
  if (savedInstanceState != null) {
    restoreState(savedInstanceState);
  }
  String userMessageString=getIntent().getStringExtra(USER_MESSAGE);
  if (userMessageString != null) {
    userMessage.setText(userMessageString);
    userMessage.setVisibility(VISIBLE);
  }
}","@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.a_provider_credentials);
  providerAPIBroadcastReceiver=new ProviderAPIBroadcastReceiver();
  IntentFilter updateIntentFilter=new IntentFilter(BROADCAST_PROVIDER_API_EVENT);
  updateIntentFilter.addCategory(Intent.CATEGORY_DEFAULT);
  LocalBroadcastManager.getInstance(this).registerReceiver(providerAPIBroadcastReceiver,updateIntentFilter);
  setUpListeners();
  restoreState(savedInstanceState);
  String userMessageString=getIntent().getStringExtra(USER_MESSAGE);
  if (userMessageString != null) {
    userMessage.setText(userMessageString);
    userMessage.setVisibility(VISIBLE);
  }
}",0.8088235294117647
109607,"private void restoreState(Bundle savedInstance){
  if (savedInstance.getString(USER_MESSAGE) != null) {
    userMessage.setText(savedInstance.getString(USER_MESSAGE));
    userMessage.setVisibility(VISIBLE);
  }
  usernameError.setError(savedInstance.getString(USERNAME_ERROR));
  passwordError.setError(savedInstance.getString(PASSWORD_ERROR));
  passwordVerificationError.setError(savedInstance.getString(PASSWORD_VERIFICATION_ERROR));
  if (savedInstance.getString(ACTIVITY_STATE) != null) {
    mConfigState.setAction(savedInstance.getString(ACTIVITY_STATE));
  }
}","protected void restoreState(Bundle savedInstance){
  super.restoreState(savedInstance);
  if (savedInstance == null) {
    return;
  }
  if (savedInstance.getString(USER_MESSAGE) != null) {
    userMessage.setText(savedInstance.getString(USER_MESSAGE));
    userMessage.setVisibility(VISIBLE);
  }
  usernameError.setError(savedInstance.getString(USERNAME_ERROR));
  passwordError.setError(savedInstance.getString(PASSWORD_ERROR));
  passwordVerificationError.setError(savedInstance.getString(PASSWORD_VERIFICATION_ERROR));
  if (savedInstance.getString(ACTIVITY_STATE) != null) {
    mConfigState.setAction(savedInstance.getString(ACTIVITY_STATE));
  }
}",0.9215686274509804
109608,"private void restoreState(Bundle savedInstanceState){
  provider=savedInstanceState.getParcelable(Provider.KEY);
  mConfigState.setAction(savedInstanceState.getString(ACTIVITY_STATE,PROVIDER_NOT_SET));
  reasonToFail=savedInstanceState.getString(REASON_TO_FAIL);
  if (reasonToFail != null) {
    showDownloadFailedDialog();
  }
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction()) || PENDING_SHOW_FAILED_DIALOG.equals(mConfigState.getAction())) {
    showProgressBar();
  }
}","protected void restoreState(Bundle savedInstanceState){
  super.restoreState(savedInstanceState);
  if (savedInstanceState == null) {
    return;
  }
  mConfigState.setAction(savedInstanceState.getString(ACTIVITY_STATE,PROVIDER_NOT_SET));
  if (savedInstanceState.containsKey(REASON_TO_FAIL)) {
    reasonToFail=savedInstanceState.getString(REASON_TO_FAIL);
  }
}",0.5017751479289941
109609,"/** 
 * Shows an error dialog, if configuring of a provider failed.
 */
public void showDownloadFailedDialog(){
  try {
    FragmentTransaction fragmentTransaction=fragmentManager.removePreviousFragment(ProviderSetupFailedDialog.TAG);
    DialogFragment newFragment;
    try {
      JSONObject errorJson=new JSONObject(reasonToFail);
      newFragment=ProviderSetupFailedDialog.newInstance(provider,errorJson);
    }
 catch (    JSONException e) {
      e.printStackTrace();
      newFragment=ProviderSetupFailedDialog.newInstance(provider,reasonToFail);
    }
    newFragment.show(fragmentTransaction,ProviderSetupFailedDialog.TAG);
  }
 catch (  IllegalStateException e) {
    e.printStackTrace();
    mConfigState.setAction(PENDING_SHOW_FAILED_DIALOG);
    mConfigState.putExtra(REASON_TO_FAIL,reasonToFail);
  }
}","/** 
 * Shows an error dialog, if configuring of a provider failed.
 */
public void showDownloadFailedDialog(){
  try {
    mConfigState.setAction(SHOW_FAILED_DIALOG);
    FragmentTransaction fragmentTransaction=fragmentManager.removePreviousFragment(ProviderSetupFailedDialog.TAG);
    DialogFragment newFragment;
    try {
      JSONObject errorJson=new JSONObject(reasonToFail);
      newFragment=ProviderSetupFailedDialog.newInstance(provider,errorJson);
    }
 catch (    JSONException e) {
      e.printStackTrace();
      newFragment=ProviderSetupFailedDialog.newInstance(provider,reasonToFail);
    }
catch (    NullPointerException e) {
      return;
    }
    newFragment.show(fragmentTransaction,ProviderSetupFailedDialog.TAG);
  }
 catch (  IllegalStateException e) {
    e.printStackTrace();
    mConfigState.setAction(PENDING_SHOW_FAILED_DIALOG);
  }
}",0.9043374925727868
109610,"@Override public void onBackPressed(){
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction()) || PENDING_SHOW_FAILED_DIALOG.equals(mConfigState.getAction())) {
    stopSettingUpProvider();
  }
 else {
    askDashboardToQuitApp();
    super.onBackPressed();
  }
}","@Override public void onBackPressed(){
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction()) || SHOW_FAILED_DIALOG.equals(mConfigState.getAction())) {
    stopSettingUpProvider();
  }
 else {
    super.onBackPressed();
  }
}",0.8525252525252526
109611,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  fragmentManager=new FragmentManagerEnhanced(getSupportFragmentManager());
  providerManager=ProviderManager.getInstance(getAssets(),getExternalFilesDir(null));
  setUpInitialUI();
  initProviderList();
  if (savedInstanceState != null)   restoreState(savedInstanceState);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  fragmentManager=new FragmentManagerEnhanced(getSupportFragmentManager());
  providerManager=ProviderManager.getInstance(getAssets(),getExternalFilesDir(null));
  setUpInitialUI();
  initProviderList();
  restoreState(savedInstanceState);
}",0.952513966480447
109612,"@Override public void cancelSettingUpProvider(){
  mConfigState.setAction(PROVIDER_NOT_SET);
  hideProgressBar();
}","@Override public void cancelSettingUpProvider(){
  mConfigState.setAction(PROVIDER_NOT_SET);
  provider=null;
  hideProgressBar();
}",0.931174089068826
109613,"@Override public void updateProviderDetails(){
  ProviderAPICommand.execute(this,UPDATE_PROVIDER_DETAILS,provider);
}","@Override public void updateProviderDetails(){
  mConfigState.setAction(SETTING_UP_PROVIDER);
  ProviderAPICommand.execute(this,UPDATE_PROVIDER_DETAILS,provider);
}",0.8327402135231317
109614,"@Override protected void onResume(){
  Log.d(TAG,""String_Node_Str"" + mConfigState.getAction());
  super.onResume();
  setUpProviderAPIResultReceiver();
  hideProgressBar();
  isActivityShowing=true;
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction())) {
    showProgressBar();
    checkProviderSetUp();
  }
 else   if (PENDING_SHOW_FAILED_DIALOG.equals(mConfigState.getAction())) {
    showDownloadFailedDialog();
  }
 else   if (SHOWING_PROVIDER_DETAILS.equals(mConfigState.getAction())) {
    cancelAndShowAllProviders();
  }
}","@Override protected void onResume(){
  Log.d(TAG,""String_Node_Str"" + mConfigState.getAction());
  super.onResume();
  setUpProviderAPIResultReceiver();
  isActivityShowing=true;
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction())) {
    showProgressBar();
    checkProviderSetUp();
  }
 else   if (PENDING_SHOW_FAILED_DIALOG.equals(mConfigState.getAction())) {
    showProgressBar();
    showDownloadFailedDialog();
  }
 else   if (SHOW_FAILED_DIALOG.equals(mConfigState.getAction())) {
    showProgressBar();
  }
 else   if (SHOWING_PROVIDER_DETAILS.equals(mConfigState.getAction())) {
    cancelSettingUpProvider();
  }
}",0.8627787307032591
109615,"@OnItemClick(R.id.provider_list) void onItemSelected(int position){
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction()) || PENDING_SHOW_FAILED_DIALOG.equals(mConfigState.getAction())) {
    return;
  }
  provider=adapter.getItem(position);
  if (provider != null && !provider.isDefault()) {
    mConfigState.setAction(SETTING_UP_PROVIDER);
    showProgressBar();
    onItemSelectedLogic();
  }
 else {
    addAndSelectNewProvider();
  }
}","@OnItemClick(R.id.provider_list) void onItemSelected(int position){
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction()) || SHOW_FAILED_DIALOG.equals(mConfigState.getAction())) {
    return;
  }
  provider=adapter.getItem(position);
  if (provider != null && !provider.isDefault()) {
    mConfigState.setAction(SETTING_UP_PROVIDER);
    showProgressBar();
    onItemSelectedLogic();
  }
 else {
    addAndSelectNewProvider();
  }
}",0.9909297052154196
109616,"@Override protected void onSaveInstanceState(@NotNull Bundle outState){
  outState.putString(ACTIVITY_STATE,mConfigState.getAction());
  outState.putParcelable(PROVIDER_KEY,provider);
  DialogFragment dialogFragment=(DialogFragment)fragmentManager.findFragmentByTag(ProviderSetupFailedDialog.TAG);
  if (dialogFragment != null) {
    outState.putString(REASON_TO_FAIL,reasonToFail);
    dialogFragment.dismiss();
  }
  super.onSaveInstanceState(outState);
}","@Override public void onSaveInstanceState(@NotNull Bundle outState){
  outState.putString(ACTIVITY_STATE,mConfigState.getAction());
  outState.putString(REASON_TO_FAIL,reasonToFail);
  super.onSaveInstanceState(outState);
}",0.5411764705882353
109617,"@Override @NonNull public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setMessage(reasonToFail).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      interfaceWithConfigurationWizard.cancelSettingUpProvider();
      dialog.dismiss();
    }
  }
);
switch (downloadError) {
case ERROR_CORRUPTED_PROVIDER_JSON:
    builder.setPositiveButton(R.string.update_provider_details,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        dismiss();
        interfaceWithConfigurationWizard.updateProviderDetails();
      }
    }
);
  break;
case ERROR_CERTIFICATE_PINNING:
case ERROR_INVALID_CERTIFICATE:
builder.setPositiveButton(R.string.update_certificate,new DialogInterface.OnClickListener(){
  @Override public void onClick(  DialogInterface dialog,  int which){
    dismiss();
    interfaceWithConfigurationWizard.updateProviderDetails();
  }
}
);
break;
default :
builder.setPositiveButton(R.string.retry,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int id){
dismiss();
interfaceWithConfigurationWizard.retrySetUpProvider(provider);
}
}
);
break;
}
return builder.create();
}","@Override @NonNull public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setMessage(reasonToFail).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      interfaceWithConfigurationWizard.cancelSettingUpProvider();
    }
  }
);
switch (downloadError) {
case ERROR_CORRUPTED_PROVIDER_JSON:
    builder.setPositiveButton(R.string.update_provider_details,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        interfaceWithConfigurationWizard.updateProviderDetails();
      }
    }
);
  break;
case ERROR_CERTIFICATE_PINNING:
case ERROR_INVALID_CERTIFICATE:
builder.setPositiveButton(R.string.update_certificate,new DialogInterface.OnClickListener(){
  @Override public void onClick(  DialogInterface dialog,  int which){
    interfaceWithConfigurationWizard.updateProviderDetails();
  }
}
);
break;
default :
builder.setPositiveButton(R.string.retry,new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int id){
interfaceWithConfigurationWizard.retrySetUpProvider(provider);
}
}
);
break;
}
return builder.create();
}",0.9739130434782608
109618,"public void onClick(DialogInterface dialog,int id){
  dismiss();
  interfaceWithConfigurationWizard.retrySetUpProvider(provider);
}","public void onClick(DialogInterface dialog,int id){
  interfaceWithConfigurationWizard.retrySetUpProvider(provider);
}",0.9477911646586346
109619,"@Override public void retrySetUpProvider(@NonNull Provider provider){
  ProviderAPICommand.execute(this,SET_UP_PROVIDER,provider);
}","@Override public void retrySetUpProvider(@NonNull Provider provider){
  mConfigState.setAction(SETTING_UP_PROVIDER);
  ProviderAPICommand.execute(this,SET_UP_PROVIDER,provider);
}",0.8488745980707395
109620,"/** 
 * Fragment managing the behaviors, interactions and presentation of the navigation drawer.
 */
@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  setSupportActionBar((Toolbar)findViewById(R.id.toolbar));
  mainActivityBroadcastReceiver=new MainActivityBroadcastReceiver();
  setUpBroadcastReceiver();
  navigationDrawerFragment=(NavigationDrawerFragment)getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
  preferences=getSharedPreferences(SHARED_PREFERENCES,MODE_PRIVATE);
  provider=ConfigHelper.getSavedProviderFromSharedPreferences(preferences);
  navigationDrawerFragment.setUp(R.id.navigation_drawer,(DrawerLayout)findViewById(R.id.drawer_layout));
  eipStatus=EipStatus.getInstance();
  handleIntentAction(getIntent());
  if (savedInstanceState != null) {
    restoreState(savedInstanceState);
  }
}","/** 
 * Fragment managing the behaviors, interactions and presentation of the navigation drawer.
 */
@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  setSupportActionBar((Toolbar)findViewById(R.id.toolbar));
  mainActivityBroadcastReceiver=new MainActivityBroadcastReceiver();
  setUpBroadcastReceiver();
  navigationDrawerFragment=(NavigationDrawerFragment)getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
  preferences=getSharedPreferences(SHARED_PREFERENCES,MODE_PRIVATE);
  provider=ConfigHelper.getSavedProviderFromSharedPreferences(preferences);
  navigationDrawerFragment.setUp(R.id.navigation_drawer,(DrawerLayout)findViewById(R.id.drawer_layout));
  eipStatus=EipStatus.getInstance();
}",0.9348703170028818
109621,"@Override protected void onResume(){
  super.onResume();
  bindOpenVpnService();
  String action=mConfigState.getAction();
  if (action.equalsIgnoreCase(SHOW_DIALOG_STATE)) {
    showDownloadFailedDialog(reasonToFail);
  }
}","@Override protected void onResume(){
  super.onResume();
  bindOpenVpnService();
}",0.5359477124183006
109622,"private void handleEIPEvent(int resultCode,Bundle resultData){
  String request=resultData.getString(EIP_REQUEST);
  if (request == null) {
    return;
  }
switch (request) {
case EIP_ACTION_START:
switch (resultCode) {
case RESULT_OK:
      break;
case RESULT_CANCELED:
    String error=resultData.getString(ERRORS);
  if (LeapSRPSession.loggedIn() || provider.allowsAnonymous()) {
    showDownloadFailedDialog(error);
  }
 else {
    askUserToLogIn(getString(vpn_certificate_user_message));
  }
break;
}
break;
case EIP_ACTION_STOP:
switch (resultCode) {
case RESULT_OK:
stop();
break;
case RESULT_CANCELED:
break;
}
break;
}
}","private void handleEIPEvent(int resultCode,Bundle resultData){
  String request=resultData.getString(EIP_REQUEST);
  if (request == null) {
    return;
  }
switch (request) {
case EIP_ACTION_START:
switch (resultCode) {
case RESULT_OK:
      break;
case RESULT_CANCELED:
    String error=resultData.getString(ERRORS);
  if (LeapSRPSession.loggedIn() || provider.allowsAnonymous()) {
    showMainActivityErrorDialog(error);
  }
 else {
    askUserToLogIn(getString(vpn_certificate_user_message));
  }
break;
}
break;
case EIP_ACTION_STOP:
switch (resultCode) {
case RESULT_OK:
stop();
break;
case RESULT_CANCELED:
break;
}
break;
}
}",0.9754163362410784
109623,"public void handleProviderApiEvent(int resultCode,Bundle resultData){
switch (resultCode) {
case CORRECTLY_DOWNLOADED_EIP_SERVICE:
    provider=resultData.getParcelable(PROVIDER_KEY);
  EipCommand.startVPN(this);
break;
case INCORRECTLY_DOWNLOADED_EIP_SERVICE:
break;
case CORRECTLY_DOWNLOADED_VPN_CERTIFICATE:
provider=resultData.getParcelable(PROVIDER_KEY);
ConfigHelper.storeProviderInPreferences(preferences,provider);
EipCommand.startVPN(this);
break;
case INCORRECTLY_DOWNLOADED_VPN_CERTIFICATE:
if (LeapSRPSession.loggedIn() || provider.allowsAnonymous()) {
showDownloadFailedDialog(getString(downloading_vpn_certificate_failed));
}
 else {
askUserToLogIn(getString(vpn_certificate_user_message));
}
break;
}
}","public void handleProviderApiEvent(int resultCode,Bundle resultData){
switch (resultCode) {
case CORRECTLY_DOWNLOADED_EIP_SERVICE:
    provider=resultData.getParcelable(PROVIDER_KEY);
  EipCommand.startVPN(this);
break;
case INCORRECTLY_DOWNLOADED_EIP_SERVICE:
break;
case CORRECTLY_DOWNLOADED_VPN_CERTIFICATE:
provider=resultData.getParcelable(PROVIDER_KEY);
ConfigHelper.storeProviderInPreferences(preferences,provider);
EipCommand.startVPN(this);
break;
case INCORRECTLY_DOWNLOADED_VPN_CERTIFICATE:
if (LeapSRPSession.loggedIn() || provider.allowsAnonymous()) {
showMainActivityErrorDialog(getString(downloading_vpn_certificate_failed));
}
 else {
askUserToLogIn(getString(vpn_certificate_user_message));
}
break;
}
}",0.9784272790535838
109624,"@Override @NonNull public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setMessage(reasonToFail).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.dismiss();
      callbackInterface.onDialogDismissed();
    }
  }
);
switch (downloadError) {
case ERROR_INVALID_VPN_CERTIFICATE:
    builder.setPositiveButton(R.string.update_certificate,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        dismiss();
        ProviderAPICommand.execute(getContext(),DOWNLOAD_VPN_CERTIFICATE,provider);
        callbackInterface.onDialogDismissed();
      }
    }
);
  break;
default :
builder.setPositiveButton(R.string.retry,new DialogInterface.OnClickListener(){
  public void onClick(  DialogInterface dialog,  int id){
    dismiss();
    callbackInterface.onDialogDismissed();
  }
}
);
break;
}
return builder.create();
}","@Override @NonNull public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  builder.setMessage(reasonToFail).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
    }
  }
);
switch (downloadError) {
case ERROR_INVALID_VPN_CERTIFICATE:
    builder.setPositiveButton(R.string.update_certificate,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        ProviderAPICommand.execute(getContext(),DOWNLOAD_VPN_CERTIFICATE,provider);
      }
    }
);
  break;
default :
break;
}
return builder.create();
}",0.810479375696767
109625,"public void onClick(DialogInterface dialog,int id){
  dismiss();
  callbackInterface.onDialogDismissed();
}","@Override public void onClick(DialogInterface dialog,int which){
  ProviderAPICommand.execute(getContext(),DOWNLOAD_VPN_CERTIFICATE,provider);
}",0.5179282868525896
109626,"@Override public void setContentView(View view,ViewGroup.LayoutParams params){
  super.setContentView(view,params);
  if (provider != null)   setProviderHeaderText(provider.getName());
}","@Override public void setContentView(View view,ViewGroup.LayoutParams params){
  super.setContentView(view,params);
  if (provider != null)   setProviderHeaderText(provider.getName());
  setProgressbarColorForPreLollipop();
}",0.9051094890510948
109627,"/** 
 * Downloads a new OpenVPN certificate, attaching authenticated cookie for authenticated certificate.
 * @return true if certificate was downloaded correctly, false if provider.json is not present in SharedPreferences, or if the certificate url could not be parsed as a URI, or if there was an SSL error.
 */
@Override protected boolean updateVpnCertificate(Provider provider){
  try {
    JSONObject providerJson=provider.getDefinition();
    String providerMainUrl=providerJson.getString(Provider.API_URL);
    URL newCertStringUrl=new URL(providerMainUrl + ""String_Node_Str"" + providerJson.getString(Provider.API_VERSION)+ ""String_Node_Str""+ PROVIDER_VPN_CERTIFICATE);
    String certString=downloadWithProviderCA(provider.getCaCert(),newCertStringUrl.toString());
    if (ConfigHelper.checkErroneousDownload(certString))     return false;
 else     return loadCertificate(certString);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
}","/** 
 * Downloads a new OpenVPN certificate, attaching authenticated cookie for authenticated certificate.
 * @return true if certificate was downloaded correctly, false if provider.json is not present in SharedPreferences, or if the certificate url could not be parsed as a URI, or if there was an SSL error.
 */
@Override protected boolean updateVpnCertificate(Provider provider){
  try {
    JSONObject providerJson=provider.getDefinition();
    String providerMainUrl=providerJson.getString(Provider.API_URL);
    URL newCertStringUrl=new URL(providerMainUrl + ""String_Node_Str"" + providerJson.getString(Provider.API_VERSION)+ ""String_Node_Str""+ PROVIDER_VPN_CERTIFICATE);
    String certString=downloadWithProviderCA(provider.getCaCert(),newCertStringUrl.toString());
    if (ConfigHelper.checkErroneousDownload(certString))     return false;
 else     return loadCertificate(provider,certString);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
}",0.9957244655581948
109628,"/** 
 * Retrys setup of last used provider, allows bypassing ca certificate validation.
 */
@Override public void retrySetUpProvider(){
  cancelSettingUpProvider();
  if (!ProviderAPI.caCertDownloaded()) {
    addAndSelectNewProvider(ProviderAPI.lastProviderMainUrl(),ProviderAPI.lastDangerOn());
  }
 else {
    showProgressBar();
    adapter.hideAllBut(adapter.indexOf(selectedProvider));
    Intent provider_API_command=new Intent(this,ProviderAPI.class);
    provider_API_command.setAction(ProviderAPI.SET_UP_PROVIDER);
    provider_API_command.putExtra(ProviderAPI.RECEIVER_KEY,providerAPIResultReceiver);
    Bundle parameters=new Bundle();
    parameters.putString(Provider.MAIN_URL,selectedProvider.getMainUrl().toString());
    provider_API_command.putExtra(ProviderAPI.PARAMETERS,parameters);
    startService(provider_API_command);
  }
}","/** 
 * Retrys setup of last used provider, allows bypassing ca certificate validation.
 */
@Override public void retrySetUpProvider(){
  cancelSettingUpProvider();
  if (!ProviderAPI.caCertDownloaded()) {
    addAndSelectNewProvider(ProviderAPI.lastProviderMainUrl(),ProviderAPI.lastDangerOn());
  }
 else {
    showProgressBar();
    adapter.hideAllBut(adapter.indexOf(selectedProvider));
    Intent providerAPICommand=new Intent(this,ProviderAPI.class);
    providerAPICommand.setAction(ProviderAPI.SET_UP_PROVIDER);
    Bundle parameters=new Bundle();
    parameters.putString(Provider.MAIN_URL,selectedProvider.getMainUrl().toString());
    providerAPICommand.putExtra(ProviderAPI.PARAMETERS,parameters);
    startService(providerAPICommand);
  }
}",0.9206745783885072
109629,"/** 
 * Asks ProviderAPI to download a new provider.json file
 * @param danger_on tells if HTTPS client should bypass certificate errors
 */
public void setUpProvider(boolean danger_on){
  mConfigState.setAction(SETTING_UP_PROVIDER);
  Intent provider_API_command=new Intent(this,ProviderAPI.class);
  Bundle parameters=new Bundle();
  parameters.putString(Provider.MAIN_URL,selectedProvider.getMainUrl().toString());
  parameters.putBoolean(ProviderItem.DANGER_ON,danger_on);
  if (selectedProvider.hasCertificatePin()) {
    parameters.putString(Provider.CA_CERT_FINGERPRINT,selectedProvider.certificatePin());
  }
  if (selectedProvider.hasCaCert()) {
    parameters.putString(Provider.CA_CERT,selectedProvider.getCaCert());
  }
  if (selectedProvider.hasDefinition()) {
    parameters.putString(Provider.KEY,selectedProvider.getDefinition().toString());
  }
  provider_API_command.setAction(ProviderAPI.SET_UP_PROVIDER);
  provider_API_command.putExtra(ProviderAPI.PARAMETERS,parameters);
  provider_API_command.putExtra(ProviderAPI.RECEIVER_KEY,providerAPIResultReceiver);
  startService(provider_API_command);
}","/** 
 * Asks ProviderAPI to download a new provider.json file
 * @param danger_on tells if HTTPS client should bypass certificate errors
 */
public void setUpProvider(boolean danger_on){
  mConfigState.setAction(SETTING_UP_PROVIDER);
  Intent provider_API_command=new Intent(this,ProviderAPI.class);
  Bundle parameters=new Bundle();
  parameters.putString(Provider.MAIN_URL,selectedProvider.getMainUrl().toString());
  parameters.putBoolean(ProviderItem.DANGER_ON,danger_on);
  if (selectedProvider.hasCertificatePin()) {
    parameters.putString(Provider.CA_CERT_FINGERPRINT,selectedProvider.certificatePin());
  }
  if (selectedProvider.hasCaCert()) {
    parameters.putString(Provider.CA_CERT,selectedProvider.getCaCert());
  }
  if (selectedProvider.hasDefinition()) {
    parameters.putString(Provider.KEY,selectedProvider.getDefinition().toString());
  }
  provider_API_command.setAction(ProviderAPI.SET_UP_PROVIDER);
  provider_API_command.putExtra(ProviderAPI.PARAMETERS,parameters);
  startService(provider_API_command);
}",0.9297347603536528
109630,"private void switchProvider(){
  if (provider.hasEIP())   eip_fragment.stopEipIfPossible();
  Map<String,?> allEntries=preferences.getAll();
  List<String> lastProvidersKeys=new ArrayList<>();
  for (  Map.Entry<String,?> entry : allEntries.entrySet()) {
    if (entry.getKey().startsWith(Provider.KEY + ""String_Node_Str"") || entry.getKey().startsWith(Provider.CA_CERT + ""String_Node_Str"") || entry.getKey().startsWith(Provider.CA_CERT_FINGERPRINT + ""String_Node_Str"")) {
      continue;
    }
    lastProvidersKeys.add(entry.getKey());
  }
  SharedPreferences.Editor preferenceEditor=preferences.edit();
  for (  String key : lastProvidersKeys) {
    preferenceEditor.remove(key);
  }
  preferenceEditor.apply();
  switching_provider=false;
  startActivityForResult(new Intent(this,ConfigurationWizard.class),SWITCH_PROVIDER);
}","private void switchProvider(){
  if (provider.hasEIP())   eip_fragment.stopEipIfPossible();
  clearDataOfLastProvider();
  switching_provider=false;
  startActivityForResult(new Intent(this,ConfigurationWizard.class),SWITCH_PROVIDER);
}",0.4018779342723004
109631,"@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  preferences=getSharedPreferences(Constants.SHARED_PREFERENCES,MODE_PRIVATE);
  Log.d(TAG,""String_Node_Str"");
switch (checkAppStart()) {
case NORMAL:
    break;
case FIRST:
  break;
case UPGRADE:
executeUpgrade();
break;
case DOWNGRADE:
break;
}
ProviderAPICommand.initialize(getApplicationContext());
VpnStatus.initLogCache(getApplicationContext().getCacheDir());
User.init(getString(R.string.default_username));
Intent intent=new Intent(this,Dashboard.class);
startActivity(intent);
}","@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  preferences=getSharedPreferences(Constants.SHARED_PREFERENCES,MODE_PRIVATE);
  Log.d(TAG,""String_Node_Str"");
switch (checkAppStart()) {
case NORMAL:
    break;
case FIRST:
  storeAppVersion();
break;
case UPGRADE:
executeUpgrade();
break;
case DOWNGRADE:
break;
}
ProviderAPICommand.initialize(getApplicationContext());
VpnStatus.initLogCache(getApplicationContext().getCacheDir());
User.init(getString(R.string.default_username));
Intent intent=new Intent(this,Dashboard.class);
startActivity(intent);
}",0.9843363561417972
109632,"/** 
 * execute necessary upgrades for version change
 */
private void executeUpgrade(){
  if (hasNewFeature(FeatureVersionCode.MULTIPLE_PROFILES)) {
  }
  preferences.edit().putInt(Constants.PREFERENCES_APP_VERSION,versionCode).apply();
}","/** 
 * execute necessary upgrades for version change
 */
private void executeUpgrade(){
  if (hasNewFeature(FeatureVersionCode.MULTIPLE_PROFILES)) {
  }
  storeAppVersion();
}",0.8240963855421687
109633,"public TestEIP(Class<EIP> activityClass){
  super(activityClass);
  context=getSystemContext();
  intent=new Intent(context,EIP.class);
  preferences=context.getSharedPreferences(Dashboard.SHARED_PREFERENCES,Context.MODE_PRIVATE);
}","public TestEIP(Class<EIP> activityClass){
  super(activityClass);
  context=getSystemContext();
  intent=new Intent(context,EIP.class);
  preferences=context.getSharedPreferences(Constants.SHARED_PREFERENCES,Context.MODE_PRIVATE);
}",0.961206896551724
109634,"@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  preferences=getSharedPreferences(Constants.SHARED_PREFERENCES,MODE_PRIVATE);
  Log.d(TAG,""String_Node_Str"");
switch (checkAppStart()) {
case NORMAL:
    break;
case FIRST:
  break;
case UPGRADE:
executeUpgrade();
break;
case DOWNGRADE:
break;
}
ProviderAPICommand.initialize(this);
VpnStatus.initLogCache(getApplicationContext().getCacheDir());
User.init(getString(R.string.default_username));
Intent intent=new Intent(this,Dashboard.class);
startActivity(intent);
}","@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  preferences=getSharedPreferences(Constants.SHARED_PREFERENCES,MODE_PRIVATE);
  Log.d(TAG,""String_Node_Str"");
switch (checkAppStart()) {
case NORMAL:
    break;
case FIRST:
  break;
case UPGRADE:
executeUpgrade();
break;
case DOWNGRADE:
break;
}
ProviderAPICommand.initialize(getApplicationContext());
VpnStatus.initLogCache(getApplicationContext().getCacheDir());
User.init(getString(R.string.default_username));
Intent intent=new Intent(this,Dashboard.class);
startActivity(intent);
}",0.9770212765957448
109635,"@Override public void onReceive(Context context,Intent intent){
  preferences=context.getSharedPreferences(Dashboard.SHARED_PREFERENCES,Context.MODE_PRIVATE);
  boolean providerConfigured=!preferences.getString(VPN_CERTIFICATE,""String_Node_Str"").isEmpty();
  boolean startOnBoot=preferences.getBoolean(RESTART_ON_BOOT,false);
  boolean isAlwaysOnConfigured=preferences.getBoolean(IS_ALWAYS_ON,false);
  Log.d(""String_Node_Str"",""String_Node_Str"" + providerConfigured + ""String_Node_Str""+ startOnBoot+ ""String_Node_Str""+ isAlwaysOnConfigured);
  if (providerConfigured) {
    if (isAlwaysOnConfigured) {
      return;
    }
    if (startOnBoot) {
      Intent dashboard_intent=new Intent(context,Dashboard.class);
      dashboard_intent.putExtra(RESTART_ON_BOOT,true);
      dashboard_intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      context.startActivity(dashboard_intent);
    }
  }
 else {
    if (isAlwaysOnConfigured) {
      Intent dashboard_intent=new Intent(context,Dashboard.class);
      dashboard_intent.putExtra(Dashboard.ACTION_CONFIGURE_ALWAYS_ON_PROFILE,true);
      dashboard_intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      context.startActivity(dashboard_intent);
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  if (intent == null || !ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
    return;
  }
  preferences=context.getSharedPreferences(Dashboard.SHARED_PREFERENCES,Context.MODE_PRIVATE);
  boolean providerConfigured=!preferences.getString(VPN_CERTIFICATE,""String_Node_Str"").isEmpty();
  boolean startOnBoot=preferences.getBoolean(RESTART_ON_BOOT,false);
  boolean isAlwaysOnConfigured=preferences.getBoolean(IS_ALWAYS_ON,false);
  Log.d(""String_Node_Str"",""String_Node_Str"" + providerConfigured + ""String_Node_Str""+ startOnBoot+ ""String_Node_Str""+ isAlwaysOnConfigured);
  if (providerConfigured) {
    if (isAlwaysOnConfigured) {
      return;
    }
    if (startOnBoot) {
      Intent dashboard_intent=new Intent(context,Dashboard.class);
      dashboard_intent.putExtra(RESTART_ON_BOOT,true);
      dashboard_intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      context.startActivity(dashboard_intent);
    }
  }
 else {
    if (isAlwaysOnConfigured) {
      Intent dashboard_intent=new Intent(context,Dashboard.class);
      dashboard_intent.putExtra(Dashboard.ACTION_CONFIGURE_ALWAYS_ON_PROFILE,true);
      dashboard_intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      context.startActivity(dashboard_intent);
    }
  }
}",0.9627254509018036
109636,"private void onItemSelectedUi(){
  startProgressBar();
  adapter.hideAllBut(adapter.indexOf(selected_provider));
}","private void onItemSelectedUi(){
  adapter.hideAllBut(adapter.indexOf(selected_provider));
  startProgressBar();
}",0.8070175438596491
109637,"private void restoreState(Bundle savedInstanceState){
  progressbar_text=savedInstanceState.getString(PROGRESSBAR_TEXT,""String_Node_Str"");
  provider_name=savedInstanceState.getString(Provider.NAME,""String_Node_Str"");
  selected_provider=savedInstanceState.getParcelable(Provider.KEY);
  progress=savedInstanceState.getInt(PROGRESSBAR_NUMBER,-1);
  if (fragment_manager.findFragmentByTag(ProviderDetailFragment.TAG) == null && setting_up_provider) {
    onItemSelectedUi();
    if (progress > 0)     mProgressBar.setProgress(progress);
  }
}","private void restoreState(Bundle savedInstanceState){
  progressbar_text=savedInstanceState.getString(PROGRESSBAR_TEXT,""String_Node_Str"");
  selected_provider=savedInstanceState.getParcelable(Provider.KEY);
  if (fragment_manager.findFragmentByTag(ProviderDetailFragment.TAG) == null && SETTING_UP_PROVIDER.equals(mConfigState.getAction())) {
    onItemSelectedUi();
  }
}",0.683461117196057
109638,"/** 
 * Asks ProviderAPI to download a new provider.json file
 * @param danger_on         tells if HTTPS client should bypass certificate errors
 */
public void setUpProvider(boolean danger_on){
  Intent provider_API_command=new Intent(this,ProviderAPI.class);
  Bundle parameters=new Bundle();
  parameters.putString(Provider.MAIN_URL,selected_provider.mainUrl().getUrl().toString());
  parameters.putBoolean(ProviderItem.DANGER_ON,danger_on);
  parameters.putString(Provider.CA_CERT_FINGERPRINT,selected_provider.certificatePin());
  provider_API_command.setAction(ProviderAPI.SET_UP_PROVIDER);
  provider_API_command.putExtra(ProviderAPI.PARAMETERS,parameters);
  provider_API_command.putExtra(ProviderAPI.RECEIVER_KEY,providerAPI_result_receiver);
  startService(provider_API_command);
  setting_up_provider=true;
}","/** 
 * Asks ProviderAPI to download a new provider.json file
 * @param danger_on         tells if HTTPS client should bypass certificate errors
 */
public void setUpProvider(boolean danger_on){
  mConfigState.setAction(SETTING_UP_PROVIDER);
  Intent provider_API_command=new Intent(this,ProviderAPI.class);
  Bundle parameters=new Bundle();
  parameters.putString(Provider.MAIN_URL,selected_provider.mainUrl().getUrl().toString());
  parameters.putBoolean(ProviderItem.DANGER_ON,danger_on);
  parameters.putString(Provider.CA_CERT_FINGERPRINT,selected_provider.certificatePin());
  provider_API_command.setAction(ProviderAPI.SET_UP_PROVIDER);
  provider_API_command.putExtra(ProviderAPI.PARAMETERS,parameters);
  provider_API_command.putExtra(ProviderAPI.RECEIVER_KEY,providerAPI_result_receiver);
  startService(provider_API_command);
}",0.9547374773687388
109639,"private void stopSettingUpProvider(){
  ProviderAPI.stop();
  mProgressBar.setVisibility(ProgressBar.GONE);
  mProgressBar.setProgress(0);
  progressbar_description.setVisibility(TextView.GONE);
  cancelSettingUpProvider();
}","private void stopSettingUpProvider(){
  ProviderAPI.stop();
  mProgressBar.setVisibility(GONE);
  mProgressBar.setProgress(0);
  progressbar_description.setVisibility(GONE);
  cancelSettingUpProvider();
}",0.951048951048951
109640,"private void startProgressBar(){
  mProgressBar.setVisibility(ProgressBar.VISIBLE);
  progressbar_description.setVisibility(TextView.VISIBLE);
  mProgressBar.setProgress(0);
  mProgressBar.setMax(3);
  int measured_height=listItemHeight();
  mProgressBar.setTranslationY(measured_height);
  progressbar_description.setTranslationY(measured_height + mProgressBar.getHeight());
}","private void startProgressBar(){
  showProgressBar();
  mProgressBar.setProgress(0);
  mProgressBar.setMax(3);
  int measured_height=listItemHeight();
  mProgressBar.setTranslationY(measured_height);
  progressbar_description.setTranslationY(measured_height + mProgressBar.getHeight());
}",0.8210526315789474
109641,"/** 
 * Once selected a provider, this fragment offers the user to log in, use it anonymously (if possible) or cancel his/her election pressing the back button.
 */
private void showProviderDetails(){
  if (setting_up_provider) {
    FragmentTransaction fragment_transaction=fragment_manager.removePreviousFragment(ProviderDetailFragment.TAG);
    DialogFragment newFragment=ProviderDetailFragment.newInstance();
    newFragment.show(fragment_transaction,ProviderDetailFragment.TAG);
    setting_up_provider=false;
  }
}","/** 
 * Once selected a provider, this fragment offers the user to log in, use it anonymously (if possible) or cancel his/her election pressing the back button.
 */
private void showProviderDetails(){
  mConfigState.setAction(SETTING_UP_PROVIDER_SHOW_PROVIDER_DETILS);
  try {
    FragmentTransaction fragment_transaction=fragment_manager.removePreviousFragment(ProviderDetailFragment.TAG);
    DialogFragment newFragment=ProviderDetailFragment.newInstance();
    newFragment.show(fragment_transaction,ProviderDetailFragment.TAG);
  }
 catch (  IllegalStateException e) {
    e.printStackTrace();
  }
}",0.8413547237076648
109642,"@Override public void onReceiveResult(int resultCode,Bundle resultData){
  if (resultCode == ProviderAPI.PROVIDER_OK) {
    mConfigState.setAction(PROVIDER_SET);
    try {
      String provider_json_string=preferences.getString(Provider.KEY,""String_Node_Str"");
      if (!provider_json_string.isEmpty())       selected_provider.define(new JSONObject(provider_json_string));
    }
 catch (    JSONException e) {
      e.printStackTrace();
    }
    if (preferences.getBoolean(Constants.ALLOWED_ANON,false)) {
      mConfigState.putExtra(SERVICES_RETRIEVED,true);
      downloadVpnCertificate();
    }
 else {
      mProgressBar.incrementProgressBy(1);
      hideProgressBar();
      showProviderDetails();
    }
  }
 else   if (resultCode == ProviderAPI.PROVIDER_NOK) {
    hideProgressBar();
    preferences.edit().remove(Provider.KEY).apply();
    setting_up_provider=false;
    String reason_to_fail=resultData.getString(ProviderAPI.ERRORS);
    showDownloadFailedDialog(reason_to_fail);
  }
 else   if (resultCode == ProviderAPI.CORRECTLY_DOWNLOADED_CERTIFICATE) {
    mProgressBar.incrementProgressBy(1);
    hideProgressBar();
    showProviderDetails();
  }
 else   if (resultCode == ProviderAPI.INCORRECTLY_DOWNLOADED_CERTIFICATE) {
    hideProgressBar();
    cancelSettingUpProvider();
    Toast.makeText(getApplicationContext(),R.string.provider_problem,Toast.LENGTH_LONG).show();
  }
 else   if (resultCode == AboutActivity.VIEWED) {
  }
}","@Override public void onReceiveResult(int resultCode,Bundle resultData){
  if (resultCode == ProviderAPI.PROVIDER_OK) {
    try {
      String provider_json_string=preferences.getString(Provider.KEY,""String_Node_Str"");
      if (!provider_json_string.isEmpty())       selected_provider.define(new JSONObject(provider_json_string));
    }
 catch (    JSONException e) {
      e.printStackTrace();
    }
    if (preferences.getBoolean(Constants.ALLOWED_ANON,false)) {
      mConfigState.putExtra(SERVICES_RETRIEVED,true);
      downloadVpnCertificate();
    }
 else {
      mProgressBar.incrementProgressBy(1);
      hideProgressBar();
      showProviderDetails();
    }
  }
 else   if (resultCode == ProviderAPI.PROVIDER_NOK) {
    mConfigState.setAction(PROVIDER_NOT_SET);
    hideProgressBar();
    preferences.edit().remove(Provider.KEY).apply();
    String reason_to_fail=resultData.getString(ProviderAPI.ERRORS);
    showDownloadFailedDialog(reason_to_fail);
  }
 else   if (resultCode == ProviderAPI.CORRECTLY_DOWNLOADED_CERTIFICATE) {
    mProgressBar.incrementProgressBy(1);
    hideProgressBar();
    showProviderDetails();
  }
 else   if (resultCode == ProviderAPI.INCORRECTLY_DOWNLOADED_CERTIFICATE) {
    mConfigState.setAction(PROVIDER_NOT_SET);
    hideProgressBar();
    setResult(RESULT_CANCELED,mConfigState);
    Toast.makeText(getApplicationContext(),R.string.provider_problem,Toast.LENGTH_LONG).show();
  }
 else   if (resultCode == AboutActivity.VIEWED) {
  }
}",0.9231819733697508
109643,"@Override public void login(){
  Intent ask_login=new Intent();
  ask_login.putExtra(SessionDialog.TAG,SessionDialog.TAG);
  ask_login.putExtra(Provider.KEY,selected_provider);
  setResult(RESULT_OK,ask_login);
  setting_up_provider=false;
  finish();
}","@Override public void login(){
  mConfigState.setAction(PROVIDER_SET);
  Intent ask_login=new Intent();
  ask_login.putExtra(SessionDialog.TAG,SessionDialog.TAG);
  ask_login.putExtra(Provider.KEY,selected_provider);
  setResult(RESULT_OK,ask_login);
  finish();
}",0.8665377176015474
109644,"@Override public void use_anonymously(){
  Intent pass_provider=new Intent();
  pass_provider.putExtra(Provider.KEY,selected_provider);
  setResult(RESULT_OK,pass_provider);
  setting_up_provider=false;
  finish();
}","@Override public void use_anonymously(){
  mConfigState.setAction(PROVIDER_SET);
  Intent pass_provider=new Intent();
  pass_provider.putExtra(Provider.KEY,selected_provider);
  setResult(RESULT_OK,pass_provider);
  finish();
}",0.8442437923250564
109645,"@Override public void onBackPressed(){
  if (setting_up_provider) {
    stopSettingUpProvider();
  }
 else {
    askDashboardToQuitApp();
    super.onBackPressed();
  }
}","@Override public void onBackPressed(){
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction())) {
    stopSettingUpProvider();
  }
 else {
    askDashboardToQuitApp();
    super.onBackPressed();
  }
}",0.8150134048257373
109646,"public void cancelSettingUpProvider(){
  adapter.showAllProviders();
  setting_up_provider=false;
  preferences.edit().remove(Provider.KEY).remove(ProviderItem.DANGER_ON).remove(Constants.ALLOWED_ANON).remove(Constants.KEY).commit();
}","public void cancelSettingUpProvider(){
  mConfigState.setAction(PROVIDER_NOT_SET);
  adapter.showAllProviders();
  preferences.edit().remove(Provider.KEY).remove(ProviderItem.DANGER_ON).remove(Constants.ALLOWED_ANON).remove(Constants.KEY).commit();
}",0.8494845360824742
109647,"@OnItemClick(R.id.provider_list) void onItemSelected(int position){
  selected_provider=adapter.getItem(position);
  onItemSelectedLogic();
  onItemSelectedUi();
}","@OnItemClick(R.id.provider_list) void onItemSelected(int position){
  if (SETTING_UP_PROVIDER.equals(mConfigState.getAction()) || SETTING_UP_PROVIDER_SHOW_PROVIDER_DETILS.equals(mConfigState.getAction())) {
    return;
  }
  mConfigState.setAction(SETTING_UP_PROVIDER);
  selected_provider=adapter.getItem(position);
  onItemSelectedLogic();
  onItemSelectedUi();
}",0.6174242424242424
109648,"private int listItemHeight(){
  View listItem=adapter.getView(0,null,provider_list_view);
  listItem.setLayoutParams(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT));
  WindowManager wm=(WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
  Display display=wm.getDefaultDisplay();
  int screenWidth=display.getWidth();
  int listViewWidth=screenWidth - 10 - 10;
  int widthSpec=View.MeasureSpec.makeMeasureSpec(listViewWidth,View.MeasureSpec.AT_MOST);
  listItem.measure(widthSpec,0);
  return listItem.getMeasuredHeight();
}","private int listItemHeight(){
  View listItem=adapter.getView(0,null,provider_list_view);
  listItem.setLayoutParams(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT));
  WindowManager wm=(WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
  Display display=wm.getDefaultDisplay();
  int screenWidth=display.getWidth();
  int listViewWidth=screenWidth - 10 - 10;
  int widthSpec=MeasureSpec.makeMeasureSpec(listViewWidth,MeasureSpec.AT_MOST);
  listItem.measure(widthSpec,0);
  return listItem.getMeasuredHeight();
}",0.9398373983739836
109649,"private void hideProgressBar(){
  mProgressBar.setVisibility(ProgressBar.INVISIBLE);
  progressbar_description.setVisibility(TextView.INVISIBLE);
}","private void hideProgressBar(){
  mProgressBar.setVisibility(INVISIBLE);
  progressbar_description.setVisibility(INVISIBLE);
}",0.9230769230769232
109650,"@Override public void onCancel(DialogInterface dialog){
  super.onCancel(dialog);
  SharedPreferences.Editor editor=getActivity().getSharedPreferences(Dashboard.SHARED_PREFERENCES,Activity.MODE_PRIVATE).edit();
  editor.remove(Provider.KEY).remove(ProviderItem.DANGER_ON).remove(Constants.ALLOWED_ANON).remove(Constants.KEY).commit();
  interface_with_configuration_wizard.showAllProviders();
}","@Override public void onCancel(DialogInterface dialog){
  super.onCancel(dialog);
  SharedPreferences.Editor editor=getActivity().getSharedPreferences(Dashboard.SHARED_PREFERENCES,Activity.MODE_PRIVATE).edit();
  editor.remove(Provider.KEY).remove(ProviderItem.DANGER_ON).remove(Constants.ALLOWED_ANON).remove(Constants.KEY).commit();
  interface_with_configuration_wizard.cancelAndShowAllProviders();
}",0.986198243412798
109651,"protected static RSAPrivateKey parseRsaKeyFromString(String RsaKeyString){
  RSAPrivateKey key=null;
  try {
    KeyFactory kf=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
    RsaKeyString=RsaKeyString.replaceFirst(""String_Node_Str"",""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str"");
    PKCS8EncodedKeySpec keySpec=new PKCS8EncodedKeySpec(Base64.decode(RsaKeyString,Base64.DEFAULT));
    key=(RSAPrivateKey)kf.generatePrivate(keySpec);
  }
 catch (  InvalidKeySpecException e) {
    e.printStackTrace();
    return null;
  }
catch (  NoSuchAlgorithmException e) {
    e.printStackTrace();
    return null;
  }
catch (  NoSuchProviderException e) {
    e.printStackTrace();
    return null;
  }
  return key;
}","protected static RSAPrivateKey parseRsaKeyFromString(String rsaKeyString){
  RSAPrivateKey key=null;
  try {
    KeyFactory kf=KeyFactory.getInstance(""String_Node_Str"",""String_Node_Str"");
    rsaKeyString=rsaKeyString.replaceFirst(""String_Node_Str"",""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str"");
    PKCS8EncodedKeySpec keySpec=new PKCS8EncodedKeySpec(Base64.decode(rsaKeyString,Base64.DEFAULT));
    key=(RSAPrivateKey)kf.generatePrivate(keySpec);
  }
 catch (  InvalidKeySpecException e) {
    e.printStackTrace();
    return null;
  }
catch (  NoSuchAlgorithmException e) {
    e.printStackTrace();
    return null;
  }
catch (  NoSuchProviderException e) {
    e.printStackTrace();
    return null;
  }
catch (  NullPointerException e) {
    e.printStackTrace();
    return null;
  }
  return key;
}",0.9255251432208784
109652,"protected boolean loadCertificate(String cert_string){
  try {
    String certificateString=null, keyString=null;
    String[] certAndKey=cert_string.split(""String_Node_Str"");
    for (int i=0; i < certAndKey.length - 1; i++) {
      if (certAndKey[i].contains(""String_Node_Str"")) {
        keyString=certAndKey[i++] + certAndKey[i];
      }
 else       if (certAndKey[i].contains(""String_Node_Str"")) {
        certificateString=certAndKey[i++] + certAndKey[i];
      }
    }
    RSAPrivateKey key=ConfigHelper.parseRsaKeyFromString(keyString);
    keyString=Base64.encodeToString(key.getEncoded(),Base64.DEFAULT);
    preferences.edit().putString(Constants.PRIVATE_KEY,""String_Node_Str"" + keyString + ""String_Node_Str"").commit();
    X509Certificate certificate=ConfigHelper.parseX509CertificateFromString(certificateString);
    certificateString=Base64.encodeToString(certificate.getEncoded(),Base64.DEFAULT);
    preferences.edit().putString(Constants.VPN_CERTIFICATE,""String_Node_Str"" + certificateString + ""String_Node_Str"").commit();
    return true;
  }
 catch (  CertificateException e) {
    e.printStackTrace();
    return false;
  }
}","protected boolean loadCertificate(String cert_string){
  if (cert_string == null) {
    return false;
  }
  try {
    String certificateString=null, keyString=null;
    String[] certAndKey=cert_string.split(""String_Node_Str"");
    for (int i=0; i < certAndKey.length - 1; i++) {
      if (certAndKey[i].contains(""String_Node_Str"")) {
        keyString=certAndKey[i++] + certAndKey[i];
      }
 else       if (certAndKey[i].contains(""String_Node_Str"")) {
        certificateString=certAndKey[i++] + certAndKey[i];
      }
    }
    RSAPrivateKey key=ConfigHelper.parseRsaKeyFromString(keyString);
    keyString=Base64.encodeToString(key.getEncoded(),Base64.DEFAULT);
    preferences.edit().putString(Constants.PRIVATE_KEY,""String_Node_Str"" + keyString + ""String_Node_Str"").commit();
    X509Certificate certificate=ConfigHelper.parseX509CertificateFromString(certificateString);
    certificateString=Base64.encodeToString(certificate.getEncoded(),Base64.DEFAULT);
    preferences.edit().putString(Constants.VPN_CERTIFICATE,""String_Node_Str"" + certificateString + ""String_Node_Str"").commit();
    return true;
  }
 catch (  CertificateException e) {
    e.printStackTrace();
    return false;
  }
}",0.9782330345710628
109653,"private void addProvider(String url){
  boolean is_new_provider=!solo.searchText(url);
  if (is_new_provider)   added_providers=added_providers + 1;
  solo.clickOnActionBarItem(R.id.new_provider);
  solo.enterText(0,url);
  if (BuildConfig.FLAVOR.equals(""String_Node_Str"")) {
    solo.clickOnCheckBox(0);
  }
  solo.clickOnText(solo.getString(R.string.save));
  waitForProviderDetails();
  solo.goBack();
}","private void addProvider(String url,boolean expectSuccess){
  solo.clickOnActionBarItem(R.id.new_provider);
  solo.enterText(0,url);
  if (BuildConfig.FLAVOR.equals(""String_Node_Str"")) {
    solo.clickOnCheckBox(0);
  }
  solo.clickOnText(solo.getString(R.string.save));
  if (expectSuccess) {
    waitForProviderDetails();
  }
 else {
    waitForNoValidProviderError();
  }
  solo.goBack();
}",0.7384230287859824
109654,"public void testAddNewProvider(){
  addProvider(""String_Node_Str"");
}","public void testAddNewProvider(){
  addProvider(""String_Node_Str"",true);
}",0.965034965034965
109655,"private int shownProviders(){
  return solo.getCurrentViews(ListView.class).get(0).getCount();
}","/** 
 * Tests should run independently from each other. We need a better approach to test the amount of providers added
 */
private int shownProviders(){
  return solo.getCurrentViews(ListView.class).get(0).getCount();
}",0.5886075949367089
109656,"private Bundle getAndSetProviderJson(String provider_main_url,boolean danger_on,String provider_ca_cert_fingerprint){
  Bundle result=new Bundle();
  if (go_ahead) {
    String provider_dot_json_string;
    if (provider_ca_cert_fingerprint.isEmpty())     provider_dot_json_string=downloadWithCommercialCA(provider_main_url + ""String_Node_Str"",danger_on);
 else     provider_dot_json_string=downloadWithCommercialCA(provider_main_url + ""String_Node_Str"",danger_on,provider_ca_cert_fingerprint);
    try {
      JSONObject provider_json=new JSONObject(provider_dot_json_string);
      provider_api_url=provider_json.getString(Provider.API_URL) + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION);
      String name=provider_json.getString(Provider.NAME);
      preferences.edit().putString(Provider.KEY,provider_json.toString()).commit();
      preferences.edit().putBoolean(Constants.ALLOWED_ANON,provider_json.getJSONObject(Provider.SERVICE).getBoolean(Constants.ALLOWED_ANON)).commit();
      preferences.edit().putBoolean(Constants.ALLOWED_REGISTERED,provider_json.getJSONObject(Provider.SERVICE).getBoolean(Constants.ALLOWED_REGISTERED)).commit();
      result.putBoolean(RESULT_KEY,true);
    }
 catch (    JSONException e) {
      String reason_to_fail=pickErrorMessage(provider_dot_json_string);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
  }
  return result;
}","private Bundle getAndSetProviderJson(String provider_main_url,boolean danger_on,String provider_ca_cert_fingerprint){
  Bundle result=new Bundle();
  if (go_ahead) {
    String provider_dot_json_string;
    if (provider_ca_cert_fingerprint.isEmpty())     provider_dot_json_string=downloadWithCommercialCA(provider_main_url + ""String_Node_Str"",danger_on);
 else     provider_dot_json_string=downloadWithCommercialCA(provider_main_url + ""String_Node_Str"",danger_on,provider_ca_cert_fingerprint);
    if (!isValidJson(provider_dot_json_string)) {
      result.putString(ERRORS,getString(malformed_url));
      result.putBoolean(RESULT_KEY,false);
      return result;
    }
    try {
      JSONObject provider_json=new JSONObject(provider_dot_json_string);
      provider_api_url=provider_json.getString(Provider.API_URL) + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION);
      String name=provider_json.getString(Provider.NAME);
      preferences.edit().putString(Provider.KEY,provider_json.toString()).commit();
      preferences.edit().putBoolean(Constants.ALLOWED_ANON,provider_json.getJSONObject(Provider.SERVICE).getBoolean(Constants.ALLOWED_ANON)).commit();
      preferences.edit().putBoolean(Constants.ALLOWED_REGISTERED,provider_json.getJSONObject(Provider.SERVICE).getBoolean(Constants.ALLOWED_REGISTERED)).commit();
      result.putBoolean(RESULT_KEY,true);
    }
 catch (    JSONException e) {
      String reason_to_fail=pickErrorMessage(provider_dot_json_string);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
  }
  return result;
}",0.9419481797310594
109657,"/** 
 * Tries to download the contents of the provided url using commercially validated CA certificate from chosen provider. <p/> If danger_on flag is true, SSL exceptions will be managed by futher methods that will try to use some bypass methods.
 * @param string_url
 * @param danger_on  if the user completely trusts this provider
 * @return
 */
private String downloadWithCommercialCA(String string_url,boolean danger_on){
  String responseString;
  JSONObject errorJson=new JSONObject();
  OkHttpClient okHttpClient=initCommercialCAHttpClient(errorJson);
  if (okHttpClient == null) {
    return errorJson.toString();
  }
  List<Pair<String,String>> headerArgs=getAuthorizationHeader();
  responseString=sendGetStringToServer(string_url,headerArgs,okHttpClient);
  if (responseString.contains(ERRORS)) {
    try {
      JSONObject responseErrorJson=new JSONObject(responseString);
      if (danger_on && responseErrorJson.getString(ERRORS).equals(getString(R.string.certificate_error))) {
        responseString=downloadWithProviderCA(string_url,danger_on);
      }
    }
 catch (    JSONException e) {
      e.printStackTrace();
    }
  }
  return responseString;
}","/** 
 * Tries to download the contents of the provided url using commercially validated CA certificate from chosen provider. <p/> If danger_on flag is true, SSL exceptions will be managed by futher methods that will try to use some bypass methods.
 * @param string_url
 * @param danger_on  if the user completely trusts this provider
 * @return
 */
private String downloadWithCommercialCA(String string_url,boolean danger_on){
  String responseString;
  JSONObject errorJson=new JSONObject();
  OkHttpClient okHttpClient=initCommercialCAHttpClient(errorJson);
  if (okHttpClient == null) {
    return errorJson.toString();
  }
  List<Pair<String,String>> headerArgs=getAuthorizationHeader();
  responseString=sendGetStringToServer(string_url,headerArgs,okHttpClient);
  if (responseString != null && responseString.contains(ERRORS)) {
    try {
      JSONObject responseErrorJson=new JSONObject(responseString);
      if (danger_on && responseErrorJson.getString(ERRORS).equals(getString(R.string.certificate_error))) {
        responseString=downloadWithProviderCA(string_url,danger_on);
      }
    }
 catch (    JSONException e) {
      e.printStackTrace();
    }
  }
  return responseString;
}",0.9890202702702704
109658,"/** 
 * Downloads a new OpenVPN certificate, attaching authenticated cookie for authenticated certificate.
 * @return true if certificate was downloaded correctly, false if provider.json is not present in SharedPreferences, or if the certificate url could not be parsed as a URI, or if there was an SSL error.
 */
@Override protected boolean updateVpnCertificate(){
  try {
    JSONObject provider_json=new JSONObject(preferences.getString(Provider.KEY,""String_Node_Str""));
    String provider_main_url=provider_json.getString(Provider.API_URL);
    URL new_cert_string_url=new URL(provider_main_url + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ Constants.VPN_CERTIFICATE);
    String cert_string=downloadWithProviderCA(new_cert_string_url.toString(),last_danger_on);
    if (cert_string.isEmpty() || ConfigHelper.checkErroneousDownload(cert_string))     return false;
 else     return loadCertificate(cert_string);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
}","/** 
 * Downloads a new OpenVPN certificate, attaching authenticated cookie for authenticated certificate.
 * @return true if certificate was downloaded correctly, false if provider.json is not present in SharedPreferences, or if the certificate url could not be parsed as a URI, or if there was an SSL error.
 */
@Override protected boolean updateVpnCertificate(){
  try {
    JSONObject provider_json=new JSONObject(preferences.getString(Provider.KEY,""String_Node_Str""));
    String provider_main_url=provider_json.getString(Provider.API_URL);
    URL new_cert_string_url=new URL(provider_main_url + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ Constants.VPN_CERTIFICATE);
    String cert_string=downloadWithProviderCA(new_cert_string_url.toString(),last_danger_on);
    if (cert_string == null || cert_string.isEmpty() || ConfigHelper.checkErroneousDownload(cert_string))     return false;
 else     return loadCertificate(cert_string);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
}",0.9897641299510458
109659,"/** 
 * Downloads the eip-service.json from a given URL, and saves eip service capabilities including the offered gateways
 * @return a bundle with a boolean value mapped to a key named RESULT_KEY, and which is true if the download was successful.
 */
@Override protected Bundle getAndSetEipServiceJson(){
  Bundle result=new Bundle();
  String eip_service_json_string=""String_Node_Str"";
  if (go_ahead) {
    try {
      JSONObject provider_json=new JSONObject(preferences.getString(Provider.KEY,""String_Node_Str""));
      String eip_service_url=provider_json.getString(Provider.API_URL) + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ EIP.SERVICE_API_PATH;
      eip_service_json_string=downloadWithProviderCA(eip_service_url,last_danger_on);
      JSONObject eip_service_json=new JSONObject(eip_service_json_string);
      eip_service_json.getInt(Provider.API_RETURN_SERIAL);
      preferences.edit().putString(Constants.KEY,eip_service_json.toString()).commit();
      result.putBoolean(RESULT_KEY,true);
    }
 catch (    JSONException e) {
      String reason_to_fail=pickErrorMessage(eip_service_json_string);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
  }
  return result;
}","/** 
 * Downloads the eip-service.json from a given URL, and saves eip service capabilities including the offered gateways
 * @return a bundle with a boolean value mapped to a key named RESULT_KEY, and which is true if the download was successful.
 */
@Override protected Bundle getAndSetEipServiceJson(){
  Bundle result=new Bundle();
  String eip_service_json_string=""String_Node_Str"";
  if (go_ahead) {
    try {
      JSONObject provider_json=new JSONObject(preferences.getString(Provider.KEY,""String_Node_Str""));
      String eip_service_url=provider_json.getString(Provider.API_URL) + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ EIP.SERVICE_API_PATH;
      eip_service_json_string=downloadWithProviderCA(eip_service_url,last_danger_on);
      JSONObject eip_service_json=new JSONObject(eip_service_json_string);
      eip_service_json.getInt(Provider.API_RETURN_SERIAL);
      preferences.edit().putString(Constants.KEY,eip_service_json.toString()).commit();
      result.putBoolean(RESULT_KEY,true);
    }
 catch (    NullPointerException|JSONException e) {
      String reason_to_fail=pickErrorMessage(eip_service_json_string);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
  }
  return result;
}",0.9918319719953326
109660,"public static boolean checkErroneousDownload(String downloaded_string){
  try {
    if (new JSONObject(downloaded_string).has(ProviderAPI.ERRORS) || downloaded_string.isEmpty()) {
      return true;
    }
 else {
      return false;
    }
  }
 catch (  JSONException e) {
    return false;
  }
}","public static boolean checkErroneousDownload(String downloaded_string){
  try {
    if (new JSONObject(downloaded_string).has(ProviderAPI.ERRORS) || downloaded_string.isEmpty()) {
      return true;
    }
 else {
      return false;
    }
  }
 catch (  NullPointerException|JSONException e) {
    return false;
  }
}",0.9656301145662848
109661,"private Bundle getAndSetProviderJson(String provider_main_url,String provider_ca_cert_fingerprint){
  Bundle result=new Bundle();
  if (go_ahead) {
    String provider_dot_json_string;
    if (provider_ca_cert_fingerprint.isEmpty())     provider_dot_json_string=downloadWithCommercialCA(provider_main_url + ""String_Node_Str"");
 else     provider_dot_json_string=downloadWithCommercialCA(provider_main_url + ""String_Node_Str"",provider_ca_cert_fingerprint);
    try {
      JSONObject provider_json=new JSONObject(provider_dot_json_string);
      provider_api_url=provider_json.getString(Provider.API_URL) + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION);
      String name=provider_json.getString(Provider.NAME);
      preferences.edit().putString(Provider.KEY,provider_json.toString()).commit();
      preferences.edit().putBoolean(Constants.ALLOWED_ANON,provider_json.getJSONObject(Provider.SERVICE).getBoolean(Constants.ALLOWED_ANON)).commit();
      preferences.edit().putBoolean(Constants.ALLOWED_REGISTERED,provider_json.getJSONObject(Provider.SERVICE).getBoolean(Constants.ALLOWED_REGISTERED)).commit();
      result.putBoolean(RESULT_KEY,true);
    }
 catch (    JSONException e) {
      String reason_to_fail=pickErrorMessage(provider_dot_json_string);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
  }
  return result;
}","private Bundle getAndSetProviderJson(String provider_main_url,String provider_ca_cert_fingerprint){
  Bundle result=new Bundle();
  if (go_ahead) {
    String provider_dot_json_string;
    if (provider_ca_cert_fingerprint.isEmpty())     provider_dot_json_string=downloadWithCommercialCA(provider_main_url + ""String_Node_Str"");
 else     provider_dot_json_string=downloadWithCommercialCA(provider_main_url + ""String_Node_Str"",provider_ca_cert_fingerprint);
    if (!isValidJson(provider_dot_json_string)) {
      result.putString(ERRORS,getString(malformed_url));
      result.putBoolean(RESULT_KEY,false);
      return result;
    }
    try {
      JSONObject provider_json=new JSONObject(provider_dot_json_string);
      provider_api_url=provider_json.getString(Provider.API_URL) + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION);
      String name=provider_json.getString(Provider.NAME);
      preferences.edit().putString(Provider.KEY,provider_json.toString()).commit();
      preferences.edit().putBoolean(Constants.ALLOWED_ANON,provider_json.getJSONObject(Provider.SERVICE).getBoolean(Constants.ALLOWED_ANON)).commit();
      preferences.edit().putBoolean(Constants.ALLOWED_REGISTERED,provider_json.getJSONObject(Provider.SERVICE).getBoolean(Constants.ALLOWED_REGISTERED)).commit();
      result.putBoolean(RESULT_KEY,true);
    }
 catch (    JSONException e) {
      String reason_to_fail=pickErrorMessage(provider_dot_json_string);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
  }
  return result;
}",0.9404641775983856
109662,"/** 
 * Tries to download the contents of the provided url using commercially validated CA certificate from chosen provider.
 * @param string_url
 * @return
 */
protected String downloadWithCommercialCA(String string_url){
  String responseString;
  JSONObject errorJson=new JSONObject();
  OkHttpClient okHttpClient=initCommercialCAHttpClient(errorJson);
  if (okHttpClient == null) {
    return errorJson.toString();
  }
  List<Pair<String,String>> headerArgs=getAuthorizationHeader();
  responseString=sendGetStringToServer(string_url,headerArgs,okHttpClient);
  if (responseString.contains(ERRORS)) {
    try {
      JSONObject responseErrorJson=new JSONObject(responseString);
      if (responseErrorJson.getString(ERRORS).equals(getString(R.string.certificate_error))) {
        responseString=downloadWithProviderCA(string_url);
      }
    }
 catch (    JSONException e) {
      e.printStackTrace();
    }
  }
  return responseString;
}","/** 
 * Tries to download the contents of the provided url using commercially validated CA certificate from chosen provider.
 * @param string_url
 * @return
 */
protected String downloadWithCommercialCA(String string_url){
  String responseString;
  JSONObject errorJson=new JSONObject();
  OkHttpClient okHttpClient=initCommercialCAHttpClient(errorJson);
  if (okHttpClient == null) {
    return errorJson.toString();
  }
  List<Pair<String,String>> headerArgs=getAuthorizationHeader();
  responseString=sendGetStringToServer(string_url,headerArgs,okHttpClient);
  if (responseString != null && responseString.contains(ERRORS)) {
    try {
      JSONObject responseErrorJson=new JSONObject(responseString);
      if (responseErrorJson.getString(ERRORS).equals(getString(R.string.certificate_error))) {
        responseString=downloadWithProviderCA(string_url);
      }
    }
 catch (    JSONException e) {
      e.printStackTrace();
    }
  }
  return responseString;
}",0.9864158829676072
109663,"/** 
 * Downloads a new OpenVPN certificate, attaching authenticated cookie for authenticated certificate.
 * @return true if certificate was downloaded correctly, false if provider.json is not present in SharedPreferences, or if the certificate url could not be parsed as a URI, or if there was an SSL error.
 */
@Override protected boolean updateVpnCertificate(){
  try {
    JSONObject provider_json=new JSONObject(preferences.getString(Provider.KEY,""String_Node_Str""));
    String provider_main_url=provider_json.getString(Provider.API_URL);
    URL new_cert_string_url=new URL(provider_main_url + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ Constants.VPN_CERTIFICATE);
    String cert_string=downloadWithProviderCA(new_cert_string_url.toString());
    if (cert_string.isEmpty() || ConfigHelper.checkErroneousDownload(cert_string))     return false;
 else     return loadCertificate(cert_string);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
}","/** 
 * Downloads a new OpenVPN certificate, attaching authenticated cookie for authenticated certificate.
 * @return true if certificate was downloaded correctly, false if provider.json is not present in SharedPreferences, or if the certificate url could not be parsed as a URI, or if there was an SSL error.
 */
@Override protected boolean updateVpnCertificate(){
  try {
    JSONObject provider_json=new JSONObject(preferences.getString(Provider.KEY,""String_Node_Str""));
    String provider_main_url=provider_json.getString(Provider.API_URL);
    URL new_cert_string_url=new URL(provider_main_url + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ Constants.VPN_CERTIFICATE);
    String cert_string=downloadWithProviderCA(new_cert_string_url.toString());
    if (cert_string == null || cert_string.isEmpty() || ConfigHelper.checkErroneousDownload(cert_string))     return false;
 else     return loadCertificate(cert_string);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
}",0.9896256202074876
109664,"/** 
 * Downloads the eip-service.json from a given URL, and saves eip service capabilities including the offered gateways
 * @return a bundle with a boolean value mapped to a key named RESULT_KEY, and which is true if the download was successful.
 */
@Override protected Bundle getAndSetEipServiceJson(){
  Bundle result=new Bundle();
  String eip_service_json_string=""String_Node_Str"";
  if (go_ahead) {
    try {
      JSONObject provider_json=new JSONObject(preferences.getString(Provider.KEY,""String_Node_Str""));
      String eip_service_url=provider_json.getString(Provider.API_URL) + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ EIP.SERVICE_API_PATH;
      eip_service_json_string=downloadWithProviderCA(eip_service_url);
      JSONObject eip_service_json=new JSONObject(eip_service_json_string);
      eip_service_json.getInt(Provider.API_RETURN_SERIAL);
      preferences.edit().putString(Constants.KEY,eip_service_json.toString()).commit();
      result.putBoolean(RESULT_KEY,true);
    }
 catch (    JSONException e) {
      String reason_to_fail=pickErrorMessage(eip_service_json_string);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
  }
  return result;
}","/** 
 * Downloads the eip-service.json from a given URL, and saves eip service capabilities including the offered gateways
 * @return a bundle with a boolean value mapped to a key named RESULT_KEY, and which is true if the download was successful.
 */
@Override protected Bundle getAndSetEipServiceJson(){
  Bundle result=new Bundle();
  String eip_service_json_string=""String_Node_Str"";
  if (go_ahead) {
    try {
      JSONObject provider_json=new JSONObject(preferences.getString(Provider.KEY,""String_Node_Str""));
      String eip_service_url=provider_json.getString(Provider.API_URL) + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ EIP.SERVICE_API_PATH;
      eip_service_json_string=downloadWithProviderCA(eip_service_url);
      JSONObject eip_service_json=new JSONObject(eip_service_json_string);
      eip_service_json.getInt(Provider.API_RETURN_SERIAL);
      preferences.edit().putString(Constants.KEY,eip_service_json.toString()).commit();
      result.putBoolean(RESULT_KEY,true);
    }
 catch (    NullPointerException|JSONException e) {
      String reason_to_fail=pickErrorMessage(eip_service_json_string);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
  }
  return result;
}",0.9917355371900828
109665,"public boolean errorInLast(int lines,Context context){
  boolean result=false;
  String[] error_keywords={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  VpnStatus.LogItem[] log=VpnStatus.getlogbuffer();
  String message=""String_Node_Str"";
  for (int i=0; i < lines; i++) {
    message=log[log.length - 1].getString(context);
    for (int j=0; j < error_keywords.length; j++)     if (message.contains(error_keywords[i]))     result=true;
  }
  return result;
}","public boolean errorInLast(int lines,Context context){
  boolean result=false;
  String[] error_keywords={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  VpnStatus.LogItem[] log=VpnStatus.getlogbuffer();
  String message=""String_Node_Str"";
  for (int i=0; i < lines; i++) {
    message=log[log.length - i].getString(context);
    for (int j=0; j < error_keywords.length; j++)     if (message.contains(error_keywords[j]))     result=true;
  }
  return result;
}",0.9959016393442623
109666,"/** 
 * Open the new provider dialog with data
 */
public void addAndSelectNewProvider(String main_url,boolean danger_on){
  FragmentTransaction fragment_transaction=fragment_manager.removePreviousFragment(NewProviderDialog.TAG);
  DialogFragment newFragment=NewProviderDialog.newInstance();
  Bundle data=new Bundle();
  data.putString(Provider.MAIN_URL,main_url);
  data.putBoolean(ProviderItem.DANGER_ON,danger_on);
  newFragment.setArguments(data);
  newFragment.show(fragment_transaction,NewProviderDialog.TAG);
}","/** 
 * Open the new provider dialog with data
 */
public void addAndSelectNewProvider(String main_url,boolean danger_on){
  FragmentTransaction fragment_transaction=fragment_manager.removePreviousFragment(NewProviderDialog.TAG);
  DialogFragment newFragment=new NewProviderDialog();
  Bundle data=new Bundle();
  data.putString(Provider.MAIN_URL,main_url);
  data.putBoolean(ProviderItem.DANGER_ON,danger_on);
  newFragment.setArguments(data);
  newFragment.show(fragment_transaction,NewProviderDialog.TAG);
}",0.9844357976653696
109667,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View new_provider_dialog_view=inflater.inflate(R.layout.new_provider_dialog,null);
  final EditText url_input_field=(EditText)new_provider_dialog_view.findViewById(R.id.new_provider_url);
  if (getArguments() != null && getArguments().containsKey(Provider.MAIN_URL)) {
    url_input_field.setText(getArguments().getString(Provider.MAIN_URL));
  }
  final CheckBox danger_checkbox=(CheckBox)new_provider_dialog_view.findViewById(R.id.danger_checkbox);
  if (getArguments() != null && getArguments().containsKey(ProviderItem.DANGER_ON)) {
    danger_checkbox.setActivated(getArguments().getBoolean(ProviderItem.DANGER_ON));
  }
  builder.setView(new_provider_dialog_view).setMessage(R.string.introduce_new_provider).setPositiveButton(R.string.save,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      String entered_url=url_input_field.getText().toString().trim();
      if (!entered_url.startsWith(""String_Node_Str"")) {
        if (entered_url.startsWith(""String_Node_Str"")) {
          entered_url=entered_url.substring(""String_Node_Str"".length());
        }
        entered_url=""String_Node_Str"".concat(entered_url);
      }
      boolean danger_on=danger_checkbox.isChecked();
      if (validURL(entered_url)) {
        interface_with_ConfigurationWizard.showAndSelectProvider(entered_url,danger_on);
        Toast.makeText(getActivity().getApplicationContext(),R.string.valid_url_entered,Toast.LENGTH_LONG).show();
      }
 else {
        url_input_field.setText(""String_Node_Str"");
        danger_checkbox.setChecked(false);
        Toast.makeText(getActivity().getApplicationContext(),R.string.not_valid_url_entered,Toast.LENGTH_LONG).show();
        ;
      }
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View view=inflater.inflate(R.layout.new_provider_dialog,null);
  ButterKnife.inject(this,view);
  Bundle arguments=getArguments();
  if (arguments != null) {
    url_input_field.setText(arguments.getString(Provider.MAIN_URL,""String_Node_Str""));
    danger_checkbox.setActivated(arguments.getBoolean(ProviderItem.DANGER_ON,false));
  }
  builder.setView(view).setMessage(R.string.introduce_new_provider).setPositiveButton(R.string.save,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      saveProvider();
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}",0.5096525096525096
109668,"@Override public void add(Provider item){
  super.add(item);
  if (getCollection().size() < hidden.length) {
    boolean[] new_hidden=new boolean[hidden.length + 1];
    System.arraycopy(hidden,0,new_hidden,0,hidden.length);
    new_hidden[hidden.length]=false;
    hidden=new_hidden;
  }
}","@Override public void add(Provider item){
  super.add(item);
  if (getCollection().size() > hidden.length) {
    boolean[] new_hidden=new boolean[hidden.length + 1];
    System.arraycopy(hidden,0,new_hidden,0,hidden.length);
    new_hidden[hidden.length]=false;
    hidden=new_hidden;
  }
}",0.996551724137931
109669,"/** 
 * Open the new provider dialog with data
 */
public void addAndSelectNewProvider(String main_url){
  FragmentTransaction fragment_transaction=fragment_manager.removePreviousFragment(NewProviderDialog.TAG);
  DialogFragment newFragment=NewProviderDialog.newInstance();
  Bundle data=new Bundle();
  data.putString(Provider.MAIN_URL,main_url);
  newFragment.setArguments(data);
  newFragment.show(fragment_transaction,NewProviderDialog.TAG);
}","/** 
 * Open the new provider dialog with data
 */
public void addAndSelectNewProvider(String main_url){
  FragmentTransaction fragment_transaction=fragment_manager.removePreviousFragment(NewProviderDialog.TAG);
  DialogFragment newFragment=new NewProviderDialog();
  Bundle data=new Bundle();
  data.putString(Provider.MAIN_URL,main_url);
  newFragment.setArguments(data);
  newFragment.show(fragment_transaction,NewProviderDialog.TAG);
}",0.981941309255079
109670,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View new_provider_dialog_view=inflater.inflate(R.layout.new_provider_dialog,null);
  final EditText url_input_field=(EditText)new_provider_dialog_view.findViewById(R.id.new_provider_url);
  if (getArguments() != null && getArguments().containsKey(Provider.MAIN_URL)) {
    url_input_field.setText(getArguments().getString(Provider.MAIN_URL));
  }
  builder.setView(new_provider_dialog_view).setMessage(R.string.introduce_new_provider).setPositiveButton(R.string.save,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      String entered_url=url_input_field.getText().toString().trim();
      if (!entered_url.startsWith(""String_Node_Str"")) {
        if (entered_url.startsWith(""String_Node_Str"")) {
          entered_url=entered_url.substring(""String_Node_Str"".length());
        }
        entered_url=""String_Node_Str"".concat(entered_url);
      }
      if (validURL(entered_url)) {
        interface_with_ConfigurationWizard.showAndSelectProvider(entered_url);
        Toast.makeText(getActivity().getApplicationContext(),R.string.valid_url_entered,Toast.LENGTH_LONG).show();
      }
 else {
        url_input_field.setText(""String_Node_Str"");
        Toast.makeText(getActivity().getApplicationContext(),R.string.not_valid_url_entered,Toast.LENGTH_LONG).show();
        ;
      }
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View view=inflater.inflate(R.layout.new_provider_dialog,null);
  ButterKnife.inject(this,view);
  Bundle arguments=getArguments();
  if (arguments != null) {
    url_input_field.setText(arguments.getString(Provider.MAIN_URL,""String_Node_Str""));
  }
  builder.setView(view).setMessage(R.string.introduce_new_provider).setPositiveButton(R.string.save,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      saveProvider();
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}",0.4990519529768676
109671,"public void testExponential(){
  byte[] expected_A;
  byte[] a_byte;
  SRPParameters params;
  LeapSRPSession client;
  expected_A=new BigInteger(""String_Node_Str"",16).toByteArray();
  String username=""String_Node_Str"", password=""String_Node_Str"", salt=""String_Node_Str"", a=""String_Node_Str"";
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  byte[] A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  a=""String_Node_Str"";
  expected_A=new BigInteger(""String_Node_Str"",16).toByteArray();
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
}","public void testExponential(){
  byte[] expected_A;
  byte[] a_byte;
  LeapSRPSession client;
  expected_A=new BigInteger(""String_Node_Str"",16).toByteArray();
  String username=""String_Node_Str"", password=""String_Node_Str"", salt=""String_Node_Str"", a=""String_Node_Str"";
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  byte[] A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  a=""String_Node_Str"";
  expected_A=new BigInteger(""String_Node_Str"",16).toByteArray();
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
}",0.3091309130913091
109672,"public void testVerify() throws NoSuchAlgorithmException {
  byte[] expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  byte[] expected_x=new BigInteger(""String_Node_Str"",16).toByteArray();
  byte[] expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  byte[] expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  String username=""String_Node_Str"", password=""String_Node_Str"", salt=""String_Node_Str"", a=""String_Node_Str"";
  byte[] a_byte=new BigInteger(a,16).toByteArray();
  SRPParameters params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  LeapSRPSession client=new LeapSRPSession(username,password,params,a_byte);
  byte[] x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  assertTrue(Arrays.equals(x,expected_x));
  byte[] A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  String B=""String_Node_Str"";
  byte[] M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  boolean verified=client.verify(expected_M2);
  assertTrue(verified);
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  A=client.exponential();
  B=""String_Node_Str"";
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  A=client.exponential();
  B=""String_Node_Str"";
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_x=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(trim(new BigInteger(salt,16).toByteArray()),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_x=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(trim(new BigInteger(salt,16).toByteArray()),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  String x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  a=""String_Node_Str"";
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  a=""String_Node_Str"";
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  a=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  a=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  a=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  a=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
}","public void testVerify() throws NoSuchAlgorithmException {
  byte[] expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  byte[] expected_x=new BigInteger(""String_Node_Str"",16).toByteArray();
  byte[] expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  byte[] expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  String username=""String_Node_Str"", password=""String_Node_Str"", salt=""String_Node_Str"", a=""String_Node_Str"";
  byte[] a_byte=new BigInteger(a,16).toByteArray();
  LeapSRPSession client=new LeapSRPSession(username,password,a_byte);
  byte[] x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  assertTrue(Arrays.equals(x,expected_x));
  byte[] A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  String B=""String_Node_Str"";
  byte[] M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  boolean verified=client.verify(expected_M2);
  assertTrue(verified);
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  A=client.exponential();
  B=""String_Node_Str"";
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  A=client.exponential();
  B=""String_Node_Str"";
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_x=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(trim(new BigInteger(salt,16).toByteArray()),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_x=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(trim(new BigInteger(salt,16).toByteArray()),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  String x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  a=""String_Node_Str"";
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  a=""String_Node_Str"";
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  a=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  a=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  a=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
  username=""String_Node_Str"";
  password=""String_Node_Str"";
  a=""String_Node_Str"";
  salt=""String_Node_Str"";
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  x_string=""String_Node_Str"";
  expected_x=trim(new BigInteger(x_string,16).toByteArray());
  assertEquals(new BigInteger(1,expected_x).toString(16),x_string);
  B=""String_Node_Str"";
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M2=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,trim(new BigInteger(salt,16).toByteArray()));
  assertTrue(Arrays.equals(x,expected_x));
  assertEquals(new BigInteger(1,expected_x).toString(16),new BigInteger(1,x).toString(16));
  A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  verified=client.verify(expected_M2);
  assertTrue(verified);
}",0.322717093804429
109673,"public void testSignUpMath() throws NoSuchAlgorithmException {
  String username=""String_Node_Str"";
  String password=""String_Node_Str"";
  byte[] salt=new BigInteger(""String_Node_Str"",16).toByteArray();
  SRPParameters params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),salt,""String_Node_Str"");
  LeapSRPSession client=new LeapSRPSession(username,password,params);
  String expected_v=""String_Node_Str"";
  assertEquals(expected_v,client.calculateV(username,password,salt).toString(16));
}","public void testSignUpMath() throws NoSuchAlgorithmException {
  String username=""String_Node_Str"";
  String password=""String_Node_Str"";
  byte[] salt=new BigInteger(""String_Node_Str"",16).toByteArray();
  LeapSRPSession client=new LeapSRPSession(username,password);
  String expected_v=""String_Node_Str"";
  assertEquals(expected_v,client.calculateV(username,password,salt).toString(16));
}",0.4658971668415529
109674,"public void testResponse() throws NoSuchAlgorithmException {
  byte[] expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  byte[] expected_x=new BigInteger(""String_Node_Str"",16).toByteArray();
  byte[] expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  String username=""String_Node_Str"", password=""String_Node_Str"", salt=""String_Node_Str"", a=""String_Node_Str"";
  byte[] a_byte=new BigInteger(a,16).toByteArray();
  SRPParameters params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  LeapSRPSession client=new LeapSRPSession(username,password,params,a_byte);
  byte[] x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  assertTrue(Arrays.equals(x,expected_x));
  byte[] A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  String B=""String_Node_Str"";
  byte[] M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  A=client.exponential();
  B=""String_Node_Str"";
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  expected_M1=new BigInteger(""String_Node_Str"",16).toByteArray();
  expected_A=new BigInteger(""String_Node_Str"",16).toByteArray();
  B=""String_Node_Str"";
  a=""String_Node_Str"";
  a_byte=new BigInteger(a,16).toByteArray();
  params=new SRPParameters(new BigInteger(ConfigHelper.NG_1024,16).toByteArray(),new BigInteger(""String_Node_Str"").toByteArray(),new BigInteger(salt,16).toByteArray(),""String_Node_Str"");
  client=new LeapSRPSession(username,password,params,a_byte);
  x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  A=client.exponential();
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
}","public void testResponse() throws NoSuchAlgorithmException {
  byte[] expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  byte[] expected_x=new BigInteger(""String_Node_Str"",16).toByteArray();
  byte[] expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  String username=""String_Node_Str"", password=""String_Node_Str"", salt=""String_Node_Str"", a=""String_Node_Str"";
  byte[] a_byte=new BigInteger(a,16).toByteArray();
  LeapSRPSession client=new LeapSRPSession(username,password,a_byte);
  byte[] x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  assertTrue(Arrays.equals(x,expected_x));
  byte[] A=client.exponential();
  assertTrue(Arrays.equals(A,expected_A));
  String B=""String_Node_Str"";
  byte[] M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  expected_A=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  expected_M1=trim(new BigInteger(""String_Node_Str"",16).toByteArray());
  a=""String_Node_Str"";
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  A=client.exponential();
  B=""String_Node_Str"";
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
  expected_M1=new BigInteger(""String_Node_Str"",16).toByteArray();
  expected_A=new BigInteger(""String_Node_Str"",16).toByteArray();
  B=""String_Node_Str"";
  a=""String_Node_Str"";
  a_byte=new BigInteger(a,16).toByteArray();
  client=new LeapSRPSession(username,password,a_byte);
  x=client.calculatePasswordHash(username,password,new BigInteger(salt,16).toByteArray());
  A=client.exponential();
  M1=client.response(new BigInteger(salt,16).toByteArray(),new BigInteger(B,16).toByteArray());
  assertTrue(Arrays.equals(M1,expected_M1));
}",0.3181026979982593
109675,"private boolean loadCertificate(String cert_string){
  try {
    String certificateString=null, keyString=null;
    String[] certAndKey=cert_string.split(""String_Node_Str"");
    for (int i=0; i < certAndKey.length - 1; i++) {
      if (certAndKey[i].contains(""String_Node_Str"")) {
        keyString=certAndKey[i++] + certAndKey[i];
      }
 else       if (certAndKey[i].contains(""String_Node_Str"")) {
        certificateString=certAndKey[i++] + certAndKey[i];
      }
    }
    RSAPrivateKey keyCert=ConfigHelper.parseRsaKeyFromString(keyString);
    keyString=Base64.encodeToString(keyCert.getEncoded(),Base64.DEFAULT);
    preferences.edit().putString(Constants.PRIVATE_KEY,""String_Node_Str"" + keyString + ""String_Node_Str"").commit();
    X509Certificate certCert=ConfigHelper.parseX509CertificateFromString(certificateString);
    certificateString=Base64.encodeToString(certCert.getEncoded(),Base64.DEFAULT);
    preferences.edit().putString(Constants.CERTIFICATE,""String_Node_Str"" + certificateString + ""String_Node_Str"").commit();
    preferences.edit().putString(Constants.DATE_FROM_CERTIFICATE,EIP.certificate_date_format.format(Calendar.getInstance().getTime())).commit();
    return true;
  }
 catch (  CertificateException e) {
    e.printStackTrace();
    return false;
  }
}","private boolean loadCertificate(String cert_string){
  try {
    String certificateString=null, keyString=null;
    String[] certAndKey=cert_string.split(""String_Node_Str"");
    for (int i=0; i < certAndKey.length - 1; i++) {
      if (certAndKey[i].contains(""String_Node_Str"")) {
        keyString=certAndKey[i++] + certAndKey[i];
      }
 else       if (certAndKey[i].contains(""String_Node_Str"")) {
        certificateString=certAndKey[i++] + certAndKey[i];
      }
    }
    RSAPrivateKey keyCert=ConfigHelper.parseRsaKeyFromString(keyString);
    keyString=Base64.encodeToString(keyCert.getEncoded(),Base64.DEFAULT);
    preferences.edit().putString(Constants.PRIVATE_KEY,""String_Node_Str"" + keyString + ""String_Node_Str"").commit();
    X509Certificate certCert=ConfigHelper.parseX509CertificateFromString(certificateString);
    certificateString=Base64.encodeToString(certCert.getEncoded(),Base64.DEFAULT);
    preferences.edit().putString(Constants.CERTIFICATE,""String_Node_Str"" + certificateString + ""String_Node_Str"").commit();
    return true;
  }
 catch (  CertificateException e) {
    e.printStackTrace();
    return false;
  }
}",0.940304652120214
109676,"@Override public void run(){
  try {
    Log.i(TAG,""String_Node_Str"");
    startOpenVPNThreadArgs(mArgv);
    Log.i(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    Log.e(TAG,""String_Node_Str"" + e.toString());
  }
 finally {
    int exitvalue=0;
    try {
      exitvalue=mProcess.waitFor();
    }
 catch (    IllegalThreadStateException ite) {
      OpenVPN.logError(""String_Node_Str"" + ite.getLocalizedMessage());
    }
catch (    InterruptedException ie) {
      OpenVPN.logError(""String_Node_Str"" + ie.getLocalizedMessage());
    }
    if (exitvalue != 0)     OpenVPN.logError(""String_Node_Str"" + exitvalue);
    OpenVPN.updateStateString(""String_Node_Str"",""String_Node_Str"",R.string.state_noprocess);
    if (mDumpPath != null) {
      try {
        BufferedWriter logout=new BufferedWriter(new FileWriter(mDumpPath + ""String_Node_Str""));
        for (        LogItem li : OpenVPN.getlogbuffer()) {
          logout.write(li.getString(null) + ""String_Node_Str"");
        }
        logout.close();
        OpenVPN.logError(R.string.minidump_generated);
      }
 catch (      IOException e) {
        OpenVPN.logError(""String_Node_Str"" + e.getLocalizedMessage());
      }
    }
    mService.processDied();
    Log.i(TAG,""String_Node_Str"");
  }
}","@Override public void run(){
  try {
    Log.i(TAG,""String_Node_Str"");
    startOpenVPNThreadArgs(mArgv);
    Log.i(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    Log.e(TAG,""String_Node_Str"" + e.toString());
  }
 finally {
    int exitvalue=0;
    try {
      exitvalue=mProcess.waitFor();
    }
 catch (    IllegalThreadStateException ite) {
      OpenVPN.logError(""String_Node_Str"" + ite.getLocalizedMessage());
    }
catch (    InterruptedException ie) {
      OpenVPN.logError(""String_Node_Str"" + ie.getLocalizedMessage());
    }
    if (exitvalue != 0)     OpenVPN.logError(""String_Node_Str"" + exitvalue);
    if (mDumpPath != null) {
      try {
        BufferedWriter logout=new BufferedWriter(new FileWriter(mDumpPath + ""String_Node_Str""));
        for (        LogItem li : OpenVPN.getlogbuffer()) {
          logout.write(li.getString(null) + ""String_Node_Str"");
        }
        logout.close();
        OpenVPN.logError(R.string.minidump_generated);
      }
 catch (      IOException e) {
        OpenVPN.logError(""String_Node_Str"" + e.getLocalizedMessage());
      }
    }
    mService.processDied();
    Log.i(TAG,""String_Node_Str"");
  }
}",0.9623329283110572
109677,"private void processCommand(String command){
  Log.d(TAG,""String_Node_Str"" + command);
  if (command.startsWith(""String_Node_Str"") && command.contains(""String_Node_Str"")) {
    String[] parts=command.split(""String_Node_Str"",2);
    String cmd=parts[0].substring(1);
    String argument=parts[1];
    if (cmd.equals(""String_Node_Str"")) {
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processPWCommand(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      handleHold();
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processNeedCommand(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processByteCount(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processState(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processState(""String_Node_Str"" + cmd + ""String_Node_Str"");
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processProxyCMD(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      String[] args=argument.split(""String_Node_Str"",3);
      OpenVPN.logMessage(0,""String_Node_Str"",args[2]);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processSignCommand(argument);
    }
 else {
      OpenVPN.logMessage(0,""String_Node_Str"",""String_Node_Str"" + command);
      Log.i(TAG,""String_Node_Str"" + command);
    }
  }
 else   if (command.startsWith(""String_Node_Str"")) {
  }
 else {
    Log.i(TAG,""String_Node_Str"" + command);
    OpenVPN.logMessage(0,""String_Node_Str"",""String_Node_Str"" + command);
  }
}","private void processCommand(String command){
  Log.d(TAG,""String_Node_Str"" + command);
  if (command.startsWith(""String_Node_Str"") && command.contains(""String_Node_Str"")) {
    String[] parts=command.split(""String_Node_Str"",2);
    String cmd=parts[0].substring(1);
    String argument=parts[1];
    if (cmd.equals(""String_Node_Str"")) {
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processPWCommand(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      handleHold();
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processNeedCommand(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processByteCount(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processState(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processState(""String_Node_Str"" + cmd + ""String_Node_Str"");
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processProxyCMD(argument);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      String[] args=argument.split(""String_Node_Str"",3);
      OpenVPN.logMessage(0,""String_Node_Str"",args[2]);
    }
 else     if (cmd.equals(""String_Node_Str"")) {
      processSignCommand(argument);
    }
 else {
      OpenVPN.logMessage(0,""String_Node_Str"",""String_Node_Str"" + command);
      Log.i(TAG,""String_Node_Str"" + command);
    }
  }
 else   if (command.startsWith(""String_Node_Str"")) {
    if (command.equals(""String_Node_Str"")) {
      Log.d(TAG,""String_Node_Str"");
      processState(""String_Node_Str"");
    }
  }
 else {
    Log.i(TAG,""String_Node_Str"" + command);
    OpenVPN.logMessage(0,""String_Node_Str"",""String_Node_Str"" + command);
  }
}",0.9558732131758856
109678,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View new_provider_dialog_view=inflater.inflate(R.layout.new_provider_dialog,null);
  final EditText url_input_field=(EditText)new_provider_dialog_view.findViewById(R.id.new_provider_url);
  final CheckBox danger_checkbox=(CheckBox)new_provider_dialog_view.findViewById(R.id.danger_checkbox);
  builder.setView(new_provider_dialog_view).setMessage(R.string.introduce_new_provider).setPositiveButton(R.string.save,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      String entered_url=url_input_field.getText().toString().trim();
      if (!entered_url.startsWith(""String_Node_Str"")) {
        entered_url=""String_Node_Str"".concat(entered_url);
      }
      boolean danger_on=danger_checkbox.isChecked();
      if (validURL(entered_url)) {
        interface_with_ConfigurationWizard.saveAndSelectProvider(entered_url,danger_on);
        Toast.makeText(getActivity().getApplicationContext(),R.string.valid_url_entered,Toast.LENGTH_LONG).show();
      }
 else {
        url_input_field.setText(""String_Node_Str"");
        Toast.makeText(getActivity().getApplicationContext(),R.string.not_valid_url_entered,Toast.LENGTH_LONG).show();
      }
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View new_provider_dialog_view=inflater.inflate(R.layout.new_provider_dialog,null);
  final EditText url_input_field=(EditText)new_provider_dialog_view.findViewById(R.id.new_provider_url);
  final CheckBox danger_checkbox=(CheckBox)new_provider_dialog_view.findViewById(R.id.danger_checkbox);
  builder.setView(new_provider_dialog_view).setMessage(R.string.introduce_new_provider).setPositiveButton(R.string.save,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      String entered_url=url_input_field.getText().toString().trim();
      if (!entered_url.startsWith(""String_Node_Str"")) {
        if (entered_url.startsWith(""String_Node_Str"")) {
          entered_url=entered_url.substring(""String_Node_Str"".length());
        }
        entered_url=""String_Node_Str"".concat(entered_url);
      }
      boolean danger_on=danger_checkbox.isChecked();
      if (validURL(entered_url)) {
        interface_with_ConfigurationWizard.saveAndSelectProvider(entered_url,danger_on);
        Toast.makeText(getActivity().getApplicationContext(),R.string.valid_url_entered,Toast.LENGTH_LONG).show();
      }
 else {
        url_input_field.setText(""String_Node_Str"");
        danger_checkbox.setChecked(false);
        Toast.makeText(getActivity().getApplicationContext(),R.string.not_valid_url_entered,Toast.LENGTH_LONG).show();
        ;
      }
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}",0.9433851569375185
109679,"/** 
 * Checks if the entered url is valid or not.
 * @param entered_url
 * @return true if it's not empty nor contains only the protocol.
 */
boolean validURL(String entered_url){
  return !entered_url.isEmpty() && entered_url.matches(""String_Node_Str"") && !entered_url.replaceFirst(""String_Node_Str"",""String_Node_Str"").isEmpty();
}","/** 
 * Checks if the entered url is valid or not.
 * @param entered_url
 * @return true if it's not empty nor contains only the protocol.
 */
boolean validURL(String entered_url){
  return android.util.Patterns.WEB_URL.matcher(entered_url).matches();
}",0.6757679180887372
109680,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == CONFIGURE_LEAP || requestCode == SWITCH_PROVIDER) {
    if (resultCode == RESULT_OK) {
      ConfigHelper.saveSharedPref(EIP.AUTHED_EIP,authed_eip);
      startService(new Intent(EIP.ACTION_UPDATE_EIP_SERVICE));
      buildDashboard();
      if (data != null && data.hasExtra(LogInDialog.VERB)) {
        View view=((ViewGroup)findViewById(android.R.id.content)).getChildAt(0);
        logInDialog(view,Bundle.EMPTY);
      }
    }
 else     if (resultCode == RESULT_CANCELED && data.hasExtra(ACTION_QUIT)) {
      finish();
    }
 else     configErrorDialog();
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == CONFIGURE_LEAP || requestCode == SWITCH_PROVIDER) {
    if (resultCode == RESULT_OK) {
      ConfigHelper.saveSharedPref(EIP.PARSED_SERIAL,0);
      ConfigHelper.saveSharedPref(EIP.AUTHED_EIP,authed_eip);
      startService(new Intent(EIP.ACTION_UPDATE_EIP_SERVICE));
      buildDashboard();
      if (data != null && data.hasExtra(LogInDialog.VERB)) {
        View view=((ViewGroup)findViewById(android.R.id.content)).getChildAt(0);
        logInDialog(view,Bundle.EMPTY);
      }
    }
 else     if (resultCode == RESULT_CANCELED && data.hasExtra(ACTION_QUIT)) {
      finish();
    }
 else     configErrorDialog();
  }
}",0.9601706970128022
109681,"@Override public boolean onOptionsItemSelected(MenuItem item){
  Intent intent;
switch (item.getItemId()) {
case R.id.about_leap:
    Fragment aboutFragment=new AboutFragment();
  FragmentTransaction trans=getFragmentManager().beginTransaction();
trans.replace(R.id.dashboardLayout,aboutFragment);
trans.addToBackStack(null);
trans.commit();
return true;
case R.id.legacy_interface:
intent=new Intent(this,MainActivity.class);
startActivity(intent);
return true;
case R.id.switch_provider:
startActivityForResult(new Intent(this,ConfigurationWizard.class),SWITCH_PROVIDER);
return true;
case R.id.login_button:
View view=((ViewGroup)findViewById(android.R.id.content)).getChildAt(0);
logInDialog(view,Bundle.EMPTY);
return true;
case R.id.logout_button:
logOut();
return true;
default :
return super.onOptionsItemSelected(item);
}
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  Intent intent;
switch (item.getItemId()) {
case R.id.about_leap:
    Fragment aboutFragment=new AboutFragment();
  FragmentTransaction trans=getFragmentManager().beginTransaction();
trans.replace(R.id.dashboardLayout,aboutFragment);
trans.addToBackStack(null);
trans.commit();
return true;
case R.id.legacy_interface:
intent=new Intent(this,MainActivity.class);
startActivity(intent);
return true;
case R.id.switch_provider:
if (Provider.getInstance().hasEIP()) {
if (ConfigHelper.getBoolFromSharedPref(EIP.AUTHED_EIP)) {
logOut();
}
eipStop();
}
startActivityForResult(new Intent(this,ConfigurationWizard.class),SWITCH_PROVIDER);
return true;
case R.id.login_button:
View view=((ViewGroup)findViewById(android.R.id.content)).getChildAt(0);
logInDialog(view,Bundle.EMPTY);
return true;
case R.id.logout_button:
logOut();
return true;
default :
return super.onOptionsItemSelected(item);
}
}",0.9316909294512878
109682,"/** 
 * Loads eip-service.json from SharedPreferences and calls   {@link updateGateways()}to parse gateway definitions. TODO Implement API call to refresh eip-service.json from the provider
 */
private void updateEIPService(){
  try {
    eipDefinition=ConfigHelper.getJsonFromSharedPref(EIP.KEY);
  }
 catch (  JSONException e) {
    e.printStackTrace();
  }
  if (eipDefinition.optInt(""String_Node_Str"") > parsedEipSerial)   updateGateways();
}","/** 
 * Loads eip-service.json from SharedPreferences and calls   {@link updateGateways()}to parse gateway definitions. TODO Implement API call to refresh eip-service.json from the provider
 */
private void updateEIPService(){
  try {
    eipDefinition=ConfigHelper.getJsonFromSharedPref(EIP.KEY);
    parsedEipSerial=ConfigHelper.getIntFromSharedPref(PARSED_SERIAL);
  }
 catch (  JSONException e) {
    e.printStackTrace();
  }
  if (parsedEipSerial == 0) {
    ProfileManager vpl=ProfileManager.getInstance(context);
    Collection<VpnProfile> profiles=vpl.getProfiles();
    for (    VpnProfile profile : profiles) {
      vpl.removeProfile(context,profile);
    }
  }
  if (eipDefinition.optInt(""String_Node_Str"") > parsedEipSerial)   updateGateways();
}",0.7402489626556017
109683,"/** 
 * Initiates an EIP connection by selecting a gateway and preparing and sending an Intent to   {@link se.leap.openvpn.LaunchVPN}
 */
private void startEIP(){
  if (activeGateway == null)   activeGateway=selectGateway();
  Intent intent=new Intent(this,LaunchVPN.class);
  intent.setAction(Intent.ACTION_MAIN);
  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  intent.putExtra(LaunchVPN.EXTRA_KEY,activeGateway.mVpnProfile.getUUID().toString());
  intent.putExtra(LaunchVPN.EXTRA_NAME,activeGateway.mVpnProfile.getName());
  intent.putExtra(RECEIVER_TAG,mReceiver);
  startActivity(intent);
  mPending=ACTION_START_EIP;
}","/** 
 * Initiates an EIP connection by selecting a gateway and preparing and sending an Intent to   {@link se.leap.openvpn.LaunchVPN}
 */
private void startEIP(){
  activeGateway=selectGateway();
  Intent intent=new Intent(this,LaunchVPN.class);
  intent.setAction(Intent.ACTION_MAIN);
  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  intent.putExtra(LaunchVPN.EXTRA_KEY,activeGateway.mVpnProfile.getUUID().toString());
  intent.putExtra(LaunchVPN.EXTRA_NAME,activeGateway.mVpnProfile.getName());
  intent.putExtra(RECEIVER_TAG,mReceiver);
  startActivity(intent);
  mPending=ACTION_START_EIP;
}",0.976326530612245
109684,"@Override public void updateState(final String state,final String logmessage,final int localizedResId){
  getActivity().runOnUiThread(new Runnable(){
    @Override public void run(){
      if (eipStatus != null) {
        boolean switchState=true;
        String statusMessage=""String_Node_Str"";
        String prefix=getString(localizedResId);
        if (state.equals(""String_Node_Str"")) {
          statusMessage=getString(R.string.eip_state_connected);
          getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
          mEipStartPending=false;
        }
 else         if (state.equals(""String_Node_Str"")) {
          statusMessage=getString(R.string.eip_state_connected);
          getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
          mEipStartPending=false;
        }
 else         if ((state.equals(""String_Node_Str"") && !mEipStartPending) || state.equals(""String_Node_Str"")) {
          statusMessage=getString(R.string.eip_state_not_connected);
          getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
          mEipStartPending=false;
          switchState=false;
        }
 else         if (state.equals(""String_Node_Str"")) {
          statusMessage=logmessage;
        }
 else {
          statusMessage=prefix + ""String_Node_Str"" + logmessage;
        }
        eipAutoSwitched=true;
        eipSwitch.setChecked(switchState);
        eipAutoSwitched=false;
        eipStatus.setText(statusMessage);
      }
    }
  }
);
}","@Override public void updateState(final String state,final String logmessage,final int localizedResId){
  getActivity().runOnUiThread(new Runnable(){
    @Override public void run(){
      if (eipStatus != null) {
        boolean switchState=true;
        String statusMessage=""String_Node_Str"";
        String prefix=getString(localizedResId);
        if (state.equals(""String_Node_Str"")) {
          statusMessage=getString(R.string.eip_state_connected);
          getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
          mEipStartPending=false;
        }
 else         if (state.equals(""String_Node_Str"")) {
          statusMessage=getString(R.string.eip_state_connected);
          getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
          mEipStartPending=false;
        }
 else         if ((state.equals(""String_Node_Str"") && !mEipStartPending) || state.equals(""String_Node_Str"") || state.equals(""String_Node_Str"")) {
          statusMessage=getString(R.string.eip_state_not_connected);
          getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
          mEipStartPending=false;
          switchState=false;
        }
 else         if (state.equals(""String_Node_Str"")) {
          statusMessage=logmessage;
        }
 else {
          statusMessage=prefix + ""String_Node_Str"" + logmessage;
        }
        eipAutoSwitched=true;
        eipSwitch.setChecked(switchState);
        eipAutoSwitched=false;
        eipStatus.setText(statusMessage);
      }
    }
  }
);
}",0.9885358663609564
109685,"@Override public void run(){
  if (eipStatus != null) {
    boolean switchState=true;
    String statusMessage=""String_Node_Str"";
    String prefix=getString(localizedResId);
    if (state.equals(""String_Node_Str"")) {
      statusMessage=getString(R.string.eip_state_connected);
      getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
      mEipStartPending=false;
    }
 else     if (state.equals(""String_Node_Str"")) {
      statusMessage=getString(R.string.eip_state_connected);
      getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
      mEipStartPending=false;
    }
 else     if ((state.equals(""String_Node_Str"") && !mEipStartPending) || state.equals(""String_Node_Str"")) {
      statusMessage=getString(R.string.eip_state_not_connected);
      getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
      mEipStartPending=false;
      switchState=false;
    }
 else     if (state.equals(""String_Node_Str"")) {
      statusMessage=logmessage;
    }
 else {
      statusMessage=prefix + ""String_Node_Str"" + logmessage;
    }
    eipAutoSwitched=true;
    eipSwitch.setChecked(switchState);
    eipAutoSwitched=false;
    eipStatus.setText(statusMessage);
  }
}","@Override public void run(){
  if (eipStatus != null) {
    boolean switchState=true;
    String statusMessage=""String_Node_Str"";
    String prefix=getString(localizedResId);
    if (state.equals(""String_Node_Str"")) {
      statusMessage=getString(R.string.eip_state_connected);
      getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
      mEipStartPending=false;
    }
 else     if (state.equals(""String_Node_Str"")) {
      statusMessage=getString(R.string.eip_state_connected);
      getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
      mEipStartPending=false;
    }
 else     if ((state.equals(""String_Node_Str"") && !mEipStartPending) || state.equals(""String_Node_Str"") || state.equals(""String_Node_Str"")) {
      statusMessage=getString(R.string.eip_state_not_connected);
      getActivity().findViewById(R.id.eipProgress).setVisibility(View.GONE);
      mEipStartPending=false;
      switchState=false;
    }
 else     if (state.equals(""String_Node_Str"")) {
      statusMessage=logmessage;
    }
 else {
      statusMessage=prefix + ""String_Node_Str"" + logmessage;
    }
    eipAutoSwitched=true;
    eipSwitch.setChecked(switchState);
    eipAutoSwitched=false;
    eipStatus.setText(statusMessage);
  }
}",0.9858814037918516
109686,"protected boolean hasEIP(){
  JSONArray services=null;
  try {
    services=definition.getJSONArray(API_TERM_SERVICES);
  }
 catch (  Exception e) {
  }
  for (int i=0; i < API_EIP_TYPES.length + 1; i++) {
    try {
      if (Arrays.asList(API_EIP_TYPES).contains(services.getString(i)))       return true;
    }
 catch (    JSONException e) {
      e.printStackTrace();
    }
  }
  return false;
}","protected boolean hasEIP(){
  JSONArray services=null;
  try {
    services=definition.getJSONArray(API_TERM_SERVICES);
  }
 catch (  Exception e) {
  }
  for (int i=0; i < API_EIP_TYPES.length + 1; i++) {
    try {
      if (Arrays.asList(API_EIP_TYPES).contains(services.getString(i)))       return true;
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
    }
catch (    JSONException e) {
      e.printStackTrace();
    }
  }
  return false;
}",0.9191685912240184
109687,"/** 
 * Downloads the main cert and the eip-service.json files given through the task parameter
 * @param task
 * @return true if eip-service.json was parsed as a JSON object correctly.
 */
private Bundle downloadJsonFiles(Bundle task){
  Bundle result=new Bundle();
  String cert_url=task.getString(Provider.CA_CERT);
  String eip_service_json_url=task.getString(EIP.KEY);
  boolean danger_on=task.getBoolean(ProviderItem.DANGER_ON);
  try {
    String cert_string=downloadWithCommercialCA(cert_url,danger_on);
    if (ConfigHelper.checkErroneousDownload(cert_string)) {
      JSONObject possible_errors=new JSONObject(cert_string);
      String reason_to_fail=""String_Node_Str"";
      if (cert_string.isEmpty())       reason_to_fail=""String_Node_Str"";
 else       reason_to_fail=possible_errors.getString(ERRORS);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
 else {
      X509Certificate certCert=ConfigHelper.parseX509CertificateFromString(cert_string);
      cert_string=Base64.encodeToString(certCert.getEncoded(),Base64.DEFAULT);
      ConfigHelper.saveSharedPref(Provider.CA_CERT,""String_Node_Str"" + cert_string + ""String_Node_Str"");
    }
  }
 catch (  JSONException e) {
    e.printStackTrace();
    result.putBoolean(RESULT_KEY,false);
  }
catch (  CertificateException e) {
    e.printStackTrace();
    result.putBoolean(RESULT_KEY,false);
  }
  try {
    String eip_service_string=downloadWithCommercialCA(eip_service_json_url,danger_on);
    JSONObject eip_service_json=new JSONObject(eip_service_string);
    if (eip_service_json.has(ERRORS)) {
      String reason_to_fail=eip_service_json.getString(ERRORS);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
 else     ConfigHelper.saveSharedPref(EIP.KEY,eip_service_json);
    result.putBoolean(RESULT_KEY,true);
  }
 catch (  JSONException e) {
    result.putBoolean(RESULT_KEY,false);
  }
  return result;
}","/** 
 * Downloads the main cert and the eip-service.json files given through the task parameter
 * @param task
 * @return true if eip-service.json was parsed as a JSON object correctly.
 */
private Bundle downloadJsonFiles(Bundle task){
  Bundle result=new Bundle();
  String cert_url=task.getString(Provider.CA_CERT);
  String eip_service_json_url=task.getString(EIP.KEY);
  boolean danger_on=task.getBoolean(ProviderItem.DANGER_ON);
  try {
    String cert_string=downloadWithCommercialCA(cert_url,danger_on);
    if (ConfigHelper.checkErroneousDownload(cert_string)) {
      JSONObject possible_errors=new JSONObject(cert_string);
      String reason_to_fail=""String_Node_Str"";
      if (cert_string.isEmpty())       reason_to_fail=""String_Node_Str"";
 else       reason_to_fail=possible_errors.getString(ERRORS);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
 else {
      X509Certificate certCert=ConfigHelper.parseX509CertificateFromString(cert_string);
      cert_string=Base64.encodeToString(certCert.getEncoded(),Base64.DEFAULT);
      ConfigHelper.saveSharedPref(Provider.CA_CERT,""String_Node_Str"" + cert_string + ""String_Node_Str"");
    }
  }
 catch (  JSONException e) {
    e.printStackTrace();
    result.putBoolean(RESULT_KEY,false);
  }
catch (  CertificateException e) {
    e.printStackTrace();
    result.putBoolean(RESULT_KEY,false);
  }
  try {
    String eip_service_string=downloadWithCommercialCA(eip_service_json_url,danger_on);
    JSONObject eip_service_json=new JSONObject(eip_service_string);
    if (eip_service_json.has(ERRORS)) {
      String reason_to_fail=eip_service_json.getString(ERRORS);
      result.putString(ERRORS,reason_to_fail);
      result.putBoolean(RESULT_KEY,false);
    }
 else {
      ConfigHelper.saveSharedPref(EIP.KEY,eip_service_json);
      ConfigHelper.saveSharedPref(EIP.PARSED_SERIAL,0);
    }
    result.putBoolean(RESULT_KEY,true);
  }
 catch (  JSONException e) {
    result.putBoolean(RESULT_KEY,false);
  }
  return result;
}",0.9835411471321696
109688,"private static int getLocalizedState(String state){
  if (state.equals(""String_Node_Str""))   return R.string.state_connecting;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_wait;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_auth;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_get_config;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_assign_ip;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_add_routes;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_connected;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_reconnecting;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_exiting;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_resolve;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_tcp_connect;
 else   return R.string.unknown_state;
}","private static int getLocalizedState(String state){
  if (state.equals(""String_Node_Str""))   return R.string.state_connecting;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_wait;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_auth;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_get_config;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_assign_ip;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_add_routes;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_connected;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_reconnecting;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_exiting;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_resolve;
 else   if (state.equals(""String_Node_Str""))   return R.string.state_tcp_connect;
 else   if (state.equals(""String_Node_Str""))   return R.string.eip_state_not_connected;
 else   return R.string.unknown_state;
}",0.9561752988047808
109689,"@Override public void run(){
  try {
    Log.i(TAG,""String_Node_Str"");
    startOpenVPNThreadArgs(mArgv);
    Log.i(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    Log.e(TAG,""String_Node_Str"" + e.toString());
  }
 finally {
    int exitvalue=0;
    try {
      exitvalue=mProcess.waitFor();
    }
 catch (    IllegalThreadStateException ite) {
      OpenVPN.logError(""String_Node_Str"" + ite.getLocalizedMessage());
    }
catch (    InterruptedException ie) {
      OpenVPN.logError(""String_Node_Str"" + ie.getLocalizedMessage());
    }
    if (exitvalue != 0)     OpenVPN.logError(""String_Node_Str"" + exitvalue);
    OpenVPN.updateStateString(""String_Node_Str"",""String_Node_Str"",R.string.state_noprocess);
    if (mDumpPath != null) {
      try {
        BufferedWriter logout=new BufferedWriter(new FileWriter(mDumpPath + ""String_Node_Str""));
        for (        LogItem li : OpenVPN.getlogbuffer()) {
          logout.write(li.getString(null) + ""String_Node_Str"");
        }
        logout.close();
        OpenVPN.logError(R.string.minidump_generated);
      }
 catch (      IOException e) {
        OpenVPN.logError(""String_Node_Str"" + e.getLocalizedMessage());
      }
    }
    mService.processDied();
    Log.i(TAG,""String_Node_Str"");
  }
}","@Override public void run(){
  try {
    Log.i(TAG,""String_Node_Str"");
    startOpenVPNThreadArgs(mArgv);
    Log.i(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
    Log.e(TAG,""String_Node_Str"" + e.toString());
  }
 finally {
    int exitvalue=0;
    try {
      exitvalue=mProcess.waitFor();
    }
 catch (    IllegalThreadStateException ite) {
      OpenVPN.logError(""String_Node_Str"" + ite.getLocalizedMessage());
    }
catch (    InterruptedException ie) {
      OpenVPN.logError(""String_Node_Str"" + ie.getLocalizedMessage());
    }
    if (exitvalue != 0)     OpenVPN.logError(""String_Node_Str"" + exitvalue);
    if (mDumpPath != null) {
      try {
        BufferedWriter logout=new BufferedWriter(new FileWriter(mDumpPath + ""String_Node_Str""));
        for (        LogItem li : OpenVPN.getlogbuffer()) {
          logout.write(li.getString(null) + ""String_Node_Str"");
        }
        logout.close();
        OpenVPN.logError(R.string.minidump_generated);
      }
 catch (      IOException e) {
        OpenVPN.logError(""String_Node_Str"" + e.getLocalizedMessage());
      }
    }
    mService.processDied();
    Log.i(TAG,""String_Node_Str"");
  }
}",0.9623329283110572
109690,"public AlertDialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View log_in_dialog_view=inflater.inflate(R.layout.log_in_dialog,null);
  final TextView user_message=(TextView)log_in_dialog_view.findViewById(R.id.user_message);
  if (getArguments() != null && getArguments().containsKey(getResources().getString(R.string.user_message))) {
    user_message.setText(getArguments().getString(getResources().getString(R.string.user_message)));
  }
 else {
    user_message.setVisibility(View.GONE);
  }
  final EditText username_field=(EditText)log_in_dialog_view.findViewById(R.id.username_entered);
  if (getArguments() != null && getArguments().containsKey(USERNAME)) {
    String username=getArguments().getString(USERNAME);
    username_field.setText(username);
  }
  if (getArguments() != null && getArguments().containsKey(USERNAME_MISSING)) {
    username_field.setError(getResources().getString(R.string.username_ask));
  }
  final EditText password_field=(EditText)log_in_dialog_view.findViewById(R.id.password_entered);
  if (!username_field.getText().toString().isEmpty() && password_field.isFocusable()) {
    password_field.requestFocus();
  }
  if (getArguments() != null && getArguments().containsKey(PASSWORD_INVALID_LENGTH)) {
    password_field.setError(getResources().getString(R.string.error_not_valid_password_user_message));
  }
  builder.setView(log_in_dialog_view).setPositiveButton(R.string.login_button,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      String username=username_field.getText().toString().trim();
      String password=password_field.getText().toString().trim();
      dialog.dismiss();
      interface_with_Dashboard.authenticate(username,password);
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}","public AlertDialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View log_in_dialog_view=inflater.inflate(R.layout.log_in_dialog,null);
  final TextView user_message=(TextView)log_in_dialog_view.findViewById(R.id.user_message);
  if (getArguments() != null && getArguments().containsKey(getResources().getString(R.string.user_message))) {
    user_message.setText(getArguments().getString(getResources().getString(R.string.user_message)));
  }
 else {
    user_message.setVisibility(View.GONE);
  }
  final EditText username_field=(EditText)log_in_dialog_view.findViewById(R.id.username_entered);
  if (getArguments() != null && getArguments().containsKey(USERNAME)) {
    String username=getArguments().getString(USERNAME);
    username_field.setText(username);
  }
  if (getArguments() != null && getArguments().containsKey(USERNAME_MISSING)) {
    username_field.setError(getResources().getString(R.string.username_ask));
  }
  final EditText password_field=(EditText)log_in_dialog_view.findViewById(R.id.password_entered);
  if (!username_field.getText().toString().isEmpty() && password_field.isFocusable()) {
    password_field.requestFocus();
  }
  if (getArguments() != null && getArguments().containsKey(PASSWORD_INVALID_LENGTH)) {
    password_field.setError(getResources().getString(R.string.error_not_valid_password_user_message));
  }
  builder.setView(log_in_dialog_view).setPositiveButton(R.string.login_button,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      String username=username_field.getText().toString();
      String password=password_field.getText().toString();
      dialog.dismiss();
      interface_with_Dashboard.authenticate(username,password);
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}",0.996642685851319
109691,"public void testLogInAndOut(){
  long miliseconds_to_log_in=40 * 1000;
  solo.clickOnMenuItem(""String_Node_Str"");
  solo.enterText(0,""String_Node_Str"");
  solo.enterText(1,""String_Node_Str"");
  solo.clickOnText(""String_Node_Str"");
  solo.waitForDialogToClose();
  solo.waitForDialogToClose(miliseconds_to_log_in);
  if (!solo.waitForText(""String_Node_Str""))   fail();
  solo.clickOnMenuItem(""String_Node_Str"");
  if (!solo.waitForDialogToClose())   fail();
}","public void testLogInAndOut(){
  long miliseconds_to_log_in=40 * 1000;
  solo.clickOnActionBarItem(R.id.login_button);
  solo.enterText(0,""String_Node_Str"");
  solo.enterText(1,""String_Node_Str"");
  solo.clickOnText(""String_Node_Str"");
  solo.waitForDialogToClose();
  solo.waitForDialogToClose(miliseconds_to_log_in);
  if (!solo.waitForText(""String_Node_Str""))   fail();
  solo.clickOnActionBarItem(R.string.logout_button);
  if (!solo.waitForDialogToClose())   fail();
}",0.8764769065520945
109692,"public void testShowAbout(){
  solo.clickOnMenuItem(""String_Node_Str"");
  solo.waitForText(""String_Node_Str"");
  solo.goBack();
  solo.clickOnMenuItem(""String_Node_Str"");
  solo.waitForText(""String_Node_Str"");
  solo.goBack();
}","public void testShowAbout(){
  solo.clickOnMenuItem(""String_Node_Str"");
  solo.waitForText(getActivity().getString(R.string.repository_url_text));
  solo.goBack();
  solo.clickOnMenuItem(""String_Node_Str"");
  solo.waitForText(getActivity().getString(R.string.repository_url_text));
  solo.goBack();
}",0.7348484848484849
109693,"/** 
 * This test will fail if Android does not trust VPN connection. I cannot automate that dialog.
 */
public void testOnOffOpenVpn(){
  solo.clickOnView(solo.getView(R.id.eipSwitch));
  if (!solo.waitForText(""String_Node_Str""))   fail();
  if (!solo.waitForText(""String_Node_Str""))   fail();
  if (!solo.waitForText(""String_Node_Str"",1,30 * 1000))   fail();
  solo.clickOnView(solo.getView(R.id.eipSwitch));
  if (!solo.waitForText(""String_Node_Str""))   fail();
  setAirplaneMode(true);
  if (!solo.waitForLogMessage(""String_Node_Str""))   fail();
  solo.clickOnView(solo.getView(R.id.eipSwitch));
  if (!solo.waitForText(""String_Node_Str""))   fail();
  if (!solo.waitForText(""String_Node_Str""))   fail();
}","/** 
 * This test will fail if Android does not trust VPN connection. I cannot automate that dialog.
 */
public void testOnOffOpenVpn(){
  solo.clickOnView(solo.getView(R.id.eipSwitch));
  if (!solo.waitForText(""String_Node_Str""))   fail();
  if (!solo.waitForText(""String_Node_Str""))   fail();
  if (!solo.waitForText(""String_Node_Str"",1,30 * 1000))   fail();
  solo.clickOnView(solo.getView(R.id.eipSwitch));
  if (!solo.waitForText(""String_Node_Str""))   fail();
}",0.7931914893617021
109694,"public void testShowSettings(){
  solo.clickOnMenuItem(""String_Node_Str"");
}","public void testShowSettings(){
  solo.clickOnActionBarItem(R.id.menu_settings);
}",0.759493670886076
109695,"/** 
 * Downloads a new OpenVPN certificate, attaching authenticated cookie for authenticated certificate.
 * @param task containing the type of the certificate to be downloaded
 * @return true if certificate was downloaded correctly, false if provider.json or danger_on flag are not present in SharedPreferences, or if the certificate url could not be parsed as a URI, or if there was an SSL error. 
 */
private boolean getNewCert(Bundle task){
  try {
    String type_of_certificate=task.getString(ConfigurationWizard.TYPE_OF_CERTIFICATE);
    JSONObject provider_json=ConfigHelper.getJsonFromSharedPref(Provider.KEY);
    String provider_main_url=provider_json.getString(Provider.API_URL);
    URL new_cert_string_url=new URL(provider_main_url + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ EIP.CERTIFICATE);
    boolean danger_on=ConfigHelper.getBoolFromSharedPref(ProviderItem.DANGER_ON);
    String cert_string=downloadWithProviderCA(new_cert_string_url,danger_on);
    if (!cert_string.isEmpty()) {
      if (ConfigHelper.checkErroneousDownload(cert_string)) {
        String reason_to_fail=provider_json.getString(ERRORS);
        return false;
      }
 else {
        String certificateString=null, keyString=null;
        String[] certAndKey=cert_string.split(""String_Node_Str"");
        for (int i=0; i < certAndKey.length - 1; i++) {
          if (certAndKey[i].contains(""String_Node_Str"")) {
            keyString=certAndKey[i++] + certAndKey[i];
          }
 else           if (certAndKey[i].contains(""String_Node_Str"")) {
            certificateString=certAndKey[i++] + certAndKey[i];
          }
        }
        try {
          RSAPrivateKey keyCert=ConfigHelper.parseRsaKeyFromString(keyString);
          keyString=Base64.encodeToString(keyCert.getEncoded(),Base64.DEFAULT);
          ConfigHelper.saveSharedPref(EIP.PRIVATE_KEY,""String_Node_Str"" + keyString + ""String_Node_Str"");
          X509Certificate certCert=ConfigHelper.parseX509CertificateFromString(certificateString);
          certificateString=Base64.encodeToString(certCert.getEncoded(),Base64.DEFAULT);
          ConfigHelper.saveSharedPref(EIP.CERTIFICATE,""String_Node_Str"" + certificateString + ""String_Node_Str"");
          return true;
        }
 catch (        CertificateException e) {
          e.printStackTrace();
          return false;
        }
      }
    }
 else {
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
}","/** 
 * Downloads a new OpenVPN certificate, attaching authenticated cookie for authenticated certificate.
 * @param task containing the type of the certificate to be downloaded
 * @return true if certificate was downloaded correctly, false if provider.json or danger_on flag are not present in SharedPreferences, or if the certificate url could not be parsed as a URI, or if there was an SSL error. 
 */
private boolean getNewCert(Bundle task){
  try {
    String type_of_certificate=task.getString(ConfigurationWizard.TYPE_OF_CERTIFICATE);
    JSONObject provider_json=ConfigHelper.getJsonFromSharedPref(Provider.KEY);
    String provider_main_url=provider_json.getString(Provider.API_URL);
    URL new_cert_string_url=new URL(provider_main_url + ""String_Node_Str"" + provider_json.getString(Provider.API_VERSION)+ ""String_Node_Str""+ EIP.CERTIFICATE);
    boolean danger_on=ConfigHelper.getBoolFromSharedPref(ProviderItem.DANGER_ON);
    String cert_string=downloadWithProviderCA(new_cert_string_url.toString(),danger_on);
    if (!cert_string.isEmpty()) {
      if (ConfigHelper.checkErroneousDownload(cert_string)) {
        String reason_to_fail=provider_json.getString(ERRORS);
        return false;
      }
 else {
        String certificateString=null, keyString=null;
        String[] certAndKey=cert_string.split(""String_Node_Str"");
        for (int i=0; i < certAndKey.length - 1; i++) {
          if (certAndKey[i].contains(""String_Node_Str"")) {
            keyString=certAndKey[i++] + certAndKey[i];
          }
 else           if (certAndKey[i].contains(""String_Node_Str"")) {
            certificateString=certAndKey[i++] + certAndKey[i];
          }
        }
        try {
          RSAPrivateKey keyCert=ConfigHelper.parseRsaKeyFromString(keyString);
          keyString=Base64.encodeToString(keyCert.getEncoded(),Base64.DEFAULT);
          ConfigHelper.saveSharedPref(EIP.PRIVATE_KEY,""String_Node_Str"" + keyString + ""String_Node_Str"");
          X509Certificate certCert=ConfigHelper.parseX509CertificateFromString(certificateString);
          certificateString=Base64.encodeToString(certCert.getEncoded(),Base64.DEFAULT);
          ConfigHelper.saveSharedPref(EIP.CERTIFICATE,""String_Node_Str"" + certificateString + ""String_Node_Str"");
          return true;
        }
 catch (        CertificateException e) {
          e.printStackTrace();
          return false;
        }
      }
    }
 else {
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
}",0.9978776770210304
109696,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  app=this;
  ConfigHelper.setSharedPreferences(getSharedPreferences(SHARED_PREFERENCES,MODE_PRIVATE));
  preferences=ConfigHelper.shared_preferences;
  if (ConfigHelper.getStringFromSharedPref(Provider.KEY).isEmpty())   startActivityForResult(new Intent(this,ConfigurationWizard.class),CONFIGURE_LEAP);
 else   buildDashboard();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  app=this;
  PRNGFixes.apply();
  ConfigHelper.setSharedPreferences(getSharedPreferences(SHARED_PREFERENCES,MODE_PRIVATE));
  preferences=ConfigHelper.shared_preferences;
  if (ConfigHelper.getStringFromSharedPref(Provider.KEY).isEmpty())   startActivityForResult(new Intent(this,ConfigurationWizard.class),CONFIGURE_LEAP);
 else   buildDashboard();
}",0.9762174405436014
109697,"/** 
 * Dialog shown when encountering a configuration error.  Such errors require reconfiguring LEAP or aborting the application.
 */
private void configErrorDialog(){
  AlertDialog.Builder alertBuilder=new AlertDialog.Builder(getAppContext());
  alertBuilder.setTitle(getResources().getString(R.string.setup_error_title));
  alertBuilder.setMessage(getResources().getString(R.string.setup_error_text)).setCancelable(false).setPositiveButton(getResources().getString(R.string.setup_error_configure_button),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      startActivityForResult(new Intent(getAppContext(),ConfigurationWizard.class),CONFIGURE_LEAP);
    }
  }
).setNegativeButton(getResources().getString(R.string.setup_error_close_button),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      SharedPreferences.Editor prefsEdit=getSharedPreferences(ConfigHelper.PREFERENCES_KEY,MODE_PRIVATE).edit();
      prefsEdit.remove(ConfigHelper.PROVIDER_KEY).commit();
      finish();
    }
  }
);
}","/** 
 * Dialog shown when encountering a configuration error.  Such errors require reconfiguring LEAP or aborting the application.
 */
private void configErrorDialog(){
  AlertDialog.Builder alertBuilder=new AlertDialog.Builder(getAppContext());
  alertBuilder.setTitle(getResources().getString(R.string.setup_error_title));
  alertBuilder.setMessage(getResources().getString(R.string.setup_error_text)).setCancelable(false).setPositiveButton(getResources().getString(R.string.setup_error_configure_button),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      startActivityForResult(new Intent(getAppContext(),ConfigurationWizard.class),CONFIGURE_LEAP);
    }
  }
).setNegativeButton(getResources().getString(R.string.setup_error_close_button),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      SharedPreferences.Editor prefsEdit=getSharedPreferences(ConfigHelper.PREFERENCES_KEY,MODE_PRIVATE).edit();
      prefsEdit.remove(ConfigHelper.PROVIDER_KEY).commit();
      finish();
    }
  }
).show();
}",0.9969176574196388
109698,"public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View new_provider_dialog_view=inflater.inflate(R.layout.new_provider_dialog,null);
  final EditText url_input_field=(EditText)new_provider_dialog_view.findViewById(R.id.new_provider_url);
  final CheckBox danger_checkbox=(CheckBox)new_provider_dialog_view.findViewById(R.id.danger_checkbox);
  builder.setView(new_provider_dialog_view).setMessage(R.string.introduce_new_provider).setPositiveButton(R.string.save,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      String entered_url=url_input_field.getText().toString().trim();
      boolean danger_on=danger_checkbox.isChecked();
      if (validURL(entered_url)) {
        interface_with_ConfigurationWizard.saveProvider(entered_url,danger_on);
        Toast.makeText(getActivity().getApplicationContext(),""String_Node_Str"",Toast.LENGTH_LONG).show();
      }
 else {
        url_input_field.setText(""String_Node_Str"");
        Toast.makeText(getActivity().getApplicationContext(),""String_Node_Str"",Toast.LENGTH_LONG).show();
      }
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}","public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  View new_provider_dialog_view=inflater.inflate(R.layout.new_provider_dialog,null);
  final EditText url_input_field=(EditText)new_provider_dialog_view.findViewById(R.id.new_provider_url);
  final CheckBox danger_checkbox=(CheckBox)new_provider_dialog_view.findViewById(R.id.danger_checkbox);
  builder.setView(new_provider_dialog_view).setMessage(R.string.introduce_new_provider).setPositiveButton(R.string.save,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      String entered_url=url_input_field.getText().toString().trim();
      if (!entered_url.startsWith(""String_Node_Str"")) {
        entered_url=""String_Node_Str"".concat(entered_url);
      }
      boolean danger_on=danger_checkbox.isChecked();
      if (validURL(entered_url)) {
        interface_with_ConfigurationWizard.saveProvider(entered_url,danger_on);
        Toast.makeText(getActivity().getApplicationContext(),""String_Node_Str"",Toast.LENGTH_LONG).show();
      }
 else {
        url_input_field.setText(""String_Node_Str"");
        Toast.makeText(getActivity().getApplicationContext(),""String_Node_Str"",Toast.LENGTH_LONG).show();
      }
    }
  }
).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  return builder.create();
}",0.9591497841248756
109699,"/** 
 * Calculates the parameter x of the SRP-6a algorithm.
 * @param username
 * @param password
 * @param salt the salt of the user
 * @return x
 */
public byte[] calculatePasswordHash(String username,String password,byte[] salt){
  password=password.replaceAll(""String_Node_Str"",""String_Node_Str"");
  MessageDigest x_digest=newDigest();
  byte[] user=null;
  byte[] password_bytes=null;
  byte[] colon={};
  try {
    user=Util.trim(username.getBytes(""String_Node_Str""));
    colon=Util.trim(""String_Node_Str"".getBytes(""String_Node_Str""));
    password_bytes=Util.trim(password.getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException e) {
    user=Util.trim(username.getBytes());
    colon=Util.trim(""String_Node_Str"".getBytes());
    password_bytes=Util.trim(password.getBytes());
  }
  x_digest.update(user);
  x_digest.update(colon);
  x_digest.update(password_bytes);
  byte[] h=x_digest.digest();
  String hstr=new BigInteger(1,h).toString(16);
  x_digest.reset();
  x_digest.update(salt);
  x_digest.update(h);
  byte[] x_digest_bytes=x_digest.digest();
  return x_digest_bytes;
}","/** 
 * Calculates the parameter x of the SRP-6a algorithm.
 * @param username
 * @param password
 * @param salt the salt of the user
 * @return x
 */
public byte[] calculatePasswordHash(String username,String password,byte[] salt){
  password=password.replaceAll(""String_Node_Str"",""String_Node_Str"");
  MessageDigest x_digest=newDigest();
  byte[] user=null;
  byte[] password_bytes=null;
  byte[] colon={};
  String encoding=""String_Node_Str"";
  try {
    user=Util.trim(username.getBytes(encoding));
    colon=Util.trim(""String_Node_Str"".getBytes(encoding));
    password_bytes=Util.trim(password.getBytes(encoding));
  }
 catch (  UnsupportedEncodingException e) {
    user=Util.trim(username.getBytes());
    colon=Util.trim(""String_Node_Str"".getBytes());
    password_bytes=Util.trim(password.getBytes());
  }
  x_digest.update(user);
  x_digest.update(colon);
  x_digest.update(password_bytes);
  byte[] h=x_digest.digest();
  String hstr=new BigInteger(1,h).toString(16);
  x_digest.reset();
  x_digest.update(salt);
  x_digest.update(h);
  byte[] x_digest_bytes=x_digest.digest();
  return x_digest_bytes;
}",0.891989198919892
109700,"/** 
 * Calculates the parameter M1, to be sent to the SRP server. It also updates hashes of client and server for further calculations in other methods. It uses a predefined k.
 * @param salt_bytes
 * @param Bbytes the parameter received from the server, in bytes
 * @return the parameter M1
 * @throws NoSuchAlgorithmException
 */
public byte[] response(byte[] salt_bytes,byte[] Bbytes) throws NoSuchAlgorithmException {
  byte[] xb=calculatePasswordHash(username,password,salt_bytes);
  this.x=new BigInteger(1,xb);
  String k_string=""String_Node_Str"";
  this.v=calculateV(k_string);
  byte[] digest_of_n=newDigest().digest(N_bytes);
  byte[] digest_of_g=newDigest().digest(params.g);
  byte[] xor_digest=xor(digest_of_n,digest_of_g,digest_of_g.length);
  clientHash.update(xor_digest);
  byte[] username_digest=newDigest().digest(Util.trim(username.getBytes()));
  username_digest=Util.trim(username_digest);
  clientHash.update(username_digest);
  clientHash.update(Util.trim(salt_bytes));
  K=null;
  byte[] Abytes=Util.trim(A.toByteArray());
  clientHash.update(Abytes);
  Bbytes=Util.trim(Bbytes);
  clientHash.update(Bbytes);
  BigInteger S=calculateS(Bbytes);
  byte[] S_bytes=Util.trim(S.toByteArray());
  String hash_algorithm=params.hashAlgorithm;
  MessageDigest sessionDigest=MessageDigest.getInstance(hash_algorithm);
  K=Util.trim(sessionDigest.digest(S_bytes));
  clientHash.update(K);
  byte[] M1=Util.trim(clientHash.digest());
  serverHash.update(Abytes);
  serverHash.update(M1);
  serverHash.update(K);
  return M1;
}","/** 
 * Calculates the parameter M1, to be sent to the SRP server. It also updates hashes of client and server for further calculations in other methods. It uses a predefined k.
 * @param salt_bytes
 * @param Bbytes the parameter received from the server, in bytes
 * @return the parameter M1
 * @throws NoSuchAlgorithmException
 */
public byte[] response(byte[] salt_bytes,byte[] Bbytes) throws NoSuchAlgorithmException {
  byte[] xb=calculatePasswordHash(username,password,Util.trim(salt_bytes));
  this.x=new BigInteger(1,xb);
  String xstr=x.toString(16);
  String k_string=""String_Node_Str"";
  this.v=calculateV(k_string);
  byte[] digest_of_n=newDigest().digest(N_bytes);
  byte[] digest_of_g=newDigest().digest(params.g);
  byte[] xor_digest=xor(digest_of_n,digest_of_g,digest_of_g.length);
  clientHash.update(xor_digest);
  byte[] username_digest=newDigest().digest(Util.trim(username.getBytes()));
  username_digest=Util.trim(username_digest);
  clientHash.update(username_digest);
  clientHash.update(Util.trim(salt_bytes));
  K=null;
  byte[] Abytes=Util.trim(A.toByteArray());
  clientHash.update(Abytes);
  Bbytes=Util.trim(Bbytes);
  clientHash.update(Bbytes);
  BigInteger S=calculateS(Bbytes);
  byte[] S_bytes=Util.trim(S.toByteArray());
  String Sstr=S.toString(16);
  String hash_algorithm=params.hashAlgorithm;
  MessageDigest sessionDigest=MessageDigest.getInstance(hash_algorithm);
  K=Util.trim(sessionDigest.digest(S_bytes));
  clientHash.update(K);
  String Kstr=new BigInteger(1,K).toString(16);
  byte[] M1=Util.trim(clientHash.digest());
  String M1str=new BigInteger(1,M1).toString(16);
  serverHash.update(Abytes);
  serverHash.update(M1);
  serverHash.update(K);
  return M1;
}",0.8907356109572176
109701,"/** 
 * Calculates the parameter x of the SRP-6a algorithm.
 * @param username
 * @param password
 * @param salt the salt of the user
 * @return x
 */
public byte[] calculatePasswordHash(String username,String password,byte[] salt){
  password=password.replaceAll(""String_Node_Str"",""String_Node_Str"");
  MessageDigest x_digest=newDigest();
  byte[] user=null;
  byte[] password_bytes=null;
  byte[] colon={};
  try {
    user=Util.trim(username.getBytes(""String_Node_Str""));
    colon=Util.trim(""String_Node_Str"".getBytes(""String_Node_Str""));
    password_bytes=Util.trim(password.getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException e) {
    user=Util.trim(username.getBytes());
    colon=Util.trim(""String_Node_Str"".getBytes());
    password_bytes=Util.trim(password.getBytes());
  }
  x_digest.update(user);
  x_digest.update(colon);
  x_digest.update(password_bytes);
  byte[] h=x_digest.digest();
  x_digest.reset();
  x_digest.update(salt);
  x_digest.update(h);
  byte[] x_digest_bytes=x_digest.digest();
  return x_digest_bytes;
}","/** 
 * Calculates the parameter x of the SRP-6a algorithm.
 * @param username
 * @param password
 * @param salt the salt of the user
 * @return x
 */
public byte[] calculatePasswordHash(String username,String password,byte[] salt){
  password=password.replaceAll(""String_Node_Str"",""String_Node_Str"");
  MessageDigest x_digest=newDigest();
  byte[] user=null;
  byte[] password_bytes=null;
  byte[] colon={};
  try {
    user=Util.trim(username.getBytes(""String_Node_Str""));
    colon=Util.trim(""String_Node_Str"".getBytes(""String_Node_Str""));
    password_bytes=Util.trim(password.getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException e) {
    user=Util.trim(username.getBytes());
    colon=Util.trim(""String_Node_Str"".getBytes());
    password_bytes=Util.trim(password.getBytes());
  }
  x_digest.update(user);
  x_digest.update(colon);
  x_digest.update(password_bytes);
  byte[] h=x_digest.digest();
  String hstr=new BigInteger(1,h).toString(16);
  x_digest.reset();
  x_digest.update(salt);
  x_digest.update(h);
  byte[] x_digest_bytes=x_digest.digest();
  return x_digest_bytes;
}",0.977818853974122
109702,"/** 
 * It calculates the parameter S used by response() to obtain session hash K.
 * @param Bbytes the parameter received from the server, in bytes
 * @return the parameter S
 */
private BigInteger calculateS(byte[] Bbytes){
  byte[] Abytes=Util.trim(A.toByteArray());
  Bbytes=Util.trim(Bbytes);
  byte[] u_bytes=getU(Abytes,Bbytes);
  BigInteger B=new BigInteger(1,Bbytes);
  BigInteger u=new BigInteger(1,u_bytes);
  BigInteger B_minus_v=B.subtract(v);
  BigInteger a_ux=a.add(u.multiply(x));
  BigInteger S=B_minus_v.modPow(a_ux,N);
  return S;
}","/** 
 * It calculates the parameter S used by response() to obtain session hash K.
 * @param Bbytes the parameter received from the server, in bytes
 * @return the parameter S
 */
private BigInteger calculateS(byte[] Bbytes){
  byte[] Abytes=Util.trim(A.toByteArray());
  Bbytes=Util.trim(Bbytes);
  byte[] u_bytes=getU(Abytes,Bbytes);
  BigInteger B=new BigInteger(1,Bbytes);
  BigInteger u=new BigInteger(1,u_bytes);
  BigInteger B_minus_v=B.subtract(v);
  String vstr=v.toString(16);
  BigInteger a_ux=a.add(u.multiply(x));
  String xstr=x.toString(16);
  BigInteger S=B_minus_v.modPow(a_ux,N);
  return S;
}",0.9483648881239244
109703,"private String getStringFromProvider(String string_url,boolean danger_on){
  String json_file_content=""String_Node_Str"";
  URL provider_url=null;
  try {
    provider_url=new URL(string_url);
    json_file_content=new Scanner(provider_url.openStream()).useDelimiter(""String_Node_Str"").next();
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    if (provider_url != null && danger_on) {
      json_file_content=getStringFromProviderWithoutValidate(provider_url);
    }
    e.printStackTrace();
  }
  return json_file_content;
}","private String getStringFromProvider(String string_url,boolean danger_on){
  String json_file_content=""String_Node_Str"";
  URL provider_url=null;
  int seconds_of_timeout=1;
  try {
    provider_url=new URL(string_url);
    URLConnection url_connection=provider_url.openConnection();
    url_connection.setConnectTimeout(seconds_of_timeout * 1000);
    json_file_content=new Scanner(url_connection.getInputStream()).useDelimiter(""String_Node_Str"").next();
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  SocketTimeoutException e) {
    return ""String_Node_Str"";
  }
catch (  IOException e) {
    if (provider_url != null && danger_on) {
      json_file_content=getStringFromProviderWithoutValidate(provider_url);
    }
    e.printStackTrace();
  }
catch (  Exception e) {
    e.printStackTrace();
  }
  return json_file_content;
}",0.7777003484320557
109704,"@Override public void saveProvider(String provider_url){
  providerAPI_result_receiver=new ProviderAPIResultReceiver(new Handler());
  providerAPI_result_receiver.setReceiver(this);
  Intent provider_API_command=new Intent(this,ProviderAPI.class);
  Bundle method_and_parameters=new Bundle();
  method_and_parameters.putString(ConfigHelper.provider_key_url,provider_url);
  provider_API_command.putExtra(ConfigHelper.downloadNewProviderDotJSON,method_and_parameters);
  provider_API_command.putExtra(""String_Node_Str"",providerAPI_result_receiver);
  startService(provider_API_command);
}","@Override public void saveProvider(String provider_main_url){
  providerAPI_result_receiver=new ProviderAPIResultReceiver(new Handler());
  providerAPI_result_receiver.setReceiver(this);
  Intent provider_API_command=new Intent(this,ProviderAPI.class);
  Bundle method_and_parameters=new Bundle();
  method_and_parameters.putString(ConfigHelper.provider_main_url,provider_main_url);
  provider_API_command.putExtra(ConfigHelper.downloadNewProviderDotJSON,method_and_parameters);
  provider_API_command.putExtra(""String_Node_Str"",providerAPI_result_receiver);
  startService(provider_API_command);
}",0.9856540084388186
109705,"@Override protected void onHandleIntent(Intent task_for){
  final ResultReceiver receiver=task_for.getParcelableExtra(""String_Node_Str"");
  Bundle task;
  if ((task=task_for.getBundleExtra(ConfigHelper.downloadJsonFilesBundleExtra)) != null) {
    if (!downloadJsonFiles(task))     receiver.send(ConfigHelper.INCORRECTLY_DOWNLOADED_JSON_FILES,Bundle.EMPTY);
 else     receiver.send(ConfigHelper.CORRECTLY_DOWNLOADED_JSON_FILES,Bundle.EMPTY);
  }
 else   if ((task=task_for.getBundleExtra(ConfigHelper.downloadNewProviderDotJSON)) != null) {
    if (downloadJsonFilesBundleExtra(task))     receiver.send(ConfigHelper.CORRECTLY_DOWNLOADED_JSON_FILES,Bundle.EMPTY);
 else     receiver.send(ConfigHelper.INCORRECTLY_DOWNLOADED_JSON_FILES,Bundle.EMPTY);
  }
}","@Override protected void onHandleIntent(Intent task_for){
  final ResultReceiver receiver=task_for.getParcelableExtra(""String_Node_Str"");
  Bundle task;
  if ((task=task_for.getBundleExtra(ConfigHelper.downloadJsonFilesBundleExtra)) != null) {
    if (!downloadJsonFiles(task))     receiver.send(ConfigHelper.INCORRECTLY_DOWNLOADED_JSON_FILES,Bundle.EMPTY);
 else     receiver.send(ConfigHelper.CORRECTLY_DOWNLOADED_JSON_FILES,Bundle.EMPTY);
  }
 else   if ((task=task_for.getBundleExtra(ConfigHelper.downloadNewProviderDotJSON)) != null) {
    if (downloadNewProviderDotJSON(task))     receiver.send(ConfigHelper.CORRECTLY_DOWNLOADED_JSON_FILES,Bundle.EMPTY);
 else     receiver.send(ConfigHelper.INCORRECTLY_DOWNLOADED_JSON_FILES,Bundle.EMPTY);
  }
}",0.9760956175298804
109706,"private boolean downloadJsonFilesBundleExtra(Bundle task){
  String provider_name=(String)task.get(ConfigHelper.provider_key);
  String cert_url=(String)task.get(ConfigHelper.cert_key);
  String eip_service_json_url=(String)task.get(ConfigHelper.eip_service_key);
  try {
    URL cacert=new URL(cert_url);
    ConfigHelper.addTrustedCertificate(provider_name,cacert.openStream());
    JSONObject eip_service_json=getJSONFromProvider(eip_service_json_url);
    ConfigHelper.saveSharedPref(ConfigHelper.eip_service_key,eip_service_json);
    return true;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    ConfigHelper.rescueJSONException(e);
    return false;
  }
catch (  Exception e) {
    e.printStackTrace();
    return false;
  }
}","private boolean downloadJsonFilesBundleExtra(Bundle task){
  String provider_main_url=(String)task.get(ConfigHelper.provider_main_url);
  String provider_name=ConfigHelper.extractProviderName(provider_main_url);
  String cert_url=(String)task.get(ConfigHelper.cert_key);
  String eip_service_json_url=(String)task.get(ConfigHelper.eip_service_key);
  try {
    URL cacert=new URL(cert_url);
    ConfigHelper.addTrustedCertificate(provider_name,cacert.openStream());
    JSONObject eip_service_json=getJSONFromProvider(eip_service_json_url);
    ConfigHelper.saveSharedPref(ConfigHelper.eip_service_key,eip_service_json);
    return true;
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
catch (  JSONException e) {
    ConfigHelper.rescueJSONException(e);
    return false;
  }
catch (  Exception e) {
    e.printStackTrace();
    return false;
  }
}",0.9420203227734608
109707,"private boolean downloadNewProviderDotJSON(Bundle task){
  boolean custom=true;
  String provider_main_url=(String)task.get(ConfigHelper.provider_key_url);
  String provider_name=provider_main_url.replaceFirst(""String_Node_Str"",""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str"");
  String provider_json_url=guessURL(provider_main_url);
  JSONObject provider_json=null;
  try {
    provider_json=getJSONFromProvider(provider_json_url);
  }
 catch (  IOException e) {
    provider_json=downloadNewProviderDotJsonWithoutCert(provider_json_url);
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
  if (provider_json == null) {
    return false;
  }
 else {
    String filename=provider_name + ""String_Node_Str"".replaceFirst(""String_Node_Str"",""String_Node_Str"");
    ConfigHelper.saveFile(filename,provider_json.toString());
    ProviderListContent.addItem(new ProviderItem(provider_name,ConfigHelper.openFileInputStream(filename),custom));
    return true;
  }
}","private boolean downloadNewProviderDotJSON(Bundle task){
  boolean custom=true;
  String provider_main_url=(String)task.get(ConfigHelper.provider_main_url);
  String provider_name=provider_main_url.replaceFirst(""String_Node_Str"",""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str"");
  String provider_json_url=guessURL(provider_main_url);
  JSONObject provider_json=null;
  try {
    provider_json=getJSONFromProvider(provider_json_url);
  }
 catch (  IOException e) {
    provider_json=downloadNewProviderDotJsonWithoutCert(provider_json_url);
  }
catch (  JSONException e) {
    e.printStackTrace();
    return false;
  }
  if (provider_json == null) {
    return false;
  }
 else {
    String filename=provider_name + ""String_Node_Str"".replaceFirst(""String_Node_Str"",""String_Node_Str"");
    ConfigHelper.saveFile(filename,provider_json.toString());
    ConfigHelper.saveSharedPref(ConfigHelper.provider_key,provider_json);
    ProviderListContent.addItem(new ProviderItem(provider_name,ConfigHelper.openFileInputStream(filename),custom));
    return true;
  }
}",0.9611510791366906
109708,"@Override public void onReceiveResult(int resultCode,Bundle resultData){
  if (resultCode == ConfigHelper.CUSTOM_PROVIDER_ADDED) {
    ProviderListFragment providerList=new ProviderListFragment();
    FragmentManager fragmentManager=getFragmentManager();
    fragmentManager.beginTransaction().replace(R.id.configuration_wizard_layout,providerList,""String_Node_Str"").commit();
  }
 else   if (resultCode == ConfigHelper.CORRECTLY_DOWNLOADED_JSON_FILES) {
    setResult(RESULT_OK);
    finish();
  }
 else   if (resultCode == ConfigHelper.INCORRECTLY_DOWNLOADED_JSON_FILES) {
    setResult(RESULT_CANCELED);
    finish();
  }
}","@Override public void onReceiveResult(int resultCode,Bundle resultData){
  if (resultCode == ConfigHelper.CUSTOM_PROVIDER_ADDED) {
    ProviderListFragment providerList=new ProviderListFragment();
    FragmentManager fragmentManager=getFragmentManager();
    fragmentManager.beginTransaction().replace(R.id.configuration_wizard_layout,providerList,""String_Node_Str"").commit();
  }
 else   if (resultCode == ConfigHelper.CORRECTLY_DOWNLOADED_JSON_FILES) {
    setResult(RESULT_OK);
    finish();
  }
 else   if (resultCode == ConfigHelper.INCORRECTLY_DOWNLOADED_JSON_FILES) {
    setResult(RESULT_CANCELED);
    Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_LONG).show();
  }
}",0.93815987933635
109709,"private JSONObject downloadNewProviderDotJsonWithoutCert(String provider_json_url){
  JSONObject provider_json=null;
  try {
    URL provider_url=new URL(provider_json_url);
    String provider_json_string=new Scanner(provider_url.openStream()).useDelimiter(""String_Node_Str"").next();
    provider_json=new JSONObject(provider_json_string);
  }
 catch (  MalformedURLException e1) {
    e1.printStackTrace();
  }
catch (  IOException e1) {
    e1.printStackTrace();
  }
catch (  JSONException e1) {
    e1.printStackTrace();
  }
  return provider_json;
}","private JSONObject downloadNewProviderDotJsonWithoutCert(String provider_json_url){
  JSONObject provider_json=null;
  try {
    URL provider_url=new URL(provider_json_url);
    String provider_json_string=new Scanner(provider_url.openStream()).useDelimiter(""String_Node_Str"").next();
    provider_json=new JSONObject(provider_json_string);
  }
 catch (  MalformedURLException e1) {
    e1.printStackTrace();
  }
catch (  UnknownHostException e1) {
    e1.printStackTrace();
  }
catch (  IOException e1) {
    e1.printStackTrace();
  }
catch (  JSONException e1) {
    e1.printStackTrace();
  }
  return provider_json;
}",0.9437819420783644
109710,"/** 
 * Callback method from   {@link ProviderListFragment.Callbacks}indicating that the item with the given ID was selected.
 */
@Override public void onItemSelected(String id){
  if (mTwoPane) {
  }
 else {
    Iterator<ProviderItem> preseeded_providers_iterator=ProviderListContent.ITEMS.iterator();
    while (preseeded_providers_iterator.hasNext()) {
      ProviderItem current_provider_item=preseeded_providers_iterator.next();
      if (current_provider_item.id.equalsIgnoreCase(id)) {
        try {
          if (current_provider_item.custom)           processAssetsFiles(current_provider_item);
          downloadJSONFiles(current_provider_item);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    setResult(RESULT_OK);
    finish();
  }
}","/** 
 * Callback method from   {@link ProviderListFragment.Callbacks}indicating that the item with the given ID was selected.
 */
@Override public void onItemSelected(String id){
  if (mTwoPane) {
  }
 else {
    Iterator<ProviderItem> preseeded_providers_iterator=ProviderListContent.ITEMS.iterator();
    while (preseeded_providers_iterator.hasNext()) {
      ProviderItem current_provider_item=preseeded_providers_iterator.next();
      if (current_provider_item.id.equalsIgnoreCase(id)) {
        try {
          if (!current_provider_item.custom)           processAssetsFiles(current_provider_item);
          downloadJSONFiles(current_provider_item);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
    setResult(RESULT_OK);
    finish();
  }
}",0.9993746091307066
109711,"public ProviderItem(String name,FileInputStream provider_json,boolean custom){
  try {
    byte[] urls_file_bytes=new byte[provider_json.available()];
    provider_json.read(urls_file_bytes);
    String urls_file_content=new String(urls_file_bytes);
    JSONObject file_contents=new JSONObject(urls_file_content);
    id=name;
    this.name=name;
    eip_service_json_url=(String)file_contents.get(""String_Node_Str"") + ConfigHelper.eip_service_api_path;
    cert_json_url=(String)file_contents.get(""String_Node_Str"");
  }
 catch (  JSONException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}","public ProviderItem(String name,FileInputStream provider_json,boolean custom){
  try {
    byte[] urls_file_bytes=new byte[provider_json.available()];
    provider_json.read(urls_file_bytes);
    String urls_file_content=new String(urls_file_bytes);
    JSONObject file_contents=new JSONObject(urls_file_content);
    id=name;
    this.name=name;
    eip_service_json_url=(String)file_contents.get(""String_Node_Str"") + ConfigHelper.eip_service_api_path;
    cert_json_url=(String)file_contents.get(""String_Node_Str"");
    this.custom=custom;
  }
 catch (  JSONException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9814814814814816
109712,"private void embedPKCS12File(){
  mResult.mPKCS12Filename=embedFile(mResult.mPKCS12Filename,true);
  if (mResult.mPKCS12Filename.startsWith(VpnProfile.INLINE_TAG)) {
    if (mResult.mAuthenticationType == VpnProfile.TYPE_USERPASS_KEYSTORE)     mResult.mAuthenticationType=VpnProfile.TYPE_USERPASS_PKCS12;
    if (mResult.mAuthenticationType == VpnProfile.TYPE_KEYSTORE)     mResult.mAuthenticationType=VpnProfile.TYPE_PKCS12;
  }
}","private void embedPKCS12File(){
  mResult.mPKCS12Filename=embedFile(mResult.mPKCS12Filename,true);
  if (mResult.mPKCS12Filename != null && mResult.mPKCS12Filename.startsWith(VpnProfile.INLINE_TAG)) {
    if (mResult.mAuthenticationType == VpnProfile.TYPE_USERPASS_KEYSTORE)     mResult.mAuthenticationType=VpnProfile.TYPE_USERPASS_PKCS12;
    if (mResult.mAuthenticationType == VpnProfile.TYPE_KEYSTORE)     mResult.mAuthenticationType=VpnProfile.TYPE_PKCS12;
  }
}",0.9609810479375696
109713,"private Vector<Vector<String>> getAllOption(String option,int minarg,int maxarg) throws ConfigParseError {
  Vector<Vector<String>> args=options.get(option);
  if (args == null)   return null;
  for (  Vector<String> optionline : args)   if (optionline.size() < (minarg + 1) || optionline.size() > maxarg + 1) {
    String err=String.format(""String_Node_Str"",option,optionline.size() - 1,minarg,maxarg);
    throw new ConfigParseError(err);
  }
  options.remove(option);
  return args;
}","private Vector<Vector<String>> getAllOption(String option,int minarg,int maxarg) throws ConfigParseError {
  Vector<Vector<String>> args=options.get(option);
  if (args == null)   return null;
  for (  Vector<String> optionline : args)   if (optionline.size() < (minarg + 1) || optionline.size() > maxarg + 1) {
    String err=String.format(Locale.getDefault(),""String_Node_Str"",option,optionline.size() - 1,minarg,maxarg);
    throw new ConfigParseError(err);
  }
  options.remove(option);
  return args;
}",0.9798792756539236
109714,"private boolean space(char c){
  return Character.isSpace(c) || c == '\0';
}","private boolean space(char c){
  return Character.isWhitespace(c) || c == '\0';
}",0.9554140127388536
109715,"@Override public void updateState(String state,String logmessage){
  if (mProcessThread == null)   return;
  if (""String_Node_Str"".equals(state)) {
    if (mDisplayBytecount) {
      showNotification(logmessage,null,true,mConnecttime);
    }
  }
 else {
    if (""String_Node_Str"".equals(state)) {
      mDisplayBytecount=true;
      mConnecttime=System.currentTimeMillis();
    }
 else {
      mDisplayBytecount=false;
    }
    String ticker=state.toLowerCase();
    showNotification(state + ""String_Node_Str"" + logmessage,ticker,false,0);
  }
}","@Override public void updateState(String state,String logmessage){
  if (mProcessThread == null)   return;
  if (""String_Node_Str"".equals(state)) {
    if (mDisplayBytecount) {
      showNotification(logmessage,null,true,mConnecttime);
    }
  }
 else {
    if (""String_Node_Str"".equals(state)) {
      mDisplayBytecount=true;
      mConnecttime=System.currentTimeMillis();
    }
 else {
      mDisplayBytecount=false;
    }
    String ticker=state.toLowerCase(Locale.getDefault());
    showNotification(state + ""String_Node_Str"" + logmessage,ticker,false,0);
  }
}",0.9828982898289828
109716,"private void showNotification(String msg,String tickerText,boolean lowpriority,long when){
  String ns=Context.NOTIFICATION_SERVICE;
  NotificationManager mNotificationManager=(NotificationManager)getSystemService(ns);
  int icon=R.drawable.ic_stat_vpn;
  android.app.Notification.Builder nbuilder=new Notification.Builder(this);
  nbuilder.setContentTitle(""String_Node_Str"" + mProfile.mName);
  nbuilder.setContentText(msg);
  nbuilder.setOnlyAlertOnce(true);
  nbuilder.setOngoing(true);
  nbuilder.setContentIntent(getLogPendingIntent());
  nbuilder.setSmallIcon(icon);
  if (when != 0)   nbuilder.setWhen(when);
  jbNotificationExtras(lowpriority,nbuilder);
  if (tickerText != null)   nbuilder.setTicker(tickerText);
  Notification notification=nbuilder.getNotification();
  mNotificationManager.notify(OPENVPN_STATUS,notification);
  startForeground(OPENVPN_STATUS,notification);
}","private void showNotification(String msg,String tickerText,boolean lowpriority,long when){
  String ns=Context.NOTIFICATION_SERVICE;
  NotificationManager mNotificationManager=(NotificationManager)getSystemService(ns);
  int icon=R.drawable.ic_stat_vpn;
  android.app.Notification.Builder nbuilder=new Notification.Builder(this);
  nbuilder.setContentTitle(""String_Node_Str"" + mProfile.mName);
  nbuilder.setContentText(msg);
  nbuilder.setOnlyAlertOnce(true);
  nbuilder.setOngoing(true);
  nbuilder.setContentIntent(getLogPendingIntent());
  nbuilder.setSmallIcon(icon);
  if (when != 0)   nbuilder.setWhen(when);
  jbNotificationExtras(lowpriority,nbuilder);
  if (tickerText != null)   nbuilder.setTicker(tickerText);
  @SuppressWarnings(""String_Node_Str"") Notification notification=nbuilder.getNotification();
  mNotificationManager.notify(OPENVPN_STATUS,notification);
  startForeground(OPENVPN_STATUS,notification);
}",0.9795692987299834
109717,"private String embedFile(String filename,boolean base64encode){
  if (filename == null)   return null;
  if (filename.startsWith(VpnProfile.INLINE_TAG))   return filename;
  File possibleFile=findFile(filename);
  if (possibleFile == null)   return null;
 else   return readFileContent(possibleFile,base64encode);
}","private String embedFile(String filename,boolean base64encode){
  if (filename == null)   return null;
  if (filename.startsWith(VpnProfile.INLINE_TAG))   return filename;
  File possibleFile=findFile(filename);
  if (possibleFile == null)   return filename;
 else   return readFileContent(possibleFile,base64encode);
}",0.9810725552050472
109718,"private void startOpenVPNThreadArgs(String[] argv){
  LinkedList<String> argvlist=new LinkedList<String>();
  for (  String arg : argv)   argvlist.add(arg);
  ProcessBuilder pb=new ProcessBuilder(argvlist);
  String applibpath=argv[0].replace(""String_Node_Str"" + VpnProfile.MINIVPN,""String_Node_Str"");
  String lbpath=pb.environment().get(""String_Node_Str"");
  if (lbpath == null)   lbpath=applibpath;
 else   lbpath=lbpath + ""String_Node_Str"" + applibpath;
  if (!applibpath.equals(mNativeDir)) {
    lbpath=lbpath + ""String_Node_Str"" + mNativeDir;
  }
  pb.environment().put(""String_Node_Str"",lbpath);
  pb.redirectErrorStream(true);
  try {
    mProcess=pb.start();
    mProcess.getOutputStream().close();
    InputStream in=mProcess.getInputStream();
    BufferedReader br=new BufferedReader(new InputStreamReader(in));
    while (true) {
      String logline=br.readLine();
      if (logline == null)       return;
      OpenVPN.logMessage(0,""String_Node_Str"",logline);
    }
  }
 catch (  IOException e) {
    OpenVPN.logMessage(0,""String_Node_Str"",""String_Node_Str"" + e.getLocalizedMessage());
    e.printStackTrace();
    stopProcess();
  }
}","private void startOpenVPNThreadArgs(String[] argv){
  LinkedList<String> argvlist=new LinkedList<String>();
  for (  String arg : argv)   argvlist.add(arg);
  ProcessBuilder pb=new ProcessBuilder(argvlist);
  String applibpath=argv[0].replace(""String_Node_Str"" + VpnProfile.MINIVPN,""String_Node_Str"");
  String lbpath=pb.environment().get(""String_Node_Str"");
  if (lbpath == null)   lbpath=applibpath;
 else   lbpath=lbpath + ""String_Node_Str"" + applibpath;
  if (!applibpath.equals(mNativeDir)) {
    lbpath=lbpath + ""String_Node_Str"" + mNativeDir;
  }
  pb.environment().put(""String_Node_Str"",lbpath);
  pb.redirectErrorStream(true);
  try {
    mProcess=pb.start();
    mProcess.getOutputStream().close();
    InputStream in=mProcess.getInputStream();
    BufferedReader br=new BufferedReader(new InputStreamReader(in));
    while (true) {
      String logline=br.readLine();
      if (logline == null) {
        return;
      }
      OpenVPN.logMessage(0,""String_Node_Str"",logline);
    }
  }
 catch (  IOException e) {
    OpenVPN.logMessage(0,""String_Node_Str"",""String_Node_Str"" + e.getLocalizedMessage());
    e.printStackTrace();
    stopProcess();
  }
}",0.9835640138408304
109719,"@Override public void run(){
  try {
    Log.i(TAG,""String_Node_Str"");
    startOpenVPNThreadArgs(mArgv);
    Log.i(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"" + e.toString());
  }
 finally {
    int exitvalue=0;
    try {
      exitvalue=mProcess.exitValue();
    }
 catch (    IllegalThreadStateException ite) {
      OpenVPN.logError(""String_Node_Str"" + ite.getLocalizedMessage());
    }
    if (exitvalue != 0)     OpenVPN.logError(""String_Node_Str"" + exitvalue);
    OpenVPN.updateStateString(""String_Node_Str"",""String_Node_Str"");
    mService.processDied();
    Log.i(TAG,""String_Node_Str"");
  }
}","@Override public void run(){
  try {
    Log.i(TAG,""String_Node_Str"");
    startOpenVPNThreadArgs(mArgv);
    Log.i(TAG,""String_Node_Str"");
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"" + e.toString());
  }
 finally {
    int exitvalue=0;
    try {
      exitvalue=mProcess.waitFor();
    }
 catch (    IllegalThreadStateException ite) {
      OpenVPN.logError(""String_Node_Str"" + ite.getLocalizedMessage());
    }
catch (    InterruptedException ie) {
      OpenVPN.logError(""String_Node_Str"" + ie.getLocalizedMessage());
    }
    if (exitvalue != 0)     OpenVPN.logError(""String_Node_Str"" + exitvalue);
    OpenVPN.updateStateString(""String_Node_Str"",""String_Node_Str"");
    mService.processDied();
    Log.i(TAG,""String_Node_Str"");
  }
}",0.9071428571428573
109720,"VpnProfile convertProfile() throws ConfigParseError {
  boolean noauthtypeset=true;
  VpnProfile np=new VpnProfile(""String_Node_Str"");
  np.clearDefaults();
  if (options.containsKey(""String_Node_Str"") || options.containsKey(""String_Node_Str"")) {
    np.mUsePull=true;
    options.remove(""String_Node_Str"");
    options.remove(""String_Node_Str"");
  }
  Vector<String> secret=getOption(""String_Node_Str"",1,2);
  if (secret != null) {
    np.mAuthenticationType=VpnProfile.TYPE_STATICKEYS;
    noauthtypeset=false;
    np.mUseTLSAuth=true;
    np.mTLSAuthFilename=secret.get(1);
    if (secret.size() == 3)     np.mTLSAuthDirection=secret.get(2);
  }
  Vector<Vector<String>> routes=getAllOption(""String_Node_Str"",1,4);
  if (routes != null) {
    String routeopt=""String_Node_Str"";
    for (    Vector<String> route : routes) {
      String netmask=""String_Node_Str"";
      if (route.size() >= 3)       netmask=route.get(2);
      String net=route.get(1);
      try {
        CIDRIP cidr=new CIDRIP(net,netmask);
        routeopt+=cidr.toString() + ""String_Node_Str"";
      }
 catch (      ArrayIndexOutOfBoundsException aioob) {
        throw new ConfigParseError(""String_Node_Str"" + netmask);
      }
    }
    np.mCustomRoutes=routeopt;
  }
  Vector<Vector<String>> tlsauthoptions=getAllOption(""String_Node_Str"",1,2);
  if (tlsauthoptions != null) {
    for (    Vector<String> tlsauth : tlsauthoptions) {
      if (tlsauth != null) {
        if (!tlsauth.get(1).equals(""String_Node_Str"")) {
          np.mTLSAuthFilename=tlsauth.get(1);
          np.mUseTLSAuth=true;
        }
        if (tlsauth.size() == 3)         np.mTLSAuthDirection=tlsauth.get(2);
      }
    }
  }
  Vector<String> direction=getOption(""String_Node_Str"",1,1);
  if (direction != null)   np.mTLSAuthDirection=direction.get(1);
  if (getAllOption(""String_Node_Str"",0,5) != null)   np.mUseDefaultRoute=true;
  Vector<String> dev=getOption(""String_Node_Str"",1,1);
  Vector<String> devtype=getOption(""String_Node_Str"",1,1);
  if ((devtype != null && devtype.get(1).equals(""String_Node_Str"")) || (dev != null && dev.get(1).startsWith(""String_Node_Str"")) || (devtype == null && dev == null)) {
  }
 else {
    throw new ConfigParseError(""String_Node_Str"");
  }
  Vector<String> mode=getOption(""String_Node_Str"",1,1);
  if (mode != null) {
    if (!mode.get(1).equals(""String_Node_Str""))     throw new ConfigParseError(""String_Node_Str"");
  }
  Vector<String> remote=getOption(""String_Node_Str"",1,3);
  if (remote != null) {
switch (remote.size()) {
case 4:
      String proto=remote.get(3);
    if (proto.equals(""String_Node_Str""))     np.mUseUdp=true;
 else     if (proto.equals(""String_Node_Str""))     np.mUseUdp=false;
 else     throw new ConfigParseError(""String_Node_Str"");
case 3:
  np.mServerPort=remote.get(2);
case 2:
np.mServerName=remote.get(1);
}
}
Vector<String> port=getOption(""String_Node_Str"",1,1);
if (port != null) {
np.mServerPort=port.get(1);
}
Vector<String> proto=getOption(""String_Node_Str"",1,1);
if (proto != null) {
if (proto.get(1).equals(""String_Node_Str"")) np.mUseUdp=true;
 else if (proto.get(1).equals(""String_Node_Str"") || proto.get(1).equals(""String_Node_Str"")) np.mUseUdp=false;
 else throw new ConfigParseError(""String_Node_Str"" + proto.get(1));
}
Vector<Vector<String>> dhcpoptions=getAllOption(""String_Node_Str"",2,2);
if (dhcpoptions != null) {
for (Vector<String> dhcpoption : dhcpoptions) {
String type=dhcpoption.get(1);
String arg=dhcpoption.get(2);
if (type.equals(""String_Node_Str"")) {
np.mSearchDomain=dhcpoption.get(2);
}
 else if (type.equals(""String_Node_Str"")) {
np.mOverrideDNS=true;
if (np.mDNS1.equals(VpnProfile.DEFAULT_DNS1)) np.mDNS1=arg;
 else np.mDNS2=arg;
}
}
}
Vector<String> ifconfig=getOption(""String_Node_Str"",2,2);
if (ifconfig != null) {
CIDRIP cidr=new CIDRIP(ifconfig.get(1),ifconfig.get(2));
np.mIPv4Address=cidr.toString();
}
if (getOption(""String_Node_Str"",0,0) != null) np.mUseRandomHostname=true;
if (getOption(""String_Node_Str"",0,0) != null) np.mUseFloat=true;
if (getOption(""String_Node_Str"",0,1) != null) np.mUseLzo=true;
Vector<String> cipher=getOption(""String_Node_Str"",1,1);
if (cipher != null) np.mCipher=cipher.get(1);
Vector<String> ca=getOption(""String_Node_Str"",1,1);
if (ca != null) {
np.mCaFilename=ca.get(1);
}
Vector<String> cert=getOption(""String_Node_Str"",1,1);
if (cert != null) {
np.mClientCertFilename=cert.get(1);
np.mAuthenticationType=VpnProfile.TYPE_CERTIFICATES;
noauthtypeset=false;
}
Vector<String> key=getOption(""String_Node_Str"",1,1);
if (key != null) np.mClientKeyFilename=key.get(1);
Vector<String> pkcs12=getOption(""String_Node_Str"",1,1);
if (pkcs12 != null) {
np.mPKCS12Filename=pkcs12.get(1);
np.mAuthenticationType=VpnProfile.TYPE_KEYSTORE;
noauthtypeset=false;
}
Vector<String> tlsremote=getOption(""String_Node_Str"",1,1);
if (tlsremote != null) {
np.mRemoteCN=tlsremote.get(1);
np.mCheckRemoteCN=true;
}
Vector<String> verb=getOption(""String_Node_Str"",1,1);
if (verb != null) {
np.mVerb=verb.get(1);
}
if (getOption(""String_Node_Str"",0,0) != null) np.mNobind=true;
if (getOption(""String_Node_Str"",0,0) != null) np.mPersistTun=true;
Vector<String> authuser=getOption(""String_Node_Str"",0,1);
if (authuser != null) {
if (noauthtypeset) {
np.mAuthenticationType=VpnProfile.TYPE_USERPASS;
}
 else if (np.mAuthenticationType == VpnProfile.TYPE_CERTIFICATES) {
np.mAuthenticationType=VpnProfile.TYPE_USERPASS_CERTIFICATES;
}
 else if (np.mAuthenticationType == VpnProfile.TYPE_KEYSTORE) {
np.mAuthenticationType=VpnProfile.TYPE_USERPASS_KEYSTORE;
}
if (authuser.size() > 1) {
np.mUsername=authuser.get(1);
}
}
checkIgnoreAndInvalidOptions(np);
fixup(np);
return np;
}","VpnProfile convertProfile() throws ConfigParseError {
  boolean noauthtypeset=true;
  VpnProfile np=new VpnProfile(""String_Node_Str"");
  np.clearDefaults();
  if (options.containsKey(""String_Node_Str"") || options.containsKey(""String_Node_Str"")) {
    np.mUsePull=true;
    options.remove(""String_Node_Str"");
    options.remove(""String_Node_Str"");
  }
  Vector<String> secret=getOption(""String_Node_Str"",1,2);
  if (secret != null) {
    np.mAuthenticationType=VpnProfile.TYPE_STATICKEYS;
    noauthtypeset=false;
    np.mUseTLSAuth=true;
    np.mTLSAuthFilename=secret.get(1);
    if (secret.size() == 3)     np.mTLSAuthDirection=secret.get(2);
  }
  Vector<Vector<String>> routes=getAllOption(""String_Node_Str"",1,4);
  if (routes != null) {
    String routeopt=""String_Node_Str"";
    for (    Vector<String> route : routes) {
      String netmask=""String_Node_Str"";
      if (route.size() >= 3)       netmask=route.get(2);
      String net=route.get(1);
      try {
        CIDRIP cidr=new CIDRIP(net,netmask);
        routeopt+=cidr.toString() + ""String_Node_Str"";
      }
 catch (      ArrayIndexOutOfBoundsException aioob) {
        throw new ConfigParseError(""String_Node_Str"" + netmask);
      }
catch (      NumberFormatException ne) {
        throw new ConfigParseError(""String_Node_Str"" + netmask);
      }
    }
    np.mCustomRoutes=routeopt;
  }
  Vector<Vector<String>> tlsauthoptions=getAllOption(""String_Node_Str"",1,2);
  if (tlsauthoptions != null) {
    for (    Vector<String> tlsauth : tlsauthoptions) {
      if (tlsauth != null) {
        if (!tlsauth.get(1).equals(""String_Node_Str"")) {
          np.mTLSAuthFilename=tlsauth.get(1);
          np.mUseTLSAuth=true;
        }
        if (tlsauth.size() == 3)         np.mTLSAuthDirection=tlsauth.get(2);
      }
    }
  }
  Vector<String> direction=getOption(""String_Node_Str"",1,1);
  if (direction != null)   np.mTLSAuthDirection=direction.get(1);
  if (getAllOption(""String_Node_Str"",0,5) != null)   np.mUseDefaultRoute=true;
  Vector<String> dev=getOption(""String_Node_Str"",1,1);
  Vector<String> devtype=getOption(""String_Node_Str"",1,1);
  if ((devtype != null && devtype.get(1).equals(""String_Node_Str"")) || (dev != null && dev.get(1).startsWith(""String_Node_Str"")) || (devtype == null && dev == null)) {
  }
 else {
    throw new ConfigParseError(""String_Node_Str"");
  }
  Vector<String> mode=getOption(""String_Node_Str"",1,1);
  if (mode != null) {
    if (!mode.get(1).equals(""String_Node_Str""))     throw new ConfigParseError(""String_Node_Str"");
  }
  Vector<String> remote=getOption(""String_Node_Str"",1,3);
  if (remote != null) {
switch (remote.size()) {
case 4:
      String proto=remote.get(3);
    if (proto.equals(""String_Node_Str""))     np.mUseUdp=true;
 else     if (proto.equals(""String_Node_Str""))     np.mUseUdp=false;
 else     throw new ConfigParseError(""String_Node_Str"");
case 3:
  np.mServerPort=remote.get(2);
case 2:
np.mServerName=remote.get(1);
}
}
Vector<String> port=getOption(""String_Node_Str"",1,1);
if (port != null) {
np.mServerPort=port.get(1);
}
Vector<String> proto=getOption(""String_Node_Str"",1,1);
if (proto != null) {
if (proto.get(1).equals(""String_Node_Str"")) np.mUseUdp=true;
 else if (proto.get(1).equals(""String_Node_Str"") || proto.get(1).equals(""String_Node_Str"")) np.mUseUdp=false;
 else throw new ConfigParseError(""String_Node_Str"" + proto.get(1));
}
Vector<Vector<String>> dhcpoptions=getAllOption(""String_Node_Str"",2,2);
if (dhcpoptions != null) {
for (Vector<String> dhcpoption : dhcpoptions) {
String type=dhcpoption.get(1);
String arg=dhcpoption.get(2);
if (type.equals(""String_Node_Str"")) {
np.mSearchDomain=dhcpoption.get(2);
}
 else if (type.equals(""String_Node_Str"")) {
np.mOverrideDNS=true;
if (np.mDNS1.equals(VpnProfile.DEFAULT_DNS1)) np.mDNS1=arg;
 else np.mDNS2=arg;
}
}
}
Vector<String> ifconfig=getOption(""String_Node_Str"",2,2);
if (ifconfig != null) {
CIDRIP cidr=new CIDRIP(ifconfig.get(1),ifconfig.get(2));
np.mIPv4Address=cidr.toString();
}
if (getOption(""String_Node_Str"",0,0) != null) np.mUseRandomHostname=true;
if (getOption(""String_Node_Str"",0,0) != null) np.mUseFloat=true;
if (getOption(""String_Node_Str"",0,1) != null) np.mUseLzo=true;
Vector<String> cipher=getOption(""String_Node_Str"",1,1);
if (cipher != null) np.mCipher=cipher.get(1);
Vector<String> ca=getOption(""String_Node_Str"",1,1);
if (ca != null) {
np.mCaFilename=ca.get(1);
}
Vector<String> cert=getOption(""String_Node_Str"",1,1);
if (cert != null) {
np.mClientCertFilename=cert.get(1);
np.mAuthenticationType=VpnProfile.TYPE_CERTIFICATES;
noauthtypeset=false;
}
Vector<String> key=getOption(""String_Node_Str"",1,1);
if (key != null) np.mClientKeyFilename=key.get(1);
Vector<String> pkcs12=getOption(""String_Node_Str"",1,1);
if (pkcs12 != null) {
np.mPKCS12Filename=pkcs12.get(1);
np.mAuthenticationType=VpnProfile.TYPE_KEYSTORE;
noauthtypeset=false;
}
Vector<String> tlsremote=getOption(""String_Node_Str"",1,1);
if (tlsremote != null) {
np.mRemoteCN=tlsremote.get(1);
np.mCheckRemoteCN=true;
}
Vector<String> verb=getOption(""String_Node_Str"",1,1);
if (verb != null) {
np.mVerb=verb.get(1);
}
if (getOption(""String_Node_Str"",0,0) != null) np.mNobind=true;
if (getOption(""String_Node_Str"",0,0) != null) np.mPersistTun=true;
Vector<String> authuser=getOption(""String_Node_Str"",0,1);
if (authuser != null) {
if (noauthtypeset) {
np.mAuthenticationType=VpnProfile.TYPE_USERPASS;
}
 else if (np.mAuthenticationType == VpnProfile.TYPE_CERTIFICATES) {
np.mAuthenticationType=VpnProfile.TYPE_USERPASS_CERTIFICATES;
}
 else if (np.mAuthenticationType == VpnProfile.TYPE_KEYSTORE) {
np.mAuthenticationType=VpnProfile.TYPE_USERPASS_KEYSTORE;
}
if (authuser.size() > 1) {
np.mUsername=authuser.get(1);
}
}
checkIgnoreAndInvalidOptions(np);
fixup(np);
return np;
}",0.989987704198138
109721,"void embedFiles(){
  mResult.mCaFilename=embedFile(mResult.mCaFilename);
  mResult.mClientCertFilename=embedFile(mResult.mClientCertFilename);
  mResult.mClientKeyFilename=embedFile(mResult.mClientKeyFilename);
  mResult.mTLSAuthFilename=embedFile(mResult.mTLSAuthFilename);
  if (mResult.mUsername != null && !mResult.mUsername.equals(""String_Node_Str"")) {
    String data=embedFile(mResult.mUsername);
    mResult.mName=null;
    if (data != null) {
      data=data.replace(VpnProfile.INLINE_TAG,""String_Node_Str"");
      String[] parts=data.split(""String_Node_Str"");
      if (parts.length >= 2) {
        mResult.mName=parts[0];
        mResult.mPassword=parts[1];
      }
    }
  }
}","void embedFiles(){
  mResult.mCaFilename=embedFile(mResult.mCaFilename);
  mResult.mClientCertFilename=embedFile(mResult.mClientCertFilename);
  mResult.mClientKeyFilename=embedFile(mResult.mClientKeyFilename);
  mResult.mTLSAuthFilename=embedFile(mResult.mTLSAuthFilename);
  if (mResult.mUsername != null && !mResult.mUsername.equals(""String_Node_Str"")) {
    String data=embedFile(mResult.mUsername);
    mResult.mUsername=null;
    if (data != null) {
      data=data.replace(VpnProfile.INLINE_TAG,""String_Node_Str"");
      String[] parts=data.split(""String_Node_Str"");
      if (parts.length >= 2) {
        mResult.mUsername=parts[0];
        mResult.mPassword=parts[1];
      }
    }
  }
}",0.9913294797687862
109722,"private void releaseHoldCmd(){
  mWaitingForRelease=false;
  managmentCommand(""String_Node_Str"");
  managmentCommand(""String_Node_Str"" + mBytecountinterval + ""String_Node_Str"");
  managmentCommand(""String_Node_Str"");
}","private void releaseHoldCmd(){
  mWaitingForRelease=false;
  mReleaseHold=true;
  managmentCommand(""String_Node_Str"");
  managmentCommand(""String_Node_Str"" + mBytecountinterval + ""String_Node_Str"");
  managmentCommand(""String_Node_Str"");
}",0.9540481400437636
109723,"public static String openVpnEscape(String unescaped){
  if (unescaped == null)   return null;
  String escapedString=unescaped.replace(""String_Node_Str"",""String_Node_Str"");
  escapedString=escapedString.replace(""String_Node_Str"",""String_Node_Str"");
  escapedString=escapedString.replace(""String_Node_Str"",""String_Node_Str"");
  if (escapedString.equals(unescaped) && !escapedString.contains(""String_Node_Str""))   return unescaped;
 else   return '""' + escapedString + '""';
}","public static String openVpnEscape(String unescaped){
  if (unescaped == null)   return null;
  String escapedString=unescaped.replace(""String_Node_Str"",""String_Node_Str"");
  escapedString=escapedString.replace(""String_Node_Str"",""String_Node_Str"");
  escapedString=escapedString.replace(""String_Node_Str"",""String_Node_Str"");
  if (escapedString.equals(unescaped) && !escapedString.contains(""String_Node_Str"") && !escapedString.contains(""String_Node_Str""))   return unescaped;
 else   return '""' + escapedString + '""';
}",0.9536290322580644
109724,"private Notification showNotification(String msg,String tickerText){
  String ns=Context.NOTIFICATION_SERVICE;
  NotificationManager mNotificationManager=(NotificationManager)getSystemService(ns);
  int icon=R.drawable.ic_stat_vpn;
  long when=System.currentTimeMillis();
  android.app.Notification.Builder nbuilder=new Notification.Builder(this);
  nbuilder.setContentTitle(""String_Node_Str"" + mProfile.mName);
  nbuilder.setContentText(msg);
  nbuilder.setOnlyAlertOnce(true);
  nbuilder.setOngoing(true);
  nbuilder.setContentIntent(getLogPendingIntent());
  nbuilder.setSmallIcon(icon);
  nbuilder.setWhen(when);
  if (tickerText != null)   nbuilder.setTicker(tickerText);
  Notification notification=nbuilder.getNotification();
  mNotificationManager.notify(OPENVPN_STATUS,notification);
  return notification;
}","private Notification showNotification(String msg,String tickerText){
  String ns=Context.NOTIFICATION_SERVICE;
  NotificationManager mNotificationManager=(NotificationManager)getSystemService(ns);
  int icon=R.drawable.ic_stat_vpn;
  long when=System.currentTimeMillis();
  android.app.Notification.Builder nbuilder=new Notification.Builder(this);
  nbuilder.setContentTitle(""String_Node_Str"" + mProfile.mName);
  nbuilder.setContentText(msg);
  nbuilder.setOnlyAlertOnce(true);
  nbuilder.setOngoing(true);
  nbuilder.setContentIntent(getLogPendingIntent());
  nbuilder.setSmallIcon(icon);
  nbuilder.setWhen(when);
  if (tickerText != null)   nbuilder.setTicker(tickerText);
  Notification notification=nbuilder.getNotification();
  mNotificationManager.notify(OPENVPN_STATUS,notification);
  startForeground(OPENVPN_STATUS,notification);
  return notification;
}",0.971462544589774
109725,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  String prefix=getPackageName();
  String[] argv=intent.getStringArrayExtra(prefix + ""String_Node_Str"");
  String nativelibdir=intent.getStringExtra(prefix + ""String_Node_Str"");
  String profileUUID=intent.getStringExtra(prefix + ""String_Node_Str"");
  mProfile=ProfileManager.get(profileUUID);
  Notification start=showNotification(""String_Node_Str"" + mProfile.mName,null);
  startForeground(OPENVPN_STATUS,start);
  OpenVPN.addSpeedListener(this);
  if (OpenVpnManagementThread.stopOpenVPN()) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  if (mProcessThread != null) {
    mProcessThread.interrupt();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  LocalServerSocket mgmtsocket=openManagmentInterface(8);
  if (mgmtsocket != null) {
    mSocketManager=new OpenVpnManagementThread(mProfile,mgmtsocket,this);
    mSocketManagerThread=new Thread(mSocketManager,""String_Node_Str"");
    mSocketManagerThread.start();
    OpenVPN.logInfo(""String_Node_Str"");
    registerNetworkStateReceiver();
  }
  OpenVPNThread processThread=new OpenVPNThread(this,argv,nativelibdir);
  mProcessThread=new Thread(processThread,""String_Node_Str"");
  mProcessThread.start();
  ProfileManager.setConnectedVpnProfile(this,mProfile);
  return START_NOT_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  String prefix=getPackageName();
  String[] argv=intent.getStringArrayExtra(prefix + ""String_Node_Str"");
  String nativelibdir=intent.getStringExtra(prefix + ""String_Node_Str"");
  String profileUUID=intent.getStringExtra(prefix + ""String_Node_Str"");
  mProfile=ProfileManager.get(profileUUID);
  showNotification(""String_Node_Str"" + mProfile.mName,null);
  OpenVPN.addSpeedListener(this);
  if (OpenVpnManagementThread.stopOpenVPN()) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  if (mProcessThread != null) {
    mProcessThread.interrupt();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  LocalServerSocket mgmtsocket=openManagmentInterface(8);
  if (mgmtsocket != null) {
    mSocketManager=new OpenVpnManagementThread(mProfile,mgmtsocket,this);
    mSocketManagerThread=new Thread(mSocketManager,""String_Node_Str"");
    mSocketManagerThread.start();
    OpenVPN.logInfo(""String_Node_Str"");
    registerNetworkStateReceiver();
  }
  OpenVPNThread processThread=new OpenVPNThread(this,argv,nativelibdir);
  mProcessThread=new Thread(processThread,""String_Node_Str"");
  mProcessThread.start();
  ProfileManager.setConnectedVpnProfile(this,mProfile);
  return START_NOT_STICKY;
}",0.9781818181818182
109726,"private String embedFile(String filename){
  if (filename == null || filename.equals(""String_Node_Str""))   return null;
  if (filename.startsWith(VpnProfile.INLINE_TAG))   return filename;
  File sdcard=Environment.getExternalStorageDirectory();
  File root=new File(""String_Node_Str"");
  Vector<File> dirlist=new Vector<File>();
  for (int i=mPathsegments.size() - 1; i >= 0; i--) {
    String path=""String_Node_Str"";
    for (int j=0; j <= i; j++) {
      path+=""String_Node_Str"" + mPathsegments.get(j);
    }
    dirlist.add(new File(path));
  }
  dirlist.add(sdcard);
  dirlist.add(root);
  String[] fileparts=filename.split(""String_Node_Str"");
  for (  File rootdir : dirlist) {
    String suffix=""String_Node_Str"";
    for (int i=fileparts.length - 1; i >= 0; i--) {
      if (i == fileparts.length - 1)       suffix=fileparts[i];
 else       suffix=fileparts[i] + ""String_Node_Str"" + suffix;
      File possibleFile=new File(rootdir,suffix);
      if (!possibleFile.canRead())       continue;
      String filedata=""String_Node_Str"";
      byte[] buf=new byte[2048];
      log(R.string.trying_to_read,possibleFile.getAbsolutePath());
      try {
        FileInputStream fis=new FileInputStream(possibleFile);
        int len=fis.read(buf);
        while (len > 0) {
          filedata+=new String(buf,0,len);
          len=fis.read(buf);
        }
        fis.close();
        return filedata;
      }
 catch (      FileNotFoundException e) {
        log(e.getLocalizedMessage());
      }
catch (      IOException e) {
        log(e.getLocalizedMessage());
      }
    }
  }
  log(R.string.import_could_not_open,filename);
  return null;
}","private String embedFile(String filename){
  if (filename == null || filename.equals(""String_Node_Str""))   return null;
  if (filename.startsWith(VpnProfile.INLINE_TAG))   return filename;
  File sdcard=Environment.getExternalStorageDirectory();
  File root=new File(""String_Node_Str"");
  Vector<File> dirlist=new Vector<File>();
  for (int i=mPathsegments.size() - 1; i >= 0; i--) {
    String path=""String_Node_Str"";
    for (int j=0; j <= i; j++) {
      path+=""String_Node_Str"" + mPathsegments.get(j);
    }
    dirlist.add(new File(path));
  }
  dirlist.add(sdcard);
  dirlist.add(root);
  String[] fileparts=filename.split(""String_Node_Str"");
  for (  File rootdir : dirlist) {
    String suffix=""String_Node_Str"";
    for (int i=fileparts.length - 1; i >= 0; i--) {
      if (i == fileparts.length - 1)       suffix=fileparts[i];
 else       suffix=fileparts[i] + ""String_Node_Str"" + suffix;
      File possibleFile=new File(rootdir,suffix);
      if (!possibleFile.canRead())       continue;
      String filedata=""String_Node_Str"";
      byte[] buf=new byte[2048];
      log(R.string.trying_to_read,possibleFile.getAbsolutePath());
      try {
        FileInputStream fis=new FileInputStream(possibleFile);
        int len=fis.read(buf);
        while (len > 0) {
          filedata+=new String(buf,0,len);
          len=fis.read(buf);
        }
        fis.close();
        return VpnProfile.INLINE_TAG + filedata;
      }
 catch (      FileNotFoundException e) {
        log(e.getLocalizedMessage());
      }
catch (      IOException e) {
        log(e.getLocalizedMessage());
      }
    }
  }
  log(R.string.import_could_not_open,filename);
  return null;
}",0.9927623642943304
109727,"void embedFiles(){
  mResult.mCaFilename=VpnProfile.INLINE_TAG + embedFile(mResult.mCaFilename);
  mResult.mClientCertFilename=VpnProfile.INLINE_TAG + embedFile(mResult.mClientCertFilename);
  mResult.mClientKeyFilename=VpnProfile.INLINE_TAG + embedFile(mResult.mClientKeyFilename);
  mResult.mTLSAuthFilename=VpnProfile.INLINE_TAG + embedFile(mResult.mTLSAuthFilename);
  if (mResult.mUsername != null && !mResult.mUsername.equals(""String_Node_Str"")) {
    String data=embedFile(mResult.mUsername);
    mResult.mName=null;
    if (data != null) {
      String[] parts=data.split(""String_Node_Str"");
      if (parts.length >= 2) {
        mResult.mName=parts[0];
        mResult.mPassword=parts[1];
      }
    }
  }
}","void embedFiles(){
  mResult.mCaFilename=embedFile(mResult.mCaFilename);
  mResult.mClientCertFilename=embedFile(mResult.mClientCertFilename);
  mResult.mClientKeyFilename=embedFile(mResult.mClientKeyFilename);
  mResult.mTLSAuthFilename=embedFile(mResult.mTLSAuthFilename);
  if (mResult.mUsername != null && !mResult.mUsername.equals(""String_Node_Str"")) {
    String data=embedFile(mResult.mUsername);
    mResult.mName=null;
    if (data != null) {
      data=data.replace(VpnProfile.INLINE_TAG,""String_Node_Str"");
      String[] parts=data.split(""String_Node_Str"");
      if (parts.length >= 2) {
        mResult.mName=parts[0];
        mResult.mPassword=parts[1];
      }
    }
  }
}",0.3570412517780938
109728,"@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  final Intent intent=getIntent();
  final String action=intent.getAction();
  mPM=ProfileManager.getInstance(this);
  if (Intent.ACTION_MAIN.equals(action)) {
    String shortcutUUID=intent.getStringExtra(EXTRA_KEY);
    VpnProfile profileToConnect=ProfileManager.get(shortcutUUID);
    if (profileToConnect == null) {
      Toast notfound=Toast.makeText(this,R.string.shortcut_profile_notfound,Toast.LENGTH_SHORT);
      notfound.show();
      finish();
      return;
    }
    mSelectedProfile=profileToConnect;
    launchVPN();
  }
 else   if (Intent.ACTION_CREATE_SHORTCUT.equals(action)) {
    createListView();
  }
}","@Override public void onCreate(Bundle icicle){
  super.onCreate(icicle);
  mPM=ProfileManager.getInstance(this);
}",0.2814814814814815
109729,"private String cidrToIPAndNetmask(String route){
  String[] parts=route.split(""String_Node_Str"");
  if (parts.length == 1)   return route;
  if (parts.length != 2)   return null;
  int len;
  try {
    len=Integer.parseInt(parts[1]);
  }
 catch (  NumberFormatException ne) {
    return null;
  }
  if (len < 0 || len > 32)   return null;
  long nm=0xffffffffl;
  nm=(nm << (32 - len)) & 0xffffffffl;
  String netmask=String.format(""String_Node_Str"",(nm & 0xff000000) >> 24,(nm & 0xff0000) >> 16,(nm & 0xff00) >> 8,nm & 0xff);
  return parts[0] + ""String_Node_Str"" + netmask;
}","private String cidrToIPAndNetmask(String route){
  String[] parts=route.split(""String_Node_Str"");
  if (parts.length == 1)   parts=(route + ""String_Node_Str"").split(""String_Node_Str"");
  if (parts.length != 2)   return null;
  int len;
  try {
    len=Integer.parseInt(parts[1]);
  }
 catch (  NumberFormatException ne) {
    return null;
  }
  if (len < 0 || len > 32)   return null;
  long nm=0xffffffffl;
  nm=(nm << (32 - len)) & 0xffffffffl;
  String netmask=String.format(""String_Node_Str"",(nm & 0xff000000) >> 24,(nm & 0xff0000) >> 16,(nm & 0xff00) >> 8,nm & 0xff);
  return parts[0] + ""String_Node_Str"" + netmask;
}",0.9416666666666668
109730,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.config);
  OpenVPN.foo();
  mServerAddress=(TextView)findViewById(R.id.address);
  mServerPort=(TextView)findViewById(R.id.port);
  mClientCert=(FileSelectLayout)findViewById(R.id.certselect);
  mClientKey=(FileSelectLayout)findViewById(R.id.keyselect);
  mCaCert=(FileSelectLayout)findViewById(R.id.certselect);
  mpkcs12=(FileSelectLayout)findViewById(R.id.pkcs12select);
  mUseLzo=(CheckBox)findViewById(R.id.lzo);
  mTcpUdp=(ToggleButton)findViewById(id.tcpudp);
  mType=(Spinner)findViewById(R.id.type);
  mPKCS12Password=(TextView)findViewById(R.id.pkcs12password);
  mAliasName=(TextView)findViewById(R.id.aliasname);
  mUseTlsAuth=(CheckBox)findViewById(R.id.useTLSAuth);
  mTLSDirection=(Spinner)findViewById(R.id.tls_direction);
  mShowAdvanced=(CheckBox)findViewById(R.id.show_advanced);
  mTlsFile=(FileSelectLayout)findViewById(R.id.tlsAuth);
  addFileSelectLayout(mCaCert);
  addFileSelectLayout(mClientCert);
  addFileSelectLayout(mClientKey);
  addFileSelectLayout(mTlsFile);
  addFileSelectLayout(mpkcs12);
  loadPreferences();
  mType.setOnItemSelectedListener(this);
  mShowAdvanced.setOnCheckedChangeListener(this);
  mUseTlsAuth.setOnCheckedChangeListener(this);
  findViewById(R.id.select_keystore_button).setOnClickListener(this);
  findViewById(R.id.about).setOnClickListener(this);
  findViewById(R.id.connect).setOnClickListener(this);
  if (mHandler == null) {
    mHandler=new Handler(this);
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.config);
  OpenVPN.foo();
  mServerAddress=(TextView)findViewById(R.id.address);
  mServerPort=(TextView)findViewById(R.id.port);
  mClientCert=(FileSelectLayout)findViewById(R.id.certselect);
  mClientKey=(FileSelectLayout)findViewById(R.id.keyselect);
  mCaCert=(FileSelectLayout)findViewById(R.id.caselect);
  mpkcs12=(FileSelectLayout)findViewById(R.id.pkcs12select);
  mUseLzo=(CheckBox)findViewById(R.id.lzo);
  mTcpUdp=(ToggleButton)findViewById(id.tcpudp);
  mType=(Spinner)findViewById(R.id.type);
  mPKCS12Password=(TextView)findViewById(R.id.pkcs12password);
  mAliasName=(TextView)findViewById(R.id.aliasname);
  mUseTlsAuth=(CheckBox)findViewById(R.id.useTLSAuth);
  mTLSDirection=(Spinner)findViewById(R.id.tls_direction);
  mShowAdvanced=(CheckBox)findViewById(R.id.show_advanced);
  mTlsFile=(FileSelectLayout)findViewById(R.id.tlsAuth);
  addFileSelectLayout(mCaCert);
  addFileSelectLayout(mClientCert);
  addFileSelectLayout(mClientKey);
  addFileSelectLayout(mTlsFile);
  addFileSelectLayout(mpkcs12);
  loadPreferences();
  mType.setOnItemSelectedListener(this);
  mShowAdvanced.setOnCheckedChangeListener(this);
  mUseTlsAuth.setOnCheckedChangeListener(this);
  findViewById(R.id.select_keystore_button).setOnClickListener(this);
  findViewById(R.id.about).setOnClickListener(this);
  findViewById(R.id.connect).setOnClickListener(this);
  if (mHandler == null) {
    mHandler=new Handler(this);
  }
}",0.9987071751777634
109731,"public static Properties getKafkaConfigProperties(Context context){
  Properties props=new Properties();
  String contextString=context.toString();
  for (  final String kv : contextString.substring(14,contextString.length() - 3).split(""String_Node_Str"")) {
    log.info(""String_Node_Str"" + kv);
    String k=kv.trim().split(""String_Node_Str"")[0];
    log.info(""String_Node_Str"" + k);
    String v=kv.trim().split(""String_Node_Str"")[1];
    log.info(""String_Node_Str"" + v);
    if (!k.equals(""String_Node_Str"") && !k.equals(""String_Node_Str"")) {
      props.put(k,v);
    }
  }
  log.info(""String_Node_Str"" + props);
  return props;
}","public static Properties getKafkaConfigProperties(Context context){
  Properties props=new Properties();
  String contextString=context.toString();
  for (  final String kv : contextString.substring(14,contextString.length() - 3).split(""String_Node_Str"")) {
    String k=kv.trim().split(""String_Node_Str"")[0];
    String v=kv.trim().split(""String_Node_Str"")[1];
    log.info(""String_Node_Str"" + k + ""String_Node_Str""+ v);
    if (!k.equals(""String_Node_Str"") && !k.equals(""String_Node_Str"")) {
      props.put(k,v);
    }
  }
  log.info(""String_Node_Str"" + props);
  return props;
}",0.919407894736842
109732,"public Status process() throws EventDeliveryException {
  log.trace(""String_Node_Str"");
  Channel channel=getChannel();
  Transaction tx=channel.getTransaction();
  try {
    tx.begin();
    Event e=channel.take();
    if (e == null) {
      tx.rollback();
      log.trace(""String_Node_Str"");
      return Status.BACKOFF;
    }
    try {
      log.trace(""String_Node_Str"");
      producer.send(new ProducerData<String,String>(this.topic,new String(e.getBody())));
      tx.commit();
      return Status.READY;
    }
 catch (    Exception ex) {
      log.trace(""String_Node_Str"",ex);
      throw ex;
    }
  }
 catch (  Exception e) {
    tx.rollback();
    log.debug(""String_Node_Str"",e);
    return Status.BACKOFF;
  }
 finally {
    log.trace(""String_Node_Str"");
    tx.close();
  }
}","public Status process() throws EventDeliveryException {
  Channel channel=getChannel();
  Transaction tx=channel.getTransaction();
  try {
    tx.begin();
    Event e=channel.take();
    if (e == null) {
      tx.rollback();
      return Status.BACKOFF;
    }
    try {
      producer.send(new ProducerData<String,String>(this.topic,new String(e.getBody())));
      log.debug(""String_Node_Str"" + e.getBody());
      tx.commit();
      return Status.READY;
    }
 catch (    Exception ex) {
      throw ex;
    }
  }
 catch (  Exception e) {
    tx.rollback();
    return Status.BACKOFF;
  }
 finally {
    tx.close();
  }
}",0.7395315826827538
109733,"public void configure(Context context){
  this.topic=KafkaUtil.getKafkaConfigParameter(context,""String_Node_Str"");
  this.producer=KafkaUtil.getProducer(context);
  log.debug(""String_Node_Str"");
}","public void configure(Context context){
  this.topic=KafkaUtil.getKafkaConfigParameter(context,""String_Node_Str"");
  this.producer=KafkaUtil.getProducer(context);
}",0.9111111111111112
109734,"public Status process() throws EventDeliveryException {
  try {
    ArrayList<Event> eventList=new ArrayList<Event>();
    Message message;
    Event event;
    ByteBuffer buffer;
    Map<String,String> headers;
    byte[] bytes;
    for (int i=0; i < batchSize; i++) {
      if (it.hasNext()) {
        log.trace(""String_Node_Str"");
        message=it.next().message();
        log.info(""String_Node_Str"" + message);
        event=new SimpleEvent();
        buffer=message.payload();
        headers=new HashMap<String,String>();
        headers.put(""String_Node_Str"",String.valueOf(System.currentTimeMillis()));
        bytes=new byte[buffer.remaining()];
        buffer.get(bytes);
        event.setBody(bytes);
        event.setHeaders(headers);
        log.trace(new String(bytes));
        eventList.add(event);
      }
      log.trace(""String_Node_Str"");
    }
    getChannelProcessor().processEventBatch(eventList);
    log.trace(""String_Node_Str"");
    return Status.READY;
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"" + e);
    return Status.BACKOFF;
  }
}","public Status process() throws EventDeliveryException {
  ArrayList<Event> eventList=new ArrayList<Event>();
  Message message;
  Event event;
  ByteBuffer buffer;
  Map<String,String> headers;
  byte[] bytes;
  try {
    for (int i=0; i < batchSize; i++) {
      if (it.hasNext()) {
        message=it.next().message();
        event=new SimpleEvent();
        buffer=message.payload();
        headers=new HashMap<String,String>();
        headers.put(""String_Node_Str"",String.valueOf(System.currentTimeMillis()));
        bytes=new byte[buffer.remaining()];
        buffer.get(bytes);
        log.debug(""String_Node_Str"" + i + ""String_Node_Str""+ ""String_Node_Str""+ new String(bytes));
        event.setBody(bytes);
        event.setHeaders(headers);
        eventList.add(event);
      }
    }
    getChannelProcessor().processEventBatch(eventList);
    return Status.READY;
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e);
    return Status.BACKOFF;
  }
 finally {
  }
}",0.5216972034715526
109735,"public void configure(Context context){
  this.topic=KafkaUtil.getKafkaConfigParameter(context,""String_Node_Str"");
  try {
    this.consumer=KafkaUtil.getConsumer(context);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  KeeperException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Map<String,Integer> topicCountMap=new HashMap<String,Integer>();
  topicCountMap.put(topic,new Integer(1));
  Map<String,List<KafkaStream<Message>>> consumerMap=consumer.createMessageStreams(topicCountMap);
  KafkaStream<Message> stream=consumerMap.get(topic).get(0);
  it=stream.iterator();
}","public void configure(Context context){
  this.topic=KafkaUtil.getKafkaConfigParameter(context,""String_Node_Str"");
  this.batchSize=Integer.parseInt(KafkaUtil.getKafkaConfigParameter(context,""String_Node_Str""));
  try {
    this.consumer=KafkaUtil.getConsumer(context);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  KeeperException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Map<String,Integer> topicCountMap=new HashMap<String,Integer>();
  topicCountMap.put(topic,new Integer(1));
  Map<String,List<KafkaStream<Message>>> consumerMap=consumer.createMessageStreams(topicCountMap);
  KafkaStream<Message> stream=consumerMap.get(topic).get(0);
  it=stream.iterator();
}",0.9306647605432452
109736,"public static Producer<String,String> getProducer(Context context){
  Producer<String,String> producer;
  Properties props=new Properties();
  props.put(""String_Node_Str"",""String_Node_Str"");
  props.put(""String_Node_Str"",getZkConnect(context));
  props.put(""String_Node_Str"",""String_Node_Str"");
  props.put(""String_Node_Str"",getBatchSize(context));
  props.put(""String_Node_Str"",15000);
  producer=new Producer<String,String>(new ProducerConfig(props));
  log.debug(""String_Node_Str"");
  return producer;
}","public static Producer<String,String> getProducer(Context context){
  Producer<String,String> producer;
  Properties props=new Properties();
  props.put(""String_Node_Str"",""String_Node_Str"");
  props.put(""String_Node_Str"",getZkConnect(context));
  props.put(""String_Node_Str"",""String_Node_Str"");
  props.put(""String_Node_Str"",getBatchSize(context));
  props.put(""String_Node_Str"",""String_Node_Str"");
  producer=new Producer<String,String>(new ProducerConfig(props));
  log.debug(""String_Node_Str"");
  return producer;
}",0.978515625
109737,"protected void configureBounds(){
  if (isFrist) {
    oriRationWH=((float)mDrawable.getIntrinsicWidth()) / ((float)mDrawable.getIntrinsicHeight());
    final float scale=mContext.getResources().getDisplayMetrics().density;
    int w=Math.min(getWidth(),(int)(mDrawable.getIntrinsicWidth() * scale + 0.5f));
    int h=(int)(w / oriRationWH);
    int left=(getWidth() - w) / 2;
    int top=(getHeight() - h) / 2;
    int right=left + w;
    int bottom=top + h;
    mDrawableSrc.set(left,top,right,bottom);
    mDrawableDst.set(mDrawableSrc);
    int floatWidth=dipTopx(mContext,cropWidth);
    int floatHeight=dipTopx(mContext,cropHeight);
    int floatLeft=(getWidth() - floatWidth) / 2;
    int floatTop=(getHeight() - floatHeight) / 2;
    mDrawableFloat.set(floatLeft,floatTop,floatLeft + floatWidth,floatTop + floatHeight);
    isFrist=false;
  }
  mDrawable.setBounds(mDrawableDst);
  mFloatDrawable.setBounds(mDrawableFloat);
}","protected void configureBounds(){
  if (isFrist) {
    oriRationWH=((float)mDrawable.getIntrinsicWidth()) / ((float)mDrawable.getIntrinsicHeight());
    final float scale=mContext.getResources().getDisplayMetrics().density;
    int w=Math.min(getWidth(),(int)(mDrawable.getIntrinsicWidth() * scale + 0.5f));
    int h=(int)(w / oriRationWH);
    int left=(getWidth() - w) / 2;
    int top=(getHeight() - h) / 2;
    int right=left + w;
    int bottom=top + h;
    mDrawableSrc.set(left,top,right,bottom);
    mDrawableDst.set(mDrawableSrc);
    int floatWidth=dipTopx(mContext,cropWidth);
    int floatHeight=dipTopx(mContext,cropHeight);
    if (floatWidth > getWidth()) {
      floatWidth=getWidth();
      floatHeight=cropHeight * floatWidth / cropWidth;
    }
    if (floatHeight > getHeight()) {
      floatHeight=getHeight();
      floatWidth=cropWidth * floatHeight / cropHeight;
    }
    int floatLeft=(getWidth() - floatWidth) / 2;
    int floatTop=(getHeight() - floatHeight) / 2;
    mDrawableFloat.set(floatLeft,floatTop,floatLeft + floatWidth,floatTop + floatHeight);
    isFrist=false;
  }
  mDrawable.setBounds(mDrawableDst);
  mFloatDrawable.setBounds(mDrawableFloat);
}",0.880188679245283
109738,"protected void configureBounds(){
  if (isFrist) {
    oriRationWH=((float)mDrawable.getIntrinsicWidth()) / ((float)mDrawable.getIntrinsicHeight());
    final float scale=mContext.getResources().getDisplayMetrics().density;
    int w=Math.min(getWidth(),(int)(mDrawable.getIntrinsicWidth() * scale + 0.5f));
    int h=(int)(w / oriRationWH);
    int left=(getWidth() - w) / 2;
    int top=(getHeight() - h) / 2;
    int right=left + w;
    int bottom=top + h;
    mDrawableSrc.set(left,top,right,bottom);
    mDrawableDst.set(mDrawableSrc);
    int floatWidth=dipTopx(mContext,cropWidth);
    int floatHeight=dipTopx(mContext,cropHeight);
    int floatLeft=(getWidth() - floatWidth) / 2;
    int floatTop=(getHeight() - floatHeight) / 2;
    mDrawableFloat.set(floatLeft,floatTop,floatLeft + floatWidth,floatTop + floatHeight);
    isFrist=false;
  }
  mDrawable.setBounds(mDrawableDst);
  mFloatDrawable.setBounds(mDrawableFloat);
}","protected void configureBounds(){
  if (isFrist) {
    oriRationWH=((float)mDrawable.getIntrinsicWidth()) / ((float)mDrawable.getIntrinsicHeight());
    final float scale=mContext.getResources().getDisplayMetrics().density;
    int w=Math.min(getWidth(),(int)(mDrawable.getIntrinsicWidth() * scale + 0.5f));
    int h=(int)(w / oriRationWH);
    int left=(getWidth() - w) / 2;
    int top=(getHeight() - h) / 2;
    int right=left + w;
    int bottom=top + h;
    mDrawableSrc.set(left,top,right,bottom);
    mDrawableDst.set(mDrawableSrc);
    int floatWidth=dipTopx(mContext,cropWidth);
    int floatHeight=dipTopx(mContext,cropHeight);
    if (floatWidth > getWidth()) {
      floatWidth=getWidth();
      floatHeight=cropHeight * floatWidth / cropWidth;
    }
    if (floatHeight > getHeight()) {
      floatHeight=getHeight();
      floatWidth=cropWidth * floatHeight / cropHeight;
    }
    int floatLeft=(getWidth() - floatWidth) / 2;
    int floatTop=(getHeight() - floatHeight) / 2;
    mDrawableFloat.set(floatLeft,floatTop,floatLeft + floatWidth,floatTop + floatHeight);
    isFrist=false;
  }
  mDrawable.setBounds(mDrawableDst);
  mFloatDrawable.setBounds(mDrawableFloat);
}",0.880188679245283
109739,"protected void configureBounds(){
  if (isFrist) {
    oriRationWH=((float)mDrawable.getIntrinsicWidth()) / ((float)mDrawable.getIntrinsicHeight());
    final float scale=mContext.getResources().getDisplayMetrics().density;
    int w=Math.min(getWidth(),(int)(mDrawable.getIntrinsicWidth() * scale + 0.5f));
    int h=(int)(w / oriRationWH);
    int left=(getWidth() - w) / 2;
    int top=(getHeight() - h) / 2;
    int right=left + w;
    int bottom=top + h;
    mDrawableSrc.set(left,top,right,bottom);
    mDrawableDst.set(mDrawableSrc);
    int floatWidth=dipTopx(mContext,cropWidth);
    int floatHeight=dipTopx(mContext,cropHeight);
    int floatLeft=(getWidth() - floatWidth) / 2;
    int floatTop=(getHeight() - floatHeight) / 2;
    mDrawableFloat.set(floatLeft,floatTop,floatLeft + floatWidth,floatTop + floatHeight);
    isFrist=false;
  }
  mDrawable.setBounds(mDrawableDst);
  mFloatDrawable.setBounds(mDrawableFloat);
}","protected void configureBounds(){
  if (isFrist) {
    oriRationWH=((float)mDrawable.getIntrinsicWidth()) / ((float)mDrawable.getIntrinsicHeight());
    final float scale=mContext.getResources().getDisplayMetrics().density;
    int w=Math.min(getWidth(),(int)(mDrawable.getIntrinsicWidth() * scale + 0.5f));
    int h=(int)(w / oriRationWH);
    int left=(getWidth() - w) / 2;
    int top=(getHeight() - h) / 2;
    int right=left + w;
    int bottom=top + h;
    mDrawableSrc.set(left,top,right,bottom);
    mDrawableDst.set(mDrawableSrc);
    int floatWidth=dipTopx(mContext,cropWidth);
    int floatHeight=dipTopx(mContext,cropHeight);
    if (floatWidth > getWidth()) {
      floatWidth=getWidth();
      floatHeight=cropHeight * floatWidth / cropWidth;
    }
    if (floatHeight > getHeight()) {
      floatHeight=getHeight();
      floatWidth=cropWidth * floatHeight / cropHeight;
    }
    int floatLeft=(getWidth() - floatWidth) / 2;
    int floatTop=(getHeight() - floatHeight) / 2;
    mDrawableFloat.set(floatLeft,floatTop,floatLeft + floatWidth,floatTop + floatHeight);
    isFrist=false;
  }
  mDrawable.setBounds(mDrawableDst);
  mFloatDrawable.setBounds(mDrawableFloat);
}",0.880188679245283
109740,"protected void configureBounds(){
  if (isFrist) {
    oriRationWH=((float)mDrawable.getIntrinsicWidth()) / ((float)mDrawable.getIntrinsicHeight());
    final float scale=mContext.getResources().getDisplayMetrics().density;
    int w=Math.min(getWidth(),(int)(mDrawable.getIntrinsicWidth() * scale + 0.5f));
    int h=(int)(w / oriRationWH);
    int left=(getWidth() - w) / 2;
    int top=(getHeight() - h) / 2;
    int right=left + w;
    int bottom=top + h;
    mDrawableSrc.set(left,top,right,bottom);
    mDrawableDst.set(mDrawableSrc);
    int floatWidth=dipTopx(mContext,cropWidth);
    int floatHeight=dipTopx(mContext,cropHeight);
    int floatLeft=(getWidth() - floatWidth) / 2;
    int floatTop=(getHeight() - floatHeight) / 2;
    mDrawableFloat.set(floatLeft,floatTop,floatLeft + floatWidth,floatTop + floatHeight);
    isFrist=false;
  }
  mDrawable.setBounds(mDrawableDst);
  mFloatDrawable.setBounds(mDrawableFloat);
}","protected void configureBounds(){
  if (isFrist) {
    oriRationWH=((float)mDrawable.getIntrinsicWidth()) / ((float)mDrawable.getIntrinsicHeight());
    final float scale=mContext.getResources().getDisplayMetrics().density;
    int w=Math.min(getWidth(),(int)(mDrawable.getIntrinsicWidth() * scale + 0.5f));
    int h=(int)(w / oriRationWH);
    int left=(getWidth() - w) / 2;
    int top=(getHeight() - h) / 2;
    int right=left + w;
    int bottom=top + h;
    mDrawableSrc.set(left,top,right,bottom);
    mDrawableDst.set(mDrawableSrc);
    int floatWidth=dipTopx(mContext,cropWidth);
    int floatHeight=dipTopx(mContext,cropHeight);
    if (floatWidth > getWidth()) {
      floatWidth=getWidth();
      floatHeight=cropHeight * floatWidth / cropWidth;
    }
    if (floatHeight > getHeight()) {
      floatHeight=getHeight();
      floatWidth=cropWidth * floatHeight / cropHeight;
    }
    int floatLeft=(getWidth() - floatWidth) / 2;
    int floatTop=(getHeight() - floatHeight) / 2;
    mDrawableFloat.set(floatLeft,floatTop,floatLeft + floatWidth,floatTop + floatHeight);
    isFrist=false;
  }
  mDrawable.setBounds(mDrawableDst);
  mFloatDrawable.setBounds(mDrawableFloat);
}",0.880188679245283
109741,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == SCRIPT_EXEC_PY) {
    Bundle bundle=data.getExtras();
    String flag=bundle.getString(""String_Node_Str"");
    String param=bundle.getString(""String_Node_Str"");
    String result=bundle.getString(""String_Node_Str"");
    Toast.makeText(this,""String_Node_Str"" + result + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == SCRIPT_EXEC_PY) {
    if (data != null) {
      Bundle bundle=data.getExtras();
      String flag=bundle.getString(""String_Node_Str"");
      String param=bundle.getString(""String_Node_Str"");
      String result=bundle.getString(""String_Node_Str"");
      Toast.makeText(this,""String_Node_Str"" + result + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
 else {
      Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
  }
}",0.8716904276985743
109742,"public void onQPyExec(View v){
  if (checkAppInstalledByName(getApplicationContext(),extPlgPlusName)) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    Intent intent=new Intent();
    intent.setClassName(extPlgPlusName,extPlgPlusName + ""String_Node_Str"");
    intent.setAction(extPlgPlusName + ""String_Node_Str"");
    Bundle mBundle=new Bundle();
    mBundle.putString(""String_Node_Str"",""String_Node_Str"");
    mBundle.putString(""String_Node_Str"",""String_Node_Str"");
    mBundle.putString(""String_Node_Str"",""String_Node_Str"");
    mBundle.putString(""String_Node_Str"",""String_Node_Str"");
    EditText codeTxt=(EditText)findViewById(R.id.edit_text);
    String code=codeTxt.getText().toString();
    mBundle.putString(""String_Node_Str"",code);
    intent.putExtras(mBundle);
    startActivityForResult(intent,SCRIPT_EXEC_PY);
  }
 else {
    Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_LONG).show();
    try {
      Uri uLink=Uri.parse(""String_Node_Str"");
      Intent intent=new Intent(Intent.ACTION_VIEW,uLink);
      startActivity(intent);
    }
 catch (    Exception e) {
      Uri uLink=Uri.parse(""String_Node_Str"");
      Intent intent=new Intent(Intent.ACTION_VIEW,uLink);
      startActivity(intent);
    }
  }
}","public void onQPyExec(View v){
  if (checkAppInstalledByName(getApplicationContext(),extPlgPlusName)) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    Intent intent=new Intent();
    intent.setClassName(extPlgPlusName,""String_Node_Str"");
    intent.setAction(extPlgPlusName + ""String_Node_Str"");
    Bundle mBundle=new Bundle();
    mBundle.putString(""String_Node_Str"",""String_Node_Str"");
    mBundle.putString(""String_Node_Str"",""String_Node_Str"");
    mBundle.putString(""String_Node_Str"",""String_Node_Str"");
    mBundle.putString(""String_Node_Str"",""String_Node_Str"");
    EditText codeTxt=(EditText)findViewById(R.id.edit_text);
    String code=codeTxt.getText().toString();
    mBundle.putString(""String_Node_Str"",code);
    intent.putExtras(mBundle);
    startActivityForResult(intent,SCRIPT_EXEC_PY);
  }
 else {
    Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_LONG).show();
    try {
      Uri uLink=Uri.parse(""String_Node_Str"");
      Intent intent=new Intent(Intent.ACTION_VIEW,uLink);
      startActivity(intent);
    }
 catch (    Exception e) {
      Uri uLink=Uri.parse(""String_Node_Str"");
      Intent intent=new Intent(Intent.ACTION_VIEW,uLink);
      startActivity(intent);
    }
  }
}",0.993256644188814
109743,"private byte[] readFully(final InputStream stream){
  try {
    int totalLength=0;
    byte[] buffer=getOrCreateBuffer();
    int read;
    while ((read=stream.read(buffer,totalLength,BUFFER_SIZE)) != -1) {
      totalLength+=read;
      if (totalLength >= buffer.length - 1) {
        byte[] newBuffer=new byte[buffer.length + BUFFER_SIZE];
        System.arraycopy(buffer,0,newBuffer,0,buffer.length);
        buffer=newBuffer;
      }
    }
    final byte[] result=new byte[totalLength];
    System.arraycopy(buffer,0,result,0,totalLength);
    return result;
  }
 catch (  Throwable t) {
    LogWrapper.log(Level.WARNING,t,""String_Node_Str"");
    return new byte[0];
  }
}","private byte[] readFully(final InputStream stream){
  try {
    int totalLength=0;
    byte[] buffer=getOrCreateBuffer();
    int read;
    while ((read=stream.read(buffer,totalLength,totalLength - buffer.length)) != -1) {
      totalLength+=read;
      if (totalLength >= buffer.length - 1) {
        byte[] newBuffer=new byte[buffer.length + BUFFER_SIZE];
        System.arraycopy(buffer,0,newBuffer,0,buffer.length);
        buffer=newBuffer;
      }
    }
    final byte[] result=new byte[totalLength];
    System.arraycopy(buffer,0,result,0,totalLength);
    return result;
  }
 catch (  Throwable t) {
    LogWrapper.log(Level.WARNING,t,""String_Node_Str"");
    return new byte[0];
  }
}",0.9722222222222222
109744,"private byte[] runTransformers(final String name,final String transformedName,byte[] basicClass){
  if (DEBUG_FINER) {
    LogWrapper.finest(""String_Node_Str"",name,transformedName,(basicClass == null ? 0 : basicClass.length));
    for (    final IClassTransformer transformer : transformers) {
      final String transName=transformer.getClass().getName();
      LogWrapper.finest(""String_Node_Str"",transName,(basicClass == null ? 0 : basicClass.length));
      basicClass=transformer.transform(name,transformedName,basicClass);
      LogWrapper.finest(""String_Node_Str"",transName,(basicClass == null ? 0 : basicClass.length));
    }
    LogWrapper.finest(""String_Node_Str"",name,transformedName,(basicClass == null ? 0 : basicClass.length));
  }
 else {
    for (    final IClassTransformer transformer : transformers) {
      basicClass=transformer.transform(name,transformedName,basicClass);
    }
  }
  return basicClass;
}","private byte[] runTransformers(final String name,final String transformedName,byte[] basicClass){
  if (DEBUG_FINER) {
    LogWrapper.finest(""String_Node_Str"",name,transformedName,(basicClass == null ? 0 : basicClass.length));
    for (    final IClassTransformer transformer : transformers) {
      final String transName=transformer.getClass().getName();
      LogWrapper.finest(""String_Node_Str"",name,transformedName,transName,(basicClass == null ? 0 : basicClass.length));
      basicClass=transformer.transform(name,transformedName,basicClass);
      LogWrapper.finest(""String_Node_Str"",name,transformedName,transName,(basicClass == null ? 0 : basicClass.length));
    }
    LogWrapper.finest(""String_Node_Str"",name,transformedName,(basicClass == null ? 0 : basicClass.length));
  }
 else {
    for (    final IClassTransformer transformer : transformers) {
      basicClass=transformer.transform(name,transformedName,basicClass);
    }
  }
  return basicClass;
}",0.9778247096092924
109745,"@Override public Class<?> findClass(final String name) throws ClassNotFoundException {
  if (invalidClasses.contains(name)) {
    throw new ClassNotFoundException(name);
  }
  for (  final String exception : classLoaderExceptions) {
    if (name.startsWith(exception)) {
      return parent.loadClass(name);
    }
  }
  if (cachedClasses.containsKey(name)) {
    return cachedClasses.get(name);
  }
  for (  final String exception : transformerExceptions) {
    if (name.startsWith(exception)) {
      try {
        final Class<?> clazz=super.findClass(name);
        cachedClasses.put(name,clazz);
        return clazz;
      }
 catch (      ClassNotFoundException e) {
        invalidClasses.add(name);
        throw e;
      }
    }
  }
  try {
    final String transformedName=transformName(name);
    final String untransformedName=untransformName(name);
    final int lastDot=untransformedName.lastIndexOf('.');
    final String packageName=lastDot == -1 ? ""String_Node_Str"" : untransformedName.substring(0,lastDot);
    final String fileName=untransformedName.replace('.','/').concat(""String_Node_Str"");
    URLConnection urlConnection=findCodeSourceConnectionFor(fileName);
    CodeSigner[] signers=null;
    if (lastDot > -1 && !untransformedName.startsWith(""String_Node_Str"")) {
      if (urlConnection instanceof JarURLConnection) {
        final JarURLConnection jarURLConnection=(JarURLConnection)urlConnection;
        final JarFile jarFile=jarURLConnection.getJarFile();
        if (jarFile != null && jarFile.getManifest() != null) {
          final Manifest manifest=jarFile.getManifest();
          final JarEntry entry=jarFile.getJarEntry(fileName);
          Package pkg=getPackage(packageName);
          getClassBytes(untransformedName);
          signers=entry.getCodeSigners();
          if (pkg == null) {
            pkg=definePackage(packageName,manifest,jarURLConnection.getJarFileURL());
            packageManifests.put(pkg,manifest);
          }
 else {
            if (pkg.isSealed() && !pkg.isSealed(jarURLConnection.getJarFileURL())) {
              LogWrapper.severe(""String_Node_Str"",jarFile.getName(),packageName);
            }
 else             if (isSealed(packageName,manifest)) {
              LogWrapper.severe(""String_Node_Str"",jarFile.getName(),packageName);
            }
          }
        }
      }
 else {
        Package pkg=getPackage(packageName);
        if (pkg == null) {
          pkg=definePackage(packageName,null,null,null,null,null,null,null);
          packageManifests.put(pkg,EMPTY);
        }
 else         if (pkg.isSealed()) {
          LogWrapper.severe(""String_Node_Str"",urlConnection.getURL(),packageName);
        }
      }
    }
    final byte[] transformedClass=runTransformers(untransformedName,transformedName,getClassBytes(untransformedName));
    if (DEBUG_SAVE) {
      saveTransformedClass(transformedClass,transformedName);
    }
    final CodeSource codeSource=urlConnection == null ? null : new CodeSource(urlConnection.getURL(),signers);
    final Class<?> clazz=defineClass(transformedName,transformedClass,0,transformedClass.length,codeSource);
    cachedClasses.put(transformedName,clazz);
    return clazz;
  }
 catch (  Throwable e) {
    invalidClasses.add(name);
    if (DEBUG) {
      LogWrapper.log(Level.FINEST,e,""String_Node_Str"",name);
    }
    throw new ClassNotFoundException(name,e);
  }
}","@Override public Class<?> findClass(final String name) throws ClassNotFoundException {
  if (invalidClasses.contains(name)) {
    throw new ClassNotFoundException(name);
  }
  for (  final String exception : classLoaderExceptions) {
    if (name.startsWith(exception)) {
      return parent.loadClass(name);
    }
  }
  if (cachedClasses.containsKey(name)) {
    return cachedClasses.get(name);
  }
  for (  final String exception : transformerExceptions) {
    if (name.startsWith(exception)) {
      try {
        final Class<?> clazz=super.findClass(name);
        cachedClasses.put(name,clazz);
        return clazz;
      }
 catch (      ClassNotFoundException e) {
        invalidClasses.add(name);
        throw e;
      }
    }
  }
  try {
    final String transformedName=transformName(name);
    if (cachedClasses.containsKey(transformedName)) {
      return cachedClasses.get(transformedName);
    }
    final String untransformedName=untransformName(name);
    final int lastDot=untransformedName.lastIndexOf('.');
    final String packageName=lastDot == -1 ? ""String_Node_Str"" : untransformedName.substring(0,lastDot);
    final String fileName=untransformedName.replace('.','/').concat(""String_Node_Str"");
    URLConnection urlConnection=findCodeSourceConnectionFor(fileName);
    CodeSigner[] signers=null;
    if (lastDot > -1 && !untransformedName.startsWith(""String_Node_Str"")) {
      if (urlConnection instanceof JarURLConnection) {
        final JarURLConnection jarURLConnection=(JarURLConnection)urlConnection;
        final JarFile jarFile=jarURLConnection.getJarFile();
        if (jarFile != null && jarFile.getManifest() != null) {
          final Manifest manifest=jarFile.getManifest();
          final JarEntry entry=jarFile.getJarEntry(fileName);
          Package pkg=getPackage(packageName);
          getClassBytes(untransformedName);
          signers=entry.getCodeSigners();
          if (pkg == null) {
            pkg=definePackage(packageName,manifest,jarURLConnection.getJarFileURL());
            packageManifests.put(pkg,manifest);
          }
 else {
            if (pkg.isSealed() && !pkg.isSealed(jarURLConnection.getJarFileURL())) {
              LogWrapper.severe(""String_Node_Str"",jarFile.getName(),packageName);
            }
 else             if (isSealed(packageName,manifest)) {
              LogWrapper.severe(""String_Node_Str"",jarFile.getName(),packageName);
            }
          }
        }
      }
 else {
        Package pkg=getPackage(packageName);
        if (pkg == null) {
          pkg=definePackage(packageName,null,null,null,null,null,null,null);
          packageManifests.put(pkg,EMPTY);
        }
 else         if (pkg.isSealed()) {
          LogWrapper.severe(""String_Node_Str"",urlConnection.getURL(),packageName);
        }
      }
    }
    final byte[] transformedClass=runTransformers(untransformedName,transformedName,getClassBytes(untransformedName));
    if (DEBUG_SAVE) {
      saveTransformedClass(transformedClass,transformedName);
    }
    final CodeSource codeSource=urlConnection == null ? null : new CodeSource(urlConnection.getURL(),signers);
    final Class<?> clazz=defineClass(transformedName,transformedClass,0,transformedClass.length,codeSource);
    cachedClasses.put(transformedName,clazz);
    return clazz;
  }
 catch (  Throwable e) {
    invalidClasses.add(name);
    if (DEBUG) {
      LogWrapper.log(Level.FINEST,e,""String_Node_Str"",name);
    }
    throw new ClassNotFoundException(name,e);
  }
}",0.984168482207698
109746,"public byte[] getClassBytes(String name) throws IOException {
  if (name.indexOf('.') == -1) {
    for (    final String reservedName : RESERVED_NAMES) {
      if (name.toUpperCase(Locale.ENGLISH).startsWith(reservedName)) {
        final byte[] data=getClassBytes(""String_Node_Str"" + name);
        if (data != null) {
          return data;
        }
      }
    }
  }
  InputStream classStream=null;
  try {
    final String resourcePath=name.replace('.','/').concat(""String_Node_Str"");
    final URL classResource=findResource(resourcePath);
    if (classResource == null) {
      if (DEBUG)       LogWrapper.finest(""String_Node_Str"",resourcePath);
      return null;
    }
    classStream=classResource.openStream();
    if (DEBUG)     LogWrapper.finest(""String_Node_Str"",name,classResource.toString());
    return readFully(classStream);
  }
  finally {
    closeSilently(classStream);
  }
}","public byte[] getClassBytes(String name) throws IOException {
  if (negativeResourceCache.contains(name)) {
    return null;
  }
 else   if (resourceCache.containsKey(name)) {
    return resourceCache.get(name);
  }
  if (name.indexOf('.') == -1) {
    for (    final String reservedName : RESERVED_NAMES) {
      if (name.toUpperCase(Locale.ENGLISH).startsWith(reservedName)) {
        final byte[] data=getClassBytes(""String_Node_Str"" + name);
        if (data != null) {
          resourceCache.put(name,data);
          return data;
        }
      }
    }
  }
  InputStream classStream=null;
  try {
    final String resourcePath=name.replace('.','/').concat(""String_Node_Str"");
    final URL classResource=findResource(resourcePath);
    if (classResource == null) {
      if (DEBUG)       LogWrapper.finest(""String_Node_Str"",resourcePath);
      negativeResourceCache.add(name);
      return null;
    }
    classStream=classResource.openStream();
    if (DEBUG)     LogWrapper.finest(""String_Node_Str"",name,classResource.toString());
    final byte[] data=readFully(classStream);
    resourceCache.put(name,data);
    return data;
  }
  finally {
    closeSilently(classStream);
  }
}",0.852082336045955
109747,"/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
public boolean shouldContinueExecuting(){
  return this.entity.getFollowingEntity() != null && this.entity.followingHoldingPinaColada();
}","/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
public boolean shouldContinueExecuting(){
  return this.entity.getFollowingEntity() != null && this.entity.followingHoldingPinaColada() && !this.entity.isTamed();
}",0.944206008583691
109748,"/** 
 * Returns whether the EntityAIBase should begin execution.
 */
public boolean shouldExecute(){
  if (this.entity.isSitting())   return false;
  if (this.entity.getOwner() != null)   return false;
  List<EntityPlayer> list=this.entity.world.<EntityPlayer>getEntitiesWithinAABB(EntityPlayer.class,this.entity.getEntityBoundingBox().grow((double)this.areaSize),this.followPredicate);
  if (!list.isEmpty()) {
    for (    EntityPlayer entityliving : list) {
      if (!entityliving.isInvisible()) {
        this.entity.setFollowingEntity(entityliving);
        return true;
      }
    }
  }
  return false;
}","/** 
 * Returns whether the EntityAIBase should begin execution.
 */
public boolean shouldExecute(){
  if (this.entity.isSitting())   return false;
  if (this.entity.isTamed())   return false;
  if (this.entity.selfHoldingDrink(Drink.pinaColada))   return false;
  List<EntityPlayer> list=this.entity.world.<EntityPlayer>getEntitiesWithinAABB(EntityPlayer.class,this.entity.getEntityBoundingBox().grow((double)this.areaSize),this.followPredicate);
  if (!list.isEmpty()) {
    for (    EntityPlayer entityliving : list) {
      if (!entityliving.isInvisible()) {
        this.entity.setFollowingEntity(entityliving);
        return true;
      }
    }
  }
  return false;
}",0.9245136186770428
109749,"public EntityAIMonkeySitInChair(EntityVMonkey monkey){
  this.entity=monkey;
  this.setMutexBits(5);
}","public EntityAIMonkeySitInChair(EntityVMonkey monkey,EntityAISit aiSit){
  this.entity=monkey;
  this.aiSit=aiSit;
  this.setMutexBits(5);
}",0.8429752066115702
109750,"/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
@Override public boolean shouldContinueExecuting(){
  return !this.entity.isRiding();
}","/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
@Override public boolean shouldContinueExecuting(){
  return isOwnerNearAndSitting();
}",0.9289940828402368
109751,"@Override public void resetTask(){
  this.entity.dismountRidingEntity();
  this.entity.setSitting(false);
}","@Override public void resetTask(){
  this.entity.dismountRidingEntity();
  this.entity.setSitting(false);
  this.aiSit.setSitting(false);
  this.entity.resetRideCooldown();
}",0.7615658362989324
109752,"@Override public boolean shouldExecute(){
  if (this.entity.getOwner() == null || this.entity == null)   return false;
  return isOwnerNear() && isEmptyChairNear();
}","@Override public boolean shouldExecute(){
  if (!this.entity.isTamed() || this.entity == null)   return false;
  return isOwnerNearAndSitting();
}",0.8461538461538461
109753,"private boolean isOwnerNear(){
  return this.entity.getOwner() != null && this.entity != null && this.entity.getOwner().getDistanceSq(this.entity) < 16D;
}","private boolean isOwnerNear(){
  return this.entity.getOwner() != null && this.entity != null && this.entity.getOwner().getDistanceSq(this.entity) < 32D;
}",0.9870967741935484
109754,"private boolean isEmptyChairNear(){
  List<EntityChair> list=this.entity.world.<EntityChair>getEntitiesWithinAABB(EntityChair.class,this.entity.getEntityBoundingBox().grow(16D));
  boolean emptyChairFound=false;
  if (!list.isEmpty()) {
    for (    EntityChair chair : list) {
      if (!chair.isInvisible()) {
        if (!chair.isBeingRidden()) {
          emptyChairFound=true;
        }
      }
    }
  }
  return emptyChairFound;
}","private boolean isEmptyChairNear(){
  List<EntityChair> list=this.entity.world.<EntityChair>getEntitiesWithinAABB(EntityChair.class,this.entity.getEntityBoundingBox().grow(32D));
  boolean emptyChairFound=false;
  if (!list.isEmpty()) {
    for (    EntityChair chair : list) {
      if (!chair.isInvisible()) {
        if (!chair.isBeingRidden()) {
          emptyChairFound=true;
        }
      }
    }
  }
  return emptyChairFound;
}",0.9954233409610984
109755,"/** 
 * Execute a one shot task or start executing a continuous task
 */
@Override public void startExecuting(){
  List<EntityChair> list=this.entity.world.<EntityChair>getEntitiesWithinAABB(EntityChair.class,this.entity.getEntityBoundingBox().grow(16D));
  if (!list.isEmpty()) {
    for (    EntityChair chair : list) {
      if (!chair.isInvisible()) {
        if (!chair.isBeingRidden()) {
          this.entity.startRiding(chair);
          this.entity.setSitting(true);
        }
      }
    }
  }
}","/** 
 * Execute a one shot task or start executing a continuous task
 */
@Override public void startExecuting(){
  List<EntityChair> list=this.entity.world.<EntityChair>getEntitiesWithinAABB(EntityChair.class,this.entity.getEntityBoundingBox().grow(32D));
  if (!list.isEmpty()) {
    for (    EntityChair chair : list) {
      if (!chair.isInvisible()) {
        if (!chair.isBeingRidden()) {
          this.entity.setSitting(true);
          this.aiSit.setSitting(true);
          this.entity.startRiding(chair);
          return;
        }
      }
    }
  }
}",0.8903467666354264
109756,"@Override public boolean shouldContinueExecuting(){
  return selfHoldingDrink(Drink.pinaColada);
}","@Override public boolean shouldContinueExecuting(){
  return this.entity.selfHoldingDrink(Drink.pinaColada);
}",0.9423076923076924
109757,"@Override public boolean shouldExecute(){
  return selfHoldingDrink(Drink.pinaColada);
}","@Override public boolean shouldExecute(){
  return this.entity.selfHoldingDrink(Drink.pinaColada);
}",0.9361702127659576
109758,"@Override public boolean shouldContinueExecuting(){
  return entity.followingHoldingPinaColada() && !selfHoldingDrink(Drink.pinaColada);
}","@Override public boolean shouldContinueExecuting(){
  return entity.getOwner() == null && entity.followingHoldingPinaColada() && !selfHoldingDrink(Drink.pinaColada);
}",0.9049180327868852
109759,"@Override public boolean shouldExecute(){
  return entity.followingHoldingPinaColada() && !selfHoldingDrink(Drink.pinaColada) && entity.isAngry();
}","@Override public boolean shouldExecute(){
  return entity.getOwner() == null && entity.followingHoldingPinaColada() && !selfHoldingDrink(Drink.pinaColada) && entity.isAngry();
}",0.9107692307692308
109760,"@Override protected void initEntityAI(){
  super.initEntityAI();
  this.aiSit=new EntityAISit(this);
  this.tasks.addTask(1,new EntityAISwimming(this));
  this.tasks.addTask(3,new EntityAIMonkeyFollowNearestWithCondition(this,1.0D,2.0F,10.0F,followPredicate));
  this.tasks.addTask(3,new EntityAIMonkeyLeap(this,0.4F));
  this.tasks.addTask(2,new EntityAIStealDrink(this));
  this.tasks.addTask(2,new EntityAISitAndDrink(this));
  this.tasks.addTask(4,new EntityAIMonkeySitInChair(this));
  this.tasks.addTask(4,this.aiSit);
  this.tasks.addTask(5,new EntityAIAttackMelee(this,1.0D,true));
  this.tasks.addTask(6,new EntityAIFollowOwner(this,1.0D,10.0F,2.0F));
  this.tasks.addTask(7,new EntityAIWander(this,1.0D));
  this.tasks.addTask(9,new EntityAIWatchClosest(this,EntityPlayer.class,8.0F));
  this.tasks.addTask(9,new EntityAILookIdle(this));
  this.targetTasks.addTask(1,new EntityAIOwnerHurtByTarget(this));
  this.targetTasks.addTask(2,new EntityAIOwnerHurtTarget(this));
  this.targetTasks.addTask(3,new EntityAIHurtByTarget(this,true,new Class[0]));
}","@Override protected void initEntityAI(){
  super.initEntityAI();
  this.aiSit=new EntityAIMonkeySit(this);
  this.tasks.addTask(1,new EntityAISwimming(this));
  this.tasks.addTask(3,new EntityAIMonkeyFollowNearestWithCondition(this,1.0D,2.0F,10.0F,followPredicate));
  this.tasks.addTask(3,new EntityAIMonkeyLeap(this,0.4F));
  this.tasks.addTask(2,new EntityAIStealDrink(this));
  this.tasks.addTask(2,new EntityAISitAndDrink(this));
  this.tasks.addTask(4,new EntityAIMonkeySitInChair(this,this.aiSit));
  this.tasks.addTask(4,this.aiSit);
  this.tasks.addTask(6,new EntityAIAttackMelee(this,1.0D,true));
  this.tasks.addTask(7,new EntityAIFollowOwner(this,1.0D,10.0F,2.0F));
  this.tasks.addTask(8,new EntityAIWander(this,1.0D));
  this.tasks.addTask(9,new EntityAIWatchClosest(this,EntityPlayer.class,8.0F));
  this.tasks.addTask(9,new EntityAILookIdle(this));
  this.targetTasks.addTask(1,new EntityAIOwnerHurtByTarget(this));
  this.targetTasks.addTask(2,new EntityAIOwnerHurtTarget(this));
  this.targetTasks.addTask(3,new EntityAIHurtByTarget(this,true,new Class[0]));
}",0.989247311827957
109761,"@Override public boolean processInteract(EntityPlayer player,EnumHand hand){
  ItemStack stack=player.getHeldItem(hand);
  if (this.isTamed()) {
    if (this.isOwner(player) && !this.world.isRemote && !stack.isEmpty()&& !this.isBreedingItem(stack)) {
      this.aiSit.setSitting(!this.isSitting());
      this.isJumping=false;
      this.navigator.clearPath();
      this.setAttackTarget((EntityLivingBase)null);
    }
  }
 else   if (!stack.isEmpty() && stack.getItem() == ItemRegistry.cocktail) {
    if (!player.capabilities.isCreativeMode) {
      stack.shrink(1);
    }
    if (!this.world.isRemote) {
      if (this.rand.nextInt(3) == 0) {
        this.setTamed(true);
        this.navigator.clearPath();
        this.setAttackTarget((EntityLivingBase)null);
        this.aiSit.setSitting(true);
        this.setHealth(20.0F);
        this.setOwnerId(player.getUniqueID());
        this.playTameEffect(true);
        this.world.setEntityState(this,(byte)7);
      }
 else {
        this.playTameEffect(false);
        this.world.setEntityState(this,(byte)6);
      }
    }
    return true;
  }
  return super.processInteract(player,hand);
}","@Override public boolean processInteract(EntityPlayer player,EnumHand hand){
  ItemStack stack=player.getHeldItem(hand);
  if (this.isTamed()) {
    if (this.isOwner(player) && !this.world.isRemote) {
      System.out.println(""String_Node_Str"" + ((EntityAIMonkeySit)this.aiSit).getSitting());
      this.aiSit.setSitting(!this.isSitting());
      this.isJumping=false;
      this.navigator.clearPath();
      this.setAttackTarget((EntityLivingBase)null);
      this.setAngry(false);
    }
  }
 else   if (!stack.isEmpty() && stack.getItem() == ItemRegistry.cocktail) {
    if (!player.capabilities.isCreativeMode) {
      stack.shrink(1);
    }
    if (!this.world.isRemote) {
      if (this.rand.nextInt(3) == 0) {
        this.setTamed(true);
        this.navigator.clearPath();
        this.setAttackTarget((EntityLivingBase)null);
        this.aiSit.setSitting(true);
        this.setHealth(20.0F);
        this.setOwnerId(player.getUniqueID());
        this.playTameEffect(true);
        this.world.setEntityState(this,(byte)7);
      }
 else {
        this.playTameEffect(false);
        this.world.setEntityState(this,(byte)6);
      }
    }
    return true;
  }
  return super.processInteract(player,hand);
}",0.9263336155800168
109762,"private boolean isFullyGrown(IBlockState state){
  return ((Integer)state.getValue(STAGE)) == TOTAL_GROW_TICKS;
}","private boolean isFullyGrown(IBlockState state){
  return ((Integer)state.getValue(STAGE)) == TOTAL_GROW_TICKS || ((PlantHalf)state.getValue(BlockTallPlant.HALF)) == PlantHalf.UPPER;
}",0.7609427609427609
109763,"@SubscribeEvent public void handlePineappleBreakEvent(HarvestDropsEvent event){
  EntityPlayer player=event.getHarvester();
  if (player == null) {
    return;
  }
  ItemStack held=player.getHeldItemMainhand();
  IBlockState state=event.getState();
  if (state.getBlock() != BlockRegistry.pineapple) {
    return;
  }
  IBlockState stateUp=event.getWorld().getBlockState(event.getPos().up());
  boolean isTop=state.getValue(BlockPineapple.HALF) == PlantHalf.UPPER;
  boolean isGrown=isTop || (state.getValue(BlockPineapple.STAGE) == BlockPineapple.TOTAL_GROW_TICKS && stateUp.getBlock() instanceof BlockPineapple && stateUp.getValue(BlockPineapple.HALF) == PlantHalf.UPPER);
  if (isGrown) {
    if (held != null && held.getItem() instanceof ItemSword) {
      event.getDrops().add(new ItemStack(ItemRegistry.pineappleCubes,event.getWorld().rand.nextInt(3) + 2));
    }
 else {
      event.getDrops().add(new ItemStack(BlockRegistry.pineapple));
    }
  }
  if (!isTop) {
    event.getWorld().setBlockToAir(event.getPos().up());
  }
}","@SubscribeEvent public void handlePineappleBreakEvent(HarvestDropsEvent event){
  EntityPlayer player=event.getHarvester();
  ItemStack held=ItemStack.EMPTY;
  if (player != null)   held=player.getHeldItemMainhand();
  IBlockState state=event.getState();
  if (state.getBlock() != BlockRegistry.pineapple) {
    return;
  }
  IBlockState stateUp=event.getWorld().getBlockState(event.getPos().up());
  boolean isTop=state.getValue(BlockPineapple.HALF) == PlantHalf.UPPER;
  boolean isGrown=isTop || (state.getValue(BlockPineapple.HALF) == PlantHalf.LOWER && stateUp.getBlock() instanceof BlockPineapple && stateUp.getValue(BlockPineapple.HALF) == PlantHalf.UPPER);
  if (isGrown) {
    if (!held.isEmpty() && held.getItem() instanceof ItemSword) {
      event.getDrops().add(new ItemStack(ItemRegistry.pineappleCubes,event.getWorld().rand.nextInt(3) + 2));
    }
 else {
      event.getDrops().add(new ItemStack(BlockRegistry.pineapple));
    }
  }
  if (!isTop) {
    event.getWorld().setBlockState(event.getPos(),state.withProperty(BlockPineapple.STAGE,Integer.valueOf(1)));
  }
}",0.4803782505910166
109764,"@Override public boolean onBlockActivated(@Nonnull World world,@Nonnull BlockPos pos,@Nonnull IBlockState state,@Nonnull EntityPlayer entityPlayer,@Nonnull EnumHand hand,@Nonnull EnumFacing side,float hitX,float hitY,float hitZ){
  if (world.isRemote) {
    return true;
  }
  ItemStack stack=entityPlayer.getHeldItemMainhand();
  TileEntityDrinkMixer mixer=(TileEntityDrinkMixer)world.getTileEntity(pos);
  if (mixer == null) {
    return false;
  }
  if (mixer.isDoneMixing()) {
    mixer.retrieveResult(entityPlayer);
    return true;
  }
  if (stack.isEmpty()) {
    mixer.emptyMixer(entityPlayer);
    return true;
  }
  ItemStack ingredientStack=stack.copy();
  ingredientStack.setCount(1);
  if (mixer.addToMixer(ingredientStack)) {
    entityPlayer.inventory.decrStackSize(entityPlayer.inventory.currentItem,1);
  }
  if (stack.getItem() == ItemRegistry.bambooMug && mixer.canMix()) {
    mixer.startMixing();
    entityPlayer.inventory.decrStackSize(entityPlayer.inventory.currentItem,1);
    Drink craftedDrink=MixerRecipes.getDrink(mixer.ingredients);
    Drink pinaColada=Drink.pinaColada;
    if (craftedDrink != null && craftedDrink.drinkId == pinaColada.drinkId) {
    }
  }
  return true;
}","@Override public boolean onBlockActivated(@Nonnull World world,@Nonnull BlockPos pos,@Nonnull IBlockState state,@Nonnull EntityPlayer entityPlayer,@Nonnull EnumHand hand,@Nonnull EnumFacing side,float hitX,float hitY,float hitZ){
  if (world.isRemote) {
    return true;
  }
  ItemStack stack=entityPlayer.getHeldItemMainhand();
  TileEntityDrinkMixer mixer=(TileEntityDrinkMixer)world.getTileEntity(pos);
  if (mixer == null) {
    return false;
  }
  if (mixer.isDoneMixing()) {
    mixer.retrieveResult(entityPlayer);
    return true;
  }
  if (stack.isEmpty()) {
    mixer.emptyMixer(entityPlayer);
    return true;
  }
  ItemStack ingredientStack=stack.copy();
  ingredientStack.setCount(1);
  if (mixer.addToMixer(ingredientStack)) {
    entityPlayer.inventory.decrStackSize(entityPlayer.inventory.currentItem,1);
  }
  if (ingredientStack.getItem() == ItemRegistry.bambooMug && mixer.canMix()) {
    mixer.startMixing();
    entityPlayer.inventory.decrStackSize(entityPlayer.inventory.currentItem,1);
    Drink craftedDrink=MixerRecipes.getDrink(mixer.ingredients);
    Drink pinaColada=Drink.pinaColada;
    if (craftedDrink != null && craftedDrink.drinkId == pinaColada.drinkId) {
    }
  }
  return true;
}",0.9950454170107348
109765,"@Override public boolean makePortal(Entity entity){
  System.out.println(""String_Node_Str"");
  int searchArea=16;
  double closestSpot=-1D;
  int entityX=MathHelper.floor(entity.posX);
  int entityY=MathHelper.floor(entity.posY);
  int entityZ=MathHelper.floor(entity.posZ);
  int foundX=entityX;
  int foundY=entityY;
  int foundZ=entityZ;
  for (int x=entityX - searchArea; x <= entityX + searchArea; x++) {
    double distX=(x + 0.5D) - entity.posX;
    nextCoords:     for (int z=entityZ - searchArea; z <= entityZ + searchArea; z++) {
      double distZ=(z + 0.5D) - entity.posZ;
      int y=world.getHeight() - 1;
      BlockPos pos=new BlockPos(x,y,z);
      for (; y >= 63 - 1 && (world.getBlockState(pos).getBlock() == Blocks.AIR || !world.getBlockState(pos).isOpaqueCube()); pos=pos.down()) {
        y=pos.getY();
      }
      if (y > 63 + 20 || y < 63) {
        continue;
      }
      BlockPos tryPos=new BlockPos(x,y,z);
      if (getValidBuildBlocks().contains(world.getBlockState(tryPos))) {
        for (int xOffset=-2; xOffset <= 2; xOffset++) {
          for (int zOffset=-2; zOffset <= 2; zOffset++) {
            int otherY=world.getHeight() - 1;
            BlockPos pos1=new BlockPos(x + xOffset,otherY,z + zOffset);
            BlockPos pos2=tryPos.toImmutable();
            for (; otherY >= 63 && (world.getBlockState(pos1).getBlock() == Blocks.AIR || !world.getBlockState(pos2).isOpaqueCube()); pos1=pos1.down()) {
              otherY=pos1.getY();
            }
            if (Math.abs(y - otherY) >= 3) {
              continue nextCoords;
            }
          }
        }
        double distY=(y + 0.5D) - entity.posY;
        double distance=distX * distX + distY * distY + distZ * distZ;
        if (closestSpot < 0.0D || distance < closestSpot) {
          closestSpot=distance;
          foundX=x;
          foundY=y;
          foundZ=z;
        }
      }
    }
  }
  int worldSpawnX=MathHelper.floor(foundX);
  int worldSpawnZ=MathHelper.floor(foundZ);
  int worldSpawnY=getTerrainHeightAt(worldSpawnX,worldSpawnZ);
  int SEARCH_FOR_LAND_DISTANCE_MAX=200;
  if (closestSpot < 0.0D) {
    foundY=worldSpawnY - 2;
    boolean foundLand=false;
    for (int dist=1; !foundLand && dist < SEARCH_FOR_LAND_DISTANCE_MAX; dist++) {
      for (      EnumFacing dir : EnumFacing.HORIZONTALS) {
        BlockPos pos=new BlockPos(worldSpawnX,worldSpawnY,worldSpawnZ).offset(dir,3 + dist);
        IBlockState state=world.getBlockState(pos);
        if (getValidBuildBlocks().contains(state)) {
          foundLand=true;
          BlockPos buildpos=new BlockPos(worldSpawnX,worldSpawnY + 1,worldSpawnZ).offset(dir,3);
          while (!buildpos.equals(pos.up())) {
            world.setBlockState(buildpos,thatchBlock);
            world.setBlockState(buildpos.offset(dir.rotateY()),thatchBlock);
            world.setBlockState(buildpos.offset(dir.rotateYCCW()),thatchBlock);
            buildpos=buildpos.offset(dir);
          }
          BlockPos stairPosMid=new BlockPos(pos.getX(),worldSpawnY + 1,worldSpawnZ);
          placeStairs(stairPosMid,dir.getOpposite());
          generateThatchBorder(worldSpawnX,worldSpawnY + 1,worldSpawnZ);
          break;
        }
      }
    }
  }
  entity.setLocationAndAngles(foundX,foundY + 2,foundZ,entity.rotationYaw,0.0F);
  buildTeleporterAt(worldSpawnX,worldSpawnY + 1,worldSpawnZ,entity);
  System.out.println(""String_Node_Str"");
  return true;
}","@Override public boolean makePortal(Entity entity){
  System.out.println(""String_Node_Str"");
  int searchArea=16;
  double closestSpot=-1D;
  int entityX=MathHelper.floor(entity.posX);
  int entityY=MathHelper.floor(entity.posY);
  int entityZ=MathHelper.floor(entity.posZ);
  int foundX=entityX;
  int foundY=entityY;
  int foundZ=entityZ;
  for (int x=entityX - searchArea; x <= entityX + searchArea; x++) {
    double distX=(x + 0.5D) - entity.posX;
    nextCoords:     for (int z=entityZ - searchArea; z <= entityZ + searchArea; z++) {
      double distZ=(z + 0.5D) - entity.posZ;
      int y=world.getHeight() - 1;
      BlockPos pos=new BlockPos(x,y,z);
      for (; y >= 63 - 1 && (world.getBlockState(pos).getBlock() == Blocks.AIR || !getValidBuildBlocks().contains(world.getBlockState(pos))); pos=pos.down()) {
        y=pos.getY();
      }
      if (y > 63 + 20 || y < 63) {
        continue;
      }
      BlockPos tryPos=new BlockPos(x,y,z);
      if (getValidBuildBlocks().contains(world.getBlockState(tryPos))) {
        for (int xOffset=-2; xOffset <= 2; xOffset++) {
          for (int zOffset=-2; zOffset <= 2; zOffset++) {
            int otherY=world.getHeight() - 1;
            BlockPos pos1=new BlockPos(x + xOffset,otherY,z + zOffset);
            BlockPos pos2=tryPos.toImmutable();
            for (; otherY >= 63 && (world.getBlockState(pos1).getBlock() == Blocks.AIR || !world.getBlockState(pos2).isOpaqueCube()); pos1=pos1.down()) {
              otherY=pos1.getY();
            }
            if (Math.abs(y - otherY) >= 3) {
              continue nextCoords;
            }
          }
        }
        double distY=(y + 0.5D) - entity.posY;
        double distance=distX * distX + distY * distY + distZ * distZ;
        if (closestSpot < 0.0D || distance < closestSpot) {
          closestSpot=distance;
          foundX=x;
          foundY=y;
          foundZ=z;
        }
      }
    }
  }
  int worldSpawnX=MathHelper.floor(foundX);
  int worldSpawnZ=MathHelper.floor(foundZ);
  int worldSpawnY=getTerrainHeightAt(worldSpawnX,worldSpawnZ);
  int SEARCH_FOR_LAND_DISTANCE_MAX=200;
  if (closestSpot < 0.0D) {
    foundY=worldSpawnY - 2;
    boolean foundLand=false;
    for (int dist=1; !foundLand && dist < SEARCH_FOR_LAND_DISTANCE_MAX; dist++) {
      for (      EnumFacing dir : EnumFacing.HORIZONTALS) {
        BlockPos pos=new BlockPos(worldSpawnX,worldSpawnY,worldSpawnZ).offset(dir,3 + dist);
        IBlockState state=world.getBlockState(pos);
        if (getValidBuildBlocks().contains(state)) {
          foundLand=true;
          BlockPos buildpos=new BlockPos(worldSpawnX,worldSpawnY + 1,worldSpawnZ).offset(dir,3);
          while (!buildpos.equals(pos.up())) {
            world.setBlockState(buildpos,thatchBlock);
            world.setBlockState(buildpos.offset(dir.rotateY()),thatchBlock);
            world.setBlockState(buildpos.offset(dir.rotateYCCW()),thatchBlock);
            buildpos=buildpos.offset(dir);
          }
          BlockPos stairPosMid=new BlockPos(pos.getX(),worldSpawnY + 1,worldSpawnZ);
          placeStairs(stairPosMid,dir.getOpposite());
          generateThatchBorder(worldSpawnX,worldSpawnY + 1,worldSpawnZ);
          break;
        }
      }
    }
  }
  entity.setLocationAndAngles(foundX,foundY + 2,foundZ,entity.rotationYaw,0.0F);
  buildTeleporterAt(worldSpawnX,worldSpawnY + 1,worldSpawnZ,entity);
  System.out.println(""String_Node_Str"");
  return true;
}",0.9887804167273788
109766,"/** 
 * Generate the EIH statue with cool eyes and lava inside!
 * @param pos Block position
 */
@Override public boolean generate(BlockPos pos){
  byte height=5;
  int i=pos.getX();
  int j=pos.getY();
  int k=pos.getZ();
  if (j < 1 || j + height + 1 > CHUNK_SIZE_Y) {
    return false;
  }
  Material matDown=worldObj.getBlockState(pos.down()).getMaterial();
  if (matDown == Material.GROUND && TCGenUtils.isAirBlock(worldObj,i,j,k)) {
    j++;
    setBlock(worldObj,i + 0,j + 0,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 0,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 0,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 1,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 1,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 2,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 3,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 3,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 4,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 3,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 3,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 2,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 4,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 4,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 4,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 5,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 5,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 5,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 5,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 3,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 4,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 6,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 6,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 6,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 6,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 6,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 1,j + 5,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 1,j + 5,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 1,j + 4,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 1,j + 4,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 2,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 0,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 6,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 5,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 4,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 5,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 3,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 4,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 3,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 2,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 3,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 2,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 1,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 3,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 3,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 2,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 3,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 4,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 5,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 6,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 6,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 6,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 5,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 5,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 4,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 4,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 5,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 4,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 3,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 4,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 3,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 2,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 3,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 2,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 1,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -3,j + 0,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 0,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 0,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 0,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 1,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 1,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 2,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 2,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 4,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 3,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 3,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 4,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 5,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 6,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 6,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 6,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -4,j + 5,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -4,j + 4,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -4,j + 4,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 4,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + 0,j + 4,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -3,j + 4,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -3,j + 4,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -3,j + 5,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -4,j + 5,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -1,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -1,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -1,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -1,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -2,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -2,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -2,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -2,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -3,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 0,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + -1,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + -1,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + -2,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + -2,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + -3,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -3,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -3,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -3,k + 0,EIH_BLOCK);
    int k1=rand.nextInt(7);
    int tropiBlockMeta=rand.nextInt(3);
    int eyeOneX=i;
    int eyeOneY=j + 5;
    int eyeOneZ=k + 1;
    int eyeTwoX=i - 3;
    int eyeTwoY=j + 5;
    int eyeTwoZ=k + 1;
    placeEye(eyeOneX,eyeOneY,eyeOneZ,k1,tropiBlockMeta);
    placeEye(eyeTwoX,eyeTwoY,eyeTwoZ,k1,tropiBlockMeta);
  }
  return true;
}","/** 
 * Generate the EIH statue with cool eyes and lava inside!
 * @param pos Block position
 */
@Override public boolean generate(BlockPos pos){
  byte height=5;
  int i=pos.getX();
  int j=pos.getY();
  int k=pos.getZ();
  if (j < 1 || j + height + 1 > CHUNK_SIZE_Y) {
    return false;
  }
  Material matDown=worldObj.getBlockState(pos.down()).getMaterial();
  if (ArrayUtils.contains(VALID_MATERIALS_FOR_PLACEMENT,matDown) && TCGenUtils.isAirBlock(worldObj,i,j,k)) {
    j++;
    setBlock(worldObj,i + 0,j + 0,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 0,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 0,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 1,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 1,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 2,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 3,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 3,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 4,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 3,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 3,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 2,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 4,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 4,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 4,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 5,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 5,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 5,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 5,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 3,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 4,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 6,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 6,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 6,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 6,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 6,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 1,j + 5,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 1,j + 5,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 1,j + 4,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 1,j + 4,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 2,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 0,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 6,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 5,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 4,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 5,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 3,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 4,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 3,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 2,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 3,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 2,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + 1,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 3,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 3,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 2,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 3,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 4,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 5,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 6,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 6,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 6,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 5,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 5,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 4,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 4,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 5,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 4,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 3,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 4,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 3,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 2,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 3,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 2,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 1,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -3,j + 0,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 0,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 0,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 0,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 1,k + 4,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 1,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 2,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 2,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 4,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 3,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 3,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 4,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 5,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 6,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 6,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + 6,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -4,j + 5,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -4,j + 4,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -4,j + 4,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + 4,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + 0,j + 4,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -3,j + 4,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -3,j + 4,k + 1,Blocks.LAVA);
    setBlock(worldObj,i + -3,j + 5,k + 0,Blocks.LAVA);
    setBlock(worldObj,i + -4,j + 5,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 1,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 1,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + 0,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + -1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -1,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -1,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -1,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -1,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -1,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -1,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -2,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -2,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -2,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -2,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -2,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -2,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -3,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + 0,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + 0,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + -1,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + -1,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + -2,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -1,j + -2,k + 2,Blocks.LAVA);
    setBlock(worldObj,i + -2,j + -3,k + 3,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -3,k + 2,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -3,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -3,k + 1,EIH_BLOCK);
    setBlock(worldObj,i + -3,j + -3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -2,j + -3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + -1,j + -3,k + 0,EIH_BLOCK);
    setBlock(worldObj,i + 0,j + -3,k + 0,EIH_BLOCK);
    int k1=rand.nextInt(7);
    int tropiBlockMeta=rand.nextInt(3);
    int eyeOneX=i;
    int eyeOneY=j + 5;
    int eyeOneZ=k + 1;
    int eyeTwoX=i - 3;
    int eyeTwoY=j + 5;
    int eyeTwoZ=k + 1;
    placeEye(eyeOneX,eyeOneY,eyeOneZ,k1,tropiBlockMeta);
    placeEye(eyeTwoX,eyeTwoY,eyeTwoZ,k1,tropiBlockMeta);
  }
  return true;
}",0.9963446475195824
109767,"@Override public boolean onBlockActivated(World world,BlockPos pos,IBlockState state,EntityPlayer entityPlayer,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (world.isRemote) {
    return true;
  }
  ItemStack stack=entityPlayer.getHeldItem(hand);
  TileEntitySifter tileentitysifta=(TileEntitySifter)world.getTileEntity(pos);
  if (tileentitysifta != null && !stack.isEmpty() && !tileentitysifta.isSifting()) {
    Item helditem=stack.getItem();
    if (helditem == Item.getItemFromBlock(Blocks.SAND) || (helditem == Item.getItemFromBlock(BlockRegistry.sands))) {
      entityPlayer.getHeldItemMainhand().shrink(1);
      tileentitysifta.addItemToSifter(stack);
      tileentitysifta.startSifting();
    }
  }
  return true;
}","@Override public boolean onBlockActivated(World world,BlockPos pos,IBlockState state,EntityPlayer entityPlayer,EnumHand hand,EnumFacing side,float hitX,float hitY,float hitZ){
  if (world.isRemote) {
    return true;
  }
  ItemStack stack=entityPlayer.getHeldItem(hand);
  TileEntitySifter tileentitysifta=(TileEntitySifter)world.getTileEntity(pos);
  if (tileentitysifta != null && !stack.isEmpty() && !tileentitysifta.isSifting()) {
    Item helditem=stack.getItem();
    if (helditem == Item.getItemFromBlock(Blocks.SAND) || (helditem == Item.getItemFromBlock(BlockRegistry.sands))) {
      tileentitysifta.addItemToSifter(stack);
      tileentitysifta.startSifting();
      entityPlayer.getHeldItemMainhand().shrink(1);
    }
  }
  return true;
}",0.8626666666666667
109768,"/** 
 * Drop all the necessary blocks/items from the sifter after sifting is complete
 */
public void dumpResults(double x,double y,double z,SiftType type){
  if (type == SiftType.HEATED) {
    spawn(new ItemStack(BlockRegistry.sands,1,0),x,y,z);
  }
 else {
    dumpBeachResults(x,y,z);
  }
  this.syncInventory();
}","/** 
 * Drop all the necessary blocks/items from the sifter after sifting is complete
 */
public void dumpResults(double x,double y,double z,SiftType type){
  dumpBeachResults(x,y,z);
  this.syncInventory();
}",0.7338403041825095
109769,"/** 
 * Dump the items involved in regular sifting
 */
private void dumpBeachResults(double x,double y,double z){
  int dumpCount=rand.nextInt(3) + 1;
  ItemStack stack;
  spawn(new ItemStack(BlockRegistry.sands,1,0),x,y,z);
  while (dumpCount > 0) {
    dumpCount--;
    if (rand.nextInt(10) == 0) {
      stack=getRareItem();
    }
 else {
      stack=getCommonItem();
    }
    spawn(stack,x,y,z);
  }
}","/** 
 * Dump the items involved in regular sifting
 */
private void dumpBeachResults(double x,double y,double z){
  int dumpCount=rand.nextInt(3) + 1;
  ItemStack stack;
  while (dumpCount > 0) {
    dumpCount--;
    if (rand.nextInt(10) == 0) {
      stack=getRareItem();
    }
 else {
      stack=getCommonItem();
    }
    spawn(stack,x,y,z);
  }
}",0.927344782034346
109770,"@Override public void renderTileEntityFast(TileSeaweed te,double x,double y,double z,float partialTicks,int destroyStage,float alpha,BufferBuilder buf){
  if (te == null) {
    return;
  }
  buf.setTranslation(x,y,z);
  Vec3d bot=new Vec3d(0.5,1,0.5).add(te.getOffset());
  Vec3d prevSway=new Vec3d(0,1,0);
  for (int i=0; i < te.getHeight(); i++) {
    Vec3d sway=computeSwayVector(te.getSwayAngle(),i,TropicraftRenderUtils.getElapsedTicks() + partialTicks + te.getSwayDelay());
    Vec3d top=bot.add(sway);
    int texture=i == te.getHeight() - 1 ? SPRITES.length - 1 : (te.getHeight() + i) % (SPRITES.length - 1);
    TextureAtlasSprite sprite=SPRITES[texture];
    renderQuad(buf,sprite,bot,top,sway,prevSway,new Vec3d(1,0,1));
    renderQuad(buf,sprite,bot,top,sway,prevSway,new Vec3d(-1,0,1));
    bot=top;
  }
  buf.setTranslation(0,0,0);
}","@Override public void renderTileEntityFast(TileSeaweed te,double x,double y,double z,float partialTicks,int destroyStage,float alpha,BufferBuilder buf){
  if (te == null) {
    return;
  }
  buf.setTranslation(x,y,z);
  Vec3d bot=new Vec3d(0.5,1,0.5).add(te.getOffset());
  Vec3d prevSway=new Vec3d(0,1,0);
  for (int i=0; i < te.getHeight(); i++) {
    Vec3d sway=computeSwayVector(te.getSwayAngle(),i,TropicraftRenderUtils.getElapsedTicks() + partialTicks + te.getSwayDelay());
    Vec3d top=bot.add(sway);
    int texture=i == te.getHeight() - 1 ? SPRITES.length - 1 : (te.getHeight() + i) % (SPRITES.length - 1);
    TextureAtlasSprite sprite=SPRITES[texture];
    renderQuad(buf,sprite,bot,top,sway,prevSway,new Vec3d(1,0,1));
    renderQuad(buf,sprite,bot,top,sway,prevSway,new Vec3d(-1,0,1));
    bot=top;
    prevSway=sway;
  }
  buf.setTranslation(0,0,0);
}",0.9889083479276124
109771,"@EventHandler public void init(FMLInitializationEvent event){
  TCPacketHandler.init();
  ItemRegistry.init();
  proxy.init();
  proxy.registerBooks();
  MinecraftForge.EVENT_BUS.register(new ItemEvents());
  MinecraftForge.EVENT_BUS.register(new BlockEvents());
  MinecraftForge.EVENT_BUS.register(new AchievementEvents());
  MinecraftForge.EVENT_BUS.register(new BuildEvents());
  MinecraftForge.EVENT_BUS.register(new MiscEvents());
  MinecraftForge.EVENT_BUS.register(new SpawnEvents());
  MinecraftForge.EVENT_BUS.register(new ScubaHandlerCommon());
  BiomeTropicraft.registerBiomes();
  GameRegistry.registerWorldGenerator(new TCWorldGenerator(),10);
  TropicraftWorldUtils.initializeDimension();
}","@EventHandler public void init(FMLInitializationEvent event){
  TCPacketHandler.init();
  proxy.init();
  proxy.registerBooks();
  SmeltingRegistry.init();
  MinecraftForge.EVENT_BUS.register(new ItemEvents());
  MinecraftForge.EVENT_BUS.register(new BlockEvents());
  MinecraftForge.EVENT_BUS.register(new AchievementEvents());
  MinecraftForge.EVENT_BUS.register(new BuildEvents());
  MinecraftForge.EVENT_BUS.register(new MiscEvents());
  MinecraftForge.EVENT_BUS.register(new SpawnEvents());
  MinecraftForge.EVENT_BUS.register(new ScubaHandlerCommon());
  BiomeTropicraft.registerBiomes();
  GameRegistry.registerWorldGenerator(new TCWorldGenerator(),10);
  TropicraftWorldUtils.initializeDimension();
}",0.9645892351274789
109772,"/** 
 * returns a list of blocks with the same ID, but different meta (eg: wood returns 4 blocks)
 */
@SideOnly(Side.CLIENT) public void getSubBlocks(Item item,CreativeTabs tab,List<ItemStack> list){
  for (int i=0; i < TropicraftLogs.values().length; i++) {
    list.add(new ItemStack(item,1,i));
  }
}","/** 
 * returns a list of blocks with the same ID, but different meta (eg: wood returns 4 blocks)
 */
@Override @SideOnly(Side.CLIENT) public void getSubBlocks(CreativeTabs tab,NonNullList<ItemStack> list){
  for (int i=0; i < TropicraftLogs.values().length; i++) {
    list.add(new ItemStack(this,1,i));
  }
}",0.8907014681892332
109773,"@SubscribeEvent public void handlePineappleBreakEvent(HarvestDropsEvent event){
  EntityPlayer player=event.getHarvester();
  if (player == null) {
    return;
  }
  ItemStack held=player.getHeldItemMainhand();
  IBlockState state=event.getState();
  if (state.getBlock() != BlockRegistry.pineapple) {
    return;
  }
  boolean isTop=state.getValue(BlockPineapple.HALF) == PlantHalf.UPPER;
  boolean isGrown=isTop || state.getValue(BlockPineapple.STAGE) == BlockPineapple.TOTAL_GROW_TICKS;
  if (isGrown) {
    if (held != null && held.getItem() instanceof ItemSword) {
      event.getDrops().add(new ItemStack(ItemRegistry.pineappleCubes,event.getWorld().rand.nextInt(3) + 2));
    }
 else {
      event.getDrops().add(new ItemStack(BlockRegistry.pineapple));
    }
  }
  if (!isTop) {
    event.getWorld().setBlockToAir(event.getPos().up());
  }
}","@SubscribeEvent public void handlePineappleBreakEvent(HarvestDropsEvent event){
  EntityPlayer player=event.getHarvester();
  if (player == null) {
    return;
  }
  ItemStack held=player.getHeldItemMainhand();
  IBlockState state=event.getState();
  if (state.getBlock() != BlockRegistry.pineapple) {
    return;
  }
  IBlockState stateUp=event.getWorld().getBlockState(event.getPos().up());
  boolean isTop=state.getValue(BlockPineapple.HALF) == PlantHalf.UPPER;
  boolean isGrown=isTop || (state.getValue(BlockPineapple.STAGE) == BlockPineapple.TOTAL_GROW_TICKS && stateUp.getBlock() instanceof BlockPineapple && stateUp.getValue(BlockPineapple.HALF) == PlantHalf.UPPER);
  if (isGrown) {
    if (held != null && held.getItem() instanceof ItemSword) {
      event.getDrops().add(new ItemStack(ItemRegistry.pineappleCubes,event.getWorld().rand.nextInt(3) + 2));
    }
 else {
      event.getDrops().add(new ItemStack(BlockRegistry.pineapple));
    }
  }
  if (!isTop) {
    event.getWorld().setBlockToAir(event.getPos().up());
  }
}",0.9017525225703664
109774,"public ItemStack getTankStack(){
  return stack;
}","@Nonnull public ItemStack getTankStack(){
  return stack;
}",0.9174311926605504
109775,"@Override public boolean isActive(){
  return getTankStack() != null;
}","@Override public boolean isActive(){
  return !getTankStack().isEmpty();
}",0.8689655172413793
109776,"@Override public IMessage onMessage(MessageAirCompressorInventory message,MessageContext ctx){
  TileEntityAirCompressor compressor=message.getClientTileEntity();
  if (compressor != null) {
    if (message.tank != null) {
      compressor.addTank(message.tank);
    }
 else {
      compressor.ejectTank();
    }
  }
  return null;
}","@Override public IMessage onMessage(MessageAirCompressorInventory message,MessageContext ctx){
  TileEntityAirCompressor compressor=message.getClientTileEntity();
  if (compressor != null) {
    if (!message.tank.isEmpty()) {
      compressor.addTank(message.tank);
    }
 else {
      compressor.ejectTank();
    }
  }
  return null;
}",0.9715994020926756
109777,"private void printRecipes() throws Exception {
  List<ShapedRecipes> recipes=((Encyclopedia)book).getRecipesForEntry(selectedIndex);
  if (recipes == null || recipes.isEmpty()) {
    return;
  }
  int newx=width / 2 + 25;
  int newy=height / 2 - 80;
  int indexPosition=0;
  for (int entry=contentPage * book.entriesPerContentPage(contentMode); entry < (contentPage + 1) * book.entriesPerContentPage(contentMode); entry++) {
    if (entry >= book.getContentPageCount(selectedIndex,contentMode)) {
      return;
    }
    Encyclopedia.RecipeEntry recipe=((Encyclopedia)book).getFormattedRecipe(recipes.get(entry));
    TropicraftRenderUtils.bindTextureGui(openTextureIndex);
    drawTexturedModalRect(newx - 3,newy - 3,0,187,122,60);
    int offsetX=18;
    int offsetY=18;
    for (int row=0; row < recipe.height; row++) {
      for (int col=0; col < recipe.width; col++) {
        int itemIndex=(row * recipe.width) + col;
        if (recipe.ingredients[itemIndex] != null) {
          int renderX=newx + (offsetX * col) + 1;
          int renderY=newy + (offsetY * row) + 1;
          GlStateManager.pushMatrix();
          GlStateManager.enableRescaleNormal();
          RenderHelper.enableGUIStandardItemLighting();
          itemRenderer.renderItemIntoGUI(recipe.ingredients[itemIndex],renderX,renderY);
          RenderHelper.disableStandardItemLighting();
          GlStateManager.disableRescaleNormal();
          GlStateManager.popMatrix();
        }
      }
    }
    for (int row=0; row < recipe.height; row++) {
      for (int col=0; col < recipe.width; col++) {
        int itemIndex=(row * recipe.width) + col;
        int renderX=newx + (offsetX * col) + 1;
        int renderY=newy + (offsetY * row) + 1;
        checkMouseHover(recipe.ingredients[itemIndex],renderX,renderY,18);
      }
    }
    GlStateManager.pushMatrix();
    GlStateManager.scale(1.5F,1.5F,1.5F);
    GlStateManager.translate(newx / 3F + 1F,newy / 3F - .75F,0F);
    GlStateManager.enableRescaleNormal();
    RenderHelper.enableGUIStandardItemLighting();
    itemRenderer.renderItemIntoGUI(recipe.output,newx / 3 + 60,newy / 3 + 11);
    itemRenderer.renderItemOverlayIntoGUI(fontRenderer,recipe.output,newx / 3 + 60,newy / 3 + 11,""String_Node_Str"");
    RenderHelper.disableStandardItemLighting();
    GlStateManager.disableRescaleNormal();
    GlStateManager.popMatrix();
    GlStateManager.pushMatrix();
    checkMouseHover(recipe.output,newx + 90,newy + 20,25);
    GlStateManager.popMatrix();
    indexPosition++;
    newy+=62;
  }
}","private void printRecipes() throws Exception {
  List<ShapedRecipes> recipes=((Encyclopedia)book).getRecipesForEntry(selectedIndex);
  if (recipes == null || recipes.isEmpty()) {
    return;
  }
  int newx=width / 2 + 25;
  int newy=height / 2 - 80;
  int indexPosition=0;
  for (int entry=contentPage * book.entriesPerContentPage(contentMode); entry < (contentPage + 1) * book.entriesPerContentPage(contentMode); entry++) {
    if (entry >= book.getContentPageCount(selectedIndex,contentMode)) {
      return;
    }
    Encyclopedia.RecipeEntry recipe=((Encyclopedia)book).getFormattedRecipe(recipes.get(entry));
    TropicraftRenderUtils.bindTextureGui(openTextureIndex);
    drawTexturedModalRect(newx - 3,newy - 3,0,187,122,60);
    int offsetX=18;
    int offsetY=18;
    for (int row=0; row < recipe.height; row++) {
      for (int col=0; col < recipe.width; col++) {
        int itemIndex=(row * recipe.width) + col;
        if (recipe.ingredients.get(itemIndex) != Ingredient.EMPTY) {
          int renderX=newx + (offsetX * col) + 1;
          int renderY=newy + (offsetY * row) + 1;
          GlStateManager.pushMatrix();
          GlStateManager.enableRescaleNormal();
          RenderHelper.enableGUIStandardItemLighting();
          itemRenderer.renderItemIntoGUI(recipe.ingredients.get(itemIndex).getMatchingStacks()[0],renderX,renderY);
          RenderHelper.disableStandardItemLighting();
          GlStateManager.disableRescaleNormal();
          GlStateManager.popMatrix();
        }
      }
    }
    for (int row=0; row < recipe.height; row++) {
      for (int col=0; col < recipe.width; col++) {
        int itemIndex=(row * recipe.width) + col;
        int renderX=newx + (offsetX * col) + 1;
        int renderY=newy + (offsetY * row) + 1;
        checkMouseHover(recipe.ingredients.get(itemIndex),renderX,renderY,18);
      }
    }
    GlStateManager.pushMatrix();
    GlStateManager.scale(1.5F,1.5F,1.5F);
    GlStateManager.translate(newx / 3F + 1F,newy / 3F - .75F,0F);
    GlStateManager.enableRescaleNormal();
    RenderHelper.enableGUIStandardItemLighting();
    itemRenderer.renderItemIntoGUI(recipe.output,newx / 3 + 60,newy / 3 + 11);
    itemRenderer.renderItemOverlayIntoGUI(fontRenderer,recipe.output,newx / 3 + 60,newy / 3 + 11,""String_Node_Str"");
    RenderHelper.disableStandardItemLighting();
    GlStateManager.disableRescaleNormal();
    GlStateManager.popMatrix();
    GlStateManager.pushMatrix();
    checkMouseHover(recipe.output,newx + 90,newy + 20,25);
    GlStateManager.popMatrix();
    indexPosition++;
    newy+=62;
  }
}",0.9872524024318494
109778,"/** 
 * Called to update the entity's position/logic.
 */
public void onUpdate(){
  super.onUpdate();
  if (this.angler == null) {
    if (this.ticksExisted > 40) {
      setDead();
    }
    return;
  }
  if (this.world.isRemote) {
    int i=((Integer)this.getDataManager().get(DATA_HOOKED_ENTITY)).intValue();
    if (i > 0 && this.caughtEntity == null) {
      this.caughtEntity=this.world.getEntityByID(i - 1);
    }
  }
 else {
    ItemStack itemstack=this.angler.getHeldItemMainhand();
    if (this.angler.isDead || !this.angler.isEntityAlive() || itemstack.isEmpty()|| itemstack.getItem() != Items.FISHING_ROD || this.getDistanceSq(this.angler) > 1024.0D) {
      this.setDead();
      this.angler.setLure(null);
      return;
    }
  }
  if (this.caughtEntity != null) {
    if (!this.caughtEntity.isDead) {
      this.posX=this.caughtEntity.posX;
      double d17=(double)this.caughtEntity.height;
      this.posY=this.caughtEntity.getEntityBoundingBox().minY + d17 * 0.8D;
      this.posZ=this.caughtEntity.posZ;
      return;
    }
    this.caughtEntity=null;
  }
  if (this.fishPosRotationIncrements > 0) {
    double d3=this.posX + (this.fishX - this.posX) / (double)this.fishPosRotationIncrements;
    double d4=this.posY + (this.fishY - this.posY) / (double)this.fishPosRotationIncrements;
    double d6=this.posZ + (this.fishZ - this.posZ) / (double)this.fishPosRotationIncrements;
    double d8=MathHelper.wrapDegrees(this.fishYaw - (double)this.rotationYaw);
    this.rotationYaw=(float)((double)this.rotationYaw + d8 / (double)this.fishPosRotationIncrements);
    this.rotationPitch=(float)((double)this.rotationPitch + (this.fishPitch - (double)this.rotationPitch) / (double)this.fishPosRotationIncrements);
    --this.fishPosRotationIncrements;
    this.setPosition(d3,d4,d6);
    this.setRotation(this.rotationYaw,this.rotationPitch);
  }
 else {
    if (this.inGround) {
      if (this.world.getBlockState(this.pos).getBlock() == this.inTile) {
        ++this.ticksInGround;
        if (this.ticksInGround == 1200) {
          this.setDead();
        }
        return;
      }
      this.inGround=false;
      this.motionX*=(double)(this.rand.nextFloat() * 0.2F);
      this.motionY*=(double)(this.rand.nextFloat() * 0.2F);
      this.motionZ*=(double)(this.rand.nextFloat() * 0.2F);
      this.ticksInGround=0;
      this.ticksInAir=0;
    }
 else {
      ++this.ticksInAir;
    }
    if (!this.world.isRemote) {
      Vec3d vec3d1=new Vec3d(this.posX,this.posY,this.posZ);
      Vec3d vec3d=new Vec3d(this.posX + this.motionX,this.posY + this.motionY,this.posZ + this.motionZ);
      RayTraceResult raytraceresult=this.world.rayTraceBlocks(vec3d1,vec3d);
      vec3d1=new Vec3d(this.posX,this.posY,this.posZ);
      vec3d=new Vec3d(this.posX + this.motionX,this.posY + this.motionY,this.posZ + this.motionZ);
      if (raytraceresult != null) {
        vec3d=new Vec3d(raytraceresult.hitVec.x,raytraceresult.hitVec.y,raytraceresult.hitVec.z);
      }
      Entity entity=null;
      List<Entity> list=this.world.getEntitiesWithinAABBExcludingEntity(this,this.getEntityBoundingBox().expand(this.motionX,this.motionY,this.motionZ).grow(1.0D));
      double d0=0.0D;
      for (int j=0; j < list.size(); ++j) {
        Entity entity1=(Entity)list.get(j);
        if (this.canBeHooked(entity1) && (entity1 != this.angler || this.ticksInAir >= 5)) {
          AxisAlignedBB axisalignedbb1=entity1.getEntityBoundingBox().grow(0.30000001192092896D);
          RayTraceResult raytraceresult1=axisalignedbb1.calculateIntercept(vec3d1,vec3d);
          if (raytraceresult1 != null) {
            double d1=vec3d1.squareDistanceTo(raytraceresult1.hitVec);
            if (d1 < d0 || d0 == 0.0D) {
              entity=entity1;
              d0=d1;
            }
          }
        }
      }
      if (entity != null) {
        raytraceresult=new RayTraceResult(entity);
      }
      if (raytraceresult != null) {
        if (raytraceresult.entityHit != null) {
          this.caughtEntity=raytraceresult.entityHit;
          this.getDataManager().set(DATA_HOOKED_ENTITY,Integer.valueOf(this.caughtEntity.getEntityId() + 1));
        }
 else {
          this.inGround=true;
        }
      }
    }
    if (!this.inGround) {
      this.move(MoverType.SELF,this.motionX,this.motionY,this.motionZ);
      float f2=MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
      this.rotationYaw=(float)(MathHelper.atan2(this.motionX,this.motionZ) * (180D / Math.PI));
      for (this.rotationPitch=(float)(MathHelper.atan2(this.motionY,(double)f2) * (180D / Math.PI)); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch-=360.0F) {
        ;
      }
      while (this.rotationPitch - this.prevRotationPitch >= 180.0F) {
        this.prevRotationPitch+=360.0F;
      }
      while (this.rotationYaw - this.prevRotationYaw < -180.0F) {
        this.prevRotationYaw-=360.0F;
      }
      while (this.rotationYaw - this.prevRotationYaw >= 180.0F) {
        this.prevRotationYaw+=360.0F;
      }
      this.rotationPitch=this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * 0.2F;
      this.rotationYaw=this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * 0.2F;
      float f3=0.92F;
      if (this.onGround || this.collidedHorizontally) {
        f3=0.5F;
      }
      int k=5;
      double d5=0.0D;
      for (int l=0; l < 5; ++l) {
        AxisAlignedBB axisalignedbb=this.getEntityBoundingBox();
        double d9=axisalignedbb.maxY - axisalignedbb.minY;
        double d10=axisalignedbb.minY + d9 * (double)l / 5.0D;
        double d11=axisalignedbb.minY + d9 * (double)(l + 1) / 5.0D;
        AxisAlignedBB axisalignedbb2=new AxisAlignedBB(axisalignedbb.minX,d10,axisalignedbb.minZ,axisalignedbb.maxX,d11,axisalignedbb.maxZ);
        if (this.world.isMaterialInBB(axisalignedbb2,Material.WATER)) {
          d5+=0.2D;
        }
      }
      if (!this.world.isRemote && d5 > 0.0D) {
        WorldServer worldserver=(WorldServer)this.world;
        int i1=1;
        BlockPos blockpos=(new BlockPos(this)).up();
        if (this.rand.nextFloat() < 0.25F && this.world.isRainingAt(blockpos)) {
          i1=2;
        }
        if (this.rand.nextFloat() < 0.5F && !this.world.canSeeSky(blockpos)) {
          --i1;
        }
        if (this.ticksCatchable > 0) {
          --this.ticksCatchable;
          if (this.ticksCatchable <= 0) {
            this.ticksCaughtDelay=0;
            this.ticksCatchableDelay=0;
          }
        }
 else         if (this.ticksCatchableDelay > 0) {
          this.ticksCatchableDelay-=i1;
          if (this.ticksCatchableDelay <= 0) {
            this.motionY-=0.20000000298023224D;
            this.playSound(SoundEvents.ENTITY_BOBBER_SPLASH,0.25F,1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
            float f6=(float)MathHelper.floor(this.getEntityBoundingBox().minY);
            worldserver.spawnParticle(EnumParticleTypes.WATER_BUBBLE,this.posX,(double)(f6 + 1.0F),this.posZ,(int)(1.0F + this.width * 20.0F),(double)this.width,0.0D,(double)this.width,0.20000000298023224D,new int[0]);
            worldserver.spawnParticle(EnumParticleTypes.WATER_WAKE,this.posX,(double)(f6 + 1.0F),this.posZ,(int)(1.0F + this.width * 20.0F),(double)this.width,0.0D,(double)this.width,0.20000000298023224D,new int[0]);
            this.ticksCatchable=MathHelper.getInt(this.rand,10,30);
          }
 else {
            this.fishApproachAngle=(float)((double)this.fishApproachAngle + this.rand.nextGaussian() * 4.0D);
            float f5=this.fishApproachAngle * 0.017453292F;
            float f8=MathHelper.sin(f5);
            float f10=MathHelper.cos(f5);
            double d13=this.posX + (double)(f8 * (float)this.ticksCatchableDelay * 0.1F);
            double d15=(double)((float)MathHelper.floor(this.getEntityBoundingBox().minY) + 1.0F);
            double d16=this.posZ + (double)(f10 * (float)this.ticksCatchableDelay * 0.1F);
            Block block1=worldserver.getBlockState(new BlockPos((int)d13,(int)d15 - 1,(int)d16)).getBlock();
            if (block1 == Blocks.WATER || block1 == Blocks.FLOWING_WATER) {
              if (this.rand.nextFloat() < 0.15F) {
                worldserver.spawnParticle(EnumParticleTypes.WATER_BUBBLE,d13,d15 - 0.10000000149011612D,d16,1,(double)f8,0.1D,(double)f10,0.0D,new int[0]);
              }
              float f=f8 * 0.04F;
              float f1=f10 * 0.04F;
              worldserver.spawnParticle(EnumParticleTypes.WATER_WAKE,d13,d15,d16,0,(double)f1,0.01D,(double)(-f),1.0D,new int[0]);
              worldserver.spawnParticle(EnumParticleTypes.WATER_WAKE,d13,d15,d16,0,(double)(-f1),0.01D,(double)f,1.0D,new int[0]);
            }
          }
        }
 else         if (this.ticksCaughtDelay > 0) {
          this.ticksCaughtDelay-=i1;
          float f4=0.15F;
          if (this.ticksCaughtDelay < 20) {
            f4=(float)((double)f4 + (double)(20 - this.ticksCaughtDelay) * 0.05D);
          }
 else           if (this.ticksCaughtDelay < 40) {
            f4=(float)((double)f4 + (double)(40 - this.ticksCaughtDelay) * 0.02D);
          }
 else           if (this.ticksCaughtDelay < 60) {
            f4=(float)((double)f4 + (double)(60 - this.ticksCaughtDelay) * 0.01D);
          }
          if (this.rand.nextFloat() < f4) {
            float f7=MathHelper.nextFloat(this.rand,0.0F,360.0F) * 0.017453292F;
            float f9=MathHelper.nextFloat(this.rand,25.0F,60.0F);
            double d12=this.posX + (double)(MathHelper.sin(f7) * f9 * 0.1F);
            double d14=(double)((float)MathHelper.floor(this.getEntityBoundingBox().minY) + 1.0F);
            double d2=this.posZ + (double)(MathHelper.cos(f7) * f9 * 0.1F);
            Block block=worldserver.getBlockState(new BlockPos((int)d12,(int)d14 - 1,(int)d2)).getBlock();
            if (block == Blocks.WATER || block == Blocks.FLOWING_WATER) {
              worldserver.spawnParticle(EnumParticleTypes.WATER_SPLASH,d12,d14,d2,2 + this.rand.nextInt(2),0.10000000149011612D,0.0D,0.10000000149011612D,0.0D,new int[0]);
            }
          }
          if (this.ticksCaughtDelay <= 0) {
            this.fishApproachAngle=MathHelper.nextFloat(this.rand,0.0F,360.0F);
            this.ticksCatchableDelay=MathHelper.getInt(this.rand,20,80);
          }
        }
 else {
          this.ticksCaughtDelay=MathHelper.getInt(this.rand,100,900);
          this.ticksCaughtDelay-=EnchantmentHelper.getLureModifier(this.angler) * 20 * 5;
        }
        if (this.ticksCatchable > 0) {
          this.motionY-=(double)(this.rand.nextFloat() * this.rand.nextFloat() * this.rand.nextFloat()) * 0.2D;
        }
      }
      double d7=d5 * 2.0D - 1.0D;
      this.motionY+=0.03999999910593033D * d7;
      if (d5 > 0.0D) {
        f3=(float)((double)f3 * 0.9D);
        this.motionY*=0.8D;
      }
      this.motionX*=(double)f3;
      this.motionY*=(double)f3;
      this.motionZ*=(double)f3;
      this.setPosition(this.posX,this.posY,this.posZ);
    }
  }
}","/** 
 * Called to update the entity's position/logic.
 */
public void onUpdate(){
  super.onUpdate();
  if (this.angler == null) {
    if (this.ticksExisted > 40) {
      setDead();
    }
    return;
  }
  if (this.world.isRemote) {
    int i=((Integer)this.getDataManager().get(DATA_HOOKED_ENTITY)).intValue();
    if (i > 0 && this.caughtEntity == null) {
      this.caughtEntity=this.world.getEntityByID(i - 1);
    }
  }
 else {
    ItemStack itemstack=this.angler.getHeldItemMainhand();
    if (this.angler.isDead || !this.angler.isEntityAlive() || itemstack.isEmpty()|| itemstack.getItem() != Items.FISHING_ROD || this.getDistanceSq(this.angler) > 1024.0D) {
      this.setDead();
      this.angler.setLure(null);
      return;
    }
  }
  if (this.caughtEntity != null) {
    if (!this.caughtEntity.isDead) {
      this.posX=this.caughtEntity.posX;
      double d17=(double)this.caughtEntity.height;
      this.posY=this.caughtEntity.getEntityBoundingBox().minY + d17 * 0.8D;
      this.posZ=this.caughtEntity.posZ;
      return;
    }
    this.caughtEntity=null;
  }
  if (this.fishPosRotationIncrements > 0) {
    double d3=this.posX + (this.fishX - this.posX) / (double)this.fishPosRotationIncrements;
    double d4=this.posY + (this.fishY - this.posY) / (double)this.fishPosRotationIncrements;
    double d6=this.posZ + (this.fishZ - this.posZ) / (double)this.fishPosRotationIncrements;
    double d8=MathHelper.wrapDegrees(this.fishYaw - (double)this.rotationYaw);
    this.rotationYaw=(float)((double)this.rotationYaw + d8 / (double)this.fishPosRotationIncrements);
    this.rotationPitch=(float)((double)this.rotationPitch + (this.fishPitch - (double)this.rotationPitch) / (double)this.fishPosRotationIncrements);
    --this.fishPosRotationIncrements;
    this.setPosition(d3,d4,d6);
    this.setRotation(this.rotationYaw,this.rotationPitch);
  }
 else {
    if (this.inGround) {
      if (this.world.getBlockState(this.pos).getBlock() == this.inTile) {
        ++this.ticksInGround;
        if (this.ticksInGround == 1200) {
          this.setDead();
        }
        return;
      }
      this.inGround=false;
      this.motionX*=(double)(this.rand.nextFloat() * 0.2F);
      this.motionY*=(double)(this.rand.nextFloat() * 0.2F);
      this.motionZ*=(double)(this.rand.nextFloat() * 0.2F);
      this.ticksInGround=0;
      this.ticksInAir=0;
    }
 else {
      ++this.ticksInAir;
    }
    if (!this.world.isRemote) {
      Vec3d vec3d1=new Vec3d(this.posX,this.posY,this.posZ);
      Vec3d vec3d=new Vec3d(this.posX + this.motionX,this.posY + this.motionY,this.posZ + this.motionZ);
      RayTraceResult raytraceresult=this.world.rayTraceBlocks(vec3d1,vec3d);
      vec3d1=new Vec3d(this.posX,this.posY,this.posZ);
      vec3d=new Vec3d(this.posX + this.motionX,this.posY + this.motionY,this.posZ + this.motionZ);
      if (raytraceresult != null) {
        vec3d=new Vec3d(raytraceresult.hitVec.x,raytraceresult.hitVec.y,raytraceresult.hitVec.z);
      }
      Entity entity=null;
      List<Entity> list=this.world.getEntitiesWithinAABBExcludingEntity(this,this.getEntityBoundingBox().expand(this.motionX,this.motionY,this.motionZ).grow(1.0D));
      double d0=0.0D;
      for (int j=0; j < list.size(); ++j) {
        Entity entity1=(Entity)list.get(j);
        if (this.canBeHooked(entity1) && (entity1 != this.angler || this.ticksInAir >= 5)) {
          AxisAlignedBB axisalignedbb1=entity1.getEntityBoundingBox().grow(0.30000001192092896D);
          RayTraceResult raytraceresult1=axisalignedbb1.calculateIntercept(vec3d1,vec3d);
          if (raytraceresult1 != null) {
            double d1=vec3d1.squareDistanceTo(raytraceresult1.hitVec);
            if (d1 < d0 || d0 == 0.0D) {
              entity=entity1;
              d0=d1;
            }
          }
        }
      }
      if (entity != null) {
        raytraceresult=new RayTraceResult(entity);
      }
      if (raytraceresult != null) {
        if (raytraceresult.entityHit != null) {
          this.caughtEntity=raytraceresult.entityHit;
          this.getDataManager().set(DATA_HOOKED_ENTITY,Integer.valueOf(this.caughtEntity.getEntityId() + 1));
        }
 else {
          this.inGround=true;
        }
      }
    }
    if (!this.inGround) {
      this.move(MoverType.SELF,this.motionX,this.motionY,this.motionZ);
      float f2=MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
      this.rotationYaw=(float)(MathHelper.atan2(this.motionX,this.motionZ) * (180D / Math.PI));
      for (this.rotationPitch=(float)(MathHelper.atan2(this.motionY,(double)f2) * (180D / Math.PI)); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch-=360.0F) {
        ;
      }
      while (this.rotationPitch - this.prevRotationPitch >= 180.0F) {
        this.prevRotationPitch+=360.0F;
      }
      while (this.rotationYaw - this.prevRotationYaw < -180.0F) {
        this.prevRotationYaw-=360.0F;
      }
      while (this.rotationYaw - this.prevRotationYaw >= 180.0F) {
        this.prevRotationYaw+=360.0F;
      }
      this.rotationPitch=this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * 0.2F;
      this.rotationYaw=this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * 0.2F;
      float f3=0.92F;
      if (this.onGround || this.collidedHorizontally) {
        f3=0.5F;
      }
      int k=5;
      double d5=0.0D;
      for (int l=0; l < 5; ++l) {
        AxisAlignedBB axisalignedbb=this.getEntityBoundingBox();
        double d9=axisalignedbb.maxY - axisalignedbb.minY;
        double d10=axisalignedbb.minY + d9 * (double)l / 5.0D;
        double d11=axisalignedbb.minY + d9 * (double)(l + 1) / 5.0D;
        AxisAlignedBB axisalignedbb2=new AxisAlignedBB(axisalignedbb.minX,d10,axisalignedbb.minZ,axisalignedbb.maxX,d11,axisalignedbb.maxZ);
        if (this.world.isMaterialInBB(axisalignedbb2,Material.WATER)) {
          d5+=0.2D;
        }
      }
      if (!this.world.isRemote && d5 > 0.0D) {
        WorldServer worldserver=(WorldServer)this.world;
        int i1=1;
        BlockPos blockpos=(new BlockPos(this)).up();
        if (this.rand.nextFloat() < 0.25F && this.world.isRainingAt(blockpos)) {
          i1=2;
        }
        if (this.rand.nextFloat() < 0.5F && !this.world.canSeeSky(blockpos)) {
          --i1;
        }
        if (this.ticksCatchable > 0) {
          --this.ticksCatchable;
          if (this.ticksCatchable <= 0) {
            this.ticksCaughtDelay=0;
            this.ticksCatchableDelay=0;
          }
        }
 else         if (this.ticksCatchableDelay > 0) {
          this.ticksCatchableDelay-=i1;
          if (this.ticksCatchableDelay <= 0) {
            this.motionY-=0.20000000298023224D;
            this.playSound(SoundEvents.ENTITY_BOBBER_SPLASH,0.25F,1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
            float f6=(float)MathHelper.floor(this.getEntityBoundingBox().minY);
            worldserver.spawnParticle(EnumParticleTypes.WATER_BUBBLE,this.posX,(double)(f6 + 1.0F),this.posZ,(int)(1.0F + this.width * 20.0F),(double)this.width,0.0D,(double)this.width,0.20000000298023224D,new int[0]);
            worldserver.spawnParticle(EnumParticleTypes.WATER_WAKE,this.posX,(double)(f6 + 1.0F),this.posZ,(int)(1.0F + this.width * 20.0F),(double)this.width,0.0D,(double)this.width,0.20000000298023224D,new int[0]);
            this.ticksCatchable=MathHelper.getInt(this.rand,10,30);
          }
 else {
            this.fishApproachAngle=(float)((double)this.fishApproachAngle + this.rand.nextGaussian() * 4.0D);
            float f5=this.fishApproachAngle * 0.017453292F;
            float f8=MathHelper.sin(f5);
            float f10=MathHelper.cos(f5);
            double d13=this.posX + (double)(f8 * (float)this.ticksCatchableDelay * 0.1F);
            double d15=(double)((float)MathHelper.floor(this.getEntityBoundingBox().minY) + 1.0F);
            double d16=this.posZ + (double)(f10 * (float)this.ticksCatchableDelay * 0.1F);
            Block block1=worldserver.getBlockState(new BlockPos((int)d13,(int)d15 - 1,(int)d16)).getBlock();
            if (block1 == Blocks.WATER || block1 == Blocks.FLOWING_WATER) {
              if (this.rand.nextFloat() < 0.15F) {
                worldserver.spawnParticle(EnumParticleTypes.WATER_BUBBLE,d13,d15 - 0.10000000149011612D,d16,1,(double)f8,0.1D,(double)f10,0.0D,new int[0]);
              }
              float f=f8 * 0.04F;
              float f1=f10 * 0.04F;
              worldserver.spawnParticle(EnumParticleTypes.WATER_WAKE,d13,d15,d16,0,(double)f1,0.01D,(double)(-f),1.0D,new int[0]);
              worldserver.spawnParticle(EnumParticleTypes.WATER_WAKE,d13,d15,d16,0,(double)(-f1),0.01D,(double)f,1.0D,new int[0]);
            }
          }
        }
 else         if (this.ticksCaughtDelay > 0) {
          this.ticksCaughtDelay-=i1;
          float f4=0.15F;
          if (this.ticksCaughtDelay < 20) {
            f4=(float)((double)f4 + (double)(20 - this.ticksCaughtDelay) * 0.05D);
          }
 else           if (this.ticksCaughtDelay < 40) {
            f4=(float)((double)f4 + (double)(40 - this.ticksCaughtDelay) * 0.02D);
          }
 else           if (this.ticksCaughtDelay < 60) {
            f4=(float)((double)f4 + (double)(60 - this.ticksCaughtDelay) * 0.01D);
          }
          if (this.rand.nextFloat() < f4) {
            float f7=MathHelper.nextFloat(this.rand,0.0F,360.0F) * 0.017453292F;
            float f9=MathHelper.nextFloat(this.rand,25.0F,60.0F);
            double d12=this.posX + (double)(MathHelper.sin(f7) * f9 * 0.1F);
            double d14=(double)((float)MathHelper.floor(this.getEntityBoundingBox().minY) + 1.0F);
            double d2=this.posZ + (double)(MathHelper.cos(f7) * f9 * 0.1F);
            Block block=worldserver.getBlockState(new BlockPos((int)d12,(int)d14 - 1,(int)d2)).getBlock();
            if (block == Blocks.WATER || block == Blocks.FLOWING_WATER) {
              worldserver.spawnParticle(EnumParticleTypes.WATER_SPLASH,d12,d14,d2,2 + this.rand.nextInt(2),0.10000000149011612D,0.0D,0.10000000149011612D,0.0D,new int[0]);
            }
          }
          if (this.ticksCaughtDelay <= 0) {
            this.fishApproachAngle=MathHelper.nextFloat(this.rand,0.0F,360.0F);
            this.ticksCatchableDelay=MathHelper.getInt(this.rand,20,80);
          }
        }
 else {
          this.ticksCaughtDelay=MathHelper.getInt(this.rand,100,900);
          this.ticksCaughtDelay-=EnchantmentHelper.getFishingSpeedBonus(EnchantmentHelper.getEnchantedItem(Enchantments.LURE,this.angler)) * 20 * 5;
        }
        if (this.ticksCatchable > 0) {
          this.motionY-=(double)(this.rand.nextFloat() * this.rand.nextFloat() * this.rand.nextFloat()) * 0.2D;
        }
      }
      double d7=d5 * 2.0D - 1.0D;
      this.motionY+=0.03999999910593033D * d7;
      if (d5 > 0.0D) {
        f3=(float)((double)f3 * 0.9D);
        this.motionY*=0.8D;
      }
      this.motionX*=(double)f3;
      this.motionY*=(double)f3;
      this.motionZ*=(double)f3;
      this.setPosition(this.posX,this.posY,this.posZ);
    }
  }
}",0.996245872721516
109779,"@SubscribeEvent public void onCrafting(ItemCraftedEvent event){
  if (event.player == null)   return;
  if (event.crafting.getItem() == ItemRegistry.cocktail) {
    ItemStack pinaColada=MixerRecipes.getItemStack(Drink.pinaColada);
    if (pinaColada.isItemEqual(event.crafting)) {
      event.player.addStat(AchievementRegistry.craftPinaColada);
    }
  }
}","@SubscribeEvent public void onCrafting(ItemCraftedEvent event){
  if (event.player == null)   return;
  if (event.crafting.getItem() == ItemRegistry.cocktail) {
    ItemStack pinaColada=MixerRecipes.getItemStack(Drink.pinaColada);
    if (pinaColada.isItemEqual(event.crafting)) {
    }
  }
}",0.8998459167950693
109780,"/** 
 * Called when the player finishes using this Item (E.g. finishes eating.). Not called when the player stops using the Item before the action is complete.
 */
@Nullable public ItemStack onItemUseFinish(ItemStack stack,World worldIn,EntityLivingBase entityLiving){
  if (entityLiving instanceof EntityPlayer) {
    EntityPlayer player=(EntityPlayer)entityLiving;
    this.onFoodEaten(stack,worldIn,player);
    Drink drink=getDrink(stack);
    if (worldIn.isRainingAt(player.getPosition()) && drink == Drink.pinaColada) {
      player.addStat(AchievementRegistry.drinkPinaColada);
    }
  }
  return stack;
}","/** 
 * Called when the player finishes using this Item (E.g. finishes eating.). Not called when the player stops using the Item before the action is complete.
 */
@Nullable public ItemStack onItemUseFinish(ItemStack stack,World worldIn,EntityLivingBase entityLiving){
  if (entityLiving instanceof EntityPlayer) {
    EntityPlayer player=(EntityPlayer)entityLiving;
    this.onFoodEaten(stack,worldIn,player);
    Drink drink=getDrink(stack);
    if (worldIn.isRainingAt(player.getPosition()) && drink == Drink.pinaColada) {
    }
  }
  return stack;
}",0.9150214592274678
109781,"public RecipeEntry getFormattedRecipe(ShapedRecipes recipe){
  try {
    int width=recipe.recipeWidth;
    int height=recipe.recipeHeight;
    ItemStack[] items=recipe.recipeItems;
    ItemStack output=recipe.getRecipeOutput();
    return new RecipeEntry(width,height,items,output);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  return null;
}","public RecipeEntry getFormattedRecipe(ShapedRecipes recipe){
  try {
    int width=recipe.recipeWidth;
    int height=recipe.recipeHeight;
    NonNullList<Ingredient> items=recipe.recipeItems;
    ItemStack output=recipe.getRecipeOutput();
    return new RecipeEntry(width,height,items,output);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  return null;
}",0.9561643835616438
109782,"public RecipeEntry(int width,int height,ItemStack[] ingredients,ItemStack output){
  this.width=width;
  this.height=height;
  this.ingredients=ingredients;
  this.output=output;
}","public RecipeEntry(int width,int height,NonNullList<Ingredient> items,ItemStack output){
  this.width=width;
  this.height=height;
  this.ingredients=items;
  this.output=output;
}",0.8888888888888888
109783,"public void includeRecipe(ItemStack result,Object aobj[]){
  Set<ItemStack> recipeContents=new HashSet<ItemStack>();
  addItemToRecipeContents(recipeContents,result);
  String recipeString=""String_Node_Str"";
  int i=0;
  int width=0;
  int height=0;
  if (aobj[i] instanceof String[]) {
    String[] cols=(String[])((String[])aobj[i++]);
    for (int j=0; j < cols.length; ++j) {
      String row=cols[j];
      ++height;
      width=row.length();
      recipeString=recipeString + row;
    }
  }
 else {
    while (aobj[i] instanceof String) {
      String row=(String)aobj[i++];
      ++height;
      width=row.length();
      recipeString=recipeString + row;
    }
  }
  HashMap<Character,ItemStack> charMap;
  for (charMap=new HashMap<Character,ItemStack>(); i < aobj.length; i+=2) {
    Character itemChar=(Character)aobj[i];
    ItemStack itemStack=null;
    if (aobj[i + 1] instanceof Item) {
      itemStack=new ItemStack((Item)aobj[i + 1]);
    }
 else     if (aobj[i + 1] instanceof Block) {
      itemStack=new ItemStack((Block)aobj[i + 1],1,-1);
    }
 else     if (aobj[i + 1] instanceof ItemStack) {
      itemStack=(ItemStack)aobj[i + 1];
    }
    charMap.put(itemChar,itemStack);
    addItemToRecipeContents(recipeContents,itemStack);
  }
  ItemStack[] slotArray=new ItemStack[width * height];
  for (int slots=0; slots < width * height; slots++) {
    char itemChar=recipeString.charAt(slots);
    if (charMap.containsKey(itemChar)) {
      slotArray[slots]=((ItemStack)charMap.get(itemChar)).copy();
    }
 else {
      slotArray[slots]=null;
    }
  }
  ShapedRecipes recipe=new ShapedRecipes(width,height,slotArray,result);
  for (  ItemStack item : recipeContents) {
    boolean foundKey=false;
    for (    ItemStack key : recipes.keySet()) {
      if (item.isItemEqual(key)) {
        foundKey=true;
        recipes.get(key).add(recipe);
        break;
      }
    }
    if (foundKey == false) {
      recipes.put(item,new ArrayList<ShapedRecipes>());
      recipes.get(item).add(recipe);
    }
  }
}","public void includeRecipe(ItemStack result,Object aobj[]){
  Set<ItemStack> recipeContents=new HashSet<ItemStack>();
  addItemToRecipeContents(recipeContents,result);
  String recipeString=""String_Node_Str"";
  int i=0;
  int width=0;
  int height=0;
  if (aobj[i] instanceof String[]) {
    String[] cols=(String[])((String[])aobj[i++]);
    for (int j=0; j < cols.length; ++j) {
      String row=cols[j];
      ++height;
      width=row.length();
      recipeString=recipeString + row;
    }
  }
 else {
    while (aobj[i] instanceof String) {
      String row=(String)aobj[i++];
      ++height;
      width=row.length();
      recipeString=recipeString + row;
    }
  }
  HashMap<Character,ItemStack> charMap;
  for (charMap=new HashMap<Character,ItemStack>(); i < aobj.length; i+=2) {
    Character itemChar=(Character)aobj[i];
    ItemStack itemStack=null;
    if (aobj[i + 1] instanceof Item) {
      itemStack=new ItemStack((Item)aobj[i + 1]);
    }
 else     if (aobj[i + 1] instanceof Block) {
      itemStack=new ItemStack((Block)aobj[i + 1],1,-1);
    }
 else     if (aobj[i + 1] instanceof ItemStack) {
      itemStack=(ItemStack)aobj[i + 1];
    }
    charMap.put(itemChar,itemStack);
    addItemToRecipeContents(recipeContents,itemStack);
  }
  NonNullList<Ingredient> slotArray=NonNullList.withSize(width * height,Ingredient.EMPTY);
  for (int slots=0; slots < width * height; slots++) {
    char itemChar=recipeString.charAt(slots);
    if (charMap.containsKey(itemChar)) {
      slotArray.set(slots,CraftingHelper.getIngredient(charMap.get(itemChar)));
    }
  }
  ShapedRecipes recipe=new ShapedRecipes(null,width,height,slotArray,result);
  for (  ItemStack item : recipeContents) {
    boolean foundKey=false;
    for (    ItemStack key : recipes.keySet()) {
      if (item.isItemEqual(key)) {
        foundKey=true;
        recipes.get(key).add(recipe);
        break;
      }
    }
    if (foundKey == false) {
      recipes.put(item,new ArrayList<ShapedRecipes>());
      recipes.get(item).add(recipe);
    }
  }
}",0.925615763546798
109784,"@SubscribeEvent public void handlePineappleBreakEvent(HarvestDropsEvent event){
  EntityPlayer player=event.getHarvester();
  if (player == null) {
    return;
  }
  ItemStack held=player.getHeldItemMainhand();
  IBlockState state=event.getState();
  boolean isTop=state.getValue(BlockPineapple.HALF) == PlantHalf.UPPER;
  boolean isGrown=isTop || state.getValue(BlockPineapple.STAGE) == BlockPineapple.TOTAL_GROW_TICKS;
  if (isGrown) {
    if (held != null && held.getItem() instanceof ItemSword) {
      event.getDrops().add(new ItemStack(ItemRegistry.pineappleCubes,event.getWorld().rand.nextInt(4)));
    }
 else {
      event.getDrops().add(new ItemStack(BlockRegistry.pineapple));
    }
  }
  if (!isTop) {
    event.getWorld().setBlockToAir(event.getPos().up());
  }
}","@SubscribeEvent public void handlePineappleBreakEvent(HarvestDropsEvent event){
  EntityPlayer player=event.getHarvester();
  if (player == null) {
    return;
  }
  ItemStack held=player.getHeldItemMainhand();
  IBlockState state=event.getState();
  if (state.getBlock() != BlockRegistry.pineapple) {
    return;
  }
  boolean isTop=state.getValue(BlockPineapple.HALF) == PlantHalf.UPPER;
  boolean isGrown=isTop || state.getValue(BlockPineapple.STAGE) == BlockPineapple.TOTAL_GROW_TICKS;
  if (isGrown) {
    if (held != null && held.getItem() instanceof ItemSword) {
      event.getDrops().add(new ItemStack(ItemRegistry.pineappleCubes,event.getWorld().rand.nextInt(4)));
    }
 else {
      event.getDrops().add(new ItemStack(BlockRegistry.pineapple));
    }
  }
  if (!isTop) {
    event.getWorld().setBlockToAir(event.getPos().up());
  }
}",0.9574336829117828
109785,"public AIAshenShootDart(EntityAshen entity){
  this.entity=entity;
  this.attackCooldown=60;
  this.maxAttackDistance=15 * 15;
  this.moveSpeedAmplifier=2.0F;
}","public AIAshenShootDart(EntityAshen entity){
  this.entity=entity;
  this.attackCooldown=60;
  this.maxAttackDistance=15 * 15;
  this.moveSpeedAmplifier=1.0F;
}",0.99375
109786,"@Override protected void applyEntityAttributes(){
  super.applyEntityAttributes();
  this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(20.0D);
  this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.24D);
  this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(getAttackStrength());
}","@Override protected void applyEntityAttributes(){
  super.applyEntityAttributes();
  this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(20.0D);
  this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.35D);
  this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(getAttackStrength());
}",0.9943502824858758
109787,"@Override public void onUpdate(){
  if (!world.isRemote) {
    if (this.ticksExisted == 1 && type >= 0) {
      this.setType(type);
    }
  }
  if (onGround) {
    this.motionX*=.5F;
    this.motionZ*=.5F;
    this.motionY=0;
  }
  if (this.checkForWater(0)) {
    this.motionY=.02F;
    this.motionX*=.95F;
    this.motionZ*=.95F;
  }
 else {
    int xMod=world.rand.nextInt(10);
    int yMod=world.rand.nextInt(30);
    int zMod=world.rand.nextInt(10);
    int[] a=this.getRotator();
    a[0]+=xMod;
    a[1]+=yMod;
    a[2]+=zMod;
    this.setRotator(a);
    motionY-=.05f;
  }
  this.move(motionX,motionY,motionZ);
}","@Override public void onUpdate(){
  if (!world.isRemote) {
    if (this.ticksExisted == 1 && type >= 0) {
      this.setType(type);
    }
    if (this.ticksExisted >= 24000) {
      this.setDead();
    }
  }
  if (onGround) {
    this.motionX*=.5F;
    this.motionZ*=.5F;
    this.motionY=0;
  }
  if (this.checkForWater(0)) {
    this.motionY=.02F;
    this.motionX*=.95F;
    this.motionZ*=.95F;
  }
 else {
    int xMod=world.rand.nextInt(10);
    int yMod=world.rand.nextInt(30);
    int zMod=world.rand.nextInt(10);
    int[] a=this.getRotator();
    a[0]+=xMod;
    a[1]+=yMod;
    a[2]+=zMod;
    this.setRotator(a);
    motionY-=.05f;
  }
  this.move(motionX,motionY,motionZ);
}",0.9494640122511484
109788,"@Override public ModelBiped getArmorModel(EntityLivingBase entityLiving,ItemStack itemStack,EntityEquipmentSlot armorSlot,ModelBiped _default){
  if (armorSlot == EntityEquipmentSlot.HEAD)   return new RenderArmorMask(maskType.getMeta());
 else   return null;
}","@Override @SideOnly(Side.CLIENT) public ModelBiped getArmorModel(EntityLivingBase entityLiving,ItemStack itemStack,EntityEquipmentSlot armorSlot,ModelBiped _default){
  if (armorSlot == EntityEquipmentSlot.HEAD)   return new RenderArmorMask(maskType.getMeta());
 else   return null;
}",0.9577981651376148
109789,"public RenderAshen(ModelBase modelbase,float f){
  super(Minecraft.getMinecraft().getRenderManager(),modelbase,f);
  modelAshen=(ModelAshen)modelbase;
  this.addLayer(new LayerMaskAshen(modelAshen));
  this.addLayer(new LayerHeldItemAshen(this,modelAshen));
}","public RenderAshen(ModelBase modelbase,float f){
  super(Minecraft.getMinecraft().getRenderManager(),modelbase,f);
  modelAshen=(ModelAshen)modelbase;
  this.addLayer(new LayerMaskAshen(modelAshen));
  this.addLayer(new LayerHeldItemAshen(this,modelAshen));
  this.shadowOpaque=0.5f;
  this.shadowSize=0.3f;
}",0.9119718309859156
109790,"public void renderLostMask(EntityLostMask entity,double d,double d1,double d2,float f,float f1){
  this.bindEntityTexture(entity);
  GL11.glPushMatrix();
  GL11.glTranslatef((float)d,(float)d1,(float)d2);
  GL11.glRotatef(f,0.0F,1.0F,0.0F);
  if (!entity.onGround && !entity.checkForWater(0) && !entity.checkForWater(-1)) {
    int[] a=entity.getRotator();
    GL11.glRotatef(a[0] + f1,1.0F,0.0F,0.0F);
    GL11.glRotatef(a[1] + f1,0.0F,1.0F,0.0F);
    GL11.glRotatef(a[2] + f1,0.0F,0.0F,1.0F);
  }
 else {
    GL11.glRotatef(270,1,0,0);
    GL11.glRotatef(180,0,0,1);
  }
  mask.renderMask(entity.getColor());
  GL11.glPopMatrix();
}","public void renderLostMask(EntityLostMask entity,double d,double d1,double d2,float f,float f1){
  GlStateManager.pushMatrix();
  this.bindEntityTexture(entity);
  GlStateManager.translate(d,d1,d2);
  GlStateManager.rotate(f,0.0F,1.0F,0.0F);
  if (!entity.onGround && !entity.checkForWater(0) && !entity.checkForWater(-1)) {
    int[] a=entity.getRotator();
    GlStateManager.rotate(a[0] + f1,1.0F,0.0F,0.0F);
    GlStateManager.rotate(a[1] + f1,0.0F,1.0F,0.0F);
    GlStateManager.rotate(a[2] + f1,0.0F,0.0F,1.0F);
  }
 else {
    GlStateManager.rotate(270,1,0,0);
    GlStateManager.rotate(180,0,0,1);
  }
  mask.renderMask(entity.getType());
  GlStateManager.popMatrix();
}",0.7139588100686499
109791,"public RenderLostMask(){
  super(Minecraft.getMinecraft().getRenderManager());
  shadowSize=0.5F;
  mask=new TropicraftSpecialRenderHelper();
}","public RenderLostMask(){
  super(Minecraft.getMinecraft().getRenderManager());
  shadowSize=0.5F;
  this.shadowOpaque=0.5f;
  mask=new TropicraftSpecialRenderHelper();
}",0.9166666666666666
109792,"@Override public boolean shouldExecute(){
  return !ashen.hasMask();
}","@Override public boolean shouldExecute(){
  return !ashen.hasMask() && ashen.maskToTrack != null;
}",0.8284023668639053
109793,"/** 
 * Spawns a LostMask into the world at a given position and angle
 * @param world World object
 * @param color Mask type
 * @param x X position
 * @param y Y position
 * @param z Z position
 * @param angle Use the ""attackers"" rotationYaw
 */
public EntityLostMask(World world,int type,double x,double y,double z,double angle){
  this(world);
  this.setPosition(x,y,z);
  this.setType(type);
  motionX=Math.cos(Math.toRadians(angle + 90)) * launchedSpeed;
  motionZ=Math.sin(Math.toRadians(angle + 90)) * launchedSpeed;
  double subAngle=MathHelper.wrapDegrees(angle);
  double subAngle2=subAngle + (180 - subAngle) * 2;
  this.rotationYaw=(float)(subAngle2);
}","/** 
 * Spawns a LostMask into the world at a given position and angle
 * @param world World object
 * @param color Mask type
 * @param x X position
 * @param y Y position
 * @param z Z position
 * @param angle Use the ""attackers"" rotationYaw
 */
public EntityLostMask(World world,int type,double x,double y,double z,double angle){
  this(world);
  this.setPosition(x,y,z);
  motionX=Math.cos(Math.toRadians(angle + 90)) * launchedSpeed;
  motionZ=Math.sin(Math.toRadians(angle + 90)) * launchedSpeed;
  double subAngle=MathHelper.wrapDegrees(angle);
  double subAngle2=subAngle + (180 - subAngle) * 2;
  this.rotationYaw=(float)(subAngle2);
  this.type=type;
}",0.9698340874811464
109794,"@Override protected void writeEntityToNBT(NBTTagCompound nbt){
  nbt.setInteger(""String_Node_Str"",this.getColor());
}","@Override protected void writeEntityToNBT(NBTTagCompound nbt){
  nbt.setInteger(""String_Node_Str"",this.getType());
}",0.96137339055794
109795,"public int getType(){
  return this.getColor();
}","public int getType(){
  return this.dataManager.get(MASK_TYPE).intValue();
}",0.72
109796,"@Override public void onUpdate(){
  if (onGround) {
    this.motionX*=.5F;
    this.motionZ*=.5F;
    this.motionY=0;
  }
  if (this.checkForWater(0)) {
    this.motionY=.02F;
    this.motionX*=.95F;
    this.motionZ*=.95F;
  }
 else {
    int xMod=world.rand.nextInt(10);
    int yMod=world.rand.nextInt(30);
    int zMod=world.rand.nextInt(10);
    int[] a=this.getRotator();
    a[0]+=xMod;
    a[1]+=yMod;
    a[2]+=zMod;
    this.setRotator(a);
    motionY-=.05f;
  }
  this.move(motionX,motionY,motionZ);
}","@Override public void onUpdate(){
  if (!world.isRemote) {
    if (this.ticksExisted == 1 && type >= 0) {
      this.setType(type);
    }
  }
  if (onGround) {
    this.motionX*=.5F;
    this.motionZ*=.5F;
    this.motionY=0;
  }
  if (this.checkForWater(0)) {
    this.motionY=.02F;
    this.motionX*=.95F;
    this.motionZ*=.95F;
  }
 else {
    int xMod=world.rand.nextInt(10);
    int yMod=world.rand.nextInt(30);
    int zMod=world.rand.nextInt(10);
    int[] a=this.getRotator();
    a[0]+=xMod;
    a[1]+=yMod;
    a[2]+=zMod;
    this.setRotator(a);
    motionY-=.05f;
  }
  this.move(motionX,motionY,motionZ);
}",0.9045936395759716
109797,"public void setPlayerSize(EntityPlayer p,float x,float y,float offset,float height){
  AxisAlignedBB axisalignedbb=p.getEntityBoundingBox();
  p.setEntityBoundingBox(new AxisAlignedBB(axisalignedbb.minX,axisalignedbb.minY,axisalignedbb.minZ,axisalignedbb.minX + (double)x,axisalignedbb.minY + (double)y,axisalignedbb.minZ + (double)x));
  p.posY-=offset;
  p.height=height;
}","public void setPlayerSize(EntityPlayer p,float x,float y,float offset,float height){
  AxisAlignedBB axisalignedbb=p.getEntityBoundingBox();
  p.setEntityBoundingBox(new AxisAlignedBB(axisalignedbb.minX,axisalignedbb.minY,axisalignedbb.minZ,axisalignedbb.minX + (double)x,axisalignedbb.minY + (double)y,axisalignedbb.minZ + (double)x));
  if (Tropicraft.proxy.helloIsItMeYoureLookingFor(p)) {
    p.posY-=offset;
  }
  p.height=height;
}",0.9236453201970444
109798,"public BlockTropicraftSlab(Material material,boolean isDoubleSlab){
  super(material);
  this.isDoubleSlab=isDoubleSlab;
  IBlockState iblockstate=this.blockState.getBaseState();
  if (!this.isDouble()) {
    iblockstate=iblockstate.withProperty(HALF,BlockSlab.EnumBlockHalf.BOTTOM);
  }
  this.setDefaultState(iblockstate.withProperty(VARIANT,TropicraftSlabs.BAMBOO));
}","public BlockTropicraftSlab(Material material,boolean isDoubleSlab){
  super(material);
  this.isDoubleSlab=isDoubleSlab;
  IBlockState iblockstate=this.blockState.getBaseState();
  if (!this.isDouble()) {
    iblockstate=iblockstate.withProperty(HALF,BlockSlab.EnumBlockHalf.BOTTOM);
  }
  this.setDefaultState(iblockstate.withProperty(VARIANT,TropicraftSlabs.BAMBOO));
  this.useNeighborBrightness=true;
}",0.954954954954955
109799,"public BlockTropicraftStairs(IBlockState modelState){
  super(modelState);
  this.setDefaultState(getDefaultState().withProperty(FACING,EnumFacing.EAST));
}","public BlockTropicraftStairs(IBlockState modelState){
  super(modelState);
  this.setDefaultState(getDefaultState().withProperty(FACING,EnumFacing.EAST));
  this.useNeighborBrightness=true;
}",0.899135446685879
109800,"/** 
 * Items that should be recognized by the encyclopedia are added here. The names given MUST match the page names in the encyclopedia text file, and duplicates here are ok - multiple items can be associated with 1 page. Ordering doesn't matter, as the page order is determined by the text file Note: Items with metadata values must be added individually (use a loop if possible)
 */
public static void addItemsToEncyclopedia(){
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,9));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,4));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,5));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,6));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.azurite));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooShoot));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooMug));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bundles,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bambooChest));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooDoor));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bambooFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bambooFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooSpear));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooStick));
  for (int i=0; i < 5; i++) {
    Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.chair,1,i));
    Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.umbrella,1,i));
  }
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.blackCoffee));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,1,3));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,14));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.caipirinha));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,3));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.chunk));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.chunkFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.chunkFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.coconut));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.coconutChunk));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.coconutBomb));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.coffeeBeans,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,0));
  for (int i=0; i < TropicraftCorals.VALUES.length; i++) {
    Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.coral,1,i));
  }
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,10));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.dagger));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,11));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordEasternIsles));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.encyclopedia));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.eudialyte));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,12));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fertilizer));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fireBoots));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fireChestplate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fireHelmet));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fireLeggings));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fishBucket));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fishingNet));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.flowerPot));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.frogLeg));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.cookedFrogLeg));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.poisonFrogSkin));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.FROX.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.grapefruit));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,1,2));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scale));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.iris));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.leaves,1,2));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.lemon));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.lemonade));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,2));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.lime));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.limeade));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,4));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordLowTide));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,7));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.logs,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.mahoganyFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.mahoganyFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.freshMarlin));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.searedMarlin));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,1,4));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.drinkMixer));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.orange));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.orangeade));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,3));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,2));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.PAB.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.planks,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.logs,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.palmFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.palmFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,8));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.blackPearl));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.whitePearl));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.pineapple,1,8));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.pineappleCubes));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.pinaColada));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.portalEnchanter));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,0,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(Items.REEDS));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.RUBE.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scaleBoots));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scaleChestplate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scaleHelmet));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scaleLeggings));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.seaUrchinRoe));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sifter));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.SOLO.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.STARFISH.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordSummering));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.tikiTorch));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bundles,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.thatchFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.thatchFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordTheTribe));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordTradeWinds));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooItemFrame));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.TURTLE.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.zircon));
}","/** 
 * Items that should be recognized by the encyclopedia are added here. The names given MUST match the page names in the encyclopedia text file, and duplicates here are ok - multiple items can be associated with 1 page. Ordering doesn't matter, as the page order is determined by the text file Note: Items with metadata values must be added individually (use a loop if possible)
 */
public static void addItemsToEncyclopedia(){
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,9));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,4));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,5));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,6));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.azurite));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooShoot));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooMug));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bundles,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bambooChest));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooDoor));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bambooFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bambooFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooSpear));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooStick));
  for (int i=0; i < 5; i++) {
    Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.chair,1,i));
    Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.umbrella,1,i));
  }
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.blackCoffee));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,1,3));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,14));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.caipirinha));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,3));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.chunk));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.chunkFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.chunkFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.coconut));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.coconutChunk));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.coconutBomb));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.coffeeBeans,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,0));
  for (int i=0; i < TropicraftCorals.VALUES.length; i++) {
    Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.coral,1,i));
  }
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,10));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.dagger));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,11));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordEasternIsles));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.encyclopedia));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.eudialyte));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,12));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fertilizer));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fireBoots));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fireChestplate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fireHelmet));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fireLeggings));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fishBucket));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.fishingNet));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.flowerPot));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.frogLeg));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.cookedFrogLeg));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.poisonFrogSkin));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.FROX.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.grapefruit));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,1,2));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scale));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.iris));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.leaves,1,2));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.lemon));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.lemonade));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,2));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.lime));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.limeade));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,4));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordLowTide));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,7));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.logs,1,1));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.mahoganyFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.mahoganyFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.freshMarlin));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.searedMarlin));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,1,4));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.drinkMixer));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.orange));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.orangeade));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,3));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,2));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.PAB.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.planks,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.logs,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.saplings,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.palmFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.palmFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.flowers,1,8));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.blackPearl));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.whitePearl));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.pineapple,1,8));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.pineappleCubes));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",MixerRecipes.getItemStack(Drink.pinaColada));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.portalEnchanter));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sands,0,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(Items.REEDS));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.RUBE.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scaleBoots));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scaleChestplate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scaleHelmet));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.scaleLeggings));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.seaUrchinRoe));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.sifter));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.SOLO.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.STARFISH.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordSummering));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.tikiTorch));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.bundles,1,0));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.thatchFence));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(BlockRegistry.thatchFenceGate));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordTheTribe));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.recordTradeWinds));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.trimix));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.bambooItemFrame));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.shell,1,TropicraftShells.TURTLE.getMeta()));
  Tropicraft.encyclopedia.includeItem(""String_Node_Str"",new ItemStack(ItemRegistry.zircon));
}",0.9959808116167508
109801,"public static void preInit(){
  blockItemRegistry.entrySet().forEach(e -> {
    Item item=GameRegistry.register(e.getValue().getItem(e.getKey()).setRegistryName(e.getKey().getRegistryName()));
    e.getValue().postRegister(e.getKey(),item);
  }
);
  diveComputer=registerItem(new ItemDiveComputer(),""String_Node_Str"");
  pinkWeightBelt=registerItem(new ItemTropicraft(),""String_Node_Str"");
  pinkPonyBottle=registerItem(new ItemPonyBottle(),""String_Node_Str"");
  pinkBCD=registerItem(new ItemBCD(),""String_Node_Str"");
  pinkRegulator=registerItem(new ItemTropicraft(),""String_Node_Str"");
  pinkScubaTank=registerItem(new ItemScubaTank(),""String_Node_Str"");
  pinkFlippers=registerItem(new ItemScubaFlippers(materialPinkSuit,ScubaMaterial.PINK,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  pinkChestplateGear=registerItem(new ItemScubaChestplateGear(materialPinkSuit,ScubaMaterial.PINK,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  pinkScubaGoggles=registerItem(new ItemScubaHelmet(materialPinkSuit,ScubaMaterial.PINK,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  yellowWeightBelt=registerItem(new ItemTropicraft(),""String_Node_Str"");
  yellowPonyBottle=registerItem(new ItemPonyBottle(),""String_Node_Str"");
  yellowBCD=registerItem(new ItemBCD(),""String_Node_Str"");
  yellowRegulator=registerItem(new ItemTropicraft(),""String_Node_Str"");
  yellowScubaTank=registerItem(new ItemScubaTank(),""String_Node_Str"");
  yellowFlippers=registerItem(new ItemScubaFlippers(materialYellowSuit,ScubaMaterial.YELLOW,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  yellowChestplateGear=registerItem(new ItemScubaChestplateGear(materialYellowSuit,ScubaMaterial.YELLOW,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  yellowScubaGoggles=registerItem(new ItemScubaHelmet(materialYellowSuit,ScubaMaterial.YELLOW,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  recordBuriedTreasure=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordEasternIsles=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordSummering=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTheTribe=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordLowTide=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTradeWinds=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  azurite=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  eudialyte=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  zircon=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  grapefruit=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lemon=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lime=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  orange=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  hoeEudialyte=registerItem(new ItemHoe(materialEudialyteTools),""String_Node_Str"");
  hoeZircon=registerItem(new ItemHoe(materialZirconTools),""String_Node_Str"");
  pickaxeEudialyte=registerItem(new ItemTropicraftPickaxe(materialEudialyteTools),""String_Node_Str"");
  pickaxeZircon=registerItem(new ItemTropicraftPickaxe(materialZirconTools),""String_Node_Str"");
  shovelEudialyte=registerItem(new ItemSpade(materialEudialyteTools),""String_Node_Str"");
  shovelZircon=registerItem(new ItemSpade(materialZirconTools),""String_Node_Str"");
  axeEudialyte=registerItem(new ItemTropicraftAxe(materialEudialyteTools,6.0F,-3.1F),""String_Node_Str"");
  axeZircon=registerItem(new ItemTropicraftAxe(materialZirconTools,6.0F,-3.2F),""String_Node_Str"");
  swordEudialyte=registerItem(new ItemSword(materialEudialyteTools),""String_Node_Str"");
  swordZircon=registerItem(new ItemSword(materialZirconTools),""String_Node_Str"");
  fishingNet=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooShoot=registerItem(new ItemBlockSpecial(BlockRegistry.bambooShoot),""String_Node_Str"");
  bambooStick=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooMug=registerItem(new ItemTropicraft().setMaxStackSize(16),""String_Node_Str"");
  freshMarlin=registerItem(new ItemTropicraftFood(2,0.3F),""String_Node_Str"");
  searedMarlin=registerItem(new ItemTropicraftFood(8,0.65F),""String_Node_Str"");
  tropicsWaterBucket=registerItem((new ItemBucket(BlockRegistry.tropicsWater)).setContainerItem(Items.BUCKET),""String_Node_Str"");
  fishBucket=registerItem(new ItemFishBucket(),""String_Node_Str"");
  coconutChunk=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  pineappleCubes=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  coffeeBeans=registerMultiItem(new ItemCoffeeBean(Names.COFFEE_NAMES,BlockRegistry.coffeePlant),""String_Node_Str"",Names.COFFEE_NAMES);
  frogLeg=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  cookedFrogLeg=registerItem(new ItemTropicraftFood(2,0.15F),""String_Node_Str"");
  poisonFrogSkin=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scale=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scaleBoots=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  scaleLeggings=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  scaleChestplate=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  scaleHelmet=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  fireBoots=registerItem(new ItemFireArmor(materialFireArmor,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  fireLeggings=registerItem(new ItemFireArmor(materialFireArmor,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  fireChestplate=registerItem(new ItemFireArmor(materialFireArmor,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  fireHelmet=registerItem(new ItemFireArmor(materialFireArmor,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  chair=registerMultiItem(new ItemChair(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  umbrella=registerMultiItem(new ItemUmbrella(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  portalEnchanter=registerItem(new ItemPortalEnchanter(),""String_Node_Str"");
  shell=registerMultiItem(new ItemShell(),""String_Node_Str"",TropicraftShells.values());
  cocktail=registerMultiItem(new ItemCocktail(),""String_Node_Str"",Drink.drinkList.length);
  whitePearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  blackPearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  fertilizer=registerItem(new ItemFertilizer(),""String_Node_Str"");
  encyclopedia=registerItem(new ItemEncyclopediaTropica(""String_Node_Str""),""String_Node_Str"");
  dagger=registerItem(new ItemDagger(materialZirconTools),""String_Node_Str"");
  bambooSpear=registerItem(new ItemSword(materialBambooTools),""String_Node_Str"");
  coconutBomb=registerItem(new ItemCoconutBomb(),""String_Node_Str"");
  flowerPot=registerItem(new ItemTropicraftBlockSpecial(BlockRegistry.flowerPot),""String_Node_Str"");
  bambooDoor=registerItem(new ItemDoor(BlockRegistry.bambooDoor),""String_Node_Str"");
  bambooItemFrame=registerItem(new ItemBambooItemFrame(EntityBambooItemFrame.class),""String_Node_Str"");
  Tropicraft.proxy.registerArbitraryBlockVariants(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  waterWand=registerItem(new ItemWaterWand(),""String_Node_Str"");
  seaUrchinRoe=registerItem(new ItemTropicraftFood(3,0.3F),""String_Node_Str"");
  mobEgg=registerMultiItemPrefixed(new ItemMobEgg(),""String_Node_Str"",Names.EGG_NAMES);
  iguanaLeather=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  OreDictionary.registerOre(""String_Node_Str"",iguanaLeather);
}","public static void preInit(){
  blockItemRegistry.entrySet().forEach(e -> {
    Item item=GameRegistry.register(e.getValue().getItem(e.getKey()).setRegistryName(e.getKey().getRegistryName()));
    e.getValue().postRegister(e.getKey(),item);
  }
);
  diveComputer=registerItem(new ItemDiveComputer(),""String_Node_Str"");
  pinkWeightBelt=registerItem(new ItemTropicraft(),""String_Node_Str"");
  pinkPonyBottle=registerItem(new ItemPonyBottle(),""String_Node_Str"");
  pinkBCD=registerItem(new ItemBCD(),""String_Node_Str"");
  pinkRegulator=registerItem(new ItemTropicraft(),""String_Node_Str"");
  pinkScubaTank=registerItem(new ItemScubaTank(),""String_Node_Str"");
  pinkFlippers=registerItem(new ItemScubaFlippers(materialPinkSuit,ScubaMaterial.PINK,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  pinkChestplateGear=registerItem(new ItemScubaChestplateGear(materialPinkSuit,ScubaMaterial.PINK,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  pinkScubaGoggles=registerItem(new ItemScubaHelmet(materialPinkSuit,ScubaMaterial.PINK,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  yellowWeightBelt=registerItem(new ItemTropicraft(),""String_Node_Str"");
  yellowPonyBottle=registerItem(new ItemPonyBottle(),""String_Node_Str"");
  yellowBCD=registerItem(new ItemBCD(),""String_Node_Str"");
  yellowRegulator=registerItem(new ItemTropicraft(),""String_Node_Str"");
  yellowScubaTank=registerItem(new ItemScubaTank(),""String_Node_Str"");
  yellowFlippers=registerItem(new ItemScubaFlippers(materialYellowSuit,ScubaMaterial.YELLOW,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  yellowChestplateGear=registerItem(new ItemScubaChestplateGear(materialYellowSuit,ScubaMaterial.YELLOW,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  yellowScubaGoggles=registerItem(new ItemScubaHelmet(materialYellowSuit,ScubaMaterial.YELLOW,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  recordBuriedTreasure=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordEasternIsles=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordSummering=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTheTribe=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordLowTide=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTradeWinds=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  azurite=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  eudialyte=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  zircon=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  grapefruit=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lemon=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lime=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  orange=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  hoeEudialyte=registerItem(new ItemHoe(materialEudialyteTools),""String_Node_Str"");
  hoeZircon=registerItem(new ItemHoe(materialZirconTools),""String_Node_Str"");
  pickaxeEudialyte=registerItem(new ItemTropicraftPickaxe(materialEudialyteTools),""String_Node_Str"");
  pickaxeZircon=registerItem(new ItemTropicraftPickaxe(materialZirconTools),""String_Node_Str"");
  shovelEudialyte=registerItem(new ItemSpade(materialEudialyteTools),""String_Node_Str"");
  shovelZircon=registerItem(new ItemSpade(materialZirconTools),""String_Node_Str"");
  axeEudialyte=registerItem(new ItemTropicraftAxe(materialEudialyteTools,6.0F,-3.1F),""String_Node_Str"");
  axeZircon=registerItem(new ItemTropicraftAxe(materialZirconTools,6.0F,-3.2F),""String_Node_Str"");
  swordEudialyte=registerItem(new ItemSword(materialEudialyteTools),""String_Node_Str"");
  swordZircon=registerItem(new ItemSword(materialZirconTools),""String_Node_Str"");
  fishingNet=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooShoot=registerItem(new ItemBlockSpecial(BlockRegistry.bambooShoot),""String_Node_Str"");
  bambooStick=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooMug=registerItem(new ItemTropicraft().setMaxStackSize(16),""String_Node_Str"");
  freshMarlin=registerItem(new ItemTropicraftFood(2,0.3F),""String_Node_Str"");
  searedMarlin=registerItem(new ItemTropicraftFood(8,0.65F),""String_Node_Str"");
  tropicsWaterBucket=registerItem((new ItemBucket(BlockRegistry.tropicsWater)).setContainerItem(Items.BUCKET),""String_Node_Str"");
  fishBucket=registerItem(new ItemFishBucket(),""String_Node_Str"");
  coconutChunk=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  pineappleCubes=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  coffeeBeans=registerMultiItem(new ItemCoffeeBean(Names.COFFEE_NAMES,BlockRegistry.coffeePlant),""String_Node_Str"",Names.COFFEE_NAMES);
  frogLeg=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  cookedFrogLeg=registerItem(new ItemTropicraftFood(2,0.15F),""String_Node_Str"");
  poisonFrogSkin=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scale=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scaleBoots=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  scaleLeggings=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  scaleChestplate=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  scaleHelmet=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  fireBoots=registerItem(new ItemFireArmor(materialFireArmor,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  fireLeggings=registerItem(new ItemFireArmor(materialFireArmor,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  fireChestplate=registerItem(new ItemFireArmor(materialFireArmor,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  fireHelmet=registerItem(new ItemFireArmor(materialFireArmor,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  chair=registerMultiItem(new ItemChair(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  umbrella=registerMultiItem(new ItemUmbrella(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  portalEnchanter=registerItem(new ItemPortalEnchanter(),""String_Node_Str"");
  shell=registerMultiItem(new ItemShell(),""String_Node_Str"",TropicraftShells.values());
  cocktail=registerMultiItem(new ItemCocktail(),""String_Node_Str"",Drink.drinkList.length);
  whitePearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  blackPearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  fertilizer=registerItem(new ItemFertilizer(),""String_Node_Str"");
  encyclopedia=registerItem(new ItemEncyclopediaTropica(""String_Node_Str""),""String_Node_Str"");
  dagger=registerItem(new ItemDagger(materialZirconTools),""String_Node_Str"");
  bambooSpear=registerItem(new ItemSword(materialBambooTools),""String_Node_Str"");
  coconutBomb=registerItem(new ItemCoconutBomb(),""String_Node_Str"");
  flowerPot=registerItem(new ItemTropicraftBlockSpecial(BlockRegistry.flowerPot),""String_Node_Str"");
  bambooDoor=registerItem(new ItemDoor(BlockRegistry.bambooDoor),""String_Node_Str"");
  bambooItemFrame=registerItem(new ItemBambooItemFrame(EntityBambooItemFrame.class),""String_Node_Str"");
  Tropicraft.proxy.registerArbitraryBlockVariants(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  waterWand=registerItem(new ItemWaterWand(),""String_Node_Str"");
  seaUrchinRoe=registerItem(new ItemTropicraftFood(3,0.3F),""String_Node_Str"");
  mobEgg=registerMultiItemPrefixed(new ItemMobEgg(),""String_Node_Str"",Names.EGG_NAMES);
  iguanaLeather=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  OreDictionary.registerOre(""String_Node_Str"",iguanaLeather);
  trimix=registerItem(new ItemTropicraft().setMaxStackSize(1),""String_Node_Str"");
}",0.9949674726893336
109802,"public BiomeGenTropicraft(BiomeProperties bgprop){
  super(bgprop);
  this.spawnableCreatureList.clear();
  this.spawnableMonsterList.clear();
  this.spawnableCaveCreatureList.clear();
  this.spawnableWaterCreatureList.clear();
  this.theBiomeDecorator=new BiomeDecoratorTropicraft();
  this.spawnableCreatureList.add(new SpawnListEntry(EntityVMonkey.class,20,1,3));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityIguana.class,20,1,1));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityTropiCreeper.class,4,1,2));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityEIH.class,10,1,1));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityTropiSkeleton.class,4,1,8));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityAshenHunter.class,4,3,12));
}","public BiomeGenTropicraft(BiomeProperties bgprop){
  super(bgprop);
  this.spawnableCreatureList.clear();
  this.spawnableMonsterList.clear();
  this.spawnableCaveCreatureList.clear();
  this.spawnableWaterCreatureList.clear();
  this.theBiomeDecorator=new BiomeDecoratorTropicraft();
  this.spawnableCreatureList.add(new SpawnListEntry(EntityVMonkey.class,20,1,3));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityIguana.class,20,1,1));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityTropiCreeper.class,4,1,2));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityEIH.class,10,1,1));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityTropiSkeleton.class,6,2,8));
  this.spawnableCreatureList.add(new SpawnListEntry(EntityAshenHunter.class,4,3,10));
}",0.8880407124681934
109803,"public EntityLand(World world){
  super(world);
  setSize(.7F,1.95F);
}","public EntityLand(World world){
  super(world);
  setSize(.7F,1.95F);
  this.enablePersistence();
}",0.8352941176470589
109804,"public EntityLandTameable(World world){
  super(world);
  setSize(.7F,1.95F);
}","public EntityLandTameable(World world){
  super(world);
  setSize(.7F,1.95F);
  this.enablePersistence();
}",0.8494623655913979
109805,"/** 
 * Updates the task
 */
public void updateTask(){
  double d0=this.entityHost.getDistanceSq(this.attackTarget.posX,this.attackTarget.getEntityBoundingBox().minY,this.attackTarget.posZ);
  boolean flag=this.entityHost.getEntitySenses().canSee(this.attackTarget);
  if (flag) {
    ++this.field_75318_f;
  }
 else {
    this.field_75318_f=0;
  }
  if (d0 <= (double)this.shootCutoffRangeSqr && this.field_75318_f >= 20) {
  }
 else {
  }
  if (this.field_75318_f >= 20) {
    this.entityHost.getNavigator().tryMoveToEntityLiving(this.attackTarget,this.entityMoveSpeed);
  }
  this.entityHost.getLookHelper().setLookPositionWithEntity(this.attackTarget,30.0F,30.0F);
  float f;
  if (--this.rangedAttackTime == 0) {
    f=MathHelper.sqrt(d0) / this.shootCutoffRange;
    float f1=f;
    if (f < 0.1F) {
      f1=0.1F;
    }
    if (f1 > 1.0F) {
      f1=1.0F;
    }
    if (d0 >= (double)this.shootCutoffRange) {
      this.rangedAttackEntityHost.attackEntityWithRangedAttack(this.attackTarget,f1);
      this.rangedAttackTime=MathHelper.floor(f * (float)(this.maxRangedAttackTime - this.field_96561_g) + (float)this.field_96561_g);
    }
 else {
      if (d0 <= meleeHitRange) {
        this.entityHost.attackEntityAsMob(attackTarget);
        this.entityHost.swingArm(EnumHand.MAIN_HAND);
        rangedAttackTime=20;
      }
    }
  }
 else   if (this.rangedAttackTime < 0) {
    f=MathHelper.sqrt(d0) / this.shootCutoffRange;
    this.rangedAttackTime=MathHelper.floor(f * (float)(this.maxRangedAttackTime - this.field_96561_g) + (float)this.field_96561_g);
  }
}","/** 
 * Updates the task
 */
public void updateTask(){
  double d0=this.entityHost.getDistanceSq(this.attackTarget.posX,this.attackTarget.getEntityBoundingBox().minY,this.attackTarget.posZ);
  boolean flag=this.entityHost.getEntitySenses().canSee(this.attackTarget);
  if (flag) {
    ++this.field_75318_f;
  }
 else {
    this.field_75318_f=0;
  }
  if (d0 <= (double)this.shootCutoffRangeSqr && this.field_75318_f >= 20) {
  }
 else {
  }
  if (this.field_75318_f >= 20) {
    this.entityHost.getNavigator().tryMoveToEntityLiving(this.attackTarget,this.entityMoveSpeed);
  }
  this.entityHost.getLookHelper().setLookPositionWithEntity(this.attackTarget,30.0F,30.0F);
  float f;
  if (--this.rangedAttackTime <= 0) {
    f=MathHelper.sqrt(d0) / this.shootCutoffRange;
    float f1=f;
    if (f < 0.1F) {
      f1=0.1F;
    }
    if (f1 > 1.0F) {
      f1=1.0F;
    }
    if (d0 >= (double)this.shootCutoffRange * (double)this.shootCutoffRange) {
      this.rangedAttackEntityHost.attackEntityWithRangedAttack(this.attackTarget,f1);
      this.rangedAttackTime=maxRangedAttackTime;
    }
 else     if (d0 <= meleeHitRange * meleeHitRange) {
      this.entityHost.attackEntityAsMob(attackTarget);
      this.entityHost.swingArm(EnumHand.MAIN_HAND);
      rangedAttackTime=maxMeleeAttackTime;
    }
  }
}",0.8310693138279345
109806,"public EntityAIMeleeAndRangedAttack(IRangedAttackMob p_i1650_1_,double p_i1650_2_,int p_i1650_4_,int p_i1650_5_,float p_i1650_6_,float meleeHitRange){
  this.rangedAttackTime=-1;
  if (!(p_i1650_1_ instanceof EntityLivingBase)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    this.rangedAttackEntityHost=p_i1650_1_;
    this.entityHost=(EntityLiving)p_i1650_1_;
    this.entityMoveSpeed=p_i1650_2_;
    this.field_96561_g=p_i1650_4_;
    this.maxRangedAttackTime=p_i1650_5_;
    this.shootCutoffRange=p_i1650_6_;
    this.shootCutoffRangeSqr=p_i1650_6_ * p_i1650_6_;
    this.meleeHitRange=meleeHitRange;
    this.setMutexBits(3);
  }
}","public EntityAIMeleeAndRangedAttack(IRangedAttackMob p_i1650_1_,double p_i1650_2_,int maxMeleeAttackTime,int maxRangedAttackTime,float p_i1650_6_,float meleeHitRange){
  this.rangedAttackTime=-1;
  if (!(p_i1650_1_ instanceof EntityLivingBase)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    this.rangedAttackEntityHost=p_i1650_1_;
    this.entityHost=(EntityLiving)p_i1650_1_;
    this.entityMoveSpeed=p_i1650_2_;
    this.maxMeleeAttackTime=maxMeleeAttackTime;
    this.maxRangedAttackTime=maxRangedAttackTime;
    this.shootCutoffRange=p_i1650_6_;
    this.shootCutoffRangeSqr=p_i1650_6_ * p_i1650_6_;
    this.meleeHitRange=meleeHitRange;
    this.setMutexBits(3);
  }
}",0.8677867056245434
109807,"@Override protected void applyEntityAttributes(){
  super.applyEntityAttributes();
  this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(20.0D);
  this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.4D);
  this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(getAttackStrength());
}","@Override protected void applyEntityAttributes(){
  super.applyEntityAttributes();
  this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(20.0D);
  this.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.24D);
  this.getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(getAttackStrength());
}",0.9985855728429984
109808,"public EntityAshen(World par1World){
  super(par1World);
  setSize(0.5F,1.3F);
  setMaskType(new Random().nextInt(7));
  actionPicker=0;
}","public EntityAshen(World par1World){
  super(par1World);
  setSize(0.5F,1.3F);
  setMaskType(new Random().nextInt(7));
  actionPicker=0;
  this.enablePersistence();
}",0.9078947368421052
109809,"public EntityAshenHunter(World par1World){
  super(par1World);
  swingProgress=0;
  setActionState(2);
  actionPicker=2;
  hasGTFO=false;
  this.setHeldItem(EnumHand.MAIN_HAND,new ItemStack(ItemRegistry.dagger));
  this.tasks.addTask(1,new EntityAISwimming(this));
  this.tasks.addTask(2,new AIAshenChaseAndPickupLostMask(this,1.0D));
  this.tasks.addTask(3,aiArrowAttack);
  this.tasks.addTask(4,new EntityAIMeleeAndRangedAttack(this,1.0D,60,5F));
  this.tasks.addTask(5,new EntityAIWander(this,1.0D));
  this.tasks.addTask(6,new EntityAIWatchClosest(this,EntityPlayer.class,8.0F));
  this.tasks.addTask(7,new EntityAILookIdle(this));
  this.targetTasks.addTask(1,new EntityAIHurtByTarget(this,false));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityPlayer.class,true));
  this.targetTasks.addTask(3,new EntityAINearestAttackableTarget(this,EntityKoaBase.class,true));
}","public EntityAshenHunter(World par1World){
  super(par1World);
  swingProgress=0;
  setActionState(2);
  actionPicker=2;
  hasGTFO=false;
  this.setHeldItem(EnumHand.MAIN_HAND,new ItemStack(ItemRegistry.dagger));
  this.tasks.addTask(1,new EntityAISwimming(this));
  this.tasks.addTask(2,new AIAshenChaseAndPickupLostMask(this,1.0D));
  this.tasks.addTask(3,aiArrowAttack);
  this.tasks.addTask(4,new EntityAIMeleeAndRangedAttack(this,1.0D,20 * 2,20 * 10,5F));
  this.tasks.addTask(5,new EntityAIWander(this,1.0D));
  this.tasks.addTask(6,new EntityAIWatchClosest(this,EntityPlayer.class,8.0F));
  this.tasks.addTask(7,new EntityAILookIdle(this));
  this.targetTasks.addTask(1,new EntityAIHurtByTarget(this,false));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityPlayer.class,true));
  this.targetTasks.addTask(3,new EntityAINearestAttackableTarget(this,EntityKoaBase.class,true));
}",0.9922737306843268
109810,"/** 
 * Checks to make sure the light is not too bright where the mob is spawning
 */
protected boolean isValidLightLevel(){
  BlockPos blockpos=new BlockPos(this.posX,this.getEntityBoundingBox().minY,this.posZ);
  if (this.world.getLightFor(EnumSkyBlock.SKY,blockpos) > this.rand.nextInt(32)) {
    return false;
  }
 else {
    int i=this.world.getLightFromNeighbors(blockpos);
    if (this.world.isThundering()) {
      int j=this.world.getSkylightSubtracted();
      this.world.setSkylightSubtracted(10);
      i=this.world.getLightFromNeighbors(blockpos);
      this.world.setSkylightSubtracted(j);
    }
    return i <= this.rand.nextInt(8);
  }
}","/** 
 * Checks to make sure the light is not too bright where the mob is spawning
 */
protected boolean isValidLightLevel(){
  boolean dayTimeSpawning=true;
  if (dayTimeSpawning) {
    return true;
  }
 else {
    BlockPos blockpos=new BlockPos(this.posX,this.getEntityBoundingBox().minY,this.posZ);
    if (this.world.getLightFor(EnumSkyBlock.SKY,blockpos) > this.rand.nextInt(32)) {
      return false;
    }
 else {
      int i=this.world.getLightFromNeighbors(blockpos);
      if (this.world.isThundering()) {
        int j=this.world.getSkylightSubtracted();
        this.world.setSkylightSubtracted(10);
        i=this.world.getLightFromNeighbors(blockpos);
        this.world.setSkylightSubtracted(j);
      }
      return i <= this.rand.nextInt(8);
    }
  }
}",0.918424753867792
109811,"public EntityFailgull(World world){
  super(world);
  setSize(0.4F,0.6F);
  this.experienceValue=1;
  this.moveHelper=new EntityFailgull.FailgullMoveHelper(this);
}","public EntityFailgull(World world){
  super(world);
  setSize(0.4F,0.6F);
  this.experienceValue=1;
  this.moveHelper=new EntityFailgull.FailgullMoveHelper(this);
  this.enablePersistence();
}",0.9213483146067416
109812,"public void genDecorations(Biome biome,World world,Random rand){
  int x=chunkPos.getX();
  int z=chunkPos.getZ();
  int i=0;
  int k=0;
  if (BiomeGenTropicraft.DISABLEDECORATION) {
    System.out.println(""String_Node_Str"" + this);
    return;
  }
  if (rand.nextInt(HOME_TREE_RARITY) == 0) {
    int cx=x;
    int cz=z;
    int xx=rand.nextInt(16) + cx + 8;
    int zz=rand.nextInt(16) + cz + 8;
    new WorldGenHomeTree(world,rand).generate(new BlockPos(xx,0,zz));
  }
  if (rand.nextInt(TALL_TREE_CHANCE) == 0) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenTallTree(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  if (rand.nextInt(UP_TREE_CHANCE) == 0) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenUpTree(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  for (int a=0; a < SMALL_TUALANG_AMOUNT; a++) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenTualang(world,rand,16,9).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  for (int a=0; a < LARGE_TUALANG_AMOUNT; a++) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenTualang(world,rand,25,11).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  for (int a=0; a < UNDERGROWTH_AMOUNT; a++) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenUndergrowth(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.TALL_GRASS_CHANCE != 0 && rand.nextInt(ConfigGenRates.TALL_GRASS_CHANCE) == 0) {
    for (int a=0; a < 10; a++) {
      int xRand=rand.nextInt(16) + 8;
      int zRand=rand.nextInt(16) + 8;
      int yRand=world.getHeight(this.chunkPos.add(xRand,0,zRand)).getY() * 2;
      if (yRand > 0) {
        int rando=rand.nextInt(yRand);
        biome.getRandomWorldGenForGrass(rand).generate(world,rand,this.chunkPos.add(xRand,rando,zRand));
      }
    }
  }
}","public void genDecorations(Biome biome,World world,Random rand){
  int x=chunkPos.getX();
  int z=chunkPos.getZ();
  int i=0;
  int k=0;
  if (BiomeGenTropicraft.DISABLEDECORATION) {
    System.out.println(""String_Node_Str"" + this);
    return;
  }
  if (rand.nextInt(HOME_TREE_RARITY) == 0) {
    int cx=x;
    int cz=z;
    int xx=rand.nextInt(16) + cx + 8;
    int zz=rand.nextInt(16) + cz + 8;
    new WorldGenHomeTree(world,rand).generate(new BlockPos(xx,0,zz));
  }
  if (rand.nextInt(TALL_TREE_CHANCE) == 0) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenTallTree(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  if (rand.nextInt(UP_TREE_CHANCE) == 0) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenUpTree(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  for (int a=0; a < SMALL_TUALANG_AMOUNT; a++) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenTualang(world,rand,16,9).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  for (int a=0; a < LARGE_TUALANG_AMOUNT; a++) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenTualang(world,rand,25,11).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  for (int a=0; a < UNDERGROWTH_AMOUNT; a++) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenUndergrowth(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.TALL_GRASS_CHANCE != 0 && rand.nextInt(ConfigGenRates.TALL_GRASS_CHANCE) == 0) {
    for (int a=0; a < 10; a++) {
      int xRand=rand.nextInt(16) + 8;
      int zRand=rand.nextInt(16) + 8;
      int yRand=world.getHeight(this.chunkPos.add(xRand,0,zRand)).getY() * 2;
      if (yRand > 0) {
        int rando=rand.nextInt(yRand);
        biome.getRandomWorldGenForGrass(rand).generate(world,rand,this.chunkPos.add(xRand,rando,zRand));
      }
    }
  }
  for (int a=0; a < COFFEE_PLANT_AMOUNT; a++) {
    i=randDecorationCoord(rand,x,16);
    k=randDecorationCoord(rand,z,16);
    new WorldGenCoffeePlant(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
}",0.9480192351728876
109813,"private void replaceBiomeBlocks(int x,int z,ChunkPrimer primer,Biome[] biomesIn){
  if (!net.minecraftforge.event.ForgeEventFactory.onReplaceBiomeBlocks(this,x,z,primer,this.worldObj))   return;
  double d0=0.03125D;
  this.depthBuffer=this.surfaceNoise.getRegion(this.depthBuffer,(double)(x * 16),(double)(z * 16),16,16,d0 * 2.0D,d0 * 2.0D,1.0D);
  int a=-1;
  boolean flag=false;
  int k=(int)63;
  double d=0.03125D;
  for (int xValue=0; xValue < 16; ++xValue) {
    for (int zValue=0; zValue < 16; ++zValue) {
      BiomeGenTropicraft biome=(BiomeGenTropicraft)biomesIn[xValue + zValue * 16];
      int yStart=-1;
      for (int yValue=128 - 1; yValue >= 0; yValue--) {
        int xx=xValue;
        int zz=zValue;
        Block block=primer.getBlockState(xx,yValue,zz).getBlock();
        if (yValue <= 0) {
          primer.setBlockState(xx,yValue,zz,Blocks.BEDROCK.getDefaultState());
          continue;
        }
        if (block == Blocks.AIR || block == BlockRegistry.tropicsWater) {
          a=0;
          continue;
        }
        if (a >= 0 && a < 5) {
          if (yStart == -1) {
            yStart=yValue;
          }
          IBlockState blockUsed=biome.getStateForLayer(yStart,a);
          primer.setBlockState(xx,yValue,zz,blockUsed);
          a++;
        }
 else {
          a=-1;
        }
      }
      a=-1;
    }
  }
}","private void replaceBiomeBlocks(int x,int z,ChunkPrimer primer,Biome[] biomesIn){
  if (!net.minecraftforge.event.ForgeEventFactory.onReplaceBiomeBlocks(this,x,z,primer,this.worldObj))   return;
  double d0=0.03125D;
  this.depthBuffer=this.surfaceNoise.getRegion(this.depthBuffer,(double)(x * 16),(double)(z * 16),16,16,d0 * 2.0D,d0 * 2.0D,1.0D);
  int a=-1;
  boolean flag=false;
  int k=(int)63;
  double d=0.03125D;
  for (int xValue=0; xValue < 16; ++xValue) {
    for (int zValue=0; zValue < 16; ++zValue) {
      Biome biomePreCast=biomesIn[xValue + zValue * 16];
      if (!(biomePreCast instanceof BiomeGenTropicraft))       continue;
      BiomeGenTropicraft biome=(BiomeGenTropicraft)biomePreCast;
      int yStart=-1;
      for (int yValue=128 - 1; yValue >= 0; yValue--) {
        int xx=xValue;
        int zz=zValue;
        Block block=primer.getBlockState(xx,yValue,zz).getBlock();
        if (yValue <= 0) {
          primer.setBlockState(xx,yValue,zz,Blocks.BEDROCK.getDefaultState());
          continue;
        }
        if (block == Blocks.AIR || block == BlockRegistry.tropicsWater) {
          a=0;
          continue;
        }
        if (a >= 0 && a < 5) {
          if (yStart == -1) {
            yStart=yValue;
          }
          IBlockState blockUsed=biome.getStateForLayer(yStart,a);
          primer.setBlockState(xx,yValue,zz,blockUsed);
          a++;
        }
 else {
          a=-1;
        }
      }
      a=-1;
    }
  }
}",0.9319148936170212
109814,"/** 
 * Places a block circle line
 * @param ai One end of the line
 * @param ai1 The other end of the line
 * @param outerRadius The radius of the circle's outside edge
 * @param innerRadius The radius of the circle's inner edge, 0 for a full circle
 * @param block The block to generate the block circle line with
 * @param meta The metadata to generate the block circle line with
 * @param allowedBlockList The block to exclude from the check
 * @return The coordinates where a circle was generated
 */
public ArrayList<int[]> placeBlockCircleLine(int ai[],int ai1[],double distance,double distance2,IBlockState state){
  ArrayList<int[]> places=new ArrayList<int[]>();
  int ai2[]={0,0,0};
  byte byte0=0;
  int j=0;
  for (; byte0 < 3; byte0++) {
    ai2[byte0]=ai1[byte0] - ai[byte0];
    if (Math.abs(ai2[byte0]) > Math.abs(ai2[j])) {
      j=byte0;
    }
  }
  if (ai2[j] == 0) {
    return null;
  }
  byte byte1=otherCoordPairs[j];
  byte byte2=otherCoordPairs[j + 3];
  byte byte3;
  if (ai2[j] > 0) {
    byte3=1;
  }
 else {
    byte3=-1;
  }
  double d=(double)ai2[byte1] / (double)ai2[j];
  double d1=(double)ai2[byte2] / (double)ai2[j];
  int ai3[]={0,0,0};
  int k=0;
  for (int l=ai2[j] + byte3; k != l; k+=byte3) {
    ai3[j]=MathHelper.floor((double)(ai[j] + k) + 0.5D);
    ai3[byte1]=MathHelper.floor((double)ai[byte1] + (double)k * d + 0.5D);
    ai3[byte2]=MathHelper.floor((double)ai[byte2] + (double)k * d1 + 0.5D);
    genCircle(getBlockPos(ai3),distance,distance2,state,true);
    places.add(new int[]{ai3[0],ai3[1],ai3[2]});
  }
  return places;
}","/** 
 * Places a block circle line
 * @param ai One end of the line
 * @param ai1 The other end of the line
 * @param outerRadius The radius of the circle's outside edge
 * @param innerRadius The radius of the circle's inner edge, 0 for a full circle
 * @param block The block to generate the block circle line with
 * @param meta The metadata to generate the block circle line with
 * @param allowedBlockList The block to exclude from the check
 * @return The coordinates where a circle was generated
 */
public ArrayList<int[]> placeBlockCircleLine(int ai[],int ai1[],double distance,double distance2,IBlockState state){
  ArrayList<int[]> places=new ArrayList<int[]>();
  int ai2[]={0,0,0};
  byte byte0=0;
  int j=0;
  for (; byte0 < 3; byte0++) {
    ai2[byte0]=ai1[byte0] - ai[byte0];
    if (Math.abs(ai2[byte0]) > Math.abs(ai2[j])) {
      j=byte0;
    }
  }
  if (ai2[j] == 0) {
    return null;
  }
  byte byte1=otherCoordPairs[j];
  byte byte2=otherCoordPairs[j + 3];
  byte byte3;
  if (ai2[j] > 0) {
    byte3=1;
  }
 else {
    byte3=-1;
  }
  double d=(double)ai2[byte1] / (double)ai2[j];
  double d1=(double)ai2[byte2] / (double)ai2[j];
  int ai3[]={0,0,0};
  int k=0;
  for (int l=ai2[j] + byte3; k != l; k+=byte3) {
    ai3[j]=MathHelper.floor((double)(ai[j] + k) + 0.5D);
    ai3[byte1]=MathHelper.floor((double)ai[byte1] + (double)k * d + 0.5D);
    ai3[byte2]=MathHelper.floor((double)ai[byte2] + (double)k * d1 + 0.5D);
    genCircle(TCGenUtils.getBlockPos(ai3),distance,distance2,state,true);
    places.add(new int[]{ai3[0],ai3[1],ai3[2]});
  }
  return places;
}",0.9965222889661712
109815,"/** 
 * Generates a sphere at the specified coordinates
 * @param x The x coordinate
 * @param y The y coordinate
 * @param z The z coordinate
 * @param outerRadius The radius of the sphere's outside edge
 * @param block The block to generate the sphere with
 * @param meta The block metadata to generate the sphere with
 */
public void genSphere(BlockPos pos,int outerRadius,IBlockState state){
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  for (int i=x - outerRadius; i < x + outerRadius; i++) {
    for (int j=y - outerRadius; j < y + outerRadius; j++) {
      for (int k=z - outerRadius; k < z + outerRadius; k++) {
        if (worldObj.isAirBlock(getBlockPos(i,j,k))) {
          int distance1=(i - x) * (i - x) + (j - y) * (j - y) + (k - z) * (k - z);
          if (distance1 <= outerRadius) {
            BlockPos pos2=getBlockPos(i,j,k);
            worldObj.setBlockState(pos2,state,blockGenNotifyFlag);
          }
        }
      }
    }
  }
}","/** 
 * Generates a sphere at the specified coordinates
 * @param x The x coordinate
 * @param y The y coordinate
 * @param z The z coordinate
 * @param outerRadius The radius of the sphere's outside edge
 * @param block The block to generate the sphere with
 * @param meta The block metadata to generate the sphere with
 */
public void genSphere(BlockPos pos,int outerRadius,IBlockState state){
  int x=pos.getX();
  int y=pos.getY();
  int z=pos.getZ();
  for (int i=x - outerRadius; i < x + outerRadius; i++) {
    for (int j=y - outerRadius; j < y + outerRadius; j++) {
      for (int k=z - outerRadius; k < z + outerRadius; k++) {
        if (worldObj.isAirBlock(TCGenUtils.getBlockPos(i,j,k))) {
          int distance1=(i - x) * (i - x) + (j - y) * (j - y) + (k - z) * (k - z);
          if (distance1 <= outerRadius) {
            BlockPos pos2=TCGenUtils.getBlockPos(i,j,k);
            worldObj.setBlockState(pos2,state,blockGenNotifyFlag);
          }
        }
      }
    }
  }
}",0.9887869520897044
109816,"/** 
 * Checks if any blocks not specified in allowedBlockList exist within the line and if not places the line
 * @param ai One end of the line
 * @param ai1 The other end of the line
 * @param block The block to generate the block circle line with
 * @param meta The metadata to generate the block circle line with
 * @param allowedBlockList The block to exclude from the check
 * @return The coordinates where a block was placed
 */
public ArrayList<int[]> checkAndPlaceBlockLine(int ai[],int ai1[],IBlockState state,List allowedBlockList){
  ArrayList<int[]> places=new ArrayList<int[]>();
  int ai2[]={0,0,0};
  byte byte0=0;
  int j=0;
  for (; byte0 < 3; byte0++) {
    ai2[byte0]=ai1[byte0] - ai[byte0];
    if (Math.abs(ai2[byte0]) > Math.abs(ai2[j])) {
      j=byte0;
    }
  }
  if (ai2[j] == 0) {
    return null;
  }
  byte byte1=otherCoordPairs[j];
  byte byte2=otherCoordPairs[j + 3];
  byte byte3;
  if (ai2[j] > 0) {
    byte3=1;
  }
 else {
    byte3=-1;
  }
  double d=(double)ai2[byte1] / (double)ai2[j];
  double d1=(double)ai2[byte2] / (double)ai2[j];
  int ai3[]={0,0,0};
  int k=0;
  for (int l=ai2[j] + byte3; k != l; k+=byte3) {
    ai3[j]=MathHelper.floor((double)(ai[j] + k) + 0.5D);
    ai3[byte1]=MathHelper.floor((double)ai[byte1] + (double)k * d + 0.5D);
    ai3[byte2]=MathHelper.floor((double)ai[byte2] + (double)k * d1 + 0.5D);
    BlockPos pos=getBlockPos(ai3);
    if (!allowedBlockList.contains(worldObj.getBlockState(pos))) {
      return null;
    }
  }
  for (int l=ai2[j] + byte3; k != l; k+=byte3) {
    ai3[j]=MathHelper.floor((double)(ai[j] + k) + 0.5D);
    ai3[byte1]=MathHelper.floor((double)ai[byte1] + (double)k * d + 0.5D);
    ai3[byte2]=MathHelper.floor((double)ai[byte2] + (double)k * d1 + 0.5D);
    BlockPos pos=getBlockPos(ai3);
    worldObj.setBlockState(pos,state,blockGenNotifyFlag);
    places.add(new int[]{ai3[0],ai3[1],ai3[2]});
  }
  return places;
}","/** 
 * Checks if any blocks not specified in allowedBlockList exist within the line and if not places the line
 * @param ai One end of the line
 * @param ai1 The other end of the line
 * @param block The block to generate the block circle line with
 * @param meta The metadata to generate the block circle line with
 * @param allowedBlockList The block to exclude from the check
 * @return The coordinates where a block was placed
 */
public ArrayList<int[]> checkAndPlaceBlockLine(int ai[],int ai1[],IBlockState state,List allowedBlockList){
  ArrayList<int[]> places=new ArrayList<int[]>();
  int ai2[]={0,0,0};
  byte byte0=0;
  int j=0;
  for (; byte0 < 3; byte0++) {
    ai2[byte0]=ai1[byte0] - ai[byte0];
    if (Math.abs(ai2[byte0]) > Math.abs(ai2[j])) {
      j=byte0;
    }
  }
  if (ai2[j] == 0) {
    return null;
  }
  byte byte1=otherCoordPairs[j];
  byte byte2=otherCoordPairs[j + 3];
  byte byte3;
  if (ai2[j] > 0) {
    byte3=1;
  }
 else {
    byte3=-1;
  }
  double d=(double)ai2[byte1] / (double)ai2[j];
  double d1=(double)ai2[byte2] / (double)ai2[j];
  int ai3[]={0,0,0};
  int k=0;
  for (int l=ai2[j] + byte3; k != l; k+=byte3) {
    ai3[j]=MathHelper.floor((double)(ai[j] + k) + 0.5D);
    ai3[byte1]=MathHelper.floor((double)ai[byte1] + (double)k * d + 0.5D);
    ai3[byte2]=MathHelper.floor((double)ai[byte2] + (double)k * d1 + 0.5D);
    BlockPos pos=TCGenUtils.getBlockPos(ai3);
    if (!allowedBlockList.contains(worldObj.getBlockState(pos))) {
      return null;
    }
  }
  for (int l=ai2[j] + byte3; k != l; k+=byte3) {
    ai3[j]=MathHelper.floor((double)(ai[j] + k) + 0.5D);
    ai3[byte1]=MathHelper.floor((double)ai[byte1] + (double)k * d + 0.5D);
    ai3[byte2]=MathHelper.floor((double)ai[byte2] + (double)k * d1 + 0.5D);
    BlockPos pos=TCGenUtils.getBlockPos(ai3);
    worldObj.setBlockState(pos,state,blockGenNotifyFlag);
    places.add(new int[]{ai3[0],ai3[1],ai3[2]});
  }
  return places;
}",0.994288681204569
109817,"/** 
 * Gets the terrain height at the specified coordinates
 * @param x The x coordinate
 * @param z The z coordinate
 * @return The terrain height at the specified coordinates
 */
public int getTerrainHeightAt(int x,int z){
  int height=worldObj.getHeight(getBlockPos(x,0,z)).getY() + 1;
  for (int y=height; y > 0; y--) {
    Block block=worldObj.getBlockState(getBlockPos(x,y,z)).getBlock();
    if (block == Blocks.DIRT || block == Blocks.GRASS || block == Blocks.SAND || block == Blocks.STONE) {
      return y + 1;
    }
  }
  return 0;
}","/** 
 * Gets the terrain height at the specified coordinates
 * @param x The x coordinate
 * @param z The z coordinate
 * @return The terrain height at the specified coordinates
 */
public int getTerrainHeightAt(int x,int z){
  int height=worldObj.getHeight(TCGenUtils.getBlockPos(x,0,z)).getY() + 1;
  for (int y=height; y > 0; y--) {
    Block block=worldObj.getBlockState(TCGenUtils.getBlockPos(x,y,z)).getBlock();
    if (block == Blocks.DIRT || block == Blocks.GRASS || block == Blocks.SAND || block == Blocks.STONE) {
      return y + 1;
    }
  }
  return 0;
}",0.9802158273381296
109818,"@Override public boolean generate(BlockPos pos){
  int i=pos.getX();
  int j=pos.getY();
  int k=pos.getZ();
  j=this.getTerrainHeightAt(i,k);
  pos=new BlockPos(i,j,k);
  if (!worldObj.isAirBlock(pos)) {
    return false;
  }
  int amount=rand.nextInt(MAX_BAMBOO - MIN_BAMBOO) + MIN_BAMBOO;
  int spread=rand.nextInt(3) - 1 + (int)(Math.sqrt(amount) / 2);
  for (int l=0; l < amount; l++) {
    int x=i + rand.nextInt(spread) - rand.nextInt(spread);
    int z=k + rand.nextInt(spread) - rand.nextInt(spread);
    int y=this.getTerrainHeightAt(x,z) - 1;
    int height=rand.nextInt(MAX_HEIGHT - MIN_HEIGHT) + MIN_HEIGHT;
    BlockPos bpos=new BlockPos(x,y,z);
    for (int h=0; h < height; h++) {
      bpos=bpos.up();
      boolean canPlace=BlockRegistry.bambooShoot.canBlockStay(worldObj,bpos);
      if (isAirBlock(bpos) && canPlace) {
        worldObj.setBlockState(bpos,BAMBOO_BLOCK.getDefaultState(),blockGenNotifyFlag);
      }
 else {
        break;
      }
    }
  }
  return true;
}","@Override public boolean generate(BlockPos pos){
  int i=pos.getX();
  int j=pos.getY();
  int k=pos.getZ();
  j=this.getTerrainHeightAt(i,k);
  pos=new BlockPos(i,j,k);
  if (!TCGenUtils.isAirBlock(worldObj,pos)) {
    return false;
  }
  int amount=rand.nextInt(MAX_BAMBOO - MIN_BAMBOO) + MIN_BAMBOO;
  int spread=rand.nextInt(3) - 1 + (int)(Math.sqrt(amount) / 2);
  for (int l=0; l < amount; l++) {
    int x=i + rand.nextInt(spread) - rand.nextInt(spread);
    int z=k + rand.nextInt(spread) - rand.nextInt(spread);
    int y=this.getTerrainHeightAt(x,z) - 1;
    int height=rand.nextInt(MAX_HEIGHT - MIN_HEIGHT) + MIN_HEIGHT;
    BlockPos bpos=new BlockPos(x,y,z);
    for (int h=0; h < height; h++) {
      bpos=bpos.up();
      boolean canPlace=BlockRegistry.bambooShoot.canBlockStay(worldObj,bpos);
      if (TCGenUtils.isAirBlock(worldObj,bpos) && canPlace) {
        worldObj.setBlockState(bpos,BAMBOO_BLOCK_STATE,blockGenNotifyFlag);
      }
 else {
        break;
      }
    }
  }
  return true;
}",0.9615576635047428
109819,"/** 
 * Returns whether the EntityAIBase should begin execution.
 */
public boolean shouldExecute(){
  BlockPos blockpos=new BlockPos(this.entityObj);
  if ((!this.entityObj.world.isDaytime() || this.entityObj.world.isRaining() && !this.entityObj.world.getBiome(blockpos).canRain()) && !this.entityObj.world.provider.hasNoSky()) {
    if (entityObj.posLastFireplaceFound != null && this.entityObj.getDistanceSq(entityObj.posLastFireplaceFound.getX(),entityObj.posLastFireplaceFound.getY(),entityObj.posLastFireplaceFound.getZ()) < 4.0D) {
      return true;
    }
 else     if (entityObj.posLastFireplaceFound != null && this.entityObj.getDistanceSq(entityObj.posLastFireplaceFound.getX(),entityObj.posLastFireplaceFound.getY(),entityObj.posLastFireplaceFound.getZ()) >= 4.0D) {
      return true;
    }
 else     if (entityObj.posLastFireplaceFound == null) {
      BlockPos pos=Util.findBlock(entityObj,20,Util::isFire);
      if (pos != null) {
        entityObj.setFirelacePos(pos);
        System.out.println(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
  }
 else {
    return false;
  }
  return false;
}","/** 
 * Returns whether the EntityAIBase should begin execution.
 */
public boolean shouldExecute(){
  BlockPos blockpos=new BlockPos(this.entityObj);
  if ((!this.entityObj.world.isDaytime() || this.entityObj.world.isRaining() && !this.entityObj.world.getBiome(blockpos).canRain()) && !this.entityObj.world.provider.hasNoSky()) {
    if (entityObj.posLastFireplaceFound != null && this.entityObj.getDistanceSq(entityObj.posLastFireplaceFound.getX(),entityObj.posLastFireplaceFound.getY(),entityObj.posLastFireplaceFound.getZ()) < 4.0D) {
      return true;
    }
 else     if (entityObj.posLastFireplaceFound != null && this.entityObj.getDistanceSq(entityObj.posLastFireplaceFound.getX(),entityObj.posLastFireplaceFound.getY(),entityObj.posLastFireplaceFound.getZ()) >= 4.0D) {
      return true;
    }
 else     if (entityObj.posLastFireplaceFound == null) {
      BlockPos pos=Util.findBlock(entityObj,20,Util::isFire);
      if (pos != null) {
        pos=pos.add(0,-1,0);
        entityObj.setFirelacePos(pos);
        IBlockState state=entityObj.world.getBlockState(pos);
        System.out.println(""String_Node_Str"");
        return true;
      }
 else {
        return false;
      }
    }
  }
 else {
    return false;
  }
  return false;
}",0.9621936019941836
109820,"/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
public boolean continueExecuting(){
  BlockPos blockpos=new BlockPos(this.entityObj);
  if ((!this.entityObj.world.isDaytime() || this.entityObj.world.isRaining() && !this.entityObj.world.getBiome(blockpos).canRain()) && !this.entityObj.world.provider.hasNoSky()) {
    return true;
  }
 else {
  }
  return false;
}","/** 
 * Returns whether an in-progress EntityAIBase should continue executing
 */
public boolean continueExecuting(){
  BlockPos blockpos=new BlockPos(this.entityObj);
  if ((!this.entityObj.world.isDaytime() || this.entityObj.world.isRaining() && !this.entityObj.world.getBiome(blockpos).canRain()) && !this.entityObj.world.provider.hasNoSky()) {
    if (entityObj.posLastFireplaceFound != null) {
      IBlockState state=entityObj.world.getBlockState(entityObj.posLastFireplaceFound);
      if (state.getMaterial() != Material.FIRE) {
        entityObj.posLastFireplaceFound=null;
        return false;
      }
    }
    return true;
  }
 else {
  }
  return false;
}",0.725398313027179
109821,"@Override protected void initEntityAI(){
  this.tasks.addTask(0,new EntityAISwimming(this));
  this.tasks.addTask(1,new EntityAIAvoidEntityOnLowHealth(this,EntityMob.class,8.0F,1D,1D,15F));
  this.tasks.addTask(1,new EntityAIAvoidEntityOnLowHealth(this,EntityAshen.class,8.0F,1D,1D,15F));
  this.tasks.addTask(1,new EntityAIAvoidEntityOnLowHealth(this,EntityIguana.class,8.0F,1D,1D,15F));
  this.tasks.addTask(1,new EntityAIAvoidEntityOnLowHealth(this,EntitySkeleton.class,8.0F,1D,1D,15F));
  this.tasks.addTask(2,new EntityAIAttackMelee(this,1F,true){
    @Override public void startExecuting(){
      super.startExecuting();
      if (this.attacker instanceof EntityKoaBase) {
        ((EntityKoaBase)this.attacker).setFightingItem();
      }
    }
  }
);
  this.tasks.addTask(3,new EntityAIChillAtFire(this));
  this.tasks.addTask(3,new EntityAIMoveIndoors(this));
  this.tasks.addTask(3,new EntityAIRestrictOpenDoor(this));
  this.tasks.addTask(4,new EntityAIOpenDoor(this,true));
  this.tasks.addTask(5,new EntityAIMoveTowardsRestriction(this,1D));
  this.tasks.addTask(6,new EntityAIVillagerMate(this));
  this.tasks.addTask(9,new EntityAIWatchClosest2(this,EntityPlayer.class,3.0F,1.0F));
  this.tasks.addTask(9,new EntityAIVillagerInteract(this));
  this.tasks.addTask(9,new EntityAIWanderNotLazy(this,1D,40));
  this.tasks.addTask(10,new EntityAIWatchClosest(this,EntityLiving.class,8.0F));
  this.targetTasks.addTask(1,new EntityAIHurtByTarget(this,true));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityMob.class,true));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityAshen.class,true));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityIguana.class,true));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntitySkeleton.class,true));
}","@Override protected void initEntityAI(){
  this.tasks.addTask(0,new EntityAISwimming(this));
  this.tasks.addTask(1,new EntityAIAvoidEntityOnLowHealth(this,EntityMob.class,8.0F,1D,1D,15F));
  this.tasks.addTask(1,new EntityAIAvoidEntityOnLowHealth(this,EntityAshen.class,8.0F,1D,1D,15F));
  this.tasks.addTask(1,new EntityAIAvoidEntityOnLowHealth(this,EntityIguana.class,8.0F,1D,1D,15F));
  this.tasks.addTask(1,new EntityAIAvoidEntityOnLowHealth(this,EntityTropiSkeleton.class,8.0F,1D,1D,15F));
  this.tasks.addTask(2,new EntityAIAttackMelee(this,1F,true){
    @Override public void startExecuting(){
      super.startExecuting();
      if (this.attacker instanceof EntityKoaBase) {
        ((EntityKoaBase)this.attacker).setFightingItem();
      }
    }
  }
);
  this.tasks.addTask(3,new EntityAIChillAtFire(this));
  this.tasks.addTask(3,new EntityAIMoveIndoors(this));
  this.tasks.addTask(3,new EntityAIRestrictOpenDoor(this));
  this.tasks.addTask(4,new EntityAIOpenDoor(this,true));
  this.tasks.addTask(5,new EntityAIMoveTowardsRestriction(this,1D));
  this.tasks.addTask(6,new EntityAIVillagerMate(this));
  this.tasks.addTask(9,new EntityAIWatchClosest2(this,EntityPlayer.class,3.0F,1.0F));
  this.tasks.addTask(9,new EntityAIVillagerInteract(this));
  this.tasks.addTask(9,new EntityAIWanderNotLazy(this,1D,40));
  this.tasks.addTask(10,new EntityAIWatchClosest(this,EntityLiving.class,8.0F));
  this.targetTasks.addTask(1,new EntityAIHurtByTarget(this,true));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityMob.class,true));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityAshen.class,true));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityIguana.class,true));
  this.targetTasks.addTask(2,new EntityAINearestAttackableTarget(this,EntityTropiSkeleton.class,true));
}",0.9973103819257664
109822,"public void readNBT(String level){
  levelData=null;
  try {
    NBTTagCompound nbttagcompound=CompressedStreamTools.readCompressed(new FileInputStream(level + ""String_Node_Str""));
    levelData=nbttagcompound;
    newFormat=nbttagcompound.getBoolean(""String_Node_Str"");
    if (nbttagcompound.hasKey(""String_Node_Str"")) {
      version=nbttagcompound.getString(""String_Node_Str"");
    }
 else {
    }
    if (newFormat) {
      NBTTagCompound nbtMapping=nbttagcompound.getCompoundTag(""String_Node_Str"");
      if (getVersion().equals(""String_Node_Str"")) {
        this.blockMappingInternalIDToBlock=genBlockIDSchemToBlockWithUnlocalizedName(nbtMapping);
      }
 else       if (getVersion().equals(""String_Node_Str"")) {
        this.blockMappingInternalIDToBlock=genBlockIDSchemToBlockWithRegistry(nbtMapping);
      }
 else {
        System.out.println(""String_Node_Str"" + getVersion());
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      NBTTagCompound nbtFallbackLookup=CompressedStreamTools.readCompressed(new FileInputStream(CoroUtilFile.getSaveFolderPath() + ""String_Node_Str""));
      this.blockMappingInternalIDToBlock=genBlockIDSchemToBlockWithUnlocalizedName(nbtFallbackLookup.getCompoundTag(""String_Node_Str""));
    }
    tileEntities=nbttagcompound.getTagList(""String_Node_Str"",10);
    entities=nbttagcompound.getTagList(""String_Node_Str"",10);
    int sizeX=map_sizeX=nbttagcompound.getShort(""String_Node_Str"");
    int sizeZ=map_sizeZ=nbttagcompound.getShort(""String_Node_Str"");
    int sizeY=map_sizeY=nbttagcompound.getShort(""String_Node_Str"");
    map_surfaceOffset=nbttagcompound.getShort(""String_Node_Str"");
    int bPosX=0;
    int bPosY=0;
    int bPosZ=0;
    build_blockIDArr=new Block[sizeX][sizeY][sizeZ];
    build_blockMetaArr=new int[sizeX][sizeY][sizeZ];
    if (newFormat) {
      int metadata[]=nbttagcompound.getIntArray(""String_Node_Str"");
      int blockids[]=nbttagcompound.getIntArray(""String_Node_Str"");
      for (int xx=0; xx < sizeX; xx++) {
        for (int yy=0; yy < sizeY; yy++) {
          for (int zz=0; zz < sizeZ; zz++) {
            int index=yy * sizeX * sizeZ + zz * sizeX + xx;
            build_blockMetaArr[xx][yy][zz]=metadata[index];
            int internalID=blockids[index];
            Block block=getConvertInternalIDToBlock(internalID);
            if (block != null) {
            }
 else {
              System.out.println(""String_Node_Str"" + getVersion() + ""String_Node_Str"");
              block=Blocks.AIR;
            }
            build_blockIDArr[xx][yy][zz]=block;
          }
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      byte metadata[]=nbttagcompound.getByteArray(""String_Node_Str"");
      byte blockids[]=nbttagcompound.getByteArray(""String_Node_Str"");
      for (int xx=0; xx < sizeX; xx++) {
        for (int yy=0; yy < sizeY; yy++) {
          for (int zz=0; zz < sizeZ; zz++) {
            int index=yy * sizeX * sizeZ + zz * sizeX + xx;
            build_blockMetaArr[xx][yy][zz]=metadata[index];
            int internalID=blockids[index];
            if (internalID < 0) {
              internalID+=256;
            }
            Block block=getConvertInternalIDToBlock(internalID);
            if (block != null) {
            }
 else {
              System.out.println(""String_Node_Str"" + getVersion() + ""String_Node_Str"");
              block=Blocks.AIR;
            }
            build_blockIDArr[xx][yy][zz]=block;
          }
        }
      }
    }
    file=level;
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","public void readNBT(String level){
  levelData=null;
  try {
    NBTTagCompound nbttagcompound=CompressedStreamTools.readCompressed(new FileInputStream(level + ""String_Node_Str""));
    levelData=nbttagcompound;
    newFormat=nbttagcompound.getBoolean(""String_Node_Str"");
    if (nbttagcompound.hasKey(""String_Node_Str"")) {
      version=nbttagcompound.getString(""String_Node_Str"");
    }
 else {
    }
    if (newFormat) {
      NBTTagCompound nbtMapping=nbttagcompound.getCompoundTag(""String_Node_Str"");
      if (getVersion().equals(""String_Node_Str"")) {
        this.blockMappingInternalIDToBlock=genBlockIDSchemToBlockWithUnlocalizedName(nbtMapping);
      }
 else       if (getVersion().equals(""String_Node_Str"")) {
        this.blockMappingInternalIDToBlock=genBlockIDSchemToBlockWithRegistry(nbtMapping);
      }
 else {
        System.out.println(""String_Node_Str"" + getVersion());
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      NBTTagCompound nbtFallbackLookup=CompressedStreamTools.readCompressed(new FileInputStream(UtilBuild.getSaveFolderPath() + ""String_Node_Str""));
      this.blockMappingInternalIDToBlock=genBlockIDSchemToBlockWithUnlocalizedName(nbtFallbackLookup.getCompoundTag(""String_Node_Str""));
    }
    tileEntities=nbttagcompound.getTagList(""String_Node_Str"",10);
    entities=nbttagcompound.getTagList(""String_Node_Str"",10);
    int sizeX=map_sizeX=nbttagcompound.getShort(""String_Node_Str"");
    int sizeZ=map_sizeZ=nbttagcompound.getShort(""String_Node_Str"");
    int sizeY=map_sizeY=nbttagcompound.getShort(""String_Node_Str"");
    map_surfaceOffset=nbttagcompound.getShort(""String_Node_Str"");
    int bPosX=0;
    int bPosY=0;
    int bPosZ=0;
    build_blockIDArr=new Block[sizeX][sizeY][sizeZ];
    build_blockMetaArr=new int[sizeX][sizeY][sizeZ];
    if (newFormat) {
      int metadata[]=nbttagcompound.getIntArray(""String_Node_Str"");
      int blockids[]=nbttagcompound.getIntArray(""String_Node_Str"");
      for (int xx=0; xx < sizeX; xx++) {
        for (int yy=0; yy < sizeY; yy++) {
          for (int zz=0; zz < sizeZ; zz++) {
            int index=yy * sizeX * sizeZ + zz * sizeX + xx;
            build_blockMetaArr[xx][yy][zz]=metadata[index];
            int internalID=blockids[index];
            Block block=getConvertInternalIDToBlock(internalID);
            if (block != null) {
            }
 else {
              System.out.println(""String_Node_Str"" + getVersion() + ""String_Node_Str"");
              block=Blocks.AIR;
            }
            build_blockIDArr[xx][yy][zz]=block;
          }
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      byte metadata[]=nbttagcompound.getByteArray(""String_Node_Str"");
      byte blockids[]=nbttagcompound.getByteArray(""String_Node_Str"");
      for (int xx=0; xx < sizeX; xx++) {
        for (int yy=0; yy < sizeY; yy++) {
          for (int zz=0; zz < sizeZ; zz++) {
            int index=yy * sizeX * sizeZ + zz * sizeX + xx;
            build_blockMetaArr[xx][yy][zz]=metadata[index];
            int internalID=blockids[index];
            if (internalID < 0) {
              internalID+=256;
            }
            Block block=getConvertInternalIDToBlock(internalID);
            if (block != null) {
            }
 else {
              System.out.println(""String_Node_Str"" + getVersion() + ""String_Node_Str"");
              block=Blocks.AIR;
            }
            build_blockIDArr[xx][yy][zz]=block;
          }
        }
      }
    }
    file=level;
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}",0.9981810549881068
109823,"public void genSchematic(){
  int yOffset=0;
  Build mainStructureData=new Build(spawn.getX(),spawn.getY() + yOffset,spawn.getZ(),CoroUtilFile.getSaveFolderPath() + ""String_Node_Str"" + File.separator+ ""String_Node_Str"");
  BuildJob bj=new BuildJob(-99,spawn.getX(),spawn.getY() + yOffset,spawn.getZ(),mainStructureData);
  bj.build.dim=getWorld().provider.getDimension();
  bj.useFirstPass=false;
  bj.useRotationBuild=true;
  bj.build_rate=100;
  bj.notifyFlag=0;
  bj.setDirection(direction);
  bj.customGenCallback=this;
  areaHeight=mainStructureData.map_sizeY;
  BuildServerTicks.buildMan.addBuild(bj);
}","public void genSchematic(){
  int yOffset=0;
  Build mainStructureData=new Build(spawn.getX(),spawn.getY() + yOffset,spawn.getZ(),UtilBuild.getSaveFolderPath() + ""String_Node_Str"" + File.separator+ ""String_Node_Str"");
  BuildJob bj=new BuildJob(-99,spawn.getX(),spawn.getY() + yOffset,spawn.getZ(),mainStructureData);
  bj.build.dim=getWorld().provider.getDimension();
  bj.useFirstPass=false;
  bj.useRotationBuild=true;
  bj.build_rate=100;
  bj.notifyFlag=0;
  bj.setDirection(direction);
  bj.customGenCallback=this;
  areaHeight=mainStructureData.map_sizeY;
  BuildServerTicks.buildMan.addBuild(bj);
}",0.9893004115226336
109824,"@Override public void spawnMemberAtSpawnLocation(SpawnLocationData parData){
  super.spawnMemberAtSpawnLocation(parData);
  EntityKoaBase ent=null;
  if (parData.type.equals(""String_Node_Str"")) {
    ent=new EntityKoaFisher(getWorld());
  }
 else   if (parData.type.equals(""String_Node_Str"")) {
    ent=new EntityKoaHunter(getWorld());
  }
 else   if (parData.type.equals(""String_Node_Str"")) {
    ent=new EntityKoaTrader(getWorld());
  }
 else   if (parData.type.equals(""String_Node_Str"")) {
    ent=new EntityKoaShaman(getWorld());
  }
  if (ent != null) {
    ent.getAIAgent().setManagedLocation(this);
    ent.setPosition(spawn.getX() + parData.coords.getX() + 0.5F,spawn.getY() + parData.coords.getY(),spawn.getZ() + parData.coords.getZ() + 0.5F);
    getWorld().spawnEntityInWorld(ent);
    addEntity(parData.type,ent);
    parData.entityUUID=ent.getPersistentID();
    ent.onSpawnWithEgg(null);
  }
}","@Override public void spawnMemberAtSpawnLocation(SpawnLocationData parData){
  super.spawnMemberAtSpawnLocation(parData);
  EntityKoaBase ent=null;
  ent=new EntityKoaHunter(getWorld());
  if (ent != null) {
    ent.setPosition(spawn.getX() + parData.coords.getX() + 0.5F,spawn.getY() + parData.coords.getY(),spawn.getZ() + parData.coords.getZ() + 0.5F);
    getWorld().spawnEntity(ent);
    addEntity(parData.type,ent);
    parData.entityUUID=ent.getPersistentID();
    ent.onInitialSpawn(getWorld().getDifficultyForLocation(ent.getPosition()),null);
  }
}",0.6707650273224044
109825,"public static boolean hookTryGenVillage(BlockPos parCoords,World parWorld){
  int directionTry=getBestGenDirection(parCoords,parWorld);
  if (directionTry != -1) {
    System.out.println(""String_Node_Str"" + directionTry);
    BlockPos centerCoords=getCoordsFromAdjustedDirection(parCoords,directionTry);
    System.out.println(""String_Node_Str"" + centerCoords);
    TownKoaVillage village=new TownKoaVillage();
    WorldDirector wd=WorldDirectorManager.instance().getCoroUtilWorldDirector(parWorld);
    int minDistBetweenVillages=128;
    Iterator it=wd.lookupTickingManagedLocations.values().iterator();
    while (it.hasNext()) {
      ManagedLocation town=(ManagedLocation)it.next();
      if (Math.sqrt(town.spawn.getDistanceSquaredToBlockPos(parCoords)) < minDistBetweenVillages) {
        return false;
      }
    }
    int newID=wd.lookupTickingManagedLocations.size();
    village.initData(newID,parWorld.provider.dimensionId,centerCoords);
    village.direction=directionTry;
    village.initFirstTime();
    wd.addTickingLocation(village);
    return true;
  }
 else {
  }
  return false;
}","public static boolean hookTryGenVillage(BlockPos parCoords,World parWorld){
  int directionTry=getBestGenDirection(parCoords,parWorld);
  if (directionTry != -1) {
    System.out.println(""String_Node_Str"" + directionTry);
    BlockPos centerCoords=getCoordsFromAdjustedDirection(parCoords,directionTry);
    System.out.println(""String_Node_Str"" + centerCoords);
    TownKoaVillage village=new TownKoaVillage();
    return true;
  }
 else {
  }
  return false;
}",0.5399872040946897
109826,"public static void init(FMLServerStartingEvent event){
  event.registerServerCommand(new CommandTropicsTeleport());
}","public static void init(FMLServerStartingEvent event){
  event.registerServerCommand(new CommandTropicsTeleport());
  event.registerServerCommand(new CommandTropicsVillage());
}",0.7959183673469388
109827,"@Override public void onLivingUpdate(){
  super.onLivingUpdate();
  if (this instanceof IPredatorDiet && world.getDifficulty().equals(EnumDifficulty.PEACEFUL)) {
    boolean hasPlayer=false;
    Class[] prey=((IPredatorDiet)this).getPreyClasses();
    for (    Class c : prey) {
      if (c.getName().equals(EntityPlayer.class.getName())) {
        hasPlayer=true;
        break;
      }
    }
    if (hasPlayer) {
      this.setDead();
    }
  }
  if (world.isRemote) {
    this.rotationPitch=-this.swimPitch;
    this.rotationYaw=-this.swimYaw;
    this.rotationYawHead=-this.swimYaw;
    this.prevRotationYawHead=-this.prevSwimYaw;
    this.renderYawOffset=0;
    this.cameraPitch=-this.swimPitch;
    this.prevRotationPitch=-this.prevSwimPitch;
    this.prevRotationYaw=-this.prevSwimYaw;
    this.prevSwimYaw=this.swimYaw;
    this.swimYaw=this.getDataManager().get(SWIMYAW);
    this.prevSwimPitch=this.swimPitch;
    this.swimPitch=this.getDataManager().get(SWIMPITCH);
    return;
  }
  if (this.isInWater()) {
    this.outOfWaterTime=0;
    BlockPos bp=new BlockPos((int)posX,(int)posY - 2,(int)posZ);
    bp=new BlockPos((int)posX,(int)posY + 1,(int)posZ);
    if (!this.world.getBlockState(bp).getMaterial().isLiquid()) {
      if (this.swimPitch > 0f) {
        Vec3d angle=this.getHeading();
        double frontDist=5f;
        Vec3d diff=new Vec3d(posX + (angle.xCoord * frontDist),posY + angle.yCoord,posZ + (angle.zCoord * frontDist));
        this.isPanicking=false;
        this.setTargetHeading(diff.xCoord,posY - 2,diff.zCoord,true);
      }
    }
    if (rand.nextInt(20) == 0) {
      this.setRandomTargetHeading();
    }
    if (canAggress) {
      if (this.ticksExisted % 200 == 0 && this.aggressTarget == null || !world.getLoadedEntityList().contains(aggressTarget)) {
        List<Entity> list=world.getEntitiesInAABBexcluding(this,this.getEntityBoundingBox().expand(20D,20D,20D).offset(0.0D,-8.0D,0.0D),EntitySelectors.IS_ALIVE);
        if (list.size() > 0) {
          Entity ent=list.get(rand.nextInt(list.size()));
          boolean skip=false;
          if (ent.equals(this))           skip=true;
          if (ent.getClass().getName().equals(this.getClass().getName()))           skip=true;
          if (this instanceof IPredatorDiet) {
            Class[] prey=((IPredatorDiet)this).getPreyClasses();
            boolean contains=false;
            for (int i=0; i < prey.length; i++) {
              if (prey[i].getName().equals(ent.getClass().getName())) {
                contains=true;
              }
            }
            if (!contains) {
              skip=true;
            }
          }
          if (!ent.isInWater())           skip=true;
          if (!this.canEntityBeSeen(ent))           skip=true;
          if (!skip) {
            if (ent instanceof EntityLivingBase) {
              if (((EntityLivingBase)ent).isInWater()) {
                this.aggressTarget=ent;
              }
            }
          }
        }
      }
      if (rand.nextInt(200) == 0) {
        this.aggressTarget=null;
        this.setRandomTargetHeading();
      }
    }
    if (this.ticksExisted % 80 == 0) {
      Vec3d angle=this.getHeading();
      double frontDist=2f;
      double behindDist=8f;
      Vec3d diff=new Vec3d(posX + (angle.xCoord * frontDist),posY + angle.yCoord,posZ + (angle.zCoord * frontDist));
      bp=new BlockPos((int)diff.xCoord,(int)posY,(int)diff.zCoord);
      if (!this.world.getBlockState(bp).getMaterial().isLiquid()) {
        Vec3d behind=new Vec3d(posX - (angle.xCoord * behindDist),posY + angle.yCoord,posZ - (angle.zCoord * behindDist));
        this.setTargetHeading(behind.xCoord,posY + 5,behind.zCoord,true);
      }
    }
    if (this.fleeFromPlayers && ticksExisted % 80 == 0) {
      EntityPlayer closest=world.getClosestPlayerToEntity(this,this.fleeDistance);
      if (closest != null) {
        if (closest.isInWater()) {
          this.fleeEntity(closest);
          this.isPanicking=true;
        }
      }
 else {
        this.isPanicking=false;
      }
    }
 else {
      this.isPanicking=false;
    }
    if (this.canSchool) {
      if (!isLeader && leader == null) {
        List<Entity> ents=world.getLoadedEntityList();
        for (int i=0; i < ents.size(); i++) {
          if (ents.get(i) instanceof EntityTropicraftWaterBase) {
            EntityTropicraftWaterBase f=((EntityTropicraftWaterBase)ents.get(i));
            if (f.getClass().getName().equals(this.getClass().getName())) {
              if (f instanceof IAtlasFish && this instanceof IAtlasFish) {
                int slot=((IAtlasFish)f).getAtlasSlot();
                if (((IAtlasFish)this).getAtlasSlot() != slot) {
                  continue;
                }
              }
              if (f.isLeader) {
                this.leader=f;
              }
            }
          }
        }
        if (this.ticksExisted > 200 && leader == null) {
          this.markAsLeader();
        }
      }
      if (this.ticksExisted > 200 && leader == null) {
        this.markAsLeader();
      }
    }
    if (this.aggressTarget != null) {
      if (this.getDistanceSqToEntity(this.aggressTarget) < 1.2f) {
        if (this.aggressTarget instanceof EntityLivingBase)         ((EntityLivingBase)this.aggressTarget).attackEntityFrom(DamageSource.cactus,1);
        this.setRandomTargetHeading();
      }
 else {
        if (this.canEntityBeSeen(this.aggressTarget) && this.ticksExisted % 5 == 0) {
          this.setTargetHeading(this.aggressTarget.posX,this.aggressTarget.posY,this.aggressTarget.posZ,true);
        }
      }
      if (this.aggressTarget != null) {
        if (!this.aggressTarget.isInWater()) {
          this.aggressTarget=null;
          this.setRandomTargetHeading();
        }
      }
    }
    if (!this.isAggressing && this.ticksExisted % 80 == 0) {
      List<Entity> ents=world.getLoadedEntityList();
      for (int i=0; i < ents.size(); i++) {
        if (ents.get(i) instanceof EntityTropicraftWaterBase) {
          EntityTropicraftWaterBase f=((EntityTropicraftWaterBase)ents.get(i));
          if (this.canEntityBeSeen(f) && this.getDistanceSqToEntity(f) < 2D)           if (f.aggressTarget != null)           if (f.aggressTarget.equals(this)) {
            this.fleeEntity(f);
            this.isPanicking=true;
            break;
          }
        }
      }
    }
    bp=new BlockPos((int)posX,(int)posY - 2,(int)posZ);
    if (!this.world.getBlockState(bp).getMaterial().isLiquid()) {
      if (this.swimPitch < 0f) {
        this.swimPitch+=2f;
      }
    }
    if (this.canSchool) {
      if (this.leader != null && !isLeader) {
        this.setTargetHeading(this.leader.posX,this.leader.posY - 5 + rand.nextInt(10),this.leader.posZ,true);
        if (leader.aggressTarget != null) {
          this.aggressTarget=leader.aggressTarget;
        }
      }
    }
    float swimSpeedTurn=this.swimSpeedTurn;
    if (this.targetVectorHeading != null) {
      this.swimYaw=lerp(this.swimYaw,-this.targetVectorHeading.x,swimSpeedTurn * 2f);
      this.swimPitch=lerp(this.swimPitch,-this.targetVectorHeading.y,swimSpeedTurn * 2f);
    }
  }
  if (!this.isInWater()) {
    this.outOfWaterTime++;
    this.setTargetHeading(posX,posY - 1,posZ,false);
  }
  float currentSpeed=this.swimSpeedCurrent;
  float desiredSpeed=this.swimSpeedDefault;
  if (this.aggressTarget != null) {
    if (this.getDistanceSqToEntity(this.aggressTarget) < 10f) {
      desiredSpeed=this.swimSpeedCharging;
    }
 else {
      desiredSpeed=this.swimSpeedChasing;
    }
    if (!world.getLoadedEntityList().contains(this.aggressTarget) || this.aggressTarget.isDead) {
      this.aggressTarget=null;
      this.setRandomTargetHeading();
    }
  }
  if (this.isPanicking) {
    desiredSpeed=this.swimSpeedPanic;
  }
  if (this.swimSpeedCurrent < desiredSpeed) {
    this.swimSpeedCurrent+=this.swimAccelRate;
  }
  if (this.swimSpeedCurrent > desiredSpeed) {
    this.swimSpeedCurrent-=this.swimDecelRate;
  }
  currentSpeed*=0.1f;
  if (this.isInWater()) {
    motionX=currentSpeed * Math.sin(this.swimYaw * (Math.PI / 180.0));
    motionZ=currentSpeed * Math.cos(this.swimYaw * (Math.PI / 180.0));
    motionY=(currentSpeed) * Math.sin((this.swimPitch) * (Math.PI / 180.0));
    fallVelocity=0f;
  }
  if (!this.isInWater()) {
    if (this.onGround) {
      if (rand.nextInt(6) == 0) {
        this.motionX+=rand.nextBoolean() ? rand.nextFloat() / 8 : -rand.nextFloat() / 8;
        this.motionZ+=rand.nextBoolean() ? rand.nextFloat() / 8 : -rand.nextFloat() / 8;
      }
      this.motionX*=0.5f;
      this.motionZ*=0.5f;
      if (this.ticksExisted % 4 == 0)       this.fallVelocity=-.02f;
      if (rand.nextInt(20) == 0 || this.hurtTime > 0) {
        this.fallVelocity=-.03f;
        this.swimPitch=25f;
      }
    }
    if (this.swimPitch > 0f) {
      this.swimPitch-=5f;
    }
    if (this.ticksExisted % 20 == 0) {
      this.outOfWaterAngle=rand.nextInt(360);
    }
    float turnSpeed=5f;
    if (this.hurtTime > 0) {
      turnSpeed=15f;
    }
    if (this.swimYaw > this.outOfWaterAngle) {
      this.swimYaw-=turnSpeed;
    }
    if (this.swimYaw < this.outOfWaterAngle) {
      this.swimYaw+=turnSpeed;
    }
    this.motionY-=this.fallVelocity;
    this.fallVelocity+=(this.fallGravity / 10);
  }
  if (swimPitch > 45f) {
    swimPitch=45f;
  }
  syncSwimAngles();
  prevSwimPitch=swimPitch;
  prevSwimYaw=swimYaw;
}","@Override public void onLivingUpdate(){
  super.onLivingUpdate();
  if (this instanceof IPredatorDiet && world.getDifficulty().equals(EnumDifficulty.PEACEFUL)) {
    boolean hasPlayer=false;
    Class[] prey=((IPredatorDiet)this).getPreyClasses();
    for (    Class c : prey) {
      if (c.getName().equals(EntityPlayer.class.getName())) {
        hasPlayer=true;
        break;
      }
    }
    if (hasPlayer) {
      this.setDead();
    }
  }
  if (world.isRemote) {
    this.rotationPitch=-this.swimPitch;
    this.rotationYaw=-this.swimYaw;
    this.rotationYawHead=-this.swimYaw;
    this.prevRotationYawHead=-this.prevSwimYaw;
    this.renderYawOffset=0;
    this.cameraPitch=-this.swimPitch;
    this.prevRotationPitch=-this.prevSwimPitch;
    this.prevRotationYaw=-this.prevSwimYaw;
    this.prevSwimYaw=this.swimYaw;
    this.swimYaw=this.getDataManager().get(SWIMYAW);
    this.prevSwimPitch=this.swimPitch;
    this.swimPitch=this.getDataManager().get(SWIMPITCH);
    return;
  }
  if (this.isInWater()) {
    this.outOfWaterTime=0;
    BlockPos bp=new BlockPos((int)posX,(int)posY - 2,(int)posZ);
    bp=new BlockPos((int)posX,(int)posY + 1,(int)posZ);
    if (!this.world.getBlockState(bp).getMaterial().isLiquid()) {
      if (this.swimPitch > 0f) {
        Vec3d angle=this.getHeading();
        double frontDist=5f;
        Vec3d diff=new Vec3d(posX + (angle.xCoord * frontDist),posY + angle.yCoord,posZ + (angle.zCoord * frontDist));
        this.isPanicking=false;
        this.setTargetHeading(diff.xCoord,posY - 2,diff.zCoord,true);
      }
    }
    if (rand.nextInt(20) == 0) {
      this.setRandomTargetHeading();
    }
    if (canAggress) {
      if (this.ticksExisted % 200 == 0 && this.aggressTarget == null || !world.loadedEntityList.contains(aggressTarget)) {
        List<Entity> list=world.getEntitiesInAABBexcluding(this,this.getEntityBoundingBox().expand(20D,20D,20D).offset(0.0D,-8.0D,0.0D),EntitySelectors.IS_ALIVE);
        if (list.size() > 0) {
          Entity ent=list.get(rand.nextInt(list.size()));
          boolean skip=false;
          if (ent.equals(this))           skip=true;
          if (ent.getClass().getName().equals(this.getClass().getName()))           skip=true;
          if (this instanceof IPredatorDiet) {
            Class[] prey=((IPredatorDiet)this).getPreyClasses();
            boolean contains=false;
            for (int i=0; i < prey.length; i++) {
              if (prey[i].getName().equals(ent.getClass().getName())) {
                contains=true;
              }
            }
            if (!contains) {
              skip=true;
            }
          }
          if (!ent.isInWater())           skip=true;
          if (!this.canEntityBeSeen(ent))           skip=true;
          if (!skip) {
            if (ent instanceof EntityLivingBase) {
              if (((EntityLivingBase)ent).isInWater()) {
                this.aggressTarget=ent;
              }
            }
          }
        }
      }
      if (rand.nextInt(200) == 0) {
        this.aggressTarget=null;
        this.setRandomTargetHeading();
      }
    }
    if (this.ticksExisted % 80 == 0) {
      Vec3d angle=this.getHeading();
      double frontDist=2f;
      double behindDist=8f;
      Vec3d diff=new Vec3d(posX + (angle.xCoord * frontDist),posY + angle.yCoord,posZ + (angle.zCoord * frontDist));
      bp=new BlockPos((int)diff.xCoord,(int)posY,(int)diff.zCoord);
      if (!this.world.getBlockState(bp).getMaterial().isLiquid()) {
        Vec3d behind=new Vec3d(posX - (angle.xCoord * behindDist),posY + angle.yCoord,posZ - (angle.zCoord * behindDist));
        this.setTargetHeading(behind.xCoord,posY + 5,behind.zCoord,true);
      }
    }
    if (this.fleeFromPlayers && ticksExisted % 80 == 0) {
      EntityPlayer closest=world.getClosestPlayerToEntity(this,this.fleeDistance);
      if (closest != null) {
        if (closest.isInWater()) {
          this.fleeEntity(closest);
          this.isPanicking=true;
        }
      }
 else {
        this.isPanicking=false;
      }
    }
 else {
      this.isPanicking=false;
    }
    if (this.canSchool) {
      if (!isLeader && leader == null) {
        List<Entity> ents=world.loadedEntityList;
        for (int i=0; i < ents.size(); i++) {
          if (ents.get(i) instanceof EntityTropicraftWaterBase) {
            EntityTropicraftWaterBase f=((EntityTropicraftWaterBase)ents.get(i));
            if (f.getClass().getName().equals(this.getClass().getName())) {
              if (f instanceof IAtlasFish && this instanceof IAtlasFish) {
                int slot=((IAtlasFish)f).getAtlasSlot();
                if (((IAtlasFish)this).getAtlasSlot() != slot) {
                  continue;
                }
              }
              if (f.isLeader) {
                this.leader=f;
              }
            }
          }
        }
        if (this.ticksExisted > 200 && leader == null) {
          this.markAsLeader();
        }
      }
      if (this.ticksExisted > 200 && leader == null) {
        this.markAsLeader();
      }
    }
    if (this.aggressTarget != null) {
      if (this.getDistanceSqToEntity(this.aggressTarget) < 1.2f) {
        if (this.aggressTarget instanceof EntityLivingBase)         ((EntityLivingBase)this.aggressTarget).attackEntityFrom(DamageSource.cactus,1);
        this.setRandomTargetHeading();
      }
 else {
        if (this.canEntityBeSeen(this.aggressTarget) && this.ticksExisted % 5 == 0) {
          this.setTargetHeading(this.aggressTarget.posX,this.aggressTarget.posY,this.aggressTarget.posZ,true);
        }
      }
      if (this.aggressTarget != null) {
        if (!this.aggressTarget.isInWater()) {
          this.aggressTarget=null;
          this.setRandomTargetHeading();
        }
      }
    }
    if (!this.isAggressing && this.ticksExisted % 80 == 0) {
      List<Entity> ents=world.loadedEntityList;
      for (int i=0; i < ents.size(); i++) {
        if (ents.get(i) instanceof EntityTropicraftWaterBase) {
          EntityTropicraftWaterBase f=((EntityTropicraftWaterBase)ents.get(i));
          if (this.canEntityBeSeen(f) && this.getDistanceSqToEntity(f) < 2D)           if (f.aggressTarget != null)           if (f.aggressTarget.equals(this)) {
            this.fleeEntity(f);
            this.isPanicking=true;
            break;
          }
        }
      }
    }
    bp=new BlockPos((int)posX,(int)posY - 2,(int)posZ);
    if (!this.world.getBlockState(bp).getMaterial().isLiquid()) {
      if (this.swimPitch < 0f) {
        this.swimPitch+=2f;
      }
    }
    if (this.canSchool) {
      if (this.leader != null && !isLeader) {
        this.setTargetHeading(this.leader.posX,this.leader.posY - 5 + rand.nextInt(10),this.leader.posZ,true);
        if (leader.aggressTarget != null) {
          this.aggressTarget=leader.aggressTarget;
        }
      }
    }
    float swimSpeedTurn=this.swimSpeedTurn;
    if (this.targetVectorHeading != null) {
      this.swimYaw=lerp(this.swimYaw,-this.targetVectorHeading.x,swimSpeedTurn * 2f);
      this.swimPitch=lerp(this.swimPitch,-this.targetVectorHeading.y,swimSpeedTurn * 2f);
    }
  }
  if (!this.isInWater()) {
    this.outOfWaterTime++;
    this.setTargetHeading(posX,posY - 1,posZ,false);
  }
  float currentSpeed=this.swimSpeedCurrent;
  float desiredSpeed=this.swimSpeedDefault;
  if (this.aggressTarget != null) {
    if (this.getDistanceSqToEntity(this.aggressTarget) < 10f) {
      desiredSpeed=this.swimSpeedCharging;
    }
 else {
      desiredSpeed=this.swimSpeedChasing;
    }
    if (!world.loadedEntityList.contains(this.aggressTarget) || this.aggressTarget.isDead) {
      this.aggressTarget=null;
      this.setRandomTargetHeading();
    }
  }
  if (this.isPanicking) {
    desiredSpeed=this.swimSpeedPanic;
  }
  if (this.swimSpeedCurrent < desiredSpeed) {
    this.swimSpeedCurrent+=this.swimAccelRate;
  }
  if (this.swimSpeedCurrent > desiredSpeed) {
    this.swimSpeedCurrent-=this.swimDecelRate;
  }
  currentSpeed*=0.1f;
  if (this.isInWater()) {
    motionX=currentSpeed * Math.sin(this.swimYaw * (Math.PI / 180.0));
    motionZ=currentSpeed * Math.cos(this.swimYaw * (Math.PI / 180.0));
    motionY=(currentSpeed) * Math.sin((this.swimPitch) * (Math.PI / 180.0));
    fallVelocity=0f;
  }
  if (!this.isInWater()) {
    if (this.onGround) {
      if (rand.nextInt(6) == 0) {
        this.motionX+=rand.nextBoolean() ? rand.nextFloat() / 8 : -rand.nextFloat() / 8;
        this.motionZ+=rand.nextBoolean() ? rand.nextFloat() / 8 : -rand.nextFloat() / 8;
      }
      this.motionX*=0.5f;
      this.motionZ*=0.5f;
      if (this.ticksExisted % 4 == 0)       this.fallVelocity=-.02f;
      if (rand.nextInt(20) == 0 || this.hurtTime > 0) {
        this.fallVelocity=-.03f;
        this.swimPitch=25f;
      }
    }
    if (this.swimPitch > 0f) {
      this.swimPitch-=5f;
    }
    if (this.ticksExisted % 20 == 0) {
      this.outOfWaterAngle=rand.nextInt(360);
    }
    float turnSpeed=5f;
    if (this.hurtTime > 0) {
      turnSpeed=15f;
    }
    if (this.swimYaw > this.outOfWaterAngle) {
      this.swimYaw-=turnSpeed;
    }
    if (this.swimYaw < this.outOfWaterAngle) {
      this.swimYaw+=turnSpeed;
    }
    this.motionY-=this.fallVelocity;
    this.fallVelocity+=(this.fallGravity / 10);
  }
  if (swimPitch > 45f) {
    swimPitch=45f;
  }
  syncSwimAngles();
  prevSwimPitch=swimPitch;
  prevSwimYaw=swimYaw;
}",0.9985085756897838
109828,"@Override public void registerItemVariantModel(Item item,String registryName,int metadata,String variantName){
  if (item != null) {
    ModelLoader.setCustomModelResourceLocation(item,metadata,new ModelResourceLocation(Info.MODID + ""String_Node_Str"" + variantName,null));
  }
}","@Override public void registerItemVariantModel(Item item,String name,int metadata,String variant){
  if (item != null) {
    ModelLoader.setCustomModelResourceLocation(item,metadata,new ModelResourceLocation(Info.MODID + ""String_Node_Str"" + name,variant));
  }
}",0.8074074074074075
109829,"public void registerItemVariantModel(Item item,String registryName,int metadata,String variantName){
}","public void registerItemVariantModel(Item item,String name,int metadata,String variant){
}",0.9270833333333334
109830,"/** 
 * Helper method for registering slabs, since they're pretty funky
 * @param block
 * @param singleSlab
 * @param doubleSlab
 * @param name
 * @return
 */
private static BlockSlab registerSlab(BlockSlab block,BlockSlab singleSlab,BlockSlab doubleSlab,String name){
  block=registerBlock(block,new ItemTropicraftSlab(block,singleSlab,doubleSlab),name,false,CreativeTabRegistry.tropicraftTab);
  ImmutableSet<IBlockState> presets=getBlockPresets(block);
  ITropicraftBlock tcBlock=(ITropicraftBlock)block;
  if (presets.isEmpty()) {
    registerBlockVariant(block,name,0);
  }
 else {
    for (    IBlockState state : presets) {
      String stateName=tcBlock.getStateName(state);
      int stateMeta=block.getMetaFromState(state);
      registerBlockVariant(block,name,stateMeta,stateName);
    }
  }
  block.setCreativeTab(CreativeTabRegistry.tropicraftTab);
  return block;
}","/** 
 * Helper method for registering slabs, since they're pretty funky
 * @param block
 * @param singleSlab
 * @param doubleSlab
 * @param name
 * @return
 */
private static BlockSlab registerSlab(BlockSlab block,BlockSlab singleSlab,BlockSlab doubleSlab,String name){
  block=registerBlock(block,new ItemTropicraftSlab(block,singleSlab,doubleSlab),name,false,CreativeTabRegistry.tropicraftTab);
  ImmutableSet<IBlockState> presets=getBlockPresets(block);
  ITropicraftBlock tcBlock=(ITropicraftBlock)block;
  if (presets.isEmpty()) {
    registerBlockVariant(block,name,0);
  }
 else {
    for (    IBlockState state : presets) {
      String stateName=tcBlock.getStateName(state);
      int stateMeta=block.getMetaFromState(state);
      registerBlockVariant(block,stateName,stateMeta,null);
    }
  }
  block.setCreativeTab(CreativeTabRegistry.tropicraftTab);
  return block;
}",0.9886492622020432
109831,"/** 
 * Register a block with metadata
 * @param block Block being registered
 * @param name Name of the image prefix
 * @param names Names of the images
 */
private static <T extends Block & ITropicraftBlock>T registerMultiBlock(T block,Class<? extends ItemBlock> clazz,String name,Object... itemCtorArgs){
  try {
    Class<?>[] ctorArgClasses=new Class<?>[itemCtorArgs.length + 1];
    ctorArgClasses[0]=Block.class;
    for (int idx=1; idx < ctorArgClasses.length; idx++) {
      ctorArgClasses[idx]=itemCtorArgs[idx - 1].getClass();
    }
    ItemBlock itemBlockInstance;
    if (clazz != null) {
      Constructor<? extends ItemBlock> itemConstructor=clazz.getConstructor(ctorArgClasses);
      itemBlockInstance=itemConstructor.newInstance(ObjectArrays.concat(block,itemCtorArgs));
    }
 else {
      itemBlockInstance=null;
    }
    block=registerBlock(block,itemBlockInstance,name,false,CreativeTabRegistry.tropicraftTab);
    ImmutableSet<IBlockState> presets=getBlockPresets(block);
    if (presets.isEmpty()) {
      registerBlockVariant(block,name,0);
    }
 else {
      for (      IBlockState state : presets) {
        String stateName=block.getStateName(state);
        int stateMeta=block.getMetaFromState(state);
        registerBlockVariant(block,name,stateMeta,stateName);
      }
    }
    block.setCreativeTab(CreativeTabRegistry.tropicraftTab);
    return block;
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + name);
    e.printStackTrace();
  }
  return null;
}","/** 
 * Register a block with metadata
 * @param block Block being registered
 * @param name Name of the image prefix
 * @param names Names of the images
 */
private static <T extends Block & ITropicraftBlock>T registerMultiBlock(T block,Class<? extends ItemBlock> clazz,String name,Object... itemCtorArgs){
  try {
    Class<?>[] ctorArgClasses=new Class<?>[itemCtorArgs.length + 1];
    ctorArgClasses[0]=Block.class;
    for (int idx=1; idx < ctorArgClasses.length; idx++) {
      ctorArgClasses[idx]=itemCtorArgs[idx - 1].getClass();
    }
    ItemBlock itemBlockInstance;
    if (clazz != null) {
      Constructor<? extends ItemBlock> itemConstructor=clazz.getConstructor(ctorArgClasses);
      itemBlockInstance=itemConstructor.newInstance(ObjectArrays.concat(block,itemCtorArgs));
    }
 else {
      itemBlockInstance=null;
    }
    block=registerBlock(block,itemBlockInstance,name,false,CreativeTabRegistry.tropicraftTab);
    ImmutableSet<IBlockState> presets=getBlockPresets(block);
    if (presets.isEmpty()) {
      registerBlockVariant(block,name,0);
    }
 else {
      for (      IBlockState state : presets) {
        String stateName=block.getStateName(state);
        int stateMeta=block.getMetaFromState(state);
        registerBlockVariant(block,stateName,stateMeta,null);
      }
    }
    block.setCreativeTab(CreativeTabRegistry.tropicraftTab);
    return block;
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + name);
    e.printStackTrace();
  }
  return null;
}",0.9933906146728354
109832,"public HashMap<Integer,Block> genBlockIDSchemToBlockWithRegistry(NBTTagCompound parMappingNBT){
  HashMap<String,Block> swapMap=new HashMap<String,Block>();
  HashMap<Integer,Block> finalMap=new HashMap<Integer,Block>();
  try {
    Set set=Block.blockRegistry.getKeys();
    Iterator it=set.iterator();
    while (it.hasNext()) {
      String tagName=(String)it.next();
      Block block=(Block)Block.blockRegistry.getObject(tagName);
      if (block != null) {
        if (!block.getUnlocalizedName().equals(""String_Node_Str"")) {
          swapMap.put(CoroUtilBlock.getNameByBlock(block),block);
        }
      }
    }
    it=parMappingNBT.getKeySet().iterator();
    while (it.hasNext()) {
      String tagName=(String)it.next();
      int tag=parMappingNBT.getInteger(tagName);
      if (swapMap.get(tagName) != null) {
        finalMap.put(tag,swapMap.get(tagName));
      }
 else {
        System.out.println(""String_Node_Str"" + tag);
      }
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  return finalMap;
}","public HashMap<Integer,Block> genBlockIDSchemToBlockWithRegistry(NBTTagCompound parMappingNBT){
  HashMap<String,Block> swapMap=new HashMap<String,Block>();
  HashMap<Integer,Block> finalMap=new HashMap<Integer,Block>();
  try {
    Set set=Block.REGISTRY.getKeys();
    Iterator it=set.iterator();
    while (it.hasNext()) {
      ResourceLocation tagName=(ResourceLocation)it.next();
      Block block=Block.REGISTRY.getObject(tagName);
      if (block != null) {
        if (!block.getUnlocalizedName().equals(""String_Node_Str"")) {
          swapMap.put(tagName.toString(),block);
        }
      }
    }
    it=parMappingNBT.getKeySet().iterator();
    while (it.hasNext()) {
      String tagName=(String)it.next();
      int tag=parMappingNBT.getInteger(tagName);
      if (swapMap.get(tagName) != null) {
        finalMap.put(tag,swapMap.get(tagName));
      }
 else {
        System.out.println(""String_Node_Str"" + tag);
      }
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  return finalMap;
}",0.8221574344023324
109833,"public void scanLevelToData(World worldObj){
  resetData();
  for (int xx=0; xx < map_sizeX; xx++) {
    for (int yy=0; yy < map_sizeY; yy++) {
      for (int zz=0; zz < map_sizeZ; zz++) {
        int index=yy * map_sizeX * map_sizeZ + zz * map_sizeX + xx;
        World worldRef=worldObj;
        build_blockIDArr[xx][yy][zz]=worldRef.getBlock(map_coord_minX + xx,map_coord_minY + yy,map_coord_minZ + zz);
        build_blockMetaArr[xx][yy][zz]=worldRef.getBlockMetadata(map_coord_minX + xx,map_coord_minY + yy,map_coord_minZ + zz);
      }
    }
  }
}","public void scanLevelToData(World worldObj){
  resetData();
  for (int xx=0; xx < map_sizeX; xx++) {
    for (int yy=0; yy < map_sizeY; yy++) {
      for (int zz=0; zz < map_sizeZ; zz++) {
        int index=yy * map_sizeX * map_sizeZ + zz * map_sizeX + xx;
        World worldRef=worldObj;
        IBlockState state=worldRef.getBlockState(new BlockPos(map_coord_minX + xx,map_coord_minY + yy,map_coord_minZ + zz));
        build_blockIDArr[xx][yy][zz]=state.getBlock();
        build_blockMetaArr[xx][yy][zz]=state.getBlock().getMetaFromState(state);
      }
    }
  }
}",0.7373107747105966
109834,"public Block getConvertInternalIDToBlock(int internalID){
  Block block=null;
  if (!getVersion().equals(""String_Node_Str"") || internalID > blockIDHighestVanilla) {
    if (blockMappingInternalIDToBlock.containsKey(internalID)) {
      block=blockMappingInternalIDToBlock.get(internalID);
      if (block == null) {
        System.out.println(""String_Node_Str"" + internalID);
      }
    }
 else {
      System.out.println(""String_Node_Str"" + internalID);
    }
  }
 else {
    block=(Block)Block.blockRegistry.getObjectById(internalID);
    if (block == null) {
      System.out.println(""String_Node_Str"" + internalID);
    }
  }
  return block;
}","public Block getConvertInternalIDToBlock(int internalID){
  Block block=null;
  if (!getVersion().equals(""String_Node_Str"") || internalID > blockIDHighestVanilla) {
    if (blockMappingInternalIDToBlock.containsKey(internalID)) {
      block=blockMappingInternalIDToBlock.get(internalID);
      if (block == null) {
        System.out.println(""String_Node_Str"" + internalID);
      }
    }
 else {
      System.out.println(""String_Node_Str"" + internalID);
    }
  }
 else {
    block=Block.REGISTRY.getObjectById(internalID);
    if (block == null) {
      System.out.println(""String_Node_Str"" + internalID);
    }
  }
  return block;
}",0.9781931464174456
109835,"public void writeNBT(){
  HashMap<Block,Integer> mapBlockToInternalID=getBlockToInternalIDMap();
  try {
    if (levelData == null) {
      System.out.println(""String_Node_Str"");
      levelData=new NBTTagCompound();
    }
    int metadataInt[]=new int[map_sizeX * map_sizeY * map_sizeZ];
    int blockidsInt[]=new int[map_sizeX * map_sizeY * map_sizeZ];
    byte metadataByte[]=new byte[map_sizeX * map_sizeY * map_sizeZ];
    byte blockidsByte[]=new byte[map_sizeX * map_sizeY * map_sizeZ];
    NBTTagList var16=new NBTTagList();
    for (int xx=0; xx < map_sizeX; xx++) {
      for (int yy=0; yy < map_sizeY; yy++) {
        for (int zz=0; zz < map_sizeZ; zz++) {
          int index=yy * map_sizeX * map_sizeZ + zz * map_sizeX + xx;
          if (newFormat) {
            Integer tryID=mapBlockToInternalID.get(build_blockIDArr[xx][yy][zz]);
            if (tryID == null) {
              System.out.println(""String_Node_Str"" + build_blockIDArr[xx][yy][zz]);
            }
 else {
              int internalID=Integer.valueOf(tryID);
              blockidsInt[index]=internalID;
            }
            metadataInt[index]=build_blockMetaArr[xx][yy][zz];
          }
 else {
            System.out.println(""String_Node_Str"");
          }
          World worldRef=DimensionManager.getWorld(dim);
          TileEntity tEnt=worldRef.getTileEntity(map_coord_minX + xx,map_coord_minY + yy,map_coord_minZ + zz);
          if (tEnt != null) {
            NBTTagCompound var10=new NBTTagCompound();
            if (tEnt instanceof SchematicData) {
              ((SchematicData)tEnt).writeToNBT(var10,this);
            }
 else {
              tEnt.writeToNBT(var10);
            }
            var10.setBoolean(""String_Node_Str"",true);
            var10.setInteger(""String_Node_Str"",xx);
            var10.setInteger(""String_Node_Str"",yy);
            var10.setInteger(""String_Node_Str"",zz);
            var16.appendTag(var10);
          }
        }
      }
    }
    levelData.setTag(""String_Node_Str"",var16);
    if (newFormat) {
      levelData.setIntArray(""String_Node_Str"",blockidsInt);
      levelData.setIntArray(""String_Node_Str"",metadataInt);
    }
 else {
      levelData.setByteArray(""String_Node_Str"",blockidsByte);
      levelData.setByteArray(""String_Node_Str"",metadataByte);
    }
    levelData.setBoolean(""String_Node_Str"",newFormat);
    levelData.setString(""String_Node_Str"",getSaveVersion());
    levelData.setTag(""String_Node_Str"",genBlockIDToNameMap());
    levelData.setShort(""String_Node_Str"",(short)map_sizeX);
    levelData.setShort(""String_Node_Str"",(short)map_sizeY);
    levelData.setShort(""String_Node_Str"",(short)map_sizeZ);
    levelData.setShort(""String_Node_Str"",(short)map_surfaceOffset);
    saveLevelData(file);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","public void writeNBT(){
  HashMap<Block,Integer> mapBlockToInternalID=getBlockToInternalIDMap();
  try {
    if (levelData == null) {
      System.out.println(""String_Node_Str"");
      levelData=new NBTTagCompound();
    }
    int metadataInt[]=new int[map_sizeX * map_sizeY * map_sizeZ];
    int blockidsInt[]=new int[map_sizeX * map_sizeY * map_sizeZ];
    byte metadataByte[]=new byte[map_sizeX * map_sizeY * map_sizeZ];
    byte blockidsByte[]=new byte[map_sizeX * map_sizeY * map_sizeZ];
    NBTTagList var16=new NBTTagList();
    for (int xx=0; xx < map_sizeX; xx++) {
      for (int yy=0; yy < map_sizeY; yy++) {
        for (int zz=0; zz < map_sizeZ; zz++) {
          int index=yy * map_sizeX * map_sizeZ + zz * map_sizeX + xx;
          if (newFormat) {
            Integer tryID=mapBlockToInternalID.get(build_blockIDArr[xx][yy][zz]);
            if (tryID == null) {
              System.out.println(""String_Node_Str"" + build_blockIDArr[xx][yy][zz]);
            }
 else {
              int internalID=Integer.valueOf(tryID);
              blockidsInt[index]=internalID;
            }
            metadataInt[index]=build_blockMetaArr[xx][yy][zz];
          }
 else {
            System.out.println(""String_Node_Str"");
          }
          World worldRef=DimensionManager.getWorld(dim);
          TileEntity tEnt=worldRef.getTileEntity(new BlockPos(map_coord_minX + xx,map_coord_minY + yy,map_coord_minZ + zz));
          if (tEnt != null) {
            NBTTagCompound var10=new NBTTagCompound();
            if (tEnt instanceof SchematicData) {
              ((SchematicData)tEnt).writeToNBT(var10,this);
            }
 else {
              tEnt.writeToNBT(var10);
            }
            var10.setBoolean(""String_Node_Str"",true);
            var10.setInteger(""String_Node_Str"",xx);
            var10.setInteger(""String_Node_Str"",yy);
            var10.setInteger(""String_Node_Str"",zz);
            var16.appendTag(var10);
          }
        }
      }
    }
    levelData.setTag(""String_Node_Str"",var16);
    if (newFormat) {
      levelData.setIntArray(""String_Node_Str"",blockidsInt);
      levelData.setIntArray(""String_Node_Str"",metadataInt);
    }
 else {
      levelData.setByteArray(""String_Node_Str"",blockidsByte);
      levelData.setByteArray(""String_Node_Str"",metadataByte);
    }
    levelData.setBoolean(""String_Node_Str"",newFormat);
    levelData.setString(""String_Node_Str"",getSaveVersion());
    levelData.setTag(""String_Node_Str"",genBlockIDToNameMap());
    levelData.setShort(""String_Node_Str"",(short)map_sizeX);
    levelData.setShort(""String_Node_Str"",(short)map_sizeY);
    levelData.setShort(""String_Node_Str"",(short)map_sizeZ);
    levelData.setShort(""String_Node_Str"",(short)map_surfaceOffset);
    saveLevelData(file);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}",0.9975115535015996
109836,"public HashMap<Integer,Block> genBlockIDSchemToBlockWithUnlocalizedName(NBTTagCompound parMappingNBT){
  HashMap<String,Block> swapMap=new HashMap<String,Block>();
  HashMap<Integer,Block> finalMap=new HashMap<Integer,Block>();
  try {
    Set set=Block.blockRegistry.getKeys();
    Iterator it=set.iterator();
    while (it.hasNext()) {
      String tagName=(String)it.next();
      Block block=(Block)Block.blockRegistry.getObject(tagName);
      if (block != null) {
        if (!block.getUnlocalizedName().equals(""String_Node_Str"")) {
          swapMap.put(block.getUnlocalizedName(),block);
        }
      }
    }
    it=parMappingNBT.getKeySet().iterator();
    while (it.hasNext()) {
      String tagName=(String)it.next();
      int tag=parMappingNBT.getInteger(tagName);
      if (swapMap.get(tagName) == null && !tagName.contains(""String_Node_Str"")) {
        tagName=tagName.replace(""String_Node_Str"",""String_Node_Str"");
      }
      if (swapMap.get(tagName) != null) {
        finalMap.put(tag,swapMap.get(tagName));
      }
 else {
        System.out.println(""String_Node_Str"" + tag + ""String_Node_Str""+ tagName);
      }
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  return finalMap;
}","public HashMap<Integer,Block> genBlockIDSchemToBlockWithUnlocalizedName(NBTTagCompound parMappingNBT){
  HashMap<String,Block> swapMap=new HashMap<String,Block>();
  HashMap<Integer,Block> finalMap=new HashMap<Integer,Block>();
  try {
    Set set=Block.REGISTRY.getKeys();
    Iterator it=set.iterator();
    while (it.hasNext()) {
      ResourceLocation tagName=(ResourceLocation)it.next();
      Block block=Block.REGISTRY.getObject(tagName);
      if (block != null) {
        if (!block.getUnlocalizedName().equals(""String_Node_Str"")) {
          swapMap.put(block.getUnlocalizedName(),block);
        }
      }
    }
    it=parMappingNBT.getKeySet().iterator();
    while (it.hasNext()) {
      String tagName=(String)it.next();
      int tag=parMappingNBT.getInteger(tagName);
      if (swapMap.get(tagName) == null && !tagName.contains(""String_Node_Str"")) {
        tagName=tagName.replace(""String_Node_Str"",""String_Node_Str"");
      }
      if (swapMap.get(tagName) != null) {
        finalMap.put(tag,swapMap.get(tagName));
      }
 else {
        System.out.println(""String_Node_Str"" + tag + ""String_Node_Str""+ tagName);
      }
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  return finalMap;
}",0.9505920783993468
109837,"public HashMap<Block,Integer> getBlockToInternalIDMap(){
  HashMap<Block,Integer> map=new HashMap<Block,Integer>();
  Set set=Block.blockRegistry.getKeys();
  Iterator it=set.iterator();
  int i=0;
  while (it.hasNext()) {
    String tagName=(String)it.next();
    Block block=(Block)Block.blockRegistry.getObject(tagName);
    if (block != null) {
      if (!block.getUnlocalizedName().equals(""String_Node_Str"")) {
        map.put(block,i);
        i++;
      }
    }
  }
  return map;
}","public HashMap<Block,Integer> getBlockToInternalIDMap(){
  HashMap<Block,Integer> map=new HashMap<Block,Integer>();
  Set set=Block.REGISTRY.getKeys();
  Iterator it=set.iterator();
  int i=0;
  while (it.hasNext()) {
    ResourceLocation tagName=(ResourceLocation)it.next();
    Block block=Block.REGISTRY.getObject(tagName);
    if (block != null) {
      if (!block.getUnlocalizedName().equals(""String_Node_Str"")) {
        map.put(block,i);
        i++;
      }
    }
  }
  return map;
}",0.8171603677221655
109838,"public NBTTagCompound genBlockIDToNameMap(){
  NBTTagCompound nbt=new NBTTagCompound();
  Set set=Block.blockRegistry.getKeys();
  Iterator it=set.iterator();
  int i=0;
  while (it.hasNext()) {
    String tagName=(String)it.next();
    Block block=(Block)Block.blockRegistry.getObject(tagName);
    if (block != null) {
      if (!block.getUnlocalizedName().equals(""String_Node_Str"")) {
        nbt.setInteger(CoroUtilBlock.getNameByBlock(block),i);
        i++;
      }
    }
  }
  return nbt;
}","public NBTTagCompound genBlockIDToNameMap(){
  NBTTagCompound nbt=new NBTTagCompound();
  Set set=Block.REGISTRY.getKeys();
  Iterator it=set.iterator();
  int i=0;
  while (it.hasNext()) {
    ResourceLocation tagName=(ResourceLocation)it.next();
    Block block=Block.REGISTRY.getObject(tagName);
    if (block != null) {
      if (!block.getUnlocalizedName().equals(""String_Node_Str"")) {
        nbt.setInteger(tagName.toString(),i);
        i++;
      }
    }
  }
  return nbt;
}",0.8204081632653061
109839,"public static void rotateSet(BuildJob parBuildJob,BlockPos coords,Block id,int meta){
  coords=rotate(coords,parBuildJob.direction,new Vec3d(parBuildJob.build_startX,parBuildJob.build_startY,parBuildJob.build_startZ),new Vec3d(parBuildJob.build.map_sizeX,parBuildJob.build.map_sizeY,parBuildJob.build.map_sizeZ));
  World world=DimensionManager.getWorld(parBuildJob.build.dim);
  if (world != null) {
    world.setBlock(coords.getX(),coords.getY(),coords.getZ(),id,meta,2);
  }
}","public static void rotateSet(BuildJob parBuildJob,BlockPos coords,Block id,int meta){
  coords=rotate(coords,parBuildJob.direction,new Vec3d(parBuildJob.build_startX,parBuildJob.build_startY,parBuildJob.build_startZ),new Vec3d(parBuildJob.build.map_sizeX,parBuildJob.build.map_sizeY,parBuildJob.build.map_sizeZ));
  World world=DimensionManager.getWorld(parBuildJob.build.dim);
  if (world != null) {
    world.setBlockState(coords,id.getDefaultState(),2);
  }
}",0.9202975557917108
109840,"public void updateBuildProgress(BuildJob buildJob){
  Build build=buildJob.build;
  buildJob.build_currentTick++;
  World worldRef=FMLCommonHandler.instance().getMinecraftServerInstance().worldServerForDimension(buildJob.build.dim);
  if (buildJob.timeout > 0) {
    buildJob.timeout--;
    Build b=buildJob.build;
    worldRef.markBlockRangeForRenderUpdate(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ,buildJob.build_startX + b.map_sizeX,buildJob.build_startY + b.map_sizeY,buildJob.build_startZ + b.map_sizeZ);
    return;
  }
  build_rate=100000;
  build_rate=25000;
  build_rate=1000;
  build_rate=buildJob.build_rate;
  boolean replaceAir=!buildJob.useFirstPass;
  if (buildJob.neverPlaceAir)   replaceAir=false;
  int loopCount;
  Block id=null;
  buildJob.curLayerCountMax=build.map_sizeX * build.map_sizeZ;
  buildJob.doRandomBuild=false;
  try {
    if (buildJob.doRandomBuild) {
      if (worldRef.rand.nextInt(build_rand) != 0)       return;
      boolean first=true;
      int tryCount=0;
      while ((first || CoroUtilBlock.isAir(id)) && tryCount < 300) {
        tryCount++;
        first=false;
        buildJob.build_loopTickX=worldRef.rand.nextInt(build.map_sizeX);
        buildJob.build_loopTickZ=worldRef.rand.nextInt(build.map_sizeZ);
        if (((float)buildJob.curLayerCount / (float)buildJob.curLayerCountMax) > 0.9F) {
          buildJob.doRandomBuild=false;
          buildJob.build_loopTickX=0;
          buildJob.build_loopTickZ=0;
          return;
        }
        if (!buildJob.build_blockPlaced[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ]) {
          id=build.build_blockIDArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
          int xx=buildJob.build_startX + buildJob.build_loopTickX;
          int yy=buildJob.build_startY + buildJob.build_loopTickY;
          int zz=buildJob.build_startZ + buildJob.build_loopTickZ;
          worldRef.setBlock(xx,yy,zz,id,build.build_blockMetaArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ],buildJob.notifyFlag);
          buildJob.build_blockPlaced[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ]=true;
          buildJob.curLayerCount++;
        }
      }
    }
 else {
      for (loopCount=0; loopCount < build_rate; loopCount++) {
        if (buildJob.build_loopTickX >= build.map_sizeX) {
          buildJob.build_loopTickX=0;
          buildJob.build_loopTickZ++;
        }
        if (buildJob.build_loopTickZ >= build.map_sizeZ) {
          buildJob.build_loopTickZ=0;
          buildJob.build_loopTickY++;
          buildJob.curLayerCount=0;
        }
        if (buildJob.build_loopTickY >= build.map_sizeY) {
          if (buildJob.pass == 2) {
            buildComplete(buildJob);
            buildJob.buildComplete();
            if (buildJob.customGenCallback != null)             buildJob.customGenCallback.genPassPre(worldRef,buildJob,-1);
          }
 else {
            buildJob.pass++;
            buildJob.build_loopTickX=0;
            buildJob.build_loopTickZ=0;
            buildJob.build_loopTickY=0;
            buildJob.timeout=5;
            if (buildJob.customGenCallback != null)             buildJob.customGenCallback.genPassPre(worldRef,buildJob,buildJob.pass);
            if (buildJob.pass == 1) {
            }
          }
          return;
        }
        buildJob.curTick++;
        if (buildJob.pass == 0) {
          int xx=buildJob.build_startX + buildJob.build_loopTickX;
          int yy=buildJob.build_startY + buildJob.build_loopTickY;
          int zz=buildJob.build_startZ + buildJob.build_loopTickZ;
          id=build.build_blockIDArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
          boolean skipGen=false;
          BlockPos coords=new BlockPos(xx,yy,zz);
          if (buildJob.useRotationBuild) {
            if (buildJob.build.backwardsCompatibleOldRotate) {
              coords=rotate(coords,buildJob.direction,new Vec3d(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ),new Vec3d(build.map_sizeX,build.map_sizeY,build.map_sizeZ));
            }
 else {
              coords=rotateNew(coords,buildJob.direction,new Vec3d(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ),new Vec3d(build.map_sizeX,build.map_sizeY,build.map_sizeZ));
            }
          }
 else {
            if (buildJob.centerBuildIfNoRotate) {
              coords.add(-MathHelper.floor(build.map_sizeX / 2D),0,-MathHelper.floor(build.map_sizeZ / 2D));
            }
          }
          if (buildJob.blockIDsNoBuildOver.size() > 0) {
            Block checkCoord=worldRef.getBlock(coords.getX(),coords.getY(),coords.getZ());
            if (buildJob.blockIDsNoBuildOver.contains(checkCoord)) {
              skipGen=true;
            }
          }
          if (!skipGen) {
            worldRef.setBlock(coords.getX(),coords.getY(),coords.getZ(),Blocks.AIR,0,buildJob.notifyFlag);
          }
        }
 else {
          if (!buildJob.build_blockPlaced[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ]) {
            id=build.build_blockIDArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
            int meta=build.build_blockMetaArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
            int xx=buildJob.build_startX + buildJob.build_loopTickX;
            int yy=buildJob.build_startY + buildJob.build_loopTickY;
            int zz=buildJob.build_startZ + buildJob.build_loopTickZ;
            boolean skip=false;
            if (buildJob.pass == 1 && buildJob.blockIDsSkipFirstPass.contains(id)) {
              skip=true;
            }
            if (!skip && ((replaceAir || !CoroUtilBlock.isAir(id)))) {
              BlockPos coords=new BlockPos(xx,yy,zz);
              if (buildJob.useRotationBuild) {
                if (buildJob.build.backwardsCompatibleOldRotate) {
                  coords=rotate(coords,buildJob.direction,new Vec3d(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ),new Vec3d(build.map_sizeX,build.map_sizeY,build.map_sizeZ));
                }
 else {
                  coords=rotateNew(coords,buildJob.direction,new Vec3d(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ),new Vec3d(build.map_sizeX,build.map_sizeY,build.map_sizeZ));
                }
                int tryMeta=rotateMeta(worldRef,coords,buildJob.rotation,id,meta);
                if (tryMeta != -1)                 meta=tryMeta;
              }
 else {
                if (buildJob.centerBuildIfNoRotate) {
                  coords.add(-MathHelper.floor(build.map_sizeX / 2D),0,-MathHelper.floor(build.map_sizeZ / 2D));
                }
              }
              if (id != null || CoroUtilBlock.isAir(id)) {
                boolean skipGen=false;
                if (buildJob.blockIDsNoBuildOver.size() > 0) {
                  Block checkCoord=worldRef.getBlock(coords.getX(),coords.getY(),coords.getZ());
                  if (buildJob.blockIDsNoBuildOver.contains(checkCoord)) {
                    skipGen=true;
                  }
                }
                if (!skipGen) {
                  worldRef.setBlock(coords.getX(),coords.getY(),coords.getZ(),id,meta,2);
                }
              }
 else {
                System.out.println(""String_Node_Str"" + id + ""String_Node_Str""+ placeholderID);
                boolean skipGen=false;
                if (buildJob.blockIDsNoBuildOver.size() > 0) {
                  Block checkCoord=worldRef.getBlock(coords.getX(),coords.getY(),coords.getZ());
                  if (buildJob.blockIDsNoBuildOver.contains(checkCoord)) {
                    skipGen=true;
                  }
                }
                if (!skipGen) {
                  worldRef.setBlock(coords.getX(),coords.getY(),coords.getZ(),placeholderID,0,buildJob.notifyFlag);
                }
              }
              buildJob.build_blockPlaced[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ]=true;
              buildJob.curLayerCount++;
            }
 else {
              loopCount--;
            }
          }
        }
        buildJob.build_loopTickX++;
      }
    }
  }
 catch (  Exception ex) {
    buildJob.build_active=false;
    ex.printStackTrace();
  }
}","public void updateBuildProgress(BuildJob buildJob){
  Build build=buildJob.build;
  buildJob.build_currentTick++;
  World worldRef=FMLCommonHandler.instance().getMinecraftServerInstance().worldServerForDimension(buildJob.build.dim);
  if (buildJob.timeout > 0) {
    buildJob.timeout--;
    Build b=buildJob.build;
    worldRef.markBlockRangeForRenderUpdate(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ,buildJob.build_startX + b.map_sizeX,buildJob.build_startY + b.map_sizeY,buildJob.build_startZ + b.map_sizeZ);
    return;
  }
  build_rate=100000;
  build_rate=25000;
  build_rate=1000;
  build_rate=buildJob.build_rate;
  boolean replaceAir=!buildJob.useFirstPass;
  if (buildJob.neverPlaceAir)   replaceAir=false;
  int loopCount;
  Block id=null;
  buildJob.curLayerCountMax=build.map_sizeX * build.map_sizeZ;
  buildJob.doRandomBuild=false;
  try {
    if (buildJob.doRandomBuild) {
      if (worldRef.rand.nextInt(build_rand) != 0)       return;
      boolean first=true;
      int tryCount=0;
      while ((first || isAir(id)) && tryCount < 300) {
        tryCount++;
        first=false;
        buildJob.build_loopTickX=worldRef.rand.nextInt(build.map_sizeX);
        buildJob.build_loopTickZ=worldRef.rand.nextInt(build.map_sizeZ);
        if (((float)buildJob.curLayerCount / (float)buildJob.curLayerCountMax) > 0.9F) {
          buildJob.doRandomBuild=false;
          buildJob.build_loopTickX=0;
          buildJob.build_loopTickZ=0;
          return;
        }
        if (!buildJob.build_blockPlaced[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ]) {
          id=build.build_blockIDArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
          int xx=buildJob.build_startX + buildJob.build_loopTickX;
          int yy=buildJob.build_startY + buildJob.build_loopTickY;
          int zz=buildJob.build_startZ + buildJob.build_loopTickZ;
          int meta=build.build_blockMetaArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
          IBlockState state=id.getStateFromMeta(meta);
          worldRef.setBlockState(new BlockPos(xx,yy,zz),state,buildJob.notifyFlag);
          buildJob.build_blockPlaced[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ]=true;
          buildJob.curLayerCount++;
        }
      }
    }
 else {
      for (loopCount=0; loopCount < build_rate; loopCount++) {
        if (buildJob.build_loopTickX >= build.map_sizeX) {
          buildJob.build_loopTickX=0;
          buildJob.build_loopTickZ++;
        }
        if (buildJob.build_loopTickZ >= build.map_sizeZ) {
          buildJob.build_loopTickZ=0;
          buildJob.build_loopTickY++;
          buildJob.curLayerCount=0;
        }
        if (buildJob.build_loopTickY >= build.map_sizeY) {
          if (buildJob.pass == 2) {
            buildComplete(buildJob);
            buildJob.buildComplete();
            if (buildJob.customGenCallback != null)             buildJob.customGenCallback.genPassPre(worldRef,buildJob,-1);
          }
 else {
            buildJob.pass++;
            buildJob.build_loopTickX=0;
            buildJob.build_loopTickZ=0;
            buildJob.build_loopTickY=0;
            buildJob.timeout=5;
            if (buildJob.customGenCallback != null)             buildJob.customGenCallback.genPassPre(worldRef,buildJob,buildJob.pass);
            if (buildJob.pass == 1) {
            }
          }
          return;
        }
        buildJob.curTick++;
        if (buildJob.pass == 0) {
          int xx=buildJob.build_startX + buildJob.build_loopTickX;
          int yy=buildJob.build_startY + buildJob.build_loopTickY;
          int zz=buildJob.build_startZ + buildJob.build_loopTickZ;
          id=build.build_blockIDArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
          boolean skipGen=false;
          BlockPos coords=new BlockPos(xx,yy,zz);
          if (buildJob.useRotationBuild) {
            if (buildJob.build.backwardsCompatibleOldRotate) {
              coords=rotate(coords,buildJob.direction,new Vec3d(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ),new Vec3d(build.map_sizeX,build.map_sizeY,build.map_sizeZ));
            }
 else {
              coords=rotateNew(coords,buildJob.direction,new Vec3d(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ),new Vec3d(build.map_sizeX,build.map_sizeY,build.map_sizeZ));
            }
          }
 else {
            if (buildJob.centerBuildIfNoRotate) {
              coords.add(-MathHelper.floor(build.map_sizeX / 2D),0,-MathHelper.floor(build.map_sizeZ / 2D));
            }
          }
          if (buildJob.blockIDsNoBuildOver.size() > 0) {
            Block checkCoord=worldRef.getBlockState(coords).getBlock();
            if (buildJob.blockIDsNoBuildOver.contains(checkCoord)) {
              skipGen=true;
            }
          }
          if (!skipGen) {
            worldRef.setBlockState(coords,Blocks.AIR.getDefaultState(),buildJob.notifyFlag);
          }
        }
 else {
          if (!buildJob.build_blockPlaced[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ]) {
            id=build.build_blockIDArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
            int meta=build.build_blockMetaArr[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ];
            int xx=buildJob.build_startX + buildJob.build_loopTickX;
            int yy=buildJob.build_startY + buildJob.build_loopTickY;
            int zz=buildJob.build_startZ + buildJob.build_loopTickZ;
            boolean skip=false;
            if (buildJob.pass == 1 && buildJob.blockIDsSkipFirstPass.contains(id)) {
              skip=true;
            }
            if (!skip && ((replaceAir || !isAir(id)))) {
              BlockPos coords=new BlockPos(xx,yy,zz);
              if (buildJob.useRotationBuild) {
                if (buildJob.build.backwardsCompatibleOldRotate) {
                  coords=rotate(coords,buildJob.direction,new Vec3d(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ),new Vec3d(build.map_sizeX,build.map_sizeY,build.map_sizeZ));
                }
 else {
                  coords=rotateNew(coords,buildJob.direction,new Vec3d(buildJob.build_startX,buildJob.build_startY,buildJob.build_startZ),new Vec3d(build.map_sizeX,build.map_sizeY,build.map_sizeZ));
                }
                int tryMeta=rotateMeta(worldRef,coords,buildJob.rotation,id,meta);
                if (tryMeta != -1)                 meta=tryMeta;
              }
 else {
                if (buildJob.centerBuildIfNoRotate) {
                  coords.add(-MathHelper.floor(build.map_sizeX / 2D),0,-MathHelper.floor(build.map_sizeZ / 2D));
                }
              }
              if (id != null || isAir(id)) {
                boolean skipGen=false;
                if (buildJob.blockIDsNoBuildOver.size() > 0) {
                  Block checkCoord=worldRef.getBlockState(coords).getBlock();
                  if (buildJob.blockIDsNoBuildOver.contains(checkCoord)) {
                    skipGen=true;
                  }
                }
                if (!skipGen) {
                  IBlockState state=id.getStateFromMeta(meta);
                  worldRef.setBlockState(coords,state,2);
                }
              }
 else {
                System.out.println(""String_Node_Str"" + id + ""String_Node_Str""+ placeholderID);
                boolean skipGen=false;
                if (buildJob.blockIDsNoBuildOver.size() > 0) {
                  Block checkCoord=worldRef.getBlockState(coords).getBlock();
                  if (buildJob.blockIDsNoBuildOver.contains(checkCoord)) {
                    skipGen=true;
                  }
                }
                if (!skipGen) {
                  worldRef.setBlockState(coords,placeholderID.getDefaultState(),buildJob.notifyFlag);
                }
              }
              buildJob.build_blockPlaced[buildJob.build_loopTickX][buildJob.build_loopTickY][buildJob.build_loopTickZ]=true;
              buildJob.curLayerCount++;
            }
 else {
              loopCount--;
            }
          }
        }
        buildJob.build_loopTickX++;
      }
    }
  }
 catch (  Exception ex) {
    buildJob.build_active=false;
    ex.printStackTrace();
  }
}",0.9526131161186752
109841,"public void spawnLevelEntities(BuildJob buildJob){
  Build build=buildJob.build;
  World worldRef=FMLCommonHandler.instance().getMinecraftServerInstance().worldServerForDimension(build.dim);
  List ents=worldRef.loadedEntityList;
  for (int i=0; i < ents.size(); i++) {
    Entity ent=(Entity)ents.get(i);
    if (ent instanceof EntityItem) {
      ent.setDead();
    }
  }
  if (build.entities != null) {
    for (int var17=0; var17 < build.entities.tagCount(); ++var17) {
      NBTTagCompound var16=(NBTTagCompound)build.entities.getCompoundTagAt(var17);
      Entity var18=EntityList.createEntityFromNBT(var16,worldRef);
    }
  }
  if (build.tileEntities != null) {
    for (int var21=0; var21 < build.tileEntities.tagCount(); ++var21) {
      NBTTagCompound var20=(NBTTagCompound)build.tileEntities.getCompoundTagAt(var21);
      TileEntity var13=worldRef.getTileEntity(build.map_coord_minX + var20.getInteger(""String_Node_Str""),buildJob.build_startY + var20.getInteger(""String_Node_Str""),build.map_coord_minZ + var20.getInteger(""String_Node_Str""));
      if (var13 instanceof SchematicData) {
        ((SchematicData)var13).readFromNBT(var20,build);
      }
 else       if (var13 != null) {
        var13.readFromNBT(var20);
      }
      if (buildJob.customGenCallback != null) {
        NBTTagCompound nbt=buildJob.customGenCallback.getInitNBTTileEntity();
        if (nbt != null) {
          if (var13 instanceof ITileEntityCustomGenData) {
            ((ITileEntityCustomGenData)var13).initWithNBT(nbt);
          }
        }
      }
      if (var13 != null) {
        var13.xCoord=build.map_coord_minX + var13.xCoord;
        var13.yCoord=buildJob.build_startY + var13.yCoord;
        var13.zCoord=build.map_coord_minZ + var13.zCoord;
        try {
          Packet packet=var13.getDescriptionPacket();
          if (packet != null) {
            MinecraftServer.getServer().getConfigurationManager().sendPacketToAllPlayers(packet);
          }
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
  }
}","public void spawnLevelEntities(BuildJob buildJob){
  Build build=buildJob.build;
  World worldRef=FMLCommonHandler.instance().getMinecraftServerInstance().worldServerForDimension(build.dim);
  List ents=worldRef.loadedEntityList;
  for (int i=0; i < ents.size(); i++) {
    Entity ent=(Entity)ents.get(i);
    if (ent instanceof EntityItem) {
      ent.setDead();
    }
  }
  if (build.entities != null) {
    for (int var17=0; var17 < build.entities.tagCount(); ++var17) {
      NBTTagCompound var16=(NBTTagCompound)build.entities.getCompoundTagAt(var17);
      Entity var18=EntityList.createEntityFromNBT(var16,worldRef);
    }
  }
  if (build.tileEntities != null) {
    for (int var21=0; var21 < build.tileEntities.tagCount(); ++var21) {
      NBTTagCompound var20=(NBTTagCompound)build.tileEntities.getCompoundTagAt(var21);
      TileEntity var13=worldRef.getTileEntity(new BlockPos(build.map_coord_minX + var20.getInteger(""String_Node_Str""),buildJob.build_startY + var20.getInteger(""String_Node_Str""),build.map_coord_minZ + var20.getInteger(""String_Node_Str"")));
      if (var13 instanceof SchematicData) {
        ((SchematicData)var13).readFromNBT(var20,build);
      }
 else       if (var13 != null) {
        var13.readFromNBT(var20);
      }
      if (buildJob.customGenCallback != null) {
        NBTTagCompound nbt=buildJob.customGenCallback.getInitNBTTileEntity();
        if (nbt != null) {
          if (var13 instanceof ITileEntityCustomGenData) {
            ((ITileEntityCustomGenData)var13).initWithNBT(nbt);
          }
        }
      }
      if (var13 != null) {
        var13.setPos(new BlockPos(build.map_coord_minX + var13.getPos().getX(),buildJob.build_startY + var13.getPos().getY(),build.map_coord_minZ + var13.getPos().getZ()));
        try {
          Packet packet=var13.getUpdatePacket();
          if (packet != null) {
            FMLCommonHandler.instance().getMinecraftServerInstance().getPlayerList().sendPacketToAllPlayers(packet);
          }
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
  }
}",0.9271587071876508
109842,"public void renderScubaGear(Entity entityIn,float limbSwing,float limbSwingAmount,float ageInTicks,float netHeadYaw,float headPitch,float scale,boolean renderHead){
  hose4.rotateAngleX=0.3075211F;
  if (!(entityIn instanceof EntityPlayer))   return;
  EntityPlayer player=(EntityPlayer)entityIn;
  boolean showHead=player.getItemStackFromSlot(EntityEquipmentSlot.HEAD) != null;
  bipedHead.showModel=showHead;
  if (showHead) {
    hose6.rotateAngleX=0F;
    hose6.rotateAngleY=0F;
    hose6.rotateAngleZ=0F;
    hose6.renderWithRotation(scale);
  }
  boolean showChest=player.getItemStackFromSlot(EntityEquipmentSlot.CHEST) != null;
  bipedBody.showModel=showChest;
  if (showChest) {
    renderTank(entityIn,limbSwing,limbSwingAmount,ageInTicks,netHeadYaw,headPitch,scale);
    renderBCD(entityIn,limbSwing,limbSwingAmount,ageInTicks,netHeadYaw,headPitch,scale);
  }
  boolean showLegs=player.getItemStackFromSlot(EntityEquipmentSlot.FEET) != null;
  bipedRightLeg.showModel=showLegs;
  bipedLeftLeg.showModel=showLegs;
  if (renderHead) {
    bipedHead.render(scale);
  }
  bipedBody.render(scale);
  bipedRightArm.render(scale);
  bipedLeftArm.render(scale);
  bipedRightLeg.render(scale);
  bipedLeftLeg.render(scale);
}","public void renderScubaGear(Entity entityIn,float limbSwing,float limbSwingAmount,float ageInTicks,float netHeadYaw,float headPitch,float scale,boolean renderHead){
  hose4.rotateAngleX=0.3075211F;
  if (!(entityIn instanceof EntityPlayer))   return;
  EntityPlayer player=(EntityPlayer)entityIn;
  boolean showHead=player.getItemStackFromSlot(EntityEquipmentSlot.HEAD) != null && this.slot == EntityEquipmentSlot.HEAD;
  bipedHead.showModel=showHead;
  if (showHead) {
    hose6.rotateAngleX=0F;
    hose6.rotateAngleY=0F;
    hose6.rotateAngleZ=0F;
    hose6.renderWithRotation(scale);
  }
  boolean showChest=player.getItemStackFromSlot(EntityEquipmentSlot.CHEST) != null && this.slot == EntityEquipmentSlot.CHEST;
  bipedBody.showModel=showChest;
  if (showChest) {
    renderTank(entityIn,limbSwing,limbSwingAmount,ageInTicks,netHeadYaw,headPitch,scale);
    renderBCD(entityIn,limbSwing,limbSwingAmount,ageInTicks,netHeadYaw,headPitch,scale);
  }
  boolean showLegs=player.getItemStackFromSlot(EntityEquipmentSlot.FEET) != null && this.slot == EntityEquipmentSlot.FEET;
  bipedRightLeg.showModel=showLegs;
  bipedLeftLeg.showModel=showLegs;
  if (renderHead) {
    bipedHead.render(scale);
  }
  bipedBody.render(scale);
  bipedRightArm.render(scale);
  bipedLeftArm.render(scale);
  bipedRightLeg.render(scale);
  bipedLeftLeg.render(scale);
}",0.9518633540372672
109843,"public ModelScubaGear(float par1){
  this.leftArmPose=ModelBiped.ArmPose.EMPTY;
  this.rightArmPose=ModelBiped.ArmPose.EMPTY;
  bipedBody=new ModelRenderer(this,32,16);
  bipedBody.setTextureSize(128,64);
  bipedBody.addBox(-4F,-6F,-2F,8,12,4);
  bipedBody.setRotationPoint(0F,6F,0F);
  bipedRightArm=new ModelRenderer(this,56,16);
  bipedRightArm.setTextureSize(128,64);
  bipedRightArm.addBox(-4F,0F,-2F,4,12,4);
  bipedRightArm.setRotationPoint(-4F,0F,0F);
  bipedLeftArm=new ModelRenderer(this,72,16);
  bipedLeftArm.setTextureSize(128,64);
  bipedLeftArm.addBox(0F,0F,-2F,4,12,4);
  bipedLeftArm.setRotationPoint(4F,0F,0F);
  bipedRightLeg=new ModelRenderer(this,0,16);
  bipedRightLeg.setTextureSize(128,64);
  bipedRightLeg.addBox(-2F,-6F,-2F,4,12,4);
  bipedRightLeg.setRotationPoint(-2F,18F,0F);
  Fin1=new ModelRenderer(this,10,38);
  Fin1.setTextureSize(128,64);
  Fin1.addBox(-5F,22F,-2.5F,5,2,5);
  Fin1.setRotationPoint(2.5F,-12F,0F);
  Fin1.mirror=true;
  Fin1m1=new ModelRenderer(this,13,47);
  Fin1m1.setTextureSize(128,64);
  Fin1m1.addBox(-2.5F,-1.5F,-1F,5,1,2);
  Fin1m1.setRotationPoint(-3.19707F,24.5F,-3.288924F);
  setRotation(Fin1m1,0F,0F,0F);
  Fin1m1.mirror=true;
  Fin1m2=new ModelRenderer(this,15,45);
  Fin1m2.setTextureSize(128,64);
  Fin1m2.addBox(-2F,-1.5F,-0.5F,4,1,1);
  Fin1m2.setRotationPoint(-3.02606F,23.5F,-2.819078F);
  setRotation(Fin1m2,0F,0F,0F);
  Fin1m2.mirror=true;
  Fin1m3=new ModelRenderer(this,1,52);
  Fin1m3.setTextureSize(128,64);
  Fin1m3.addBox(-5F,-1F,-6F,10,0,12);
  Fin1m3.setRotationPoint(-5.420201F,24.5F,-9.396926F);
  setRotation(Fin1m3,0F,0F,0F);
  Fin1m3.mirror=true;
  Fin1m4=new ModelRenderer(this,15,50);
  Fin1m4.setTextureSize(128,64);
  Fin1m4.addBox(-2F,-1.5F,-0.5F,4,1,1);
  Fin1m4.setRotationPoint(-3.710101F,24.5F,-4.698463F);
  setRotation(Fin1m4,0F,0F,0F);
  Fin1m4.mirror=true;
  Fin1.addChild(Fin1m1);
  Fin1.addChild(Fin1m2);
  Fin1.addChild(Fin1m3);
  Fin1.addChild(Fin1m4);
  setRotation(Fin1,0F,0F,0F);
  bipedRightLeg.addChild(Fin1);
  bipedLeftLeg=new ModelRenderer(this,16,16);
  bipedLeftLeg.setTextureSize(128,64);
  bipedLeftLeg.addBox(-2F,-6F,-2F,4,12,4);
  bipedLeftLeg.setRotationPoint(2F,18F,0F);
  Fin2=new ModelRenderer(this,10,38);
  Fin2.setTextureSize(128,64);
  Fin2.addBox(0F,22F,-2.5F,5,2,5);
  Fin2.setRotationPoint(-2F,-12F,0F);
  Fin2m1=new ModelRenderer(this,13,47);
  Fin2m1.setTextureSize(128,64);
  Fin2m1.addBox(-2.5F,-1.5F,-1F,5,1,2);
  Fin2m1.setRotationPoint(3.19707F,24.5F,-3.288924F);
  setRotation(Fin2m1,0F,0F,0F);
  Fin2m2=new ModelRenderer(this,15,45);
  Fin2m2.setTextureSize(128,64);
  Fin2m2.addBox(-2F,-1.5F,-0.5F,4,1,1);
  Fin2m2.setRotationPoint(3.02606F,23.5F,-2.819078F);
  setRotation(Fin2m2,0F,0F,0F);
  Fin2m3=new ModelRenderer(this,1,52);
  Fin2m3.setTextureSize(128,64);
  Fin2m3.addBox(-5F,-1.0F,-6F,10,0,12);
  Fin2m3.setRotationPoint(5.420201F,24.5F,-9.396926F);
  setRotation(Fin2m3,0F,0F,0F);
  Fin2m4=new ModelRenderer(this,15,50);
  Fin2m4.setTextureSize(128,64);
  Fin2m4.addBox(-2F,-1.5F,-0.5F,4,1,1);
  Fin2m4.setRotationPoint(3.710101F,24.5F,-4.698463F);
  setRotation(Fin2m4,0F,0F,0F);
  Fin2.addChild(Fin2m1);
  Fin2.addChild(Fin2m2);
  Fin2.addChild(Fin2m3);
  Fin2.addChild(Fin2m4);
  setRotation(Fin2,0F,0F,0F);
  bipedLeftLeg.addChild(Fin2);
  BCD=new ModelRenderer(this,65,50);
  BCD.setTextureSize(128,64);
  BCD.addBox(-4F,-6F,-1F,8,12,2);
  BCD.setRotationPoint(0F,6.5F,3F);
  BCD12=new ModelRenderer(this,102,46);
  BCD12.setTextureSize(128,64);
  BCD12.addBox(-0.5F,-0.5F,-0.5F,1,1,1);
  BCD12.setRotationPoint(0F,10F,-2.7F);
  BCD11=new ModelRenderer(this,79,42);
  BCD11.setTextureSize(128,64);
  BCD11.addBox(-0.5F,-0.5F,-2F,1,1,4);
  BCD11.setRotationPoint(3.6F,3F,0F);
  BCD4=new ModelRenderer(this,97,50);
  BCD4.setTextureSize(128,64);
  BCD4.addBox(-1F,-5.5F,-0.5F,2,11,1);
  BCD4.setRotationPoint(3F,5.5F,-2.5F);
  Tank2=new ModelRenderer(this,41,50);
  Tank2.setTextureSize(128,64);
  Tank2.addBox(-2F,-5F,-2F,4,10,4);
  Tank2.setRotationPoint(-3F,7F,6.5F);
  Tank2m1=new ModelRenderer(this,45,54);
  Tank2m1.setTextureSize(128,64);
  Tank2m1.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank2m1.setRotationPoint(-3F,7F,8.5F);
  Tank2m2=new ModelRenderer(this,45,54);
  Tank2m2.setTextureSize(128,64);
  Tank2m2.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank2m2.setRotationPoint(-5F,7F,6.5F);
  Tank2m3=new ModelRenderer(this,45,54);
  Tank2m3.setTextureSize(128,64);
  Tank2m3.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank2m3.setRotationPoint(-1F,7F,6.5F);
  Tank2m4=new ModelRenderer(this,43,46);
  Tank2m4.setTextureSize(128,64);
  Tank2m4.addBox(-1.5F,-0.5F,-1.5F,3,1,3);
  Tank2m4.setRotationPoint(-3F,1.5F,6.5F);
  Tank2m5=new ModelRenderer(this,38,49);
  Tank2m5.setTextureSize(128,64);
  Tank2m5.addBox(-0.5F,-2F,-0.5F,1,4,1);
  Tank2m5.setRotationPoint(-3F,-0.5F,6.5F);
  Tank2m6=new ModelRenderer(this,44,44);
  Tank2m6.setTextureSize(128,64);
  Tank2m6.addBox(-2F,-0.5F,-0.5F,4,1,1);
  Tank2m6.setRotationPoint(-3.5F,-0.5F,6.5F);
  Tank2m7=new ModelRenderer(this,36,44);
  Tank2m7.setTextureSize(128,64);
  Tank2m7.addBox(-1F,-1F,-1F,2,2,2);
  Tank2m7.setRotationPoint(-5.5F,-0.5F,6.5F);
  BCD2=new ModelRenderer(this,66,51);
  BCD2.setTextureSize(128,64);
  BCD2.addBox(-3.5F,-5F,-0.5F,7,10,1);
  BCD2.setRotationPoint(0F,6.5F,4F);
  Tank1=new ModelRenderer(this,41,50);
  Tank1.setTextureSize(128,64);
  Tank1.addBox(-2F,-5F,-2F,4,10,4);
  Tank1.setRotationPoint(3F,7F,6.5F);
  Tank1m1=new ModelRenderer(this,45,54);
  Tank1m1.setTextureSize(128,64);
  Tank1m1.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank1m1.setRotationPoint(3F,7F,8.5F);
  Tank1m2=new ModelRenderer(this,45,54);
  Tank1m2.setTextureSize(128,64);
  Tank1m2.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank1m2.setRotationPoint(1F,7F,6.5F);
  Tank1m3=new ModelRenderer(this,45,54);
  Tank1m3.setTextureSize(128,64);
  Tank1m3.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank1m3.setRotationPoint(5F,7F,6.5F);
  Tank1m4=new ModelRenderer(this,43,46);
  Tank1m4.setTextureSize(128,64);
  Tank1m4.addBox(-1.5F,-0.5F,-1.5F,3,1,3);
  Tank1m4.setRotationPoint(3F,1.5F,6.5F);
  Tank1m5=new ModelRenderer(this,38,49);
  Tank1m5.setTextureSize(128,64);
  Tank1m5.addBox(-0.5F,-2F,-0.5F,1,4,1);
  Tank1m5.setRotationPoint(3F,-0.5F,6.5F);
  Tank1m6=new ModelRenderer(this,44,44);
  Tank1m6.setTextureSize(128,64);
  Tank1m6.addBox(-2F,-0.5F,-0.5F,4,1,1);
  Tank1m6.setRotationPoint(3.5F,-0.5F,6.5F);
  Tank1m7=new ModelRenderer(this,36,44);
  Tank1m7.setTextureSize(128,64);
  Tank1m7.addBox(-1F,-1F,-1F,2,2,2);
  Tank1m7.setRotationPoint(5.5F,-0.5F,6.5F);
  BCD6=new ModelRenderer(this,68,41);
  BCD6.setTextureSize(128,64);
  BCD6.addBox(-0.5F,-1F,-2F,1,2,4);
  BCD6.setRotationPoint(-3.6F,10F,0F);
  BCD5=new ModelRenderer(this,68,41);
  BCD5.setTextureSize(128,64);
  BCD5.addBox(-0.5F,-1F,-2F,1,2,4);
  BCD5.setRotationPoint(3.6F,10F,0F);
  BCD3=new ModelRenderer(this,91,50);
  BCD3.setTextureSize(128,64);
  BCD3.addBox(-1F,-5.5F,-0.5F,2,11,1);
  BCD3.setRotationPoint(-3F,5.5F,-2.5F);
  BCD7=new ModelRenderer(this,91,45);
  BCD7.setTextureSize(128,64);
  BCD7.addBox(-2F,-1F,-0.5F,4,2,1);
  BCD7.setRotationPoint(0F,10F,-2.5F);
  BCD8=new ModelRenderer(this,91,48);
  BCD8.setTextureSize(128,64);
  BCD8.addBox(-2F,-0.5F,-0.5F,4,1,1);
  BCD8.setRotationPoint(0F,3F,-2.5F);
  BCD9=new ModelRenderer(this,79,42);
  BCD9.setTextureSize(128,64);
  BCD9.addBox(-0.5F,-0.5F,-2F,1,1,4);
  BCD9.setRotationPoint(-3.6F,3F,0F);
  BCD13=new ModelRenderer(this,91,38);
  BCD13.setTextureSize(128,64);
  BCD13.addBox(-4F,-0.5F,-0.5F,8,1,1);
  BCD13.setRotationPoint(0F,0.5F,2.5F);
  Mask=new ModelRenderer(this,109,60);
  Mask.setTextureSize(128,64);
  Mask.addBox(-4F,-0.5F,-0.5F,8,1,1);
  Mask.setRotationPoint(0F,-6F,-4.5F);
  Mask2=new ModelRenderer(this,120,55);
  Mask2.setTextureSize(128,64);
  Mask2.addBox(-0.5F,-2F,-0.5F,1,4,1);
  Mask2.setRotationPoint(-4F,-4F,-4.5F);
  Mask3=new ModelRenderer(this,116,55);
  Mask3.setTextureSize(128,64);
  Mask3.addBox(-0.5F,-2F,-0.5F,1,4,1);
  Mask3.setRotationPoint(4F,-4F,-4.5F);
  Mask4=new ModelRenderer(this,114,51);
  Mask4.setTextureSize(128,64);
  Mask4.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  Mask4.setRotationPoint(-2.5F,-2F,-4.5F);
  Mask5=new ModelRenderer(this,114,53);
  Mask5.setTextureSize(128,64);
  Mask5.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  Mask5.setRotationPoint(2.5F,-2F,-4.5F);
  Mask6=new ModelRenderer(this,114,49);
  Mask6.setTextureSize(128,64);
  Mask6.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  Mask6.setRotationPoint(0F,-3F,-4.5F);
  Mask7=new ModelRenderer(this,110,38);
  Mask7.setTextureSize(128,64);
  Mask7.addBox(-0.5F,-1F,-4F,1,2,8);
  Mask7.setRotationPoint(4F,-4.5F,0F);
  Mask8=new ModelRenderer(this,110,38);
  Mask8.setTextureSize(128,64);
  Mask8.addBox(-0.5F,-1F,-4F,1,2,8);
  Mask8.setRotationPoint(-4F,-4.5F,0F);
  Mask9=new ModelRenderer(this,110,35);
  Mask9.setTextureSize(128,64);
  Mask9.addBox(-4F,-1F,-0.5F,8,2,1);
  Mask9.setRotationPoint(0F,-4.5F,4F);
  mouthpiece=new ModelRenderer(this,115,28);
  mouthpiece.setTextureSize(128,64);
  mouthpiece.addBox(-1.5F,-1.5F,-0.5F,3,3,1);
  mouthpiece.setRotationPoint(0F,0F,-5F);
  mouthpiece2=new ModelRenderer(this,116,25);
  mouthpiece2.setTextureSize(128,64);
  mouthpiece2.addBox(-1F,-1F,-0.5F,2,2,1);
  mouthpiece2.setRotationPoint(0F,0F,-5.5F);
  mouthpiece3=new ModelRenderer(this,116,23);
  mouthpiece3.setTextureSize(128,64);
  mouthpiece3.addBox(-1F,-0.5F,-0.5F,2,1,1);
  mouthpiece3.setRotationPoint(0F,-0.6000004F,-4F);
  bipedHead=new ModelRenderer(this,0,0);
  bipedHead.setTextureSize(128,64);
  bipedHead.addBox(-4F,-4F,-4F,8,8,8);
  bipedHead.setRotationPoint(0F,-4F,0F);
  bipedHead.mirror=true;
  setRotation(bipedHead,0F,0F,0F);
  hose1=new ModelRenderer(this,117,16);
  hose1.setTextureSize(128,64);
  hose1.addBox(-0.5F,-0.5F,-0.5F,1,1,1);
  hose1.setRotationPoint(3F,-3F,6.5F);
  hose2=new ModelRenderer(this,117,16);
  hose2.setTextureSize(128,64);
  hose2.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  hose2.setRotationPoint(5F,-3F,6.5F);
  hose3=new ModelRenderer(this,116,15);
  hose3.setTextureSize(128,64);
  hose3.addBox(-0.5F,-0.5F,-1F,1,1,2);
  hose3.setRotationPoint(6F,-3F,5F);
  hose4=new ModelRenderer(this,106,7);
  hose4.setTextureSize(128,64);
  hose4.addBox(-0.5F,-0.5F,-10F,1,1,10);
  hose4.setRotationPoint(6F,-3F,4.2F);
  hose5=new ModelRenderer(this,115,16);
  hose5.setTextureSize(128,64);
  hose5.addBox(-2.5F,-0.5F,-0.5F,5,1,1);
  hose5.setRotationPoint(4F,0F,-5F);
  hose6=new ModelRenderer(this,115,16);
  hose6.setTextureSize(128,64);
  hose6.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  hose6.setRotationPoint(0F,-0.5F,6.5F);
  bipedHead.addChild(Mask);
  bipedHead.addChild(Mask2);
  bipedHead.addChild(Mask3);
  bipedHead.addChild(Mask4);
  bipedHead.addChild(Mask5);
  bipedHead.addChild(Mask6);
  bipedHead.addChild(Mask7);
  bipedHead.addChild(Mask8);
  bipedHead.addChild(mouthpiece);
  bipedHead.addChild(mouthpiece2);
  bipedHead.addChild(mouthpiece3);
  bipedHead.addChild(hose1);
  bipedHead.addChild(hose2);
  bipedHead.addChild(hose3);
  bipedHead.addChild(hose4);
  bipedHead.addChild(hose5);
}","public ModelScubaGear(float par1,EntityEquipmentSlot slot){
  this.slot=slot;
  this.leftArmPose=ModelBiped.ArmPose.EMPTY;
  this.rightArmPose=ModelBiped.ArmPose.EMPTY;
  bipedBody=new ModelRenderer(this,32,16);
  bipedBody.setTextureSize(128,64);
  bipedBody.addBox(-4F,-6F,-2F,8,12,4);
  bipedBody.setRotationPoint(0F,6F,0F);
  bipedRightArm=new ModelRenderer(this,56,16);
  bipedRightArm.setTextureSize(128,64);
  bipedRightArm.addBox(-4F,0F,-2F,4,12,4);
  bipedRightArm.setRotationPoint(-4F,0F,0F);
  bipedLeftArm=new ModelRenderer(this,72,16);
  bipedLeftArm.setTextureSize(128,64);
  bipedLeftArm.addBox(0F,0F,-2F,4,12,4);
  bipedLeftArm.setRotationPoint(4F,0F,0F);
  bipedRightLeg=new ModelRenderer(this,0,16);
  bipedRightLeg.setTextureSize(128,64);
  bipedRightLeg.addBox(-2F,-6F,-2F,4,12,4);
  bipedRightLeg.setRotationPoint(-2F,18F,0F);
  Fin1=new ModelRenderer(this,10,38);
  Fin1.setTextureSize(128,64);
  Fin1.addBox(-5F,22F,-2.5F,5,2,5);
  Fin1.setRotationPoint(2.5F,-12F,0F);
  Fin1.mirror=true;
  Fin1m1=new ModelRenderer(this,13,47);
  Fin1m1.setTextureSize(128,64);
  Fin1m1.addBox(-2.5F,-1.5F,-1F,5,1,2);
  Fin1m1.setRotationPoint(-3.19707F,24.5F,-3.288924F);
  setRotation(Fin1m1,0F,0F,0F);
  Fin1m1.mirror=true;
  Fin1m2=new ModelRenderer(this,15,45);
  Fin1m2.setTextureSize(128,64);
  Fin1m2.addBox(-2F,-1.5F,-0.5F,4,1,1);
  Fin1m2.setRotationPoint(-3.02606F,23.5F,-2.819078F);
  setRotation(Fin1m2,0F,0F,0F);
  Fin1m2.mirror=true;
  Fin1m3=new ModelRenderer(this,1,52);
  Fin1m3.setTextureSize(128,64);
  Fin1m3.addBox(-5F,-1F,-6F,10,0,12);
  Fin1m3.setRotationPoint(-5.420201F,24.5F,-9.396926F);
  setRotation(Fin1m3,0F,0F,0F);
  Fin1m3.mirror=true;
  Fin1m4=new ModelRenderer(this,15,50);
  Fin1m4.setTextureSize(128,64);
  Fin1m4.addBox(-2F,-1.5F,-0.5F,4,1,1);
  Fin1m4.setRotationPoint(-3.710101F,24.5F,-4.698463F);
  setRotation(Fin1m4,0F,0F,0F);
  Fin1m4.mirror=true;
  Fin1.addChild(Fin1m1);
  Fin1.addChild(Fin1m2);
  Fin1.addChild(Fin1m3);
  Fin1.addChild(Fin1m4);
  setRotation(Fin1,0F,0F,0F);
  bipedRightLeg.addChild(Fin1);
  bipedLeftLeg=new ModelRenderer(this,16,16);
  bipedLeftLeg.setTextureSize(128,64);
  bipedLeftLeg.addBox(-2F,-6F,-2F,4,12,4);
  bipedLeftLeg.setRotationPoint(2F,18F,0F);
  Fin2=new ModelRenderer(this,10,38);
  Fin2.setTextureSize(128,64);
  Fin2.addBox(0F,22F,-2.5F,5,2,5);
  Fin2.setRotationPoint(-2F,-12F,0F);
  Fin2m1=new ModelRenderer(this,13,47);
  Fin2m1.setTextureSize(128,64);
  Fin2m1.addBox(-2.5F,-1.5F,-1F,5,1,2);
  Fin2m1.setRotationPoint(3.19707F,24.5F,-3.288924F);
  setRotation(Fin2m1,0F,0F,0F);
  Fin2m2=new ModelRenderer(this,15,45);
  Fin2m2.setTextureSize(128,64);
  Fin2m2.addBox(-2F,-1.5F,-0.5F,4,1,1);
  Fin2m2.setRotationPoint(3.02606F,23.5F,-2.819078F);
  setRotation(Fin2m2,0F,0F,0F);
  Fin2m3=new ModelRenderer(this,1,52);
  Fin2m3.setTextureSize(128,64);
  Fin2m3.addBox(-5F,-1.0F,-6F,10,0,12);
  Fin2m3.setRotationPoint(5.420201F,24.5F,-9.396926F);
  setRotation(Fin2m3,0F,0F,0F);
  Fin2m4=new ModelRenderer(this,15,50);
  Fin2m4.setTextureSize(128,64);
  Fin2m4.addBox(-2F,-1.5F,-0.5F,4,1,1);
  Fin2m4.setRotationPoint(3.710101F,24.5F,-4.698463F);
  setRotation(Fin2m4,0F,0F,0F);
  Fin2.addChild(Fin2m1);
  Fin2.addChild(Fin2m2);
  Fin2.addChild(Fin2m3);
  Fin2.addChild(Fin2m4);
  setRotation(Fin2,0F,0F,0F);
  bipedLeftLeg.addChild(Fin2);
  BCD=new ModelRenderer(this,65,50);
  BCD.setTextureSize(128,64);
  BCD.addBox(-4F,-6F,-1F,8,12,2);
  BCD.setRotationPoint(0F,6.5F,3F);
  BCD12=new ModelRenderer(this,102,46);
  BCD12.setTextureSize(128,64);
  BCD12.addBox(-0.5F,-0.5F,-0.5F,1,1,1);
  BCD12.setRotationPoint(0F,10F,-2.7F);
  BCD11=new ModelRenderer(this,79,42);
  BCD11.setTextureSize(128,64);
  BCD11.addBox(-0.5F,-0.5F,-2F,1,1,4);
  BCD11.setRotationPoint(3.6F,3F,0F);
  BCD4=new ModelRenderer(this,97,50);
  BCD4.setTextureSize(128,64);
  BCD4.addBox(-1F,-5.5F,-0.5F,2,11,1);
  BCD4.setRotationPoint(3F,5.5F,-2.5F);
  Tank2=new ModelRenderer(this,41,50);
  Tank2.setTextureSize(128,64);
  Tank2.addBox(-2F,-5F,-2F,4,10,4);
  Tank2.setRotationPoint(-3F,7F,6.5F);
  Tank2m1=new ModelRenderer(this,45,54);
  Tank2m1.setTextureSize(128,64);
  Tank2m1.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank2m1.setRotationPoint(-3F,7F,8.5F);
  Tank2m2=new ModelRenderer(this,45,54);
  Tank2m2.setTextureSize(128,64);
  Tank2m2.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank2m2.setRotationPoint(-5F,7F,6.5F);
  Tank2m3=new ModelRenderer(this,45,54);
  Tank2m3.setTextureSize(128,64);
  Tank2m3.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank2m3.setRotationPoint(-1F,7F,6.5F);
  Tank2m4=new ModelRenderer(this,43,46);
  Tank2m4.setTextureSize(128,64);
  Tank2m4.addBox(-1.5F,-0.5F,-1.5F,3,1,3);
  Tank2m4.setRotationPoint(-3F,1.5F,6.5F);
  Tank2m5=new ModelRenderer(this,38,49);
  Tank2m5.setTextureSize(128,64);
  Tank2m5.addBox(-0.5F,-2F,-0.5F,1,4,1);
  Tank2m5.setRotationPoint(-3F,-0.5F,6.5F);
  Tank2m6=new ModelRenderer(this,44,44);
  Tank2m6.setTextureSize(128,64);
  Tank2m6.addBox(-2F,-0.5F,-0.5F,4,1,1);
  Tank2m6.setRotationPoint(-3.5F,-0.5F,6.5F);
  Tank2m7=new ModelRenderer(this,36,44);
  Tank2m7.setTextureSize(128,64);
  Tank2m7.addBox(-1F,-1F,-1F,2,2,2);
  Tank2m7.setRotationPoint(-5.5F,-0.5F,6.5F);
  BCD2=new ModelRenderer(this,66,51);
  BCD2.setTextureSize(128,64);
  BCD2.addBox(-3.5F,-5F,-0.5F,7,10,1);
  BCD2.setRotationPoint(0F,6.5F,4F);
  Tank1=new ModelRenderer(this,41,50);
  Tank1.setTextureSize(128,64);
  Tank1.addBox(-2F,-5F,-2F,4,10,4);
  Tank1.setRotationPoint(3F,7F,6.5F);
  Tank1m1=new ModelRenderer(this,45,54);
  Tank1m1.setTextureSize(128,64);
  Tank1m1.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank1m1.setRotationPoint(3F,7F,8.5F);
  Tank1m2=new ModelRenderer(this,45,54);
  Tank1m2.setTextureSize(128,64);
  Tank1m2.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank1m2.setRotationPoint(1F,7F,6.5F);
  Tank1m3=new ModelRenderer(this,45,54);
  Tank1m3.setTextureSize(128,64);
  Tank1m3.addBox(-1.5F,-4.5F,-0.5F,3,9,1);
  Tank1m3.setRotationPoint(5F,7F,6.5F);
  Tank1m4=new ModelRenderer(this,43,46);
  Tank1m4.setTextureSize(128,64);
  Tank1m4.addBox(-1.5F,-0.5F,-1.5F,3,1,3);
  Tank1m4.setRotationPoint(3F,1.5F,6.5F);
  Tank1m5=new ModelRenderer(this,38,49);
  Tank1m5.setTextureSize(128,64);
  Tank1m5.addBox(-0.5F,-2F,-0.5F,1,4,1);
  Tank1m5.setRotationPoint(3F,-0.5F,6.5F);
  Tank1m6=new ModelRenderer(this,44,44);
  Tank1m6.setTextureSize(128,64);
  Tank1m6.addBox(-2F,-0.5F,-0.5F,4,1,1);
  Tank1m6.setRotationPoint(3.5F,-0.5F,6.5F);
  Tank1m7=new ModelRenderer(this,36,44);
  Tank1m7.setTextureSize(128,64);
  Tank1m7.addBox(-1F,-1F,-1F,2,2,2);
  Tank1m7.setRotationPoint(5.5F,-0.5F,6.5F);
  BCD6=new ModelRenderer(this,68,41);
  BCD6.setTextureSize(128,64);
  BCD6.addBox(-0.5F,-1F,-2F,1,2,4);
  BCD6.setRotationPoint(-3.6F,10F,0F);
  BCD5=new ModelRenderer(this,68,41);
  BCD5.setTextureSize(128,64);
  BCD5.addBox(-0.5F,-1F,-2F,1,2,4);
  BCD5.setRotationPoint(3.6F,10F,0F);
  BCD3=new ModelRenderer(this,91,50);
  BCD3.setTextureSize(128,64);
  BCD3.addBox(-1F,-5.5F,-0.5F,2,11,1);
  BCD3.setRotationPoint(-3F,5.5F,-2.5F);
  BCD7=new ModelRenderer(this,91,45);
  BCD7.setTextureSize(128,64);
  BCD7.addBox(-2F,-1F,-0.5F,4,2,1);
  BCD7.setRotationPoint(0F,10F,-2.5F);
  BCD8=new ModelRenderer(this,91,48);
  BCD8.setTextureSize(128,64);
  BCD8.addBox(-2F,-0.5F,-0.5F,4,1,1);
  BCD8.setRotationPoint(0F,3F,-2.5F);
  BCD9=new ModelRenderer(this,79,42);
  BCD9.setTextureSize(128,64);
  BCD9.addBox(-0.5F,-0.5F,-2F,1,1,4);
  BCD9.setRotationPoint(-3.6F,3F,0F);
  BCD13=new ModelRenderer(this,91,38);
  BCD13.setTextureSize(128,64);
  BCD13.addBox(-4F,-0.5F,-0.5F,8,1,1);
  BCD13.setRotationPoint(0F,0.5F,2.5F);
  Mask=new ModelRenderer(this,109,60);
  Mask.setTextureSize(128,64);
  Mask.addBox(-4F,-0.5F,-0.5F,8,1,1);
  Mask.setRotationPoint(0F,-6F,-4.5F);
  Mask2=new ModelRenderer(this,120,55);
  Mask2.setTextureSize(128,64);
  Mask2.addBox(-0.5F,-2F,-0.5F,1,4,1);
  Mask2.setRotationPoint(-4F,-4F,-4.5F);
  Mask3=new ModelRenderer(this,116,55);
  Mask3.setTextureSize(128,64);
  Mask3.addBox(-0.5F,-2F,-0.5F,1,4,1);
  Mask3.setRotationPoint(4F,-4F,-4.5F);
  Mask4=new ModelRenderer(this,114,51);
  Mask4.setTextureSize(128,64);
  Mask4.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  Mask4.setRotationPoint(-2.5F,-2F,-4.5F);
  Mask5=new ModelRenderer(this,114,53);
  Mask5.setTextureSize(128,64);
  Mask5.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  Mask5.setRotationPoint(2.5F,-2F,-4.5F);
  Mask6=new ModelRenderer(this,114,49);
  Mask6.setTextureSize(128,64);
  Mask6.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  Mask6.setRotationPoint(0F,-3F,-4.5F);
  Mask7=new ModelRenderer(this,110,38);
  Mask7.setTextureSize(128,64);
  Mask7.addBox(-0.5F,-1F,-4F,1,2,8);
  Mask7.setRotationPoint(4F,-4.5F,0F);
  Mask8=new ModelRenderer(this,110,38);
  Mask8.setTextureSize(128,64);
  Mask8.addBox(-0.5F,-1F,-4F,1,2,8);
  Mask8.setRotationPoint(-4F,-4.5F,0F);
  Mask9=new ModelRenderer(this,110,35);
  Mask9.setTextureSize(128,64);
  Mask9.addBox(-4F,-1F,-0.5F,8,2,1);
  Mask9.setRotationPoint(0F,-4.5F,4F);
  mouthpiece=new ModelRenderer(this,115,28);
  mouthpiece.setTextureSize(128,64);
  mouthpiece.addBox(-1.5F,-1.5F,-0.5F,3,3,1);
  mouthpiece.setRotationPoint(0F,0F,-5F);
  mouthpiece2=new ModelRenderer(this,116,25);
  mouthpiece2.setTextureSize(128,64);
  mouthpiece2.addBox(-1F,-1F,-0.5F,2,2,1);
  mouthpiece2.setRotationPoint(0F,0F,-5.5F);
  mouthpiece3=new ModelRenderer(this,116,23);
  mouthpiece3.setTextureSize(128,64);
  mouthpiece3.addBox(-1F,-0.5F,-0.5F,2,1,1);
  mouthpiece3.setRotationPoint(0F,-0.6000004F,-4F);
  bipedHead=new ModelRenderer(this,0,0);
  bipedHead.setTextureSize(128,64);
  bipedHead.addBox(-4F,-4F,-4F,8,8,8);
  bipedHead.setRotationPoint(0F,-4F,0F);
  bipedHead.mirror=true;
  setRotation(bipedHead,0F,0F,0F);
  hose1=new ModelRenderer(this,117,16);
  hose1.setTextureSize(128,64);
  hose1.addBox(-0.5F,-0.5F,-0.5F,1,1,1);
  hose1.setRotationPoint(3F,-3F,6.5F);
  hose2=new ModelRenderer(this,117,16);
  hose2.setTextureSize(128,64);
  hose2.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  hose2.setRotationPoint(5F,-3F,6.5F);
  hose3=new ModelRenderer(this,116,15);
  hose3.setTextureSize(128,64);
  hose3.addBox(-0.5F,-0.5F,-1F,1,1,2);
  hose3.setRotationPoint(6F,-3F,5F);
  hose4=new ModelRenderer(this,106,7);
  hose4.setTextureSize(128,64);
  hose4.addBox(-0.5F,-0.5F,-10F,1,1,10);
  hose4.setRotationPoint(6F,-3F,4.2F);
  hose5=new ModelRenderer(this,115,16);
  hose5.setTextureSize(128,64);
  hose5.addBox(-2.5F,-0.5F,-0.5F,5,1,1);
  hose5.setRotationPoint(4F,0F,-5F);
  hose6=new ModelRenderer(this,115,16);
  hose6.setTextureSize(128,64);
  hose6.addBox(-1.5F,-0.5F,-0.5F,3,1,1);
  hose6.setRotationPoint(0F,-0.5F,6.5F);
  bipedHead.addChild(Mask);
  bipedHead.addChild(Mask2);
  bipedHead.addChild(Mask3);
  bipedHead.addChild(Mask4);
  bipedHead.addChild(Mask5);
  bipedHead.addChild(Mask6);
  bipedHead.addChild(Mask7);
  bipedHead.addChild(Mask8);
  bipedHead.addChild(mouthpiece);
  bipedHead.addChild(mouthpiece2);
  bipedHead.addChild(mouthpiece3);
  bipedHead.addChild(hose1);
  bipedHead.addChild(hose2);
  bipedHead.addChild(hose3);
  bipedHead.addChild(hose4);
  bipedHead.addChild(hose5);
}",0.9980577261845612
109844,"/** 
 * Called each tick as long the item is on a player inventory. Uses by maps to check if is on a player hand and update it's contents.
 */
@Override public void onUpdate(ItemStack itemstack,World world,Entity entity,int par4,boolean par5){
  if (world.isRemote)   return;
  if (ticksUntilUpdate <= 0) {
    EntityPlayer player;
    if (entity instanceof EntityPlayer)     player=(EntityPlayer)entity;
 else     return;
    if (!isFullyUnderwater(world,player)) {
      return;
    }
    ItemStack helmetStack=player.getItemStackFromSlot(EntityEquipmentSlot.HEAD);
    ItemStack chestplateStack=player.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
    ItemStack leggingsStack=player.getItemStackFromSlot(EntityEquipmentSlot.LEGS);
    ItemStack flippersStack=player.getItemStackFromSlot(EntityEquipmentSlot.FEET);
    if (!armorCheck(world,player,helmetStack,chestplateStack,leggingsStack,flippersStack))     return;
    player.setAir(300);
    float air=getTagCompound(chestplateStack).getFloat(""String_Node_Str"");
    AirType airType=chestplateStack.getItemDamage() >= 2 ? AirType.TRIMIX : AirType.REGULAR;
    chestplateStack.getTagCompound().setFloat(""String_Node_Str"",air - airType.getUsageRate());
    int currentDepth=MathHelper.floor(player.posY);
    if (currentDepth < chestplateStack.getTagCompound().getInteger(""String_Node_Str"") || chestplateStack.getTagCompound().getInteger(""String_Node_Str"") == 0)     chestplateStack.getTagCompound().setInteger(""String_Node_Str"",currentDepth);
    int waterBlocksAbove=0, waterBlocksBelow=0;
    int x=MathHelper.floor(player.posX);
    int y=MathHelper.floor(player.posY + player.height - 0.5);
    int z=MathHelper.floor(player.posZ);
    while (world.getBlockState(new BlockPos(x,y + waterBlocksAbove + 1,z)).getMaterial().isLiquid()) {
      waterBlocksAbove++;
    }
    while (world.getBlockState(new BlockPos(x,y - waterBlocksBelow - 1,z)).getMaterial().isLiquid()) {
      waterBlocksBelow++;
    }
    chestplateStack.getTagCompound().setInteger(""String_Node_Str"",waterBlocksAbove);
    chestplateStack.getTagCompound().setInteger(""String_Node_Str"",waterBlocksBelow);
    ticksUntilUpdate=UPDATE_RATE;
  }
 else   ticksUntilUpdate--;
}","/** 
 * Called each tick as long the item is on a player inventory. Uses by maps to check if is on a player hand and update it's contents.
 */
@Override public void onUpdate(ItemStack itemstack,World world,Entity entity,int par4,boolean par5){
  if (world.isRemote) {
    return;
  }
  if (ticksUntilUpdate <= 0) {
    EntityPlayer player;
    if (entity instanceof EntityPlayer)     player=(EntityPlayer)entity;
 else     return;
    if (!isFullyUnderwater(world,player)) {
      return;
    }
    ItemStack helmetStack=player.getItemStackFromSlot(EntityEquipmentSlot.HEAD);
    ItemStack chestplateStack=player.getItemStackFromSlot(EntityEquipmentSlot.CHEST);
    ItemStack leggingsStack=player.getItemStackFromSlot(EntityEquipmentSlot.LEGS);
    ItemStack flippersStack=player.getItemStackFromSlot(EntityEquipmentSlot.FEET);
    if (!armorCheck(world,player,helmetStack,chestplateStack,leggingsStack,flippersStack))     return;
    player.setAir(300);
    float air=getTagCompound(chestplateStack).getFloat(""String_Node_Str"");
    AirType airType=chestplateStack.getItemDamage() >= 2 ? AirType.TRIMIX : AirType.REGULAR;
    chestplateStack.getTagCompound().setFloat(""String_Node_Str"",air - airType.getUsageRate());
    int currentDepth=MathHelper.floor(player.posY);
    if (currentDepth < chestplateStack.getTagCompound().getInteger(""String_Node_Str"") || chestplateStack.getTagCompound().getInteger(""String_Node_Str"") == 0)     chestplateStack.getTagCompound().setInteger(""String_Node_Str"",currentDepth);
    int waterBlocksAbove=0, waterBlocksBelow=0;
    int x=MathHelper.floor(player.posX);
    int y=MathHelper.floor(player.posY + player.height - 0.5);
    int z=MathHelper.floor(player.posZ);
    while (world.getBlockState(new BlockPos(x,y + waterBlocksAbove + 1,z)).getMaterial().isLiquid()) {
      waterBlocksAbove++;
    }
    while (world.getBlockState(new BlockPos(x,y - waterBlocksBelow - 1,z)).getMaterial().isLiquid()) {
      waterBlocksBelow++;
    }
    chestplateStack.getTagCompound().setInteger(""String_Node_Str"",waterBlocksAbove);
    chestplateStack.getTagCompound().setInteger(""String_Node_Str"",waterBlocksBelow);
    ticksUntilUpdate=UPDATE_RATE;
  }
 else   ticksUntilUpdate--;
}",0.998185941043084
109845,"@Override public String getArmorTexture(ItemStack stack,Entity entity,EntityEquipmentSlot slot,String type){
  return Info.ARMOR_LOCATION + ""String_Node_Str"";
}","@Override public String getArmorTexture(ItemStack stack,Entity entity,EntityEquipmentSlot slot,String type){
  String color=scubaMaterial == ScubaMaterial.DRY ? ""String_Node_Str"" : ""String_Node_Str"";
  return Info.ARMOR_LOCATION + ""String_Node_Str"" + color+ ""String_Node_Str"";
}",0.730593607305936
109846,"/** 
 * Override this method to have an item handle its own armor rendering.
 * @param entityLiving  The entity wearing the armor
 * @param itemStack  The itemStack to render the model of
 * @param armorSlot  The slot the armor is in
 * @param _default Original armor model. Will have attributes set.
 * @return  A ModelBiped to render instead of the default
 */
@Override @SideOnly(Side.CLIENT) public net.minecraft.client.model.ModelBiped getArmorModel(EntityLivingBase entityLiving,ItemStack itemstack,EntityEquipmentSlot armorSlot,net.minecraft.client.model.ModelBiped _default){
  if (itemstack == null) {
    return null;
  }
  ModelBiped armorModel=EntityRenderRegistry.scubaGearModel;
  if (armorModel != null) {
    armorModel.isSneak=entityLiving.isSneaking();
    armorModel.isRiding=entityLiving.isRiding();
    armorModel.isChild=entityLiving.isChild();
    armorModel.rightArmPose=entityLiving.getHeldItemMainhand() != null ? ModelBiped.ArmPose.BLOCK : ModelBiped.ArmPose.EMPTY;
    return armorModel;
  }
  return null;
}","/** 
 * Override this method to have an item handle its own armor rendering.
 * @param entityLiving  The entity wearing the armor
 * @param itemStack  The itemStack to render the model of
 * @param armorSlot  The slot the armor is in
 * @param _default Original armor model. Will have attributes set.
 * @return  A ModelBiped to render instead of the default
 */
@Override @SideOnly(Side.CLIENT) public net.minecraft.client.model.ModelBiped getArmorModel(EntityLivingBase entityLiving,ItemStack itemstack,EntityEquipmentSlot armorSlot,net.minecraft.client.model.ModelBiped _default){
  if (itemstack == null) {
    return null;
  }
  ModelBiped armorModel;
  armorModel=EntityRenderRegistry.getScubaModel(armorSlot);
  if (armorModel != null) {
    armorModel.isSneak=entityLiving.isSneaking();
    armorModel.isRiding=entityLiving.isRiding();
    armorModel.isChild=entityLiving.isChild();
    armorModel.rightArmPose=entityLiving.getHeldItemMainhand() != null ? ModelBiped.ArmPose.BLOCK : ModelBiped.ArmPose.EMPTY;
    return armorModel;
  }
  return null;
}",0.9790076335877864
109847,"public static void init(){
  registerEntityRender(EntityEIH.class,new RenderEIH());
  registerEntityRender(EntityTropiCreeper.class,new RenderTropiCreeper());
  registerEntityRender(EntityIguana.class,new RenderIguana());
  registerEntityRender(EntityTreeFrogBase.class,new RenderTreeFrog());
  registerEntityRender(EntityTropiSkeleton.class,new RenderTropiSkeleton());
  registerEntityRender(EntityVMonkey.class,new RenderVMonkey());
  registerEntityRender(EntityMarlin.class,new RenderMarlin(new ModelMarlin(),0.25F));
  registerEntityRender(EntityLavaBall.class,new RenderLavaBall());
  registerEntityRender(EntitySeahorse.class,new RenderSeahorse(new ModelSeahorse(),0.25F));
  registerEntityRender(EntityFailgull.class,new RenderFailgull(0.25F));
  registerEntityRender(EntityChair.class,new RenderChair());
  registerEntityRender(EntityUmbrella.class,new RenderUmbrella());
  registerEntityRender(EntityCoconutGrenade.class,new RenderSnowball(Minecraft.getMinecraft().getRenderManager(),ItemRegistry.coconutBomb,Minecraft.getMinecraft().getRenderItem()));
  registerEntityRender(EntityTropicalFish.class,new RenderTropicalFish(new ModelFish(),0.25F));
  registerEntityRender(EntityManOWar.class,new RenderManOWar(new ModelManOWar(32,20,true),0.35F));
  registerEntityRender(EntityEagleRay.class,new RenderEagleRay());
  registerEntityRender(EntitySeaUrchin.class,new RenderSeaUrchin());
  registerEntityRender(EntitySeaUrchinEgg.class,new RenderEchinodermEgg());
  registerEntityRender(EntityStarfish.class,new RenderStarfish());
  registerEntityRender(EntityStarfishEgg.class,new RenderEchinodermEgg());
  registerEntityRender(EntityBambooItemFrame.class,new RenderBambooItemFrame());
  registerEntityRender(EntityWallItem.class,new RenderWallItem());
  registerEntityRender(EntityKoaHunter.class,new RenderKoaMan(Minecraft.getMinecraft().getRenderManager(),new ModelKoaMan(),0.5F));
  scubaGearModel=new ModelScubaGear(0);
}","public static void init(){
  registerEntityRender(EntityEIH.class,new RenderEIH());
  registerEntityRender(EntityTropiCreeper.class,new RenderTropiCreeper());
  registerEntityRender(EntityIguana.class,new RenderIguana());
  registerEntityRender(EntityTreeFrogBase.class,new RenderTreeFrog());
  registerEntityRender(EntityTropiSkeleton.class,new RenderTropiSkeleton());
  registerEntityRender(EntityVMonkey.class,new RenderVMonkey());
  registerEntityRender(EntityMarlin.class,new RenderMarlin(new ModelMarlin(),0.25F));
  registerEntityRender(EntityLavaBall.class,new RenderLavaBall());
  registerEntityRender(EntitySeahorse.class,new RenderSeahorse(new ModelSeahorse(),0.25F));
  registerEntityRender(EntityFailgull.class,new RenderFailgull(0.25F));
  registerEntityRender(EntityChair.class,new RenderChair());
  registerEntityRender(EntityUmbrella.class,new RenderUmbrella());
  registerEntityRender(EntityCoconutGrenade.class,new RenderSnowball(Minecraft.getMinecraft().getRenderManager(),ItemRegistry.coconutBomb,Minecraft.getMinecraft().getRenderItem()));
  registerEntityRender(EntityTropicalFish.class,new RenderTropicalFish(new ModelFish(),0.25F));
  registerEntityRender(EntityManOWar.class,new RenderManOWar(new ModelManOWar(32,20,true),0.35F));
  registerEntityRender(EntityEagleRay.class,new RenderEagleRay());
  registerEntityRender(EntitySeaUrchin.class,new RenderSeaUrchin());
  registerEntityRender(EntitySeaUrchinEgg.class,new RenderEchinodermEgg());
  registerEntityRender(EntityStarfish.class,new RenderStarfish());
  registerEntityRender(EntityStarfishEgg.class,new RenderEchinodermEgg());
  registerEntityRender(EntityBambooItemFrame.class,new RenderBambooItemFrame());
  registerEntityRender(EntityWallItem.class,new RenderWallItem());
  registerEntityRender(EntityKoaHunter.class,new RenderKoaMan(Minecraft.getMinecraft().getRenderManager(),new ModelKoaMan(),0.5F));
  chestModel=new ModelScubaGear(0,EntityEquipmentSlot.CHEST);
  feetModel=new ModelScubaGear(0,EntityEquipmentSlot.FEET);
  legsModel=new ModelScubaGear(0,EntityEquipmentSlot.LEGS);
  headModel=new ModelScubaGear(0,EntityEquipmentSlot.HEAD);
}",0.9498278406296116
109848,"public static void preInit(){
  recordBuriedTreasure=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordEasternIsles=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordSummering=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTheTribe=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordLowTide=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTradeWinds=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  azurite=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  eudialyte=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  zircon=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  grapefruit=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lemon=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lime=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  orange=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  hoeEudialyte=registerItem(new ItemHoe(materialEudialyteTools),""String_Node_Str"");
  hoeZircon=registerItem(new ItemHoe(materialZirconTools),""String_Node_Str"");
  pickaxeEudialyte=registerItem(new ItemTropicraftPickaxe(materialEudialyteTools),""String_Node_Str"");
  pickaxeZircon=registerItem(new ItemTropicraftPickaxe(materialZirconTools),""String_Node_Str"");
  shovelEudialyte=registerItem(new ItemSpade(materialEudialyteTools),""String_Node_Str"");
  shovelZircon=registerItem(new ItemSpade(materialZirconTools),""String_Node_Str"");
  axeEudialyte=registerItem(new ItemTropicraftAxe(materialEudialyteTools,6.0F,-3.1F),""String_Node_Str"");
  axeZircon=registerItem(new ItemTropicraftAxe(materialZirconTools,6.0F,-3.2F),""String_Node_Str"");
  swordEudialyte=registerItem(new ItemSword(materialEudialyteTools),""String_Node_Str"");
  swordZircon=registerItem(new ItemSword(materialZirconTools),""String_Node_Str"");
  fishingNet=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooShoot=registerItem(new ItemBlockSpecial(BlockRegistry.bambooShoot),""String_Node_Str"");
  bambooStick=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooMug=registerItem(new ItemTropicraft().setMaxStackSize(16),""String_Node_Str"");
  freshMarlin=registerItem(new ItemTropicraftFood(2,0.3F),""String_Node_Str"");
  searedMarlin=registerItem(new ItemTropicraftFood(8,0.65F),""String_Node_Str"");
  tropicsWaterBucket=registerItem((new ItemBucket(BlockRegistry.tropicsWater)).setContainerItem(Items.BUCKET),""String_Node_Str"");
  fishBucket=registerItem(new ItemFishBucket(),""String_Node_Str"");
  coconutChunk=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  pineappleCubes=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  coffeeBeans=registerMultiItem(new ItemCoffeeBean(Names.COFFEE_NAMES,BlockRegistry.coffeePlant),""String_Node_Str"",Names.COFFEE_NAMES);
  frogLeg=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  cookedFrogLeg=registerItem(new ItemTropicraftFood(2,0.15F),""String_Node_Str"");
  poisonFrogSkin=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scale=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scaleBoots=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  scaleLeggings=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  scaleChestplate=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  scaleHelmet=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  chair=registerMultiItem(new ItemChair(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  umbrella=registerMultiItem(new ItemUmbrella(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  portalEnchanter=registerItem(new ItemPortalEnchanter(),""String_Node_Str"");
  shellFrox=registerItem(new ItemShell(),""String_Node_Str"");
  shellPab=registerItem(new ItemShell(),""String_Node_Str"");
  shellRube=registerItem(new ItemShell(),""String_Node_Str"");
  shellSolo=registerItem(new ItemShell(),""String_Node_Str"");
  shellStarfish=registerItem(new ItemShell(),""String_Node_Str"");
  shellTurtle=registerItem(new ItemShell(),""String_Node_Str"");
  cocktail=registerMultiItem(new ItemCocktail(),""String_Node_Str"",Drink.drinkList.length);
  whitePearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  blackPearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  fertilizer=registerItem(new ItemFertilizer(),""String_Node_Str"");
  encyclopedia=registerItem(new ItemEncyclopediaTropica(""String_Node_Str""),""String_Node_Str"");
  dagger=registerItem(new ItemDagger(materialZirconTools),""String_Node_Str"");
  bambooSpear=registerItem(new ItemSword(materialBambooTools),""String_Node_Str"");
  coconutBomb=registerItem(new ItemCoconutBomb(),""String_Node_Str"");
  flowerPot=registerItem(new ItemTropicraftBlockSpecial(BlockRegistry.flowerPot),""String_Node_Str"");
  bambooDoor=registerItem(new ItemDoor(BlockRegistry.bambooDoor),""String_Node_Str"");
  bambooItemFrame=registerItem(new ItemBambooItemFrame(EntityBambooItemFrame.class),""String_Node_Str"");
  Tropicraft.proxy.registerArbitraryBlockVariants(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  waterWand=registerItem(new ItemWaterWand(),""String_Node_Str"");
  seaUrchinRoe=registerItem(new ItemTropicraftFood(3,0.3F),""String_Node_Str"");
  mobEgg=registerMultiItemPrefixed(new ItemMobEgg(),""String_Node_Str"",Names.EGG_NAMES);
  scubaTank=registerItem(new ItemScubaTank(),""String_Node_Str"");
  diveComputer=registerItem(new ItemDiveComputer(),""String_Node_Str"");
  bcd=registerItem(new ItemBCD(),""String_Node_Str"");
  dryFlippers=registerItem(new ItemScubaFlippers(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  dryLeggings=registerItem(new ItemScubaLeggings(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  dryChestplate=registerItem(new ItemScubaChestplate(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  dryChestplateGear=registerItem(new ItemScubaChestplateGear(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  dryHelmet=registerItem(new ItemScubaHelmet(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
}","public static void preInit(){
  recordBuriedTreasure=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordEasternIsles=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordSummering=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTheTribe=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordLowTide=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTradeWinds=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  azurite=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  eudialyte=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  zircon=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  grapefruit=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lemon=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lime=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  orange=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  hoeEudialyte=registerItem(new ItemHoe(materialEudialyteTools),""String_Node_Str"");
  hoeZircon=registerItem(new ItemHoe(materialZirconTools),""String_Node_Str"");
  pickaxeEudialyte=registerItem(new ItemTropicraftPickaxe(materialEudialyteTools),""String_Node_Str"");
  pickaxeZircon=registerItem(new ItemTropicraftPickaxe(materialZirconTools),""String_Node_Str"");
  shovelEudialyte=registerItem(new ItemSpade(materialEudialyteTools),""String_Node_Str"");
  shovelZircon=registerItem(new ItemSpade(materialZirconTools),""String_Node_Str"");
  axeEudialyte=registerItem(new ItemTropicraftAxe(materialEudialyteTools,6.0F,-3.1F),""String_Node_Str"");
  axeZircon=registerItem(new ItemTropicraftAxe(materialZirconTools,6.0F,-3.2F),""String_Node_Str"");
  swordEudialyte=registerItem(new ItemSword(materialEudialyteTools),""String_Node_Str"");
  swordZircon=registerItem(new ItemSword(materialZirconTools),""String_Node_Str"");
  fishingNet=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooShoot=registerItem(new ItemBlockSpecial(BlockRegistry.bambooShoot),""String_Node_Str"");
  bambooStick=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooMug=registerItem(new ItemTropicraft().setMaxStackSize(16),""String_Node_Str"");
  freshMarlin=registerItem(new ItemTropicraftFood(2,0.3F),""String_Node_Str"");
  searedMarlin=registerItem(new ItemTropicraftFood(8,0.65F),""String_Node_Str"");
  tropicsWaterBucket=registerItem((new ItemBucket(BlockRegistry.tropicsWater)).setContainerItem(Items.BUCKET),""String_Node_Str"");
  fishBucket=registerItem(new ItemFishBucket(),""String_Node_Str"");
  coconutChunk=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  pineappleCubes=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  coffeeBeans=registerMultiItem(new ItemCoffeeBean(Names.COFFEE_NAMES,BlockRegistry.coffeePlant),""String_Node_Str"",Names.COFFEE_NAMES);
  frogLeg=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  cookedFrogLeg=registerItem(new ItemTropicraftFood(2,0.15F),""String_Node_Str"");
  poisonFrogSkin=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scale=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scaleBoots=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  scaleLeggings=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  scaleChestplate=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  scaleHelmet=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  chair=registerMultiItem(new ItemChair(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  umbrella=registerMultiItem(new ItemUmbrella(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  portalEnchanter=registerItem(new ItemPortalEnchanter(),""String_Node_Str"");
  shellFrox=registerItem(new ItemShell(),""String_Node_Str"");
  shellPab=registerItem(new ItemShell(),""String_Node_Str"");
  shellRube=registerItem(new ItemShell(),""String_Node_Str"");
  shellSolo=registerItem(new ItemShell(),""String_Node_Str"");
  shellStarfish=registerItem(new ItemShell(),""String_Node_Str"");
  shellTurtle=registerItem(new ItemShell(),""String_Node_Str"");
  cocktail=registerMultiItem(new ItemCocktail(),""String_Node_Str"",Drink.drinkList.length);
  whitePearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  blackPearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  fertilizer=registerItem(new ItemFertilizer(),""String_Node_Str"");
  encyclopedia=registerItem(new ItemEncyclopediaTropica(""String_Node_Str""),""String_Node_Str"");
  dagger=registerItem(new ItemDagger(materialZirconTools),""String_Node_Str"");
  bambooSpear=registerItem(new ItemSword(materialBambooTools),""String_Node_Str"");
  coconutBomb=registerItem(new ItemCoconutBomb(),""String_Node_Str"");
  flowerPot=registerItem(new ItemTropicraftBlockSpecial(BlockRegistry.flowerPot),""String_Node_Str"");
  bambooDoor=registerItem(new ItemDoor(BlockRegistry.bambooDoor),""String_Node_Str"");
  bambooItemFrame=registerItem(new ItemBambooItemFrame(EntityBambooItemFrame.class),""String_Node_Str"");
  Tropicraft.proxy.registerArbitraryBlockVariants(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  waterWand=registerItem(new ItemWaterWand(),""String_Node_Str"");
  seaUrchinRoe=registerItem(new ItemTropicraftFood(3,0.3F),""String_Node_Str"");
  mobEgg=registerMultiItemPrefixed(new ItemMobEgg(),""String_Node_Str"",Names.EGG_NAMES);
  scubaTank=registerItem(new ItemScubaTank(),""String_Node_Str"");
  diveComputer=registerItem(new ItemDiveComputer(),""String_Node_Str"");
  bcd=registerItem(new ItemBCD(),""String_Node_Str"");
  dryFlippers=registerItem(new ItemScubaFlippers(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  dryLeggings=registerItem(new ItemScubaLeggings(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  dryChestplate=registerItem(new ItemScubaChestplate(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  dryChestplateGear=registerItem(new ItemScubaChestplateGear(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  dryHelmet=registerItem(new ItemScubaHelmet(materialDrySuit,ItemScubaGear.ScubaMaterial.DRY,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  wetFlippers=registerItem(new ItemScubaFlippers(materialWetSuit,ItemScubaGear.ScubaMaterial.WET,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  wetLeggings=registerItem(new ItemScubaLeggings(materialWetSuit,ItemScubaGear.ScubaMaterial.WET,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  wetChestplate=registerItem(new ItemScubaChestplate(materialWetSuit,ItemScubaGear.ScubaMaterial.WET,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  wetChestplateGear=registerItem(new ItemScubaChestplateGear(materialWetSuit,ItemScubaGear.ScubaMaterial.WET,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  wetHelmet=registerItem(new ItemScubaHelmet(materialWetSuit,ItemScubaGear.ScubaMaterial.WET,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
}",0.9491151965847276
109849,"public static void preInit(){
  recordBuriedTreasure=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordEasternIsles=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordSummering=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTheTribe=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordLowTide=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTradeWinds=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  azurite=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  eudialyte=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  zircon=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  grapefruit=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lemon=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lime=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  orange=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  hoeEudialyte=registerItem(new ItemHoe(materialEudialyteTools),""String_Node_Str"");
  hoeZircon=registerItem(new ItemHoe(materialZirconTools),""String_Node_Str"");
  pickaxeEudialyte=registerItem(new ItemTropicraftPickaxe(materialEudialyteTools),""String_Node_Str"");
  pickaxeZircon=registerItem(new ItemTropicraftPickaxe(materialZirconTools),""String_Node_Str"");
  shovelEudialyte=registerItem(new ItemSpade(materialEudialyteTools),""String_Node_Str"");
  shovelZircon=registerItem(new ItemSpade(materialZirconTools),""String_Node_Str"");
  axeEudialyte=registerItem(new ItemTropicraftAxe(materialEudialyteTools,6.0F,-3.1F),""String_Node_Str"");
  axeZircon=registerItem(new ItemTropicraftAxe(materialZirconTools,6.0F,-3.2F),""String_Node_Str"");
  swordEudialyte=registerItem(new ItemSword(materialEudialyteTools),""String_Node_Str"");
  swordZircon=registerItem(new ItemSword(materialZirconTools),""String_Node_Str"");
  fishingNet=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooShoot=registerItem(new ItemBlockSpecial(BlockRegistry.bambooShoot),""String_Node_Str"");
  bambooStick=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooMug=registerItem(new ItemTropicraft().setMaxStackSize(16),""String_Node_Str"");
  freshMarlin=registerItem(new ItemTropicraftFood(2,0.3F),""String_Node_Str"");
  searedMarlin=registerItem(new ItemTropicraftFood(8,0.65F),""String_Node_Str"");
  tropicsWaterBucket=registerItem((new ItemBucket(BlockRegistry.tropicsWater)).setContainerItem(Items.BUCKET),""String_Node_Str"");
  fishBucket=registerItem(new ItemFishBucket(),""String_Node_Str"");
  coconutChunk=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  pineappleCubes=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  coffeeBeans=registerMultiItem(new ItemCoffeeBean(Names.COFFEE_NAMES,BlockRegistry.coffeePlant),""String_Node_Str"",Names.COFFEE_NAMES);
  frogLeg=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  cookedFrogLeg=registerItem(new ItemTropicraftFood(2,0.15F),""String_Node_Str"");
  poisonFrogSkin=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scale=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scaleBoots=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  scaleLeggings=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  scaleChestplate=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  scaleHelmet=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  chair=registerMultiItem(new ItemChair(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  umbrella=registerMultiItem(new ItemUmbrella(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  portalEnchanter=registerItem(new ItemPortalEnchanter(),""String_Node_Str"");
  shellFrox=registerItem(new ItemShell(),""String_Node_Str"");
  shellPab=registerItem(new ItemShell(),""String_Node_Str"");
  shellRube=registerItem(new ItemShell(),""String_Node_Str"");
  shellSolo=registerItem(new ItemShell(),""String_Node_Str"");
  shellStarfish=registerItem(new ItemShell(),""String_Node_Str"");
  shellTurtle=registerItem(new ItemShell(),""String_Node_Str"");
  cocktail=registerMultiItem(new ItemCocktail(),""String_Node_Str"",Drink.drinkList.length);
  whitePearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  blackPearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  fertilizer=registerItem(new ItemFertilizer(),""String_Node_Str"");
  encyclopedia=registerItem(new ItemEncyclopediaTropica(""String_Node_Str""),""String_Node_Str"");
  dagger=registerItem(new ItemDagger(materialZirconTools),""String_Node_Str"");
  bambooSpear=registerItem(new ItemSword(materialBambooTools),""String_Node_Str"");
  coconutBomb=registerItem(new ItemCoconutBomb(),""String_Node_Str"");
  flowerPot=registerItem(new ItemTropicraftBlockSpecial(BlockRegistry.flowerPot),""String_Node_Str"");
  bambooDoor=registerItem(new ItemDoor(BlockRegistry.bambooDoor),""String_Node_Str"");
  bambooItemFrame=registerItem(new ItemBambooItemFrame(EntityBambooItemFrame.class),""String_Node_Str"");
  Tropicraft.proxy.registerArbitraryBlockVariants(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  waterWand=registerItem(new ItemWaterWand(),""String_Node_Str"");
  seaUrchinRoe=registerItem(new ItemTropicraftFood(3,0.3F),""String_Node_Str"");
  mobEgg=registerMultiItem(new ItemMobEgg(),""String_Node_Str"",Names.EGG_NAMES);
}","public static void preInit(){
  recordBuriedTreasure=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordEasternIsles=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordSummering=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTheTribe=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordLowTide=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  recordTradeWinds=registerItem(new ItemMusicDisc(""String_Node_Str"",""String_Node_Str"",SoundRegistry.get(""String_Node_Str"")),""String_Node_Str"");
  azurite=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  eudialyte=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  zircon=registerItem(new ItemTropicsOre(),""String_Node_Str"");
  grapefruit=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lemon=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  lime=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  orange=registerItem(new ItemTropicraftFood(2,0.2F),""String_Node_Str"");
  hoeEudialyte=registerItem(new ItemHoe(materialEudialyteTools),""String_Node_Str"");
  hoeZircon=registerItem(new ItemHoe(materialZirconTools),""String_Node_Str"");
  pickaxeEudialyte=registerItem(new ItemTropicraftPickaxe(materialEudialyteTools),""String_Node_Str"");
  pickaxeZircon=registerItem(new ItemTropicraftPickaxe(materialZirconTools),""String_Node_Str"");
  shovelEudialyte=registerItem(new ItemSpade(materialEudialyteTools),""String_Node_Str"");
  shovelZircon=registerItem(new ItemSpade(materialZirconTools),""String_Node_Str"");
  axeEudialyte=registerItem(new ItemTropicraftAxe(materialEudialyteTools,6.0F,-3.1F),""String_Node_Str"");
  axeZircon=registerItem(new ItemTropicraftAxe(materialZirconTools,6.0F,-3.2F),""String_Node_Str"");
  swordEudialyte=registerItem(new ItemSword(materialEudialyteTools),""String_Node_Str"");
  swordZircon=registerItem(new ItemSword(materialZirconTools),""String_Node_Str"");
  fishingNet=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooShoot=registerItem(new ItemBlockSpecial(BlockRegistry.bambooShoot),""String_Node_Str"");
  bambooStick=registerItem(new ItemTropicraft(),""String_Node_Str"");
  bambooMug=registerItem(new ItemTropicraft().setMaxStackSize(16),""String_Node_Str"");
  freshMarlin=registerItem(new ItemTropicraftFood(2,0.3F),""String_Node_Str"");
  searedMarlin=registerItem(new ItemTropicraftFood(8,0.65F),""String_Node_Str"");
  tropicsWaterBucket=registerItem((new ItemBucket(BlockRegistry.tropicsWater)).setContainerItem(Items.BUCKET),""String_Node_Str"");
  fishBucket=registerItem(new ItemFishBucket(),""String_Node_Str"");
  coconutChunk=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  pineappleCubes=registerItem(new ItemTropicraftFood(1,0.1F),""String_Node_Str"");
  coffeeBeans=registerMultiItem(new ItemCoffeeBean(Names.COFFEE_NAMES,BlockRegistry.coffeePlant),""String_Node_Str"",Names.COFFEE_NAMES);
  frogLeg=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  cookedFrogLeg=registerItem(new ItemTropicraftFood(2,0.15F),""String_Node_Str"");
  poisonFrogSkin=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scale=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  scaleBoots=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.FEET),""String_Node_Str"");
  scaleLeggings=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.LEGS),""String_Node_Str"");
  scaleChestplate=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.CHEST),""String_Node_Str"");
  scaleHelmet=registerItem(new ItemScaleArmor(materialScaleArmor,0,EntityEquipmentSlot.HEAD),""String_Node_Str"");
  chair=registerMultiItem(new ItemChair(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  umbrella=registerMultiItem(new ItemUmbrella(),""String_Node_Str"",ItemDye.DYE_COLORS.length);
  portalEnchanter=registerItem(new ItemPortalEnchanter(),""String_Node_Str"");
  shellFrox=registerItem(new ItemShell(),""String_Node_Str"");
  shellPab=registerItem(new ItemShell(),""String_Node_Str"");
  shellRube=registerItem(new ItemShell(),""String_Node_Str"");
  shellSolo=registerItem(new ItemShell(),""String_Node_Str"");
  shellStarfish=registerItem(new ItemShell(),""String_Node_Str"");
  shellTurtle=registerItem(new ItemShell(),""String_Node_Str"");
  cocktail=registerMultiItem(new ItemCocktail(),""String_Node_Str"",Drink.drinkList.length);
  whitePearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  blackPearl=registerItem(new ItemTropicraft().setMaxStackSize(64),""String_Node_Str"");
  fertilizer=registerItem(new ItemFertilizer(),""String_Node_Str"");
  encyclopedia=registerItem(new ItemEncyclopediaTropica(""String_Node_Str""),""String_Node_Str"");
  dagger=registerItem(new ItemDagger(materialZirconTools),""String_Node_Str"");
  bambooSpear=registerItem(new ItemSword(materialBambooTools),""String_Node_Str"");
  coconutBomb=registerItem(new ItemCoconutBomb(),""String_Node_Str"");
  flowerPot=registerItem(new ItemTropicraftBlockSpecial(BlockRegistry.flowerPot),""String_Node_Str"");
  bambooDoor=registerItem(new ItemDoor(BlockRegistry.bambooDoor),""String_Node_Str"");
  bambooItemFrame=registerItem(new ItemBambooItemFrame(EntityBambooItemFrame.class),""String_Node_Str"");
  Tropicraft.proxy.registerArbitraryBlockVariants(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  waterWand=registerItem(new ItemWaterWand(),""String_Node_Str"");
  seaUrchinRoe=registerItem(new ItemTropicraftFood(3,0.3F),""String_Node_Str"");
  mobEgg=registerMultiItemPrefixed(new ItemMobEgg(),""String_Node_Str"",Names.EGG_NAMES);
}",0.9993288590604028
109850,"@Override public void updateTick(World worldIn,BlockPos pos,IBlockState state,Random rand){
  if (worldIn.isAirBlock(pos.up())) {
    int height;
    BlockPos ground=pos;
    for (height=1; worldIn.getBlockState(ground=ground.down()).getBlock() == this; ++height)     ;
    if (height < MAX_HEIGHT) {
      worldIn.setBlockState(pos.up(),getDefaultState());
    }
  }
  super.updateTick(worldIn,pos,state,rand);
}","@Override public void updateTick(World worldIn,BlockPos pos,IBlockState state,Random rand){
  if (worldIn.isAirBlock(pos.up())) {
    int height;
    BlockPos ground=pos;
    for (height=1; worldIn.getBlockState(ground=ground.down()).getBlock() == this; ++height)     ;
    if (height < MAX_HEIGHT && worldIn.rand.nextInt(worldIn.getBlockState(ground).getBlock().isFertile(worldIn,ground) ? GROWTH_RATE_FERTILE : GROWTH_RATE_INFERTILE) == 0) {
      worldIn.setBlockState(pos.up(),getDefaultState());
    }
  }
  super.updateTick(worldIn,pos,state,rand);
}",0.8524251805985552
109851,"@Override public int getColorFromItemstack(ItemStack stack,int tintIndex){
  return SandColors.getColor(tintIndex);
}","@Override public int getColorFromItemstack(ItemStack stack,int tintIndex){
  return SandColors.getColor(tintIndex - 1);
}",0.9831932773109244
109852,"private void checkMouseHover(ItemStack itemstack,int k,int l,int size){
  float scale;
switch (mc.gameSettings.guiScale) {
case 1:
    scale=4F;
  break;
case 2:
scale=2F;
break;
case 3:
scale=3F;
break;
default :
scale=2F;
}
int i=(int)(Mouse.getEventX() / scale);
int j=(int)(height - Mouse.getEventY() / scale);
boolean flag=(i >= k && j >= l && i < k + size && j < l + size);
if (itemstack != null && flag) {
String s=itemstack.getItem().getItemStackDisplayName(itemstack);
if (s.length() > 0) {
RenderHelper.disableStandardItemLighting();
GlStateManager.disableLighting();
GlStateManager.disableDepth();
int l2=fontRendererObj.getStringWidth(s);
int i2=i - l2 - 4;
int k2=j;
drawGradientRect(i2 - 3,k2 - 3,i2 + l2 + 3,k2 + 8 + 3,0xc0000000,0xc0000000);
fontRendererObj.drawStringWithShadow(s,i2,k2,-1);
GlStateManager.enableLighting();
GlStateManager.enableDepth();
}
}
}","/** 
 * Draw the name of an item when it's hovered over in game
 * @param itemstack ItemStack being hovered over
 * @param k x coord
 * @param l y coord
 * @param size size...of something idk what :D
 */
private void checkMouseHover(ItemStack itemstack,int k,int l,int size){
  int i=Mouse.getEventX() * this.width / this.mc.displayWidth;
  int j=this.height - Mouse.getEventY() * this.height / this.mc.displayHeight - 1;
  boolean flag=(i >= k && j >= l && i < k + size && j < l + size);
  if (itemstack != null && flag) {
    String s=itemstack.getItem().getItemStackDisplayName(itemstack);
    if (s.length() > 0) {
      RenderHelper.disableStandardItemLighting();
      GlStateManager.disableLighting();
      GlStateManager.disableDepth();
      int l2=fontRendererObj.getStringWidth(s);
      int i2=i - l2 - 4;
      int k2=j;
      drawGradientRect(i2 - 3,k2 - 3,i2 + l2 + 3,k2 + 8 + 3,0xc0000000,0xc0000000);
      fontRendererObj.drawStringWithShadow(s,i2,k2,-1);
      GlStateManager.enableLighting();
      GlStateManager.enableDepth();
    }
  }
}",0.7072792978833248
109853,"private void printRecipes() throws Exception {
  List<ShapedRecipes> recipes=((Encyclopedia)book).getRecipesForEntry(selectedIndex);
  if (recipes == null || recipes.isEmpty()) {
    return;
  }
  int newx=width / 2 + 25;
  int newy=height / 2 - 80;
  int indexPosition=0;
  for (int entry=contentPage * book.entriesPerContentPage(contentMode); entry < (contentPage + 1) * book.entriesPerContentPage(contentMode); entry++) {
    if (entry >= book.getContentPageCount(selectedIndex,contentMode)) {
      return;
    }
    Encyclopedia.RecipeEntry recipe=((Encyclopedia)book).getFormattedRecipe(recipes.get(entry));
    TropicraftRenderUtils.bindTextureGui(openTextureIndex);
    drawTexturedModalRect(newx - 3,newy - 3,0,187,122,60);
    int offsetX=18;
    int offsetY=18;
    for (int row=0; row < recipe.height; row++) {
      for (int col=0; col < recipe.width; col++) {
        int itemIndex=(row * recipe.width) + col;
        if (recipe.ingredients[itemIndex] != null) {
          int renderX=newx + (offsetX * col) + 1;
          int renderY=newy + (offsetY * row) + 1;
          GlStateManager.pushMatrix();
          GlStateManager.enableRescaleNormal();
          RenderHelper.enableGUIStandardItemLighting();
          itemRenderer.isNotRenderingEffectsInGUI(true);
          itemRenderer.renderItemIntoGUI(recipe.ingredients[itemIndex],renderX,renderY);
          itemRenderer.isNotRenderingEffectsInGUI(false);
          RenderHelper.disableStandardItemLighting();
          GlStateManager.disableRescaleNormal();
          GlStateManager.popMatrix();
        }
      }
    }
    for (int row=0; row < recipe.height; row++) {
      for (int col=0; col < recipe.width; col++) {
        int itemIndex=(row * recipe.width) + col;
        int renderX=newx + (offsetX * col) + 1;
        int renderY=newy + (offsetY * row) + 1;
        checkMouseHover(recipe.ingredients[itemIndex],renderX,renderY,18);
      }
    }
    GlStateManager.pushMatrix();
    GlStateManager.scale(1.5F,1.5F,1.5F);
    GlStateManager.translate(newx / 3F + 1F,newy / 3F - .75F,0F);
    GlStateManager.enableRescaleNormal();
    RenderHelper.enableGUIStandardItemLighting();
    itemRenderer.renderItemIntoGUI(recipe.output,newx / 3 + 60,newy / 3 + 11);
    itemRenderer.renderItemOverlayIntoGUI(fontRendererObj,recipe.output,newx / 3 + 60,newy / 3 + 11,recipe.output.getDisplayName());
    RenderHelper.disableStandardItemLighting();
    GlStateManager.disableRescaleNormal();
    GlStateManager.popMatrix();
    GlStateManager.pushMatrix();
    checkMouseHover(recipe.output,newx + 90,newy + 20,25);
    GlStateManager.popMatrix();
    indexPosition++;
    newy+=62;
  }
}","private void printRecipes() throws Exception {
  List<ShapedRecipes> recipes=((Encyclopedia)book).getRecipesForEntry(selectedIndex);
  if (recipes == null || recipes.isEmpty()) {
    return;
  }
  int newx=width / 2 + 25;
  int newy=height / 2 - 80;
  int indexPosition=0;
  for (int entry=contentPage * book.entriesPerContentPage(contentMode); entry < (contentPage + 1) * book.entriesPerContentPage(contentMode); entry++) {
    if (entry >= book.getContentPageCount(selectedIndex,contentMode)) {
      return;
    }
    Encyclopedia.RecipeEntry recipe=((Encyclopedia)book).getFormattedRecipe(recipes.get(entry));
    TropicraftRenderUtils.bindTextureGui(openTextureIndex);
    drawTexturedModalRect(newx - 3,newy - 3,0,187,122,60);
    int offsetX=18;
    int offsetY=18;
    for (int row=0; row < recipe.height; row++) {
      for (int col=0; col < recipe.width; col++) {
        int itemIndex=(row * recipe.width) + col;
        if (recipe.ingredients[itemIndex] != null) {
          int renderX=newx + (offsetX * col) + 1;
          int renderY=newy + (offsetY * row) + 1;
          GlStateManager.pushMatrix();
          GlStateManager.enableRescaleNormal();
          RenderHelper.enableGUIStandardItemLighting();
          itemRenderer.isNotRenderingEffectsInGUI(true);
          itemRenderer.renderItemIntoGUI(recipe.ingredients[itemIndex],renderX,renderY);
          itemRenderer.isNotRenderingEffectsInGUI(false);
          RenderHelper.disableStandardItemLighting();
          GlStateManager.disableRescaleNormal();
          GlStateManager.popMatrix();
        }
      }
    }
    for (int row=0; row < recipe.height; row++) {
      for (int col=0; col < recipe.width; col++) {
        int itemIndex=(row * recipe.width) + col;
        int renderX=newx + (offsetX * col) + 1;
        int renderY=newy + (offsetY * row) + 1;
        checkMouseHover(recipe.ingredients[itemIndex],renderX,renderY,18);
      }
    }
    GlStateManager.pushMatrix();
    GlStateManager.scale(1.5F,1.5F,1.5F);
    GlStateManager.translate(newx / 3F + 1F,newy / 3F - .75F,0F);
    GlStateManager.enableRescaleNormal();
    RenderHelper.enableGUIStandardItemLighting();
    itemRenderer.renderItemIntoGUI(recipe.output,newx / 3 + 60,newy / 3 + 11);
    itemRenderer.renderItemOverlayIntoGUI(fontRendererObj,recipe.output,newx / 3 + 60,newy / 3 + 11,""String_Node_Str"");
    RenderHelper.disableStandardItemLighting();
    GlStateManager.disableRescaleNormal();
    GlStateManager.popMatrix();
    GlStateManager.pushMatrix();
    checkMouseHover(recipe.output,newx + 90,newy + 20,25);
    GlStateManager.popMatrix();
    indexPosition++;
    newy+=62;
  }
}",0.9915110356536504
109854,"@Override public void onBlockDestroyedByPlayer(World world,BlockPos pos,IBlockState state){
  if (!world.isRemote) {
    TorchSection section=state.getValue(SECTION);
    if (section == TorchSection.LOWER) {
      dropBlockAsItem(world,pos,state,0);
      world.setBlockToAir(pos.up());
      world.setBlockToAir(pos.up(2));
    }
 else     if (section == TorchSection.MIDDLE) {
      dropBlockAsItem(world,pos.down(),world.getBlockState(pos.down()),0);
      world.setBlockToAir(pos.down());
      world.setBlockToAir(pos.up());
    }
 else {
      dropBlockAsItem(world,pos.down(2),world.getBlockState(pos.down(2)),0);
      world.setBlockToAir(pos.down());
      world.setBlockToAir(pos.down(2));
    }
  }
}","@Override public void onBlockDestroyedByPlayer(World world,BlockPos pos,IBlockState state){
  if (!world.isRemote) {
    TorchSection section=state.getValue(SECTION);
    if (section == TorchSection.LOWER) {
      dropBlockAsItem(world,pos,state,0);
      if (world.getBlockState(pos.up()).getBlock() == this) {
        world.setBlockToAir(pos.up());
      }
      if (world.getBlockState(pos.up(2)).getBlock() == this) {
        world.setBlockToAir(pos.up(2));
      }
    }
 else     if (section == TorchSection.MIDDLE) {
      dropBlockAsItem(world,pos.down(),world.getBlockState(pos.down()),0);
      if (world.getBlockState(pos.down()).getBlock() == this) {
        world.setBlockToAir(pos.down());
      }
      if (world.getBlockState(pos.up()).getBlock() == this) {
        world.setBlockToAir(pos.up());
      }
    }
 else {
      dropBlockAsItem(world,pos.down(2),world.getBlockState(pos.down(2)),0);
      if (world.getBlockState(pos.down()).getBlock() == this) {
        world.setBlockToAir(pos.down());
      }
      if (world.getBlockState(pos.down(2)).getBlock() == this) {
        world.setBlockToAir(pos.down(2));
      }
    }
  }
}",0.7636949516648764
109855,"public void genDecorations(Biome biome,World world,Random rand){
  int i=0;
  int k=0;
  if (BiomeGenTropicraft.DISABLEDECORATION) {
    System.out.println(""String_Node_Str"" + this);
    return;
  }
  if (ConfigGenRates.BAMBOO_CHANCE != 0 && rand.nextInt(ConfigGenRates.BAMBOO_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenBamboo(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.NORMAL_PALM_CHANCE != 0 && rand.nextInt(ConfigGenRates.NORMAL_PALM_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenNormalPalms(world,rand).generate(new BlockPos(i,this.getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.CURVED_PALM_CHANCE != 0 && rand.nextInt(ConfigGenRates.CURVED_PALM_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenCurvedPalms(world,rand).generate(new BlockPos(i,this.getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.EIH_CHANCE != 0 && rand.nextInt(ConfigGenRates.EIH_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenEIH(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  i=randCoord(rand,chunkPos.getX(),16);
  k=randCoord(rand,chunkPos.getZ(),16);
  new WorldGenTropicalFlowers(world,rand,BlockRegistry.flowers).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  if (ConfigGenRates.LARGE_PALM_CHANCE != 0 && rand.nextInt(ConfigGenRates.LARGE_PALM_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenLargePalmTrees(world,rand).generate(world,rand,new BlockPos(i,this.getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.FRUIT_TREE_CHANCE != 0 && rand.nextInt(ConfigGenRates.FRUIT_TREE_CHANCE) == 0) {
    int treeType=new Random((long)(chunkPos.getX() >> 2) << 32 | (long)(chunkPos.getZ() >> 2)).nextInt(4);
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenFruitTrees(world,rand,treeType).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.TALL_GRASS_CHANCE != 0 && rand.nextInt(ConfigGenRates.TALL_GRASS_CHANCE) == 0) {
    for (int a=0; a < 10; a++) {
      int xRand=rand.nextInt(16) + 8;
      int zRand=rand.nextInt(16) + 8;
      int yRand=world.getHeight(this.chunkPos.add(xRand,0,zRand)).getY() * 2;
      if (yRand > 0) {
        int rando=rand.nextInt(yRand);
        biome.getRandomWorldGenForGrass(rand).generate(world,rand,this.chunkPos.add(xRand,rando,zRand));
      }
    }
  }
}","public void genDecorations(Biome biome,World world,Random rand){
  int i=0;
  int k=0;
  if (BiomeGenTropicraft.DISABLEDECORATION) {
    System.out.println(""String_Node_Str"" + this);
    return;
  }
  if (ConfigGenRates.BAMBOO_CHANCE != 0 && rand.nextInt(ConfigGenRates.BAMBOO_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenBamboo(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.NORMAL_PALM_CHANCE != 0 && rand.nextInt(ConfigGenRates.NORMAL_PALM_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenNormalPalms(world,rand).generate(new BlockPos(i,this.getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.CURVED_PALM_CHANCE != 0 && rand.nextInt(ConfigGenRates.CURVED_PALM_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenCurvedPalms(world,rand).generate(new BlockPos(i,this.getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.EIH_CHANCE != 0 && rand.nextInt(ConfigGenRates.EIH_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenEIH(world,rand).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  i=randCoord(rand,chunkPos.getX(),16);
  k=randCoord(rand,chunkPos.getZ(),16);
  new WorldGenTropicalFlowers(world,rand,BlockRegistry.flowers).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  if (ConfigGenRates.LARGE_PALM_CHANCE != 0 && rand.nextInt(ConfigGenRates.LARGE_PALM_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenLargePalmTrees(world,rand).generate(world,rand,new BlockPos(i,this.getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.FRUIT_TREE_CHANCE != 0 && rand.nextInt(ConfigGenRates.FRUIT_TREE_CHANCE) == 0) {
    int treeType=new Random((long)(chunkPos.getX() >> 2) << 32 | (long)(chunkPos.getZ() >> 2)).nextInt(4);
    i=randCoord(rand,chunkPos.getX(),16);
    k=randCoord(rand,chunkPos.getZ(),16);
    new WorldGenFruitTrees(world,rand,treeType).generate(new BlockPos(i,getTerrainHeightAt(world,i,k),k));
  }
  if (ConfigGenRates.TALL_GRASS_CHANCE != 0 && rand.nextInt(ConfigGenRates.TALL_GRASS_CHANCE) == 0) {
    for (int a=0; a < 10; a++) {
      int xRand=rand.nextInt(16) + 8;
      int zRand=rand.nextInt(16) + 8;
      int yRand=world.getHeight(this.chunkPos.add(xRand,0,zRand)).getY() * 2;
      if (yRand > 0) {
        int rando=rand.nextInt(yRand);
        biome.getRandomWorldGenForGrass(rand).generate(world,rand,this.chunkPos.add(xRand,rando,zRand));
      }
    }
  }
  if (ConfigGenRates.TALL_FLOWERS_CHANCE != 0 && rand.nextInt(ConfigGenRates.TALL_FLOWERS_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    int y=getTerrainHeightAt(world,i,k);
    k=randCoord(rand,chunkPos.getZ(),16);
    BlockPos pos=new BlockPos(i,y,k);
    (new WorldGenTallFlower(world,rand,BlockRegistry.pineapple.getDefaultState())).generate(pos);
  }
  if (ConfigGenRates.TALL_FLOWERS_CHANCE != 0 && rand.nextInt(ConfigGenRates.TALL_FLOWERS_CHANCE) == 0) {
    i=randCoord(rand,chunkPos.getX(),16);
    int y=getTerrainHeightAt(world,i,k);
    k=randCoord(rand,chunkPos.getZ(),16);
    BlockPos pos=new BlockPos(i,y,k);
    (new WorldGenTallFlower(world,rand,BlockRegistry.iris.getDefaultState())).generate(pos);
  }
}",0.8808407437348423
109856,"@Override public boolean receiveClientEvent(int id,int type){
  System.out.println(""String_Node_Str"");
  return super.receiveClientEvent(id,type);
}","@Override public boolean receiveClientEvent(int id,int type){
  return super.receiveClientEvent(id,type);
}",0.8392156862745098
109857,"@Override public void update(){
  if (!worldObj.isRemote) {
    System.out.println(radius + ""String_Node_Str"" + pos.getX()+ ""String_Node_Str""+ pos.getZ()+ ""String_Node_Str""+ state+ ""String_Node_Str""+ lavaLevel);
    System.out.println(""String_Node_Str"" + ticksUntilSmoking + ""String_Node_Str""+ ticksUntilRising+ ""String_Node_Str""+ ticksUntilEruption+ ""String_Node_Str""+ ticksUntilRetreating+ ""String_Node_Str""+ ticksUntilDormant);
  }
  if (radius == -1) {
    radius=findRadius();
  }
  if (lavaLevel == -1) {
    setLavaLevel();
  }
  updateStates();
switch (state) {
case DORMANT:
    break;
case ERUPTING:
  if (!worldObj.isRemote) {
    if (worldObj.rand.nextInt(15) == 0)     throwLavaFromCaldera((worldObj.rand.nextDouble() * 0.5) + (lavaLevel > 90 ? 1 : 0.75));
    if (worldObj.rand.nextInt(15) == 0)     throwLavaFromCaldera((worldObj.rand.nextDouble() * 0.5) + (lavaLevel > 90 ? 1 : 0.75));
  }
break;
case RETREATING:
if (ticksUntilDormant % 30 == 0) {
lowerLavaLevels();
}
break;
case RISING:
if (worldObj.isRemote) {
spewSmoke();
}
if (ticksUntilEruption % 20 == 0) {
if (lavaLevel < MAX_LAVA_LEVEL_DURING_ERUPTION) {
raiseLavaLevels();
}
 else {
ticksUntilEruption=0;
worldObj.playSound(this.pos.getX(),73,this.pos.getY(),SoundEvents.ENTITY_GENERIC_EXPLODE,SoundCategory.NEUTRAL,1.0F,worldObj.rand.nextFloat() / 4 + 0.825F,false);
int balls=worldObj.rand.nextInt(25) + 15;
for (int i=0; i < balls; i++) {
throwLavaFromCaldera((worldObj.rand.nextDouble() * 0.5) + 1.25);
}
break;
}
}
break;
case SMOKING:
if (worldObj.isRemote) {
spewSmoke();
}
break;
default :
break;
}
}","@Override public void update(){
  if (!worldObj.isRemote) {
  }
  if (radius == -1) {
    radius=findRadius();
  }
  if (lavaLevel == -1) {
    setLavaLevel();
  }
  updateStates();
switch (state) {
case DORMANT:
    break;
case ERUPTING:
  if (!worldObj.isRemote) {
    if (worldObj.rand.nextInt(15) == 0)     throwLavaFromCaldera((worldObj.rand.nextDouble() * 0.5) + (lavaLevel > 90 ? 1 : 0.75));
    if (worldObj.rand.nextInt(15) == 0)     throwLavaFromCaldera((worldObj.rand.nextDouble() * 0.5) + (lavaLevel > 90 ? 1 : 0.75));
  }
break;
case RETREATING:
if (ticksUntilDormant % 30 == 0) {
lowerLavaLevels();
}
break;
case RISING:
if (worldObj.isRemote) {
spewSmoke();
}
if (ticksUntilEruption % 20 == 0) {
if (lavaLevel < MAX_LAVA_LEVEL_DURING_ERUPTION) {
raiseLavaLevels();
}
 else {
ticksUntilEruption=0;
worldObj.playSound(this.pos.getX(),73,this.pos.getY(),SoundEvents.ENTITY_GENERIC_EXPLODE,SoundCategory.NEUTRAL,1.0F,worldObj.rand.nextFloat() / 4 + 0.825F,false);
int balls=worldObj.rand.nextInt(25) + 15;
for (int i=0; i < balls; i++) {
throwLavaFromCaldera((worldObj.rand.nextDouble() * 0.5) + 1.25);
}
break;
}
}
break;
case SMOKING:
if (worldObj.isRemote) {
spewSmoke();
}
break;
default :
break;
}
}",0.867547304534095
109858,"@SubscribeEvent public void handlePineappleBreakEvent(HarvestDropsEvent event){
  World world=event.getWorld();
  Block block=event.getState().getBlock();
  int stage=event.getState().getValue(BlockPineapple.STAGE);
  boolean isFullyGrown=((BlockTallPlant.PlantHalf)event.getState().getValue(BlockPineapple.HALF)) == BlockTallPlant.PlantHalf.UPPER && stage >= BlockPineapple.TOTAL_GROW_TICKS;
  int x=event.getPos().getX();
  int y=event.getPos().getY();
  int z=event.getPos().getZ();
  EntityPlayer player=event.getHarvester();
  if (world.isRemote) {
    return;
  }
  if (block != BlockRegistry.pineapple) {
    return;
  }
  ItemStack handItemStack=getPlayerItem(world,player);
  Item inHand;
  if (handItemStack != null)   inHand=handItemStack.getItem();
 else   inHand=null;
  ItemStack drop=null;
  if (inHand != null && (inHand instanceof ItemSword || inHand.getItemUseAction(new ItemStack(inHand)) == EnumAction.BLOCK)) {
    drop=new ItemStack(ItemRegistry.pineappleCubes);
  }
 else {
    drop=new ItemStack(block,1,0);
  }
  int numDrops=isFullyGrown && drop.getItem() == ItemRegistry.pineappleCubes ? world.rand.nextInt(3) + 2 : 1;
  if (isFullyGrown) {
    world.setBlockState(event.getPos().down(),event.getState().withProperty(BlockPineapple.STAGE,Integer.valueOf(1)));
    world.setBlockToAir(event.getPos());
    for (int i=0; i < numDrops; i++) {
      dropBlockAsItem(world,x,y,z,drop);
    }
  }
 else   if (stage < BlockPineapple.TOTAL_GROW_TICKS) {
    IBlockState stateUp=world.getBlockState(event.getPos().up());
    if (stateUp.getBlock() instanceof BlockPineapple) {
      boolean aboveBlockFullyGrown=stateUp.getValue(BlockPineapple.STAGE) > BlockPineapple.TOTAL_GROW_TICKS;
      if (aboveBlockFullyGrown) {
        world.setBlockToAir(event.getPos().up());
        dropBlockAsItem(world,x,y + 1,z,drop);
      }
 else {
        world.setBlockToAir(event.getPos());
      }
    }
  }
 else {
    world.setBlockToAir(event.getPos());
    world.setBlockToAir(event.getPos().down());
  }
}","@SubscribeEvent public void handlePineappleBreakEvent(HarvestDropsEvent event){
  World world=event.getWorld();
  Block block=event.getState().getBlock();
  if (world.isRemote) {
    return;
  }
  if (block != BlockRegistry.pineapple) {
    return;
  }
  int stage=event.getState().getValue(BlockPineapple.STAGE);
  boolean isFullyGrown=((BlockTallPlant.PlantHalf)event.getState().getValue(BlockPineapple.HALF)) == BlockTallPlant.PlantHalf.UPPER && stage >= BlockPineapple.TOTAL_GROW_TICKS;
  int x=event.getPos().getX();
  int y=event.getPos().getY();
  int z=event.getPos().getZ();
  EntityPlayer player=event.getHarvester();
  ItemStack handItemStack=getPlayerItem(world,player);
  Item inHand;
  if (handItemStack != null)   inHand=handItemStack.getItem();
 else   inHand=null;
  ItemStack drop=null;
  if (inHand != null && (inHand instanceof ItemSword || inHand.getItemUseAction(new ItemStack(inHand)) == EnumAction.BLOCK)) {
    drop=new ItemStack(ItemRegistry.pineappleCubes);
  }
 else {
    drop=new ItemStack(block,1,0);
  }
  int numDrops=isFullyGrown && drop.getItem() == ItemRegistry.pineappleCubes ? world.rand.nextInt(3) + 2 : 1;
  if (isFullyGrown) {
    world.setBlockState(event.getPos().down(),event.getState().withProperty(BlockPineapple.STAGE,Integer.valueOf(1)));
    world.setBlockToAir(event.getPos());
    for (int i=0; i < numDrops; i++) {
      dropBlockAsItem(world,x,y,z,drop);
    }
  }
 else   if (stage < BlockPineapple.TOTAL_GROW_TICKS) {
    IBlockState stateUp=world.getBlockState(event.getPos().up());
    if (stateUp.getBlock() instanceof BlockPineapple) {
      boolean aboveBlockFullyGrown=stateUp.getValue(BlockPineapple.STAGE) > BlockPineapple.TOTAL_GROW_TICKS;
      if (aboveBlockFullyGrown) {
        world.setBlockToAir(event.getPos().up());
        dropBlockAsItem(world,x,y + 1,z,drop);
      }
 else {
        world.setBlockToAir(event.getPos());
      }
    }
  }
 else {
    world.setBlockToAir(event.getPos());
    world.setBlockToAir(event.getPos().down());
  }
}",0.9513888888888888
109859,"@Override public boolean generate(BlockPos pos){
  int i=pos.getX();
  int j=pos.getY();
  int k=pos.getZ();
  Block blockUnder=getBlock(i,j - 1,k);
  if (blockUnder != Blocks.SAND) {
    return false;
  }
  int height=9 + rand.nextInt(3);
  int dir=this.pickDirection(i,j,k);
  this.setDir(dir);
  this.setOrigin(i,k);
  for (int x=0; x < 4; x++) {
    for (int y=0; y < height; y++) {
      if (this.getBlockWithDir(x,y + j,0) != Blocks.AIR) {
        return false;
      }
    }
  }
  for (int x=0; x < 9; x++) {
    for (int z=0; z < 9; z++) {
      for (int y=height - 3; y < height + 4; y++) {
        if (this.getBlockWithDir(x + TOP_OFFSET,y + j,z) != Blocks.AIR) {
          return false;
        }
      }
    }
  }
  for (int x=0, y=0; y < height; y++) {
    this.placeBlockWithDir(x,y + j,0,woodState);
    if (y == 0 || y == 1 || y == 3) {
      x++;
      this.placeBlockWithDir(x,y + j,0,woodState);
    }
  }
  this.setOrigin(this.getActualXAt(TOP_OFFSET,0),this.getActualZAt(TOP_OFFSET,0));
  for (int y=1; y < 5; y++) {
    if (y == 4) {
      this.placeBlockWithDir(1,y + j + height - 1,0,leafState);
    }
 else {
      this.placeBlockWithDir(0,y + j + height - 1,0,leafState);
    }
  }
  for (int curDir=0; curDir < 4; curDir++) {
    this.setDir(curDir);
    int y=height - 1;
    this.placeBlockWithDir(1,y - 1 + j,1,leafState);
    this.placeBlockWithDir(2,y - 2 + j,1,leafState);
    this.placeBlockWithDir(1,y - 2 + j,2,leafState);
    this.placeBlockWithDir(2,y - 3 + j,2,leafState);
    this.placeBlockWithDir(1,y + 1 + j,1,leafState);
    this.placeBlockWithDir(2,y + 2 + j,1,leafState);
    this.placeBlockWithDir(1,y + 2 + j,2,leafState);
    this.placeBlockWithDir(2,y + 3 + j,2,leafState);
    System.out.println(""String_Node_Str"" + this.getActualXAt(1,1) + ""String_Node_Str""+ this.getActualZAt(1,1)+ ""String_Node_Str""+ curDir);
    for (int x=1; x < 5; x++) {
      if (x == 4) {
        y--;
      }
      this.placeBlockWithDir(x,y + j,0,leafState);
    }
  }
  return true;
}","@Override public boolean generate(BlockPos pos){
  int i=pos.getX();
  int j=pos.getY();
  int k=pos.getZ();
  Block blockUnder=getBlock(i,j - 1,k);
  if (blockUnder != Blocks.SAND) {
    return false;
  }
  int height=9 + rand.nextInt(3);
  int dir=this.pickDirection(i,j,k);
  this.setDir(dir);
  this.setOrigin(i,k);
  for (int x=0; x < 4; x++) {
    for (int y=0; y < height; y++) {
      if (this.getBlockWithDir(x,y + j,0) != Blocks.AIR) {
        return false;
      }
    }
  }
  for (int x=0; x < 9; x++) {
    for (int z=0; z < 9; z++) {
      for (int y=height - 3; y < height + 4; y++) {
        if (this.getBlockWithDir(x + TOP_OFFSET,y + j,z) != Blocks.AIR) {
          return false;
        }
      }
    }
  }
  for (int x=0, y=0; y < height; y++) {
    this.placeBlockWithDir(x,y + j,0,woodState);
    if (y == 0 || y == 1 || y == 3) {
      x++;
      this.placeBlockWithDir(x,y + j,0,woodState);
    }
  }
  this.setOrigin(this.getActualXAt(TOP_OFFSET,0),this.getActualZAt(TOP_OFFSET,0));
  for (int y=1; y < 5; y++) {
    if (y == 4) {
      this.placeBlockWithDir(1,y + j + height - 1,0,leafState);
    }
 else {
      this.placeBlockWithDir(0,y + j + height - 1,0,leafState);
    }
  }
  for (int curDir=0; curDir < 4; curDir++) {
    this.setDir(curDir);
    int y=height - 1;
    this.placeBlockWithDir(1,y - 1 + j,1,leafState);
    this.placeBlockWithDir(2,y - 2 + j,1,leafState);
    this.placeBlockWithDir(1,y - 2 + j,2,leafState);
    this.placeBlockWithDir(2,y - 3 + j,2,leafState);
    this.placeBlockWithDir(1,y + 1 + j,1,leafState);
    this.placeBlockWithDir(2,y + 2 + j,1,leafState);
    this.placeBlockWithDir(1,y + 2 + j,2,leafState);
    this.placeBlockWithDir(2,y + 3 + j,2,leafState);
    for (int x=1; x < 5; x++) {
      if (x == 4) {
        y--;
      }
      this.placeBlockWithDir(x,y + j,0,leafState);
    }
  }
  return true;
}",0.964239773604322
109860,"public static DateTime longToDateTime(long l){
  return new org.joda.time.DateTime(l);
}","@Nullable public static DateTime longToDateTime(@Nullable Long l){
  if (l == null) {
    return null;
  }
  return new org.joda.time.DateTime(l);
}",0.7457627118644068
109861,"public static long dateTimeToLong(@Nonnull DateTime d){
  return d.getMillis();
}","@Nullable public static Long dateTimeToLong(@Nullable DateTime d){
  if (d == null) {
    return null;
  }
  return d.getMillis();
}",0.7230046948356808
109862,"public static long dateTimeToLongUtc(@Nonnull DateTime d){
  return d.withZone(DateTimeZone.UTC).getMillis();
}","@Nullable public static Long dateTimeToLongUtc(@Nullable DateTime d){
  if (d == null) {
    return null;
  }
  return d.withZone(DateTimeZone.UTC).getMillis();
}",0.7838827838827839
109863,"public static long localDateTimeToLongUtc(@Nonnull LocalDateTime d){
  return d.toInstant(ZoneOffset.UTC).toEpochMilli();
}","@Nullable public static Long localDateTimeToLongUtc(@Nullable LocalDateTime d){
  if (d == null) {
    return null;
  }
  return d.toInstant(ZoneOffset.UTC).toEpochMilli();
}",0.8013468013468014
109864,"public static LocalDateTime longToLocalDateTimeUtc(long l){
  return Instant.ofEpochMilli(l).atZone(ZoneOffset.UTC).toLocalDateTime();
}","@Nullable public static LocalDateTime longToLocalDateTimeUtc(@Nullable Long l){
  if (l == null) {
    return null;
  }
  return Instant.ofEpochMilli(l).atZone(ZoneOffset.UTC).toLocalDateTime();
}",0.8192771084337349
109865,"public static LocalDateTime longToLocalDateTime(long l){
  return Instant.ofEpochMilli(l).atZone(ZoneId.systemDefault()).toLocalDateTime();
}","@Nullable public static LocalDateTime longToLocalDateTime(@Nullable Long l){
  if (l == null) {
    return null;
  }
  return Instant.ofEpochMilli(l).atZone(ZoneId.systemDefault()).toLocalDateTime();
}",0.8187134502923976
109866,"public static long localDateTimeToLong(@Nonnull LocalDateTime d){
  return d.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
}","@Nullable public static Long localDateTimeToLong(@Nullable LocalDateTime d){
  if (d == null) {
    return null;
  }
  return d.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
}",0.8184615384615385
109867,"public static long dateToLong(@Nonnull Date d){
  return d.getTime();
}","@Nullable public static Long dateToLong(@Nullable Date d){
  if (d == null) {
    return null;
  }
  return d.getTime();
}",0.694300518134715
109868,"public static DateTime longToDateTimeUtc(long l){
  return new org.joda.time.DateTime(l,DateTimeZone.UTC);
}","@Nullable public static DateTime longToDateTimeUtc(@Nullable Long l){
  if (l == null) {
    return null;
  }
  return new org.joda.time.DateTime(l,DateTimeZone.UTC);
}",0.782608695652174
109869,"public static Date longToDate(long l){
  return new Date(l);
}","@Nullable public static Date longToDate(@Nullable Long l){
  if (l == null) {
    return null;
  }
  return new Date(l);
}",0.6739130434782609
109870,"public void endTransaction(@Nonnull String databaseName,boolean success){
  if (success) {
    getWritableDatabase(databaseName).setTransactionSuccessful();
  }
  getWritableDatabase(databaseName).endTransaction();
  postEndTransactionEvent(success);
}","public void endTransaction(@Nonnull String databaseName,boolean success){
  if (success) {
    getWritableDatabase(databaseName).setTransactionSuccessful();
  }
  Set<String> tableNameChanges=transactionChangesTableNamesMap.get(databaseName);
  transactionChangesTableNamesMap.remove(databaseName);
  getWritableDatabase(databaseName).endTransaction();
  postEndTransactionEvent(success,getDatabaseName(),tableNameChanges);
}",0.7444608567208272
109871,"private void postUpdateEvent(@Nonnull DatabaseWrapper db,@Nonnull String tableName,int rowsAffected){
  Bus bus=getBus();
  if (bus != null) {
    if (!db.inTransaction()) {
      bus.post(new DatabaseUpdateEvent(tableName,rowsAffected));
    }
 else {
      transactionChangesTableNames.add(tableName);
    }
  }
}","private void postUpdateEvent(@Nonnull DatabaseWrapper db,@Nonnull String tableName,int rowsAffected){
  Bus bus=getBus();
  if (bus != null) {
    if (!db.inTransaction()) {
      bus.post(new DatabaseUpdateEvent(tableName,rowsAffected));
    }
 else {
      addTransactionTableNameChange(tableName);
    }
  }
}",0.9473684210526316
109872,"private void postEndTransactionEvent(boolean success){
  Bus bus=getBus();
  if (bus != null) {
    bus.post(new DatabaseEndTransactionEvent(success,transactionChangesTableNames));
    transactionChangesTableNames.clear();
  }
}","private void postEndTransactionEvent(boolean success,String databaseName,Set<String> tableNameChanges){
  Bus bus=getBus();
  if (bus != null && tableNameChanges != null) {
    bus.post(new DatabaseEndTransactionEvent(success,databaseName,tableNameChanges));
  }
}",0.6707317073170732
109873,"private void postDeleteEvent(@Nonnull DatabaseWrapper db,@Nonnull String tableName,int rowsAffected){
  Bus bus=getBus();
  if (bus != null) {
    if (!db.inTransaction()) {
      bus.post(new DatabaseDeleteEvent(tableName,rowsAffected));
    }
 else {
      transactionChangesTableNames.add(tableName);
    }
  }
}","private void postDeleteEvent(@Nonnull DatabaseWrapper db,@Nonnull String tableName,int rowsAffected){
  Bus bus=getBus();
  if (bus != null) {
    if (!db.inTransaction()) {
      bus.post(new DatabaseDeleteEvent(tableName,rowsAffected));
    }
 else {
      addTransactionTableNameChange(tableName);
    }
  }
}",0.9473684210526316
109874,"private void postInsertEvent(@Nullable DatabaseWrapper db,@Nonnull String tableName,long rowId){
  Bus bus=getBus();
  if (bus != null) {
    if (!(db != null && db.inTransaction())) {
      bus.post(new DatabaseInsertEvent(tableName,rowId));
    }
 else {
      transactionChangesTableNames.add(tableName);
    }
  }
}","private void postInsertEvent(@Nullable DatabaseWrapper db,@Nonnull String tableName,long rowId){
  Bus bus=getBus();
  if (bus != null) {
    if (!(db != null && db.inTransaction())) {
      bus.post(new DatabaseInsertEvent(tableName,rowId));
    }
 else {
      addTransactionTableNameChange(tableName);
    }
  }
}",0.948031496062992
109875,"public DatabaseEndTransactionEvent(boolean success,@Nonnull Set<String> tablesChanged){
  super(""String_Node_Str"");
  this.tablesChanged.addAll(tablesChanged);
  this.success=success;
}","public DatabaseEndTransactionEvent(boolean success,@Nonnull String databaseName,@Nonnull Set<String> tablesChanged){
  super(""String_Node_Str"");
  this.databaseName=databaseName;
  this.tablesChanged=tablesChanged;
  this.success=success;
}",0.7294117647058823
109876,"public void connectAllDatabases(){
  Collection<AndroidDatabase> databases=getDatabases();
  for (  AndroidDatabase database : databases) {
    connectDatabase(database.getName());
  }
}","public void connectAllDatabases(){
  createDatabaseMap();
  Collection<AndroidDatabase> databases=getDatabases();
  for (  AndroidDatabase database : databases) {
    connectDatabase(database.getName());
  }
}",0.9417721518987342
109877,"public T findByRowId(String databaseName,long rowId){
  return findBySelection(databaseName,getPrimaryKey() + ""String_Node_Str"" + rowId,null,null);
}","public T findByRowId(String databaseName,long rowId){
  return findBySelection(databaseName,getPrimaryKey() + ""String_Node_Str"",new String[]{String.valueOf(rowId)},null);
}",0.8847352024922118
109878,"public Cursor findCursorByRowId(String databaseName,long rowId){
  return findCursorBySelection(databaseName,getPrimaryKey() + ""String_Node_Str"" + rowId,null);
}","public Cursor findCursorByRowId(String databaseName,long rowId){
  return findCursorBySelection(databaseName,getPrimaryKey() + ""String_Node_Str"",new String[]{String.valueOf(rowId)},null);
}",0.9085714285714286
109879,"public T findByRowId(String databaseName,long rowId){
  return findBySelection(databaseName,getPrimaryKey() + ""String_Node_Str"" + rowId,null,null);
}","public T findByRowId(String databaseName,long rowId){
  return findBySelection(databaseName,getPrimaryKey() + ""String_Node_Str"",new String[]{String.valueOf(rowId)},null);
}",0.8847352024922118
109880,"public Cursor findCursorByRowId(String databaseName,long rowId){
  return findCursorBySelection(databaseName,getPrimaryKey() + ""String_Node_Str"" + rowId,null);
}","public Cursor findCursorByRowId(String databaseName,long rowId){
  return findCursorBySelection(databaseName,getPrimaryKey() + ""String_Node_Str"",new String[]{String.valueOf(rowId)},null);
}",0.9085714285714286
109881,"public AndroidDatabase(String name,String password,String path,int version){
  this.name=name;
  this.password=password;
  this.path=path;
  this.version=version;
}","public AndroidDatabase(String name,String password,String path,int version){
  this.name=name;
  this.password=password;
  this.encrypted=password != null;
  this.path=path;
  this.version=version;
}",0.9035812672176308
109882,"private void openDatabase(AndroidDatabase db){
  if (db.isEncrypted()) {
    db.setSecureSqLiteDatabase(net.sqlcipher.database.SQLiteDatabase.openOrCreateDatabase(db.getPath(),db.getPassword(),null));
  }
 else {
    db.setSqLiteDatabase(SQLiteDatabase.openOrCreateDatabase(db.getPath(),null));
  }
}","private void openDatabase(AndroidDatabase db){
  if (db.isEncrypted()) {
    try {
      db.setSecureSqLiteDatabase(net.sqlcipher.database.SQLiteDatabase.openOrCreateDatabase(db.getPath(),db.getPassword(),null));
    }
 catch (    UnsatisfiedLinkError e) {
      throw new IllegalStateException(""String_Node_Str"",e);
    }
  }
 else {
    db.setSqLiteDatabase(SQLiteDatabase.openOrCreateDatabase(db.getPath(),null));
  }
}",0.8310249307479224
109883,"public Item next(){
  if (null == x) {
    throw new NoSuchElementException();
  }
  Item item=x.value;
  x=x.next;
  return item;
}","public Item next(){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  Item item=x.value;
  x=x.prev;
  return item;
}",0.9132075471698112
109884,"public Item removeFirst(){
  if (null == first) {
    throw new NoSuchElementException();
  }
  Node tmp=first;
  first=first.prev;
  if (null != first) {
    first.next=null;
  }
  tmp.prev=null;
  size--;
  return tmp.value;
}","public Item removeFirst(){
  if (isEmpty()) {
    throw new NoSuchElementException();
  }
  Node tmp=first;
  first=first.prev;
  if (null != first) {
    first.next=null;
  }
 else {
    first=last=null;
  }
  tmp.prev=null;
  size--;
  return tmp.value;
}",0.8865979381443299
109885,"public Item removeLast(){
  if (null == first) {
    throw new NoSuchElementException();
  }
  Node tmp=last;
  last=last.next;
  if (null != last) {
    last.prev=null;
  }
  tmp.next=null;
  size--;
  return tmp.value;
}","public Item removeLast(){
  if (isEmpty()) {
    throw new NoSuchElementException();
  }
  Node tmp=last;
  last=last.next;
  if (null != last) {
    last.prev=null;
  }
 else {
    first=last=null;
  }
  tmp.next=null;
  size--;
  return tmp.value;
}",0.8837209302325582
109886,"@Test public void testOneElement(){
  Deque<Integer> d=new Deque<Integer>();
  Integer item=Integer.valueOf(5);
  Assert.assertTrue(d.isEmpty());
  d.addFirst(item);
  Assert.assertTrue(d.size() == 1);
  Assert.assertFalse(d.isEmpty());
  Integer x=d.removeLast();
  Assert.assertTrue(x.equals(item));
  Assert.assertTrue(d.size() == 0);
  Assert.assertTrue(d.isEmpty());
}","@Test public void testOneElement(){
  Deque<Integer> d=new Deque<Integer>();
  Integer item=Integer.valueOf(5);
  Assert.assertTrue(d.isEmpty());
  d.addFirst(item);
  Assert.assertTrue(d.size() == 1);
  Assert.assertFalse(d.isEmpty());
  Integer x=d.removeLast();
  Assert.assertTrue(x.equals(item));
  Assert.assertTrue(d.size() == 0);
  Assert.assertTrue(d.isEmpty());
  d.addLast(item);
  Assert.assertTrue(d.size() == 1);
  Assert.assertFalse(d.isEmpty());
  x=d.removeFirst();
  Assert.assertTrue(x.equals(item));
  Assert.assertTrue(d.size() == 0);
  Assert.assertTrue(d.isEmpty());
}",0.7738589211618258
109887,"@Test public void testIterator(){
  Deque<Integer> d=new Deque<Integer>();
  List<Integer> values=new ArrayList<Integer>(Arrays.asList(1,3,5,7,9,11,13,15,19,21));
  for (  Integer item : values) {
    d.addFirst(item);
  }
  List<Integer> reversed=new ArrayList<Integer>(values);
  Collections.reverse(reversed);
  int i=0;
  for (  Integer item : d) {
    Assert.assertEquals(reversed.get(i),item);
    i++;
  }
}","@Test public void testIterator(){
  Deque<Integer> d=new Deque<Integer>();
  List<Integer> values=new ArrayList<Integer>(Arrays.asList(1,3,5,7,9,11,13,15,19,21));
  for (  Integer item : values) {
    d.addFirst(item);
  }
  List<Integer> reversed=new ArrayList<Integer>(values);
  Collections.reverse(reversed);
  int i=0;
  for (  Integer item : d) {
    Assert.assertEquals(reversed.get(i),item);
    i++;
  }
  Assert.assertTrue(i == reversed.size());
}",0.9506314580941446
109888,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override protected void internalTransform(String arg0,@SuppressWarnings(""String_Node_Str"") Map arg1){
  pointsToAnalysis=new PointsToAnalysis();
  pointsToAnalysis.doAnalysis();
  final ContextTransitionTable<SootMethod,Unit,PointsToGraph> ctt=pointsToAnalysis.getContextTransitionTable();
  final Set<SootMethod> allMethods=pointsToAnalysis.getMethods();
  final Map<Context<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>> csEdgesIntoContext=new HashMap<Context<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>>();
  final Map<Context<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>> csEdgesOutOfContext=new HashMap<Context<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>>();
  final Map<CallSite<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>> csEdgesOutOfCallSite=new HashMap<CallSite<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>>();
  final Collection<ContextSensitiveEdge> csEdges=new ArrayList<ContextSensitiveEdge>();
  CallGraph callGraph=new CallGraph();
  for (  Map.Entry<CallSite<SootMethod,Unit,PointsToGraph>,Map<SootMethod,Context<SootMethod,Unit,PointsToGraph>>> e : ctt.getTransitions().entrySet()) {
    CallSite<SootMethod,Unit,PointsToGraph> cs=e.getKey();
    final Context<SootMethod,Unit,PointsToGraph> sourceContext=cs.getCallingContext();
    final SootMethod sourceMethod=sourceContext.getMethod();
    final Unit stmt=cs.getCallNode();
    final Map<SootMethod,Context<SootMethod,Unit,PointsToGraph>> targets=e.getValue();
    for (    final SootMethod targetMethod : targets.keySet()) {
      final Context<SootMethod,Unit,PointsToGraph> targetContext=targets.get(targetMethod);
      Edge cgEdge=new Edge(sourceMethod,(Stmt)stmt,targetMethod);
      callGraph.addEdge(cgEdge);
      ContextSensitiveEdge csEdge=new ContextSensitiveEdge(){
        @Override public Kind kind(){
          if (stmt instanceof InvokeExpr) {
            return Edge.ieToKind((InvokeExpr)stmt);
          }
 else {
            return Kind.INVALID;
          }
        }
        @Override public SootMethod src(){
          return sourceMethod;
        }
        @Override public soot.Context srcCtxt(){
          return sourceContext;
        }
        @Override public Stmt srcStmt(){
          return (Stmt)stmt;
        }
        @Override public Unit srcUnit(){
          return stmt;
        }
        @Override public SootMethod tgt(){
          return targetMethod;
        }
        @Override public soot.Context tgtCtxt(){
          return targetContext;
        }
      }
;
      csEdges.add(csEdge);
      if (!csEdgesOutOfContext.containsKey(sourceContext))       csEdgesOutOfContext.put(sourceContext,new ArrayList<ContextSensitiveEdge>());
      csEdgesOutOfContext.get(sourceContext).add(csEdge);
      if (!csEdgesOutOfCallSite.containsKey(cs))       csEdgesOutOfCallSite.put(cs,new ArrayList<ContextSensitiveEdge>());
      csEdgesOutOfCallSite.get(cs).add(csEdge);
      if (!csEdgesIntoContext.containsKey(targetContext))       csEdgesIntoContext.put(targetContext,new ArrayList<ContextSensitiveEdge>());
      csEdgesIntoContext.get(targetContext).add(csEdge);
    }
  }
  Scene.v().setCallGraph(callGraph);
  Scene.v().setContextSensitiveCallGraph(new ContextSensitiveCallGraph(){
    @SuppressWarnings(""String_Node_Str"") private Context<SootMethod,Unit,PointsToGraph> vContext(    soot.Context sContext){
      return (Context<SootMethod,Unit,PointsToGraph>)sContext;
    }
    private CallSite<SootMethod,Unit,PointsToGraph> vCallSite(    soot.Context sContext,    Unit unit){
      return new CallSite<SootMethod,Unit,PointsToGraph>(vContext(sContext),unit);
    }
    @Override public Iterator<?> edgesOutOf(    soot.Context sContext,    SootMethod m,    Unit stmt){
      return csEdgesOutOfCallSite.get((vCallSite(sContext,stmt))).iterator();
    }
    @Override public Iterator<?> edgesOutOf(    soot.Context sContext,    SootMethod m){
      return csEdgesOutOfContext.get(vContext(sContext)).iterator();
    }
    @Override public Iterator<?> edgesInto(    soot.Context sContext,    SootMethod m){
      return csEdgesIntoContext.get(vContext(sContext)).iterator();
    }
    @Override public Iterator<?> edgeSources(){
      return allMethods.iterator();
    }
    @Override public Iterator<?> allEdges(){
      return csEdges.iterator();
    }
  }
);
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override protected void internalTransform(String arg0,@SuppressWarnings(""String_Node_Str"") Map arg1){
  pointsToAnalysis=new PointsToAnalysis();
  pointsToAnalysis.doAnalysis();
  final ContextTransitionTable<SootMethod,Unit,PointsToGraph> ctt=pointsToAnalysis.getContextTransitionTable();
  final Set<SootMethod> allMethods=pointsToAnalysis.getMethods();
  final Map<Context<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>> csEdgesIntoContext=new HashMap<Context<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>>();
  final Map<Context<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>> csEdgesOutOfContext=new HashMap<Context<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>>();
  final Map<CallSite<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>> csEdgesOutOfCallSite=new HashMap<CallSite<SootMethod,Unit,PointsToGraph>,Collection<ContextSensitiveEdge>>();
  final Collection<ContextSensitiveEdge> csEdges=new ArrayList<ContextSensitiveEdge>();
  CallGraph callGraph=new CallGraph();
  for (  Map.Entry<CallSite<SootMethod,Unit,PointsToGraph>,Map<SootMethod,Context<SootMethod,Unit,PointsToGraph>>> e : ctt.getTransitions().entrySet()) {
    CallSite<SootMethod,Unit,PointsToGraph> cs=e.getKey();
    final Context<SootMethod,Unit,PointsToGraph> sourceContext=cs.getCallingContext();
    final SootMethod sourceMethod=sourceContext.getMethod();
    final Unit stmt=cs.getCallNode();
    final Map<SootMethod,Context<SootMethod,Unit,PointsToGraph>> targets=e.getValue();
    for (    final SootMethod targetMethod : targets.keySet()) {
      final Context<SootMethod,Unit,PointsToGraph> targetContext=targets.get(targetMethod);
      Kind K;
      if (stmt instanceof InvokeExpr) {
        K=Edge.ieToKind((InvokeExpr)stmt);
      }
 else {
        K=Kind.INVALID;
      }
      Edge cgEdge=new Edge(sourceMethod,(Stmt)stmt,targetMethod,K);
      callGraph.addEdge(cgEdge);
      ContextSensitiveEdge csEdge=new ContextSensitiveEdge(){
        @Override public Kind kind(){
          if (stmt instanceof InvokeExpr) {
            return Edge.ieToKind((InvokeExpr)stmt);
          }
 else {
            return Kind.INVALID;
          }
        }
        @Override public SootMethod src(){
          return sourceMethod;
        }
        @Override public soot.Context srcCtxt(){
          return sourceContext;
        }
        @Override public Stmt srcStmt(){
          return (Stmt)stmt;
        }
        @Override public Unit srcUnit(){
          return stmt;
        }
        @Override public SootMethod tgt(){
          return targetMethod;
        }
        @Override public soot.Context tgtCtxt(){
          return targetContext;
        }
      }
;
      csEdges.add(csEdge);
      if (!csEdgesOutOfContext.containsKey(sourceContext))       csEdgesOutOfContext.put(sourceContext,new ArrayList<ContextSensitiveEdge>());
      csEdgesOutOfContext.get(sourceContext).add(csEdge);
      if (!csEdgesOutOfCallSite.containsKey(cs))       csEdgesOutOfCallSite.put(cs,new ArrayList<ContextSensitiveEdge>());
      csEdgesOutOfCallSite.get(cs).add(csEdge);
      if (!csEdgesIntoContext.containsKey(targetContext))       csEdgesIntoContext.put(targetContext,new ArrayList<ContextSensitiveEdge>());
      csEdgesIntoContext.get(targetContext).add(csEdge);
    }
  }
  Scene.v().setCallGraph(callGraph);
  Scene.v().setContextSensitiveCallGraph(new ContextSensitiveCallGraph(){
    @SuppressWarnings(""String_Node_Str"") private Context<SootMethod,Unit,PointsToGraph> vContext(    soot.Context sContext){
      return (Context<SootMethod,Unit,PointsToGraph>)sContext;
    }
    private CallSite<SootMethod,Unit,PointsToGraph> vCallSite(    soot.Context sContext,    Unit unit){
      return new CallSite<SootMethod,Unit,PointsToGraph>(vContext(sContext),unit);
    }
    @Override public Iterator<?> edgesOutOf(    soot.Context sContext,    SootMethod m,    Unit stmt){
      return csEdgesOutOfCallSite.get((vCallSite(sContext,stmt))).iterator();
    }
    @Override public Iterator<?> edgesOutOf(    soot.Context sContext,    SootMethod m){
      return csEdgesOutOfContext.get(vContext(sContext)).iterator();
    }
    @Override public Iterator<?> edgesInto(    soot.Context sContext,    SootMethod m){
      return csEdgesIntoContext.get(vContext(sContext)).iterator();
    }
    @Override public Iterator<?> edgeSources(){
      return allMethods.iterator();
    }
    @Override public Iterator<?> allEdges(){
      return csEdges.iterator();
    }
  }
);
}",0.6361929998895882
109889,"CopyConstantAnalysis(){
  super();
  verbose=true;
}","public CopyConstantAnalysis(){
  super();
  verbose=true;
}",0.9369369369369368
109890,"public static void main(String args[]){
  String classPath=""String_Node_Str"";
  String mainClass=null;
  try {
    int i=0;
    while (true) {
      if (args[i].equals(""String_Node_Str"")) {
        classPath=args[i + 1];
        i+=2;
      }
 else {
        mainClass=args[i];
        i++;
        break;
      }
    }
    if (i != args.length || mainClass == null)     throw new Exception();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  String[] sootArgs={""String_Node_Str"",classPath,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",mainClass,""String_Node_Str"",""String_Node_Str"",mainClass};
  CopyConstantTest cgt=new CopyConstantTest();
  PackManager.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",cgt));
  soot.Main.main(sootArgs);
}","public static void main(String args[]){
  String classPath=""String_Node_Str"";
  String mainClass=null;
  try {
    int i=0;
    while (true) {
      if (args[i].equals(""String_Node_Str"")) {
        classPath=args[i + 1];
        i+=2;
      }
 else {
        mainClass=args[i];
        i++;
        break;
      }
    }
    if (i != args.length || mainClass == null)     throw new Exception();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  String[] sootArgs={""String_Node_Str"",classPath,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",mainClass,""String_Node_Str"",""String_Node_Str"",mainClass};
  CopyConstantTest cgt=new CopyConstantTest();
  PackManager.v().getPack(""String_Node_Str"").add(new Transform(""String_Node_Str"",cgt));
  soot.Main.main(sootArgs);
}",0.997485331098072
109891,"@Override protected void init(NodeMainExecutor nodeMainExecutor){
  this.nodeMainExecutor=nodeMainExecutor;
  nodeConfiguration=NodeConfiguration.newPublic(InetAddressFactory.newNonLoopback().getHostAddress(),getMasterUri());
  if (getIntent().hasExtra(ROBOT_DESCRIPTION_EXTRA)) {
    robotDescription=(RobotDescription)getIntent().getSerializableExtra(ROBOT_DESCRIPTION_EXTRA);
  }
  if (robotDescription != null) {
    if (fromAppChooser) {
      robotNameResolver.setRobot(robotDescription);
    }
    dashboard.setRobotName(robotDescription.getRobotType());
  }
 else {
    dashboard.setRobotName(getRobotNameSpace().getNamespace().toString());
  }
  nodeMainExecutor.execute(robotNameResolver,nodeConfiguration.setNodeName(""String_Node_Str""));
  while (getAppNameSpace() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    Exception e) {
    }
  }
  nodeMainExecutor.execute(dashboard,nodeConfiguration.setNodeName(""String_Node_Str""));
  if (fromAppChooser && startApplication) {
    if (getIntent().getBooleanExtra(""String_Node_Str"",false)) {
      restartApp();
    }
 else     startApp();
  }
 else   if (startApplication) {
    startApp();
  }
}","@Override protected void init(NodeMainExecutor nodeMainExecutor){
  this.nodeMainExecutor=nodeMainExecutor;
  nodeConfiguration=NodeConfiguration.newPublic(InetAddressFactory.newNonLoopback().getHostAddress(),getMasterUri());
  if (getIntent().hasExtra(ROBOT_DESCRIPTION_EXTRA)) {
    robotDescription=(RobotDescription)getIntent().getSerializableExtra(ROBOT_DESCRIPTION_EXTRA);
  }
  if (robotDescription != null) {
    robotNameResolver.setRobot(robotDescription);
    dashboard.setRobotName(robotDescription.getRobotType());
  }
 else   if (fromApplication) {
    robotNameResolver.setRobotName(getIntent().getStringExtra(""String_Node_Str""));
    dashboard.setRobotName(getIntent().getStringExtra(""String_Node_Str""));
  }
  nodeMainExecutor.execute(robotNameResolver,nodeConfiguration.setNodeName(""String_Node_Str""));
  while (getAppNameSpace() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    Exception e) {
    }
  }
  if (robotDescription == null) {
    dashboard.setRobotName(getRobotNameSpace().getNamespace().toString());
  }
  nodeMainExecutor.execute(dashboard,nodeConfiguration.setNodeName(""String_Node_Str""));
  if (fromAppChooser && startApplication) {
    if (getIntent().getBooleanExtra(""String_Node_Str"",false)) {
      restartApp();
    }
 else     startApp();
  }
 else   if (startApplication) {
    startApp();
  }
}",0.7644020659515296
109892,"@Override public void onBackPressed(){
  if (fromAppChooser) {
    keyBackTouched=true;
    Intent intent=new Intent();
    intent.putExtra(AppManager.PACKAGE + ""String_Node_Str"",""String_Node_Str"");
    intent.putExtra(""String_Node_Str"",uri.toString());
    intent.setAction(""String_Node_Str"");
    intent.addCategory(""String_Node_Str"");
    startActivity(intent);
    onDestroy();
  }
  super.onBackPressed();
}","@Override public void onBackPressed(){
  if (fromAppChooser) {
    keyBackTouched=true;
    Intent intent=new Intent();
    intent.putExtra(AppManager.PACKAGE + ""String_Node_Str"",""String_Node_Str"");
    intent.putExtra(""String_Node_Str"",uri.toString());
    intent.putExtra(""String_Node_Str"",robotDescription.getRobotType());
    intent.putExtra(""String_Node_Str"",robotDescription.getRobotName());
    intent.setAction(""String_Node_Str"");
    intent.addCategory(""String_Node_Str"");
    startActivity(intent);
    onDestroy();
  }
  super.onBackPressed();
}",0.8512396694214877
109893,"/** 
 * Constructor for the QCMetrics instance.
 * @param survey The survey for which we want to compute metrics.
 * @param classifier The classifier we want to use for respondents.
 */
public QCMetrics(Survey survey,AbstractClassifier classifier){
}","/** 
 * Constructor for the QCMetrics instance.
 * @param survey The survey for which we want to compute metrics.
 * @param classifier The classifier we want to use for respondents.
 * @throws UnanalyzableException If the survey contains no analyzable questions (i.e., radio-button or check-boxquestions), then we throw this exception.
 */
public QCMetrics(Survey survey,AbstractClassifier classifier) throws SurveyException {
}",0.7374631268436578
109894,"/** 
 * Method to add a subblock to this block programmatically.
 * @param b The block we want to add as a subblock.
 * @throws SurveyException
 */
public void addBlock(Block b) throws SurveyException {
  if (this.branchParadigm.equals(BranchParadigm.ALL))   throw new BlockException(""String_Node_Str"");
 else {
    this.subBlocks.add(b);
  }
  edu.umass.cs.surveyman.analyses.rules.BranchParadigm.ensureBranchParadigms(this);
}","/** 
 * Method to add a subblock to this block programmatically.
 * @param b The block we want to add as a subblock.
 * @throws SurveyException
 */
public void addBlock(Block b) throws SurveyException {
  if (this.branchParadigm.equals(BranchParadigm.ALL))   throw new BlockException(""String_Node_Str"");
 else {
    this.subBlocks.add(b);
    b.parentBlock=this;
  }
  edu.umass.cs.surveyman.analyses.rules.BranchParadigm.ensureBranchParadigms(this);
}",0.9727272727272728
109895,"/** 
 * Sets the appropriate   {@link edu.umass.cs.surveyman.survey.Block.BranchParadigm} for this block and its ancestors.
 * @throws SurveyException
 */
private void propagateUp() throws SurveyException {
  if (parentBlock == null)   return;
switch (this.branchParadigm) {
case ONE:
switch (parentBlock.branchParadigm) {
case NONE:
      parentBlock.branchParadigm=this.branchParadigm;
    parentBlock.branchQ=this.branchQ;
  parentBlock.propagateUp();
break;
case ONE:
if (parentBlock.branchQ == null) parentBlock.branchQ=this.branchQ;
if (parentBlock.branchQ != null && !parentBlock.branchQ.equals(this.branchQ)) throw new BranchException(String.format(""String_Node_Str"",this.strId,this.parentBlock.strId,this.branchQ,this.parentBlock.branchQ));
break;
case ALL:
throw new BranchException(String.format(""String_Node_Str"",this.parentBlock.strId,this.strId));
}
case NONE:
break;
case ALL:
break;
}
}","/** 
 * Sets the appropriate   {@link edu.umass.cs.surveyman.survey.Block.BranchParadigm} for this block and its ancestors.
 * @throws SurveyException
 */
private void propagateUp() throws SurveyException {
}",0.3747747747747748
109896,"/** 
 * Sets the appropriate   {@link edu.umass.cs.surveyman.survey.Block.BranchParadigm} for all connected blocks.
 * @throws SurveyException
 */
public void propagateBranchParadigm() throws SurveyException {
  if (parentBlock == null)   return;
  if (branchParadigm.equals(BranchParadigm.ONE))   propagateUp();
  Block branchBlock=null;
  for (  Block b : parentBlock.subBlocks) {
switch (b.branchParadigm) {
case ONE:
      if (branchBlock != null)       throw new BlockException(String.format(""String_Node_Str"",parentBlock.strId,branchBlock.strId,b.strId));
 else {
        branchBlock=b;
        parentBlock.branchParadigm=BranchParadigm.ONE;
      }
    break;
case ALL:
  if (b.subBlocks.size() != 0)   throw new BlockException(String.format(""String_Node_Str"",b.strId,subBlocks.size()));
}
}
}","/** 
 * Sets the appropriate   {@link edu.umass.cs.surveyman.survey.Block.BranchParadigm} for all connected blocks.This method passes the branch paradigm up. It expects the branch paradigm for this current block to be set already. The method returns when it hits a top-level block. Since branch-all and branch-none classifications don't propagate up, this method only propagates branch-one, and asserts that its properties are not violated.
 * @throws SurveyException
 */
public void propagateBranchParadigm() throws SurveyException {
  if (parentBlock == null)   return;
  if (branchParadigm.equals(BranchParadigm.ONE))   propagateUp();
  for (  Block sibling : parentBlock.subBlocks) {
switch (sibling.branchParadigm) {
case ONE:
      if (!sibling.equals(this) && this.branchParadigm.equals(BranchParadigm.ONE))       throw new BlockException(String.format(""String_Node_Str"",parentBlock.strId,this.strId,sibling.strId));
    break;
case ALL:
  if (sibling.subBlocks.size() != 0)   throw new BlockException(String.format(""String_Node_Str"",sibling.strId,subBlocks.size()));
}
}
}",0.6180851063829788
109897,"/** 
 * Sets the branch destination of this question at the input option to the input destination. Adds the input option to this question's options, if it hasn't been added already. Resets the branch paradigm, if needed, and propagates the branch paradigm.
 * @param c The answer option whose branch destination we need to set.
 * @param dest The branch destination for the input answer option.
 * @throws SurveyException
 */
public void setBranchDest(SurveyDatum c,Block dest) throws SurveyException {
  if (!this.options.values().contains(c))   this.addOption(c);
  this.branchMap.put(c,dest);
  if (this.block.branchQ == null || !this.block.branchQ.equals(this)) {
    this.block.branchQ=this;
switch (this.block.branchParadigm) {
case NONE:
      this.block.updateBranchParadigm(Block.BranchParadigm.ONE);
    break;
case ONE:
  this.block.updateBranchParadigm(Block.BranchParadigm.ALL);
break;
}
}
this.block.propagateBranchParadigm();
}","/** 
 * Sets the branch destination of this question at the input option to the input destination. Adds the input option to this question's options, if it hasn't been added already. Resets the branch paradigm, if needed, and propagates the branch paradigm.
 * @param c The answer option whose branch destination we need to set.
 * @param dest The branch destination for the input answer option.
 * @throws SurveyException
 */
public void setBranchDest(SurveyDatum c,Block dest) throws SurveyException {
  if (!this.options.values().contains(c))   this.addOption(c);
  this.branchMap.put(c,dest);
  if (this.block.branchQ == null || !this.block.branchQ.equals(this)) {
    this.block.branchQ=this;
switch (this.block.branchParadigm) {
case NONE:
      this.block.updateBranchParadigm(Block.BranchParadigm.ONE);
    break;
case ONE:
  this.block.updateBranchParadigm(Block.BranchParadigm.ALL);
break;
}
}
}",0.9794149512459372
109898,"public void init(){
  block1=new Block(""String_Node_Str"");
  block2=new Block(""String_Node_Str"");
  block3=new Block(""String_Node_Str"");
  block4=new Block(""String_Node_Str"");
  branchQuestion1=Question.makeQuestion(""String_Node_Str"",1,1);
  a=new StringDatum(""String_Node_Str"",1,2,0);
  b=new StringDatum(""String_Node_Str"",2,2,1);
  branchQuestion2=Question.makeQuestion(""String_Node_Str"",3,1);
  c=new StringDatum(""String_Node_Str"",3,1,0);
  d=new StringDatum(""String_Node_Str"",4,1,1);
  noBranchQuestion1=Question.makeQuestion(""String_Node_Str"",5,1);
  noBranchQuestion2=Question.makeQuestion(""String_Node_Str"",6,1);
  survey=new Survey();
  try {
    branchQuestion1.addOption(a,block2);
    branchQuestion1.addOption(b,block4);
    block1.addBranchQuestion(branchQuestion1);
    branchQuestion2.addOption(c,block3);
    branchQuestion2.addOption(d,block4);
    block2.addBranchQuestion(branchQuestion2);
    block3.addQuestion(noBranchQuestion1);
    block4.addQuestion(noBranchQuestion2);
    survey.addBlock(block1);
    survey.addBlock(block2);
    survey.addBlock(block3);
    survey.addBlock(block4);
    StaticAnalysis.wellFormednessChecks(survey);
  }
 catch (  SurveyException e) {
    e.printStackTrace();
  }
  qcMetrics=new QCMetrics(survey,new StackedClassifier(survey,false,0.05,2));
}","public void init(){
  block1=new Block(""String_Node_Str"");
  block2=new Block(""String_Node_Str"");
  block3=new Block(""String_Node_Str"");
  block4=new Block(""String_Node_Str"");
  branchQuestion1=Question.makeQuestion(""String_Node_Str"",1,1);
  a=new StringDatum(""String_Node_Str"",1,2,0);
  b=new StringDatum(""String_Node_Str"",2,2,1);
  branchQuestion2=Question.makeQuestion(""String_Node_Str"",3,1);
  c=new StringDatum(""String_Node_Str"",3,1,0);
  d=new StringDatum(""String_Node_Str"",4,1,1);
  noBranchQuestion1=Question.makeQuestion(""String_Node_Str"",5,1);
  noBranchQuestion2=Question.makeQuestion(""String_Node_Str"",6,1);
  survey=new Survey();
  try {
    branchQuestion1.addOption(a,block2);
    branchQuestion1.addOption(b,block4);
    block1.addBranchQuestion(branchQuestion1);
    branchQuestion2.addOption(c,block3);
    branchQuestion2.addOption(d,block4);
    block2.addBranchQuestion(branchQuestion2);
    block3.addQuestion(noBranchQuestion1);
    block4.addQuestion(noBranchQuestion2);
    survey.addBlock(block1);
    survey.addBlock(block2);
    survey.addBlock(block3);
    survey.addBlock(block4);
    StaticAnalysis.wellFormednessChecks(survey);
    qcMetrics=new QCMetrics(survey);
  }
 catch (  SurveyException e) {
    e.printStackTrace();
  }
}",0.9551656920077972
109899,"@Test public void testProbabilities() throws SurveyException {
  SurveyDatum optionA=new StringDatum(""String_Node_Str"");
  SurveyDatum optionB=new StringDatum(""String_Node_Str"");
  SurveyDatum optionC=new StringDatum(""String_Node_Str"");
  SurveyDatum optionD=new StringDatum(""String_Node_Str"");
  Survey survey=new Survey(new Question(""String_Node_Str"",optionA,optionB,optionC,optionD),new Question(""String_Node_Str"",optionA,optionB,optionC,optionD),new Question(""String_Node_Str"",optionA,optionB,optionC,optionD),new Question(""String_Node_Str"",optionA,optionB,optionC,optionD),new Question(""String_Node_Str"",optionA,optionB,optionC,optionD));
  AbstractClassifier classifier=new AbstractClassifier(survey,false,0.05,1){
    @Override public double getScoreForResponse(    List<IQuestionResponse> responses) throws SurveyException {
      return 0;
    }
    @Override public double getScoreForResponse(    SurveyResponse surveyResponse) throws SurveyException {
      return 0;
    }
    @Override public void computeScoresForResponses(    List<? extends SurveyResponse> responses) throws SurveyException {
    }
    @Override public boolean classifyResponse(    SurveyResponse response) throws SurveyException {
      return false;
    }
  }
;
  List<SurveyResponse> responses=makeNResponses(500,new RandomRespondent(survey,RandomRespondent.AdversaryType.UNIFORM));
  classifier.makeProbabilities(responses);
  for (  Map<String,Double> m : classifier.answerProbabilityMap.values()) {
    double total=0.0;
    for (    Double d : m.values()) {
      Assert.assertTrue(String.format(""String_Node_Str"",d),d > 0.20 && d < 0.30);
      total+=d;
    }
    Assert.assertTrue(String.format(""String_Node_Str"",total),total > 0.95 && total < 1.05);
  }
}","@Test public void testProbabilities() throws SurveyException {
  SurveyDatum optionA=new StringDatum(""String_Node_Str"");
  SurveyDatum optionB=new StringDatum(""String_Node_Str"");
  SurveyDatum optionC=new StringDatum(""String_Node_Str"");
  SurveyDatum optionD=new StringDatum(""String_Node_Str"");
  Survey survey=new Survey(new Question(""String_Node_Str"",optionA,optionB,optionC,optionD),new Question(""String_Node_Str"",optionA,optionB,optionC,optionD),new Question(""String_Node_Str"",optionA,optionB,optionC,optionD),new Question(""String_Node_Str"",optionA,optionB,optionC,optionD),new Question(""String_Node_Str"",optionA,optionB,optionC,optionD));
  AbstractClassifier classifier=new AbstractClassifier(survey,false,0.05,1){
    @Override public double getScoreForResponse(    List<IQuestionResponse> responses) throws SurveyException {
      return 0;
    }
    @Override public double getScoreForResponse(    SurveyResponse surveyResponse) throws SurveyException {
      return 0;
    }
    @Override public void computeScoresForResponses(    List<? extends SurveyResponse> responses) throws SurveyException {
    }
    @Override public boolean classifyResponse(    SurveyResponse response) throws SurveyException {
      return false;
    }
  }
;
  List<SurveyResponse> responses=makeNResponses(500,new RandomRespondent(survey,RandomRespondent.AdversaryType.UNIFORM));
  classifier.makeProbabilities(responses);
  for (  Map<String,Double> m : classifier.answerProbabilityMap.values()) {
    double total=0.0;
    for (    Double d : m.values()) {
      Assert.assertTrue(String.format(""String_Node_Str"",d),d > 0.19 && d < 0.31);
      total+=d;
    }
    Assert.assertTrue(String.format(""String_Node_Str"",total),total > 0.95 && total < 1.05);
  }
}",0.998283752860412
109900,"protected static double chiSquared(int[][] contingencyTable,Object[] categoryA,Object[] categoryB){
  double testStatistic=0.0;
  int numSamples=0;
  for (int i=0; i < contingencyTable.length; i++)   for (int j=0; j < contingencyTable[i].length; j++)   numSamples+=contingencyTable[i][j];
  for (int r=0; r < categoryA.length; r++)   for (int c=0; c < categoryB.length; c++) {
    double eij=cellExpectation(contingencyTable,r,c,numSamples);
    if (eij == 0.0)     continue;
    testStatistic+=Math.pow(contingencyTable[r][c] - eij,2.0) / eij;
  }
  return testStatistic;
}","protected static double chiSquared(int[][] contingencyTable,Object[] categoryA,Object[] categoryB){
  double testStatistic=0.0;
  int numSamples=0;
  for (  int[] aContingencyTable : contingencyTable)   for (  int anAContingencyTable : aContingencyTable)   numSamples+=anAContingencyTable;
  for (int r=0; r < categoryA.length; r++)   for (int c=0; c < categoryB.length; c++) {
    double eij=cellExpectation(contingencyTable,r,c,numSamples);
    if (eij == 0.0)     continue;
    testStatistic+=Math.pow(contingencyTable[r][c] - eij,2.0) / eij;
  }
  return testStatistic;
}",0.8128807658833769
109901,"/** 
 * Returns paths through **blocks** in the survey. Top level randomized blocks are all listed last
 * @param s The survey whose paths we want to enumerate
 * @return A List of all paths through the survey. A path is represented by a List. There may be duplicate paths,so if you need distinct paths, you will need to filter for uniqueness.
 */
protected static List<Set<Block>> getPaths(Survey s){
  List<Set<Block>> retval=new ArrayList<>();
  Map<Boolean,List<Block>> partitionedBlocks=Interpreter.partitionBlocks(s);
  List<Block> topLevelRandomizableBlocks=partitionedBlocks.get(true);
  List<Block> nonrandomizableBlocks=partitionedBlocks.get(false);
  Collections.sort(nonrandomizableBlocks);
  List<List<Block>> dag=getDag(nonrandomizableBlocks);
  SurveyMan.LOGGER.info(""String_Node_Str"" + dag.size() + ""String_Node_Str"");
  if (dag.size() == 1 && dag.get(0).isEmpty()) {
    retval.add(new HashSet<>(topLevelRandomizableBlocks));
    return retval;
  }
  for (  List<Block> blist : dag) {
    if (blist.isEmpty())     continue;
    blist.addAll(topLevelRandomizableBlocks);
    retval.add(new HashSet<>(blist));
  }
  if (retval.size() > 1)   SurveyMan.LOGGER.info(String.format(""String_Node_Str"",retval.size()));
  return retval;
}","/** 
 * Returns paths through **blocks** in the survey. Top level randomized blocks are all listed last
 * @param s The survey whose paths we want to enumerate
 * @return A List of all paths through the survey. A path is represented by a List. There may be duplicate paths,so if you need distinct paths, you will need to filter for uniqueness.
 */
protected static List<Set<Block>> getPaths(Survey s){
}",0.4890776699029126
109902,"public StaticAnalysisServer(int port){
  this.server=new Server(port);
  this.server.setHandler(new AbstractHandler(){
    @Override public void handle(    String target,    Request baseRequest,    HttpServletRequest request,    HttpServletResponse response) throws IOException, ServletException {
      baseRequest.setHandled(true);
      try {
        response.addHeader(""String_Node_Str"",""String_Node_Str"");
        analyzeRequest(request,response);
      }
 catch (      SurveyException e) {
        e.printStackTrace();
        response.sendError(400,""String_Node_Str"" + e.getMessage());
      }
catch (      Exception e) {
        e.printStackTrace();
        System.out.println(""String_Node_Str"");
        response.sendError(501,e.getMessage());
      }
    }
  }
);
}","public StaticAnalysisServer(int port){
  this.server=new Server(port);
  this.server.setHandler(new AbstractHandler(){
    @Override public void handle(    String target,    Request baseRequest,    HttpServletRequest request,    HttpServletResponse response) throws IOException, ServletException {
      baseRequest.setHandled(true);
      try {
        response.addHeader(""String_Node_Str"",""String_Node_Str"");
        response.addHeader(""String_Node_Str"",""String_Node_Str"");
        response.addHeader(""String_Node_Str"",""String_Node_Str"");
        analyzeRequest(request,response);
      }
 catch (      SurveyException e) {
        e.printStackTrace();
        response.sendError(400,""String_Node_Str"" + e.getMessage());
      }
catch (      Exception e) {
        e.printStackTrace();
        System.out.println(""String_Node_Str"");
        response.sendError(501,e.getMessage());
      }
    }
  }
);
}",0.9226190476190476
109903,"@Override public void handle(String target,Request baseRequest,HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  baseRequest.setHandled(true);
  try {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    analyzeRequest(request,response);
  }
 catch (  SurveyException e) {
    e.printStackTrace();
    response.sendError(400,""String_Node_Str"" + e.getMessage());
  }
catch (  Exception e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
    response.sendError(501,e.getMessage());
  }
}","@Override public void handle(String target,Request baseRequest,HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  baseRequest.setHandled(true);
  try {
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    response.addHeader(""String_Node_Str"",""String_Node_Str"");
    analyzeRequest(request,response);
  }
 catch (  SurveyException e) {
    e.printStackTrace();
    response.sendError(400,""String_Node_Str"" + e.getMessage());
  }
catch (  Exception e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"");
    response.sendError(501,e.getMessage());
  }
}",0.9028662420382164
109904,"public static void analyzeRequest(HttpServletRequest request,HttpServletResponse response) throws IOException, SurveyException {
  String path=request.getPathInfo();
  if (!path.equals(""String_Node_Str"")) {
    response.sendError(400,""String_Node_Str"");
    return;
  }
  String method=request.getMethod();
  SurveyMan.LOGGER.info(""String_Node_Str"" + method);
switch (method) {
case ""String_Node_Str"":
    break;
default :
  response.sendError(400,""String_Node_Str"");
return;
}
String contentType=request.getContentType();
int semicolon=contentType.indexOf(';');
if (semicolon >= 0) {
contentType=contentType.substring(0,semicolon);
}
Survey survey;
AbstractRule.getDefaultRules();
switch (contentType) {
case ""String_Node_Str"":
survey=parseJSON(request);
break;
case ""String_Node_Str"":
survey=parseJSON(request);
break;
case ""String_Node_Str"":
survey=parseCSV(request);
break;
default :
response.sendError(400,""String_Node_Str"");
return;
}
Map<String,String> qp=parseQueryParams(request);
Classifier classifier=Classifier.valueOf(getOrElse(qp,""String_Node_Str"",DEFAULT_CLASSIFIER.name()));
int n=Integer.parseInt(getOrElse(qp,""String_Node_Str"",Integer.toString(DEFAULT_N)));
double granularity=Double.parseDouble(getOrElse(qp,""String_Node_Str"",Double.toString(DEFAULT_GRANULARITY)));
double alpha=Double.parseDouble(getOrElse(qp,""String_Node_Str"",Double.toString(DEFAULT_ALPHA)));
StaticAnalysis.Report report=StaticAnalysis.staticAnalysis(survey,classifier,n,granularity,alpha,RandomRespondent.AdversaryType.UNIFORM);
try (OutputStream out=response.getOutputStream()){
report.print(out);
response.setStatus(200);
response.setContentType(""String_Node_Str"");
}
 }","public static void analyzeRequest(HttpServletRequest request,HttpServletResponse response) throws IOException, SurveyException {
  String path=request.getPathInfo();
  if (!path.equals(""String_Node_Str"")) {
    response.sendError(400,""String_Node_Str"");
    return;
  }
  String method=request.getMethod();
  SurveyMan.LOGGER.info(""String_Node_Str"" + method);
switch (method) {
case ""String_Node_Str"":
    break;
case ""String_Node_Str"":
  response.setStatus(200);
response.setContentType(""String_Node_Str"");
return;
default :
response.sendError(400,""String_Node_Str"");
return;
}
String contentType=request.getContentType();
int semicolon=contentType.indexOf(';');
if (semicolon >= 0) {
contentType=contentType.substring(0,semicolon);
}
Survey survey;
AbstractRule.getDefaultRules();
switch (contentType) {
case ""String_Node_Str"":
survey=parseJSON(request);
break;
case ""String_Node_Str"":
survey=parseJSON(request);
break;
case ""String_Node_Str"":
survey=parseCSV(request);
break;
default :
response.sendError(400,""String_Node_Str"");
return;
}
Map<String,String> qp=parseQueryParams(request);
Classifier classifier=Classifier.valueOf(getOrElse(qp,""String_Node_Str"",DEFAULT_CLASSIFIER.name()));
int n=Integer.parseInt(getOrElse(qp,""String_Node_Str"",Integer.toString(DEFAULT_N)));
double granularity=Double.parseDouble(getOrElse(qp,""String_Node_Str"",Double.toString(DEFAULT_GRANULARITY)));
double alpha=Double.parseDouble(getOrElse(qp,""String_Node_Str"",Double.toString(DEFAULT_ALPHA)));
StaticAnalysis.Report report=StaticAnalysis.staticAnalysis(survey,classifier,n,granularity,alpha,RandomRespondent.AdversaryType.UNIFORM);
try (OutputStream out=response.getOutputStream()){
report.print(out);
response.setStatus(200);
response.setContentType(""String_Node_Str"");
}
 }",0.96936095710534
109905,"public double responseToDouble(List<OptTuple> opts,boolean noise) throws SurveyException {
}","/** 
 * Converts a response to a double precision representation, for use in clustering.
 * @param opts The answer set to this question.
 * @param noise Boolean indicating whether we should add noise.
 * @return
 * @throws SurveyException
 */
public double responseToDouble(List<OptTuple> opts,boolean noise) throws SurveyException {
}",0.126463700234192
109906,"public DynamicSurveyResponse(Survey survey,String srid){
  super(survey);
  this.setSrid(srid);
}","public DynamicSurveyResponse(SurveyResponse surveyResponse){
  super(surveyResponse.getSurvey(),surveyResponse.getAllResponses(),surveyResponse.getSrid(),surveyResponse.getScore(),surveyResponse.getThreshold(),surveyResponse.getKnownValidityStatus());
}",0.3485714285714286
109907,"public static Report dynamicAnalysis(Survey survey,List<DynamicSurveyResponse> responses,Classifier classifier,boolean smoothing,double alpha) throws SurveyException {
  return new Report(survey.sourceName,survey.sid,alpha,smoothing,QCMetrics.calculateOrderBiases(survey,responses,alpha),QCMetrics.calculateWordingBiases(survey,responses,alpha),QCMetrics.calculateBreakoffByPosition(survey,responses),QCMetrics.calculateBreakoffByQuestion(survey,responses),QCMetrics.classifyResponses(survey,responses,classifier,smoothing,alpha));
}","public static Report dynamicAnalysis(Survey survey,List<DynamicSurveyResponse> responses,Classifier classifier,boolean smoothing,double alpha) throws SurveyException {
  return new Report(survey.sourceName,survey.sid,alpha,smoothing,OrderBias.calculateOrderBiases(survey,responses,alpha),QCMetrics.calculateWordingBiases(survey,responses,alpha),QCMetrics.calculateBreakoffByPosition(survey,responses),QCMetrics.calculateBreakoffByQuestion(survey,responses),QCMetrics.classifyResponses(survey,responses,classifier,smoothing,alpha));
}",0.8142589118198874
109908,"public CorrelationStruct(CoefficentsAndTests coefficientType,double coefficientValue,Question thingA,Question thingB,int numSamplesA,int numSamplesB){
  this.coefficientType=coefficientType;
  this.coefficientValue=coefficientValue;
  this.thingA=thingA;
  this.thingB=thingB;
  this.numSamplesA=numSamplesA;
  this.numSamplesB=numSamplesB;
}","public CorrelationStruct(CoefficentsAndTests coefficientType,double coefficientValue,double coefficientPValue,Question thingA,Question thingB,int numSamplesA,int numSamplesB){
  this.coefficientType=coefficientType;
  this.coefficientValue=coefficientValue;
  this.coefficientPValue=coefficientPValue;
  this.thingA=thingA;
  this.thingB=thingB;
  this.numSamplesA=numSamplesA;
  this.numSamplesB=numSamplesB;
}",0.9083665338645418
109909,"public OrderBiasStruct(Survey survey,double alpha){
  this.alpha=alpha;
  for (  Question q1 : survey.questions) {
    this.biases.put(q1,new HashMap<Question,CorrelationStruct>());
    for (    Question q2 : survey.questions)     this.biases.get(q1).put(q2,null);
  }
}","public OrderBiasStruct(Survey survey,double alpha){
  this.alpha=alpha;
  for (int i=0; i < survey.questions.size() - 1; i++) {
    Question q1=survey.questions.get(i);
    this.biases.put(q1,new HashMap<Question,CorrelationStruct>());
    for (int j=i + 1; j < survey.questions.size(); j++) {
      Question q2=survey.questions.get(j);
      this.biases.get(q1).put(q2,null);
    }
  }
}",0.6930091185410334
109910,"private boolean flagCondition(CorrelationStruct struct){
  double ratio=struct.numSamplesA / (double)struct.numSamplesB;
  return struct.coefficientValue > 0.0 && struct.coefficientValue < this.alpha && struct.numSamplesA > minSamples && struct.numSamplesB > minSamples && ratio > 1.0 - ratioRange && ratio < 1.0 + ratioRange;
}","private boolean flagCondition(CorrelationStruct struct){
  double ratio=struct.numSamplesA / (double)struct.numSamplesB;
  return struct.coefficientPValue > 0.0 && struct.coefficientPValue < this.alpha && struct.numSamplesA > minSamples && struct.numSamplesB > minSamples && ratio > 1.0 - ratioRange && ratio < 1.0 + ratioRange;
}",0.9969604863221884
109911,"@Override public String toString(){
  List<String> biases=new ArrayList<String>();
  for (  Question q1 : this.biases.keySet()) {
    for (    Question q2 : this.biases.get(q1).keySet()) {
      CorrelationStruct structs=this.biases.get(q1).get(q2);
      if (structs == null)       continue;
      String data=String.format(""String_Node_Str"",q1.data,q2.data,structs.coefficientType.name(),structs.coefficientValue,structs.numSamplesA,structs.numSamplesB);
      SurveyMan.LOGGER.debug(data);
      if (flagCondition(structs))       biases.add(data);
    }
  }
  return ""String_Node_Str"" + ""String_Node_Str"" + StringUtils.join(biases,""String_Node_Str"") + ""String_Node_Str"";
}","@Override public String toString(){
  List<String> biases=new ArrayList<>();
  for (  Question q1 : this.biases.keySet()) {
    for (    Question q2 : this.biases.get(q1).keySet()) {
      CorrelationStruct structs=this.biases.get(q1).get(q2);
      if (structs == null)       continue;
      String data=String.format(""String_Node_Str"",q1.data,q2.data,structs.coefficientType.name(),structs.coefficientValue,structs.coefficientPValue,structs.numSamplesA,structs.numSamplesB);
      if (flagCondition(structs))       biases.add(data);
    }
  }
  return ""String_Node_Str"" + ""String_Node_Str"" + this.numImbalances + ""String_Node_Str""+ ""String_Node_Str""+ this.numComparisons+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtils.join(biases,""String_Node_Str"")+ ""String_Node_Str"";
}",0.6629910406616126
109912,"/** 
 * Returns the next question, according to the status of the interpreter.
 * @return The next question that needs to be answered.
 * @throws SurveyException
 */
public Question getNextQuestion() throws SurveyException {
  Question next=nextQ();
  SurveyDatum[] options=next.getOptListByIndex();
  if (next.randomize)   if (next.ordered) {
    if (random.nextBoolean())     for (int i=0; i < options.length / 2; i++) {
      SurveyDatum foo=options[i];
      options[i]=options[options.length - i - 1];
      options[options.length - i - 1]=foo;
    }
  }
 else {
    List<SurveyDatum> stuff=Arrays.asList(options);
    Collections.shuffle(stuff);
    options=stuff.toArray(options);
  }
  for (int i=0; i < options.length; i++)   options[i].setIndex(i);
  return next;
}","/** 
 * Returns the next question, according to the status of the interpreter.
 * @return The next question that needs to be answered.
 * @throws SurveyException
 */
public Question getNextQuestion() throws SurveyException {
  Question next=nextQ();
  SurveyDatum[] options=next.getOptListByIndex();
  if (next.randomize)   if (next.ordered) {
    if (random.nextBoolean())     for (int i=0; i < options.length / 2; i++) {
      SurveyDatum foo=options[i];
      options[i]=options[options.length - i - 1];
      options[options.length - i - 1]=foo;
    }
  }
 else {
    random.shuffle(options);
  }
  for (int i=0; i < options.length; i++)   options[i].setIndex(i);
  return next;
}",0.9198080877313228
109913,"/** 
 * Returns an empty survey response.
 * @return SurveyResponse object.
 * @throws SurveyException
 */
public SurveyResponse getResponse() throws SurveyException {
  final Map<Question,List<SurveyDatum>> responseMap=this.responseMap;
  final List<IQuestionResponse> questionResponses=new ArrayList<>();
  for (  final Map.Entry<Question,List<SurveyDatum>> e : responseMap.entrySet()) {
    questionResponses.add(new IQuestionResponse(){
      List<Question> questions=new ArrayList<>(responseMap.keySet());
      @Override public Question getQuestion(){
        return e.getKey();
      }
      @Override public List<OptTuple> getOpts(){
        List<OptTuple> retval=new ArrayList<>();
        for (        SurveyDatum c : e.getValue()) {
          retval.add(new OptTuple(c,c.getIndex()));
        }
        return retval;
      }
      @Override public int getIndexSeen(){
        return questions.indexOf(e.getKey());
      }
      @Override public SurveyDatum getAnswer() throws SurveyException {
        if (this.getQuestion().exclusive)         return this.getOpts().get(0).c;
 else         throw new RuntimeException(""String_Node_Str"");
      }
      @Override public List<SurveyDatum> getAnswers() throws SurveyException {
        if (this.getQuestion().exclusive)         throw new RuntimeException(""String_Node_Str"");
        List<SurveyDatum> answers=new ArrayList<>();
        for (        OptTuple optTuple : this.getOpts())         answers.add(optTuple.c);
        return answers;
      }
      @Override public int compareTo(      Object o){
        if (o instanceof IQuestionResponse) {
          IQuestionResponse that=(IQuestionResponse)o;
          return this.getQuestion().compareTo(that.getQuestion());
        }
 else         throw new RuntimeException(String.format(""String_Node_Str"",this.getClass().getName(),o.getClass().getName()));
      }
    }
);
  }
  return new SurveyResponse(survey,questionResponses,SurveyResponse.gensym.next(),0.0,0.0,KnownValidityStatus.MAYBE);
}","/** 
 * Returns an empty survey response.
 * @return SurveyResponse object.
 * @throws SurveyException
 */
public SurveyResponse getResponse() throws SurveyException {
  final Map<Question,List<SurveyDatum>> responseMap=this.responseMap;
  final List<Question> questionList=this.questionList;
  final List<IQuestionResponse> questionResponses=new ArrayList<>();
  for (  final Map.Entry<Question,List<SurveyDatum>> e : responseMap.entrySet()) {
    questionResponses.add(new IQuestionResponse(){
      List<Question> questions=new ArrayList<>(responseMap.keySet());
      @Override public Question getQuestion(){
        return e.getKey();
      }
      @Override public List<OptTuple> getOpts(){
        List<OptTuple> retval=new ArrayList<>();
        for (        SurveyDatum c : e.getValue()) {
          retval.add(new OptTuple(c,c.getIndex()));
        }
        return retval;
      }
      @Override public int getIndexSeen(){
        return questionList.indexOf(e.getKey());
      }
      @Override public SurveyDatum getAnswer() throws SurveyException {
        if (this.getQuestion().exclusive)         return this.getOpts().get(0).c;
 else         throw new RuntimeException(""String_Node_Str"");
      }
      @Override public List<SurveyDatum> getAnswers() throws SurveyException {
        if (this.getQuestion().exclusive)         throw new RuntimeException(""String_Node_Str"");
        List<SurveyDatum> answers=new ArrayList<>();
        for (        OptTuple optTuple : this.getOpts())         answers.add(optTuple.c);
        return answers;
      }
      @Override public int compareTo(      Object o){
        if (o instanceof IQuestionResponse) {
          IQuestionResponse that=(IQuestionResponse)o;
          return this.getQuestion().compareTo(that.getQuestion());
        }
 else         throw new RuntimeException(String.format(""String_Node_Str"",this.getClass().getName(),o.getClass().getName()));
      }
    }
);
  }
  return new SurveyResponse(survey,questionResponses,SurveyResponse.gensym.next(),0.0,0.0,KnownValidityStatus.MAYBE);
}",0.9852507374631267
109914,"/** 
 * Answers question q with some list of answers.
 * @param q Question of interest.
 * @param aList List of components (i.e., valid answer(s) to the input question) .
 * @throws SurveyException
 */
public void answer(Question q,List<SurveyDatum> aList) throws SurveyException {
  responseMap.put(q,aList);
  if (q.isBranchQuestion()) {
    branchTo=q.getBranchDest(aList.get(0));
  }
}","/** 
 * Answers question q with some list of answers.
 * @param q Question of interest.
 * @param aList List of components (i.e., valid answer(s) to the input question) .
 * @throws SurveyException
 */
public void answer(Question q,List<SurveyDatum> aList) throws SurveyException {
  responseMap.put(q,aList);
  questionList.add(q);
  if (q.isBranchQuestion()) {
    branchTo=q.getBranchDest(aList.get(0));
  }
}",0.9712858926342072
109915,"@Override public int getIndexSeen(){
  return questions.indexOf(e.getKey());
}","@Override public int getIndexSeen(){
  return questionList.indexOf(e.getKey());
}",0.981132075471698
109916,"private void unifyBranching(Survey survey,JsonArray jsonBlocks) throws BranchException {
  for (  JsonElement e : jsonBlocks) {
    JsonObject block=e.getAsJsonObject();
    if (block.has(""String_Node_Str"")) {
      for (      JsonElement qs : block.getAsJsonArray(""String_Node_Str"")) {
        JsonObject q=qs.getAsJsonObject();
        if (q.has(""String_Node_Str"")) {
          String jsonId=q.get(""String_Node_Str"").getAsString();
          Question question=findQuestion(survey.questions,internalIdMap.get(jsonId));
          for (          Map.Entry<String,JsonElement> ee : q.get(""String_Node_Str"").getAsJsonObject().entrySet())           question.addOption(question.options.get(ee.getKey()),this.internalBlockLookup.get(ee.getValue().getAsString()));
          if (question.block.branchQ == null) {
            question.block.branchParadigm=Block.BranchParadigm.ONE;
            question.block.branchQ=question;
          }
 else           if (question.block.branchQ != question) {
            question.block.branchParadigm=Block.BranchParadigm.ALL;
          }
        }
      }
    }
    if (block.has(""String_Node_Str"")) {
      unifyBranching(survey,block.get(""String_Node_Str"").getAsJsonArray());
    }
  }
}","private void unifyBranching(Survey survey,JsonArray jsonBlocks) throws SurveyException {
  for (  JsonElement e : jsonBlocks) {
    JsonObject block=e.getAsJsonObject();
    if (block.has(""String_Node_Str"")) {
      for (      JsonElement qs : block.getAsJsonArray(""String_Node_Str"")) {
        JsonObject q=qs.getAsJsonObject();
        if (q.has(""String_Node_Str"")) {
          String jsonQuestionId=q.get(""String_Node_Str"").getAsString();
          Question question=findQuestion(survey.questions,internalIdMap.get(jsonQuestionId));
          for (          Map.Entry<String,JsonElement> ee : q.get(""String_Node_Str"").getAsJsonObject().entrySet()) {
            String jsonOptionId=ee.getKey();
            String jsonBlockId=ee.getValue().getAsString();
            if (jsonBlockId.equals(Block.NEXT))             continue;
            Component opt=findOption(question,internalIdMap.get(jsonOptionId));
            Block dest=findBlock(jsonBlockId);
            question.addOption(opt,dest);
          }
          if (question.block.branchQ == null) {
            question.block.branchParadigm=Block.BranchParadigm.ONE;
            question.block.branchQ=question;
          }
 else           if (question.block.branchQ != question) {
            question.block.branchParadigm=Block.BranchParadigm.ALL;
          }
        }
      }
    }
    if (block.has(""String_Node_Str"")) {
      unifyBranching(survey,block.get(""String_Node_Str"").getAsJsonArray());
    }
  }
}",0.8234856930509105
109917,"private Component makeComponent(JsonObject option,int r){
  String data=option.get(""String_Node_Str"").getAsString();
  if (HTMLComponent.isHTMLComponent(data))   return new HTMLComponent(data,r,OPTION_COL);
 else   return new StringComponent(data,r,OPTION_COL);
}","private Component makeComponent(JsonObject option,int r){
  String data=option.get(""String_Node_Str"").getAsString();
  String id=option.get(""String_Node_Str"").getAsString();
  Component c;
  if (HTMLComponent.isHTMLComponent(data))   c=new HTMLComponent(data,r,OPTION_COL);
 else   c=new StringComponent(data,r,OPTION_COL);
  internalIdMap.put(id,c.getCid());
  return c;
}",0.550314465408805
109918,"/** 
 * Returns the maximum possible entropy for a single Question.
 * @param question
 * @return
 */
private static double maxEntropyOneQuestion(Question question){
  double retval=0.0;
  int numOptions=question.options.size();
  if (numOptions != 0) {
    retval+=Math.log((double)numOptions) / Math.log(2.0);
  }
  return retval;
}","/** 
 * Returns the maximum possible entropy for a single Question.
 * @param question
 * @return
 */
private static double maxEntropyOneQuestion(Question question){
  double retval=0.0;
  int numOptions=question.options.size();
  if (numOptions != 0) {
    retval+=log2((double)numOptions);
  }
  return retval;
}",0.9660493827160492
109919,"public static double surveyEntropy(Survey s,List<ISurveyResponse> responses){
  List<List<Block>> paths=getPaths(s);
  Map<List<Block>,List<ISurveyResponse>> pathMap=makeFrequenciesForPaths(paths,responses);
  int totalResponses=responses.size();
  double retval=0.0;
  for (  Question q : removeFreetext(s.questions)) {
    for (    Component c : q.options.values()) {
      for (      List<Block> path : paths) {
        List<Component> variants=getEquivalentAnswerVariants(q,c);
        List<ISurveyResponse> responsesThisPath=pathMap.get(path);
        List<ISurveyResponse> ansThisPath=new ArrayList<ISurveyResponse>();
        for (        ISurveyResponse r : responsesThisPath) {
          if (r.surveyResponseContainsAnswer(variants)) {
            ansThisPath.add(r);
          }
        }
        double p=ansThisPath.size() / (double)totalResponses;
        retval+=(Math.log(p) / Math.log(2.0)) * p;
      }
    }
  }
  return -retval;
}","public static double surveyEntropy(Survey s,List<ISurveyResponse> responses){
  List<List<Block>> paths=getPaths(s);
  Map<List<Block>,List<ISurveyResponse>> pathMap=makeFrequenciesForPaths(paths,responses);
  int totalResponses=responses.size();
  double retval=0.0;
  for (  Question q : removeFreetext(s.questions)) {
    for (    Component c : q.options.values()) {
      for (      List<Block> path : paths) {
        List<Component> variants=getEquivalentAnswerVariants(q,c);
        List<ISurveyResponse> responsesThisPath=pathMap.get(path);
        List<ISurveyResponse> ansThisPath=new ArrayList<ISurveyResponse>();
        for (        ISurveyResponse r : responsesThisPath) {
          if (r.surveyResponseContainsAnswer(variants)) {
            ansThisPath.add(r);
          }
        }
        double p=ansThisPath.size() / (double)totalResponses;
        retval+=log2(p) * p;
      }
    }
  }
  return -retval;
}",0.9861407249466952
109920,"public static double getLLForResponse(ISurveyResponse surveyResponse,Map<String,Map<String,Double>> probabilities){
  double ll=0.0;
  for (  IQuestionResponse questionResponse : surveyResponse.getResponses()) {
    String qid=questionResponse.getQuestion().quid;
    for (    String cid : OptTuple.getCids(questionResponse.getOpts())) {
      ll+=Math.log(probabilities.get(qid).get(cid)) / Math.log(2.0);
    }
  }
  return ll;
}","public static double getLLForResponse(ISurveyResponse surveyResponse,Map<String,Map<String,Double>> probabilities){
  double ll=0.0;
  for (  IQuestionResponse questionResponse : surveyResponse.getResponses()) {
    String qid=questionResponse.getQuestion().quid;
    for (    String cid : OptTuple.getCids(questionResponse.getOpts())) {
      ll+=log2(probabilities.get(qid).get(cid));
    }
  }
  return ll;
}",0.9548693586698336
109921,"@Test public void testParse() throws Exception {
  String[] jsonExamples=Slurpie.slurp(""String_Node_Str"").split(""String_Node_Str"");
  for (  String f : jsonExamples) {
    JSONParser parser=JSONParser.makeParser(f);
    Survey s=parser.parse();
    LOGGER.debug(""String_Node_Str"" + s.toString());
  }
}","@Test public void testParse() throws Exception {
  String[] jsonExamples=Slurpie.slurp(""String_Node_Str"").split(""String_Node_Str"");
  LOGGER.info(String.format(""String_Node_Str"",Arrays.toString(jsonExamples)));
  for (  String f : jsonExamples) {
    LOGGER.debug(String.format(""String_Node_Str"",f));
    JSONParser parser=JSONParser.makeParser(f);
    LOGGER.debug(String.format(""String_Node_Str"",f));
    Survey s=parser.parse();
    LOGGER.debug(""String_Node_Str"" + s.toString());
  }
}",0.7635903919089759
109922,"@Test public void testNonRandomRespondentFrequencies(){
  AbstractRespondent profile=new NonRandomRespondent(survey);
  List<ISurveyResponse> responses=new ArrayList<ISurveyResponse>();
  for (int i=0; i < 10; i++) {
    responses.add(profile.getResponse());
  }
}","@Test public void testNonRandomRespondentFrequencies(){
}",0.3551401869158878
109923,"private String[] getHeaders(Reader reader) throws SurveyException, IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
  Gensym gensym=new Gensym(""String_Node_Str"");
  boolean hasQuestion=false, hasOption=false;
  CsvPreference pref;
  if (this.sep.equals(""String_Node_Str""))   pref=CsvPreference.EXCEL_PREFERENCE;
 else   if (this.sep.equals(""String_Node_Str"") || this.sep.equals(""String_Node_Str"") || this.sep.equals(""String_Node_Str""))   pref=CsvPreference.TAB_PREFERENCE;
 else   throw new SyntaxException(""String_Node_Str"" + this.sep);
  CsvListReader csvListReader=new CsvListReader(reader,pref);
  List<String> line=csvListReader.read();
  String[] headers=mapStringOp(line.toArray(new String[line.size()]),String.class.getMethod(""String_Node_Str""));
  headers=mapStringOp(headers,String.class.getMethod(""String_Node_Str""));
  for (int i=0; i < headers.length; i++) {
    if (headers[i].equals(AbstractParser.QUESTION))     hasQuestion=true;
    if (headers[i].equals(AbstractParser.OPTIONS))     hasOption=true;
    if (headers[i].equals(""String_Node_Str""))     headers[i]=gensym.next();
  }
  if (!hasQuestion || !hasOption)   throw new HeaderException(String.format(""String_Node_Str"",hasQuestion ? AbstractParser.OPTIONS : AbstractParser.QUESTION,this.filename,sep));
  return headers;
}","private int getHeaders(Reader reader) throws SurveyException, IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
}",0.2021563342318059
109924,"private CellProcessor[] makeProcessors() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
  CellProcessor[] cellProcessors=new CellProcessor[headers.length];
  String[] truthValues=new String[(trueValues.length + falseValues.length) * 2];
  Method upperCase=String.class.getMethod(""String_Node_Str"");
  System.arraycopy(trueValues,0,truthValues,0,trueValues.length);
  System.arraycopy(falseValues,0,truthValues,trueValues.length,falseValues.length);
  System.arraycopy(mapStringOp(trueValues,upperCase),0,truthValues,trueValues.length + falseValues.length,trueValues.length);
  System.arraycopy(mapStringOp(falseValues,upperCase),0,truthValues,(trueValues.length * 2) + falseValues.length,falseValues.length);
  for (int i=0; i < headers.length; i++) {
    String header=headers[i];
    if (header.equals(AbstractParser.BLOCK))     cellProcessors[i]=new Optional(new StrRegEx(""String_Node_Str""));
 else     if (header.equals(AbstractParser.BRANCH))     cellProcessors[i]=new Optional(new StrRegEx(""String_Node_Str""));
 else     if (header.equals(AbstractParser.EXCLUSIVE) || headers[i].equals(AbstractParser.ORDERED) || headers[i].equals(AbstractParser.RANDOMIZE))     cellProcessors[i]=new Optional(new IsIncludedIn(truthValues));
 else     cellProcessors[i]=new Optional();
  }
  return cellProcessors;
}","private CellProcessor[] makeProcessors() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
}",0.1693989071038251
109925,"@Test public void testNonRandomRespondent() throws InvocationTargetException, SurveyException, IllegalAccessException, NoSuchMethodException, IOException {
  LOGGER.info(""String_Node_Str"");
  Survey survey=new CSVParser(new CSVLexer(super.testsFiles[0],String.valueOf(super.separators[0]))).parse();
  AbstractRespondent profile=new NonRandomRespondent(survey);
  ISurveyResponse sr1=profile.getResponse();
  ISurveyResponse sr2=profile.getResponse();
  List<ISurveyResponse> srs=new ArrayList<ISurveyResponse>();
  srs.add(sr1);
  srs.add(sr2);
  Map<String,Map<String,Double>> probs=QCMetrics.makeProbabilities(QCMetrics.makeFrequencies(srs));
  double ll1=QCMetrics.getLLForResponse(sr1,probs);
  double ll2=QCMetrics.getLLForResponse(sr2,probs);
  LOGGER.debug(String.format(""String_Node_Str"",ll1,ll2));
}","@Test public void testNonRandomRespondent() throws InvocationTargetException, SurveyException, IllegalAccessException, NoSuchMethodException, IOException {
}",0.3250517598343685
109926,"public static double averagePathLength(Survey survey) throws SurveyException {
  double lengthSum=0.0;
  for (int i=0; i < 5000; i++) {
    System.out.println(lengthSum);
    lengthSum+=new RandomRespondent(survey,RandomRespondent.AdversaryType.UNIFORM).response.responses.size();
  }
  return lengthSum / 5000.0;
}","public static double averagePathLength(Survey survey) throws SurveyException {
  double lengthSum=0.0;
  for (int i=0; i < 5000; i++) {
    lengthSum+=new RandomRespondent(survey,RandomRespondent.AdversaryType.UNIFORM).response.responses.size();
  }
  return lengthSum / 5000.0;
}",0.9411764705882352
109927,"private void populateResponses() throws SurveyException {
  Interpreter interpreter=new Interpreter(survey);
  do {
    Question q=interpreter.getNextQuestion();
    Component[] c=q.getOptListByIndex();
    List<Component> answers=new ArrayList<Component>();
    int denom=getDenominator(q);
    if (q.freetext || denom < 1) {
      answers.add(new StringComponent(""String_Node_Str"",-1,-1));
    }
 else {
      double prob=rng.nextDouble();
      double cumulativeProb=0.0;
      for (int j=0; j < denom; j++) {
        cumulativeProb+=posPref.get(q)[j];
        if (prob < cumulativeProb) {
          answers.addAll(selectOptions(j,c));
        }
      }
    }
    interpreter.answer(q,answers);
  }
 while (!interpreter.terminated());
  this.response=interpreter.getResponse();
}","private void populateResponses() throws SurveyException {
}",0.1403091557669441
109928,"private List<Component> selectOptions(int i,Component[] options){
  List<Component> retval=new ArrayList<Component>();
  if (i > options.length) {
    int j=0;
    for (    char c : Integer.toBinaryString(i).toCharArray()) {
      if (c == '1')       retval.add(options[j]);
      j++;
    }
  }
 else   retval.add(options[i]);
  return retval;
}","private List<Component> selectOptions(int i,Component[] options){
}",0.324455205811138
109929,"private int resetQuestionIndices(Block b,int startingIndex){
  System.out.println(""String_Node_Str"" + b.strId + ""String_Node_Str""+ startingIndex);
  int index=startingIndex;
  for (  Question q : b.questions) {
    q.index=index;
    index++;
  }
  for (  Block bb : b.subBlocks) {
    System.out.println(String.format(""String_Node_Str"",b.strId,bb.strId,index));
    index+=resetQuestionIndices(bb,index);
  }
  System.out.println(String.format(""String_Node_Str"",b.strId,b.blockSize()));
  return b.blockSize();
}","private int resetQuestionIndices(Block b,int startingIndex){
  LOGGER.info(""String_Node_Str"" + b.strId + ""String_Node_Str""+ startingIndex);
  int index=startingIndex;
  for (  Question q : b.questions) {
    q.index=index;
    index++;
  }
  for (  Block bb : b.subBlocks) {
    LOGGER.info(String.format(""String_Node_Str"",b.strId,bb.strId,index));
    index+=resetQuestionIndices(bb,index);
  }
  LOGGER.info(String.format(""String_Node_Str"",b.strId,b.blockSize()));
  return b.blockSize();
}",0.5393034825870647
109930,"public static String getHTMLString(Survey survey,system.interfaces.HTML backendHTML) throws SurveyException {
  String html=""String_Node_Str"";
  try {
    if (ResponseManager.getRecord(survey) == null)     ResponseManager.putRecord(survey,new Library(),BackendType.LOCALHOST);
    Record record=ResponseManager.getRecord(survey);
    assert(record != null);
    assert(record.library != null);
    assert(record.library.props != null);
    Component preview=CSVParser.parseComponent(record.library.props.getProperty(""String_Node_Str"",""String_Node_Str""),-1,-1);
    System.out.println(backendHTML.getClass().getName());
    html=String.format(Slurpie.slurp(Library.HTMLSKELETON),survey.encoding,JS.getJSString(survey,preview),stringifyPreview(preview),stringify(),backendHTML.getActionForm(record),survey.source,record.outputFileName,backendHTML.getHTMLString(),Slurpie.slurp(Library.CUSTOMCSS,true));
  }
 catch (  FileNotFoundException ex) {
    LOGGER.fatal(ex);
    System.exit(-1);
  }
catch (  IOException ex) {
    LOGGER.fatal(ex);
    System.exit(-1);
  }
  try {
    spitHTMLToFile(html,survey);
  }
 catch (  IOException io) {
    LOGGER.warn(io);
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
  return (new HtmlCompressor()).compress(html);
}","public static String getHTMLString(Survey survey,system.interfaces.HTML backendHTML) throws SurveyException {
  String html=""String_Node_Str"";
  try {
    if (ResponseManager.getRecord(survey) == null)     ResponseManager.putRecord(survey,new Library(),BackendType.LOCALHOST);
    Record record=ResponseManager.getRecord(survey);
    assert(record != null);
    assert(record.library != null);
    assert(record.library.props != null);
    Component preview=CSVParser.parseComponent(record.library.props.getProperty(""String_Node_Str"",""String_Node_Str""),-1,-1);
    html=String.format(Slurpie.slurp(Library.HTMLSKELETON),survey.encoding,JS.getJSString(survey,preview),stringifyPreview(preview),stringify(),backendHTML.getActionForm(record),survey.source,record.outputFileName,backendHTML.getHTMLString(),Slurpie.slurp(Library.CUSTOMCSS,true));
  }
 catch (  FileNotFoundException ex) {
    LOGGER.fatal(ex);
    System.exit(-1);
  }
catch (  IOException ex) {
    LOGGER.fatal(ex);
    System.exit(-1);
  }
  try {
    spitHTMLToFile(html,survey);
  }
 catch (  IOException io) {
    LOGGER.warn(io);
  }
catch (  InstantiationException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
  return (new HtmlCompressor()).compress(html);
}",0.9779299847792998
109931,"private static String jsonizeQuestion(Question question) throws SurveyException {
  String options=jsonizeOptions(Arrays.asList(question.getOptListByIndex()));
  String branchMap=jsonizeBranchMap(question.branchMap);
  StringBuilder qtext=new StringBuilder();
  try {
    for (    Component q : question.data) {
      qtext.append(HTML.stringify(q));
    }
  }
 catch (  SurveyException se) {
    LOGGER.info(""String_Node_Str"" + se);
  }
  return String.format(""String_Node_Str"",question.quid,CSVLexer.xmlChars2HTML(qtext.toString()),options.equals(""String_Node_Str"") ? (question.freetext ? String.format(""String_Node_Str"",getFreetextValue(question)) : ""String_Node_Str"") : String.format(""String_Node_Str"",options),branchMap.equals(""String_Node_Str"") ? ""String_Node_Str"" : String.format(""String_Node_Str"",branchMap),question.randomize.equals(CSVParser.defaultValues.get(Survey.RANDOMIZE)) ? ""String_Node_Str"" : String.format(""String_Node_Str"",question.randomize),question.ordered.equals(CSVParser.defaultValues.get(Survey.ORDERED)) ? ""String_Node_Str"" : String.format(""String_Node_Str"",question.ordered),question.exclusive.equals(CSVParser.defaultValues.get(Survey.EXCLUSIVE)) ? ""String_Node_Str"" : String.format(""String_Node_Str"",question.exclusive),question.permitBreakoff == true ? ""String_Node_Str"" : ""String_Node_Str"");
}","private static String jsonizeQuestion(Question question) throws SurveyException {
  String options=jsonizeOptions(Arrays.asList(question.getOptListByIndex()));
  String branchMap=jsonizeBranchMap(question.branchMap);
  StringBuilder qtext=new StringBuilder();
  StringBuilder otherStuff=new StringBuilder();
  try {
    for (    Component q : question.data) {
      qtext.append(HTML.stringify(q));
    }
  }
 catch (  SurveyException se) {
    LOGGER.info(""String_Node_Str"" + se);
  }
  if (options.equals(""String_Node_Str""))   otherStuff.append(question.freetext ? String.format(""String_Node_Str"",getFreetextValue(question)) : ""String_Node_Str"");
 else   otherStuff.append(String.format(""String_Node_Str"",options));
  if (!branchMap.equals(""String_Node_Str""))   otherStuff.append(String.format(""String_Node_Str"",branchMap));
  if (question.randomize != CSVParser.defaultValues.get(Survey.RANDOMIZE).booleanValue())   otherStuff.append(String.format(""String_Node_Str"",question.randomize));
  if (question.ordered != CSVParser.defaultValues.get(Survey.ORDERED).booleanValue())   otherStuff.append(String.format(""String_Node_Str"",question.ordered));
  if (question.exclusive != CSVParser.defaultValues.get(Survey.EXCLUSIVE).booleanValue())   otherStuff.append(String.format(""String_Node_Str"",question.exclusive));
  if (!question.permitBreakoff)   otherStuff.append(""String_Node_Str"");
  return String.format(""String_Node_Str"",question.quid,CSVLexer.xmlChars2HTML(qtext.toString()),otherStuff.toString());
}",0.5515536723163842
109932,"@Override public void refresh(Record record){
  MturkLibrary lib=(MturkLibrary)record.library;
  config.setServiceURL(lib.MTURK_URL);
  service=new RequesterService(config);
}","@Override public void refresh(Record record){
  if (!record.library.getClass().equals(MturkLibrary.class)) {
    record.library=new MturkLibrary();
  }
  MturkLibrary lib=(MturkLibrary)record.library;
  config.setServiceURL(lib.MTURK_URL);
  service=new RequesterService(config);
}",0.7675438596491229
109933,"@Override public boolean makeTaskAvailable(String taskId){
  return false;
}","@Override public boolean makeTaskAvailable(String taskId,Record r){
  return false;
}",0.9440993788819876
109934,"public Survey parse() throws MalformedURLException, SurveyException {
  Map<String,ArrayList<CSVEntry>> lexemes=csvLexer.entries;
  Survey survey=new Survey();
  survey.encoding=csvLexer.encoding;
  survey.source=csvLexer.filename;
  survey.sourceName=new File(csvLexer.filename).getName().split(""String_Node_Str"")[0];
  for (  String key : lexemes.keySet())   CSVEntry.sort(lexemes.get(key));
  ArrayList<Question> questions=unifyQuestions();
  survey.questions=questions;
  if (lexemes.containsKey(Survey.BLOCK)) {
    ArrayList<Block> blocks=initializeBlocks();
    unifyBlocks(lexemes.get(Survey.BLOCK),blocks,lexemes.get(Survey.QUESTION),questions);
    survey.blocks=blocks;
  }
 else   survey.blocks=new ArrayList<Block>();
  unifyBranching(survey);
  for (  Question q : questions) {
    Block b=q.block;
    int[] bid=b.getBlockId();
    for (int i=0; i < bid.length; i++) {
      int[] ancestor=new int[i + 1];
      for (int j=0; j <= i; j++)       ancestor[i]=j;
      String ancestorId=Block.idToString(ancestor);
      assert(this.allBlockLookUp.containsKey(ancestorId));
    }
  }
  Collections.sort(survey.blocks);
  survey.resetQuestionIndices();
  Collections.sort(survey.questions);
  for (  String id : this.allBlockLookUp.keySet())   System.out.println(id);
  for (  Question q : survey.questions) {
    System.out.println(q.toString() + q.block.strId);
    Block currentBlock=q.block;
    int[] parentBlockId=q.block.parentBlockID;
    while (parentBlockId != null) {
      System.out.println(""String_Node_Str"" + Block.idToString(parentBlockId));
      currentBlock=this.allBlockLookUp.get(Block.idToString(parentBlockId));
      System.out.println(""String_Node_Str"" + Block.idToString(currentBlock.getBlockId()));
      parentBlockId=currentBlock.parentBlockID;
    }
  }
  survey.correlationMap=this.correlationMap;
  return survey;
}","public Survey parse() throws MalformedURLException, SurveyException {
  Map<String,ArrayList<CSVEntry>> lexemes=csvLexer.entries;
  Survey survey=new Survey();
  survey.encoding=csvLexer.encoding;
  survey.source=csvLexer.filename;
  survey.sourceName=new File(csvLexer.filename).getName().split(""String_Node_Str"")[0];
  for (  String key : lexemes.keySet())   CSVEntry.sort(lexemes.get(key));
  ArrayList<Question> questions=unifyQuestions();
  survey.questions=questions;
  if (lexemes.containsKey(Survey.BLOCK)) {
    ArrayList<Block> blocks=initializeBlocks();
    unifyBlocks(lexemes.get(Survey.BLOCK),blocks,lexemes.get(Survey.QUESTION),questions);
    survey.blocks=blocks;
  }
 else   survey.blocks=new ArrayList<Block>();
  unifyBranching(survey);
  for (  Question q : questions) {
    Block b=q.block;
    int[] bid=b.getBlockId();
    for (int i=0; i < bid.length; i++) {
      int[] ancestor=new int[i + 1];
      for (int j=0; j <= i; j++)       ancestor[i]=j;
      String ancestorId=Block.idToString(ancestor);
      assert(this.allBlockLookUp.containsKey(ancestorId));
    }
  }
  Collections.sort(survey.blocks);
  survey.resetQuestionIndices();
  Collections.sort(survey.questions);
  for (  Question q : survey.questions) {
    System.out.println(q.toString() + q.block.strId);
    Block currentBlock=q.block;
    int[] parentBlockId=q.block.parentBlockID;
    while (parentBlockId != null) {
      assert(this.allBlockLookUp.get(Block.idToString(parentBlockId)).subBlocks.contains(currentBlock));
      System.out.println(""String_Node_Str"" + Block.idToString(parentBlockId));
      currentBlock=this.allBlockLookUp.get(Block.idToString(parentBlockId));
      System.out.println(""String_Node_Str"" + Block.idToString(currentBlock.getBlockId()));
      parentBlockId=currentBlock.parentBlockID;
    }
  }
  survey.correlationMap=this.correlationMap;
  return survey;
}",0.9513888888888888
109935,"private int resetQuestionIndices(Block b,int startingIndex){
  int index=startingIndex;
  for (  Question q : b.questions) {
    q.index=index;
    index++;
  }
  for (  Block bb : b.subBlocks) {
    System.out.println(String.format(""String_Node_Str"",b.strId,bb.strId));
    index+=resetQuestionIndices(bb,index);
  }
  return index;
}","private int resetQuestionIndices(Block b,int startingIndex){
  System.out.println(""String_Node_Str"" + b.strId + ""String_Node_Str""+ startingIndex);
  int index=startingIndex;
  for (  Question q : b.questions) {
    q.index=index;
    index++;
  }
  for (  Block bb : b.subBlocks) {
    System.out.println(String.format(""String_Node_Str"",b.strId,bb.strId,index));
    index+=resetQuestionIndices(bb,index);
  }
  System.out.println(String.format(""String_Node_Str"",b.strId,b.blockSize()));
  return b.blockSize();
}",0.7617924528301887
109936,"public Survey parse() throws MalformedURLException, SurveyException {
  Map<String,ArrayList<CSVEntry>> lexemes=csvLexer.entries;
  Survey survey=new Survey();
  survey.encoding=csvLexer.encoding;
  survey.source=csvLexer.filename;
  survey.sourceName=new File(csvLexer.filename).getName().split(""String_Node_Str"")[0];
  for (  String key : lexemes.keySet())   CSVEntry.sort(lexemes.get(key));
  ArrayList<Question> questions=unifyQuestions();
  survey.questions=questions;
  if (lexemes.containsKey(Survey.BLOCK)) {
    ArrayList<Block> blocks=initializeBlocks();
    unifyBlocks(lexemes.get(Survey.BLOCK),blocks,lexemes.get(Survey.QUESTION),questions);
    survey.blocks=blocks;
  }
 else   survey.blocks=new ArrayList<Block>();
  Collections.sort(survey.blocks);
  unifyBranching(survey);
  survey.correlationMap=this.correlationMap;
  return survey;
}","public Survey parse() throws MalformedURLException, SurveyException {
  Map<String,ArrayList<CSVEntry>> lexemes=csvLexer.entries;
  Survey survey=new Survey();
  survey.encoding=csvLexer.encoding;
  survey.source=csvLexer.filename;
  survey.sourceName=new File(csvLexer.filename).getName().split(""String_Node_Str"")[0];
  for (  String key : lexemes.keySet())   CSVEntry.sort(lexemes.get(key));
  ArrayList<Question> questions=unifyQuestions();
  survey.questions=questions;
  if (lexemes.containsKey(Survey.BLOCK)) {
    ArrayList<Block> blocks=initializeBlocks();
    unifyBlocks(lexemes.get(Survey.BLOCK),blocks,lexemes.get(Survey.QUESTION),questions);
    survey.blocks=blocks;
  }
 else   survey.blocks=new ArrayList<Block>();
  Collections.sort(survey.blocks);
  int startingIndex=0;
  for (  Block b : survey.blocks) {
    System.out.println(b.strId + ""String_Node_Str"" + b.index);
    Block.propagateQuestionIndices(b,0);
    startingIndex+=b.blockSize();
  }
  Collections.sort(survey.questions);
  for (  Question q : survey.questions)   System.out.print(""String_Node_Str"" + q.index);
  System.out.println();
  unifyBranching(survey);
  survey.correlationMap=this.correlationMap;
  return survey;
}",0.8292919495635306
109937,"protected static void shuffleRandomizedBlocks(List<Block> blockCollection){
  List<Integer> indices=new ArrayList<Integer>();
  for (  Block b : blockCollection)   indices.add(b.index);
  Collections.shuffle(indices,Question.rng);
  for (int i=0; i < blockCollection.size(); i++)   blockCollection.get(i).index=indices.get(i);
  for (  Block b : blockCollection)   propagateIndices(b);
}","protected static void shuffleRandomizedBlocks(List<Block> blockCollection){
  List<Integer> indices=new ArrayList<Integer>();
  for (  Block b : blockCollection)   indices.add(b.index);
  Collections.shuffle(indices,Question.rng);
  for (int i=0; i < blockCollection.size(); i++)   blockCollection.get(i).index=indices.get(i);
  for (  Block b : blockCollection)   propagateBlockIndices(b);
}",0.993581514762516
109938,"public void sort() throws SurveyException {
  System.out.println(""String_Node_Str"");
  Collections.sort(questions);
  Collections.sort(subBlocks);
  int base=questions.get(0).index, j=0;
}","public void sort() throws SurveyException {
  System.out.println(""String_Node_Str"");
  Collections.sort(questions);
  Collections.sort(subBlocks);
  int base=questions.get(0).index, j=0;
  for (int i=1; i < questions.size(); i++) {
    int thisIndex=questions.get(i).index;
    if (i + base != thisIndex)     if (subBlocks != null)     for (    Block b : subBlocks.subList(j,subBlocks.size())) {
      j+=1;
      int jumpIndex=i + base + b.blockSize();
      if (jumpIndex == thisIndex)       break;
 else       if (jumpIndex > thisIndex)       throw new BlockContiguityException(questions.get(i - 1),questions.get(i),this,this.getClass().getEnclosingMethod());
    }
 else     throw new BlockContiguityException(questions.get(i - 1),questions.get(i),this,this.getClass().getEnclosingMethod());
  }
}",0.3801820020222446
109939,"public void randomize() throws SurveyException {
  sort();
  Question[] qs=questions.toArray(new Question[questions.size()]);
  for (int i=qs.length; i > 0; i--) {
    int j=Question.rng.nextInt(i);
    int k=qs[j].index;
    qs[j].index=qs[i - 1].index;
    qs[i - 1].index=k;
  }
  for (  Question q : qs)   q.randomize();
  List<Block> randomizedBlocks=new LinkedList<Block>();
  for (  Block b : this.subBlocks)   if (b.randomize)   randomizedBlocks.add(b);
  shuffleRandomizedBlocks(randomizedBlocks);
  sort();
  if (subBlocks != null)   for (  Block b : subBlocks)   b.randomize();
}","public void randomize() throws SurveyException {
  sort();
  List<Block> randomizedBlocks=new LinkedList<Block>();
  shuffleRandomizedBlocks(randomizedBlocks);
  for (  Block b : this.subBlocks)   if (b.randomize)   randomizedBlocks.add(b);
  sort();
  Question[] qs=questions.toArray(new Question[questions.size()]);
  for (int i=qs.length; i > 0; i--) {
    int j=Question.rng.nextInt(i);
    int k=qs[j].index;
    qs[j].index=qs[i - 1].index;
    qs[i - 1].index=k;
  }
  for (  Question q : qs)   q.randomize();
  if (subBlocks != null)   for (  Block b : subBlocks)   b.randomize();
  sort();
}",0.5899159663865546
109940,"public void sort() throws SurveyException {
  Collections.sort(questions);
  Collections.sort(subBlocks);
  int base=questions.get(0).index, j=0;
}","public void sort() throws SurveyException {
  System.out.println(""String_Node_Str"");
  Collections.sort(questions);
  Collections.sort(subBlocks);
  int base=questions.get(0).index, j=0;
}",0.8776119402985074
109941,"public void randomize() throws SurveyException {
  sort();
  Question[] qs=questions.toArray(new Question[questions.size()]);
  for (int i=qs.length; i > 0; i--) {
    int j=Question.rng.nextInt(i);
    int k=qs[j].index;
    qs[j].index=qs[i - 1].index;
    qs[i - 1].index=k;
  }
  for (  Question q : qs)   q.randomize();
  List<Block> randomizedBlocks=new LinkedList<Block>();
  for (  Block b : this.subBlocks)   if (b.randomize)   randomizedBlocks.add(b);
  shuffleRandomizedBlocks(randomizedBlocks);
  sort();
  if (branchQ != null) {
    Question lastQuestion=questions.get(questions.size() - 1);
    int lastIndex=lastQuestion.index;
    lastQuestion.index=branchQ.index;
    branchQ.index=lastIndex;
    sort();
  }
  if (subBlocks != null)   for (  Block b : subBlocks)   b.randomize();
}","public void randomize() throws SurveyException {
  sort();
  Question[] qs=questions.toArray(new Question[questions.size()]);
  for (int i=qs.length; i > 0; i--) {
    int j=Question.rng.nextInt(i);
    int k=qs[j].index;
    qs[j].index=qs[i - 1].index;
    qs[i - 1].index=k;
  }
  for (  Question q : qs)   q.randomize();
  List<Block> randomizedBlocks=new LinkedList<Block>();
  for (  Block b : this.subBlocks)   if (b.randomize)   randomizedBlocks.add(b);
  shuffleRandomizedBlocks(randomizedBlocks);
  sort();
  if (subBlocks != null)   for (  Block b : subBlocks)   b.randomize();
}",0.7688984881209503
109942,"public void randomize() throws SurveyException {
  Component[] opts=getOptListByIndex();
  if (randomize)   if (ordered && rng.nextFloat() > 0.5) {
    for (int i=0; i < opts.length; i++)     opts[i].index=opts.length - 1 - i;
  }
 else   if (!ordered) {
    for (int i=opts.length; i > 0; i--) {
      int j=rng.nextInt(i);
      int temp=opts[j].index;
      opts[j].index=opts[i - 1].index;
      opts[i - 1].index=temp;
    }
  }
}","public void randomize() throws SurveyException {
  assert(randomize);
  Component[] opts=getOptListByIndex();
  if (randomize)   if (ordered && rng.nextFloat() > 0.5) {
    for (int i=0; i < opts.length; i++)     opts[i].index=opts.length - 1 - i;
  }
 else   if (!ordered) {
    for (int i=opts.length; i > 0; i--) {
      int j=rng.nextInt(i);
      int temp=opts[j].index;
      opts[j].index=opts[i - 1].index;
      opts[i - 1].index=temp;
    }
  }
}",0.9764309764309764
109943,"public synchronized Map<String,Integer> randomize() throws SurveyException {
  if (blocks != null)   for (  Block b : blocks)   b.randomize();
 else {
    Collections.shuffle(questions,Question.rng);
    int i=0;
    for (    Question q : questions) {
      q.randomize();
      q.index=i;
      i++;
    }
  }
  Map<String,Integer> orderSeen=new HashMap<String,Integer>();
  for (  Question q : this.getQuestionsByIndex()) {
    orderSeen.put(q.quid,q.index);
    for (    Component c : q.getOptListByIndex())     orderSeen.put(c.getCid(),c.index);
  }
  return orderSeen;
}","public synchronized void randomize() throws SurveyException {
  if (!(blocks == null || blocks.isEmpty())) {
    System.out.println(""String_Node_Str"");
    for (    Block b : blocks)     b.randomize();
  }
 else {
    System.out.println(""String_Node_Str"");
    Collections.shuffle(questions,Question.rng);
    int i=0;
    for (    Question q : questions) {
      q.randomize();
      q.index=i;
      i++;
    }
  }
}",0.5760322255790534
109944,"@Override public int compareTo(Object o){
  return this.index - ((SurveyObj)o).index;
}","@Override public int compareTo(SurveyObj o){
  System.out.println(""String_Node_Str"");
  return this.index - o.index;
}",0.6926829268292682
109945,"public static String registerNewHitType(Record record){
  int waittime=1;
synchronized (service) {
    while (true) {
      try {
        String keywords=(String)record.parameters.getProperty(""String_Node_Str"");
        String description=""String_Node_Str"";
        QualificationType qualificationType=service.createQualificationType(record.survey.sid + gensym.next(),keywords,description,QualificationTypeStatus.Active,new Long(Integer.MAX_VALUE),null,null,null,true,0);
        assert(qualificationType != null);
        record.qualificationType=qualificationType;
        QualificationRequirement qr=answerOnce(record);
        String hitTypeId=service.registerHITType(maxAutoApproveDelay,Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str"")),Double.parseDouble((String)MturkLibrary.props.get(""String_Node_Str"")),(String)MturkLibrary.props.getProperty(""String_Node_Str""),(String)MturkLibrary.props.getProperty(""String_Node_Str""),(String)MturkLibrary.props.getProperty(""String_Node_Str""),new QualificationRequirement[]{qr});
        record.hitTypeId=hitTypeId;
        LOGGER.info(String.format(""String_Node_Str"",qualificationType.getQualificationTypeId()));
        return hitTypeId;
      }
 catch (      InternalServiceException ise) {
        LOGGER.warn(ise);
        if (overTime(""String_Node_Str"",waittime))         throw new RuntimeException(""String_Node_Str"");
        chill(waittime);
        waittime*=2;
      }
    }
  }
}","public static String registerNewHitType(Record record){
  int waittime=1;
synchronized (service) {
    while (true) {
      try {
        String keywords=(String)record.parameters.getProperty(""String_Node_Str"");
        String description=""String_Node_Str"";
        QualificationType qualificationType=service.createQualificationType(record.survey.sid + gensym.next() + MturkLibrary.TIME,keywords,description,QualificationTypeStatus.Active,new Long(Integer.MAX_VALUE),null,null,null,true,0);
        assert(qualificationType != null);
        record.qualificationType=qualificationType;
        QualificationRequirement qr=answerOnce(record);
        String hitTypeId=service.registerHITType(maxAutoApproveDelay,Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str"")),Double.parseDouble((String)MturkLibrary.props.get(""String_Node_Str"")),(String)MturkLibrary.props.getProperty(""String_Node_Str""),(String)MturkLibrary.props.getProperty(""String_Node_Str""),(String)MturkLibrary.props.getProperty(""String_Node_Str""),new QualificationRequirement[]{qr});
        record.hitTypeId=hitTypeId;
        LOGGER.info(String.format(""String_Node_Str"",qualificationType.getQualificationTypeId()));
        return hitTypeId;
      }
 catch (      InternalServiceException ise) {
        LOGGER.warn(ise);
        if (overTime(""String_Node_Str"",waittime))         throw new RuntimeException(""String_Node_Str"");
        chill(waittime);
        waittime*=2;
      }
    }
  }
}",0.9931459904043866
109946,"public static void run(final Survey survey,final BoxedBool interrupt) throws SurveyException, ServiceException, IOException, ParseException {
  final Properties params=(Properties)MturkLibrary.props.clone();
  do {
    if (!interrupt.getInterrupt() && SurveyPoster.postMore(survey)) {
      Map<String,Integer> orderSeen=survey.randomize();
      List<HIT> hits;
      hits=SurveyPoster.postSurvey(survey,orderSeen);
      System.out.println(""String_Node_Str"" + hits.size());
      ResponseManager.chill(2);
    }
    ResponseManager.chill(2);
  }
 while (stillLive(survey,interrupt) && !interrupt.getInterrupt());
  ResponseManager.chill(10);
  Record record=ResponseManager.getRecord(survey);
synchronized (record) {
    for (    HIT hit : ResponseManager.listAvailableHITsForRecord(ResponseManager.getRecord(survey)))     ResponseManager.expireHIT(hit);
    ResponseManager.removeQualification(record);
  }
  interrupt.setInterrupt(true);
}","public static void run(final Survey survey,final BoxedBool interrupt) throws SurveyException, ServiceException, IOException, ParseException {
  final Properties params=(Properties)MturkLibrary.props.clone();
  do {
    if (!interrupt.getInterrupt() && SurveyPoster.postMore(survey)) {
      survey.randomize();
      List<HIT> hits;
      hits=SurveyPoster.postSurvey(survey);
      System.out.println(""String_Node_Str"" + hits.size());
      ResponseManager.chill(2);
    }
    ResponseManager.chill(2);
  }
 while (stillLive(survey,interrupt) && !interrupt.getInterrupt());
  ResponseManager.chill(10);
  Record record=ResponseManager.getRecord(survey);
synchronized (record) {
    for (    HIT hit : ResponseManager.listAvailableHITsForRecord(ResponseManager.getRecord(survey)))     ResponseManager.expireHIT(hit);
    ResponseManager.removeQualification(record);
  }
  interrupt.setInterrupt(true);
}",0.9783315276273022
109947,"/** 
 * Posts a survey on Mechanical Turk using the current settings in MturkLibrary. Note that randomization is not performed here and so must be called before calling postSurvey. This also allows the user to not use randomization if she wishes.
 * @param survey
 * @return
 * @throws SurveyException
 * @throws ServiceException
 * @throws IOException
 */
public static List<HIT> postSurvey(Survey survey,Map<String,Integer> orderSeen) throws SurveyException, ServiceException, IOException, ParseException {
  Record record;
synchronized (ResponseManager.manager) {
    if (!ResponseManager.manager.containsKey(survey.sid)) {
      record=new Record(survey,(Properties)MturkLibrary.props.clone());
      ResponseManager.manager.put(survey.sid,record);
    }
 else {
      record=ResponseManager.manager.get(survey.sid);
    }
    if (record.hitTypeId == null || record.qualificationType == null)     ResponseManager.registerNewHitType(record);
  }
  List<HIT> hits=new ArrayList<HIT>();
  for (int i=numToBatch; i > 0; i--) {
    long lifetime=Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str""));
    assert(record.hitTypeId != null);
    assert(record.qualificationType != null);
    String hitid=ResponseManager.createHIT(MturkLibrary.props.getProperty(""String_Node_Str""),MturkLibrary.props.getProperty(""String_Node_Str""),MturkLibrary.props.getProperty(""String_Node_Str""),XML.getXMLString(survey),Double.parseDouble(MturkLibrary.props.getProperty(""String_Node_Str"")),Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str"")),ResponseManager.maxAutoApproveDelay,lifetime,ResponseManager.answerOnce(record),record.hitTypeId);
    HIT hit=ResponseManager.getHIT(hitid);
    System.out.println(SurveyPoster.makeHITURL(hit));
synchronized (ResponseManager.manager) {
      record.addNewHIT(hit);
      ResponseManager.manager.notifyAll();
    }
    hits.add(hit);
  }
  return hits;
}","/** 
 * Posts a survey on Mechanical Turk using the current settings in MturkLibrary. Note that randomization is not performed here and so must be called before calling postSurvey. This also allows the user to not use randomization if she wishes.
 * @param survey
 * @return
 * @throws SurveyException
 * @throws ServiceException
 * @throws IOException
 */
public static List<HIT> postSurvey(Survey survey) throws SurveyException, ServiceException, IOException, ParseException {
  Record record;
synchronized (ResponseManager.manager) {
    if (!ResponseManager.manager.containsKey(survey.sid)) {
      record=new Record(survey,(Properties)MturkLibrary.props.clone());
      ResponseManager.manager.put(survey.sid,record);
    }
 else {
      record=ResponseManager.manager.get(survey.sid);
    }
    if (record.hitTypeId == null || record.qualificationType == null)     ResponseManager.registerNewHitType(record);
  }
  List<HIT> hits=new ArrayList<HIT>();
  for (int i=numToBatch; i > 0; i--) {
    long lifetime=Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str""));
    assert(record.hitTypeId != null);
    assert(record.qualificationType != null);
    String hitid=ResponseManager.createHIT(MturkLibrary.props.getProperty(""String_Node_Str""),MturkLibrary.props.getProperty(""String_Node_Str""),MturkLibrary.props.getProperty(""String_Node_Str""),XML.getXMLString(survey),Double.parseDouble(MturkLibrary.props.getProperty(""String_Node_Str"")),Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str"")),ResponseManager.maxAutoApproveDelay,lifetime,ResponseManager.answerOnce(record),record.hitTypeId);
    HIT hit=ResponseManager.getHIT(hitid);
    System.out.println(SurveyPoster.makeHITURL(hit));
synchronized (ResponseManager.manager) {
      record.addNewHIT(hit);
      ResponseManager.manager.notifyAll();
    }
    hits.add(hit);
  }
  return hits;
}",0.9920592906299628
109948,"private void unifyBranching(Survey survey) throws SurveyException {
  ArrayList<CSVEntry> branches=lexemes.get(Survey.BRANCH);
  if (!(branches == null || branches.isEmpty())) {
    for (    CSVEntry entry : branches) {
      if (!(entry == null || entry.contents == null || entry.contents.equals(""String_Node_Str""))) {
        CSVEntry matchingOption=lexemes.get(Survey.OPTIONS).get(branches.indexOf(entry));
        Question question=null;
        for (        Question q : survey.questions) {
          if (q.sourceLineNos.contains(Integer.valueOf(entry.lineNo))) {
            question=q;
            break;
          }
        }
        if (question == null) {
          SurveyException e=new SyntaxException(String.format(""String_Node_Str"",entry.contents,entry.lineNo),this,this.getClass().getEnclosingMethod());
          LOGGER.warn(e);
          throw e;
        }
        if (question.block.branchQ != null) {
          if (!question.quid.equals(question.block.branchQ.quid)) {
            SurveyException e=new BranchException(String.format(""String_Node_Str"",entry.contents),this,this.getClass().getEnclosingMethod());
            LOGGER.warn(e);
            throw e;
          }
        }
 else         question.block.branchQ=question;
        Component c=question.getOptByData(matchingOption.contents);
        Block b=allBlockLookUp.get(entry.contents);
        if (b == null) {
          SurveyException e=new SyntaxException(String.format(""String_Node_Str"",entry.contents,entry.lineNo),this,this.getClass().getEnclosingMethod());
          LOGGER.warn(e);
          throw e;
        }
        question.branchMap.put(c,b);
      }
    }
  }
}","private void unifyBranching(Survey survey) throws SurveyException {
  ArrayList<CSVEntry> branches=lexemes.get(Survey.BRANCH);
  if (!(branches == null || branches.isEmpty())) {
    for (    CSVEntry entry : branches) {
      if (!(entry == null || entry.contents == null || entry.contents.equals(""String_Node_Str""))) {
        Question question=survey.getQuestionByLineNo(entry.lineNo);
        if (question.block.branchQ != null) {
          if (!question.quid.equals(question.block.branchQ.quid)) {
            SurveyException e=new BranchException(String.format(""String_Node_Str"",entry.contents),this,this.getClass().getEnclosingMethod());
            LOGGER.warn(e);
            throw e;
          }
        }
 else         question.block.branchQ=question;
        CSVEntry option=lexemes.get(Survey.OPTIONS).get(branches.indexOf(entry));
        Component c=question.getOptById(Component.makeComponentId(option.lineNo,option.colNo));
        Block b=allBlockLookUp.get(entry.contents);
        if (b == null) {
          SurveyException e=new SyntaxException(String.format(""String_Node_Str"",entry.contents,entry.lineNo),this,this.getClass().getEnclosingMethod());
          LOGGER.warn(e);
          throw e;
        }
        question.branchMap.put(c,b);
      }
    }
  }
}",0.4690265486725664
109949,"private ArrayList<Question> unifyQuestions() throws MalformedURLException, SurveyException {
  Question tempQ=null;
  ArrayList<Question> qlist=new ArrayList<Question>();
  ArrayList<CSVEntry> questions=lexemes.get(Survey.QUESTION);
  ArrayList<CSVEntry> options=lexemes.get(Survey.OPTIONS);
  ArrayList<CSVEntry> resources=(lexemes.containsKey(Survey.RESOURCE)) ? lexemes.get(Survey.RESOURCE) : null;
  ArrayList<CSVEntry> correlates=(lexemes.containsKey(Survey.CORRELATION)) ? lexemes.get(Survey.CORRELATION) : null;
  int index=0;
  for (int i=0; i < questions.size(); i++) {
    CSVEntry question=questions.get(i);
    CSVEntry option=options.get(i);
    LOGGER.log(Level.INFO,tempQ + ""String_Node_Str"" + question.contents+ ""String_Node_Str""+ option.contents);
    if (newQuestion(question,option,tempQ,i)) {
      tempQ=new Question(question.lineNo,question.colNo);
      tempQ.data.add(parseComponent(question));
      tempQ.options=new HashMap<String,Component>();
      tempQ.index=index;
      qlist.add(tempQ);
      index++;
    }
    if (resources != null && resources.get(i).contents != null) {
      CSVEntry resource=resources.get(i);
      String potentialURL=resource.contents.trim();
      if (!potentialURL.equals(""String_Node_Str""))       tempQ.data.add(new URLComponent(potentialURL,resource.lineNo,resource.colNo));
    }
    if (correlates != null && correlates.get(i).contents != null) {
      CSVEntry correlation=correlates.get(i);
      if (correlationMap.containsKey(correlation.contents)) {
        List<Question> qs=correlationMap.get(correlation.contents);
        qs.add(tempQ);
      }
 else       correlationMap.put(correlation.contents,Arrays.asList(new Question[]{tempQ}));
    }
    tempQ.sourceLineNos.add(option.lineNo);
    tempQ.exclusive=assignBool(tempQ.exclusive,Survey.EXCLUSIVE,i,this);
    tempQ.ordered=assignBool(tempQ.ordered,Survey.ORDERED,i,this);
    tempQ.randomize=assignBool(tempQ.randomize,Survey.RANDOMIZE,i,this);
    tempQ.freetext=assignBool(tempQ.freetext,Survey.FREETEXT,i,this);
    if (tempQ.freetext)     tempQ.options.put(Survey.FREETEXT,new StringComponent(""String_Node_Str"",option.lineNo,option.colNo));
    if (tempQ.otherValues.isEmpty())     for (    String col : headers) {
      boolean known=false;
      for (int j=0; j < Survey.knownHeaders.length; j++)       if (Survey.knownHeaders[j].equals(col)) {
        known=true;
        break;
      }
      if (!known) {
        String val=lexemes.get(col).get(i).contents;
        LOGGER.log(Level.DEBUG,""String_Node_Str"" + val);
        tempQ.otherValues.put(col,val);
      }
    }
    LOGGER.log(Level.DEBUG,""String_Node_Str"" + tempQ.otherValues.size());
  }
  return qlist;
}","private ArrayList<Question> unifyQuestions() throws MalformedURLException, SurveyException {
  Question tempQ=null;
  ArrayList<Question> qlist=new ArrayList<Question>();
  ArrayList<CSVEntry> questions=lexemes.get(Survey.QUESTION);
  ArrayList<CSVEntry> options=lexemes.get(Survey.OPTIONS);
  ArrayList<CSVEntry> resources=(lexemes.containsKey(Survey.RESOURCE)) ? lexemes.get(Survey.RESOURCE) : null;
  ArrayList<CSVEntry> correlates=(lexemes.containsKey(Survey.CORRELATION)) ? lexemes.get(Survey.CORRELATION) : null;
  int index=0;
  for (int i=0; i < questions.size(); i++) {
    CSVEntry question=questions.get(i);
    CSVEntry option=options.get(i);
    LOGGER.log(Level.INFO,tempQ + ""String_Node_Str"" + question.contents+ ""String_Node_Str""+ option.contents);
    if (newQuestion(question,option,tempQ,i)) {
      tempQ=new Question(question.lineNo,question.colNo);
      tempQ.data.add(parseComponent(question));
      tempQ.options=new HashMap<String,Component>();
      tempQ.index=index;
      qlist.add(tempQ);
      index++;
    }
    if (resources != null && resources.get(i).contents != null) {
      CSVEntry resource=resources.get(i);
      String potentialURL=resource.contents.trim();
      if (!potentialURL.equals(""String_Node_Str""))       tempQ.data.add(new URLComponent(potentialURL,resource.lineNo,resource.colNo));
    }
    if (correlates != null && correlates.get(i).contents != null) {
      CSVEntry correlation=correlates.get(i);
      if (correlationMap.containsKey(correlation.contents)) {
        List<Question> qs=correlationMap.get(correlation.contents);
        qs.add(tempQ);
      }
 else       correlationMap.put(correlation.contents,Arrays.asList(new Question[]{tempQ}));
    }
    tempQ.options.put(Component.makeComponentId(option.lineNo,option.colNo),parseComponent(option));
    tempQ.sourceLineNos.add(option.lineNo);
    tempQ.exclusive=assignBool(tempQ.exclusive,Survey.EXCLUSIVE,i,this);
    tempQ.ordered=assignBool(tempQ.ordered,Survey.ORDERED,i,this);
    tempQ.randomize=assignBool(tempQ.randomize,Survey.RANDOMIZE,i,this);
    tempQ.freetext=assignBool(tempQ.freetext,Survey.FREETEXT,i,this);
    if (tempQ.freetext)     tempQ.options.put(Survey.FREETEXT,new StringComponent(""String_Node_Str"",option.lineNo,option.colNo));
    if (tempQ.otherValues.isEmpty())     for (    String col : headers) {
      boolean known=false;
      for (int j=0; j < Survey.knownHeaders.length; j++)       if (Survey.knownHeaders[j].equals(col)) {
        known=true;
        break;
      }
      if (!known) {
        String val=lexemes.get(col).get(i).contents;
        LOGGER.log(Level.DEBUG,""String_Node_Str"" + val);
        tempQ.otherValues.put(col,val);
      }
    }
    LOGGER.log(Level.DEBUG,""String_Node_Str"" + tempQ.otherValues.size());
  }
  return qlist;
}",0.9816463747047064
109950,"public Component(int row,int col){
  this.cid=String.format(""String_Node_Str"",row,col);
}","public Component(int row,int col){
  this.cid=makeComponentId(row,col);
}",0.7530864197530864
109951,"public Question(int row,int col){
  this.quid=String.format(""String_Node_Str"",row,col);
}","public Question(int row,int col){
  this.quid=makeQuestionId(row,col);
}",0.7577639751552795
109952,"public Component getOptById(String oid) throws SurveyException {
  for (  Component c : options.values()) {
    if (c.getCid().equals(oid))     return c;
  }
  throw new OptionNotFoundException(oid,this.quid);
}","public Component getOptById(String oid) throws SurveyException {
  if (options.containsKey(oid))   return options.get(oid);
  throw new OptionNotFoundException(oid,this.quid);
}",0.7783505154639175
109953,"public QuestionNotFoundException(String quid,String sid){
  super(String.format(""String_Node_Str"",quid,sid));
}","public QuestionNotFoundException(int i){
  super(String.format(""String_Node_Str"",i));
}",0.8686868686868687
109954,"public static void main(String[] args) throws IOException, SurveyException, InterruptedException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, ParseException {
  if (args.length != 3) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    System.exit(-1);
  }
  LOGGER.setLevel(Level.ALL);
  try {
    txtHandler=new FileAppender(new PatternLayout(""String_Node_Str""),""String_Node_Str"");
    txtHandler.setAppend(true);
    LOGGER.addAppender(txtHandler);
  }
 catch (  IOException io) {
    System.err.println(io.getMessage());
    System.exit(-1);
  }
  System.out.println(""String_Node_Str"");
  if (Boolean.parseBoolean(args[2])) {
    ResponseManager.approveAllHITs();
    ResponseManager.expireOldHITs();
    ResponseManager.deleteExpiredHITs();
  }
  String file=args[0];
  String sep=args[1];
  while (true) {
    try {
      BoxedBool interrupt=new BoxedBool(false);
      CSVParser csvParser=new CSVParser(new CSVLexer(file,sep));
      Survey survey=csvParser.parse();
      Rules.ensureBranchForward(survey,csvParser);
      Rules.ensureCompactness(csvParser);
      Rules.ensureNoDupes(survey);
      Thread writer=makeWriter(survey,interrupt);
      Thread responder=makeResponseGetter(survey,interrupt);
      writer.start();
      responder.start();
      Runner.run(survey,interrupt);
      writer.join();
      responder.join();
      System.exit(0);
    }
 catch (    InsufficientFundsException ife) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      int i=0;
      while (i != 1 && i != 2) {
        System.out.println(""String_Node_Str"");
        i=new Scanner(System.in).nextInt();
        if (i == 2)         System.exit(1);
      }
    }
  }
}","public static void main(String[] args) throws IOException, SurveyException, InterruptedException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, ParseException {
  if (args.length != 3) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    System.exit(-1);
  }
  try {
    txtHandler=new FileAppender(new PatternLayout(""String_Node_Str""),""String_Node_Str"");
    txtHandler.setAppend(true);
    LOGGER.addAppender(txtHandler);
  }
 catch (  IOException io) {
    System.err.println(io.getMessage());
    System.exit(-1);
  }
  System.out.println(""String_Node_Str"");
  if (Boolean.parseBoolean(args[2])) {
    ResponseManager.approveAllHITs();
    ResponseManager.expireOldHITs();
    ResponseManager.deleteExpiredHITs();
  }
  String file=args[0];
  String sep=args[1];
  while (true) {
    try {
      BoxedBool interrupt=new BoxedBool(false);
      CSVParser csvParser=new CSVParser(new CSVLexer(file,sep));
      Survey survey=csvParser.parse();
      Rules.ensureBranchForward(survey,csvParser);
      Rules.ensureCompactness(csvParser);
      Rules.ensureNoDupes(survey);
      Thread writer=makeWriter(survey,interrupt);
      Thread responder=makeResponseGetter(survey,interrupt);
      writer.start();
      responder.start();
      Runner.run(survey,interrupt);
      writer.join();
      responder.join();
      System.exit(0);
    }
 catch (    InsufficientFundsException ife) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      int i=0;
      while (i != 1 && i != 2) {
        System.out.println(""String_Node_Str"");
        i=new Scanner(System.in).nextInt();
        if (i == 2)         System.exit(1);
      }
    }
  }
}",0.917607223476298
109955,"public CSVLexer(String sep,String filename) throws IOException, SurveyException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  this(sep,filename,""String_Node_Str"");
}","public CSVLexer(String filename,String sep) throws IOException, SurveyException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  this(filename,sep,""String_Node_Str"");
}",0.934010152284264
109956,"public Thread makeRunner(final Survey survey,final Runner.BoxedBool interrupt){
  return new Thread(){
    public void run(){
      Tuple2<Thread,Runner.BoxedBool> threadData=new Tuple2(this,interrupt);
      ExperimentAction.addThisThread(survey,threadData);
      while (!interrupt.getInterrupt()) {
        try {
          Runner.run(survey,interrupt);
          System.out.println(""String_Node_Str"");
        }
 catch (        AccessKeyException ake) {
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",ake.getMessage()));
          (new File(MturkLibrary.CONFIG)).delete();
          SurveyMan.LOGGER.fatal(ake);
          System.exit(-1);
        }
catch (        SurveyException se) {
          SurveyMan.LOGGER.warn(se);
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",se.getMessage()));
          interrupt.setInterrupt(true);
        }
catch (        InsufficientFundsException ife) {
          SurveyMan.LOGGER.warn(ife);
          int opt=JOptionPane.showConfirmDialog(Display.frame,""String_Node_Str"");
          if (opt == JOptionPane.NO_OPTION) {
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sourceName));
            interrupt.setInterrupt(true);
          }
 else           if (opt == JOptionPane.CANCEL_OPTION) {
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sourceName));
            Runner.saveJob(survey);
            interrupt.setInterrupt(true);
          }
        }
catch (        ServiceException mturkse) {
          SurveyMan.LOGGER.warn(mturkse);
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",mturkse.getMessage()));
        }
catch (        IOException io) {
          SurveyMan.LOGGER.warn(io);
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",io.getMessage()));
          interrupt.setInterrupt(true);
        }
      }
      ExperimentAction.removeThisThread(survey,threadData);
    }
  }
;
}","public Thread makeRunner(final Survey survey,final Runner.BoxedBool interrupt){
  return new Thread(){
    public void run(){
      Tuple2<Thread,Runner.BoxedBool> threadData=new Tuple2(this,interrupt);
      ExperimentAction.addThisThread(survey,threadData);
      while (!interrupt.getInterrupt()) {
        try {
          Runner.run(survey,interrupt);
          System.out.println(""String_Node_Str"");
        }
 catch (        AccessKeyException ake) {
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",ake.getMessage()));
          (new File(MturkLibrary.CONFIG)).delete();
          SurveyMan.LOGGER.fatal(ake);
          System.exit(-1);
        }
catch (        SurveyException se) {
          SurveyMan.LOGGER.warn(se);
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",se.getMessage()));
          interrupt.setInterrupt(true);
        }
catch (        InsufficientFundsException ife) {
          SurveyMan.LOGGER.warn(ife);
          int opt=JOptionPane.showConfirmDialog(Display.frame,""String_Node_Str"");
          if (opt == JOptionPane.NO_OPTION) {
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sourceName));
            interrupt.setInterrupt(true);
          }
 else           if (opt == JOptionPane.CANCEL_OPTION) {
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sourceName));
            try {
              Runner.saveJob(survey,MturkLibrary.JobStatus.INTERRUPTED);
              interrupt.setInterrupt(true);
            }
 catch (            SurveyException se) {
              SurveyMan.LOGGER.info(se);
            }
catch (            IOException io) {
              SurveyMan.LOGGER.warn(io);
            }
          }
        }
catch (        ServiceException mturkse) {
          SurveyMan.LOGGER.warn(mturkse);
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",mturkse.getMessage()));
        }
catch (        IOException io) {
          SurveyMan.LOGGER.warn(io);
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",io.getMessage()));
          interrupt.setInterrupt(true);
        }
      }
      ExperimentAction.removeThisThread(survey,threadData);
    }
  }
;
}",0.8576158940397351
109957,"protected static void addResponses(Survey survey,String hitid) throws SurveyException, IOException {
  boolean success=false;
  Record r=manager.get(survey);
  List<SurveyResponse> responses=r.responses;
  List<SurveyResponse> botResponses=r.botResponses;
  QC qc=r.qc;
  List<SurveyResponse> validResponsesToAdd=new ArrayList<SurveyResponse>();
  List<SurveyResponse> randomResponsesToAdd=new ArrayList<SurveyResponse>();
  while (!success) {
    try {
      Assignment[] assignments=getAllAssignmentsForHIT(hitid);
      for (      Assignment a : assignments) {
        if (a.getAssignmentStatus().equals(AssignmentStatus.Submitted)) {
          SurveyResponse sr=parseResponse(a,survey);
          if (QCAction.addAsValidResponse(qc.assess(sr),a,sr))           validResponsesToAdd.add(sr);
 else           randomResponsesToAdd.add(sr);
        }
      }
      responses.addAll(validResponsesToAdd);
      botResponses.addAll(randomResponsesToAdd);
      success=true;
    }
 catch (    ServiceException se) {
      LOGGER.warn(""String_Node_Str"" + se);
    }
  }
}","protected static void addResponses(Survey survey,String hitid) throws SurveyException, IOException {
  boolean success=false;
  Record r=manager.get(survey);
  List<SurveyResponse> responses=r.responses;
  List<SurveyResponse> botResponses=r.botResponses;
  QC qc=r.qc;
  List<SurveyResponse> validResponsesToAdd=new ArrayList<SurveyResponse>();
  List<SurveyResponse> randomResponsesToAdd=new ArrayList<SurveyResponse>();
  while (!success) {
    try {
      Assignment[] assignments=getAllAssignmentsForHIT(hitid);
      for (      Assignment a : assignments) {
        if (a.getAssignmentStatus().equals(AssignmentStatus.Submitted)) {
          SurveyResponse sr=parseResponse(a,survey);
          if (QCAction.addAsValidResponse(qc.assess(sr),a,r))           validResponsesToAdd.add(sr);
 else           randomResponsesToAdd.add(sr);
        }
      }
      responses.addAll(validResponsesToAdd);
      botResponses.addAll(randomResponsesToAdd);
      success=true;
    }
 catch (    ServiceException se) {
      LOGGER.warn(""String_Node_Str"" + se);
    }
  }
}",0.999530736743313
109958,"public static String createHIT(String title,String description,String keywords,String xml,double reward,long assignmentDuration,long maxAutoApproveDelay,long lifetime,QualificationType qualificationType){
  int waittime=1;
synchronized (service) {
    while (true) {
      try {
        QualificationRequirement qr=new QualificationRequirement(qualificationType.getQualificationTypeId(),null,null,null,true);
        HIT hitid=service.createHIT(null,title,description,keywords,xml,reward,assignmentDuration,maxAutoApproveDelay,lifetime,1,""String_Node_Str"",new QualificationRequirement[]{qr},null);
        return hitid.getHITId();
      }
 catch (      InternalServiceException ise) {
        LOGGER.info(ise);
        chill(waittime);
        waittime=waittime * 2;
      }
    }
  }
}","public static String createHIT(String title,String description,String keywords,String xml,double reward,long assignmentDuration,long maxAutoApproveDelay,long lifetime,QualificationType qualificationType) throws ParseException {
  int waittime=1;
synchronized (service) {
    while (true) {
      try {
        QualificationRequirement qr=new QualificationRequirement(qualificationType.getQualificationTypeId(),Comparator.fromString(""String_Node_Str""),null,null,true);
        HIT hitid=service.createHIT(null,title,description,keywords,xml,reward,assignmentDuration,maxAutoApproveDelay,lifetime,1,""String_Node_Str"",new QualificationRequirement[]{qr},null);
        return hitid.getHITId();
      }
 catch (      InternalServiceException ise) {
        LOGGER.info(ise);
        chill(waittime);
        waittime=waittime * 2;
      }
    }
  }
}",0.9589209074187616
109959,"private static void extendHIT(String hitd,Integer maxAssignmentsIncrement,Long expirationIncrementInSeconds){
  while (true) {
    try {
      service.extendHIT(hitd,maxAssignmentsIncrement,expirationIncrementInSeconds);
      return;
    }
 catch (    InternalServiceException ise) {
      chill(2);
    }
  }
}","private static void extendHIT(String hitd,Integer maxAssignmentsIncrement,Long expirationIncrementInSeconds){
  int waitTime=1;
  while (true) {
    try {
      service.extendHIT(hitd,maxAssignmentsIncrement,expirationIncrementInSeconds);
      return;
    }
 catch (    InternalServiceException ise) {
      chill(waitTime);
      waitTime=2 * waitTime;
    }
  }
}",0.9174041297935104
109960,"/** 
 * Writes survey back to its file (in case any changes have been made to its contents) and saves the parameters file. Also stores the file information for later loading.
 * @param survey
 */
private static void saveJob(Survey survey,Library.JobStatus status) throws SurveyException, IOException {
  String surveyString=survey.toFileString();
  String fileName=Library.STATEDATADIR + Library.fileSep + survey.sourceName+ ""String_Node_Str"";
  String paramsFileName=Library.STATEDATADIR + Library.fileSep + survey.sourceName+ ""String_Node_Str"";
  BufferedWriter csvWriter=new BufferedWriter(new FileWriter(fileName));
  csvWriter.write(surveyString);
  csvWriter.close();
  Record r=ResponseManager.manager.get(survey);
synchronized (r) {
    r.parameters.store(new BufferedWriter(new FileWriter(paramsFileName)),""String_Node_Str"");
    Library.writeJobInfo(fileName,paramsFileName,status);
  }
}","/** 
 * Writes survey back to its file (in case any changes have been made to its contents) and saves the parameters file. Also stores the file information for later loading.
 * @param survey
 */
public static void saveJob(Survey survey,Library.JobStatus status) throws SurveyException, IOException {
  String surveyString=survey.toFileString();
  String fileName=Library.STATEDATADIR + Library.fileSep + survey.sourceName+ ""String_Node_Str"";
  String paramsFileName=Library.STATEDATADIR + Library.fileSep + survey.sourceName+ ""String_Node_Str"";
  BufferedWriter csvWriter=new BufferedWriter(new FileWriter(fileName));
  csvWriter.write(surveyString);
  csvWriter.close();
  Record r=ResponseManager.manager.get(survey);
synchronized (r) {
    r.parameters.store(new BufferedWriter(new FileWriter(paramsFileName)),""String_Node_Str"");
    Library.writeJobInfo(fileName,paramsFileName,status);
  }
}",0.9938718662952646
109961,"/** 
 * Posts a survey on Mechanical Turk using the current settings in MturkLibrary. Note that randomization is not performed here and so must be called before calling postSurvey. This also allows the user to not use randomization if she wishes.
 * @param survey
 * @return
 * @throws SurveyException
 * @throws ServiceException
 * @throws IOException
 */
public static List<HIT> postSurvey(Survey survey,Map<String,Integer> orderSeen) throws SurveyException, ServiceException, IOException {
  List<HIT> hits=new ArrayList<HIT>();
  QualificationType qualificationType;
  if (ResponseManager.manager.containsKey(survey))   qualificationType=ResponseManager.manager.get(survey).qualificationType;
 else {
    qualificationType=service.createQualificationType(survey.sourceName + survey.sid + MturkLibrary.TIME,MturkLibrary.props.getProperty(""String_Node_Str""),""String_Node_Str"");
    qualificationType.setAutoGranted(true);
    qualificationType.setIsRequestable(false);
  }
  for (int i=numToBatch; i > 0; i--) {
    long lifetime=Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str""));
    String hitid=ResponseManager.createHIT(MturkLibrary.props.getProperty(""String_Node_Str""),MturkLibrary.props.getProperty(""String_Node_Str""),MturkLibrary.props.getProperty(""String_Node_Str""),XML.getXMLString(survey),Double.parseDouble(MturkLibrary.props.getProperty(""String_Node_Str"")),Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str"")),maxAutoApproveDelay,lifetime,qualificationType);
    HIT hit=ResponseManager.getHIT(hitid);
    System.out.println(SurveyPoster.makeHITURL(hit));
synchronized (ResponseManager.manager) {
      if (!ResponseManager.manager.containsKey(survey))       ResponseManager.manager.put(survey,new Record(survey,(Properties)MturkLibrary.props.clone()));
      Record record=ResponseManager.manager.get(survey);
      record.addNewHIT(hit);
      ResponseManager.manager.notifyAll();
    }
    hits.add(hit);
  }
  return hits;
}","/** 
 * Posts a survey on Mechanical Turk using the current settings in MturkLibrary. Note that randomization is not performed here and so must be called before calling postSurvey. This also allows the user to not use randomization if she wishes.
 * @param survey
 * @return
 * @throws SurveyException
 * @throws ServiceException
 * @throws IOException
 */
public static List<HIT> postSurvey(Survey survey,Map<String,Integer> orderSeen) throws SurveyException, ServiceException, IOException, ParseException {
  List<HIT> hits=new ArrayList<HIT>();
  QualificationType qualificationType;
  if (ResponseManager.manager.containsKey(survey))   qualificationType=ResponseManager.manager.get(survey).qualificationType;
 else {
    qualificationType=service.createQualificationType(survey.sourceName + survey.sid + MturkLibrary.TIME,MturkLibrary.props.getProperty(""String_Node_Str""),""String_Node_Str"");
    qualificationType.setAutoGranted(true);
    qualificationType.setIsRequestable(false);
  }
  for (int i=numToBatch; i > 0; i--) {
    long lifetime=Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str""));
    String hitid=ResponseManager.createHIT(MturkLibrary.props.getProperty(""String_Node_Str""),MturkLibrary.props.getProperty(""String_Node_Str""),MturkLibrary.props.getProperty(""String_Node_Str""),XML.getXMLString(survey),Double.parseDouble(MturkLibrary.props.getProperty(""String_Node_Str"")),Long.parseLong(MturkLibrary.props.getProperty(""String_Node_Str"")),maxAutoApproveDelay,lifetime,qualificationType);
    HIT hit=ResponseManager.getHIT(hitid);
    System.out.println(SurveyPoster.makeHITURL(hit));
synchronized (ResponseManager.manager) {
      if (!ResponseManager.manager.containsKey(survey))       ResponseManager.manager.put(survey,new Record(survey,(Properties)MturkLibrary.props.clone()));
      Record record=ResponseManager.manager.get(survey);
      record.addNewHIT(hit);
      ResponseManager.manager.notifyAll();
    }
    hits.add(hit);
  }
  return hits;
}",0.9959575543203638
109962,"@Test public void testRenew() throws IOException, SurveyException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
}","@Test public void testRenew() throws IOException, SurveyException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, ParseException {
  Tuple2<Survey,List<HIT>> stuff=sendSurvey();
  Survey survey=stuff._1();
  List<HIT> hits=stuff._2();
  for (  HIT hit : hits)   ResponseManager.expireHIT(hit);
  for (  HIT hit : hits)   if (ResponseManager.renewIfExpired(hit.getHITId(),ResponseManager.getRecord(survey).parameters))   continue;
 else   throw new RuntimeException(""String_Node_Str"");
  for (  HIT hit : hits)   ResponseManager.expireHIT(hit);
}",0.4
109963,"private Tuple2<Survey,List> sendSurvey() throws IOException, SurveyException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  SurveyPoster.init();
  MturkLibrary.props.setProperty(""String_Node_Str"",""String_Node_Str"");
  MturkLibrary.props.setProperty(""String_Node_Str"",""String_Node_Str"");
  SurveyPoster.updateProperties();
  CSVParser parser=new CSVParser(new CSVLexer((String)tests[1]._2(),(String)tests[1]._1()));
  Survey survey=parser.parse();
  List<HIT> hits=SurveyPoster.postSurvey(survey,new HashMap<String,Integer>());
  return new Tuple2<Survey,List>(survey,hits);
}","private Tuple2<Survey,List<HIT>> sendSurvey() throws IOException, SurveyException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, ParseException {
  SurveyPoster.init();
  MturkLibrary.props.setProperty(""String_Node_Str"",""String_Node_Str"");
  MturkLibrary.props.setProperty(""String_Node_Str"",""String_Node_Str"");
  SurveyPoster.updateProperties();
  CSVParser parser=new CSVParser(new CSVLexer((String)tests[1]._2(),(String)tests[1]._1()));
  Survey survey=parser.parse();
  List<HIT> hits=SurveyPoster.postSurvey(survey,new HashMap<String,Integer>());
  return new Tuple2<Survey,List<HIT>>(survey,hits);
}",0.1712439418416801
109964,"@Test public void testRecordCopy() throws IOException, SurveyException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
}","@Test public void testRecordCopy() throws IOException, SurveyException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, ParseException {
}",0.9487179487179488
109965,"private void openPreviewHTML(){
  if (Experiment.csvLabel != null) {
    String csv=(String)Experiment.csvLabel.getSelectedItem();
    String htmlFileName=""String_Node_Str"";
    try {
      Survey survey;
      if (cachedSurveys.containsKey(csv)) {
        Experiment.loadParameters();
        SurveyPoster.updateProperties();
        survey=cachedSurveys.get(csv);
      }
 else {
        survey=Experiment.makeSurvey();
        cachedSurveys.put(csv,survey);
      }
      HTML.spitHTMLToFile(HTML.getHTMLString(survey),survey);
      htmlFileName=ResponseManager.getRecord(survey).htmlFileName;
      Desktop.getDesktop().browse(new URI(""String_Node_Str"" + htmlFileName));
    }
 catch (    IOException io) {
      Experiment.updateStatusLabel(String.format(""String_Node_Str"",htmlFileName));
      SurveyMan.LOGGER.fatal(io);
    }
catch (    SurveyException se) {
      Experiment.updateStatusLabel(se.getMessage());
      cachedSurveys.remove(csv);
      SurveyMan.LOGGER.warn(se);
    }
catch (    URISyntaxException uri) {
      SurveyMan.LOGGER.fatal(uri);
    }
  }
}","private void openPreviewHTML(){
  if (Experiment.csvLabel != null) {
    String csv=(String)Experiment.csvLabel.getSelectedItem();
    String htmlFileName=""String_Node_Str"";
    try {
      Survey survey;
      if (cachedSurveys.containsKey(csv)) {
        Experiment.loadParameters();
        SurveyPoster.updateProperties();
        survey=cachedSurveys.get(csv);
      }
 else {
        survey=Experiment.makeSurvey();
        cachedSurveys.put(csv,survey);
      }
      HTML.spitHTMLToFile(HTML.getHTMLString(survey),survey);
      htmlFileName=ResponseManager.getRecord(survey).htmlFileName;
      Desktop.getDesktop().browse(new URI(new File(htmlFileName).getCanonicalPath()));
    }
 catch (    IOException io) {
      Experiment.updateStatusLabel(String.format(""String_Node_Str"",htmlFileName));
      SurveyMan.LOGGER.fatal(io);
    }
catch (    SurveyException se) {
      Experiment.updateStatusLabel(se.getMessage());
      cachedSurveys.remove(csv);
      SurveyMan.LOGGER.warn(se);
    }
catch (    URISyntaxException uri) {
      SurveyMan.LOGGER.fatal(uri);
    }
  }
}",0.967144840351689
109966,"protected static void addResponses(Survey survey,String hitid) throws SurveyException, IOException {
  List<SurveyResponse> responses=getRecord(survey).responses;
  boolean success=false;
  ArrayList<SurveyResponse> responsesToAdd=new ArrayList<SurveyResponse>();
  while (!success) {
    try {
      Assignment[] assignments=service.getAllAssignmentsForHIT(hitid);
      System.out.println(assignments.length);
      for (      Assignment a : assignments) {
        SurveyResponse sr=parseResponse(a,survey);
        if (QCAction.addAsValidResponse(QC.assess(sr),a))         responsesToAdd.add(sr);
        System.out.println(""String_Node_Str"" + responses.size());
        responses.addAll(responsesToAdd);
        System.out.println(""String_Node_Str"" + responses.size());
      }
      success=true;
    }
 catch (    ServiceException se) {
      LOGGER.warn(""String_Node_Str"" + se);
    }
  }
}","protected static void addResponses(Survey survey,String hitid) throws SurveyException, IOException {
  List<SurveyResponse> responses=manager.get(survey).responses;
  boolean success=false;
  ArrayList<SurveyResponse> responsesToAdd=new ArrayList<SurveyResponse>();
  while (!success) {
    try {
      Assignment[] assignments=getAssignments(hitid);
      System.out.println(""String_Node_Str"" + assignments.length);
      for (      Assignment a : assignments) {
        SurveyResponse sr=parseResponse(a,survey);
        if (QCAction.addAsValidResponse(QC.assess(sr),a))         responsesToAdd.add(sr);
        System.out.println(""String_Node_Str"" + responses.size());
        responses.addAll(responsesToAdd);
        System.out.println(""String_Node_Str"" + responses.size());
      }
      success=true;
    }
 catch (    ServiceException se) {
      LOGGER.warn(""String_Node_Str"" + se);
    }
  }
}",0.9160644802668148
109967,"public static Thread makeWriter(Survey survey){
  return new Thread(){
    @Override public void run(){
      while (!interrupt) {
        for (        Entry<Survey,Record> entry : ResponseManager.manager.entrySet()) {
          System.out.println(""String_Node_Str"");
          writeResponses(entry.getKey(),entry.getValue());
        }
        try {
          Thread.sleep(writeInterval);
        }
 catch (        InterruptedException ex) {
          LOGGER.info(ex);
        }
      }
    }
  }
;
}","public static Thread makeWriter(Survey survey){
  return new Thread(){
    @Override public void run(){
      while (!interrupt) {
        for (        Entry<Survey,Record> entry : ResponseManager.manager.entrySet()) {
          System.out.println(""String_Node_Str"" + entry.getValue().outputFileName);
          writeResponses(entry.getKey(),entry.getValue());
        }
        try {
          Thread.sleep(writeInterval);
        }
 catch (        InterruptedException ex) {
          LOGGER.info(ex);
        }
      }
    }
  }
;
}",0.9671814671814672
109968,"public static void writeResponses(Survey survey,Record record){
synchronized (record) {
    for (    SurveyResponse r : record.responses) {
      if (!r.recorded) {
        BufferedWriter bw=null;
        try {
          String sep=""String_Node_Str"";
          File f=new File(record.outputFileName);
          bw=new BufferedWriter(new FileWriter(f,true));
          if (!f.exists() || f.length() == 0)           bw.write(SurveyResponse.outputHeaders(survey,sep));
          for (          SurveyResponse sr : record.responses) {
            LOGGER.info(""String_Node_Str"" + sr.recorded);
            if (!sr.recorded) {
              bw.write(sr.toString(survey,sep));
              sr.recorded=true;
            }
          }
          bw.close();
        }
 catch (        IOException ex) {
          LOGGER.warn(ex);
        }
 finally {
          try {
            bw.close();
          }
 catch (          IOException ex) {
            LOGGER.warn(ex);
          }
        }
      }
    }
  }
}","public static void writeResponses(Survey survey,Record record){
synchronized (record) {
    for (    SurveyResponse r : record.responses) {
      if (!r.recorded) {
        BufferedWriter bw=null;
        System.out.println(""String_Node_Str"" + r.srid);
        try {
          String sep=""String_Node_Str"";
          File f=new File(record.outputFileName);
          bw=new BufferedWriter(new FileWriter(f,true));
          if (!f.exists() || f.length() == 0)           bw.write(SurveyResponse.outputHeaders(survey,sep));
          for (          SurveyResponse sr : record.responses) {
            LOGGER.info(""String_Node_Str"" + sr.recorded);
            if (!sr.recorded) {
              bw.write(sr.toString(survey,sep));
              sr.recorded=true;
            }
          }
          bw.close();
        }
 catch (        IOException ex) {
          LOGGER.warn(ex);
        }
 finally {
          try {
            bw.close();
          }
 catch (          IOException ex) {
            LOGGER.warn(ex);
          }
        }
      }
    }
  }
}",0.9727626459143968
109969,"public static void main(String[] args) throws IOException, SurveyException {
  SurveyPoster.init();
  if (args.length != 3) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    System.exit(-1);
  }
  if (Boolean.parseBoolean(args[2]))   ResponseManager.expireOldHITs();
  String file=args[0];
  String sep=args[1];
  while (true) {
    try {
      Survey survey=CSVParser.parse(file,sep);
      Thread writer=makeWriter(survey);
      Thread responder=makeResponseGetter(survey);
      writer.start();
      responder.start();
      Runner.run(survey);
      System.exit(1);
    }
 catch (    InsufficientFundsException ife) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      int i=0;
      while (i != 1 && i != 2) {
        System.out.println(""String_Node_Str"");
        i=new Scanner(System.in).nextInt();
        if (i == 2)         System.exit(1);
      }
    }
  }
}","public static void main(String[] args) throws IOException, SurveyException {
  SurveyPoster.init();
  if (args.length != 3) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    System.exit(-1);
  }
  if (Boolean.parseBoolean(args[2]))   ResponseManager.expireOldHITs();
  String file=args[0];
  String sep=args[1];
  while (true) {
    try {
      Survey survey=CSVParser.parse(file,sep);
      Thread writer=makeWriter(survey);
      Thread responder=makeResponseGetter(survey);
      writer.start();
      responder.start();
      Runner.run(survey);
      interrupt=true;
      System.exit(1);
    }
 catch (    InsufficientFundsException ife) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      int i=0;
      while (i != 1 && i != 2) {
        System.out.println(""String_Node_Str"");
        i=new Scanner(System.in).nextInt();
        if (i == 2)         System.exit(1);
      }
    }
  }
}",0.9887755102040816
109970,"public static Thread makeResponseGetter(final Survey survey){
  return new Thread(){
    @Override public void run(){
      boolean done=false;
      while (!done) {
        try {
          while (stillLive(survey)) {
            Record record=ResponseManager.getRecord(survey);
            for (            HIT hit : record.getAllHITs()) {
              String hitid=hit.getHITId();
              if (ResponseManager.hasResponse(hitid)) {
                ResponseManager.addResponses(survey,hitid);
                System.out.println(""String_Node_Str"" + hitid);
              }
              try {
                Thread.sleep(1000);
              }
 catch (              InterruptedException e) {
                LOGGER.info(e);
              }
            }
          }
          done=true;
        }
 catch (        Exception e) {
          LOGGER.warn(e);
        }
      }
    }
  }
;
}","public static Thread makeResponseGetter(final Survey survey){
  return new Thread(){
    @Override public void run(){
      while (true) {
        System.out.println(""String_Node_Str"");
        try {
          while (stillLive(survey) && !interrupt) {
            Record record=ResponseManager.getRecord(survey);
            for (            HIT hit : record.getAllHITs()) {
              String hitid=hit.getHITId();
              if (ResponseManager.hasResponse(hitid)) {
                ResponseManager.addResponses(survey,hitid);
                System.out.println(String.format(""String_Node_Str"",SurveyPoster.makeHITURL(hit),record.responses.size()));
              }
              try {
                Thread.sleep(1000);
              }
 catch (              InterruptedException e) {
                LOGGER.info(e);
              }
            }
          }
        }
 catch (        Exception e) {
          LOGGER.warn(e);
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException e1) {
          }
        }
      }
    }
  }
;
}",0.7781155015197568
109971,"private void selectCSVFile(){
  JButton selectCSV=(JButton)componentMap.get(""String_Node_Str"");
  JComboBox csvLabel=(JComboBox)componentMap.get(""String_Node_Str"");
  if (fc.showOpenDialog(selectCSV) == JFileChooser.APPROVE_OPTION) {
    for (int i=0; i < csvLabel.getItemCount(); i++)     if (((String)csvLabel.getItemAt(i)).equals(filename.string)) {
      csvLabel.setSelectedItem(filename.string);
      return;
    }
    csvLabel.addItem(filename.string);
    csvLabel.setSelectedItem(filename.string);
  }
}","private void selectCSVFile(){
  if (fc.showOpenDialog(Experiment.selectCSV) == JFileChooser.APPROVE_OPTION) {
    for (int i=0; i < Experiment.csvLabel.getItemCount(); i++)     if (((String)Experiment.csvLabel.getItemAt(i)).equals(filename.string)) {
      Experiment.csvLabel.setSelectedItem(filename.string);
      return;
    }
    Experiment.csvLabel.addItem(filename.string);
    Experiment.csvLabel.setSelectedItem(filename.string);
  }
}",0.7899686520376176
109972,"private void loadSplashPage(){
  JButton splashLoaderButton=(JButton)componentMap.get(""String_Node_Str"");
  JComboBox splashLoadOpt=(JComboBox)componentMap.get(""String_Node_Str"");
  JTextArea splashPage=(JTextArea)componentMap.get(""String_Node_Str"");
  fc.showOpenDialog(splashLoaderButton);
  if (filename.string != null) {
    if (splashLoadOpt.getSelectedIndex() == 0)     splashPage.setText(filename.string);
 else {
      try {
        splashPage.setText(Slurpie.slurp(filename.string));
      }
 catch (      IOException e) {
        SurveyMan.LOGGER.fatal(e);
      }
    }
  }
}","private void loadSplashPage(){
  fc.showOpenDialog(Experiment.splashLoaderButton);
  if (filename.string != null) {
    if (Experiment.splashLoadOpt.getSelectedIndex() == 0)     Experiment.splashPage.setText(filename.string);
 else {
      try {
        Experiment.splashPage.setText(Slurpie.slurp(filename.string));
      }
 catch (      IOException e) {
        SurveyMan.LOGGER.fatal(e);
      }
    }
  }
}",0.6746987951807228
109973,"private void viewResults(){
  JComboBox csvLabel=(JComboBox)componentMap.get(""String_Node_Str"");
  if (csvLabel != null) {
    String csv=(String)csvLabel.getSelectedItem();
    System.out.println(csv);
    Survey survey=cachedSurveys.get(csv);
    if (survey != null) {
      try {
        ResponseManager.Record record=ResponseManager.getRecord(survey);
        if (record != null) {
          Experiment.updateStatusLabel(""String_Node_Str"" + record.outputFileName);
          Experiment.updateStatusLabel(Slurpie.slurp(record.outputFileName));
        }
      }
 catch (      IOException io) {
        SurveyMan.LOGGER.warn(io);
        Experiment.updateStatusLabel(io.getMessage());
      }
    }
  }
}","private void viewResults(){
  if (Experiment.csvLabel != null) {
    String csv=(String)Experiment.csvLabel.getSelectedItem();
    System.out.println(csv);
    Survey survey=cachedSurveys.get(csv);
    if (survey != null) {
      try {
        ResponseManager.Record record=ResponseManager.getRecord(survey);
        if (record != null) {
          Experiment.updateStatusLabel(""String_Node_Str"" + record.outputFileName);
          Experiment.updateStatusLabel(Slurpie.slurp(record.outputFileName));
        }
      }
 catch (      IOException io) {
        SurveyMan.LOGGER.warn(io);
        Experiment.updateStatusLabel(io.getMessage());
      }
    }
  }
}",0.928937728937729
109974,"private void sendSurvey(){
  final Survey survey;
  final Thread runner, writer, notifier;
  try {
    JComboBox csvLabel=(JComboBox)componentMap.get(""String_Node_Str"");
    if (csvLabel != null) {
      String csv=(String)csvLabel.getSelectedItem();
      if (cachedSurveys.containsKey(csv))       survey=cachedSurveys.get(csv);
 else {
        survey=Experiment.makeSurvey();
        cachedSurveys.put(csv,survey);
      }
    }
 else     survey=null;
    runner=new Thread(){
      public void run(){
        boolean done=false;
        while (!done) {
          try {
            Runner.run(survey);
            done=true;
          }
 catch (          AccessKeyException ake) {
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",ake.getMessage()));
            (new File(MturkLibrary.CONFIG)).delete();
            SurveyMan.LOGGER.fatal(ake);
            System.exit(-1);
          }
catch (          SurveyException se) {
            SurveyMan.LOGGER.warn(se);
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",se.getMessage()));
            done=true;
          }
catch (          ServiceException mturkse) {
            SurveyMan.LOGGER.warn(mturkse);
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",mturkse.getMessage()));
          }
catch (          IOException io) {
            SurveyMan.LOGGER.warn(io);
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",io.getMessage()));
            done=true;
          }
        }
      }
    }
;
    writer=new Thread(){
      public void run(){
        boolean notJoined=true;
        try {
          while (true) {
            ResponseManager.Record record=ResponseManager.getRecord(survey);
            if (record != null) {
              Runner.writeResponses(survey);
              if (!runner.isAlive() || !Runner.stillLive(survey)) {
                Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sourceName,record.responses.size(),record.outputFileName));
                cachedSurveys.remove(survey);
                break;
              }
              try {
                sleep(Runner.waitTime);
              }
 catch (              InterruptedException ie) {
                SurveyMan.LOGGER.warn(ie);
              }
            }
          }
        }
 catch (        AccessKeyException ake) {
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",ake.getMessage()));
          (new File(MturkLibrary.CONFIG)).delete();
          SurveyMan.LOGGER.fatal(ake);
          System.exit(-1);
        }
catch (        IOException io) {
          SurveyMan.LOGGER.warn(io);
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sid,survey.sourceName));
          boolean success=false;
          while (!success) {
            try {
              runner.join();
              ResponseManager.Record record=ResponseManager.getRecord(survey);
              for (              HIT hit : record.getAllHITs())               ResponseManager.expireHIT(hit);
              success=true;
            }
 catch (            InterruptedException ie) {
              SurveyMan.LOGGER.warn(ie);
            }
catch (            IOException ioe) {
              SurveyMan.LOGGER.warn(ioe);
            }
          }
        }
      }
    }
;
    notifier=new Thread(){
      public void run(){
        Map<String,HIT> hitsNotified=new HashMap<String,HIT>();
        Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sourceName));
        long waitTime=1000;
        while (runner.isAlive()) {
          try {
            while (ResponseManager.getRecord(survey) == null) {
              try {
                sleep(waitTime);
              }
 catch (              InterruptedException e) {
                SurveyMan.LOGGER.warn(e);
              }
            }
            while (ResponseManager.getRecord(survey).getLastHIT() == null) {
              try {
                sleep(waitTime);
              }
 catch (              InterruptedException e) {
                SurveyMan.LOGGER.warn(e);
              }
            }
            ResponseManager.Record record=ResponseManager.getRecord(survey);
            HIT hit=record.getLastHIT();
            if (!hitsNotified.containsKey(hit.getHITId())) {
              hitsNotified.put(hit.getHITId(),hit);
              Experiment.updateStatusLabel(String.format(""String_Node_Str"",hit.getHITId(),survey.sourceName));
            }
 else             waitTime=waitTime * (long)1.5;
          }
 catch (          AccessKeyException ake) {
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",ake.getMessage()));
            (new File(MturkLibrary.CONFIG)).delete();
            SurveyMan.LOGGER.fatal(ake);
            System.exit(-1);
          }
catch (          IOException io) {
            SurveyMan.LOGGER.warn(io);
          }
        }
      }
    }
;
    if (survey != null) {
      runner.setPriority(Thread.MIN_PRIORITY);
      writer.setPriority(Thread.MIN_PRIORITY);
      notifier.setPriority(Thread.MIN_PRIORITY);
      runner.start();
      writer.start();
      notifier.start();
    }
  }
 catch (  IOException e) {
    SurveyMan.LOGGER.warn(e);
    Experiment.updateStatusLabel(e.getMessage());
  }
catch (  SurveyException se) {
    SurveyMan.LOGGER.warn(se);
    Experiment.updateStatusLabel(String.format(""String_Node_Str"",se.getMessage()));
  }
catch (  ServiceException mturkse) {
    SurveyMan.LOGGER.warn(mturkse.getMessage());
    Experiment.updateStatusLabel(String.format(""String_Node_Str"",mturkse.getMessage()));
  }
}","private void sendSurvey(){
  final Survey survey;
  final Thread runner, writer, notifier;
  try {
    if (Experiment.csvLabel != null) {
      String csv=(String)Experiment.csvLabel.getSelectedItem();
      if (cachedSurveys.containsKey(csv))       survey=cachedSurveys.get(csv);
 else {
        survey=Experiment.makeSurvey();
        cachedSurveys.put(csv,survey);
      }
    }
 else     survey=null;
    runner=new Thread(){
      public void run(){
        boolean done=false;
        while (!done) {
          try {
            Runner.run(survey);
            done=true;
          }
 catch (          AccessKeyException ake) {
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",ake.getMessage()));
            (new File(MturkLibrary.CONFIG)).delete();
            SurveyMan.LOGGER.fatal(ake);
            System.exit(-1);
          }
catch (          SurveyException se) {
            SurveyMan.LOGGER.warn(se);
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",se.getMessage()));
            done=true;
          }
catch (          ServiceException mturkse) {
            SurveyMan.LOGGER.warn(mturkse);
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",mturkse.getMessage()));
          }
catch (          IOException io) {
            SurveyMan.LOGGER.warn(io);
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",io.getMessage()));
            done=true;
          }
        }
      }
    }
;
    writer=new Thread(){
      public void run(){
        boolean notJoined=true;
        try {
          while (true) {
            ResponseManager.Record record=ResponseManager.getRecord(survey);
            if (record != null) {
              Runner.writeResponses(survey);
              if (!runner.isAlive() || !Runner.stillLive(survey)) {
                Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sourceName,record.responses.size(),record.outputFileName));
                cachedSurveys.remove(survey);
                break;
              }
              try {
                sleep(Runner.waitTime);
              }
 catch (              InterruptedException ie) {
                SurveyMan.LOGGER.warn(ie);
              }
            }
          }
        }
 catch (        AccessKeyException ake) {
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",ake.getMessage()));
          (new File(MturkLibrary.CONFIG)).delete();
          SurveyMan.LOGGER.fatal(ake);
          System.exit(-1);
        }
catch (        IOException io) {
          SurveyMan.LOGGER.warn(io);
          Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sid,survey.sourceName));
          boolean success=false;
          while (!success) {
            try {
              runner.join();
              ResponseManager.Record record=ResponseManager.getRecord(survey);
              for (              HIT hit : record.getAllHITs())               ResponseManager.expireHIT(hit);
              success=true;
            }
 catch (            InterruptedException ie) {
              SurveyMan.LOGGER.warn(ie);
            }
catch (            IOException ioe) {
              SurveyMan.LOGGER.warn(ioe);
            }
          }
        }
      }
    }
;
    notifier=new Thread(){
      public void run(){
        Map<String,HIT> hitsNotified=new HashMap<String,HIT>();
        Experiment.updateStatusLabel(String.format(""String_Node_Str"",survey.sourceName));
        long waitTime=1000;
        while (runner.isAlive()) {
          try {
            while (ResponseManager.getRecord(survey) == null) {
              try {
                sleep(waitTime);
              }
 catch (              InterruptedException e) {
                SurveyMan.LOGGER.warn(e);
              }
            }
            while (ResponseManager.getRecord(survey).getLastHIT() == null) {
              try {
                sleep(waitTime);
              }
 catch (              InterruptedException e) {
                SurveyMan.LOGGER.warn(e);
              }
            }
            ResponseManager.Record record=ResponseManager.getRecord(survey);
            HIT hit=record.getLastHIT();
            if (!hitsNotified.containsKey(hit.getHITId())) {
              hitsNotified.put(hit.getHITId(),hit);
              Experiment.updateStatusLabel(String.format(""String_Node_Str"",hit.getHITId(),survey.sourceName));
            }
 else             waitTime=waitTime * (long)1.5;
          }
 catch (          AccessKeyException ake) {
            Experiment.updateStatusLabel(String.format(""String_Node_Str"",ake.getMessage()));
            (new File(MturkLibrary.CONFIG)).delete();
            SurveyMan.LOGGER.fatal(ake);
            System.exit(-1);
          }
catch (          IOException io) {
            SurveyMan.LOGGER.warn(io);
          }
        }
      }
    }
;
    if (survey != null) {
      runner.setPriority(Thread.MIN_PRIORITY);
      writer.setPriority(Thread.MIN_PRIORITY);
      notifier.setPriority(Thread.MIN_PRIORITY);
      runner.start();
      writer.start();
      notifier.start();
    }
  }
 catch (  IOException e) {
    SurveyMan.LOGGER.warn(e);
    Experiment.updateStatusLabel(e.getMessage());
  }
catch (  SurveyException se) {
    SurveyMan.LOGGER.warn(se);
    Experiment.updateStatusLabel(String.format(""String_Node_Str"",se.getMessage()));
  }
catch (  ServiceException mturkse) {
    SurveyMan.LOGGER.warn(mturkse.getMessage());
    Experiment.updateStatusLabel(String.format(""String_Node_Str"",mturkse.getMessage()));
  }
}",0.9911819720317092
109975,"private void openPreviewHTML(){
  JComboBox csvLabel=(JComboBox)componentMap.get(""String_Node_Str"");
  if (csvLabel != null) {
    String csv=(String)csvLabel.getSelectedItem();
    try {
      Survey survey;
      if (cachedSurveys.containsKey(csv)) {
        Experiment.loadParameters();
        SurveyPoster.updateProperties();
        survey=cachedSurveys.get(csv);
      }
 else {
        survey=Experiment.makeSurvey();
        cachedSurveys.put(csv,survey);
      }
      HTMLGenerator.spitHTMLToFile(HTMLGenerator.getHTMLString(survey),survey);
      Desktop.getDesktop().browse(new URI(""String_Node_Str"" + HTMLGenerator.htmlFileName));
    }
 catch (    IOException io) {
      Experiment.updateStatusLabel(String.format(""String_Node_Str"",HTMLGenerator.htmlFileName));
      SurveyMan.LOGGER.fatal(io);
    }
catch (    SurveyException se) {
      Experiment.updateStatusLabel(se.getMessage());
      cachedSurveys.remove(csv);
      SurveyMan.LOGGER.warn(se);
    }
catch (    URISyntaxException uri) {
      SurveyMan.LOGGER.fatal(uri);
    }
  }
}","private void openPreviewHTML(){
  if (Experiment.csvLabel != null) {
    String csv=(String)Experiment.csvLabel.getSelectedItem();
    try {
      Survey survey;
      if (cachedSurveys.containsKey(csv)) {
        Experiment.loadParameters();
        SurveyPoster.updateProperties();
        survey=cachedSurveys.get(csv);
      }
 else {
        survey=Experiment.makeSurvey();
        cachedSurveys.put(csv,survey);
      }
      HTMLGenerator.spitHTMLToFile(HTMLGenerator.getHTMLString(survey),survey);
      Desktop.getDesktop().browse(new URI(""String_Node_Str"" + HTMLGenerator.htmlFileName));
    }
 catch (    IOException io) {
      Experiment.updateStatusLabel(String.format(""String_Node_Str"",HTMLGenerator.htmlFileName));
      SurveyMan.LOGGER.fatal(io);
    }
catch (    SurveyException se) {
      Experiment.updateStatusLabel(se.getMessage());
      cachedSurveys.remove(csv);
      SurveyMan.LOGGER.warn(se);
    }
catch (    URISyntaxException uri) {
      SurveyMan.LOGGER.fatal(uri);
    }
  }
}",0.9531627233220666
109976,"private void previewCSV(){
  JComboBox csvLabel=(JComboBox)componentMap.get(""String_Node_Str"");
  if (csvLabel != null) {
    try {
      Experiment.updateStatusLabel(Slurpie.slurp(((String)csvLabel.getSelectedItem()),previewSize).substring(0,previewSize) + ""String_Node_Str"");
    }
 catch (    IOException io) {
      SurveyMan.LOGGER.warn(io);
      Experiment.updateStatusLabel(io.getMessage());
    }
  }
}","private void previewCSV(){
  if (Experiment.csvLabel != null) {
    try {
      Experiment.updateStatusLabel(Slurpie.slurp(((String)Experiment.csvLabel.getSelectedItem()),previewSize).substring(0,previewSize) + ""String_Node_Str"");
    }
 catch (    IOException io) {
      SurveyMan.LOGGER.warn(io);
      Experiment.updateStatusLabel(io.getMessage());
    }
  }
}",0.8825806451612903
109977,"private static void setActionListeners(){
  ExperimentAction splashAction=new ExperimentAction(ExperimentActions.LOAD_SPLASH);
  splashAction.registerComponent(""String_Node_Str"",splashLoaderButton);
  splashAction.registerComponent(""String_Node_Str"",splashLoadOpt);
  splashAction.registerComponent(""String_Node_Str"",splashPage);
  splashLoaderButton.addActionListener(splashAction);
  ExperimentAction csvAction=new ExperimentAction(ExperimentActions.SELECT_CSV);
  csvAction.registerComponent(""String_Node_Str"",selectCSV);
  csvAction.registerComponent(""String_Node_Str"",csvLabel);
  selectCSV.addActionListener(csvAction);
  previewCSV.addActionListener(new ExperimentAction(ExperimentActions.PREVIEW_CSV));
  viewResults.addActionListener(new ExperimentAction(ExperimentActions.VIEW_RESULTS));
  send.addActionListener(new ExperimentAction(ExperimentActions.SEND_SURVEY));
  previewHTML.addActionListener(new ExperimentAction(ExperimentActions.PREVIEW_HIT));
  dumpParams.addActionListener(new ExperimentAction(ExperimentActions.DUMP_PARAMS));
  viewHIT.addActionListener(new ExperimentAction(ExperimentActions.VIEW_HIT));
}","private static void setActionListeners(){
  splashLoaderButton.addActionListener(new ExperimentAction(ExperimentActions.LOAD_SPLASH));
  selectCSV.addActionListener(new ExperimentAction(ExperimentActions.SELECT_CSV));
  previewCSV.addActionListener(new ExperimentAction(ExperimentActions.PREVIEW_CSV));
  viewResults.addActionListener(new ExperimentAction(ExperimentActions.VIEW_RESULTS));
  send.addActionListener(new ExperimentAction(ExperimentActions.SEND_SURVEY));
  previewHTML.addActionListener(new ExperimentAction(ExperimentActions.PREVIEW_HIT));
  dumpParams.addActionListener(new ExperimentAction(ExperimentActions.DUMP_PARAMS));
  viewHIT.addActionListener(new ExperimentAction(ExperimentActions.VIEW_HIT));
}",0.7175324675324676
109978,"private static ArrayList<Block> initializeBlocks() throws SurveyException {
  Map<String,Block> blockLookUp=new HashMap<String,Block>();
  setBlockMaps(blockLookUp,topLevelBlocks);
  allBlockLookUp=new HashMap<String,Block>(blockLookUp);
  ArrayList<Block> blocks=(ArrayList<Block>)topLevelBlocks;
  int currentDepth=1;
  while (!blockLookUp.isEmpty()) {
    Iterator<String> itr=blockLookUp.keySet().iterator();
    while (itr.hasNext()) {
      String strId=itr.next();
      if (topLevelBlocks.contains(blockLookUp.get(strId))) {
        itr.remove();
        blockLookUp.remove(strId);
      }
 else {
        LOGGER.log(Level.WARN,""String_Node_Str"");
        Block block=blockLookUp.get(strId);
        if (block.id.length == currentDepth + 1) {
          List<Integer> sublist=new ArrayList<Integer>();
          for (int i=0; i < block.id.length - 1; i++)           sublist.add(block.id[i]);
          Integer[] parentBlockId=sublist.toArray(new Integer[block.id.length - 1]);
          String parentBlockStr=parentBlockId[0].toString();
          for (int i=1; i < parentBlockId.length; i++)           parentBlockStr=parentBlockStr + ""String_Node_Str"" + parentBlockId[i].toString();
          Block parent=allBlockLookUp.get(parentBlockStr);
          int thisBlocksIndex=block.id[block.id.length - 1] - 1;
          if (parent.subBlocks == null)           parent.subBlocks=new ArrayList<Block>();
          if (parent.subBlocks.size() < thisBlocksIndex + 1)           for (int j=parent.subBlocks.size(); j <= thisBlocksIndex; j++)           parent.subBlocks.add(null);
          if (parent.subBlocks.get(thisBlocksIndex) != null)           throw new MalformedBlockException(block.strId);
          parent.subBlocks.set(thisBlocksIndex,block);
          itr.remove();
          blockLookUp.remove(strId);
        }
      }
    }
    currentDepth++;
  }
  return blocks;
}","private static ArrayList<Block> initializeBlocks() throws SurveyException {
  Map<String,Block> blockLookUp=new HashMap<String,Block>();
  setBlockMaps(blockLookUp,topLevelBlocks);
  allBlockLookUp=new HashMap<String,Block>(blockLookUp);
  ArrayList<Block> blocks=(ArrayList<Block>)topLevelBlocks;
  int currentDepth=1;
  while (!blockLookUp.isEmpty()) {
    Iterator<String> itr=blockLookUp.keySet().iterator();
    while (itr.hasNext()) {
      String strId=itr.next();
      if (topLevelBlocks.contains(blockLookUp.get(strId))) {
        itr.remove();
        blockLookUp.remove(strId);
      }
 else {
        LOGGER.log(Level.WARN,""String_Node_Str"");
        Block block=blockLookUp.get(strId);
        if (block.id.length == currentDepth + 1) {
          List<Integer> sublist=new ArrayList<Integer>();
          for (int i=0; i < block.id.length - 1; i++)           sublist.add(block.id[i]);
          Integer[] parentBlockId=sublist.toArray(new Integer[block.id.length - 1]);
          String parentBlockStr=parentBlockId[0].toString();
          for (int i=1; i < parentBlockId.length; i++)           parentBlockStr=parentBlockStr + ""String_Node_Str"" + parentBlockId[i].toString();
          Block parent=allBlockLookUp.get(parentBlockStr);
          int thisBlocksIndex=block.id[block.id.length - 1] - 1;
          if (parent == null) {
            parent=new Block();
            parent.strId=parentBlockStr;
            parent.id=getBlockIdArray(parentBlockStr);
          }
          if (parent.subBlocks == null)           parent.subBlocks=new ArrayList<Block>();
          if (parent.subBlocks.size() < thisBlocksIndex + 1)           for (int j=parent.subBlocks.size(); j <= thisBlocksIndex; j++)           parent.subBlocks.add(null);
          if (parent.subBlocks.get(thisBlocksIndex) != null)           throw new MalformedBlockException(block.strId);
          parent.subBlocks.set(thisBlocksIndex,block);
          itr.remove();
          blockLookUp.remove(strId);
        }
      }
    }
    currentDepth++;
  }
  return blocks;
}",0.956234096692112
109979,"private void openPreviewHTML(){
  JComboBox csvLabel=(JComboBox)componentMap.get(""String_Node_Str"");
  if (csvLabel != null) {
    String csv=(String)csvLabel.getSelectedItem();
    try {
      Survey survey;
      if (cachedSurveys.containsKey(csv)) {
        Experiment.loadParameters();
        SurveyPoster.updateProperties();
        survey=cachedSurveys.get(csv);
      }
 else {
        survey=Experiment.makeSurvey();
        cachedSurveys.put(csv,survey);
      }
      HTMLGenerator.spitHTMLToFile(HTMLGenerator.getHTMLString(survey),survey);
      Desktop.getDesktop().browse(new URI(""String_Node_Str"" + HTMLGenerator.htmlFileName));
    }
 catch (    IOException io) {
      Experiment.updateStatusLabel(String.format(""String_Node_Str"",HTMLGenerator.htmlFileName));
      SurveyMan.LOGGER.fatal(io);
    }
catch (    SurveyException se) {
      Experiment.updateStatusLabel(se.getMessage());
      SurveyMan.LOGGER.warn(se);
    }
catch (    URISyntaxException uri) {
      SurveyMan.LOGGER.fatal(uri);
    }
  }
}","private void openPreviewHTML(){
  JComboBox csvLabel=(JComboBox)componentMap.get(""String_Node_Str"");
  if (csvLabel != null) {
    String csv=(String)csvLabel.getSelectedItem();
    try {
      Survey survey;
      if (cachedSurveys.containsKey(csv)) {
        Experiment.loadParameters();
        SurveyPoster.updateProperties();
        survey=cachedSurveys.get(csv);
      }
 else {
        survey=Experiment.makeSurvey();
        cachedSurveys.put(csv,survey);
      }
      HTMLGenerator.spitHTMLToFile(HTMLGenerator.getHTMLString(survey),survey);
      Desktop.getDesktop().browse(new URI(""String_Node_Str"" + HTMLGenerator.htmlFileName));
    }
 catch (    IOException io) {
      Experiment.updateStatusLabel(String.format(""String_Node_Str"",HTMLGenerator.htmlFileName));
      SurveyMan.LOGGER.fatal(io);
    }
catch (    SurveyException se) {
      Experiment.updateStatusLabel(se.getMessage());
      cachedSurveys.remove(csv);
      SurveyMan.LOGGER.warn(se);
    }
catch (    URISyntaxException uri) {
      SurveyMan.LOGGER.fatal(uri);
    }
  }
}",0.9841726618705036
109980,"public double surveyEntropy(Survey s,ArrayList<SurveyResponse> responses){
  double entropy=0;
  ArrayList<Map<String,Double>> hists=qHistograms(s,responses);
  for (int x=0; x < s.questions.size(); x++) {
    int qopts=s.questions.get(x).options.size();
    for (    Double count : hists.get(x).values()) {
      entropy+=(count / qopts) * Math.log(count / qopts);
    }
  }
  return -entropy;
}","public double surveyEntropy(Survey s,ArrayList<SurveyResponse> responses){
  double entropy=0;
  ArrayList<Map<String,Double>> hists=qHistograms(s,responses);
  double n=responses.size();
  for (int x=0; x < s.questions.size(); x++) {
    for (    Double count : hists.get(x).values()) {
      entropy+=(count / n) * Math.log(count / n);
    }
  }
  return -entropy;
}",0.7041884816753927
109981,"public ArrayList<SurveyResponse> entropyBootstrap(Survey s,ArrayList<SurveyResponse> responses){
  double fraction=((double)responses.size()) / ((double)responses.size() - 1);
  double multiplier=Math.pow(fraction,responses.size());
  double numBootstraps=1000 * multiplier;
  int n=responses.size();
  final int THRESHOLD=5;
  Random r=new Random();
  ArrayList<Double> bootstrapStats=new ArrayList<Double>((int)numBootstraps);
  ArrayList<ArrayList<Double>> responseEntropies=new ArrayList<ArrayList<Double>>();
  for (int x=0; x < n; x++) {
    responseEntropies.add(new ArrayList<Double>());
  }
  boolean[] included;
  double entropy=0;
  for (int x=0; x < numBootstraps; x++) {
    included=new boolean[n];
    ArrayList<SurveyResponse> temp=new ArrayList<SurveyResponse>();
    for (int y=0; y < n; y++) {
      int randIndex=r.nextInt(n);
      SurveyResponse sr=responses.get(randIndex);
      temp.add(sr);
      included[randIndex]=true;
    }
    entropy=surveyEntropy(s,temp);
    bootstrapStats.add(entropy);
    for (int z=0; z < n; z++) {
      if (!included[z])       responseEntropies.get(z).add(entropy);
    }
  }
  double bootstrapMean=Stat.mean(bootstrapStats);
  double bootstrapSD=Stat.stddev(bootstrapStats);
  double responseMean=0;
  double responseSD=0;
  double t;
  ArrayList<SurveyResponse> outliers=new ArrayList<SurveyResponse>();
  for (int x=0; x < n; x++) {
    responseMean=Stat.mean(responseEntropies.get(x));
    responseSD=Stat.stddev(responseEntropies.get(x));
    t=(bootstrapMean - responseMean) / Math.sqrt((Math.pow(bootstrapSD,2)) / n + (Math.pow(responseSD,2)) / responseEntropies.get(x).size());
    if (t > THRESHOLD)     outliers.add(responses.get(x));
  }
  return responses;
}","public ArrayList<SurveyResponse> entropyBootstrap(Survey s,ArrayList<SurveyResponse> responses){
  double fraction=((double)responses.size()) / ((double)responses.size() - 1);
  double multiplier=Math.pow(fraction,responses.size());
  double numBootstraps=10000 * multiplier;
  int n=responses.size();
  final int THRESHOLD=5;
  System.out.println(numBootstraps);
  System.out.println();
  Random r=new Random();
  ArrayList<Double> bootstrapStats=new ArrayList<Double>((int)numBootstraps);
  ArrayList<ArrayList<Double>> responseEntropies=new ArrayList<ArrayList<Double>>();
  for (int x=0; x < n; x++) {
    responseEntropies.add(new ArrayList<Double>());
  }
  boolean[] included;
  double entropy=0;
  for (int x=0; x < numBootstraps; x++) {
    included=new boolean[n];
    ArrayList<SurveyResponse> temp=new ArrayList<SurveyResponse>();
    for (int y=0; y < n; y++) {
      int randIndex=r.nextInt(n);
      SurveyResponse sr=responses.get(randIndex);
      temp.add(sr);
      included[randIndex]=true;
    }
    entropy=surveyEntropy(s,temp);
    bootstrapStats.add(entropy);
    for (int z=0; z < n; z++) {
      if (!included[z])       responseEntropies.get(z).add(entropy);
    }
  }
  double bootstrapMean=Stat.mean(bootstrapStats);
  System.out.println(""String_Node_Str"" + bootstrapMean);
  double bootstrapSD=Stat.stddev(bootstrapStats);
  System.out.println(""String_Node_Str"" + bootstrapSD);
  double responseMean=0;
  double responseSD=0;
  double t;
  ArrayList<SurveyResponse> outliers=new ArrayList<SurveyResponse>();
  for (int x=0; x < n; x++) {
    responseMean=Stat.mean(responseEntropies.get(x));
    responseSD=Stat.stddev(responseEntropies.get(x));
    t=(bootstrapMean - responseMean) / Math.sqrt((Math.pow(bootstrapSD,2)) / n + (Math.pow(responseSD,2)) / responseEntropies.get(x).size());
    if (t > THRESHOLD)     outliers.add(responses.get(x));
  }
  return responses;
}",0.9520661157024792
109982,"public static void main(String[] args){
  String separator=System.getProperty(""String_Node_Str"");
  System.out.println(separator);
  String filename=""String_Node_Str"" + separator + ""String_Node_Str"";
  Survey survey1=null;
  try {
    survey1=csv.CSVParser.parse(filename,""String_Node_Str"");
    System.out.println(survey1);
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"");
  }
  for (  Question q : survey1.questions) {
    System.out.println(q.data);
    System.out.println(q.options);
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  ArrayList<SurveyResponse> responses=new ArrayList<SurveyResponse>();
  Random rand=new Random();
  int numResponses=20;
  int numRandomResponses=5;
  for (int x=0; x < numResponses; x++) {
    SurveyResponse sr=new SurveyResponse(""String_Node_Str"" + rand.nextInt(1000));
    responses.add(sr.consistentResponse(survey1));
  }
  SurveyResponse curR=responses.get(0);
  for (int x=0; x < numRandomResponses; x++) {
    SurveyResponse sr=new SurveyResponse(""String_Node_Str"" + rand.nextInt(1000));
    responses.add(sr.randomResponse(survey1));
  }
  Collections.shuffle(responses);
  QCMetric qc=new QCMetric();
  ArrayList<SurveyResponse> outliers=qc.entropyBootstrap(survey1,responses);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + outliers.size());
  for (  SurveyResponse o : outliers) {
    System.out.println(o.toString(survey1,""String_Node_Str""));
    System.out.println(o.real);
    System.out.println();
  }
}","public static void main(String[] args){
  String separator=System.getProperty(""String_Node_Str"");
  System.out.println(separator);
  String filename=""String_Node_Str"" + separator + ""String_Node_Str"";
  Survey survey1=null;
  try {
    survey1=csv.CSVParser.parse(filename,""String_Node_Str"");
    System.out.println(survey1);
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"");
  }
  for (  Question q : survey1.questions) {
    System.out.println(q.data);
    System.out.println(q.options);
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  ArrayList<SurveyResponse> responses=new ArrayList<SurveyResponse>();
  Random rand=new Random();
  int numResponses=30;
  int numRandomResponses=2;
  for (int x=0; x < numResponses; x++) {
    SurveyResponse sr=new SurveyResponse(""String_Node_Str"" + rand.nextInt(1000));
    responses.add(sr.consistentResponse(survey1));
  }
  SurveyResponse curR=responses.get(0);
  for (int x=0; x < numRandomResponses; x++) {
    SurveyResponse sr=new SurveyResponse(""String_Node_Str"" + rand.nextInt(1000));
    responses.add(sr.randomResponse(survey1));
  }
  Collections.shuffle(responses);
  for (  SurveyResponse r : responses) {
    System.out.println(r.toString(survey1,""String_Node_Str""));
    System.out.println(r.real);
    System.out.println();
  }
  QCMetric qc=new QCMetric();
  ArrayList<SurveyResponse> outliers=qc.entropyBootstrap(survey1,responses);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + outliers.size());
  for (  SurveyResponse o : outliers) {
    System.out.println(o.toString(survey1,""String_Node_Str""));
    System.out.println(o.real);
    System.out.println();
  }
}",0.9319148936170212
109983,"public static HashMap<String,ArrayList<CSVEntry>> lex(String filename) throws FileNotFoundException, IOException, RuntimeException {
  BufferedReader br=new BufferedReader(new FileReader(filename));
  HashMap<String,ArrayList<CSVEntry>> entries=null;
  String line=""String_Node_Str"";
  int lineno=0;
  while ((line=br.readLine()) != null) {
    lineno+=1;
    if (headers == null) {
      headers=getHeaders(line);
      entries=new HashMap<String,ArrayList<CSVEntry>>(headers.length);
      for (int i=0; i < headers.length; i++)       entries.put(headers[i],new ArrayList<CSVEntry>());
    }
 else {
      while (inQuot(line)) {
        String newLine=br.readLine();
        lineno+=1;
        if (newLine != null)         line=line + newLine;
 else         throw new MalformedQuotationException(line);
      }
      String entry=null;
      String restOfLine=line;
      for (int i=0; i < headers.length; i++) {
        if (i == headers.length - 1) {
          if (inQuot(restOfLine))           throw new MalformedQuotationException(restOfLine);
          entries.get(headers[i]).add(new CSVEntry(restOfLine,lineno,i));
        }
 else {
          int a=restOfLine.indexOf(Character.toString((char)seperator));
          int b=1;
          if (a == -1) {
            out.println(String.format(""String_Node_Str"",Character.toString((char)seperator),String.format(""String_Node_Str"",seperator),lineno,line));
          }
          entry=restOfLine.substring(0,a + b);
          restOfLine=restOfLine.substring(entry.length());
          while (inQuot(entry)) {
            if (restOfLine.equals(""String_Node_Str""))             throw new MalformedQuotationException(entry);
            a=restOfLine.indexOf(Character.toString((char)seperator));
            entry=entry + restOfLine.substring(0,a + b);
            restOfLine=restOfLine.substring(a + b);
          }
          entries.get(headers[i]).add(new CSVEntry(entry,lineno,i));
        }
      }
    }
  }
  out.println(filename + ""String_Node_Str"" + (lineno - 1)+ ""String_Node_Str""+ Character.toString((char)seperator)+ ""String_Node_Str"");
  clean(entries);
  if (!entries.keySet().contains(""String_Node_Str""))   throw new CSVColumnException(""String_Node_Str"");
  if (!entries.keySet().contains(""String_Node_Str""))   throw new CSVColumnException(""String_Node_Str"");
  return entries;
}","public static HashMap<String,ArrayList<CSVEntry>> lex(String filename) throws FileNotFoundException, IOException, RuntimeException {
  BufferedReader br=new BufferedReader(new FileReader(filename));
  HashMap<String,ArrayList<CSVEntry>> entries=null;
  String line=""String_Node_Str"";
  int lineno=0;
  resetHeaders();
  while ((line=br.readLine()) != null) {
    lineno+=1;
    if (headers == null) {
      headers=getHeaders(line);
      entries=new HashMap<String,ArrayList<CSVEntry>>(headers.length);
      for (int i=0; i < headers.length; i++)       entries.put(headers[i],new ArrayList<CSVEntry>());
    }
 else {
      while (inQuot(line)) {
        String newLine=br.readLine();
        lineno+=1;
        if (newLine != null)         line=line + newLine;
 else         throw new MalformedQuotationException(line);
      }
      String entry=null;
      String restOfLine=line;
      for (int i=0; i < headers.length; i++) {
        if (i == headers.length - 1) {
          if (inQuot(restOfLine))           throw new MalformedQuotationException(restOfLine);
          entries.get(headers[i]).add(new CSVEntry(restOfLine,lineno,i));
        }
 else {
          int a=restOfLine.indexOf(Character.toString((char)seperator));
          int b=1;
          if (a == -1) {
            out.println(String.format(""String_Node_Str"",Character.toString((char)seperator),String.format(""String_Node_Str"",seperator),lineno,line));
          }
          entry=restOfLine.substring(0,a + b);
          restOfLine=restOfLine.substring(entry.length());
          while (inQuot(entry)) {
            if (restOfLine.equals(""String_Node_Str""))             throw new MalformedQuotationException(entry);
            a=restOfLine.indexOf(Character.toString((char)seperator));
            entry=entry + restOfLine.substring(0,a + b);
            restOfLine=restOfLine.substring(a + b);
          }
          try {
            entries.get(headers[i]).add(new CSVEntry(entry,lineno,i));
          }
 catch (          NullPointerException e) {
            System.out.println(entries);
            System.out.println(headers + ""String_Node_Str"" + i);
            System.out.println(headers[i]);
            System.out.println(entry);
            System.out.println(lineno);
          }
        }
      }
    }
  }
  out.println(filename + ""String_Node_Str"" + (lineno - 1)+ ""String_Node_Str""+ Character.toString((char)seperator)+ ""String_Node_Str"");
  clean(entries);
  if (!entries.keySet().contains(""String_Node_Str""))   throw new CSVColumnException(""String_Node_Str"");
  if (!entries.keySet().contains(""String_Node_Str""))   throw new CSVColumnException(""String_Node_Str"");
  return entries;
}",0.8362911266201396
109984,"public static void main(String[] args){
  WebGenerator generator=new WebGenerator();
  String fileContents=""String_Node_Str"";
  String previewContents=""String_Node_Str"";
  int numSurveys=0;
  String[] lines;
  List<String> toQuestion=new ArrayList<String>();
  ArrayList<String[]> allQuestions=new ArrayList<String[]>();
  String[] parsedData;
  if (args.length < 3) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  Parser csvParser=new Parser();
  try {
    System.out.println(args[0]);
    System.out.println(args[1]);
    fileContents=csvParser.readFile(args[0]);
    previewContents=csvParser.readFile(args[1]);
  }
 catch (  java.io.FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  try {
    numSurveys=Integer.parseInt(args[2]);
  }
 catch (  java.lang.NumberFormatException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  lines=csvParser.split(fileContents);
  for (int i=0; i < lines.length; i++) {
    parsedData=csvParser.parse(lines[i].replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    boolean listSeparate=false;
    if (parsedData.length > 1 && toQuestion.size() > 1) {
      if (!(parsedData[1].equals(toQuestion.get(1)) && parsedData[2].equals(toQuestion.get(2)))) {
        listSeparate=true;
      }
    }
    if (toQuestion.size() == 0 || listSeparate) {
      String[] q=toQuestion.toArray(new String[toQuestion.size()]);
      if (i != 0 && i != 1) {
        allQuestions.add(q);
      }
      toQuestion=Arrays.asList(parsedData);
    }
 else {
      if (toQuestion.size() > 3 && parsedData.length > 3) {
        toQuestion.set(3,toQuestion.get(3) + ""String_Node_Str"" + parsedData[3]);
      }
 else {
        System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
        System.exit(0);
      }
    }
  }
  String[] q=toQuestion.toArray(new String[toQuestion.size()]);
  allQuestions.add(q);
  generator.generateSurvey(allQuestions,previewContents,numSurveys);
}","public static void main(String[] args){
  WebGenerator generator=new WebGenerator();
  String fileContents=""String_Node_Str"";
  String previewContents=""String_Node_Str"";
  int numSurveys=0;
  String[] lines;
  List<String> toQuestion=new ArrayList<String>();
  ArrayList<String[]> allQuestions=new ArrayList<String[]>();
  String[] parsedData;
  if (args.length < 3) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  Parser csvParser=new Parser();
  try {
    System.out.println(args[0]);
    System.out.println(args[1]);
    fileContents=csvParser.readFile(args[0]);
    previewContents=csvParser.readFile(args[1]);
  }
 catch (  java.io.FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  try {
    numSurveys=Integer.parseInt(args[2]);
  }
 catch (  java.lang.NumberFormatException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  lines=csvParser.split(fileContents);
  for (int i=0; i < lines.length; i++) {
    parsedData=csvParser.parse(lines[i]);
    boolean listSeparate=false;
    if (parsedData.length > 1 && toQuestion.size() > 1) {
      if (!(parsedData[1].equals(toQuestion.get(1)) && parsedData[2].equals(toQuestion.get(2)))) {
        listSeparate=true;
      }
    }
    if (toQuestion.size() == 0 || listSeparate) {
      String[] q=toQuestion.toArray(new String[toQuestion.size()]);
      if (i != 0 && i != 1) {
        allQuestions.add(q);
      }
      toQuestion=Arrays.asList(parsedData);
    }
 else {
      if (toQuestion.size() > 3 && parsedData.length > 3) {
        toQuestion.set(3,toQuestion.get(3) + ""String_Node_Str"" + parsedData[3]);
      }
 else {
        System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
        System.exit(0);
      }
    }
  }
  String[] q=toQuestion.toArray(new String[toQuestion.size()]);
  allQuestions.add(q);
  generator.generateSurvey(allQuestions,previewContents,numSurveys);
}",0.9774436090225564
109985,"public void waitForResults(String successFilePath,String outputFilePath,Map<Integer,String[]> qs,Map<Integer,Map> opts){
  boolean resultsNotIn=true;
  try {
    while (resultsNotIn) {
      Thread.sleep(15000);
      getResults(successFilePath,outputFilePath);
      if (surveyIsComplete(outputFilePath,qs,opts)) {
        resultsNotIn=false;
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void waitForResults(String successFilePath,String outputFilePath,Map<Integer,String[]> qs,Map<Integer,Map> opts){
  boolean resultsNotIn=true;
  try {
    while (resultsNotIn) {
      Thread.sleep(2 * 60000);
      getResults(successFilePath,outputFilePath);
      if (surveyIsComplete(outputFilePath,qs,opts)) {
        resultsNotIn=false;
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.9925925925925926
109986,"static void generateSurvey(ArrayList<String[]> questions,String preview,int numSurveys){
  int count=0;
  SurveyPoster turkSurveyPoster=new SurveyPoster();
  for (  String[] question : questions) {
    count++;
    identifiers.put(question,count);
    qs.put(count,question);
  }
  for (int ind=0; ind < numSurveys; ind++) {
    try {
      PrintWriter out;
      File file;
      if (ind + 1 < 10) {
        file=new File(""String_Node_Str"" + (ind + 1) + ""String_Node_Str"");
      }
 else {
        file=new File(""String_Node_Str"" + (ind + 1) + ""String_Node_Str"");
      }
      file.getParentFile().mkdirs();
      out=new PrintWriter(new FileWriter(file));
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(preview);
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      questions=randomize(questions);
      for (      String[] question : questions) {
        out.println(generateQuestion(identifiers.get(question),question));
      }
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.flush();
    }
 catch (    java.io.IOException e) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
  }
  String surveyDir=""String_Node_Str"";
  turkSurveyPoster.postSurvey(numSurveys,surveyDir,qs,opts);
  return;
}","static void generateSurvey(ArrayList<String[]> questions,String preview,int numSurveys){
  int count=0;
  SurveyPoster turkSurveyPoster=new SurveyPoster();
  for (  String[] question : questions) {
    count++;
    identifiers.put(question,count);
    qs.put(count,question);
  }
  for (int ind=0; ind < numSurveys; ind++) {
    try {
      PrintWriter out;
      File file;
      if (ind + 1 < 10) {
        file=new File(""String_Node_Str"" + (ind + 1) + ""String_Node_Str"");
      }
 else {
        file=new File(""String_Node_Str"" + (ind + 1) + ""String_Node_Str"");
      }
      file.getParentFile().mkdirs();
      out=new PrintWriter(new FileWriter(file));
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(preview);
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      questions=randomize(questions);
      for (      String[] question : questions) {
        out.println(generateQuestion(identifiers.get(question),question));
      }
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.flush();
    }
 catch (    java.io.IOException e) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
  }
  String surveyDir=""String_Node_Str"";
  turkSurveyPoster.postSurvey(numSurveys,surveyDir,qs,opts);
  return;
}",0.9791951820421572
109987,"public static void main(String[] args){
  WebGenerator generator=new WebGenerator();
  String fileContents=""String_Node_Str"";
  String previewContents=""String_Node_Str"";
  int numSurveys=0;
  String[] lines;
  List<String> toQuestion=new ArrayList<String>();
  ArrayList<String[]> allQuestions=new ArrayList<String[]>();
  String[] parsedData;
  if (args.length < 3) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  Parser csvParser=new Parser();
  try {
    System.out.println(args[0]);
    System.out.println(args[1]);
    fileContents=csvParser.readFile(args[0]);
    previewContents=csvParser.readFile(args[1]);
  }
 catch (  java.io.FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  try {
    numSurveys=Integer.parseInt(args[2]);
  }
 catch (  java.lang.NumberFormatException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  lines=csvParser.split(fileContents);
  for (int i=0; i < lines.length; i++) {
    parsedData=csvParser.parse(lines[i]);
    boolean listSeparate=false;
    if (parsedData.length > 7) {
      if (parsedData[7].equals(""String_Node_Str"") || parsedData[7].equals(""String_Node_Str"")) {
        listSeparate=true;
      }
    }
    if (toQuestion.size() == 0 || (parsedData.length > 0 && !parsedData[1].equals(toQuestion.get(1)) || listSeparate)) {
      String[] q=toQuestion.toArray(new String[toQuestion.size()]);
      if (i != 0 && i != 1) {
        allQuestions.add(q);
      }
      toQuestion=Arrays.asList(parsedData);
    }
 else {
      if (toQuestion.size() > 3 && parsedData.length > 3) {
        toQuestion.set(3,toQuestion.get(3) + ""String_Node_Str"" + parsedData[3]);
      }
 else {
        System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
        System.exit(0);
      }
    }
  }
  String[] q=toQuestion.toArray(new String[toQuestion.size()]);
  allQuestions.add(q);
  generator.generateSurvey(allQuestions,previewContents,numSurveys);
}","public static void main(String[] args){
  WebGenerator generator=new WebGenerator();
  String fileContents=""String_Node_Str"";
  String previewContents=""String_Node_Str"";
  int numSurveys=0;
  String[] lines;
  List<String> toQuestion=new ArrayList<String>();
  ArrayList<String[]> allQuestions=new ArrayList<String[]>();
  String[] parsedData;
  if (args.length < 3) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  Parser csvParser=new Parser();
  try {
    System.out.println(args[0]);
    System.out.println(args[1]);
    fileContents=csvParser.readFile(args[0]);
    previewContents=csvParser.readFile(args[1]);
  }
 catch (  java.io.FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  try {
    numSurveys=Integer.parseInt(args[2]);
  }
 catch (  java.lang.NumberFormatException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  lines=csvParser.split(fileContents);
  for (int i=0; i < lines.length; i++) {
    parsedData=csvParser.parse(lines[i].replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
    boolean listSeparate=false;
    if (parsedData.length > 1 && toQuestion.size() > 1) {
      if (!(parsedData[1].equals(toQuestion.get(1)) && parsedData[2].equals(toQuestion.get(2)))) {
        listSeparate=true;
      }
    }
    if (toQuestion.size() == 0 || listSeparate) {
      String[] q=toQuestion.toArray(new String[toQuestion.size()]);
      if (i != 0 && i != 1) {
        allQuestions.add(q);
      }
      toQuestion=Arrays.asList(parsedData);
    }
 else {
      if (toQuestion.size() > 3 && parsedData.length > 3) {
        toQuestion.set(3,toQuestion.get(3) + ""String_Node_Str"" + parsedData[3]);
      }
 else {
        System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
        System.exit(0);
      }
    }
  }
  String[] q=toQuestion.toArray(new String[toQuestion.size()]);
  allQuestions.add(q);
  generator.generateSurvey(allQuestions,previewContents,numSurveys);
}",0.8896603025043393
109988,"public void waitForResults(String successFilePath,String outputFilePath,Map<Integer,String[]> qs,Map<Integer,Map> opts){
  boolean resultsNotIn=true;
  try {
    while (resultsNotIn) {
      Thread.sleep(2 * 60000);
      getResults(successFilePath,outputFilePath);
      if (surveyIsComplete(outputFilePath,qs,opts)) {
        resultsNotIn=false;
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void waitForResults(String successFilePath,String outputFilePath,Map<Integer,String[]> qs,Map<Integer,Map> opts){
  boolean resultsNotIn=true;
  try {
    while (resultsNotIn) {
      Thread.sleep(15000);
      getResults(successFilePath,outputFilePath);
      if (surveyIsComplete(outputFilePath,qs,opts)) {
        resultsNotIn=false;
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.9925925925925926
109989,"public boolean parseResults(String resultsFile,Map<Integer,String[]> qs,Map<Integer,Map> opts){
  boolean complete=true;
  try {
    Scanner scan=new Scanner(new File(resultsFile));
    String[] headers=scan.nextLine().split(""String_Node_Str"");
    int assignCol=0, completeCol=0, pendCol=0, answerCol=0;
    Map<Integer,String> results=new HashMap<Integer,String>();
    for (int i=0; i < headers.length; i++) {
      if (headers[i].equals(""String_Node_Str"")) {
        assignCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        pendCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        completeCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        answerCol=i;
      }
    }
    int numAvailable=0;
    int numComplete=0;
    int numPending=0;
    Map<Integer,String> optionMap;
    int oid=0;
    Map<Integer,Double> ratings=new HashMap<Integer,Double>();
    while (scan.hasNextLine()) {
      String line=scan.nextLine();
      String[] hitArray=line.split(""String_Node_Str"");
      if (hitArray.length == 0) {
        break;
      }
      try {
        numAvailable=Integer.parseInt(hitArray[assignCol].replace(""String_Node_Str"",""String_Node_Str""));
        numPending=Integer.parseInt(hitArray[pendCol].replace(""String_Node_Str"",""String_Node_Str""));
        numComplete=Integer.parseInt(hitArray[completeCol].replace(""String_Node_Str"",""String_Node_Str""));
        if (numAvailable > 0 || numPending > 0) {
          complete=false;
        }
      }
 catch (      java.lang.NumberFormatException e) {
        e.printStackTrace();
      }
      ArrayList<String> answers=new ArrayList<String>();
      String res=""String_Node_Str"";
      int currentCol=answerCol;
      if (!hitArray[answerCol].equals(""String_Node_Str"")) {
        for (int x=0; x < qs.keySet().size() * 2 + 2; x++) {
          res=hitArray[currentCol].replace(""String_Node_Str"",""String_Node_Str"");
          if (!res.equalsIgnoreCase(""String_Node_Str"")) {
            answers.add(res);
          }
          currentCol++;
        }
      }
      int qid=0;
      int counter=0;
      String questionString=""String_Node_Str"";
      for (      String ans : answers) {
        if (counter % 2 == 0) {
          qid=Integer.parseInt(ans.replace(""String_Node_Str"",""String_Node_Str""));
        }
 else {
          String[] q=qs.get(qid);
          if (!results.containsKey(qid)) {
            if (!q[2].equals(""String_Node_Str"")) {
              results.put(qid,q[1] + ""String_Node_Str"" + q[2].substring(q[2].lastIndexOf(""String_Node_Str"") + 1)+ ""String_Node_Str"");
            }
 else {
              results.put(qid,q[1] + ""String_Node_Str"");
            }
          }
          oid=Integer.parseInt(ans.substring(ans.lastIndexOf(""String_Node_Str"") + 1).replace(""String_Node_Str"",""String_Node_Str""));
          String questionLine=results.get(qid);
          questionLine+=(opts.get(qid).get(oid) + ""String_Node_Str"");
          results.put(qid,questionLine);
          if (!ratings.containsKey(qid)) {
            ratings.put(qid,(double)oid);
          }
 else {
            ratings.put(qid,((double)oid + ratings.get(qid)) / 2.0);
          }
        }
        counter++;
      }
    }
    for (    int qid : results.keySet()) {
      results.put(qid,results.get(qid) + ratings.get(qid));
    }
    System.out.println(results);
    PrintWriter out=new PrintWriter(new FileWriter(""String_Node_Str""));
    out.println(""String_Node_Str"");
    for (    int qid : results.keySet()) {
      out.println(results.get(qid));
    }
    out.flush();
    out.close();
  }
 catch (  java.io.IOException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    System.exit(0);
  }
  return complete;
}","public boolean parseResults(String resultsFile,Map<Integer,String[]> qs,Map<Integer,Map> opts){
  boolean complete=true;
  try {
    Scanner scan=new Scanner(new File(resultsFile));
    String[] headers=scan.nextLine().split(""String_Node_Str"");
    int assignCol=0, completeCol=0, pendCol=0, answerCol=0;
    Map<Integer,String> results=new HashMap<Integer,String>();
    for (int i=0; i < headers.length; i++) {
      if (headers[i].equals(""String_Node_Str"")) {
        assignCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        pendCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        completeCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        answerCol=i;
      }
    }
    int numAvailable=0;
    int numComplete=0;
    int numPending=0;
    Map<Integer,String> optionMap;
    Map<Integer,Double> ratings=new HashMap<Integer,Double>();
    while (scan.hasNextLine()) {
      String line=scan.nextLine();
      String[] hitArray=line.split(""String_Node_Str"");
      if (hitArray.length == 0) {
        break;
      }
      try {
        numAvailable=Integer.parseInt(hitArray[assignCol].replace(""String_Node_Str"",""String_Node_Str""));
        numPending=Integer.parseInt(hitArray[pendCol].replace(""String_Node_Str"",""String_Node_Str""));
        numComplete=Integer.parseInt(hitArray[completeCol].replace(""String_Node_Str"",""String_Node_Str""));
        if (numAvailable > 0 || numPending > 0) {
          complete=false;
        }
      }
 catch (      java.lang.NumberFormatException e) {
        e.printStackTrace();
      }
      ArrayList<String> answers=new ArrayList<String>();
      String res=""String_Node_Str"";
      int currentCol=answerCol;
      if (!hitArray[answerCol].equals(""String_Node_Str"")) {
        for (int x=0; x < qs.keySet().size() * 2 + 2; x++) {
          System.out.println(hitArray[currentCol]);
          res=hitArray[currentCol].replace(""String_Node_Str"",""String_Node_Str"");
          if (!res.equalsIgnoreCase(""String_Node_Str"")) {
            answers.add(res);
          }
          currentCol++;
        }
      }
      int qid=0;
      int counter=0;
      String questionString=""String_Node_Str"";
      for (      String ans : answers) {
        if (counter % 2 == 0) {
          qid=Integer.parseInt(ans.replace(""String_Node_Str"",""String_Node_Str""));
        }
 else {
          String[] q=qs.get(qid);
          if (!results.containsKey(qid)) {
            if (!q[2].equals(""String_Node_Str"")) {
              results.put(qid,q[1] + ""String_Node_Str"" + q[2].substring(q[2].lastIndexOf(""String_Node_Str"") + 1)+ ""String_Node_Str"");
            }
 else {
              results.put(qid,q[1] + ""String_Node_Str"");
            }
          }
          int oid=0;
          String[] optionStrings=ans.split(""String_Node_Str"");
          String questionLine=results.get(qid);
          double rating=0.0;
          for (int k=0; k < optionStrings.length; k++) {
            oid=Integer.parseInt(optionStrings[k].substring(optionStrings[k].lastIndexOf(""String_Node_Str"") + 1).replace(""String_Node_Str"",""String_Node_Str""));
            questionLine+=(opts.get(qid).get(oid) + ""String_Node_Str"");
            rating=((double)oid + rating) / 2;
          }
          results.put(qid,questionLine);
          if (!ratings.containsKey(qid)) {
            ratings.put(qid,rating);
          }
 else {
            ratings.put(qid,(rating + ratings.get(qid)) / 2.0);
          }
        }
        counter++;
      }
    }
    for (    int qid : results.keySet()) {
      results.put(qid,results.get(qid) + ratings.get(qid));
    }
    System.out.println(results);
    PrintWriter out=new PrintWriter(new FileWriter(""String_Node_Str""));
    out.println(""String_Node_Str"");
    for (    int qid : results.keySet()) {
      out.println(results.get(qid));
    }
    out.flush();
    out.close();
  }
 catch (  java.io.IOException e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
    System.exit(0);
  }
  return complete;
}",0.9317186292192734
109990,"static String generateHTMLQuestion(int uid,String text,String resource,String[] options,boolean exclusive,boolean ordered,boolean perturb){
  String HTMLString=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str"";
  HTMLString+=replaceSpecialCharacters(text);
  if (!resource.equals(""String_Node_Str"")) {
    if (resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"")|| resource.contains(""String_Node_Str"")) {
      HTMLString+=""String_Node_Str"" + resource + ""String_Node_Str"";
    }
 else     if (resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"")|| resource.contains(""String_Node_Str"")) {
      HTMLString+=""String_Node_Str"" + resource + ""String_Node_Str"";
    }
  }
  HTMLString+=""String_Node_Str"";
  if (options.length > 10) {
    HTMLString+=""String_Node_Str"";
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + replaceSpecialCharacters(options[i]) + ""String_Node_Str"";
    }
    HTMLString+=""String_Node_Str"";
  }
 else   if (exclusive) {
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ oids.get(uid).get(options[i])+ ""String_Node_Str"";
      HTMLString+=replaceSpecialCharacters(options[i]);
    }
  }
 else {
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ oids.get(uid).get(options[i])+ ""String_Node_Str"";
      HTMLString+=replaceSpecialCharacters(options[i]);
    }
  }
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  return HTMLString;
}","static String generateHTMLQuestion(int uid,String text,String resource,String[] options,boolean exclusive,boolean ordered,boolean perturb){
  String HTMLString=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str"";
  HTMLString+=replaceSpecialCharacters(text);
  if (!resource.equals(""String_Node_Str"")) {
    if (resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"")|| resource.contains(""String_Node_Str"")) {
      HTMLString+=""String_Node_Str"" + resource + ""String_Node_Str"";
    }
 else     if (resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"")|| resource.contains(""String_Node_Str"")) {
      HTMLString+=""String_Node_Str"" + resource + ""String_Node_Str"";
    }
  }
  HTMLString+=""String_Node_Str"";
  if (options.length > 10) {
    HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str"";
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ oids.get(uid).get(options[i])+ ""String_Node_Str""+ replaceSpecialCharacters(options[i])+ ""String_Node_Str"";
    }
    HTMLString+=""String_Node_Str"";
  }
 else   if (exclusive) {
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ oids.get(uid).get(options[i])+ ""String_Node_Str"";
      HTMLString+=replaceSpecialCharacters(options[i]);
    }
  }
 else {
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ oids.get(uid).get(options[i])+ ""String_Node_Str"";
      HTMLString+=replaceSpecialCharacters(options[i]);
    }
  }
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  return HTMLString;
}",0.962253829321663
109991,"static void generateSurvey(ArrayList<String[]> questions,String preview,int numSurveys){
  int count=0;
  for (  String[] question : questions) {
    count++;
    identifiers.put(question,count);
    qs.put(count,question);
  }
  for (int ind=0; ind < numSurveys; ind++) {
    try {
      PrintWriter out;
      File file;
      if (ind + 1 < 10) {
        file=new File(""String_Node_Str"" + (ind + 1) + ""String_Node_Str"");
      }
 else {
        file=new File(""String_Node_Str"" + (ind + 1) + ""String_Node_Str"");
      }
      file.getParentFile().mkdirs();
      out=new PrintWriter(new FileWriter(file));
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(preview);
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      questions=randomize(questions);
      for (      String[] question : questions) {
        out.println(generateQuestion(identifiers.get(question),question));
      }
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.flush();
    }
 catch (    java.io.IOException e) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
  }
  runScript(""String_Node_Str"",""String_Node_Str"");
  boolean resultsNotIn=true;
  try {
    while (resultsNotIn) {
      Thread.sleep(2 * 60000);
      runScript(""String_Node_Str"",""String_Node_Str"");
      if (surveyIsComplete()) {
        resultsNotIn=false;
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  java.lang.InterruptedException e) {
    e.printStackTrace();
  }
  return;
}","static void generateSurvey(ArrayList<String[]> questions,String preview,int numSurveys){
  int count=0;
  for (  String[] question : questions) {
    count++;
    identifiers.put(question,count);
    qs.put(count,question);
  }
  for (int ind=0; ind < numSurveys; ind++) {
    try {
      PrintWriter out;
      File file;
      if (ind + 1 < 10) {
        file=new File(""String_Node_Str"" + (ind + 1) + ""String_Node_Str"");
      }
 else {
        file=new File(""String_Node_Str"" + (ind + 1) + ""String_Node_Str"");
      }
      file.getParentFile().mkdirs();
      out=new PrintWriter(new FileWriter(file));
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(preview);
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      questions=randomize(questions);
      for (      String[] question : questions) {
        out.println(generateQuestion(identifiers.get(question),question));
      }
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"");
      out.flush();
    }
 catch (    java.io.IOException e) {
      System.out.println(""String_Node_Str"");
      System.exit(0);
    }
  }
  runScript(""String_Node_Str"",""String_Node_Str"");
  boolean resultsNotIn=true;
  try {
    while (resultsNotIn) {
      Thread.sleep(2 * 60000);
      runScript(""String_Node_Str"",""String_Node_Str"");
      if (surveyIsComplete()) {
        resultsNotIn=false;
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
    runScript(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  java.lang.InterruptedException e) {
    e.printStackTrace();
  }
  return;
}",0.9933571793561574
109992,"static boolean parseResults(){
  try {
    String resultsFile=""String_Node_Str"";
    Scanner scan=new Scanner(new File(resultsFile));
    String[] headers=scan.nextLine().split(""String_Node_Str"");
    int assignCol=0, completeCol=0, pendCol=0;
    List<Integer> answerCols=new ArrayList<Integer>();
    Map<Integer,String> columnToQuestion=new HashMap<Integer,String>();
    Map<Integer,String> results=new HashMap<Integer,String>();
    int quid=0;
    for (int i=0; i < headers.length; i++) {
      if (headers[i].equals(""String_Node_Str"")) {
        assignCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        pendCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        completeCol=i;
      }
      if (headers[i].contains(""String_Node_Str"") && !(headers[i].contains(""String_Node_Str""))) {
        answerCols.add(i);
        columnToQuestion.put(i,headers[i].substring(headers[i].lastIndexOf(""String_Node_Str"") + 2).replace(""String_Node_Str"",""String_Node_Str""));
        quid=Integer.parseInt(columnToQuestion.get(i));
        String[] question=qs.get(quid);
        String s=question[2].substring(question[2].lastIndexOf(""String_Node_Str"") + 1) + ""String_Node_Str"";
        results.put(quid,s);
      }
    }
    System.out.print(results);
    int numAvailable=0;
    int numComplete=0;
    int numPending=0;
    Map<Integer,String> optionMap;
    int oid=0;
    Map<Integer,Double> ratings=new HashMap<Integer,Double>();
    while (scan.hasNextLine()) {
      String line=scan.nextLine();
      String[] hitArray=line.split(""String_Node_Str"");
      try {
        numAvailable=Integer.parseInt(hitArray[assignCol].replace(""String_Node_Str"",""String_Node_Str""));
        numPending=Integer.parseInt(hitArray[pendCol].replace(""String_Node_Str"",""String_Node_Str""));
        numComplete=Integer.parseInt(hitArray[completeCol].replace(""String_Node_Str"",""String_Node_Str""));
        if (numAvailable > 0 || numPending > 0) {
          for (          int qid : results.keySet()) {
            results.put(qid,results.get(qid) + ratings.get(qid));
          }
          System.out.println(results);
          PrintWriter out=new PrintWriter(new FileWriter(""String_Node_Str""));
          out.println(""String_Node_Str"");
          for (          int qid : results.keySet()) {
            out.println(results.get(qid));
          }
          out.flush();
          out.close();
          return false;
        }
      }
 catch (      java.lang.NumberFormatException e) {
        e.printStackTrace();
      }
      for (      int answerCol : answerCols) {
        quid=Integer.parseInt(columnToQuestion.get(answerCol));
        oid=Integer.parseInt(hitArray[answerCol].substring(hitArray[answerCol].lastIndexOf(""String_Node_Str"") + 1).replace(""String_Node_Str"",""String_Node_Str""));
        String questionLine=results.get(quid);
        questionLine+=(opts.get(quid).get(oid) + ""String_Node_Str"");
        results.put(quid,questionLine);
        if (!ratings.containsKey(quid)) {
          ratings.put(quid,(double)oid);
        }
 else {
          ratings.put(quid,((double)oid + ratings.get(quid)) / 2.0);
        }
      }
    }
    System.out.println(ratings);
    for (    int qid : results.keySet()) {
      results.put(qid,results.get(qid) + ratings.get(qid));
    }
    System.out.println(results);
    PrintWriter out=new PrintWriter(new FileWriter(""String_Node_Str""));
    out.println(""String_Node_Str"");
    for (    int qid : results.keySet()) {
      out.println(results.get(qid));
    }
    out.flush();
    out.close();
  }
 catch (  java.io.IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  return true;
}","static boolean parseResults(){
  boolean complete=true;
  try {
    String resultsFile=""String_Node_Str"";
    Scanner scan=new Scanner(new File(resultsFile));
    String[] headers=scan.nextLine().split(""String_Node_Str"");
    int assignCol=0, completeCol=0, pendCol=0;
    List<Integer> answerCols=new ArrayList<Integer>();
    Map<Integer,String> columnToQuestion=new HashMap<Integer,String>();
    Map<Integer,String> results=new HashMap<Integer,String>();
    int quid=0;
    for (int i=0; i < headers.length; i++) {
      if (headers[i].equals(""String_Node_Str"")) {
        assignCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        pendCol=i;
      }
      if (headers[i].equals(""String_Node_Str"")) {
        completeCol=i;
      }
      if (headers[i].contains(""String_Node_Str"") && !(headers[i].contains(""String_Node_Str""))) {
        answerCols.add(i);
        columnToQuestion.put(i,headers[i].substring(headers[i].lastIndexOf(""String_Node_Str"") + 2).replace(""String_Node_Str"",""String_Node_Str""));
        quid=Integer.parseInt(columnToQuestion.get(i));
        String[] question=qs.get(quid);
        String s=question[2].substring(question[2].lastIndexOf(""String_Node_Str"") + 1) + ""String_Node_Str"";
        results.put(quid,s);
      }
    }
    System.out.print(results);
    int numAvailable=0;
    int numComplete=0;
    int numPending=0;
    Map<Integer,String> optionMap;
    int oid=0;
    Map<Integer,Double> ratings=new HashMap<Integer,Double>();
    while (scan.hasNextLine()) {
      String line=scan.nextLine();
      String[] hitArray=line.split(""String_Node_Str"");
      try {
        numAvailable=Integer.parseInt(hitArray[assignCol].replace(""String_Node_Str"",""String_Node_Str""));
        numPending=Integer.parseInt(hitArray[pendCol].replace(""String_Node_Str"",""String_Node_Str""));
        numComplete=Integer.parseInt(hitArray[completeCol].replace(""String_Node_Str"",""String_Node_Str""));
        if (numAvailable > 0 || numPending > 0) {
          complete=false;
        }
      }
 catch (      java.lang.NumberFormatException e) {
        e.printStackTrace();
      }
      for (      int answerCol : answerCols) {
        quid=Integer.parseInt(columnToQuestion.get(answerCol));
        if (hitArray.length >= answerCol + 1) {
          oid=Integer.parseInt(hitArray[answerCol].substring(hitArray[answerCol].lastIndexOf(""String_Node_Str"") + 1).replace(""String_Node_Str"",""String_Node_Str""));
          String questionLine=results.get(quid);
          questionLine+=(opts.get(quid).get(oid) + ""String_Node_Str"");
          results.put(quid,questionLine);
          if (!ratings.containsKey(quid)) {
            ratings.put(quid,(double)oid);
          }
 else {
            ratings.put(quid,((double)oid + ratings.get(quid)) / 2.0);
          }
        }
      }
    }
    System.out.println(ratings);
    for (    int qid : results.keySet()) {
      results.put(qid,results.get(qid) + ratings.get(qid));
    }
    System.out.println(results);
    PrintWriter out=new PrintWriter(new FileWriter(""String_Node_Str""));
    out.println(""String_Node_Str"");
    for (    int qid : results.keySet()) {
      out.println(results.get(qid));
    }
    out.flush();
    out.close();
  }
 catch (  java.io.IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  return complete;
}",0.9184805804524114
109993,"public static void main(String[] args){
  String fileContents=""String_Node_Str"";
  String[] lines;
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  parser csvParser=new parser();
  try {
    fileContents=csvParser.readFile(args[0]);
  }
 catch (  java.io.FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
  lines=csvParser.split(fileContents);
  for (int i=0; i < lines.length; i++) {
    for (    String s : csvParser.parse(lines[i])) {
      System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
    }
  }
}","public static void main(String[] args){
  String fileContents=""String_Node_Str"";
  String[] lines;
  if (args.length == 0) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  parser csvParser=new parser();
  try {
    fileContents=csvParser.readFile(args[0]);
  }
 catch (  java.io.FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
  }
  lines=csvParser.split(fileContents);
  for (int i=0; i < lines.length; i++) {
    System.out.println(""String_Node_Str"" + lines[i]);
    for (    String s : csvParser.parse(lines[i])) {
      System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
    }
  }
}",0.9560975609756096
109994,"public String[] parse(String csv){
  matcher=csvPattern.matcher(csv);
  allMatches.clear();
  String match;
  while (matcher.find()) {
    match=matcher.group(1);
    if (matcher.group(1) != null) {
      allMatches.add(match);
    }
 else     if (matcher.group(2) != null) {
      allMatches.add(matcher.group(2));
    }
 else     if (matcher.group(3) != null) {
      allMatches.add(matcher.group(3));
    }
 else {
      allMatches.add(matcher.group(4).replace(""String_Node_Str"",""String_Node_Str""));
    }
  }
  size=allMatches.size();
  if (size > 0) {
    return allMatches.toArray(new String[size]);
  }
 else {
    return new String[0];
  }
}","public String[] parse(String csv){
  matcher=csvPattern.matcher(csv);
  allMatches.clear();
  String match;
  while (matcher.find()) {
    match=matcher.group(1);
    if (matcher.group(1) != null) {
      allMatches.add(match);
    }
 else     if (matcher.group(2) != null) {
      allMatches.add(matcher.group(2));
    }
 else     if (matcher.group(3) != null) {
      allMatches.add(matcher.group(3));
    }
 else {
      allMatches.add(matcher.group(4));
    }
  }
  size=allMatches.size();
  if (size > 0) {
    return allMatches.toArray(new String[size]);
  }
 else {
    return new String[0];
  }
}",0.9640861931364724
109995,"static String generateScaleQuestion(int uid,String text,String resource,String[] options,boolean exclusive,boolean ordered,boolean perturb){
  String HTMLString=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str"";
  HTMLString+=text;
  if (!resource.equals(""String_Node_Str"")) {
    if (resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"")|| resource.contains(""String_Node_Str"")) {
      HTMLString+=""String_Node_Str"" + resource + ""String_Node_Str"";
    }
 else     if (resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"")|| resource.contains(""String_Node_Str"")) {
      HTMLString+=""String_Node_Str"" + resource + ""String_Node_Str"";
    }
  }
  HTMLString+=""String_Node_Str"";
  if (options.length > 10) {
    HTMLString+=""String_Node_Str"";
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + options[i] + ""String_Node_Str"";
    }
    HTMLString+=""String_Node_Str"";
  }
 else   if (exclusive) {
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ Integer.toString(i)+ ""String_Node_Str"";
      HTMLString+=options[i];
    }
  }
 else {
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ Integer.toString(i)+ ""String_Node_Str"";
      HTMLString+=options[i];
    }
  }
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  return HTMLString;
}","static String generateScaleQuestion(int uid,String text,String resource,String[] options,boolean exclusive,boolean ordered,boolean perturb){
  String HTMLString=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str"";
  HTMLString+=text;
  if (!resource.equals(""String_Node_Str"")) {
    if (resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"")|| resource.contains(""String_Node_Str"")) {
      HTMLString+=""String_Node_Str"" + resource + ""String_Node_Str"";
    }
 else     if (resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"") || resource.contains(""String_Node_Str"")|| resource.contains(""String_Node_Str"")) {
      HTMLString+=""String_Node_Str"" + resource + ""String_Node_Str"";
    }
  }
  HTMLString+=""String_Node_Str"";
  if (options.length > 10) {
    HTMLString+=""String_Node_Str"";
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + options[i] + ""String_Node_Str"";
    }
    HTMLString+=""String_Node_Str"";
  }
 else   if (exclusive) {
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ Integer.toString(i)+ ""String_Node_Str"";
      HTMLString+=options[i];
    }
  }
 else {
    for (int i=0; i < options.length; i++) {
      HTMLString+=""String_Node_Str"" + Integer.toString(uid) + ""String_Node_Str""+ Integer.toString(i)+ ""String_Node_Str"";
      HTMLString+=options[i];
    }
  }
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  HTMLString+=""String_Node_Str"";
  return HTMLString;
}",0.9851968503937008
109996,"static void generateSurvey(ArrayList<String[]> questions){
  try {
    PrintWriter out=new PrintWriter(new FileWriter(""String_Node_Str""));
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    int count=0;
    questions=randomize(questions);
    for (    String[] question : questions) {
      count++;
      out.println(generateQuestion(count,question));
    }
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.flush();
  }
 catch (  java.io.IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  return;
}","static void generateSurvey(ArrayList<String[]> questions){
  try {
    PrintWriter out=new PrintWriter(new FileWriter(""String_Node_Str""));
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    int count=0;
    questions=randomize(questions);
    for (    String[] question : questions) {
      count++;
      out.println(generateQuestion(count,question));
    }
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.flush();
  }
 catch (  java.io.IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  return;
}",0.9746121297602256
109997,"public int[] getCheckedMusicsSortedByTime(){
  Object[] objs=Utils.getSortedKeyOfTimeMap(mCheckedMap);
  int[] poss=new int[objs.length];
  for (int i=0; i < poss.length; i++)   poss[i]=(int)(long)objs[i];
  return poss;
}","public int[] getCheckedMusicsSortedByTime(){
  Object[] objs=Utils.getSortedKeyOfTimeMap(mCheckedMap);
  int[] poss=new int[objs.length];
  for (int i=0; i < poss.length; i++)   poss[i]=(int)objs[i];
  return poss;
}",0.9863013698630136
109998,"private void appendCheckMusicsToPlayQ(){
  YTVideoSearchAdapter adpr=getAdapter();
  int[] checkedItems=adpr.getCheckItemSortedByTime();
  YTPlayer.Video[] vids=new YTPlayer.Video[checkedItems.length];
  int j=0;
  for (  int i : checkedItems) {
    vids[j++]=adpr.getYTPlayerVideo(i);
  }
  appendToPlayQ(vids);
  adpr.cleanChecked();
}","private void appendCheckMusicsToPlayQ(){
  YTVideoSearchAdapter adpr=getAdapter();
  int[] checkedItems=adpr.getCheckItemSortedByTime();
  YTPlayer.Video[] vids=new YTPlayer.Video[checkedItems.length];
  int j=0;
  for (  int i : checkedItems)   vids[j++]=adpr.getYTPlayerVideo(i);
  appendToPlayQ(vids);
  adpr.cleanChecked();
}",0.8558558558558559
109999,"public int[] getCheckItemSortedByTime(){
  Object[] objs=Utils.getSortedKeyOfTimeMap(mCheckedMap);
  int[] poss=new int[objs.length];
  for (int i=0; i < poss.length; i++)   poss[i]=(int)(long)objs[i];
  return poss;
}","public int[] getCheckItemSortedByTime(){
  Object[] objs=Utils.getSortedKeyOfTimeMap(mCheckedMap);
  int[] poss=new int[objs.length];
  for (int i=0; i < poss.length; i++)   poss[i]=(int)objs[i];
  return poss;
}",0.986046511627907
110000,"private static YtVideoHtmlResult parseYtVideoHtml(BufferedReader brdr) throws LocalException {
  String htmlText=""String_Node_Str"";
  YtVideoHtmlResult result=new YtVideoHtmlResult();
  String line=""String_Node_Str"";
  while (null != line) {
    try {
      line=brdr.readLine();
    }
 catch (    IOException e) {
      throw new LocalException(Err.IO_NET);
    }
    if (null == line)     break;
    htmlText+=line + ""String_Node_Str"";
    if (line.contains(""String_Node_Str"")) {
      result.playable=false;
      if (DBG)       P.v(""String_Node_Str"");
      break;
    }
 else     if (line.contains(""String_Node_Str"")) {
      Matcher m=sYtUrlGenerate204Pattern.matcher(line);
      if (m.matches()) {
        line=m.group(1);
        line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        result.generate_204_url=line;
      }
    }
 else     if (line.contains(""String_Node_Str"")) {
      Matcher m=sYtUrlStreamMapPattern.matcher(line);
      if (m.matches()) {
        line=m.group(1);
        String[] vidElemUrls=line.split(""String_Node_Str"");
        ArrayList<YtVideoElem> al=new ArrayList<>(vidElemUrls.length);
        for (        String s : vidElemUrls) {
          YtVideoElem ve=YtVideoElem.parse(s);
          if (null != ve)           al.add(ve);
        }
        result.vids=al.toArray(new YtVideoElem[al.size()]);
      }
    }
  }
  if (DBG)   P.v(htmlText);
  result.tmstamp=System.currentTimeMillis();
  return result;
}","private static YtVideoHtmlResult parseYtVideoHtml(BufferedReader brdr) throws LocalException {
  String htmlText=""String_Node_Str"";
  YtVideoHtmlResult result=new YtVideoHtmlResult();
  String line=""String_Node_Str"";
  while (null != line) {
    try {
      line=brdr.readLine();
    }
 catch (    IOException e) {
      throw new LocalException(Err.IO_NET);
    }
    if (null == line)     break;
    htmlText+=line + ""String_Node_Str"";
    if (line.contains(""String_Node_Str"")) {
      ;
    }
 else     if (line.contains(""String_Node_Str"")) {
      Matcher m=sYtUrlGenerate204Pattern.matcher(line);
      if (m.matches()) {
        line=m.group(1);
        line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        result.generate_204_url=line;
      }
    }
 else     if (line.contains(""String_Node_Str"")) {
      Matcher m=sYtUrlStreamMapPattern.matcher(line);
      if (m.matches()) {
        line=m.group(1);
        String[] vidElemUrls=line.split(""String_Node_Str"");
        ArrayList<YtVideoElem> al=new ArrayList<>(vidElemUrls.length);
        for (        String s : vidElemUrls) {
          YtVideoElem ve=YtVideoElem.parse(s);
          if (null != ve)           al.add(ve);
        }
        result.vids=al.toArray(new YtVideoElem[al.size()]);
      }
    }
  }
  if (DBG)   P.v(htmlText);
  result.tmstamp=System.currentTimeMillis();
  return result;
}",0.9733737782271656
