record_number,buggy_code,fixed_code,code_similarity
26001,"/** 
 * Fetches a default set of filtered items for the application with the given id.
 * @param applicationId The id of the parent application.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object getForApplication(long applicationId,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.ItemRequest.Result> parser=new ItemParser<com.podio.sdk.domain.ItemRequest.Result>(com.podio.sdk.domain.ItemRequest.Result.class);
  client.setItemParser(parser);
  ItemProvider provider=new ItemProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.fetchItemsForApplication(applicationId);
}","/** 
 * Fetches a default set of filtered items for the application with the given id.
 * @param applicationId The id of the parent application.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object getForApplication(long applicationId,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.ItemRequest.Result> parser=new ItemParser<com.podio.sdk.domain.ItemRequest.Result>(com.podio.sdk.domain.ItemRequest.Result.class);
  ItemProvider provider=new ItemProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  provider.setItemParser(parser);
  return provider.fetchItemsForApplication(applicationId);
}",0.8985849056603774
26002,"/** 
 * Fetches a single item with the given id.
 * @param itemId The id of the item to fetch.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object get(long itemId,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Item> parser=new ItemParser<com.podio.sdk.domain.Item>(com.podio.sdk.domain.Item.class);
  client.setItemParser(parser);
  ItemProvider provider=new ItemProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.fetchItem(itemId);
}","/** 
 * Fetches a single item with the given id.
 * @param itemId The id of the item to fetch.
 * @param providerListener The callback implementation called when the items are fetched. Null is valid, but doesn't make any sense.
 * @return A ticket which the caller can use to identify this requestwith.
 */
public static final Object get(long itemId,PodioProviderListener providerListener){
  ItemParser<com.podio.sdk.domain.Item> parser=new ItemParser<com.podio.sdk.domain.Item>(com.podio.sdk.domain.Item.class);
  ItemProvider provider=new ItemProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  provider.setItemParser(parser);
  return provider.fetchItem(itemId);
}",0.9102384291725104
26003,"/** 
 * Revokes a previously created Podio session. Even though the access token may have expired, the refresh token can be used to get a new access token. The idea here is to enable the caller to persist the session and avoid an unnecessary re-authentication. NOTE! The server may very well invalidate both the access and refresh tokens, which would require a re-authentication anyway.
 * @param session The previously stored session object.
 */
public static final void restoreSession(Session session){
  client.setItemParser(null);
  client.restoreSession(SessionFilter.PATH,session);
}","/** 
 * Revokes a previously created Podio session. Even though the access token may have expired, the refresh token can be used to get a new access token. The idea here is to enable the caller to persist the session and avoid an unnecessary re-authentication. NOTE! The server may very well invalidate both the access and refresh tokens, which would require a re-authentication anyway.
 * @param session The previously stored session object.
 */
public static final void restoreSession(Session session){
  client.restoreSession(SessionFilter.PATH,session);
}",0.9738675958188152
26004,"public RestResult post(Uri uri,Object item);","public RestResult post(Uri uri,Object item,ItemParser<?> parser);",0.8073394495412844
26005,public RestResult get(Uri uri);,"public RestResult get(Uri uri,ItemParser<?> parser);",0.7469879518072289
26006,public RestResult authorize(Uri uri);,"public RestResult authorize(Uri uri,ItemParser<?> parser);",0.7789473684210526
26007,public RestResult delete(Uri uri);,"public RestResult delete(Uri uri,ItemParser<?> parser);",0.7640449438202247
26008,"public RestResult put(Uri uri,Object item);","public RestResult put(Uri uri,Object item,ItemParser<?> parser);",0.8037383177570093
26009,"/** 
 * Lets the assigned   {@link RestClientDelegate} implementation act upon theunderlying content as requested per operation and Uri.
 * @param operation The operation to perform.
 * @param uri The key used to identify the content.
 * @param item The description of the new content.
 * @return The result description of the requested operation.
 */
private RestResult delegate(RestOperation operation,Uri uri,Object item){
switch (operation) {
case DELETE:
    return databaseDelegate.delete(uri);
case GET:
  return databaseDelegate.get(uri);
case POST:
return databaseDelegate.post(uri,item);
case PUT:
return databaseDelegate.put(uri,item);
default :
String message=""String_Node_Str"" + operation.name();
return new RestResult(false,message,null);
}
}","/** 
 * Lets the assigned   {@link RestClientDelegate} implementation act upon theunderlying content as requested per operation and Uri.
 * @param operation The operation to perform.
 * @param uri The key used to identify the content.
 * @param item The description of the new content.
 * @return The result description of the requested operation.
 */
private RestResult delegate(RestOperation operation,Uri uri,Object item,ItemParser<?> itemParser){
switch (operation) {
case DELETE:
    return databaseDelegate.delete(uri,itemParser);
case GET:
  return databaseDelegate.get(uri,itemParser);
case POST:
return databaseDelegate.post(uri,item,itemParser);
case PUT:
return databaseDelegate.put(uri,item,itemParser);
default :
String message=""String_Node_Str"" + operation.name();
return new RestResult(false,message,null);
}
}",0.9563567362428842
26010,"/** 
 * Performs a custom rest request flow, by - generally speaking - allowing all requests to be handled by the super network client implementation first. When the super implementation delivers a result, that result is stored by this implementation in a local database. The stored data is then requested immediately after and returned to the caller. One exception from the above flow is the GET rest requests, which actually return the cached content first and then re-posts the same request to be handled by the network client as well according to the above pattern.
 * @see com.podio.sdk.client.HttpRestClient#handleRequest(com.podio.sdk.client.RestRequest)
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    RestOperation operation=restRequest.getOperation();
    PodioFilter filter=restRequest.getFilter();
    Object item=restRequest.getContent();
    Uri uri=filter.buildUri(contentScheme,authority);
    if (Utils.notEmpty(uri)) {
      if (operation == RestOperation.GET && !delegatedRequests.contains(restRequest)) {
        result=delegate(operation,uri,item);
        delegatedRequests.add(restRequest);
        super.enqueue(restRequest);
      }
 else {
        delegatedRequests.remove(restRequest);
        result=super.handleRequest(restRequest);
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          if (operation == RestOperation.GET) {
            result=delegate(RestOperation.POST,uri,result.item());
          }
 else {
            result=delegate(operation,uri,result.item());
          }
        }
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          result=delegate(RestOperation.GET,uri,null);
        }
      }
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}","/** 
 * Performs a custom rest request flow, by - generally speaking - allowing all requests to be handled by the super network client implementation first. When the super implementation delivers a result, that result is stored by this implementation in a local database. The stored data is then requested immediately after and returned to the caller. One exception from the above flow is the GET rest requests, which actually return the cached content first and then re-posts the same request to be handled by the network client as well according to the above pattern.
 * @see com.podio.sdk.client.HttpRestClient#handleRequest(com.podio.sdk.client.RestRequest)
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    RestOperation operation=restRequest.getOperation();
    PodioFilter filter=restRequest.getFilter();
    ItemParser<?> itemParser=restRequest.getItemParser();
    Object item=restRequest.getContent();
    Uri uri=filter.buildUri(contentScheme,authority);
    if (Utils.notEmpty(uri)) {
      if (operation != RestOperation.DELETE && operation != RestOperation.PUT && operation != RestOperation.AUTHORIZE && !delegatedRequests.contains(restRequest)) {
        result=delegate(operation,uri,item,itemParser);
        delegatedRequests.add(restRequest);
        super.enqueue(restRequest);
      }
 else {
        delegatedRequests.remove(restRequest);
        result=super.handleRequest(restRequest);
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          if (operation == RestOperation.GET) {
            result=delegate(RestOperation.POST,uri,result.item(),itemParser);
          }
 else {
            result=delegate(operation,uri,result.item(),itemParser);
          }
          if (result.isSuccess()) {
            result=delegate(RestOperation.GET,uri,null,itemParser);
          }
        }
      }
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}",0.7770601911650736
26011,"/** 
 * {@inheritDoc}
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    PodioFilter filter=restRequest.getFilter();
    if (filter != null) {
      RestOperation operation=restRequest.getOperation();
      Object item=restRequest.getContent();
      Uri uri=filter.buildUri(scheme,authority);
      result=queryNetwork(operation,uri,item);
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}","/** 
 * {@inheritDoc}
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    PodioFilter filter=restRequest.getFilter();
    if (filter != null) {
      Uri uri=filter.buildUri(scheme,authority);
      RestOperation operation=restRequest.getOperation();
      Object item=restRequest.getContent();
      ItemParser<?> parser=restRequest.getItemParser();
      result=queryNetwork(operation,uri,item,parser);
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}",0.8718428437792329
26012,"private RestResult queryNetwork(RestOperation operation,Uri uri,Object item){
switch (operation) {
case AUTHORIZE:
    return networkDelegate.authorize(uri);
case DELETE:
  return networkDelegate.delete(uri);
case GET:
return networkDelegate.get(uri);
case POST:
return networkDelegate.post(uri,item);
case PUT:
return networkDelegate.put(uri,item);
default :
String message=""String_Node_Str"" + operation.name();
return new RestResult(false,message,null);
}
}","private RestResult queryNetwork(RestOperation operation,Uri uri,Object item,ItemParser<?> parser){
switch (operation) {
case AUTHORIZE:
    return networkDelegate.authorize(uri,parser);
case DELETE:
  return networkDelegate.delete(uri,parser);
case GET:
return networkDelegate.get(uri,parser);
case POST:
return networkDelegate.post(uri,item,parser);
case PUT:
return networkDelegate.put(uri,item,parser);
default :
String message=""String_Node_Str"" + operation.name();
return new RestResult(false,message,null);
}
}",0.942505133470226
26013,"/** 
 * Delegates the requested operation to the   {@link DatabaseClientDelegate}to execute.
 * @param operation The type of rest operation to perform.
 * @param uri The URI that defines the details of the operation.
 * @param content Any additional data that the operation refers to.
 * @return An object representation of the result of the operation.
 */
private RestResult queryDatabase(RestOperation operation,Uri uri,Object content){
switch (operation) {
case AUTHORIZE:
    return databaseDelegate.authorize(uri);
case DELETE:
  return databaseDelegate.delete(uri);
case GET:
return databaseDelegate.get(uri);
case POST:
return databaseDelegate.post(uri,content);
case PUT:
return databaseDelegate.put(uri,content);
default :
String message=""String_Node_Str"" + operation.name();
return new RestResult(false,message,null);
}
}","/** 
 * Delegates the requested operation to the   {@link DatabaseClientDelegate}to execute.
 * @param operation The type of rest operation to perform.
 * @param uri The URI that defines the details of the operation.
 * @param content Any additional data that the operation refers to.
 * @return An object representation of the result of the operation.
 */
private RestResult queryDatabase(RestOperation operation,Uri uri,Object content,ItemParser<?> itemParser){
switch (operation) {
case AUTHORIZE:
    return databaseDelegate.authorize(uri,itemParser);
case DELETE:
  return databaseDelegate.delete(uri,itemParser);
case GET:
return databaseDelegate.get(uri,itemParser);
case POST:
return databaseDelegate.post(uri,content,itemParser);
case PUT:
return databaseDelegate.put(uri,content,itemParser);
default :
String message=""String_Node_Str"" + operation.name();
return new RestResult(false,message,null);
}
}",0.9540757749712974
26014,"/** 
 * {@inheritDoc}
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    PodioFilter filter=restRequest.getFilter();
    if (filter != null) {
      RestOperation operation=restRequest.getOperation();
      Object item=restRequest.getContent();
      Uri uri=filter.buildUri(scheme,authority);
      result=queryDatabase(operation,uri,item);
    }
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    PodioFilter filter=restRequest.getFilter();
    ItemParser<?> itemParser=restRequest.getItemParser();
    if (filter != null) {
      RestOperation operation=restRequest.getOperation();
      Object item=restRequest.getContent();
      Uri uri=filter.buildUri(scheme,authority);
      result=queryDatabase(operation,uri,item,itemParser);
    }
  }
  return result;
}",0.9292307692307692
26015,"public Object fetchItemsForApplication(long applicationId){
  PodioParser<Item> parser=new PodioParser<Item>(Item.class);
  ItemFilter filter=new ItemFilter().withApplicationId(applicationId);
  ItemRequest filterRequest=new ItemRequest(null,null,null,null,null,null);
  return pushRequest(filter,filterRequest,parser);
}","public Object fetchItemsForApplication(long applicationId){
  PodioParser<ItemRequest.Result> parser=new PodioParser<ItemRequest.Result>(ItemRequest.Result.class);
  ItemFilter filter=new ItemFilter().withApplicationId(applicationId);
  ItemRequest filterRequest=new ItemRequest(null,null,null,null,null,null);
  return pushRequest(filter,filterRequest,parser);
}",0.9385964912280702
26016,"@Override public RestResult get(Uri uri,Class<?> classOfResult){
  String json=null;
  SQLiteDatabase database=openDatabase(uri);
  if (database != null) {
    String[] projection={""String_Node_Str""};
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    Cursor cursor=database.query(""String_Node_Str"",projection,key,value,null,null,null);
    if (cursor != null) {
      json=cursor.moveToFirst() ? cursor.getString(0) : ""String_Node_Str"";
    }
  }
  boolean isSuccess=json != null;
  String message=null;
  Object item=jsonToItemParser.parse(json,classOfResult);
  RestResult result=new RestResult(isSuccess,message,item);
  return result;
}","@Override public RestResult get(Uri uri,Class<?> classOfResult){
  String json=null;
  SQLiteDatabase database=openDatabase(uri);
  if (database != null) {
    String[] projection={""String_Node_Str""};
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    Cursor cursor=database.query(""String_Node_Str"",projection,key,value,null,null,null);
    if (cursor != null) {
      json=cursor.moveToFirst() ? cursor.getString(0) : null;
    }
  }
  boolean isSuccess=json != null;
  String message=null;
  Object item=jsonToItemParser.parse(json,classOfResult);
  RestResult result=new RestResult(isSuccess,message,item);
  return result;
}",0.9840546697038725
26017,"/** 
 * Performs a custom rest request flow, by - generally speaking - allowing all requests to be handled by the super network client implementation first. When the super implementation delivers a result, that result is stored by this implementation in a local database. The stored data is then requested immediately after and returned to the caller. One exception from the above flow is the GET rest requests, which actually return the cached content first and then re-posts the same request to be handled by the network client as well according to the above pattern.
 * @see com.podio.sdk.client.HttpRestClient#handleRequest(com.podio.sdk.client.RestRequest)
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    RestOperation operation=restRequest.getOperation();
    Filter filter=restRequest.getFilter();
    Object item=restRequest.getContent();
    Uri uri=filter.buildUri(contentScheme,authority);
    if (Utils.notEmpty(uri)) {
      if (operation == RestOperation.GET && !delegatedRequests.contains(restRequest)) {
        result=delegate(operation,uri,item);
        delegatedRequests.add(restRequest);
        super.enqueue(restRequest);
      }
 else {
        delegatedRequests.remove(restRequest);
        result=super.handleRequest(restRequest);
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          if (operation == RestOperation.GET) {
            result=delegate(RestOperation.POST,uri,item);
          }
 else {
            result=delegate(operation,uri,item);
          }
        }
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          result=delegate(RestOperation.GET,uri,item);
        }
      }
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}","/** 
 * Performs a custom rest request flow, by - generally speaking - allowing all requests to be handled by the super network client implementation first. When the super implementation delivers a result, that result is stored by this implementation in a local database. The stored data is then requested immediately after and returned to the caller. One exception from the above flow is the GET rest requests, which actually return the cached content first and then re-posts the same request to be handled by the network client as well according to the above pattern.
 * @see com.podio.sdk.client.HttpRestClient#handleRequest(com.podio.sdk.client.RestRequest)
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    RestOperation operation=restRequest.getOperation();
    Filter filter=restRequest.getFilter();
    Object item=restRequest.getContent();
    Uri uri=filter.buildUri(contentScheme,authority);
    if (Utils.notEmpty(uri)) {
      if (operation == RestOperation.GET && !delegatedRequests.contains(restRequest)) {
        result=delegate(operation,uri,item);
        delegatedRequests.add(restRequest);
        super.enqueue(restRequest);
      }
 else {
        delegatedRequests.remove(restRequest);
        result=super.handleRequest(restRequest);
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          if (operation == RestOperation.GET) {
            result=delegate(RestOperation.POST,uri,result.item());
          }
 else {
            result=delegate(operation,uri,result.item());
          }
        }
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          result=delegate(RestOperation.GET,uri,null);
        }
      }
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}",0.9886425094645754
26018,"@Override public RestResult get(Uri uri) throws InvalidParserException {
  ItemParser.raiseExceptionIfInvalidInstance(itemParser);
  String json=null;
  SQLiteDatabase database=openDatabase(uri);
  if (database != null) {
    String[] projection={""String_Node_Str""};
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    Cursor cursor=database.query(""String_Node_Str"",projection,key,value,null,null,null);
    if (cursor != null) {
      json=cursor.moveToFirst() ? cursor.getString(0) : null;
    }
  }
  boolean isSuccess=json != null;
  String message=null;
  Object item=itemParser.parseToItem(json);
  RestResult result=new RestResult(isSuccess,message,item);
  return result;
}","@Override public RestResult get(Uri uri) throws InvalidParserException {
  ItemParser.raiseExceptionIfInvalidInstance(itemParser);
  String json=null;
  SQLiteDatabase database=openDatabase(uri);
  if (database != null) {
    String[] projection={""String_Node_Str""};
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    Cursor cursor=database.query(""String_Node_Str"",projection,key,value,null,null,null);
    if (cursor != null) {
      json=cursor.moveToFirst() ? cursor.getString(0) : ""String_Node_Str"";
    }
  }
  boolean isSuccess=json != null;
  String message=null;
  Object item=itemParser.parseToItem(json);
  RestResult result=new RestResult(isSuccess,message,item);
  return result;
}",0.9852216748768472
26019,"private String request(int method,Uri uri,String body){
  String url=Utils.notEmpty(uri) ? uri.toString() : null;
  RequestFuture<String> future=RequestFuture.newFuture();
  StringRequest request=new PodioRequest(method,url,body,session,future);
  requestQueue.add(request);
  String result=getBlockingResponse(future);
  if (result == null && lastRequestError != null && lastRequestError.networkResponse != null) {
    if (lastRequestError.networkResponse.statusCode == 401) {
      session=new Session(null);
      refreshSession();
      future=RequestFuture.newFuture();
      request=new PodioRequest(method,url,body,session,future);
      requestQueue.add(request);
      result=getBlockingResponse(future);
    }
  }
  return result;
}","private String request(int method,Uri uri,String body){
  String url=Utils.notEmpty(uri) ? uri.toString() : null;
  String accessToken=session != null ? session.accessToken : ""String_Node_Str"";
  Map<String,String> headers=new HashMap<String,String>();
  headers.put(""String_Node_Str"",""String_Node_Str"" + accessToken);
  RequestFuture<String> future=RequestFuture.newFuture();
  StringRequest request=new PodioRequest(method,url,body,headers,future);
  requestQueue.add(request);
  String result=getBlockingResponse(future);
  return result;
}",0.491828793774319
26020,"@Override public RestResult delete(Uri uri){
  Session resultSession=null;
  if (session.shouldRefreshTokens()) {
    refreshSession();
    resultSession=session;
  }
  String outputJson=request(Method.DELETE,uri,null);
  boolean isSuccess=Utils.notEmpty(outputJson);
  RestResult result=new RestResult(isSuccess,resultSession,null,null);
  return result;
}","@Override public RestResult delete(Uri uri){
  Session resultSession=null;
  if (session.shouldRefreshTokens()) {
    refreshSession();
    resultSession=session;
  }
  String outputJson=request(Method.DELETE,uri,null);
  if (outputJson == null && lastRequestError != null && lastRequestError.networkResponse != null && lastRequestError.networkResponse.statusCode == 401) {
    refreshSession();
    resultSession=session;
    outputJson=request(Method.DELETE,uri,null);
  }
  boolean isSuccess=Utils.notEmpty(outputJson);
  RestResult result=new RestResult(isSuccess,resultSession,null,null);
  return result;
}",0.7368421052631579
26021,"@Override public RestResult put(Uri uri,Object item,Class<?> classOfItem){
  Session resultSession=null;
  if (session.shouldRefreshTokens()) {
    refreshSession();
    resultSession=session;
  }
  String inputJson=itemToJsonParser.parse(item,classOfItem);
  String outputJson=request(Method.PUT,uri,inputJson);
  boolean isSuccess=Utils.notEmpty(outputJson);
  Object content=jsonToItemParser.parse(outputJson,classOfItem);
  RestResult result=new RestResult(isSuccess,resultSession,null,content);
  return result;
}","@Override public RestResult put(Uri uri,Object item,Class<?> classOfItem){
  Session resultSession=null;
  if (session.shouldRefreshTokens()) {
    refreshSession();
    resultSession=session;
  }
  String inputJson=itemToJsonParser.parse(item,classOfItem);
  String outputJson=request(Method.PUT,uri,inputJson);
  if (outputJson == null && lastRequestError != null && lastRequestError.networkResponse != null && lastRequestError.networkResponse.statusCode == 401) {
    refreshSession();
    resultSession=session;
    outputJson=request(Method.PUT,uri,inputJson);
  }
  boolean isSuccess=Utils.notEmpty(outputJson);
  Object content=jsonToItemParser.parse(outputJson,classOfItem);
  RestResult result=new RestResult(isSuccess,resultSession,null,content);
  return result;
}",0.8012374323279196
26022,"@Override public RestResult post(Uri uri,Object item,Class<?> classOfItem){
  Session resultSession=null;
  if (session.shouldRefreshTokens()) {
    refreshSession();
    resultSession=session;
  }
  String inputJson=itemToJsonParser.parse(item,classOfItem);
  String outputJson=request(Method.POST,uri,inputJson);
  boolean isSuccess=Utils.notEmpty(outputJson);
  Object content=jsonToItemParser.parse(outputJson,classOfItem);
  RestResult result=new RestResult(isSuccess,resultSession,null,content);
  return result;
}","@Override public RestResult post(Uri uri,Object item,Class<?> classOfItem){
  Session resultSession=null;
  if (session.shouldRefreshTokens()) {
    refreshSession();
    resultSession=session;
  }
  String inputJson=itemToJsonParser.parse(item,classOfItem);
  String outputJson=request(Method.POST,uri,inputJson);
  if (outputJson == null && lastRequestError != null && lastRequestError.networkResponse != null && lastRequestError.networkResponse.statusCode == 401) {
    refreshSession();
    resultSession=session;
    outputJson=request(Method.POST,uri,inputJson);
  }
  boolean isSuccess=Utils.notEmpty(outputJson);
  Object content=jsonToItemParser.parse(outputJson,classOfItem);
  RestResult result=new RestResult(isSuccess,resultSession,null,content);
  return result;
}",0.8012326656394453
26023,"@Override public RestResult get(Uri uri,Class<?> classOfResult){
  Session resultSession=null;
  if (session.shouldRefreshTokens()) {
    refreshSession();
    resultSession=session;
  }
  String outputJson=request(Method.GET,uri,null);
  boolean isSuccess=Utils.notEmpty(outputJson);
  Object item=jsonToItemParser.parse(outputJson,classOfResult);
  RestResult result=new RestResult(isSuccess,resultSession,null,item);
  return result;
}","@Override public RestResult get(Uri uri,Class<?> classOfResult){
  Session resultSession=null;
  if (session.shouldRefreshTokens()) {
    refreshSession();
    resultSession=session;
  }
  String outputJson=request(Method.GET,uri,null);
  if (outputJson == null && lastRequestError != null && lastRequestError.networkResponse != null && lastRequestError.networkResponse.statusCode == 401) {
    refreshSession();
    resultSession=session;
    outputJson=request(Method.GET,uri,null);
  }
  boolean isSuccess=Utils.notEmpty(outputJson);
  Object item=jsonToItemParser.parse(outputJson,classOfResult);
  RestResult result=new RestResult(isSuccess,resultSession,null,item);
  return result;
}",0.776595744680851
26024,"@Override public Map<String,String> getHeaders() throws AuthFailureError {
  Map<String,String> headers=new HashMap<String,String>();
  if (Utils.notEmpty(authToken)) {
    headers.put(""String_Node_Str"",""String_Node_Str"" + authToken);
  }
  return headers;
}","@Override public Map<String,String> getHeaders() throws AuthFailureError {
  return headers;
}",0.5340909090909091
26025,"public PodioRequest(int method,String url,String body,Session session,RequestFuture<String> future){
  super(method,url,future,future);
  setShouldCache(false);
  this.authToken=session != null ? session.accessToken : ""String_Node_Str"";
  this.body=body;
}","public PodioRequest(int method,String url,String body,Map<String,String> headers,RequestFuture<String> future){
  super(method,url,future,future);
  setShouldCache(false);
  this.headers=headers;
  this.body=body;
}",0.7430997876857749
26026,"@Override public RestResult post(Uri uri,Object item) throws SQLiteException, InvalidParserException {
  long id=-1L;
  SQLiteDatabase database=sqliteHelper.getWritableDatabase();
  if (database != null) {
    String json=parseItem(item);
    ContentValues values=new ContentValues();
    values.put(""String_Node_Str"",uri.toString());
    values.put(""String_Node_Str"",json);
    id=database.insertWithOnConflict(""String_Node_Str"",null,values,SQLiteDatabase.CONFLICT_REPLACE);
  }
  boolean isSuccess=id != -1L;
  String message=null;
  List<?> items=null;
  RestResult result=new RestResult(isSuccess,message,items);
  return result;
}","@Override public RestResult post(Uri uri,Object item) throws SQLiteException, InvalidParserException {
  long id=-1L;
  if (Utils.notEmpty(uri)) {
    SQLiteDatabase database=sqliteHelper.getWritableDatabase();
    String json=parseItem(item);
    ContentValues values=new ContentValues();
    values.put(""String_Node_Str"",uri.toString());
    values.put(""String_Node_Str"",json);
    id=database.insertWithOnConflict(""String_Node_Str"",null,values,SQLiteDatabase.CONFLICT_REPLACE);
  }
  boolean isSuccess=id != -1L;
  String message=null;
  List<?> items=null;
  RestResult result=new RestResult(isSuccess,message,items);
  return result;
}",0.9552941176470588
26027,"@Override public RestResult get(Uri uri) throws SQLiteException, InvalidParserException {
  String json=null;
  SQLiteDatabase database=sqliteHelper.getReadableDatabase();
  if (database != null) {
    String[] projection={""String_Node_Str""};
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    Cursor cursor=database.query(""String_Node_Str"",projection,key,value,null,null,null);
    if (cursor != null) {
      json=cursor.moveToFirst() ? cursor.getString(0) : ""String_Node_Str"";
    }
  }
  boolean isSuccess=json != null;
  String message=null;
  Object item=parseJson(json);
  RestResult result=new RestResult(isSuccess,message,item);
  return result;
}","@Override public RestResult get(Uri uri) throws SQLiteException, InvalidParserException {
  String json=null;
  if (Utils.notEmpty(uri)) {
    SQLiteDatabase database=sqliteHelper.getReadableDatabase();
    String[] projection={""String_Node_Str""};
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    Cursor cursor=database.query(""String_Node_Str"",projection,key,value,null,null,null);
    if (cursor != null) {
      json=cursor.moveToFirst() ? cursor.getString(0) : ""String_Node_Str"";
    }
  }
  boolean isSuccess=json != null;
  String message=null;
  Object item=parseJson(json);
  RestResult result=new RestResult(isSuccess,message,item);
  return result;
}",0.9582417582417584
26028,"@Override public RestResult delete(Uri uri) throws SQLiteException {
  int count=-1;
  SQLiteDatabase database=sqliteHelper.getWritableDatabase();
  if (database != null) {
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    count=database.delete(""String_Node_Str"",key,value);
  }
  boolean isSuccess=count != -1;
  String message=null;
  List<?> items=null;
  RestResult result=new RestResult(isSuccess,message,items);
  return result;
}","@Override public RestResult delete(Uri uri) throws SQLiteException {
  int count=-1;
  if (Utils.notEmpty(uri)) {
    SQLiteDatabase database=sqliteHelper.getWritableDatabase();
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    count=database.delete(""String_Node_Str"",key,value);
  }
  boolean isSuccess=count != -1;
  String message=null;
  List<?> items=null;
  RestResult result=new RestResult(isSuccess,message,items);
  return result;
}",0.9385113268608414
26029,"@Override public RestResult put(Uri uri,Object item) throws SQLiteException, InvalidParserException {
  int count=-1;
  SQLiteDatabase database=sqliteHelper.getWritableDatabase();
  if (database != null) {
    String json=parseItem(item);
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    ContentValues values=new ContentValues();
    values.put(""String_Node_Str"",json);
    count=database.updateWithOnConflict(""String_Node_Str"",values,key,value,SQLiteDatabase.CONFLICT_IGNORE);
  }
  boolean isSuccess=count != -1;
  String message=null;
  List<?> items=null;
  RestResult result=new RestResult(isSuccess,message,items);
  return result;
}","@Override public RestResult put(Uri uri,Object item) throws SQLiteException, InvalidParserException {
  int count=-1;
  if (Utils.notEmpty(uri)) {
    SQLiteDatabase database=sqliteHelper.getWritableDatabase();
    String json=parseItem(item);
    String key=""String_Node_Str"";
    String[] value={uri.toString()};
    ContentValues values=new ContentValues();
    values.put(""String_Node_Str"",json);
    count=database.updateWithOnConflict(""String_Node_Str"",values,key,value,SQLiteDatabase.CONFLICT_IGNORE);
  }
  boolean isSuccess=count != -1;
  String message=null;
  List<?> items=null;
  RestResult result=new RestResult(isSuccess,message,items);
  return result;
}",0.9573033707865168
26030,"/** 
 * Verifies that both the database delegate and the network delegate are triggered when a ""get"" rest request is called. <pre> 1. Create a new CachedRestClient. 2. Add a mocked   {@link DatabaseClientDelegate} to the client.3. Add a mocked  {@link NetworkClientDelegate} to the client.4. Perform a ""get"" request. 5. Verify that the mocked database delegate is triggered. 6. Verify that the mocked network delegate is triggered. </pre>
 */
public void testGetRequestTriggersBothClientDelegates(){
  targetNetworkDelegate.mock_setMockGetResult(new RestResult(true,null,new Object()));
  targetDatabaseDelegate.mock_setMockPostResult(new RestResult(true,null,null));
  targetDatabaseDelegate.mock_setMockGetResult(new RestResult(true,null,new Object()));
  expectedReportCount=4;
  RestRequest request=buildRestRequest(RestOperation.GET);
  targetRestClient.enqueue(request);
  TestUtils.blockThread();
  assertEquals(2,targetDatabaseDelegate.mock_getGetCallCount());
  assertEquals(1,targetNetworkDelegate.mock_getGetCallCount());
  assertEquals(1,targetDatabaseDelegate.mock_getPostCallCount());
}","/** 
 * Verifies that both the database delegate and the network delegate are triggered when a ""get"" rest request is called. <pre> 1. Create a new CachedRestClient. 2. Add a mocked   {@link DatabaseClientDelegate} to the client.3. Add a mocked  {@link NetworkClientDelegate} to the client.4. Perform a ""get"" request. 5. Verify that the mocked database delegate is triggered. 6. Verify that the mocked network delegate is triggered. </pre>
 */
public void testGetRequestTriggersBothClientDelegates(){
  targetNetworkDelegate.mock_setMockGetResult(new RestResult(true,null,new Object()));
  targetDatabaseDelegate.mock_setMockPostResult(new RestResult(true,null,new Object()));
  targetDatabaseDelegate.mock_setMockGetResult(new RestResult(true,null,new Object()));
  expectedReportCount=4;
  RestRequest request=buildRestRequest(RestOperation.GET);
  targetRestClient.enqueue(request);
  TestUtils.blockThread();
  assertEquals(2,targetDatabaseDelegate.mock_getGetCallCount());
  assertEquals(1,targetNetworkDelegate.mock_getGetCallCount());
  assertEquals(1,targetDatabaseDelegate.mock_getPostCallCount());
}",0.9936594202898552
26031,"/** 
 * Verifies that a get rest operation is delegated correctly to the  {@link DatabaseClientDelegate}. <pre> 1. Create a new   {@link SQLiteRestClient} and add a mock{@link DatabaseClientDelegate} to it.2. Push a get operation to the client. 3. Verify that the query method of the database helper is called. </pre>
 */
public void testGetOperationIsDelegatedCorrectly(){
  RestRequest restRequest=new RestRequest().setFilter(new PodioFilter()).setOperation(RestOperation.GET);
  target.enqueue(restRequest);
  TestUtils.blockThread(20);
  assertEquals(false,result.isAuthorizeCalled);
  assertEquals(false,result.isDeleteCalled);
  assertEquals(false,result.isInsertCalled);
  assertEquals(true,result.isQueryCalled);
  assertEquals(false,result.isUpdateCalled);
}","/** 
 * Verifies that a get rest operation is delegated correctly to the  {@link DatabaseClientDelegate}. <pre> 1. Create a new   {@link SQLiteRestClient} and add a mock{@link DatabaseClientDelegate} to it.2. Push a get operation to the client. 3. Verify that the query method of the database helper is called. </pre>
 */
public void testGetOperationIsDelegatedCorrectly(){
  RestRequest restRequest=new RestRequest().setFilter(new PodioFilter()).setOperation(RestOperation.GET);
  target.enqueue(restRequest);
  TestUtils.blockThread(40);
  assertEquals(false,result.isAuthorizeCalled);
  assertEquals(false,result.isDeleteCalled);
  assertEquals(false,result.isInsertCalled);
  assertEquals(true,result.isQueryCalled);
  assertEquals(false,result.isUpdateCalled);
}",0.998696219035202
26032,"/** 
 * Verifies that a delete rest operation is delegated correctly to the  {@link DatabaseClientDelegate}. <pre> 1. Create a new   {@link SQLiteRestClient} and add a mock{@link DatabaseClientDelegate} to it.2. Push a delete operation to the client. 3. Verify that the delete method of the database helper is called. </pre>
 */
public void testDeleteOperationIsDelegatedCorrectly(){
  RestRequest restRequest=new RestRequest().setFilter(new PodioFilter()).setOperation(RestOperation.DELETE);
  target.enqueue(restRequest);
  TestUtils.blockThread(20);
  assertEquals(false,result.isAuthorizeCalled);
  assertEquals(true,result.isDeleteCalled);
  assertEquals(false,result.isInsertCalled);
  assertEquals(false,result.isQueryCalled);
  assertEquals(false,result.isUpdateCalled);
}","/** 
 * Verifies that a delete rest operation is delegated correctly to the  {@link DatabaseClientDelegate}. <pre> 1. Create a new   {@link SQLiteRestClient} and add a mock{@link DatabaseClientDelegate} to it.2. Push a delete operation to the client. 3. Verify that the delete method of the database helper is called. </pre>
 */
public void testDeleteOperationIsDelegatedCorrectly(){
  RestRequest restRequest=new RestRequest().setFilter(new PodioFilter()).setOperation(RestOperation.DELETE);
  target.enqueue(restRequest);
  TestUtils.blockThread(40);
  assertEquals(false,result.isAuthorizeCalled);
  assertEquals(true,result.isDeleteCalled);
  assertEquals(false,result.isInsertCalled);
  assertEquals(false,result.isQueryCalled);
  assertEquals(false,result.isUpdateCalled);
}",0.9987179487179488
26033,"public void setup(Context context,String clientId,String clientSecret){
  Podio.clientId=clientId;
  Podio.clientSecret=clientSecret;
  Podio.networkDelegate=new HttpClientDelegate(context);
  Podio.cacheDelegate=new SQLiteClientDelegate(context,DATABASE_NAME,DATABASE_VERSION);
  Podio.client=new CachedRestClient(context,AUTHORITY,networkDelegate,cacheDelegate,QUEUE_CAPACITY);
}","public static void setup(Context context,String clientId,String clientSecret){
  Podio.clientId=clientId;
  Podio.clientSecret=clientSecret;
  Podio.networkDelegate=new HttpClientDelegate(context);
  Podio.cacheDelegate=new SQLiteClientDelegate(context,DATABASE_NAME,DATABASE_VERSION);
  Podio.client=new CachedRestClient(context,AUTHORITY,networkDelegate,cacheDelegate,QUEUE_CAPACITY);
}",0.9908972691807544
26034,"public static final void authenticateWithCredentials(String username,String password,SessionListener sessionListener){
  networkDelegate.setSessionListener(sessionListener);
  SessionProvider provider=new SessionProvider();
  provider.setRestClient(client);
  provider.authenticateWithUserCredentials(clientId,clientSecret,username,password);
}","public static final Object authenticateWithCredentials(String username,String password,ProviderListener providerListener){
  SessionProvider provider=new SessionProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.authenticateWithUserCredentials(clientId,clientSecret,username,password);
}",0.6195965417867435
26035,"public static final void authenticateWithApp(String appId,String appToken,SessionListener sessionListener){
  networkDelegate.setSessionListener(sessionListener);
  SessionProvider provider=new SessionProvider();
  provider.setRestClient(client);
  provider.authenticateWithAppCredentials(clientId,clientSecret,appId,appToken);
}","public static final Object authenticateWithApp(String appId,String appToken,ProviderListener providerListener){
  SessionProvider provider=new SessionProvider();
  provider.setRestClient(client);
  provider.setProviderListener(providerListener);
  return provider.authenticateWithAppCredentials(clientId,clientSecret,appId,appToken);
}",0.6024096385542169
26036,"public boolean isAuthorized(){
  return Utils.notAnyEmpty(accessToken,refreshToken) && expiresInMillis > 0L;
}","public boolean isAuthorized(){
  return Utils.notAnyEmpty(accessToken,refreshToken) && expiresMillis > 0L;
}",0.9908256880733946
26037,"public boolean shouldRefreshTokens(){
  long timeLeft=expiresInMillis - System.currentTimeMillis();
  return timeLeft < 600000;
}","public boolean shouldRefreshTokens(){
  long timeLeft=expiresMillis - System.currentTimeMillis();
  return timeLeft < 600000;
}",0.9921875
26038,"public Session(String accessToken,String refreshToken,long expiresIn){
  this.accessToken=accessToken;
  this.refreshToken=refreshToken;
  this.expiresInMillis=System.currentTimeMillis() + (expiresIn * 1000);
}","public Session(String accessToken,String refreshToken,long expiresIn){
  this.accessToken=accessToken;
  this.refreshToken=refreshToken;
  this.expiresMillis=System.currentTimeMillis() + (expiresIn * 1000);
}",0.9952153110047848
26039,"/** 
 * Performs a custom rest request flow, by - generally speaking - allowing all requests to be handled by the super network client implementation first. When the super implementation delivers a result, that result is stored by this implementation in a local database. The stored data is then requested immediately after and returned to the caller. One exception from the above flow is the GET rest requests, which actually return the cached content first and then re-posts the same request to be handled by the network client as well according to the above pattern.
 * @see com.podio.sdk.client.HttpRestClient#handleRequest(com.podio.sdk.client.RestRequest)
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    RestOperation operation=restRequest.getOperation();
    Filter filter=restRequest.getFilter();
    Object item=restRequest.getContent();
    Class<?> itemType=restRequest.getItemType();
    Uri uri=filter.buildUri(contentScheme,authority);
    if (uri != null && itemType != null) {
      if (operation == RestOperation.GET && !delegatedRequests.contains(restRequest)) {
        result=delegate(operation,uri,item,itemType);
        delegatedRequests.add(restRequest);
        super.enqueue(restRequest);
      }
 else {
        delegatedRequests.remove(restRequest);
        result=super.handleRequest(restRequest);
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          if (operation == RestOperation.GET) {
            result=delegate(RestOperation.POST,uri,item,itemType);
          }
 else {
            result=delegate(operation,uri,item,itemType);
          }
        }
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          result=delegate(RestOperation.GET,uri,item,itemType);
        }
      }
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}","/** 
 * Performs a custom rest request flow, by - generally speaking - allowing all requests to be handled by the super network client implementation first. When the super implementation delivers a result, that result is stored by this implementation in a local database. The stored data is then requested immediately after and returned to the caller. One exception from the above flow is the GET rest requests, which actually return the cached content first and then re-posts the same request to be handled by the network client as well according to the above pattern.
 * @see com.podio.sdk.client.HttpRestClient#handleRequest(com.podio.sdk.client.RestRequest)
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    RestOperation operation=restRequest.getOperation();
    Filter filter=restRequest.getFilter();
    Object item=restRequest.getContent();
    Class<?> itemType=restRequest.getItemType();
    Uri uri=filter.buildUri(contentScheme,authority);
    if (Utils.notEmpty(uri)) {
      if (operation == RestOperation.GET && !delegatedRequests.contains(restRequest)) {
        result=delegate(operation,uri,item,itemType);
        delegatedRequests.add(restRequest);
        super.enqueue(restRequest);
      }
 else {
        delegatedRequests.remove(restRequest);
        result=super.handleRequest(restRequest);
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          if (operation == RestOperation.GET) {
            result=delegate(RestOperation.POST,uri,item,itemType);
          }
 else {
            result=delegate(operation,uri,item,itemType);
          }
        }
        if (result.isSuccess() && operation != RestOperation.AUTHORIZE) {
          result=delegate(RestOperation.GET,uri,item,itemType);
        }
      }
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}",0.9875712066286898
26040,"@Override public void run(){
  if (result == null) {
    resultListener.onFailure(ticket,null);
  }
 else   if (result.isSuccess()) {
    resultListener.onSuccess(ticket,result.item());
  }
 else {
    resultListener.onFailure(ticket,result.message());
  }
}","@Override public void run(){
  if (result == null) {
    resultListener.onFailure(ticket,null);
  }
 else {
    if (result.isSuccess()) {
      resultListener.onSuccess(ticket,result.item());
    }
 else {
      resultListener.onFailure(ticket,result.message());
    }
    Session session=result.session();
    if (session != null) {
      resultListener.onSessionChange(ticket,session);
    }
  }
}",0.745814307458143
26041,"/** 
 * Reports a result back to any callback implementation.
 * @param ticket The request ticket to pass back to the caller.
 * @param resultListener The callback implementation to call through.
 * @param result The result of the request.
 */
protected void reportResult(final Object ticket,final ResultListener resultListener,final RestResult result){
  if (resultListener != null) {
    callerHandler.post(new Runnable(){
      @Override public void run(){
        if (result == null) {
          resultListener.onFailure(ticket,null);
        }
 else         if (result.isSuccess()) {
          resultListener.onSuccess(ticket,result.item());
        }
 else {
          resultListener.onFailure(ticket,result.message());
        }
      }
    }
);
  }
}","/** 
 * Reports a result back to any callback implementation.
 * @param ticket The request ticket to pass back to the caller.
 * @param resultListener The callback implementation to call through.
 * @param result The result of the request.
 */
protected void reportResult(final Object ticket,final ResultListener resultListener,final RestResult result){
  if (resultListener != null) {
    callerHandler.post(new Runnable(){
      @Override public void run(){
        if (result == null) {
          resultListener.onFailure(ticket,null);
        }
 else {
          if (result.isSuccess()) {
            resultListener.onSuccess(ticket,result.item());
          }
 else {
            resultListener.onFailure(ticket,result.message());
          }
          Session session=result.session();
          if (session != null) {
            resultListener.onSessionChange(ticket,session);
          }
        }
      }
    }
);
  }
}",0.8986366330764671
26042,"/** 
 * Constructor. The one and only way to set the state of this object.
 * @param isSuccess Boolean true if this object represents a successfully performed  {@link RestRequest}. Boolean false otherwise.
 * @param message A optional message provided to the caller by the creator of this object.
 * @param item Optional content of this object.
 */
public RestResult(boolean isSuccess,String message,Object item){
  this.isSuccess=isSuccess;
  this.message=message;
  this.item=item;
}","/** 
 * Constructor. The one and only way to set the state of this object.
 * @param isSuccess Boolean true if this object represents a successfully performed  {@link RestRequest}. Boolean false otherwise.
 * @param session The new session variables, if changed. Otherwise null.
 * @param message A optional message provided to the caller by the creator of this object.
 * @param item Optional content of this object.
 */
public RestResult(boolean isSuccess,Session session,String message,Object item){
  this.isSuccess=isSuccess;
  this.session=session;
  this.message=message;
  this.item=item;
}",0.8550323176361958
26043,"public AuthRequest(String url,String body,RequestFuture<JSONObject> future){
  super(Method.POST,url,null,future,future);
  setShouldCache(false);
  authBody=body;
}","public AuthRequest(String url,Map<String,String> params,RequestFuture<String> future){
  super(Method.POST,url,future,future);
  setShouldCache(false);
  this.params=params;
}",0.8117647058823529
26044,"/** 
 * Performs a custom rest request flow, by - generally speaking - allowing all requests to be handled by the super network client implementation first. When the super implementation delivers a result, that result is stored by this implementation in a local database. The stored data is then requested immediately after and returned to the caller. One exception from the above flow is the GET rest requests, which actually return the cached content first and then re-posts the same request to be handled by the network client as well according to the above pattern.
 * @see com.podio.sdk.client.HttpRestClient#handleRequest(com.podio.sdk.client.RestRequest)
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    RestOperation operation=restRequest.getOperation();
    Filter filter=restRequest.getFilter();
    Object item=restRequest.getContent();
    Class<?> itemType=restRequest.getItemType();
    Uri uri=filter.buildUri(contentScheme,authority);
    if (uri != null && itemType != null) {
      if (operation == RestOperation.GET && !delegatedRequests.contains(restRequest)) {
        delegate(operation,uri,item,itemType);
        delegatedRequests.add(restRequest);
        super.perform(restRequest);
      }
 else {
        delegatedRequests.remove(restRequest);
        result=super.handleRequest(restRequest);
        if (result.isSuccess() && operation != RestOperation.GET) {
          result=delegate(operation,uri,item,itemType);
        }
        if (result.isSuccess()) {
          result=delegate(RestOperation.GET,uri,item,itemType);
        }
      }
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}","/** 
 * Performs a custom rest request flow, by - generally speaking - allowing all requests to be handled by the super network client implementation first. When the super implementation delivers a result, that result is stored by this implementation in a local database. The stored data is then requested immediately after and returned to the caller. One exception from the above flow is the GET rest requests, which actually return the cached content first and then re-posts the same request to be handled by the network client as well according to the above pattern.
 * @see com.podio.sdk.client.HttpRestClient#handleRequest(com.podio.sdk.client.RestRequest)
 */
@Override protected RestResult handleRequest(RestRequest restRequest){
  RestResult result=null;
  if (restRequest != null) {
    RestOperation operation=restRequest.getOperation();
    Filter filter=restRequest.getFilter();
    Object item=restRequest.getContent();
    Class<?> itemType=restRequest.getItemType();
    Uri uri=filter.buildUri(contentScheme,authority);
    if (uri != null && itemType != null) {
      if (operation == RestOperation.GET && !delegatedRequests.contains(restRequest)) {
        result=delegate(operation,uri,item,itemType);
        delegatedRequests.add(restRequest);
        super.perform(restRequest);
      }
 else {
        delegatedRequests.remove(restRequest);
        result=super.handleRequest(restRequest);
        if (result.isSuccess()) {
          if (operation == RestOperation.GET) {
            result=delegate(RestOperation.POST,uri,item,itemType);
          }
 else {
            result=delegate(operation,uri,item,itemType);
          }
        }
        if (result.isSuccess()) {
          result=delegate(RestOperation.GET,uri,item,itemType);
        }
      }
    }
  }
  return result != null ? result : new RestResult(false,null,null);
}",0.9526726057906458
26045,"@Override public RestResult post(Uri uri,Object item,Class<?> classOfItem){
  long id=-1L;
  SQLiteDatabase database=openDatabase(uri);
  if (database != null) {
    String json=itemToJsonParser.parse(item,classOfItem);
    ContentValues values=new ContentValues();
    values.put(""String_Node_Str"",uri.toString());
    values.put(""String_Node_Str"",json);
    id=database.insertWithOnConflict(""String_Node_Str"",null,values,SQLiteDatabase.CONFLICT_IGNORE);
  }
  boolean isSuccess=id != -1L;
  String message=null;
  List<?> items=null;
  RestResult result=new RestResult(isSuccess,message,items);
  return result;
}","@Override public RestResult post(Uri uri,Object item,Class<?> classOfItem){
  long id=-1L;
  SQLiteDatabase database=openDatabase(uri);
  if (database != null) {
    String json=itemToJsonParser.parse(item,classOfItem);
    ContentValues values=new ContentValues();
    values.put(""String_Node_Str"",uri.toString());
    values.put(""String_Node_Str"",json);
    id=database.insertWithOnConflict(""String_Node_Str"",null,values,SQLiteDatabase.CONFLICT_REPLACE);
  }
  boolean isSuccess=id != -1L;
  String message=null;
  List<?> items=null;
  RestResult result=new RestResult(isSuccess,message,items);
  return result;
}",0.992688870836718
26046,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  logger.info(""String_Node_Str"");
  if (outboundChannel != null) {
    closeOnFlush(outboundChannel);
  }
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  log.info(""String_Node_Str"");
  if (outboundChannel != null) {
    closeOnFlush(outboundChannel);
  }
}",0.992084432717678
26047,"@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  inboundChannel=ctx.channel();
  InetSocketAddress localAddress=(InetSocketAddress)inboundChannel.localAddress();
  int port=localAddress.getPort();
  ProxyHost outboundRemoteHost=TcpProxyServer.getProxyHosts().get(port);
  Bootstrap b=new Bootstrap();
  b.group(inboundChannel.eventLoop()).channel(ctx.channel().getClass()).handler(new BackendInitializer(this)).option(ChannelOption.SO_REUSEADDR,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_KEEPALIVE,true);
  ChannelFuture f=b.connect(outboundRemoteHost.getRemoteHost(),outboundRemoteHost.getRemotePort());
  outboundChannel=f.channel();
  f.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    final ChannelFuture channelFuture) throws Exception {
      if (!channelFuture.isSuccess()) {
        close();
      }
    }
  }
);
}","@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  inboundChannel=ctx.channel();
  InetSocketAddress localAddress=(InetSocketAddress)inboundChannel.localAddress();
  int port=localAddress.getPort();
  final ProxyHost outboundRemoteHost=TcpProxyServer.getProxyHosts().get(port);
  Bootstrap b=new Bootstrap();
  b.group(inboundChannel.eventLoop()).channel(ctx.channel().getClass()).handler(new BackendInitializer(this)).option(ChannelOption.SO_REUSEADDR,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_KEEPALIVE,true);
  ChannelFuture f=b.connect(outboundRemoteHost.getRemoteHost(),outboundRemoteHost.getRemotePort());
  outboundChannel=f.channel();
  f.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    final ChannelFuture channelFuture) throws Exception {
      if (!channelFuture.isSuccess()) {
        log.info(""String_Node_Str"" + outboundRemoteHost.getRemoteHost() + ""String_Node_Str""+ outboundRemoteHost.getRemotePort());
        close();
      }
    }
  }
);
}",0.9295238095238096
26048,"@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  logger.info(""String_Node_Str"" + ctx.channel().remoteAddress(),cause);
  close();
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  log.info(""String_Node_Str"" + ctx.channel().remoteAddress(),cause);
  close();
}",0.9917808219178084
26049,"@Override public void operationComplete(final ChannelFuture channelFuture) throws Exception {
  if (!channelFuture.isSuccess()) {
    close();
  }
}","@Override public void operationComplete(final ChannelFuture channelFuture) throws Exception {
  if (!channelFuture.isSuccess()) {
    log.info(""String_Node_Str"" + outboundRemoteHost.getRemoteHost() + ""String_Node_Str""+ outboundRemoteHost.getRemotePort());
    close();
  }
}",0.6729857819905213
26050,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  logger.info(""String_Node_Str"");
  proxyFrondtendHandle.close();
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  log.info(""String_Node_Str"");
  proxyFrondtendHandle.close();
}",0.9899665551839464
26051,"@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  logger.info(""String_Node_Str"");
  proxyFrondtendHandle.outBoundChannelReady();
}","@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  log.info(""String_Node_Str"");
  proxyFrondtendHandle.outBoundChannelReady();
}",0.9907692307692308
26052,"@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  logger.info(""String_Node_Str"" + ctx.channel().remoteAddress(),cause);
  proxyFrondtendHandle.close();
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  log.info(""String_Node_Str"" + ctx.channel().remoteAddress(),cause);
  proxyFrondtendHandle.close();
}",0.9926289926289926
26053,"@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  inboundChannel=ctx.channel();
  InetSocketAddress localAddress=(InetSocketAddress)inboundChannel.localAddress();
  int port=localAddress.getPort();
  ProxyHost outboundRemoteHost=TcpProxyServer.getProxyHosts().get(port);
  Bootstrap b=new Bootstrap();
  b.group(inboundChannel.eventLoop()).channel(ctx.channel().getClass()).handler(new BackendInitializer(this)).option(ChannelOption.SO_REUSEADDR,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_KEEPALIVE,true);
  ChannelFuture f=b.connect(outboundRemoteHost.getRemoteHost(),outboundRemoteHost.getRemotePort());
  outboundChannel=f.channel();
}","@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  inboundChannel=ctx.channel();
  InetSocketAddress localAddress=(InetSocketAddress)inboundChannel.localAddress();
  int port=localAddress.getPort();
  ProxyHost outboundRemoteHost=TcpProxyServer.getProxyHosts().get(port);
  Bootstrap b=new Bootstrap();
  b.group(inboundChannel.eventLoop()).channel(ctx.channel().getClass()).handler(new BackendInitializer(this)).option(ChannelOption.SO_REUSEADDR,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_KEEPALIVE,true);
  ChannelFuture f=b.connect(outboundRemoteHost.getRemoteHost(),outboundRemoteHost.getRemotePort());
  outboundChannel=f.channel();
  f.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    final ChannelFuture channelFuture) throws Exception {
      if (!channelFuture.isSuccess()) {
        close();
      }
    }
  }
);
}",0.870615296147211
26054,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  log.info(""String_Node_Str"");
  proxyFrondtendHandle.close();
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  log.debug(""String_Node_Str"");
  proxyFrondtendHandle.close();
}",0.9696969696969696
26055,"@Override public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
  log.info(""String_Node_Str"");
}","@Override public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
  log.debug(""String_Node_Str"");
}",0.9626556016597512
26056,"@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  log.info(""String_Node_Str"");
  proxyFrondtendHandle.outBoundChannelReady();
}","@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  log.debug(""String_Node_Str"");
  proxyFrondtendHandle.outBoundChannelReady();
}",0.9721362229102168
26057,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  log.info(""String_Node_Str"");
  if (outboundChannel != null) {
    closeOnFlush(outboundChannel);
  }
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  log.debug(""String_Node_Str"");
  close();
}",0.7784810126582279
26058,"@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  inboundChannel=ctx.channel();
  InetSocketAddress localAddress=(InetSocketAddress)inboundChannel.localAddress();
  int port=localAddress.getPort();
  final ProxyHost outboundRemoteHost=TcpProxyServer.getProxyHosts().get(port);
  Bootstrap b=new Bootstrap();
  b.group(inboundChannel.eventLoop()).channel(ctx.channel().getClass()).handler(new BackendInitializer(this)).option(ChannelOption.SO_REUSEADDR,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_KEEPALIVE,true);
  ChannelFuture f=b.connect(outboundRemoteHost.getRemoteHost(),outboundRemoteHost.getRemotePort());
  outboundChannel=f.channel();
  f.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    final ChannelFuture channelFuture) throws Exception {
      if (!channelFuture.isSuccess()) {
        log.info(""String_Node_Str"" + outboundRemoteHost.getRemoteHost() + ""String_Node_Str""+ outboundRemoteHost.getRemotePort());
        close();
      }
    }
  }
);
}","@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {
  inboundChannel=ctx.channel();
  InetSocketAddress localAddress=(InetSocketAddress)inboundChannel.localAddress();
  int port=localAddress.getPort();
  final ProxyHost outboundRemoteHost=TcpProxyServer.getProxyHosts().get(port);
  Bootstrap b=new Bootstrap();
  b.group(inboundChannel.eventLoop()).channel(ctx.channel().getClass()).handler(new BackendInitializer(this)).option(ChannelOption.SO_REUSEADDR,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_KEEPALIVE,true);
  ChannelFuture f=b.connect(outboundRemoteHost.getRemoteHost(),outboundRemoteHost.getRemotePort());
  connectStatus=ConnectionStatus.outBoundChnnlConnecting;
  outboundChannel=f.channel();
  f.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    final ChannelFuture channelFuture) throws Exception {
      if (!channelFuture.isSuccess()) {
        log.info(""String_Node_Str"" + outboundRemoteHost.getRemoteHost() + ""String_Node_Str""+ outboundRemoteHost.getRemotePort());
        close();
      }
    }
  }
);
}",0.974716652136007
26059,"@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  log.info(""String_Node_Str"" + ctx.channel().remoteAddress(),cause);
  close();
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  log.debug(""String_Node_Str"" + ctx.channel().remoteAddress(),cause);
  close();
}",0.975206611570248
26060,"public void outBoundChannelReady(){
synchronized (buffer) {
    if (outboundChannel.isActive()) {
      for (      Object ojb : buffer) {
        outboundChannel.writeAndFlush(ojb);
      }
      buffer.clear();
    }
    outBoundChnnlReady=true;
  }
}","public void outBoundChannelReady(){
  inboundChannel.config().setAutoRead(true);
  connectStatus=ConnectionStatus.outBoundChnnlReady;
  for (  Object obj : inboundMsgBuffer) {
    outboundChannel.writeAndFlush(obj);
  }
  inboundMsgBuffer.clear();
}",0.2395209580838323
26061,"public void close(){
  closeOnFlush(inboundChannel);
  closeOnFlush(outboundChannel);
}","public void close(){
  connectStatus=ConnectionStatus.closing;
  for (  Object obj : inboundMsgBuffer) {
    release(obj);
  }
  inboundMsgBuffer.clear();
  closeOnFlush(inboundChannel);
  closeOnFlush(outboundChannel);
}",0.538961038961039
26062,"@Override public void channelRead(final ChannelHandlerContext ctx,Object msg) throws Exception {
  if (outBoundChnnlReady) {
    outboundChannel.writeAndFlush(msg);
    return;
  }
synchronized (buffer) {
    if (outBoundChnnlReady) {
      outboundChannel.writeAndFlush(msg);
      return;
    }
    if (outboundChannel.isActive()) {
      for (      Object ojb : buffer) {
        outboundChannel.writeAndFlush(ojb);
      }
      buffer.clear();
      outboundChannel.writeAndFlush(msg);
    }
 else {
      buffer.add(msg);
    }
  }
}","@Override public void channelRead(final ChannelHandlerContext ctx,Object msg) throws Exception {
switch (connectStatus) {
case outBoundChnnlReady:
    outboundChannel.writeAndFlush(msg);
  break;
case closing:
release(msg);
break;
case init:
log.error(""String_Node_Str"");
close();
break;
case outBoundChnnlConnecting:
default :
inboundMsgBuffer.add(msg);
}
}",0.3879598662207358
26063,"private void run() throws Exception {
  EventLoopGroup bossGroup=new NioEventLoopGroup();
  EventLoopGroup workerGroup=new NioEventLoopGroup(TcpProxyServer.getConfig().getInt(""String_Node_Str""));
  try {
    ServerBootstrap b=new ServerBootstrap();
    b.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new FrontendInitializer()).option(ChannelOption.SO_BACKLOG,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_REUSEADDR,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_KEEPALIVE,true);
    ArrayList<Channel> allchannels=new ArrayList<Channel>();
    ArrayList<ProxyHost> hostList=getProxyHostList();
    log.info(""String_Node_Str"");
    for (    ProxyHost host : hostList) {
      proxyHosts.put(host.localPort,host);
      log.info(""String_Node_Str"" + host.localPort + ""String_Node_Str""+ host.remoteHost+ ""String_Node_Str""+ host.remotePort);
      Channel ch=b.bind(host.localPort).sync().channel();
      allchannels.add(ch);
    }
    log.info(""String_Node_Str"");
    for (    Channel ch : allchannels) {
      ch.closeFuture().sync();
    }
  }
  finally {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
  }
}","private void run() throws Exception {
  EventLoopGroup bossGroup=new NioEventLoopGroup();
  EventLoopGroup workerGroup=new NioEventLoopGroup(TcpProxyServer.getConfig().getInt(""String_Node_Str""));
  try {
    ServerBootstrap b=new ServerBootstrap();
    b.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new FrontendInitializer()).option(ChannelOption.SO_BACKLOG,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_REUSEADDR,true).option(ChannelOption.CONNECT_TIMEOUT_MILLIS,TcpProxyServer.getConfig().getInt(""String_Node_Str"")).option(ChannelOption.SO_KEEPALIVE,true).option(ChannelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.AUTO_READ,false);
    ArrayList<Channel> allchannels=new ArrayList<Channel>();
    ArrayList<ProxyHost> hostList=getProxyHostList();
    log.info(""String_Node_Str"");
    for (    ProxyHost host : hostList) {
      proxyHosts.put(host.localPort,host);
      log.info(""String_Node_Str"" + host.localPort + ""String_Node_Str""+ host.remoteHost+ ""String_Node_Str""+ host.remotePort);
      Channel ch=b.bind(host.localPort).sync().channel();
      allchannels.add(ch);
    }
    log.info(""String_Node_Str"");
    for (    Channel ch : allchannels) {
      ch.closeFuture().sync();
    }
  }
  finally {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
  }
}",0.9364499634769904
26064,"/** 
 * Registers an instance as being a listener, any packets received from linked Connection will be passed to applicable methods <p/> Methods must have the   {@link com.ikeirnez.communicationsframework.api.packets.PacketHandler} annotationMethods have an optional first parameter  {@link com.ikeirnez.communicationsframework.api.connection.Connection} and a required second parameter implementing {@link com.ikeirnez.communicationsframework.api.packets.Packet}
 * @param packetListener The instance we should register and pass packets to
 */
public void registerListener(PacketListener packetListener);","/** 
 * Registers an instance as being a listener, any packets received from linked Connection will be passed to applicable methods Methods must have the   {@link com.ikeirnez.communicationsframework.api.packets.PacketHandler} annotationMethods have an optional first parameter  {@link com.ikeirnez.communicationsframework.api.connection.Connection} and a required second parameter implementing {@link com.ikeirnez.communicationsframework.api.packets.Packet}
 * @param packetListener The instance we should register and pass packets to
 */
public void registerListener(PacketListener packetListener);",0.995850622406639
26065,"public ChannelFuture send(Packet packet){
  ChannelFuture channelFuture=ctx.writeAndFlush(packet);
  channelFuture.addListener(new GenericFutureListener<ChannelFuture>(){
    @Override public void operationComplete(    ChannelFuture future) throws Exception {
      if (!future.isSuccess()) {
        throw new Exception(""String_Node_Str"",future.cause());
      }
    }
  }
);
  return channelFuture;
}","public ChannelFuture send(Packet packet){
  ChannelFuture channelFuture=ctx.writeAndFlush(packet);
  channelFuture.addListener(new GenericFutureListener<ChannelFuture>(){
    @Override public void operationComplete(    ChannelFuture future) throws Exception {
      if (!future.isSuccess() && !connection.closing.get()) {
        throw new Exception(""String_Node_Str"",future.cause());
      }
    }
  }
);
  return channelFuture;
}",0.965186074429772
26066,"@Override public void close() throws IOException {
  if (ctx != null) {
    connection.closing.set(true);
    send(new PacketDisconnect()).syncUninterruptibly();
    ctx.channel().disconnect().syncUninterruptibly();
  }
}","@Override public void close() throws IOException {
  if (ctx != null) {
    connection.closing.set(true);
    if (connection.isConnected()) {
      send(new PacketDisconnect()).syncUninterruptibly();
    }
    ctx.channel().disconnect().syncUninterruptibly();
  }
}",0.9094650205761317
26067,"@Override public void operationComplete(ChannelFuture future) throws Exception {
  if (!future.isSuccess()) {
    throw new Exception(""String_Node_Str"",future.cause());
  }
}","@Override public void operationComplete(ChannelFuture future) throws Exception {
  if (!future.isSuccess() && !connection.closing.get()) {
    throw new Exception(""String_Node_Str"",future.cause());
  }
}",0.9230769230769232
26068,"private boolean isMethodApplicable(Method method){
  Class<?>[] parameters=method.getParameterTypes();
  return method.isAnnotationPresent(PacketHandler.class) && ((parameters.length == 1 && Packet.class.isAssignableFrom(parameters[0])) || (parameters.length == 2 && Connection.class.equals(parameters[0].getClass()) && Packet.class.isAssignableFrom(parameters[1])));
}","private boolean isMethodApplicable(Method method){
  Class<?>[] parameters=method.getParameterTypes();
  return method.isAnnotationPresent(PacketHandler.class) && ((parameters.length == 1 && Packet.class.isAssignableFrom(parameters[0])) || (parameters.length == 2 && parameters[0].equals(Connection.class) && Packet.class.isAssignableFrom(parameters[1])));
}",0.9243466299862448
26069,"protected static void logEdgeScore(Edge e,double score){
  if (LOGGER.isDebugEnabled())   LOGGER.debug(String.format(""String_Node_Str"",Graphs.edgeToString(e),score));
}","protected void logEdgeScore(Edge e,double score){
  if (LOGGER.isDebugEnabled())   LOGGER.debug(String.format(""String_Node_Str"",type(),Graphs.edgeToString(e),score));
}",0.9583333333333334
26070,"@Override public Double transform(Edge e){
  String pred=getPred(e);
  String obj=getObj(e);
  double score=ic(pred) + ic(pred + obj) / ic(pred);
  logEdgeScore(e,score);
  return score;
}","@Override public Double transform(Edge e){
  String pred=getPred(e);
  String obj=getObj(e);
  double icObjGivenPred=-1 * Math.log(p(pred + obj) / p(pred));
  double score=ic(pred) + icObjGivenPred;
  logEdgeScore(e,score);
  return score;
}",0.7086247086247086
26071,"@Override public Double getVertexScore(Vertex v){
  double score=betweenness.getVertexScore(v);
  double normalizedScore=score / ((verticesCount - 1) * (verticesCount - 2));
  return normalizedScore;
}","@Override public Double getVertexScore(Vertex v){
  double score=betweenness.getVertexScore(v);
  if (graphType == GraphType.UNDIRECTED_GRAPH)   score/=2;
  double normalizedScore=score / ((verticesCount - 1) * (verticesCount - 2));
  return normalizedScore;
}",0.8720173535791758
26072,"@Override protected VertexScorer<Vertex,Double> getVertexScorer(Graph subgraph,Map<Vertex,Double> vertexPriors){
  GraphJung<Graph> graphJung=Graphs.asGraphJung(graphType,subgraph);
  PageRankWithPriors<Vertex,Edge> pageRank=new PageRank<Vertex,Edge>(graphJung,edgeWeights,alpha);
  return new PRVertexScorer(pageRank,subgraph,iterations);
}","@Override protected VertexScorer<Vertex,Double> getVertexScorer(Graph subgraph,Map<Vertex,Double> vertexPriors){
  GraphJung<Graph> graphJung=new GraphJung<Graph>(subgraph);
  PageRankWithPriors<Vertex,Edge> pageRank=new PageRank<Vertex,Edge>(graphJung,edgeWeights,alpha);
  return new PRVertexScorer(pageRank,subgraph,iterations);
}",0.9554896142433236
26073,"@Override public Double getVertexScore(Vertex v){
  return pageRank.getVertexScore(v) / scoreSum;
}","@Override public Double getVertexScore(Vertex v){
  if (scoreSum == 0)   return 0.0;
  return pageRank.getVertexScore(v) / scoreSum;
}",0.8497854077253219
26074,"@Override public List<SurfaceFormSenseScore<T,U>> disambiguate(Map<T,List<U>> surfaceFormsSenses,Graph subgraph){
  Map<T,List<SurfaceFormSenseScore<T,U>>> allScores=allSurfaceFormSensesScores(surfaceFormsSenses,subgraph);
  List<SurfaceFormSenseScore<T,U>> highestScores=new ArrayList<>();
  for (  T surfaceForm : allScores.keySet()) {
    List<SurfaceFormSenseScore<T,U>> sFSScores=allScores.get(surfaceForm);
    if (sFSScores.isEmpty()) {
      logger.warn(""String_Node_Str"",surfaceForm);
      continue;
    }
    SurfaceFormSenseScore<T,U> highestScoreSense=Collections.max(sFSScores,SurfaceFormSenseScore.DESCENDING_SCORE_COMPARATOR);
    highestScores.add(highestScoreSense);
  }
  return highestScores;
}","@Override public List<SurfaceFormSenseScore<T,U>> disambiguate(Map<T,List<U>> surfaceFormsSenses,Graph subgraph){
  Map<T,List<SurfaceFormSenseScore<T,U>>> allScores=allSurfaceFormSensesScores(surfaceFormsSenses,subgraph);
  List<SurfaceFormSenseScore<T,U>> highestScores=new ArrayList<>();
  for (  T surfaceForm : allScores.keySet()) {
    List<SurfaceFormSenseScore<T,U>> sFSScores=allScores.get(surfaceForm);
    if (sFSScores.isEmpty()) {
      logger.warn(""String_Node_Str"",surfaceForm);
      continue;
    }
    SurfaceFormSenseScore<T,U> highestScoreSense=Collections.max(sFSScores,SurfaceFormSenseScore.SCORE_COMPARATOR);
    highestScores.add(highestScoreSense);
  }
  return highestScores;
}",0.9922371206774876
26075,"/** 
 * Main method.
 * @param args each arg can be a directory containing RDF files or a RDF file itself.
 * @throws FileNotFoundException
 */
public static void main(String[] args) throws ConfigurationException, FileNotFoundException {
  Configuration config=GraphConfig.config();
  DBpediaGraphLoader.loadFromFiles(FileUtils.extractFilesFromArgs(args),config);
  if (EdgeWeightsType.fromConfig(config) != EdgeWeightsType.DUMMY)   PredObjOccsCounter.countAndPersistDBpediaGraphOccs();
}","/** 
 * Main method.
 * @param args each arg can be a directory containing RDF files or a RDF file itself.
 * @throws FileNotFoundException
 */
public static void main(String[] args) throws ConfigurationException, FileNotFoundException {
  Configuration config=GraphConfig.config();
  DBpediaGraphLoader.loadFromFiles(FileUtils.extractFilesFromArgs(args),config);
  if (EdgeWeightsType.fromConfig(config) != EdgeWeightsType.DUMMY)   PredObjOccsCounter.countAndPersistDBpediaGraphOccs(GraphFactory.getDBpediaGraph());
}",0.9701789264413518
26076,"/** 
 * @return prior probability (number of occurrences) of the short URI.
 */
protected double p(String shortUri){
  int shortUriCount=checkNotNull(occCounts.get(shortUri),""String_Node_Str"",shortUri);
  return shortUriCount / totalEdges;
}","/** 
 * @return prior probability (number of occurrences) of the short URI.
 */
protected double p(String shortUri){
  int shortUriCount=checkNotNull(occCounts.get(shortUri),""String_Node_Str"",shortUri);
  double p=(double)shortUriCount / totalEdges;
  if (LOGGER.isTraceEnabled())   LOGGER.trace(String.format(""String_Node_Str"",shortUri,shortUriCount,totalEdges,p));
  return p;
}",0.7536231884057971
26077,"/** 
 * @return the information content of the short URI.
 */
protected double ic(String shortUri){
  return -1 * Math.log(p(shortUri));
}","/** 
 * @return the information content of the short URI.
 */
protected double ic(String shortUri){
  double ic=-1 * Math.log(p(shortUri));
  if (LOGGER.isTraceEnabled())   LOGGER.trace(String.format(""String_Node_Str"",shortUri,ic));
  return ic;
}",0.6805194805194805
26078,"public static void main(String[] args){
  Map<String,Integer> map=loadOccCountsMap(GraphConfig.config());
  queryContent(map);
}","public static void main(String[] args){
  Map<String,Integer> map=loadOccCountsMap(GraphConfig.config(),false);
  queryContent(map);
}",0.9770992366412212
26079,"public static Map<String,Integer> loadOccCountsMap(Configuration config){
  logger.info(""String_Node_Str"");
  Stopwatch stopwatch=Stopwatch.createStarted();
  String fileName=config.getString(CONFIG_EDGE_COUNTS_FILE);
  Kryo kryo=KryoMap.getDefault();
  Input input;
  try {
    input=new Input(new FileInputStream(fileName));
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Integer> map=kryo.readObject(input,HashMap.class);
  input.close();
  logger.info(""String_Node_Str"",stopwatch);
  return map;
}","public static Map<String,Integer> loadOccCountsMap(Configuration config,boolean createIfNonExisting){
  String fileName=config.getString(CONFIG_EDGE_COUNTS_FILE);
  File file=new File(fileName);
  if (createIfNonExisting && !file.exists()) {
    try {
      PredObjOccsCounter.countAndPersistDBpediaGraphOccs(GraphFactory.getDBpediaGraph());
    }
 catch (    FileNotFoundException e) {
      throw new RuntimeException(e);
    }
  }
  logger.info(""String_Node_Str"");
  Stopwatch stopwatch=Stopwatch.createStarted();
  Kryo kryo=KryoMap.getDefault();
  Input input;
  try {
    input=new Input(new FileInputStream(file));
  }
 catch (  FileNotFoundException e) {
    throw new RuntimeException(e);
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Integer> map=kryo.readObject(input,HashMap.class);
  input.close();
  logger.info(""String_Node_Str"",stopwatch);
  return map;
}",0.3526999316473
26080,"public static void countAndPersistDBpediaGraphOccs() throws FileNotFoundException {
  logger.info(""String_Node_Str"");
  Graph graph=GraphFactory.getDBpediaGraph();
  Map<String,Integer> map=countGraphOccs(graph);
  graph.shutdown();
  KryoMap.serializeMap(map,GraphConfig.config());
}","public static void countAndPersistDBpediaGraphOccs(Graph graph) throws FileNotFoundException {
  logger.info(""String_Node_Str"");
  Map<String,Integer> map=countGraphOccs(graph);
  KryoMap.serializeMap(map,GraphConfig.config());
}",0.682261208576998
26081,"public static void main(String[] args) throws FileNotFoundException {
  countAndPersistDBpediaGraphOccs();
}","public static void main(String[] args) throws FileNotFoundException {
  Graph graph=GraphFactory.getDBpediaGraph();
  countAndPersistDBpediaGraphOccs(graph);
  graph.shutdown();
}",0.7526132404181185
26082,"/** 
 * Returns the batch graph instance that can be used for bulk inserting nodes and vertices into the dbpedia graph. If a persisted dbpedia graph exists already it is returned, otherwise a new graph is created.
 * @param bufferSize the buffer size used for the batch inserts.
 * @return
 */
public static BatchGraph<? extends TransactionalGraph> getBatchGraph(long bufferSize){
  TransactionalGraph graph=openGraph(false);
  BatchGraph<TransactionalGraph> bgraph=new BatchGraph<>(graph,VertexIDType.STRING,bufferSize);
  long verticesCount=Graphs.verticesCount(graph);
  if (verticesCount != 0) {
    bgraph.setLoadingFromScratch(false);
    logger.info(""String_Node_Str"",verticesCount);
  }
  return bgraph;
}","/** 
 * Returns the batch graph instance that can be used for bulk inserting nodes and vertices into the dbpedia graph. If a persisted dbpedia graph exists already it is returned, otherwise a new graph is created.
 * @param bufferSize the buffer size used for the batch inserts.
 * @return
 */
public static BatchGraph<? extends TransactionalGraph> getBatchGraph(long bufferSize){
  TransactionalGraph graph=openGraph(false);
  BatchGraph<TransactionalGraph> bgraph=new BatchGraph<>(graph,VertexIDType.STRING,bufferSize);
  long verticesCount=Graphs.verticesCount(graph);
  if (verticesCount != 0) {
    bgraph.setVertexIdKey(GraphConfig.URI_PROPERTY);
    bgraph.setLoadingFromScratch(false);
    logger.info(""String_Node_Str"",verticesCount);
  }
  return bgraph;
}",0.9641649763353616
26083,"@Override public Map<T,List<SurfaceFormSenseScore<T,U>>> bestK(Map<T,List<U>> surfaceFormsSenses,Graph subgraph,int k){
  logger.info(""String_Node_Str"",this);
  VertexScorer<Vertex,Double> vertexScorer=getVertexScorer(subgraph);
  Map<T,List<SurfaceFormSenseScore<T,U>>> senseScores=new HashMap<>();
  for (  T surfaceForm : surfaceFormsSenses.keySet()) {
    List<U> sFSenses=surfaceFormsSenses.get(surfaceForm);
    List<SurfaceFormSenseScore<T,U>> sfss=new ArrayList<>();
    for (    U sense : sFSenses) {
      Vertex v=Graphs.vertexByFullUri(subgraph,sense.fullUri());
      double score=(v == null) ? -1 : vertexScorer.getVertexScore(v);
      sfss.add(new SurfaceFormSenseScore<T,U>(surfaceForm,sense,score));
    }
    if (usePriorFallback && Collections.max(sfss,SurfaceFormSenseScore.ASCENDING_SCORE_COMPARATOR).getScore() == 0.0)     assignPriors(surfaceForm,sfss);
    Collections.sort(sfss,SurfaceFormSenseScore.DESCENDING_SCORE_COMPARATOR);
    int toIndex=k > sfss.size() ? sfss.size() : k;
    senseScores.put(surfaceForm,sfss.subList(0,toIndex));
  }
  return senseScores;
}","@Override public Map<T,List<SurfaceFormSenseScore<T,U>>> bestK(Map<T,List<U>> surfaceFormsSenses,Graph subgraph,int k){
  logger.info(""String_Node_Str"",this);
  VertexScorer<Vertex,Double> vertexScorer=getVertexScorer(subgraph);
  Map<T,List<SurfaceFormSenseScore<T,U>>> senseScores=new HashMap<>();
  for (  T surfaceForm : surfaceFormsSenses.keySet()) {
    List<U> sFSenses=surfaceFormsSenses.get(surfaceForm);
    List<SurfaceFormSenseScore<T,U>> sfss=new ArrayList<>();
    for (    U sense : sFSenses) {
      Vertex v=Graphs.vertexByFullUri(subgraph,sense.fullUri());
      double score=(v == null) ? -1 : vertexScorer.getVertexScore(v);
      sfss.add(new SurfaceFormSenseScore<T,U>(surfaceForm,sense,score));
    }
    if (usePriorFallback && !sfss.isEmpty() && Collections.max(sfss,SurfaceFormSenseScore.ASCENDING_SCORE_COMPARATOR).getScore() == 0.0)     assignPriors(surfaceForm,sfss);
    Collections.sort(sfss,SurfaceFormSenseScore.DESCENDING_SCORE_COMPARATOR);
    int toIndex=k > sfss.size() ? sfss.size() : k;
    senseScores.put(surfaceForm,sfss.subList(0,toIndex));
  }
  return senseScores;
}",0.991375397185656
26084,"public static void persistGraph(Graph graph,boolean normalize,String fileName){
  checkState(checkNotNull(fileName).length() > 0);
  long nanoStartTime=System.nanoTime();
  GraphMLWriter writer=new GraphMLWriter(graph);
  writer.setNormalize(normalize);
  try {
    Files.createParentDirs(new File(fileName));
    writer.outputGraph(fileName);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  logger.info(""String_Node_Str"",Counter.elapsedSecs(nanoStartTime));
}","public static void persistGraph(Graph graph,boolean normalize,String fileName){
  checkState(checkNotNull(fileName).length() > 0);
  long nanoStartTime=System.nanoTime();
  GraphMLWriter writer=new GraphMLWriter(graph);
  writer.setNormalize(normalize);
  try {
    Files.createParentDirs(new File(fileName));
    writer.outputGraph(fileName);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  logger.info(String.format(""String_Node_Str"",Counter.elapsedSecs(nanoStartTime)));
}",0.9848637739656912
26085,"public static void persistGraphInDirectory(Graph graph,boolean normalize,String dirName){
  String fileName=dirName + File.separator + ""String_Node_Str""+ DATE_FORMATTER.format(new Date() + ""String_Node_Str"");
  persistGraph(graph,normalize,fileName);
}","public static void persistGraphInDirectory(Graph graph,boolean normalize,String dirName){
  String fileName=dirName + File.separator + ""String_Node_Str""+ DATE_FORMATTER.format(new Date())+ ""String_Node_Str"";
  persistGraph(graph,normalize,fileName);
}",0.9184890656063618
26086,"@Override public Map<T,List<SurfaceFormSenseScore<T,U>>> bestK(Map<T,List<U>> surfaceFormsSenses,Graph subgraph,int k){
  logger.info(""String_Node_Str"",this);
  VertexScorer<Vertex,Double> vertexScorer=getVertexScorer(subgraph);
  Map<T,List<SurfaceFormSenseScore<T,U>>> senseScores=new HashMap<>();
  for (  T surfaceForm : surfaceFormsSenses.keySet()) {
    List<U> sFSenses=surfaceFormsSenses.get(surfaceForm);
    List<SurfaceFormSenseScore<T,U>> sfss=new ArrayList<>();
    for (    U sense : sFSenses) {
      Vertex v=Graphs.vertexByFullUri(subgraph,sense.fullUri());
      double score=(v == null) ? -1 : vertexScorer.getVertexScore(v);
      sfss.add(new SurfaceFormSenseScore<T,U>(surfaceForm,sense,score));
    }
    Collections.sort(sfss,SurfaceFormSenseScore.DESCENDING_SCORE_COMPARATOR);
    int toIndex=k > sfss.size() ? sfss.size() : k;
    senseScores.put(surfaceForm,sfss.subList(0,toIndex));
  }
  if (usePriorFallback)   handleSingletons(senseScores);
  return senseScores;
}","@Override public Map<T,List<SurfaceFormSenseScore<T,U>>> bestK(Map<T,List<U>> surfaceFormsSenses,Graph subgraph,int k){
  logger.info(""String_Node_Str"",this);
  VertexScorer<Vertex,Double> vertexScorer=getVertexScorer(subgraph);
  Map<T,List<SurfaceFormSenseScore<T,U>>> senseScores=new HashMap<>();
  for (  T surfaceForm : surfaceFormsSenses.keySet()) {
    List<U> sFSenses=surfaceFormsSenses.get(surfaceForm);
    List<SurfaceFormSenseScore<T,U>> sfss=new ArrayList<>();
    for (    U sense : sFSenses) {
      Vertex v=Graphs.vertexByFullUri(subgraph,sense.fullUri());
      double score=(v == null) ? -1 : vertexScorer.getVertexScore(v);
      sfss.add(new SurfaceFormSenseScore<T,U>(surfaceForm,sense,score));
    }
    if (usePriorFallback && Collections.max(sfss,SurfaceFormSenseScore.ASCENDING_SCORE_COMPARATOR).getScore() == 0.0)     assignPriors(surfaceForm,sfss);
    Collections.sort(sfss,SurfaceFormSenseScore.DESCENDING_SCORE_COMPARATOR);
    int toIndex=k > sfss.size() ? sfss.size() : k;
    senseScores.put(surfaceForm,sfss.subList(0,toIndex));
  }
  return senseScores;
}",0.8663152850982271
26087,"@Override public String toString(){
  return getClass().getSimpleName() + ""String_Node_Str"" + graphType.getDirection()+ ""String_Node_Str"";
}","@Override public String toString(){
  return getClass().getSimpleName() + ""String_Node_Str"" + graphType.getTraversalDirection()+ ""String_Node_Str"";
}",0.9688581314878892
26088,"@Override public Double getVertexScore(Vertex v){
  double degree=Graphs.vertexDegreeWeighted(v,graphType.getDirection(),edgeWeights);
  double centrality=degree / (verticesCount - 1);
  return centrality;
}","@Override public Double getVertexScore(Vertex v){
  double degree=Graphs.vertexDegreeWeighted(v,Direction.BOTH,edgeWeights);
  double centrality=degree / (verticesCount - 1);
  return centrality;
}",0.9504950495049505
26089,"@Override public Double getVertexScore(Vertex v){
  Scores scores=hits.getVertexScore(v);
  double authority=Iterables.size(v.getEdges(graphType.getDirection())) != 0 ? scores.authority : 0;
  return authority;
}","@Override public Double getVertexScore(Vertex v){
  Scores scores=hits.getVertexScore(v);
  double authority=Graphs.vertexHasNoNeighbours(v) ? 0 : scores.authority;
  return authority;
}",0.8140703517587939
26090,"public static boolean hasNoEdges(Graph graph){
  return !graph.getEdges().iterator().hasNext();
}","public static boolean hasNoEdges(Graph graph){
  return Iterables.isEmpty(graph.getEdges());
}",0.7958115183246073
26091,"public static boolean hasNoVertices(Graph graph){
  return !graph.getVertices().iterator().hasNext();
}","public static boolean hasNoVertices(Graph graph){
  return Iterables.isEmpty(graph.getVertices());
}",0.8078817733990148
26092,"@Override protected void dfs(Path path,Set<Vertex> targets,Graph subgraph,Set<Vertex> stopVertices){
  Deque<Path> stack=new ArrayDeque<>();
  stack.push(path);
  while (!stack.isEmpty()) {
    traversedNodes++;
    path=stack.pop();
    Vertex current=path.getLast();
    if (path.getEdges().size() > settings.maxDistance)     continue;
    if (targets.contains(current))     SubgraphConstructions.addPathToSubGraph(current,path,subgraph,settings.graphType);
    for (    Edge edge : current.getEdges(settings.graphType.getDirection())) {
      Vertex child=Graphs.oppositeVertexUnsafe(edge,current);
      if (settings.graphType.equals(GraphType.UNDIRECTED_GRAPH) && !settings.explorationThreshold.isBelowThreshold(child,edge))       continue;
      if (!path.getVertices().contains(child) && !stopVertices.contains(child)) {
        Path newPath=Path.newHop(path,edge,child);
        stack.push(newPath);
      }
    }
  }
}","@Override protected void dfs(Path path,Set<Vertex> targets,Graph subgraph,Set<Vertex> stopVertices){
  Deque<Path> stack=new ArrayDeque<>();
  stack.push(path);
  while (!stack.isEmpty()) {
    traversedNodes++;
    path=stack.pop();
    Vertex current=path.getLast();
    if (path.getEdges().size() > settings.maxDistance)     continue;
    if (targets.contains(current))     SubgraphConstructions.addPathToSubGraph(current,path,subgraph,settings.graphType);
    for (    Edge edge : current.getEdges(settings.graphType.getTraversalDirection())) {
      Vertex child=Graphs.oppositeVertexUnsafe(edge,current);
      if (settings.graphType.equals(GraphType.UNDIRECTED_GRAPH) && !settings.explorationThreshold.isBelowThreshold(child,edge))       continue;
      if (!path.getVertices().contains(child) && !stopVertices.contains(child)) {
        Path newPath=Path.newHop(path,edge,child);
        stack.push(newPath);
      }
    }
  }
}",0.9951690821256038
26093,"public static void main(String[] args) throws IOException, URISyntaxException {
  Graph graph=GraphFactory.getDBpediaGraph();
  for (  String fullUri : fullUris) {
    Vertex v=Graphs.vertexByUri(graph,URLDecoder.decode(fullUri,""String_Node_Str""));
    String id=(v == null) ? ""String_Node_Str"" : v.getId().toString();
    System.out.println(fullUri + ""String_Node_Str"" + id);
  }
  graph.shutdown();
}","public static void main(String[] args) throws IOException, URISyntaxException {
  Graph graph=GraphFactory.getDBpediaGraph();
  for (  String fullUri : fullUris) {
    Vertex v=Graphs.vertexByFullUri(graph,URLDecoder.decode(fullUri,""String_Node_Str""));
    String id=(v == null) ? ""String_Node_Str"" : v.getId().toString();
    System.out.println(fullUri + ""String_Node_Str"" + id);
  }
  graph.shutdown();
}",0.995049504950495
26094,"@Override public Map<T,List<SurfaceFormSenseScore<T,U>>> bestK(Map<T,List<U>> surfaceFormsSenses,Graph subgraph,int k){
  VertexScorer<Vertex,Double> vertexScorer=getVertexScorer(subgraph);
  Map<T,List<SurfaceFormSenseScore<T,U>>> senseScores=new HashMap<>();
  for (  T surfaceForm : surfaceFormsSenses.keySet()) {
    List<U> sFSenses=surfaceFormsSenses.get(surfaceForm);
    List<SurfaceFormSenseScore<T,U>> sFSS=new ArrayList<>();
    for (    U sense : sFSenses) {
      Vertex v=Graphs.vertexByUri(subgraph,sense.fullUri());
      double score=(v == null) ? -1 : vertexScorer.getVertexScore(v);
      sFSS.add(new SurfaceFormSenseScore<T,U>(surfaceForm,sense,score));
    }
    Collections.sort(sFSS,descendingScoreComparator);
    int toIndex=k > sFSS.size() ? sFSS.size() : k;
    senseScores.put(surfaceForm,sFSS.subList(0,toIndex));
  }
  return senseScores;
}","@Override public Map<T,List<SurfaceFormSenseScore<T,U>>> bestK(Map<T,List<U>> surfaceFormsSenses,Graph subgraph,int k){
  VertexScorer<Vertex,Double> vertexScorer=getVertexScorer(subgraph);
  Map<T,List<SurfaceFormSenseScore<T,U>>> senseScores=new HashMap<>();
  for (  T surfaceForm : surfaceFormsSenses.keySet()) {
    List<U> sFSenses=surfaceFormsSenses.get(surfaceForm);
    List<SurfaceFormSenseScore<T,U>> sFSS=new ArrayList<>();
    for (    U sense : sFSenses) {
      Vertex v=Graphs.vertexByFullUri(subgraph,sense.fullUri());
      double score=(v == null) ? -1 : vertexScorer.getVertexScore(v);
      sFSS.add(new SurfaceFormSenseScore<T,U>(surfaceForm,sense,score));
    }
    Collections.sort(sFSS,descendingScoreComparator);
    int toIndex=k > sFSS.size() ? sFSS.size() : k;
    senseScores.put(surfaceForm,sFSS.subList(0,toIndex));
  }
  return senseScores;
}",0.997709049255441
26095,"@Override public Double getVertexScore(Vertex v){
  Scores scores=hits.getVertexScore(v);
  double authority=Iterables.size(Graphs.connectedEdges(v,graphType)) != 0 ? scores.authority : 0;
  return authority;
}","@Override public Double getVertexScore(Vertex v){
  Scores scores=hits.getVertexScore(v);
  double authority=Iterables.size(v.getEdges(graphType.getDirection())) != 0 ? scores.authority : 0;
  return authority;
}",0.909952606635071
26096,"@Override public Double getVertexScore(Vertex v){
  HitsScores scores=hitsScores.get(v);
  double authority=Iterables.size(Graphs.connectedEdges(v,graphType)) != 0 ? scores.authority : 0;
  return authority;
}","@Override public Double getVertexScore(Vertex v){
  HitsScores scores=hitsScores.get(v);
  double authority=Iterables.size(v.getEdges(graphType.getDirection())) != 0 ? scores.authority : 0;
  return authority;
}",0.9095238095238096
26097,"private double calculateScoreSum(PageRank<Vertex,Edge> pageRank,Graph subgraph){
  double scoreSum=0;
  Iterable<Vertex> vertices=subgraph.getVertices();
  for (  Vertex v : vertices)   scoreSum+=pageRank.getVertexScore(v);
  return scoreSum;
}","private double calculateScoreSum(PageRank<Vertex,Edge> pageRank,Graph subgraph){
  double scoreSum=0;
  for (  Vertex v : subgraph.getVertices())   scoreSum+=pageRank.getVertexScore(v);
  return scoreSum;
}",0.8711111111111111
26098,"public static Iterable<Edge> connectedEdges(Vertex v,GraphType graphDirection){
switch (graphDirection) {
case DIRECTED_GRAPH:
    return v.getEdges(Direction.OUT);
case UNDIRECTED_GRAPH:
  return v.getEdges(Direction.BOTH);
default :
throw new IllegalArgumentException(""String_Node_Str"" + graphDirection);
}
}","public static Collection<Edge> connectedEdges(Vertex vertex,Direction direction,String... labels){
  Collection<Edge> edges;
  final Iterable<Edge> itty=vertex.getEdges(direction,labels);
  if (itty instanceof Collection)   edges=(Collection<Edge>)itty;
 else {
    edges=new ArrayList<Edge>();
    for (    final Edge edge : itty)     edges.add(edge);
  }
  return edges;
}",0.1520467836257309
26099,"/** 
 * Converts the uris to vertices. Omits uris that cannot be found in the provided graph.
 */
public static Set<Vertex> verticesByFullUris(Graph graph,Collection<String> fullUris){
  Set<Vertex> vertices=new HashSet<Vertex>();
  for (  String fullUri : fullUris) {
    Vertex v=vertexByUri(graph,fullUri);
    if (v != null)     vertices.add(v);
  }
  return vertices;
}","/** 
 * Converts the uris to vertices. Omits uris that cannot be found in the provided graph.
 */
public static Set<Vertex> verticesByFullUris(Graph graph,Collection<String> fullUris){
  Set<Vertex> vertices=new HashSet<Vertex>();
  for (  String fullUri : fullUris) {
    Vertex v=vertexByFullUri(graph,fullUri);
    if (v != null)     vertices.add(v);
  }
  return vertices;
}",0.9946808510638298
26100,"public static boolean isNodeOnPath(Vertex child,Collection<Edge> path){
  for (  Edge edge : path)   if (child.equals(edge.getVertex(Direction.IN)) || child.equals(edge.getVertex(Direction.OUT)))   return true;
  return false;
}","public static boolean isNodeOnPath(Vertex child,List<Edge> path){
  for (  Edge edge : path)   if (child.equals(edge.getVertex(Direction.IN)) || child.equals(edge.getVertex(Direction.OUT)))   return true;
  return false;
}",0.9688888888888888
26101,"public static Set<Vertex> verticesFromSenses(Graph graph,Collection<? extends Sense> senses){
  Set<Vertex> vertices=new HashSet<>(senses.size());
  for (  Sense sense : senses) {
    Vertex v=Graphs.vertexByUri(graph,sense.fullUri());
    if (v != null)     vertices.add(v);
  }
  return vertices;
}","public static Set<Vertex> verticesFromSenses(Graph graph,Collection<? extends Sense> senses){
  Set<Vertex> vertices=new HashSet<>(senses.size());
  for (  Sense sense : senses) {
    Vertex v=Graphs.vertexByFullUri(graph,sense.fullUri());
    if (v != null)     vertices.add(v);
  }
  return vertices;
}",0.9933774834437086
26102,"@Override protected void dfs(Path path,Set<Vertex> targets,Graph subgraph,Set<Vertex> stopVertices){
  Deque<Path> stack=new ArrayDeque<>();
  stack.push(path);
  while (!stack.isEmpty()) {
    traversedNodes++;
    path=stack.pop();
    Vertex current=path.getLast();
    if (path.getEdges().size() > settings.maxDistance)     continue;
    if (targets.contains(current))     SubgraphConstructions.addPathToSubGraph(current,path,subgraph,settings.graphType);
    for (    Edge edge : Graphs.connectedEdges(current,settings.graphType)) {
      Vertex child=Graphs.oppositeVertexUnsafe(edge,current);
      if (settings.graphType.equals(GraphType.UNDIRECTED_GRAPH) && !settings.explorationThreshold.isBelowThreshold(child,edge))       continue;
      if (!path.getVertices().contains(child) && !stopVertices.contains(child)) {
        Path newPath=Path.newHop(path,edge,child);
        stack.push(newPath);
      }
    }
  }
}","@Override protected void dfs(Path path,Set<Vertex> targets,Graph subgraph,Set<Vertex> stopVertices){
  Deque<Path> stack=new ArrayDeque<>();
  stack.push(path);
  while (!stack.isEmpty()) {
    traversedNodes++;
    path=stack.pop();
    Vertex current=path.getLast();
    if (path.getEdges().size() > settings.maxDistance)     continue;
    if (targets.contains(current))     SubgraphConstructions.addPathToSubGraph(current,path,subgraph,settings.graphType);
    for (    Edge edge : current.getEdges(settings.graphType.getDirection())) {
      Vertex child=Graphs.oppositeVertexUnsafe(edge,current);
      if (settings.graphType.equals(GraphType.UNDIRECTED_GRAPH) && !settings.explorationThreshold.isBelowThreshold(child,edge))       continue;
      if (!path.getVertices().contains(child) && !stopVertices.contains(child)) {
        Path newPath=Path.newHop(path,edge,child);
        stack.push(newPath);
      }
    }
  }
}",0.9730021598272138
26103,"private GraphConfig(){
  throw new AssertionError();
}","private GraphConfig(){
}",0.6153846153846154
26104,"public static String graphDirectory(){
  return config.getString(GRAPH_DIRECTORY_KEY);
}","public static String graphDirectory(){
  return config.getString(CONFIG_GRAPH_DIRECTORY);
}",0.9385474860335196
26105,"@Test public void testNewGlobalDisambiguator(){
  GlobalGraphDisambiguator<DefaultSurfaceForm,DefaultSense> disambiguator=GraphConfig.newGlobalDisambiguator(config,subgraphConstructionSettings,graphWeights);
  assertNotNull(disambiguator);
}","@Test public void testNewGlobalDisambiguator(){
  GlobalGraphDisambiguator<DefaultSurfaceForm,DefaultSense> disambiguator=GraphDisambiguatorFactory.newGlobalFromConfig(config,subgraphConstructionSettings,graphWeights);
  assertNotNull(disambiguator);
}",0.8843813387423936
26106,"@Test public void testNewLocalDisambiguator(){
  LocalGraphDisambiguator<DefaultSurfaceForm,DefaultSense> disambiguator=GraphConfig.newLocalDisambiguator(graphType,graphWeights);
  assertNotNull(disambiguator);
}","@Test public void testNewLocalDisambiguator(){
  LocalGraphDisambiguator<DefaultSurfaceForm,DefaultSense> disambiguator=GraphDisambiguatorFactory.newLocalFromConfig(config,graphType,graphWeights);
  assertNotNull(disambiguator);
}",0.8733031674208145
26107,"public static void main(String[] args) throws IOException, URISyntaxException {
  Graph graph=GraphFactory.getDBpediaGraph();
  for (  String uri : uris) {
    Vertex v=Graphs.vertexByUri(graph,URLDecoder.decode(uri,""String_Node_Str""));
    String id=(v == null) ? ""String_Node_Str"" : v.getId().toString();
    System.out.println(uri + ""String_Node_Str"" + id);
  }
  graph.shutdown();
}","public static void main(String[] args) throws IOException, URISyntaxException {
  Graph graph=GraphFactory.getDBpediaGraph();
  for (  String fullUri : fullUris) {
    Vertex v=Graphs.vertexByUri(graph,URLDecoder.decode(fullUri,""String_Node_Str""));
    String id=(v == null) ? ""String_Node_Str"" : v.getId().toString();
    System.out.println(fullUri + ""String_Node_Str"" + id);
  }
  graph.shutdown();
}",0.9695431472081218
26108,"public AbstractLocalGraphDisambiguator(GraphType graphType,EdgeWeights graphWeights){
  this.graphType=graphType;
  this.graphWeights=graphWeights;
}","public AbstractLocalGraphDisambiguator(GraphType graphType,EdgeWeights edgeWeights){
  this.graphType=graphType;
  this.edgeWeights=edgeWeights;
}",0.928813559322034
26109,"@Override public double globalConnectivityMeasure(Graph sensegraph){
  Graphs.checkHasVertices(sensegraph);
  if (Graphs.hasNoEdges(sensegraph))   return 0;
  GraphJung<Graph> graphJung=Graphs.asGraphJung(subgraphConstructionSettings.graphType,sensegraph);
  Distance<Vertex> distances=new UnweightedShortestPath<>(graphJung);
  int sumDistances=0;
  for (  Vertex source : sensegraph.getVertices()) {
    Map<Vertex,Number> distancesFromSource=distances.getDistanceMap(source);
    for (    Vertex target : sensegraph.getVertices()) {
      Number distance=distancesFromSource.get(target);
      sumDistances+=distance == null ? 0 : distance.intValue();
    }
  }
  int totalVertices=Graphs.verticesCount(sensegraph);
  int min=totalVertices * (totalVertices - 1);
  int K=totalVertices;
  int max=K * min;
  double compactness=((double)(max - sumDistances)) / (max - min);
  return compactness;
}","@Override public double globalConnectivityMeasure(Graph sensegraph){
  Graphs.checkHasVertices(sensegraph);
  if (Graphs.hasNoEdges(sensegraph))   return 0;
  GraphJung<Graph> graphJung=Graphs.asGraphJung(subgraphConstructionSettings.graphType,sensegraph);
  Distance<Vertex> distances=new DijkstraDistance<>(graphJung,edgeWeights);
  double sumDistances=0;
  for (  Vertex source : sensegraph.getVertices()) {
    Map<Vertex,Number> distancesFromSource=distances.getDistanceMap(source);
    for (    Vertex target : sensegraph.getVertices()) {
      Number distance=distancesFromSource.get(target);
      sumDistances+=distance == null ? 0.0 : distance.doubleValue();
    }
  }
  int totalVertices=Graphs.verticesCount(sensegraph);
  int min=totalVertices * (totalVertices - 1);
  int K=totalVertices;
  int max=K * min;
  double compactness=(max - sumDistances) / (max - min);
  return compactness;
}",0.95
26110,"@Override public double globalConnectivityMeasure(Graph sensegraph){
  Graphs.checkHasVertices(sensegraph);
  int totalVertices=Graphs.verticesCount(sensegraph);
  int totalEdges=Graphs.edgesCount(sensegraph);
  double edgesCompleteGraph=(totalVertices * (totalVertices - 1)) / 2.0;
  return totalEdges / edgesCompleteGraph;
}","@Override public double globalConnectivityMeasure(Graph sensegraph){
  Graphs.checkHasVertices(sensegraph);
  int totalVertices=Graphs.verticesCount(sensegraph);
  double totalEdgesWeighted=Graphs.edgesCountWeighted(sensegraph,edgeWeights);
  double edgesCompleteGraph=(totalVertices * (totalVertices - 1)) / 2.0;
  return totalEdgesWeighted / edgesCompleteGraph;
}",0.9030390738060782
26111,"@Override public double globalConnectivityMeasure(Graph sensegraph){
  Graphs.checkHasVertices(sensegraph);
  int totalVertices=Graphs.verticesCount(sensegraph);
  int totalEdges=Graphs.edgesCount(sensegraph);
  if (totalEdges == 0)   return 0;
  double graphEntropy=0;
  for (  Vertex vertex : sensegraph.getVertices()) {
    double degree=Graphs.vertexDegreeWeighted(vertex,Direction.BOTH,edgeWeights);
    if (degree != 0) {
      double vertexProbability=degree / (2.0 * totalEdges);
      graphEntropy+=vertexProbability * Math.log(vertexProbability);
    }
  }
  graphEntropy*=-1;
  graphEntropy/=Math.log(totalVertices);
  return graphEntropy;
}","@Override public double globalConnectivityMeasure(Graph sensegraph){
  Graphs.checkHasVertices(sensegraph);
  int totalVertices=Graphs.verticesCount(sensegraph);
  double totalEdgesWeighted=Graphs.edgesCountWeighted(sensegraph,edgeWeights);
  if (totalEdgesWeighted == 0)   return 0;
  double graphEntropy=0;
  for (  Vertex vertex : sensegraph.getVertices()) {
    double degree=Graphs.vertexDegreeWeighted(vertex,Direction.BOTH,edgeWeights);
    if (degree != 0) {
      double vertexProbability=degree / (2.0 * totalEdgesWeighted);
      graphEntropy+=vertexProbability * Math.log(vertexProbability);
    }
  }
  graphEntropy*=-1;
  graphEntropy/=Math.log(totalVertices);
  return graphEntropy;
}",0.92820133234641
26112,"public BetweennessVertexScorer(Graph subgraph){
  GraphJung<Graph> graphJung=Graphs.asGraphJung(graphType,subgraph);
  betweenness=new edu.uci.ics.jung.algorithms.scoring.BetweennessCentrality<Vertex,Edge>(graphJung);
  verticesCount=Graphs.verticesCount(subgraph);
}","public BetweennessVertexScorer(Graph subgraph){
  GraphJung<Graph> graphJung=Graphs.asGraphJung(graphType,subgraph);
  betweenness=new edu.uci.ics.jung.algorithms.scoring.BetweennessCentrality<Vertex,Edge>(graphJung,edgeWeights);
  verticesCount=Graphs.verticesCount(subgraph);
}",0.978021978021978
26113,"@Override public Double getVertexScore(Vertex v){
  double degree=Graphs.vertexDegreeWeighted(v,graphType.getDirection(),graphWeights);
  double centrality=degree / (verticesCount - 1);
  return centrality;
}","@Override public Double getVertexScore(Vertex v){
  double degree=Graphs.vertexDegreeWeighted(v,graphType.getDirection(),edgeWeights);
  double centrality=degree / (verticesCount - 1);
  return centrality;
}",0.9783132530120482
26114,"public HITSVertexScorer(Graph subgraph){
  GraphJung<Graph> graphJung=Graphs.asGraphJung(graphType,subgraph);
  hits=new HITS<Vertex,Edge>(graphJung,alpha);
  hits.acceptDisconnectedGraph(true);
  hits.setMaxIterations(iterations);
  hits.evaluate();
}","public HITSVertexScorer(Graph subgraph){
  GraphJung<Graph> graphJung=Graphs.asGraphJung(graphType,subgraph);
  hits=new HITS<Vertex,Edge>(graphJung,edgeWeights,alpha);
  hits.acceptDisconnectedGraph(true);
  hits.setMaxIterations(iterations);
  hits.evaluate();
}",0.9767441860465116
26115,"@Override public Double getVertexScore(Vertex v){
  Scores scores=hits.getVertexScore(v);
  double authority=CollectionUtils.iterableItemCount(Graphs.connectedEdges(v,graphType)) != 0 ? scores.authority : 0;
  return authority;
}","@Override public Double getVertexScore(Vertex v){
  Scores scores=hits.getVertexScore(v);
  double authority=Iterables.size(Graphs.connectedEdges(v,graphType)) != 0 ? scores.authority : 0;
  return authority;
}",0.9066059225512528
26116,"/** 
 * Get a   {@link Predicate} implementation from config.
 * @param config A configuration object where the  {@link LoadingType} is looked up.
 * @return A {@link Predicate} instance.
 */
static Predicate<Statement> fromConfig(final Configuration config){
  List<LoadingType> loadingTypes=loadingTypesFromConfig(config);
  if (loadingTypes == null || loadingTypes.isEmpty())   return DUMMY_PREDICATE;
  return fromLoadingTypes(loadingTypes);
}","/** 
 * Get a   {@link Predicate} implementation from config.
 * @param config A configuration object where the  {@link LoadingType} is looked up.
 * @return A {@link Predicate} instance.
 */
static Predicate<Statement> fromConfig(final Configuration config){
  List<LoadingType> loadingTypes=LoadingType.fromConfig(config);
  if (loadingTypes == null || loadingTypes.isEmpty())   return DUMMY_PREDICATE;
  return fromLoadingTypes(loadingTypes);
}",0.970917225950783
26117,"public static EdgeWeight getDBpediaImpl(Configuration config){
  EdgeWeightType edgeWeightType=EdgeWeightType.fromConfig(config);
switch (edgeWeightType) {
case COMB_IC:
    return new CombinedInformationContent(occCounts);
case IC_PMI:
  return new InfContentAndPointwiseMutuaInf(occCounts);
case JOINT_IC:
return new JointInformationContent(occCounts);
default :
throw new IllegalArgumentException(""String_Node_Str"" + edgeWeightType);
}
}","public static EdgeWeight getDBpediaImpl(Configuration config){
  EdgeWeightType edgeWeightType=EdgeWeightType.fromConfig(config);
switch (edgeWeightType) {
case COMB_IC:
    return new CombinedInformationContent(occCounts);
case IC_PMI:
  return new InfContentAndPointwiseMutuaInf(occCounts);
case JOINT_IC:
return new JointInformationContent(occCounts);
}
throw new IllegalArgumentException(""String_Node_Str"" + EdgeWeightType.class.getSimpleName() + ""String_Node_Str""+ edgeWeightType);
}",0.9245689655172412
26118,"@Test public void testConfig2LoadingTypes(){
  List<LoadingType> loadingTypes=StatementPredicateFactory.loadingTypesFromConfig(config2);
  assertTrue(loadingTypes.size() == 1);
  assertTrue(loadingTypes.get(0).equals(LoadingType.COMPLETE));
}","@Test public void testConfig2LoadingTypes(){
  List<LoadingType> loadingTypes=StatementPredicateFactory.LoadingType.fromConfig(config2);
  assertTrue(loadingTypes.size() == 1);
  assertTrue(loadingTypes.get(0).equals(LoadingType.COMPLETE));
}",0.9462809917355371
26119,"@Test public void testConfig3LoadingTypes(){
  List<LoadingType> loadingTypes=StatementPredicateFactory.loadingTypesFromConfig(config3);
  assertTrue(loadingTypes.size() == 0);
}","@Test public void testConfig3LoadingTypes(){
  List<LoadingType> loadingTypes=StatementPredicateFactory.LoadingType.fromConfig(config3);
  assertTrue(loadingTypes.size() == 0);
}",0.9831460674157304
26120,"@Test public void testConfig1LoadingTypes(){
  List<LoadingType> loadingTypes=StatementPredicateFactory.loadingTypesFromConfig(config1);
  assertTrue(loadingTypes.size() == 2);
  assertTrue(loadingTypes.get(0).equals(LoadingType.BLACKLIST));
  assertTrue(loadingTypes.get(1).equals(LoadingType.COMPLETE));
}","@Test public void testConfig1LoadingTypes(){
  List<LoadingType> loadingTypes=StatementPredicateFactory.LoadingType.fromConfig(config1);
  assertTrue(loadingTypes.size() == 2);
  assertTrue(loadingTypes.get(0).equals(LoadingType.BLACKLIST));
  assertTrue(loadingTypes.get(1).equals(LoadingType.COMPLETE));
}",0.9576547231270358
26121,"BlacklistStatementPredicate(){
  Configuration conf=GraphConfig.config();
  categories=new HashSet<String>();
  predicates=new HashSet<String>();
  String categoriesFileName=conf.getString(KEY_CATEGORIES_FILE);
  try {
    categories.addAll(FileUtils.readNonEmptyNonCommentLinesFromFile(getClass(),categoriesFileName));
  }
 catch (  URISyntaxException|IOException e) {
    logger.warn(""String_Node_Str"",e);
  }
  String predicatesFileName=conf.getString(KEY_PREDICATES_FILE);
  try {
    predicates.addAll(FileUtils.readNonEmptyNonCommentLinesFromFile(getClass(),predicatesFileName));
  }
 catch (  URISyntaxException|IOException e) {
    logger.warn(""String_Node_Str"",e);
  }
}","BlacklistStatementPredicate(Configuration config){
  categories=new HashSet<String>();
  predicates=new HashSet<String>();
  String categoriesFileName=config.getString(CONFIG_CATEGORIES_FILE);
  try {
    categories.addAll(FileUtils.readNonEmptyNonCommentLinesFromFile(getClass(),categoriesFileName));
  }
 catch (  URISyntaxException|IOException e) {
    logger.warn(""String_Node_Str"",e);
  }
  String predicatesFileName=config.getString(CONFIG_PREDICATES_FILE);
  try {
    predicates.addAll(FileUtils.readNonEmptyNonCommentLinesFromFile(getClass(),predicatesFileName));
  }
 catch (  URISyntaxException|IOException e) {
    logger.warn(""String_Node_Str"",e);
  }
}",0.7613382899628253
26122,"@Override public void run(){
  if (db != null) {
    logger.info(""String_Node_Str"");
    db.close();
  }
}","@Override public void run(){
  if (db instanceof PersistentMap) {
    logger.info(""String_Node_Str"");
    db.close();
  }
}",0.8820960698689956
26123,"static PersistentMap<String,Integer> loadPersistentOccCountsMap(Configuration config,boolean clear,boolean readOnly){
  long startTime=System.currentTimeMillis();
  String dbName=""String_Node_Str"";
  String location=config.getString(""String_Node_Str"");
  final PersistentMap<String,Integer> db=new BerkeleyDB.Builder<>(new File(location),dbName,String.class,Integer.class).readOnly(readOnly).build();
  if (clear)   db.clear();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      if (db != null) {
        logger.info(""String_Node_Str"");
        db.close();
      }
    }
  }
);
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime) / 1000.0);
  return db;
}","static PersistentMap<String,Integer> loadPersistentOccCountsMap(Configuration config,boolean clear,boolean readOnly){
  long startTime=System.currentTimeMillis();
  String dbName=""String_Node_Str"";
  String location=config.getString(""String_Node_Str"");
  final PersistentMap<String,Integer> db=new BerkeleyDB.Builder<>(new File(location),dbName,String.class,Integer.class).readOnly(readOnly).build();
  if (clear)   db.clear();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      if (db instanceof PersistentMap) {
        logger.info(""String_Node_Str"");
        db.close();
      }
    }
  }
);
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime) / 1000.0);
  return db;
}",0.9786354238456236
26124,"@BeforeClass public static void beforeClass(){
  predicate=new BlacklistStatementPredicate();
  invalidSubject=fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  invalidObject=fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  validStatement=fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@BeforeClass public static void beforeClass(){
  predicate=new BlacklistStatementPredicate(GraphConfig.config());
  invalidSubject=fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  invalidObject=fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  validStatement=fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.9728260869565216
26125,"@Override public String transform(Edge edge){
  String uriProp=edge.getProperty(GraphConfig.URI_PROPERTY);
  return uriProp != null ? uriProp : ""String_Node_Str"";
}","@Override public String transform(Edge edge){
  return Graphs.edgeToString(edge);
}",0.5506072874493927
26126,"private static void visualizeGraph(Graph graph,String frameTitle){
  GraphJung<Graph> graphJung=new GraphJung<>(graph);
  Layout<Vertex,Edge> layout=new ISOMLayout<Vertex,Edge>(graphJung);
  layout.setSize(SCREEN_DIMENSION);
  BasicVisualizationServer<Vertex,Edge> viz=new BasicVisualizationServer<Vertex,Edge>(layout);
  viz.setPreferredSize(SCREEN_DIMENSION);
  Transformer<Vertex,String> vertexLabelTransformer=new Transformer<Vertex,String>(){
    @Override public String transform(    Vertex vertex){
      return vertex.getProperty(GraphConfig.URI_PROPERTY).toString();
    }
  }
;
  Transformer<Edge,String> edgeLabelTransformer=new Transformer<Edge,String>(){
    @Override public String transform(    Edge edge){
      String uriProp=edge.getProperty(GraphConfig.URI_PROPERTY);
      return uriProp != null ? uriProp : ""String_Node_Str"";
    }
  }
;
  viz.getRenderContext().setEdgeLabelTransformer(edgeLabelTransformer);
  viz.getRenderContext().setVertexLabelTransformer(vertexLabelTransformer);
  JFrame frame=new JFrame(frameTitle);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.getContentPane().add(viz);
  frame.pack();
  frame.setVisible(true);
}","private static void visualizeGraph(Graph graph,String frameTitle){
  GraphJung<Graph> graphJung=new GraphJung<>(graph);
  Layout<Vertex,Edge> layout=new ISOMLayout<Vertex,Edge>(graphJung);
  layout.setSize(SCREEN_DIMENSION);
  BasicVisualizationServer<Vertex,Edge> viz=new BasicVisualizationServer<Vertex,Edge>(layout);
  viz.setPreferredSize(SCREEN_DIMENSION);
  Transformer<Vertex,String> vertexLabelTransformer=new Transformer<Vertex,String>(){
    @Override public String transform(    Vertex vertex){
      return vertex.getProperty(GraphConfig.URI_PROPERTY).toString();
    }
  }
;
  Transformer<Edge,String> edgeLabelTransformer=new Transformer<Edge,String>(){
    @Override public String transform(    Edge edge){
      return Graphs.edgeToString(edge);
    }
  }
;
  viz.getRenderContext().setEdgeLabelTransformer(edgeLabelTransformer);
  viz.getRenderContext().setVertexLabelTransformer(vertexLabelTransformer);
  JFrame frame=new JFrame(frameTitle);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.getContentPane().add(viz);
  frame.pack();
  frame.setVisible(true);
}",0.9389010989010989
26127,"public AbstractGlobalGraphDisambiguator(SubgraphConstructionSettings subgraphConstructionSettings,GraphWeights graphWeights){
  this.subgraphConstructionSettings=subgraphConstructionSettings;
  this.graphWeights=graphWeights;
}","public AbstractGlobalGraphDisambiguator(SubgraphConstructionSettings subgraphConstructionSettings,EdgeWeight graphWeights){
  this.subgraphConstructionSettings=subgraphConstructionSettings;
  this.graphWeights=graphWeights;
}",0.9513274336283186
26128,"public AbstractLocalGraphDisambiguator(GraphType graphType,GraphWeights graphWeights){
  this.graphType=graphType;
  this.graphWeights=graphWeights;
}","public AbstractLocalGraphDisambiguator(GraphType graphType,EdgeWeight graphWeights){
  this.graphType=graphType;
  this.graphWeights=graphWeights;
}",0.9664429530201344
26129,"public Compactness(SubgraphConstructionSettings settings,GraphWeights graphWeights){
  super(settings,graphWeights);
}","public Compactness(SubgraphConstructionSettings settings,EdgeWeight graphWeights){
  super(settings,graphWeights);
}",0.9572649572649572
26130,"public EdgeDensity(SubgraphConstructionSettings settings,GraphWeights graphWeights){
  super(settings,graphWeights);
}","public EdgeDensity(SubgraphConstructionSettings settings,EdgeWeight graphWeights){
  super(settings,graphWeights);
}",0.9572649572649572
26131,"public GraphEntropy(SubgraphConstructionSettings settings,GraphWeights graphWeights){
  super(settings,graphWeights);
}","public GraphEntropy(SubgraphConstructionSettings settings,EdgeWeight graphWeights){
  super(settings,graphWeights);
}",0.9576271186440678
26132,"public BetweennessCentrality(GraphType graphType,GraphWeights graphWeights){
  super(graphType,graphWeights);
}","public BetweennessCentrality(GraphType graphType,EdgeWeight graphWeights){
  super(graphType,graphWeights);
}",0.9545454545454546
26133,"public DegreeCentrality(GraphType graphType,GraphWeights graphWeights){
  super(graphType,graphWeights);
}","public DegreeCentrality(GraphType graphType,EdgeWeight graphWeights){
  super(graphType,graphWeights);
}",0.9523809523809524
26134,"public HITSCentrality(GraphType graphType,GraphWeights graphWeights){
  this(graphType,graphWeights,DEFAULT_ALPHA,DEFAULT_ITERATIONS);
}","public HITSCentrality(GraphType graphType,EdgeWeight graphWeights){
  this(graphType,graphWeights,DEFAULT_ALPHA,DEFAULT_ITERATIONS);
}",0.9629629629629628
26135,"public KPPCentrality(GraphType graphType,GraphWeights graphWeights){
  super(graphType,graphWeights);
}","public KPPCentrality(GraphType graphType,EdgeWeight graphWeights){
  super(graphType,graphWeights);
}",0.9509803921568628
26136,"public PageRankCentrality(GraphType graphType,GraphWeights graphWeights){
  this(graphType,graphWeights,DEFAULT_ALPHA,DEFAULT_ITERATIONS);
}","public PageRankCentrality(GraphType graphType,EdgeWeight graphWeights){
  this(graphType,graphWeights,DEFAULT_ALPHA,DEFAULT_ITERATIONS);
}",0.9640287769784172
26137,"@SuppressWarnings(""String_Node_Str"") public static <T extends SurfaceForm,U extends Sense>LocalGraphDisambiguator<T,U> newLocalDisambiguator(GraphType graphType,GraphWeights graphWeights){
  String disambiguatorClassName=config.getString(LOCAL_DISAMBIGUATOR_KEY,DEFAULT_LOCAL_DISAMBIGUATOR);
  try {
    @SuppressWarnings(""String_Node_Str"") Class<? extends LocalGraphDisambiguator> localDisambiguatorClass=Class.forName(disambiguatorClassName).asSubclass(LocalGraphDisambiguator.class);
    return localDisambiguatorClass.getConstructor(GraphType.class,GraphWeights.class).newInstance(graphType,graphWeights);
  }
 catch (  ClassNotFoundException|NoSuchMethodException|SecurityException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@SuppressWarnings(""String_Node_Str"") public static <T extends SurfaceForm,U extends Sense>LocalGraphDisambiguator<T,U> newLocalDisambiguator(GraphType graphType,EdgeWeight graphWeights){
  String disambiguatorClassName=config.getString(LOCAL_DISAMBIGUATOR_KEY,DEFAULT_LOCAL_DISAMBIGUATOR);
  try {
    @SuppressWarnings(""String_Node_Str"") Class<? extends LocalGraphDisambiguator> localDisambiguatorClass=Class.forName(disambiguatorClassName).asSubclass(LocalGraphDisambiguator.class);
    return localDisambiguatorClass.getConstructor(GraphType.class,EdgeWeight.class).newInstance(graphType,graphWeights);
  }
 catch (  ClassNotFoundException|NoSuchMethodException|SecurityException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9881656804733728
26138,"@SuppressWarnings(""String_Node_Str"") public static <T extends SurfaceForm,U extends Sense>GlobalGraphDisambiguator<T,U> newGlobalDisambiguator(Configuration configuration,SubgraphConstructionSettings subgraphConstructionSettings,GraphWeights graphWeights){
  String disambiguatorClassName=config.getString(GLOBAL_DISAMBIGUATOR_KEY,DEFAULT_GLOBAL_DISAMBIGUATOR);
  try {
    @SuppressWarnings(""String_Node_Str"") Class<? extends GlobalGraphDisambiguator> globalDisambiguatorClass=Class.forName(disambiguatorClassName).asSubclass(GlobalGraphDisambiguator.class);
    return globalDisambiguatorClass.getConstructor(SubgraphConstructionSettings.class,GraphWeights.class).newInstance(subgraphConstructionSettings,graphWeights);
  }
 catch (  ClassNotFoundException|NoSuchMethodException|SecurityException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@SuppressWarnings(""String_Node_Str"") public static <T extends SurfaceForm,U extends Sense>GlobalGraphDisambiguator<T,U> newGlobalDisambiguator(Configuration configuration,SubgraphConstructionSettings subgraphConstructionSettings,EdgeWeight graphWeights){
  String disambiguatorClassName=config.getString(GLOBAL_DISAMBIGUATOR_KEY,DEFAULT_GLOBAL_DISAMBIGUATOR);
  try {
    @SuppressWarnings(""String_Node_Str"") Class<? extends GlobalGraphDisambiguator> globalDisambiguatorClass=Class.forName(disambiguatorClassName).asSubclass(GlobalGraphDisambiguator.class);
    return globalDisambiguatorClass.getConstructor(SubgraphConstructionSettings.class,EdgeWeight.class).newInstance(subgraphConstructionSettings,graphWeights);
  }
 catch (  ClassNotFoundException|NoSuchMethodException|SecurityException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9895506792058516
26139,"public static Set<String> urisOfVertices(Iterable<Vertex> vertices){
  Set<String> uris=new HashSet<>();
  for (  Vertex v : vertices)   uris.add(uriOfVertex(v));
  return uris;
}","public static Set<String> urisOfVertices(Iterable<Vertex> vertices){
  Set<String> uris=new HashSet<>();
  for (  Vertex v : vertices)   uris.add(shortUriOfVertex(v));
  return uris;
}",0.9807162534435262
26140,"private static void addEdgeIfNonExistentUnsafe(Graph graph,Edge edge,Vertex outVertex,Vertex inVertex){
  if (graph.getEdge(edge.getId()) == null)   graph.addEdge(edge.getId(),outVertex,inVertex,edge.getLabel());
}","private static void addEdgeIfNonExistentUnsafe(Graph graph,Edge edge,Vertex outVertex,Vertex inVertex){
  if (graph.getEdge(edge.getId()) == null) {
    Edge newEdge=graph.addEdge(edge.getId(),outVertex,inVertex,edge.getLabel());
    newEdge.setProperty(GraphConfig.URI_PROPERTY,edge.getProperty(GraphConfig.URI_PROPERTY));
  }
}",0.7808471454880295
26141,"public static boolean isVertexInGraph(Vertex v,Graph graph){
  String uri=Graphs.uriOfVertex(v);
  Vertex graphVertex=vertexByUri(graph,uri);
  return graphVertex != null;
}","public static boolean isVertexInGraph(Vertex v,Graph graph){
  String uri=Graphs.shortUriOfVertex(v);
  Vertex graphVertex=vertexByUri(graph,uri);
  return graphVertex != null;
}",0.98005698005698
26142,"@Deprecated public static boolean equalByUri(Vertex v1,Vertex v2){
  return uriOfVertex(v1).equals(uriOfVertex(v2));
}","@Deprecated public static boolean equalByUri(Vertex v1,Vertex v2){
  return shortUriOfVertex(v1).equals(shortUriOfVertex(v2));
}",0.943089430894309
26143,"/** 
 * Main method.
 * @param args each arg can be a directory containing RDF files or a RDF file itself.
 */
public static void main(String[] args) throws ConfigurationException {
  DBpediaGraphLoader.loadFromFiles(FileUtils.extractFilesFromArgs(args));
  PredObjOccsCounter.countDBpediaGraphOccsIntoDB();
}","/** 
 * Main method.
 * @param args each arg can be a directory containing RDF files or a RDF file itself.
 */
public static void main(String[] args) throws ConfigurationException {
  DBpediaGraphLoader.loadFromFiles(FileUtils.extractFilesFromArgs(args));
  PredObjOccsCounter.countAndPersistDBpediaGraphOccs();
}",0.9742765273311896
26144,"@Override public String toString(){
  return new StringBuilder().append(""String_Node_Str"").append(Graphs.uriOfVertex(start)).append(""String_Node_Str"").append(Graphs.uriOfVertex(last)).append(""String_Node_Str"").append(edges).toString();
}","@Override public String toString(){
  return new StringBuilder().append(""String_Node_Str"").append(Graphs.shortUriOfVertex(start)).append(""String_Node_Str"").append(Graphs.shortUriOfVertex(last)).append(""String_Node_Str"").append(edges).toString();
}",0.9710743801652892
26145,"@Override public void handleStatement(Statement st){
  Triple triple=Triple.fromStatement(st);
  if (!tripleFilter.apply(triple)) {
    invalidTriples++;
  }
 else {
    validTriples++;
    String subject=UriTransformer.shorten(triple.subject());
    String predicate=UriTransformer.shorten(triple.predicate());
    String object=UriTransformer.shorten(triple.object());
    Vertex out=addVertexByUriBatchIfNonExistent(subject);
    Vertex in=addVertexByUriBatchIfNonExistent(object);
    Edge e=bgraph.addEdge(null,out,in,GraphConfig.EDGE_LABEL);
    e.setProperty(GraphConfig.URI_PROPERTY,predicate);
  }
  long totalTriples=validTriples + invalidTriples;
  if (totalTriples % TICK_SIZE == 0) {
    long timeDelta=(System.currentTimeMillis() - tick);
    logger.info(String.format(""String_Node_Str"",totalTriples,validTriples,invalidTriples,timeDelta / 1000.0,TICK_SIZE));
    tick=System.currentTimeMillis();
  }
}","@Override public void handleStatement(Statement st){
  if (st.getObject() instanceof Literal)   invalidTriples++;
 else {
    Triple triple=Triple.fromStatement(st);
    if (!tripleFilter.apply(triple))     invalidTriples++;
 else {
      validTriples++;
      String subject=UriTransformer.shorten(triple.subject());
      String predicate=UriTransformer.shorten(triple.predicate());
      String object=UriTransformer.shorten(triple.object());
      Vertex out=addVertexByUriBatchIfNonExistent(subject);
      Vertex in=addVertexByUriBatchIfNonExistent(object);
      Edge e=bgraph.addEdge(null,out,in,GraphConfig.EDGE_LABEL);
      e.setProperty(GraphConfig.URI_PROPERTY,predicate);
    }
  }
  long totalTriples=validTriples + invalidTriples;
  if (totalTriples % TICK_SIZE == 0) {
    long timeDelta=(System.currentTimeMillis() - tick);
    logger.info(String.format(""String_Node_Str"",totalTriples,validTriples,invalidTriples,timeDelta / 1000.0,TICK_SIZE));
    tick=System.currentTimeMillis();
  }
}",0.8682977615825092
26146,"public Triple(String subject,String predicate,String object){
  this.subject=UriTransformer.decode(subject);
  this.predicate=UriTransformer.decode(predicate);
  this.object=UriTransformer.decode(object);
}","Triple(Resource subject,URI predicate,Value object){
  this.subject=UriTransformer.decode(subject.stringValue());
  this.predicate=UriTransformer.decode(predicate.stringValue());
  if (object instanceof Literal)   this.object=object.stringValue();
 else   this.object=UriTransformer.decode(object.stringValue());
}",0.6038461538461538
26147,"public String predicate(){
  return predicate;
}","String predicate(){
  return predicate;
}",0.9213483146067416
26148,"public String subject(){
  return subject;
}","String subject(){
  return subject;
}",0.9135802469135802
26149,"public static Triple fromStatement(Statement st){
  return new Triple(st.getSubject().stringValue(),st.getPredicate().stringValue(),st.getObject().stringValue());
}","static Triple fromStatement(Statement st){
  return new Triple(st.getSubject(),st.getPredicate(),st.getObject());
}",0.8243727598566308
26150,"public String object(){
  return object;
}","String object(){
  return object;
}",0.9090909090909092
26151,"@BeforeClass public static void beforeClass(){
  predicate=new BlacklistTriplePredicate(GraphConfig.config());
  invalidSubject=new Triple(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  invalidObject=new Triple(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  validTriple=new Triple(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@BeforeClass public static void beforeClass(){
  predicate=new BlacklistTriplePredicate(GraphConfig.config());
  invalidSubject=Triple.fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  invalidObject=Triple.fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  validTriple=Triple.fromStringUris(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.8764940239043825
26152,"private static void checkUri(String fullUriEncoded,String fullUriDecoded){
  Triple t=new Triple(fullUriEncoded,fullUriEncoded,fullUriEncoded);
  assertEquals(fullUriDecoded,t.subject());
  assertEquals(fullUriDecoded,t.predicate());
  assertEquals(fullUriDecoded,t.object());
}","private static void checkUri(String fullUriEncoded,String fullUriDecoded){
  Triple t=Triple.fromStringUris(fullUriEncoded,fullUriEncoded,fullUriEncoded);
  assertEquals(fullUriDecoded,t.subject());
  assertEquals(fullUriDecoded,t.predicate());
  assertEquals(fullUriDecoded,t.object());
}",0.9664902998236332
26153,"private void createDBEnvironment(final File location){
  if (!location.exists())   location.mkdirs();
  try {
    final EnvironmentConfig envConfig=new EnvironmentConfig();
    envConfig.setCachePercent(60);
    envConfig.setAllowCreate(true);
    envConfig.setConfigParam(EnvironmentConfig.LOG_FILE_MAX,""String_Node_Str"");
    this.dbEnv=new Environment(location,envConfig);
  }
 catch (  DatabaseException dbe) {
    dbe.printStackTrace();
  }
}","private void createDBEnvironment(final File location,boolean allowCreate){
  if (!location.exists())   location.mkdirs();
  try {
    final EnvironmentConfig envConfig=new EnvironmentConfig();
    envConfig.setAllowCreate(allowCreate);
    envConfig.setConfigParam(EnvironmentConfig.LOG_FILE_MAX,""String_Node_Str"");
    this.dbEnv=new Environment(location,envConfig);
  }
 catch (  DatabaseException dbe) {
    dbe.printStackTrace();
  }
}",0.9232505643340858
26154,"public BerkeleyDB<K,V> build(){
  return new BerkeleyDB<>(location,dbName,keyClass,valueClass,allowSortedDuplicates,readOnly);
}","public BerkeleyDB<K,V> build(){
  return new BerkeleyDB<>(location,dbName,keyClass,valueClass,allowSortedDuplicates,readOnly,allowCreate);
}",0.9552238805970148
26155,"public BerkeleyDB(final File location,final String dbName,final Class<K> keyClass,final Class<V> valueClass,boolean allowSortedDuplicates,boolean readOnly){
  createDBEnvironment(location);
  initDB(dbName,keyClass,valueClass,allowSortedDuplicates,readOnly);
}","public BerkeleyDB(final File location,final String dbName,final Class<K> keyClass,final Class<V> valueClass,boolean allowSortedDuplicates,boolean readOnly,boolean allowCreate){
  createDBEnvironment(location,allowCreate);
  initDB(dbName,keyClass,valueClass,allowSortedDuplicates,readOnly);
}",0.9420289855072465
26156,"/** 
 * Parse all non-empty and non-comment lines (comment lines start with '#') from a test results file into a map.
 * @param clazz the class whose classpath will be used.
 * @throws ClassNotFoundException
 */
public static Map<String,Map<Class<?>,Double>> parseDisambiguationResults(String fileName,Class<?> clazz,String packageNameDisambiguator) throws IOException, URISyntaxException, ClassNotFoundException {
  Map<String,Map<Class<?>,Double>> results=new HashMap<>();
  List<String> lines=FileUtils.readRelevantLinesFromFile(clazz,fileName);
  if (lines.isEmpty())   throw new RuntimeException(fileName + ""String_Node_Str"");
  String[] headers=lines.remove(0).split(DELIMITER);
  for (  String line : lines) {
    String[] values=line.split(DELIMITER);
    String uri=values[0];
    Map<Class<?>,Double> map=new HashMap<>();
    for (int i=1; i < values.length; i++) {
      Double value=Double.parseDouble(values[i]);
      String fullClassName=packageNameDisambiguator + ""String_Node_Str"" + headers[i];
      Class<?> keyClazz=Class.forName(fullClassName);
      map.put(keyClazz,value);
    }
    results.put(uri,map);
  }
  return results;
}","/** 
 * Parse all non-empty and non-comment lines (comment lines start with '#') from a test results file into a map.
 * @param clazz the class whose classpath will be used.
 * @throws ClassNotFoundException
 */
public static Map<String,Map<Class<?>,Double>> parseDisambiguationResults(String fileName,Class<?> clazz,String packageNameDisambiguator) throws IOException, URISyntaxException, ClassNotFoundException {
  Map<String,Map<Class<?>,Double>> results=new HashMap<>();
  List<String> lines=FileUtils.readRelevantLinesFromFile(clazz,fileName);
  if (lines.isEmpty())   throw new RuntimeException(fileName + ""String_Node_Str"");
  String[] headers=lines.get(0).split(DELIMITER);
  for (  String line : lines.subList(1,lines.size())) {
    String[] values=line.split(DELIMITER);
    String uri=values[0];
    Map<Class<?>,Double> map=new HashMap<>();
    for (int i=1; i < values.length; i++) {
      Double value=Double.parseDouble(values[i]);
      String fullClassName=packageNameDisambiguator + ""String_Node_Str"" + headers[i];
      Class<?> keyClazz=Class.forName(fullClassName);
      map.put(keyClazz,value);
    }
    results.put(uri,map);
  }
  return results;
}",0.9858064516129031
26157,"/** 
 * Read all lines from a file and return all non-empty and non-comment lines (comment lines start with '#').
 * @param clazz the class whose classpath will be used.
 */
public static List<String> readRelevantLinesFromFile(Class<?> clazz,String fileName) throws IOException, URISyntaxException {
  URL url=clazz.getResource(fileName);
  if (url == null)   throw new IllegalArgumentException(""String_Node_Str"" + fileName);
  List<String> lines=Files.readAllLines(Paths.get(url.toURI()),StandardCharsets.UTF_8);
  Iterator<String> iter=lines.iterator();
  while (iter.hasNext()) {
    String line=iter.next();
    if (line.trim().isEmpty() || line.startsWith(""String_Node_Str""))     iter.remove();
  }
  return lines;
}","/** 
 * Read all lines from a file and return all non-empty and non-comment lines (comment lines start with '#').
 * @param clazz the class whose classpath will be used.
 */
public static List<String> readRelevantLinesFromFile(Class<?> clazz,String fileName) throws IOException, URISyntaxException {
  URL resource=clazz.getResource(fileName);
  if (resource == null)   throw new IllegalArgumentException(""String_Node_Str"" + fileName);
  List<String> lines=Resources.readLines(resource,Charsets.UTF_8,new NonEmptyNonCommentLinesCollector());
  return lines;
}",0.7453125
26158,"@Override public List<SurfaceFormSenseScore<T,U>> disambiguate(Collection<? extends SurfaceFormSenses<T,U>> surfaceFormsSenses,Graph subgraph){
  VertexScorer<Vertex,Double> vertexScorer=getVertexScorer(subgraph);
  List<SurfaceFormSenseScore<T,U>> senseScores=ModelTransformer.initializeScores(surfaceFormsSenses,factory);
  for (  SurfaceFormSenseScore<T,U> senseScore : senseScores) {
    double score=vertexScorer.getVertexScore(Graphs.vertexByUri(subgraph,senseScore.sense().fullUri()));
    senseScore.setScore(score);
  }
  Collections.sort(senseScores);
  Collections.reverse(senseScores);
  return senseScores;
}","@Override public List<SurfaceFormSenseScore<T,U>> disambiguate(Collection<? extends SurfaceFormSenses<T,U>> surfaceFormsSenses,Graph subgraph){
  VertexScorer<Vertex,Double> vertexScorer=getVertexScorer(subgraph);
  List<SurfaceFormSenseScore<T,U>> senseScores=ModelTransformer.initializeScores(surfaceFormsSenses,factory);
  for (  SurfaceFormSenseScore<T,U> senseScore : senseScores) {
    Vertex v=Graphs.vertexByUri(subgraph,senseScore.sense().fullUri());
    double score=(v == null) ? -1 : vertexScorer.getVertexScore(v);
    senseScore.setScore(score);
  }
  Collections.sort(senseScores);
  Collections.reverse(senseScores);
  return senseScores;
}",0.9099451840250588
26159,"public static Vertex vertexByUri(Graph graph,String uri){
  String shortUri=UriShortener.shorten(uri);
  List<Vertex> vertices=new LinkedList<Vertex>();
  Iterable<Vertex> verticesIter=graph.getVertices(GraphConfig.URI_PROPERTY,shortUri);
  for (  Vertex v : verticesIter)   vertices.add(v);
  if (vertices.size() == 0) {
    logger.warn(""String_Node_Str"",uri);
    return null;
  }
  if (vertices.size() > 1) {
    logger.warn(""String_Node_Str"",uri);
    for (    Vertex v : vertices) {
      int inDegree=vertexDegree(v,Direction.IN);
      int outDegree=vertexDegree(v,Direction.OUT);
      logger.warn(""String_Node_Str"",v.getId(),v.getProperty(GraphConfig.URI_PROPERTY),inDegree,outDegree);
    }
    logger.warn(""String_Node_Str"");
  }
  return vertices.get(0);
}","public static Vertex vertexByUri(Graph graph,String uri){
  String shortUri=UriShortener.shorten(uri);
  List<Vertex> vertices=new LinkedList<Vertex>();
  Iterable<Vertex> verticesIter=graph.getVertices(GraphConfig.URI_PROPERTY,shortUri);
  for (  Vertex v : verticesIter)   vertices.add(v);
  if (vertices.size() == 0) {
    return null;
  }
  if (vertices.size() > 1) {
    logger.warn(""String_Node_Str"",uri);
    for (    Vertex v : vertices) {
      int inDegree=vertexDegree(v,Direction.IN);
      int outDegree=vertexDegree(v,Direction.OUT);
      logger.warn(""String_Node_Str"",v.getId(),v.getProperty(GraphConfig.URI_PROPERTY),inDegree,outDegree);
    }
    logger.warn(""String_Node_Str"");
  }
  return vertices.get(0);
}",0.9732620320855616
26160,"/** 
 * Converts the uris to vertices. Omits uris that cannot be found in the provided graph.
 */
public static List<Vertex> verticesByUri(Graph graph,Collection<String> uris){
  List<Vertex> vertices=new LinkedList<Vertex>();
  for (  String uri : uris) {
    Vertex v=vertexByUri(graph,uri);
    if (v != null)     vertices.add(v);
  }
  return vertices;
}","/** 
 * Converts the uris to vertices. Omits uris that cannot be found in the provided graph.
 */
public static List<Vertex> verticesByUri(Graph graph,Collection<String> uris){
  List<Vertex> vertices=new LinkedList<Vertex>();
  for (  String uri : uris) {
    Vertex v=vertexByUri(graph,uri);
    if (v != null)     vertices.add(v);
 else     logger.warn(""String_Node_Str"",uri);
  }
  return vertices;
}",0.9396325459317584
26161,"public static void main(String[] args) throws IOException, URISyntaxException {
  dbpediaDemo();
}","public static void main(String[] args) throws IOException, URISyntaxException {
  String sensesFileName=""String_Node_Str"";
  Collection<SurfaceFormSenses<DefaultSurfaceForm,DefaultSense>> wordsSensesString=ModelTransformer.surfaceFormsSensesFromFile(DemoSubgraphConstruction.class,sensesFileName,GraphConfig.DBPEDIA_RESOURCE_PREFIX,factory);
  Graph graph=GraphFactory.getDBpediaGraph();
  demo(graph,wordsSensesString);
}",0.3384615384615385
26162,"public static <T extends SurfaceForm,U extends Sense>Collection<Vertex> verticesFromSenses(Graph graph,SurfaceFormSenses<T,U> surfaceFormSenses){
  Collection<Vertex> vertices=new ArrayList<>(surfaceFormSenses.getSenses().size());
  for (  Sense sense : surfaceFormSenses.getSenses())   vertices.add(Graphs.vertexByUri(graph,sense.fullUri()));
  return vertices;
}","public static <T extends SurfaceForm,U extends Sense>Collection<Vertex> verticesFromSenses(Graph graph,SurfaceFormSenses<T,U> surfaceFormSenses){
  Collection<Vertex> vertices=new ArrayList<>(surfaceFormSenses.getSenses().size());
  for (  Sense sense : surfaceFormSenses.getSenses()) {
    Vertex v=Graphs.vertexByUri(graph,sense.fullUri());
    if (v != null)     vertices.add(v);
 else     logger.warn(""String_Node_Str"",sense.fullUri());
  }
  return vertices;
}",0.8033775633293124
26163,"/** 
 * Read all lines from a file and return all non-empty and non-comment lines (comment lines start with '#').
 * @param clazz the class whose classpath will be used.
 */
public static List<String> readRelevantLinesFromFile(Class<?> clazz,String fileName) throws IOException, URISyntaxException {
  URL url=clazz.getResource(fileName);
  if (url == null)   throw new IllegalArgumentException(""String_Node_Str"" + fileName);
  List<String> lines=Files.readAllLines(Paths.get(url.toURI()),StandardCharsets.UTF_8);
  Iterator<String> iter=lines.iterator();
  while (iter.hasNext()) {
    String line=iter.next();
    if (line.isEmpty() || line.startsWith(""String_Node_Str""))     iter.remove();
  }
  return lines;
}","/** 
 * Read all lines from a file and return all non-empty and non-comment lines (comment lines start with '#').
 * @param clazz the class whose classpath will be used.
 */
public static List<String> readRelevantLinesFromFile(Class<?> clazz,String fileName) throws IOException, URISyntaxException {
  URL url=clazz.getResource(fileName);
  if (url == null)   throw new IllegalArgumentException(""String_Node_Str"" + fileName);
  List<String> lines=Files.readAllLines(Paths.get(url.toURI()),StandardCharsets.UTF_8);
  Iterator<String> iter=lines.iterator();
  while (iter.hasNext()) {
    String line=iter.next();
    if (line.trim().isEmpty() || line.startsWith(""String_Node_Str""))     iter.remove();
  }
  return lines;
}",0.9951219512195122
26164,"/** 
 * Open a graph based on configuration settings.
 */
private static TransactionalGraph openGraph(){
  long startTime=System.currentTimeMillis();
  Graph graph=com.tinkerpop.blueprints.GraphFactory.open(GraphConfig.config());
  if (graph instanceof Neo4jGraph) {
    Neo4jGraph nGraph=(Neo4jGraph)graph;
    nGraph.createKeyIndex(GraphConfig.URI_PROPERTY,Vertex.class);
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime) / 1000.0);
  if (graph instanceof TransactionalGraph)   return (TransactionalGraph)graph;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}","/** 
 * Open a graph based on configuration settings.
 */
private static TransactionalGraph openGraph(){
  long startTime=System.currentTimeMillis();
  Graph graph=com.tinkerpop.blueprints.GraphFactory.open(GraphConfig.config());
  if (Graphs.isEmptyGraph(graph))   logger.warn(String.format(""String_Node_Str"",GraphConfig.graphDirectory()));
  if (graph instanceof Neo4jGraph) {
    Neo4jGraph nGraph=(Neo4jGraph)graph;
    nGraph.createKeyIndex(GraphConfig.URI_PROPERTY,Vertex.class);
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime) / 1000.0);
  if (graph instanceof TransactionalGraph)   return (TransactionalGraph)graph;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}",0.9152798789712556
26165,"/** 
 * Accessor for the dbpedia graph.
 * @return the dbpedia graph
 */
public static TransactionalGraph getDBpediaGraph(){
  return graph;
}","/** 
 * Accessor for the dbpedia graph.
 * @return the dbpedia graph
 */
public static TransactionalGraph getDBpediaGraph(){
  if (Graphs.isEmptyGraph(graph))   throw new IllegalStateException(""String_Node_Str"");
  return graph;
}",0.7634408602150538
26166,"public static Vertex vertexByUri(Graph graph,String uri){
  String shortUri=UriShortener.shorten(uri);
  List<Vertex> vertices=new LinkedList<Vertex>();
  Iterable<Vertex> verticesIter=graph.getVertices(GraphConfig.URI_PROPERTY,shortUri);
  for (  Vertex v : verticesIter)   vertices.add(v);
  if (vertices.size() == 0)   return null;
  if (vertices.size() > 1) {
    logger.warn(""String_Node_Str"" + uri);
    for (    Vertex v : vertices) {
      int inDegree=vertexDegree(v,Direction.IN);
      int outDegree=vertexDegree(v,Direction.OUT);
      logger.warn(""String_Node_Str"",v.getId(),v.getProperty(GraphConfig.URI_PROPERTY),inDegree,outDegree);
    }
    logger.warn(""String_Node_Str"");
  }
  return vertices.get(0);
}","public static Vertex vertexByUri(Graph graph,String uri){
  String shortUri=UriShortener.shorten(uri);
  List<Vertex> vertices=new LinkedList<Vertex>();
  Iterable<Vertex> verticesIter=graph.getVertices(GraphConfig.URI_PROPERTY,shortUri);
  for (  Vertex v : verticesIter)   vertices.add(v);
  if (vertices.size() == 0) {
    logger.warn(""String_Node_Str"",uri);
    return null;
  }
  if (vertices.size() > 1) {
    logger.warn(""String_Node_Str"",uri);
    for (    Vertex v : vertices) {
      int inDegree=vertexDegree(v,Direction.IN);
      int outDegree=vertexDegree(v,Direction.OUT);
      logger.warn(""String_Node_Str"",v.getId(),v.getProperty(GraphConfig.URI_PROPERTY),inDegree,outDegree);
    }
    logger.warn(""String_Node_Str"");
  }
  return vertices.get(0);
}",0.9651006711409396
26167,"public static SubgraphConstruction newDefaultImplementation(Graph graph,SubgraphConstructionSettings settings){
  return newInstance(defaultClass(),settings,graph);
}","public static SubgraphConstruction newDefaultImplementation(SubgraphConstructionSettings settings){
  return newDefaultImplementation(GraphFactory.getDBpediaGraph(),settings);
}",0.7871720116618076
26168,"public static void checkValidSenses(Graph graph,Collection<Vertex> senses){
  if (senses == null)   throw new NullPointerException(""String_Node_Str"");
  if (senses.size() == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  for (  Vertex v : senses)   if (graph.getVertex(v.getId()) == null)   throw new IllegalArgumentException(String.format(""String_Node_Str"",v.getId(),v.getProperty(GraphConfig.URI_PROPERTY)));
}","public static void checkValidSenses(Graph graph,Collection<Vertex> senses){
  if (senses == null)   throw new NullPointerException(""String_Node_Str"");
  if (senses.size() == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  for (  Vertex v : senses) {
    if (v == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (graph.getVertex(v.getId()) == null)     throw new IllegalArgumentException(String.format(""String_Node_Str"",v.getId(),v.getProperty(GraphConfig.URI_PROPERTY)));
  }
}",0.8970588235294118
26169,"public static <T extends SurfaceForm,U extends Sense>Collection<Collection<Vertex>> wordsVerticesFromSenses(Graph graph,Collection<SurfaceFormSenses<T,U>> surfaceFormsSenses){
  Collection<Collection<Vertex>> wordVertices=new ArrayList<>();
  for (  SurfaceFormSenses<T,U> surfaceFormSenses : surfaceFormsSenses) {
    Collection<Vertex> vertices=verticesFromSenses(graph,surfaceFormSenses);
    wordVertices.add(vertices);
  }
  return wordVertices;
}","public static <T extends SurfaceForm,U extends Sense>Collection<Collection<Vertex>> wordsVerticesFromSenses(Graph graph,Collection<SurfaceFormSenses<T,U>> surfaceFormsSenses){
  Collection<Collection<Vertex>> wordVertices=new ArrayList<>();
  for (  SurfaceFormSenses<T,U> surfaceFormSenses : surfaceFormsSenses) {
    Collection<Vertex> vertices=verticesFromSenses(graph,surfaceFormSenses);
    if (!vertices.isEmpty())     wordVertices.add(vertices);
  }
  return wordVertices;
}",0.9689174705251876
26170,"public static void checkValidSenses(Graph graph,Collection<Vertex> senses){
  if (senses == null)   throw new NullPointerException(""String_Node_Str"");
  if (senses.size() == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  for (  Vertex v : senses) {
    if (v == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (graph.getVertex(v.getId()) == null)     throw new IllegalArgumentException(String.format(""String_Node_Str"",v.getId(),v.getProperty(GraphConfig.URI_PROPERTY)));
  }
}","public static void checkValidSenses(Graph graph,Collection<Vertex> senses){
  if (senses == null)   throw new NullPointerException(""String_Node_Str"");
  for (  Vertex v : senses) {
    if (v == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (graph.getVertex(v.getId()) == null)     throw new IllegalArgumentException(String.format(""String_Node_Str"",v.getId(),v.getProperty(GraphConfig.URI_PROPERTY)));
  }
}",0.9141675284384696
26171,"public static void checkValidWordsSenses(Graph graph,Collection<Collection<Vertex>> wordsSenses){
  if (wordsSenses == null)   throw new NullPointerException(""String_Node_Str"");
  if (wordsSenses.size() == 0)   throw new IllegalArgumentException(""String_Node_Str"");
  for (  Collection<Vertex> senses : wordsSenses)   checkValidSenses(graph,senses);
}","public static void checkValidWordsSenses(Graph graph,Collection<Collection<Vertex>> wordsSenses){
  if (wordsSenses == null)   throw new NullPointerException(""String_Node_Str"");
  for (  Collection<Vertex> senses : wordsSenses)   checkValidSenses(graph,senses);
}",0.8566775244299675
26172,"/** 
 * Creates and returns a graph implementation. The graph is created for batch inserts using the provided buffer size.
 */
public Graph getBatchGraph(long bufferSize){
  return new BatchGraph<TransactionalGraph>(graph,bufferSize);
}","/** 
 * Creates and returns a graph implementation. The graph is created for batch inserts using the provided buffer size.
 */
public Graph getBatchGraph(long bufferSize){
  BatchGraph<TransactionalGraph> bgraph=new BatchGraph<TransactionalGraph>(graph,bufferSize);
  long verticesCount=new GremlinPipeline<Object,Object>(graph.getVertices()).count();
  if (verticesCount != 0) {
    bgraph.setVertexIdKey(GraphConfig.URI_PROPERTY);
    bgraph.setLoadingFromScratch(false);
    logger.info(""String_Node_Str"",verticesCount);
  }
  return bgraph;
}",0.5754475703324808
26173,"/** 
 * Open a graph based on configuration settings.
 */
private TransactionalGraph openGraph(){
  long startTime=System.currentTimeMillis();
  Graph graph=GraphFactory.open(GraphConfig.getInstance().getConfig());
  logger.debug(String.format(""String_Node_Str"",(System.currentTimeMillis() - startTime) / 1000.0));
  if (graph instanceof TransactionalGraph) {
    return (TransactionalGraph)graph;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Open a graph based on configuration settings.
 */
private TransactionalGraph openGraph(){
  long startTime=System.currentTimeMillis();
  Graph graph=GraphFactory.open(GraphConfig.getInstance().getConfig());
  if (graph instanceof Neo4jGraph) {
    Neo4jGraph nGraph=(Neo4jGraph)graph;
    nGraph.createKeyIndex(GraphConfig.URI_PROPERTY,Vertex.class);
  }
  logger.info(""String_Node_Str"",(System.currentTimeMillis() - startTime) / 1000.0);
  if (graph instanceof TransactionalGraph) {
    return (TransactionalGraph)graph;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.8314814814814815
26174,"protected void refreshUI(boolean gameOverNoWinner,GameWinPattern gameWinPattern,GameSymbol winningSymbol,int[] selectedXBoxIds,int[] selectedOBoxIds){
  if (gameWinPattern != null) {
    hapticFeedbackHelper.vibrate(hapticFeedbackHelper.getWinningPattern(toeGame.symbolIsAndroid(winningSymbol)),HapticFeedbackHelper.VIBE_PATTERN_NO_REPEAT);
    disableAllBoxes();
    highlightWinningPattern(gameWinPattern);
    messageTurnIndicatorValue.setText(getString(R.string.game_message_wins,winningSymbol.getValue()));
  }
 else   if (gameOverNoWinner) {
    messageTurnIndicatorValue.setText(getString(R.string.game_message_draw));
  }
 else {
    messageTurnIndicatorValue.setText(toeGame.getTurn().getValue());
    startTurn(selectedXBoxIds,selectedOBoxIds);
  }
}","protected void refreshUI(boolean gameOverNoWinner,GameWinPattern gameWinPattern,GameSymbol winningSymbol,int[] selectedXBoxIds,int[] selectedOBoxIds){
  if (gameWinPattern != null) {
    hapticFeedbackHelper.vibrate(hapticFeedbackHelper.getWinningPattern(toeGame.symbolIsAndroid(winningSymbol)),HapticFeedbackHelper.VIBE_PATTERN_NO_REPEAT);
    disableAllBoxes();
    highlightWinningPattern(gameWinPattern);
    getMessageTurnIndicator.setText(getString(R.string.game_message_over));
    messageTurnIndicatorValue.setText(getString(R.string.game_message_wins,winningSymbol.getValue()));
  }
 else   if (gameOverNoWinner) {
    getMessageTurnIndicator.setText(getString(R.string.game_message_over));
    messageTurnIndicatorValue.setText(getString(R.string.game_message_draw));
  }
 else {
    getMessageTurnIndicator.setText(getString(R.string.message_turn_indicator));
    messageTurnIndicatorValue.setText(toeGame.getTurn().getValue());
    startTurn(selectedXBoxIds,selectedOBoxIds);
  }
}",0.8670849971477467
26175,"public int getBoxId(int[] selectedXBoxIds,int[] selectedOBoxIds,GameSymbol androidSymbol){
  Random random=new Random();
  int selectedIndex=random.nextInt(availableBoxes.length - 1);
  return availableBoxes[selectedIndex];
}","public int getBoxId(int[] selectedXBoxIds,int[] selectedOBoxIds,GameSymbol androidSymbol){
  Random random=new Random();
  int max=availableBoxes.length - 1;
  Log.d(Toe.TAG,""String_Node_Str"" + max);
  int selectedIndex=max > 0 ? random.nextInt(max) : 0;
  return availableBoxes[selectedIndex];
}",0.7562380038387716
26176,"protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_showpage);
  tv=(TextView)findViewById(R.id.tv_page);
  sv=(ScrollView)findViewById(R.id.scrollView1);
  settings=getSharedPreferences(FOXSETTING,0);
  editor=settings.edit();
  sp_fontsize=settings.getFloat(""String_Node_Str"",sp_fontsize);
  tv.setTextSize(sp_fontsize);
  Intent itt=getIntent();
  foxfrom=itt.getIntExtra(""String_Node_Str"",0);
  pagename=itt.getStringExtra(""String_Node_Str"");
  pageurl=itt.getStringExtra(""String_Node_Str"");
  SE_TYPE=itt.getIntExtra(""String_Node_Str"",1);
  setTitle(pagename + ""String_Node_Str"" + pageurl);
  final Handler handler=new Handler(){
    public void handleMessage(    Message msg){
      String sText=(String)msg.obj;
      if (msg.what == IS_REFRESH) {
        tv.setText(""String_Node_Str"" + sText.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ pagename);
        setTitle(pagename + ""String_Node_Str"" + pageurl);
        if (sText.length() < 9) {
          tv.setText(""String_Node_Str"" + pageurl + ""String_Node_Str""+ pagename+ ""String_Node_Str""+ sText);
        }
      }
    }
  }
;
  final Runnable down_page=new Runnable(){
    @Override public void run(){
      String text=""String_Node_Str"";
switch (SE_TYPE) {
case SE_EASOU:
        text=FoxBookLib.downhtml(pageurl,""String_Node_Str"");
      text=site_easou.json2Text(text);
    break;
case SE_ZSSQ:
  text=FoxBookLib.downhtml(pageurl,""String_Node_Str"");
text=site_zssq.json2Text(text);
break;
case SE_KUAIDU:
text=site_qreader.qreader_GetContent(pageurl);
break;
default :
text=FoxBookLib.updatepage(-1,pageurl,oDB);
}
Message msg=Message.obtain();
msg.what=IS_REFRESH;
msg.obj=text;
handler.sendMessage(msg);
}
}
;
if (FROM_DB == foxfrom) {
pageid=itt.getIntExtra(""String_Node_Str"",0);
Map<String,String> infox=oDB.getOneRow(""String_Node_Str"" + pageid + ""String_Node_Str"");
pagetext=infox.get(""String_Node_Str"");
if (null == pagetext) {
pagetext=""String_Node_Str"";
}
 else {
bookid=Integer.valueOf(infox.get(""String_Node_Str""));
}
tv.setText(""String_Node_Str"" + pagetext.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ pagename);
}
if (FROM_NET == foxfrom) {
setTitle(""String_Node_Str"");
new Thread(down_page).start();
}
tv.setOnClickListener(new OnClickListener(){
@Override public void onClick(View arg0){
int vy=getWindowManager().getDefaultDisplay().getHeight();
if (cY <= vy / 3) {
sv.smoothScrollBy(0,30 - sv.getMeasuredHeight());
}
 else {
sv.smoothScrollBy(0,sv.getMeasuredHeight() - 30);
}
}
}
);
tv.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View arg0,MotionEvent arg1){
cY=arg1.getRawY();
return false;
}
}
);
}","protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_showpage);
  tv=(TextView)findViewById(R.id.tv_page);
  sv=(ScrollView)findViewById(R.id.scrollView1);
  settings=getSharedPreferences(FOXSETTING,0);
  editor=settings.edit();
  sp_fontsize=settings.getFloat(""String_Node_Str"",sp_fontsize);
  tv.setTextSize(sp_fontsize);
  Intent itt=getIntent();
  foxfrom=itt.getIntExtra(""String_Node_Str"",0);
  pagename=itt.getStringExtra(""String_Node_Str"");
  pageurl=itt.getStringExtra(""String_Node_Str"");
  SE_TYPE=itt.getIntExtra(""String_Node_Str"",1);
  setTitle(pagename + ""String_Node_Str"" + pageurl);
  final Handler handler=new Handler(){
    public void handleMessage(    Message msg){
      String sText=(String)msg.obj;
      if (msg.what == IS_REFRESH) {
        tv.setText(""String_Node_Str"" + sText.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ pagename);
        setTitle(pagename + ""String_Node_Str"" + pageurl);
        if (sText.length() < 9) {
          tv.setText(""String_Node_Str"" + pageurl + ""String_Node_Str""+ pagename+ ""String_Node_Str""+ sText);
        }
      }
    }
  }
;
  final Runnable down_page=new Runnable(){
    @Override public void run(){
      String text=""String_Node_Str"";
switch (SE_TYPE) {
case SE_EASOU:
        text=FoxBookLib.downhtml(pageurl,""String_Node_Str"");
      text=site_easou.json2Text(text);
    break;
case SE_ZSSQ:
  text=FoxBookLib.downhtml(pageurl,""String_Node_Str"");
text=site_zssq.json2Text(text);
break;
case SE_KUAIDU:
text=site_qreader.qreader_GetContent(pageurl);
break;
default :
text=FoxBookLib.updatepage(-1,pageurl,oDB);
}
Message msg=Message.obtain();
msg.what=IS_REFRESH;
msg.obj=text;
handler.sendMessage(msg);
}
}
;
if (FROM_DB == foxfrom) {
pageid=itt.getIntExtra(""String_Node_Str"",0);
Map<String,String> infox=oDB.getOneRow(""String_Node_Str"" + pageid + ""String_Node_Str"");
pagetext=infox.get(""String_Node_Str"");
pagename=infox.get(""String_Node_Str"");
if (null == pagetext) {
pagetext=""String_Node_Str"";
}
 else {
bookid=Integer.valueOf(infox.get(""String_Node_Str""));
}
tv.setText(""String_Node_Str"" + pagetext.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ pagename);
}
if (FROM_NET == foxfrom) {
setTitle(""String_Node_Str"");
new Thread(down_page).start();
}
tv.setOnClickListener(new OnClickListener(){
@Override public void onClick(View arg0){
int vy=getWindowManager().getDefaultDisplay().getHeight();
if (cY <= vy / 3) {
sv.smoothScrollBy(0,30 - sv.getMeasuredHeight());
}
 else {
sv.smoothScrollBy(0,sv.getMeasuredHeight() - 30);
}
}
}
);
tv.setOnTouchListener(new OnTouchListener(){
@Override public boolean onTouch(View arg0,MotionEvent arg1){
cY=arg1.getRawY();
return false;
}
}
);
}",0.9928948806704316
26177,"public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.show_prev:
    if (0 == pageid) {
      foxtip(""String_Node_Str"");
      break;
    }
  Map<String,String> pp;
pp=oDB.getOneRow(""String_Node_Str"" + pageid + ""String_Node_Str""+ bookid+ ""String_Node_Str"");
if (null == pp.get(""String_Node_Str"")) {
pp=oDB.getOneRow(""String_Node_Str"" + bookid + ""String_Node_Str"");
if (null == pp.get(""String_Node_Str"")) {
  foxtip(""String_Node_Str"");
  break;
}
}
pageid=Integer.valueOf(pp.get(""String_Node_Str""));
bookid=Integer.valueOf(pp.get(""String_Node_Str""));
setTitle(pageid + ""String_Node_Str"" + pp.get(""String_Node_Str"")+ ""String_Node_Str""+ pp.get(""String_Node_Str""));
pagetext=pp.get(""String_Node_Str"");
tv.setText(""String_Node_Str"" + pagetext.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ pagename);
sv.scrollTo(0,0);
break;
case R.id.show_next:
if (0 == pageid) {
foxtip(""String_Node_Str"");
break;
}
Map<String,String> nn;
nn=oDB.getOneRow(""String_Node_Str"" + pageid + ""String_Node_Str""+ bookid+ ""String_Node_Str"");
if (null == nn.get(""String_Node_Str"")) {
nn=oDB.getOneRow(""String_Node_Str"" + bookid + ""String_Node_Str"");
if (null == nn.get(""String_Node_Str"")) {
foxtip(""String_Node_Str"");
break;
}
}
pageid=Integer.valueOf(nn.get(""String_Node_Str""));
bookid=Integer.valueOf(nn.get(""String_Node_Str""));
setTitle(pageid + ""String_Node_Str"" + nn.get(""String_Node_Str"")+ ""String_Node_Str""+ nn.get(""String_Node_Str""));
pagetext=nn.get(""String_Node_Str"");
tv.setText(""String_Node_Str"" + pagetext.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ pagename);
sv.scrollTo(0,0);
break;
case R.id.sp_set_size_up:
++sp_fontsize;
tv.setTextSize(sp_fontsize);
editor.putFloat(""String_Node_Str"",sp_fontsize);
editor.commit();
break;
case R.id.sp_set_size_down:
--sp_fontsize;
tv.setTextSize(sp_fontsize);
editor.putFloat(""String_Node_Str"",sp_fontsize);
editor.commit();
break;
}
return super.onOptionsItemSelected(item);
}","public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.show_prev:
    if (0 == pageid) {
      foxtip(""String_Node_Str"");
      break;
    }
  Map<String,String> pp;
pp=oDB.getOneRow(""String_Node_Str"" + pageid + ""String_Node_Str""+ bookid+ ""String_Node_Str"");
if (null == pp.get(""String_Node_Str"")) {
pp=oDB.getOneRow(""String_Node_Str"" + bookid + ""String_Node_Str"");
if (null == pp.get(""String_Node_Str"")) {
  foxtip(""String_Node_Str"");
  break;
}
}
pageid=Integer.valueOf(pp.get(""String_Node_Str""));
bookid=Integer.valueOf(pp.get(""String_Node_Str""));
setTitle(pageid + ""String_Node_Str"" + pp.get(""String_Node_Str"")+ ""String_Node_Str""+ pp.get(""String_Node_Str""));
pagetext=pp.get(""String_Node_Str"");
tv.setText(""String_Node_Str"" + pagetext.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ pp.get(""String_Node_Str""));
sv.scrollTo(0,0);
break;
case R.id.show_next:
if (0 == pageid) {
foxtip(""String_Node_Str"");
break;
}
Map<String,String> nn;
nn=oDB.getOneRow(""String_Node_Str"" + pageid + ""String_Node_Str""+ bookid+ ""String_Node_Str"");
if (null == nn.get(""String_Node_Str"")) {
nn=oDB.getOneRow(""String_Node_Str"" + bookid + ""String_Node_Str"");
if (null == nn.get(""String_Node_Str"")) {
foxtip(""String_Node_Str"");
break;
}
}
pageid=Integer.valueOf(nn.get(""String_Node_Str""));
bookid=Integer.valueOf(nn.get(""String_Node_Str""));
setTitle(pageid + ""String_Node_Str"" + nn.get(""String_Node_Str"")+ ""String_Node_Str""+ nn.get(""String_Node_Str""));
pagetext=nn.get(""String_Node_Str"");
tv.setText(""String_Node_Str"" + pagetext.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ nn.get(""String_Node_Str""));
sv.scrollTo(0,0);
break;
case R.id.sp_set_size_up:
++sp_fontsize;
tv.setTextSize(sp_fontsize);
editor.putFloat(""String_Node_Str"",sp_fontsize);
editor.commit();
break;
case R.id.sp_set_size_down:
--sp_fontsize;
tv.setTextSize(sp_fontsize);
editor.putFloat(""String_Node_Str"",sp_fontsize);
editor.commit();
break;
}
return super.onOptionsItemSelected(item);
}",0.9839598997493736
26178,"public DownloadCardViewItem(Context context){
  super(context,R.layout.download_cardview);
  headerCardView=new HeaderCardView(context);
  setUpTitle();
}","public DownloadCardViewItem(Context context){
  super(context,R.layout.download_cardview);
}",0.7479674796747967
26179,"@Override protected void setUpInnerLayout(final View view){
  super.setUpInnerLayout(view);
  md5sumView=(TextView)view.findViewById(R.id.md5sum_view);
  noteView=(TextView)view.findViewById(R.id.note_view);
  ImageButton downloadButton=(ImageButton)view.findViewById(R.id.download_view);
  ImageButton changelogButton=(ImageButton)view.findViewById(R.id.changelog_view);
  if (md5sum != null)   md5sumView.setText(Html.fromHtml(""String_Node_Str"" + md5sum));
  setNoteView();
  downloadButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Utils.confirmDialog(null,getContext().getString(R.string.install_confirm,version),new Utils.OnConfirmDialogListener(){
        @Override public void onDismiss(){
        }
        @Override public void onConfirm(){
          new DownloadTask(ROMSWITCHER_DOWNLOAD_PATH,""String_Node_Str"",new DownloadTask.DownloadListener(){
            @Override public void downloadFinish(            DownloadTask.DownloadStatus status){
switch (status) {
case SUCCESS:
                if (onDownloadListener != null)                 onDownloadListener.onSuccess();
              break;
case CANCELED:
            Toast.makeText(getContext(),getContext().getString(R.string.download_cancel),Toast.LENGTH_SHORT).show();
          break;
case FAILED:
        Toast.makeText(getContext(),getContext().getString(R.string.download_failed),Toast.LENGTH_SHORT).show();
      break;
  }
}
}
,getContext()).execute(download);
}
}
,getContext());
}
}
);
changelogButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
String[] changelogArray=changelog.split(""String_Node_Str"");
StringBuilder message=new StringBuilder();
for (String change : changelogArray) if (change.startsWith(""String_Node_Str"")) {
if (!message.toString().isEmpty()) message.append(""String_Node_Str"");
message.append(change.replace(""String_Node_Str"",""String_Node_Str""));
}
 else {
if (!message.toString().isEmpty()) message.append(""String_Node_Str"");
message.append(""String_Node_Str"").append(change).append(""String_Node_Str"").append(""String_Node_Str"");
}
View dialogView=LayoutInflater.from(getContext()).inflate(R.layout.dialog_textview,(ViewGroup)getParent(),false);
((TextView)dialogView.findViewById(R.id.title_text)).setText(getContext().getString(R.string.changelog));
((TextView)dialogView.findViewById(R.id.text)).setText(Html.fromHtml(message.toString()));
AlertDialog.Builder dialog=new AlertDialog.Builder(getContext());
dialog.setView(dialogView).show();
}
}
);
}","@Override protected void setUpInnerLayout(final View view){
  super.setUpInnerLayout(view);
  downloadHeaderView=new DownloadHeaderView(getContext());
  setUpTitle();
  md5sumView=(TextView)view.findViewById(R.id.md5sum_view);
  noteView=(TextView)view.findViewById(R.id.note_view);
  if (md5sum != null)   md5sumView.setText(Html.fromHtml(""String_Node_Str"" + md5sum));
  setNoteView();
  downloadHeaderView.downloadButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Utils.confirmDialog(null,getContext().getString(R.string.install_confirm,version),new Utils.OnConfirmDialogListener(){
        @Override public void onDismiss(){
        }
        @Override public void onConfirm(){
          new DownloadTask(ROMSWITCHER_DOWNLOAD_PATH,""String_Node_Str"",new DownloadTask.DownloadListener(){
            @Override public void downloadFinish(            DownloadTask.DownloadStatus status){
switch (status) {
case SUCCESS:
                if (onDownloadListener != null)                 onDownloadListener.onSuccess();
              break;
case CANCELED:
            Toast.makeText(getContext(),getContext().getString(R.string.download_cancel),Toast.LENGTH_SHORT).show();
          break;
case FAILED:
        Toast.makeText(getContext(),getContext().getString(R.string.download_failed),Toast.LENGTH_SHORT).show();
      break;
  }
}
}
,getContext()).execute(download);
}
}
,getContext());
}
}
);
downloadHeaderView.changelogButton.setOnClickListener(new OnClickListener(){
@Override public void onClick(View v){
String[] changelogArray=changelog.split(""String_Node_Str"");
StringBuilder message=new StringBuilder();
for (String change : changelogArray) if (change.startsWith(""String_Node_Str"")) {
if (!message.toString().isEmpty()) message.append(""String_Node_Str"");
message.append(change.replace(""String_Node_Str"",""String_Node_Str""));
}
 else {
if (!message.toString().isEmpty()) message.append(""String_Node_Str"");
message.append(""String_Node_Str"").append(change).append(""String_Node_Str"").append(""String_Node_Str"");
}
View dialogView=LayoutInflater.from(getContext()).inflate(R.layout.dialog_textview,(ViewGroup)getParent(),false);
((TextView)dialogView.findViewById(R.id.title_text)).setText(getContext().getString(R.string.changelog));
((TextView)dialogView.findViewById(R.id.text)).setText(Html.fromHtml(message.toString()));
AlertDialog.Builder dialog=new AlertDialog.Builder(getContext());
dialog.setView(dialogView).show();
}
}
);
}",0.9448975532126516
26180,"private void setUpTitle(){
  if (headerCardView != null) {
    if (version == null)     removeHeader();
 else     addHeader(headerCardView);
  }
  if (headerCardView != null && version != null) {
    String text=getContext().getString(R.string.version) + ""String_Node_Str"" + version;
    if (size != null)     text+=""String_Node_Str"" + size + ""String_Node_Str"";
    headerCardView.setText(text);
  }
}","private void setUpTitle(){
  if (downloadHeaderView != null) {
    if (version == null)     removeHeader();
 else     addHeader(downloadHeaderView);
  }
  if (downloadHeaderView != null && version != null) {
    String text=getContext().getString(R.string.version) + ""String_Node_Str"" + version;
    if (size != null)     text+=""String_Node_Str"" + size + ""String_Node_Str"";
    downloadHeaderView.setText(text);
  }
}",0.882640586797066
26181,"private void refresh(String json){
  if (mDownloadsJson == null)   mDownloadsJson=new DownloadsJson(json);
 else   mDownloadsJson.refresh(json);
  removeAllViews();
  for (int i=0; i < mDownloadsJson.getLength(); i++) {
    DownloadCardViewItem.DDownloadCardView mDownloadCard=new DownloadCardViewItem.DDownloadCardView();
    mDownloadCard.setVersion(mDownloadsJson.getVersion(i));
    mDownloadCard.setMd5sum(mDownloadsJson.getMd5sum(i));
    mDownloadCard.setDownload(mDownloadsJson.getLink(i));
    mDownloadCard.setChangelog(mDownloadsJson.getChangelog(i));
    mDownloadCard.setOnDownloadListener(new DownloadCardViewItem.OnDownloadListener(){
      private boolean installing;
      @Override public void onSuccess(){
        new Thread(new Runnable(){
          @Override public void run(){
            int count=0;
            installing=true;
            while (installing) {
              try {
                count++;
                String title=getString(R.string.installing);
                for (int i=0; i < count; i++)                 title+=""String_Node_Str"";
                setTextTitle(title);
                if (count >= 5)                 count=0;
                Thread.sleep(500);
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
            }
          }
        }
).start();
        new Thread(new Runnable(){
          @Override public void run(){
            DevicesJson json=Utils.getDevicesJson(getActivity());
            RootUtils.writePartition(""String_Node_Str"",json.getRecoveryPartition());
            installing=false;
            setTextTitle(getString(R.string.done) + ""String_Node_Str"");
          }
        }
).start();
      }
    }
);
    String text;
    if ((text=mDownloadsJson.getSize(i)) != null)     mDownloadCard.setSize(text);
    if ((text=mDownloadsJson.getNote(i)) != null)     mDownloadCard.setNote(text);
    addView(mDownloadCard);
  }
  animateRecyclerView();
}","private void refresh(String json){
  if (mDownloadsJson == null)   mDownloadsJson=new DownloadsJson(json);
 else   mDownloadsJson.refresh(json);
  removeAllViews();
  for (int i=0; i < mDownloadsJson.getLength(); i++) {
    DownloadCardViewItem.DDownloadCardView mDownloadCard=new DownloadCardViewItem.DDownloadCardView();
    mDownloadCard.setVersion(mDownloadsJson.getVersion(i));
    mDownloadCard.setMd5sum(mDownloadsJson.getMd5sum(i));
    mDownloadCard.setDownload(mDownloadsJson.getLink(i));
    mDownloadCard.setChangelog(mDownloadsJson.getChangelog(i));
    mDownloadCard.setOnDownloadListener(new DownloadCardViewItem.OnDownloadListener(){
      private boolean installing;
      @Override public void onSuccess(){
        new Thread(new Runnable(){
          @Override public void run(){
            int count=0;
            installing=true;
            while (installing) {
              try {
                count++;
                String title=getString(R.string.installing);
                for (int i=0; i < count; i++)                 title+=""String_Node_Str"";
                setTextTitle(title);
                if (count >= 5)                 count=0;
                Thread.sleep(500);
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
            }
          }
        }
).start();
        new Thread(new Runnable(){
          @Override public void run(){
            DevicesJson json=Utils.getDevicesJson(getActivity());
            RootUtils.writePartition(""String_Node_Str"",json.getRecoveryPartition());
            installing=false;
            setTextTitle(getString(R.string.done) + ""String_Node_Str"");
            getActivity().runOnUiThread(new Runnable(){
              @Override public void run(){
                Utils.confirmDialog(null,getString(R.string.installation_success),new Utils.OnConfirmDialogListener(){
                  @Override public void onDismiss(){
                  }
                  @Override public void onConfirm(){
                    Utils.reboot();
                  }
                }
,getActivity());
              }
            }
);
          }
        }
).start();
      }
    }
);
    String text;
    if ((text=mDownloadsJson.getSize(i)) != null)     mDownloadCard.setSize(text);
    if ((text=mDownloadsJson.getNote(i)) != null)     mDownloadCard.setNote(text);
    addView(mDownloadCard);
  }
  animateRecyclerView();
}",0.8948314606741573
26182,"@Override public void run(){
  DevicesJson json=Utils.getDevicesJson(getActivity());
  RootUtils.writePartition(""String_Node_Str"",json.getRecoveryPartition());
  installing=false;
  setTextTitle(getString(R.string.done) + ""String_Node_Str"");
}","@Override public void run(){
  Utils.confirmDialog(null,getString(R.string.installation_success),new Utils.OnConfirmDialogListener(){
    @Override public void onDismiss(){
    }
    @Override public void onConfirm(){
      Utils.reboot();
    }
  }
,getActivity());
}",0.2152641878669275
26183,"@Override public void onSuccess(){
  new Thread(new Runnable(){
    @Override public void run(){
      int count=0;
      installing=true;
      while (installing) {
        try {
          count++;
          String title=getString(R.string.installing);
          for (int i=0; i < count; i++)           title+=""String_Node_Str"";
          setTextTitle(title);
          if (count >= 5)           count=0;
          Thread.sleep(500);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
).start();
  new Thread(new Runnable(){
    @Override public void run(){
      DevicesJson json=Utils.getDevicesJson(getActivity());
      RootUtils.writePartition(""String_Node_Str"",json.getRecoveryPartition());
      installing=false;
      setTextTitle(getString(R.string.done) + ""String_Node_Str"");
    }
  }
).start();
}","@Override public void onSuccess(){
  new Thread(new Runnable(){
    @Override public void run(){
      int count=0;
      installing=true;
      while (installing) {
        try {
          count++;
          String title=getString(R.string.installing);
          for (int i=0; i < count; i++)           title+=""String_Node_Str"";
          setTextTitle(title);
          if (count >= 5)           count=0;
          Thread.sleep(500);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
).start();
  new Thread(new Runnable(){
    @Override public void run(){
      DevicesJson json=Utils.getDevicesJson(getActivity());
      RootUtils.writePartition(""String_Node_Str"",json.getRecoveryPartition());
      installing=false;
      setTextTitle(getString(R.string.done) + ""String_Node_Str"");
      getActivity().runOnUiThread(new Runnable(){
        @Override public void run(){
          Utils.confirmDialog(null,getString(R.string.installation_success),new Utils.OnConfirmDialogListener(){
            @Override public void onDismiss(){
            }
            @Override public void onConfirm(){
              Utils.reboot();
            }
          }
,getActivity());
        }
      }
);
    }
  }
).start();
}",0.8020541549953315
26184,"@Override protected void onPreExecute(){
  super.onPreExecute();
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,context.getClass().getName());
  mWakeLock.acquire();
  if (!new File(path).exists())   new File(path).mkdirs();
  LinearLayout layout=new LinearLayout(context);
  layout.setOrientation(LinearLayout.VERTICAL);
  mProgressDialog=new ProgressDialog(context);
  mProgressDialog.setMessage(context.getString(R.string.downloading,file));
  mProgressDialog.setIndeterminate(true);
  mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
  mProgressDialog.setCancelable(true);
  mProgressDialog.setOnCancelListener(new DialogInterface.OnCancelListener(){
    @Override public void onCancel(    DialogInterface dialog){
      cancel();
    }
  }
);
  mProgressDialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialog){
      cancel();
    }
  }
);
  mProgressDialog.show();
}","@Override protected void onPreExecute(){
  super.onPreExecute();
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,context.getClass().getName());
  mWakeLock.acquire();
  if (!new File(path).exists())   new File(path).mkdirs();
  LinearLayout layout=new LinearLayout(context);
  layout.setOrientation(LinearLayout.VERTICAL);
  mProgressDialog=new ProgressDialog(context);
  mProgressDialog.setMessage(context.getString(R.string.downloading));
  mProgressDialog.setIndeterminate(true);
  mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
  mProgressDialog.setCancelable(true);
  mProgressDialog.setOnCancelListener(new DialogInterface.OnCancelListener(){
    @Override public void onCancel(    DialogInterface dialog){
      cancel();
    }
  }
);
  mProgressDialog.show();
}",0.9004641567818463
26185,"/** 
 * Builds the difference of the given configurations and emits the results.
 * @param configs The list of given configurations.
 * @throws IOException When emitting the results fails.
 */
public void diff(ArrayList<Configuration> configs) throws IOException {
  if (!quiet) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
  MergedConfiguration mc=new MergedConfiguration();
  TreeSet<String> prevKeys=null;
  Configuration prevConf=null;
  if (!quiet)   System.out.println(""String_Node_Str"");
  for (  Configuration conf : configs) {
    TreeSet<String> keys=new TreeSet<String>();
    for (    Property p : conf.getProperties()) {
      mc.addProperty(p);
      keys.add(p.getKey());
    }
    String currentVersion=conf.getProperties().first().getSource();
    if (prevKeys != null) {
      TreeSet<String> addedKeys=new TreeSet<String>(keys);
      addedKeys.removeAll(prevKeys);
      if (addedKeys.size() > 0) {
        if (!quiet)         System.out.println(""String_Node_Str"" + currentVersion + ""String_Node_Str"");
        for (        String key : addedKeys) {
          Property p=conf.getProperty(key);
          Property p2=prevConf.getPropertyByDescription(p.getDescription());
          boolean renamed=!Property.NULL.equals(p.getDescription()) && p2 != null;
          printProperty(p,p2,renamed ? Action.Renamed : Action.Added);
        }
        System.out.println();
      }
      TreeSet<String> removedKeys=new TreeSet<String>(prevKeys);
      removedKeys.removeAll(keys);
      if (removedKeys.size() > 0) {
        System.out.println(""String_Node_Str"" + currentVersion + ""String_Node_Str"");
        for (        String key : removedKeys) {
          Property p=prevConf.getProperty(key);
          printProperty(p,null,Action.Removed);
        }
        System.out.println();
      }
    }
    prevKeys=keys;
    prevConf=conf;
  }
  if (!quiet)   System.out.println(""String_Node_Str"");
  if (!quiet)   System.out.println(""String_Node_Str"");
  int diffCount=0;
  for (  String key : mc.getProperties().keySet()) {
    TreeSet<Property> merged=mc.getProperties().get(key);
    if (merged.size() > 1) {
      if (!quiet)       System.out.println(""String_Node_Str"" + key);
      diffCount++;
      for (      Property p : merged) {
        printProperty(p,null,Action.Changed);
      }
      System.out.println();
    }
  }
  if (!quiet)   System.out.println(""String_Node_Str"" + diffCount + ""String_Node_Str"");
  if (!quiet)   System.out.println(""String_Node_Str"");
}","/** 
 * Builds the difference of the given configurations and emits the results.
 * @param configs The list of given configurations.
 * @throws IOException When emitting the results fails.
 */
public void diff(ArrayList<Configuration> configs) throws IOException {
  if (!quiet) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
  }
  MergedConfiguration mc=new MergedConfiguration();
  TreeSet<String> prevKeys=null;
  Configuration prevConf=null;
  if (!quiet)   System.out.println(""String_Node_Str"");
  for (  Configuration conf : configs) {
    TreeSet<String> keys=new TreeSet<String>();
    for (    Property p : conf.getProperties()) {
      mc.addProperty(p);
      keys.add(p.getKey());
    }
    if (conf.getProperties().size() > 0) {
      String currentVersion=conf.getProperties().first().getSource();
      if (prevKeys != null) {
        TreeSet<String> addedKeys=new TreeSet<String>(keys);
        addedKeys.removeAll(prevKeys);
        if (addedKeys.size() > 0) {
          if (!quiet)           System.out.println(""String_Node_Str"" + currentVersion + ""String_Node_Str"");
          int addedCount=0, renamedCount=0;
          for (          String key : addedKeys) {
            Property p=conf.getProperty(key);
            Property p2=prevConf.getPropertyByDescription(p.getDescription());
            boolean renamed=!Property.NULL.equals(p.getDescription()) && p2 != null;
            if (renamed)             renamedCount++;
 else             addedCount++;
            printProperty(p,p2,renamed ? Action.Renamed : Action.Added);
          }
          if (!quiet)           System.out.println(""String_Node_Str"" + currentVersion + ""String_Node_Str""+ addedCount+ ""String_Node_Str""+ renamedCount+ ""String_Node_Str"");
          System.out.println();
        }
        TreeSet<String> removedKeys=new TreeSet<String>(prevKeys);
        removedKeys.removeAll(keys);
        if (removedKeys.size() > 0) {
          System.out.println(""String_Node_Str"" + currentVersion + ""String_Node_Str"");
          for (          String key : removedKeys) {
            Property p=prevConf.getProperty(key);
            printProperty(p,null,Action.Removed);
          }
          System.out.println();
        }
      }
    }
    prevKeys=keys;
    prevConf=conf;
  }
  if (!quiet)   System.out.println(""String_Node_Str"");
  if (!quiet)   System.out.println(""String_Node_Str"");
  int diffCount=0;
  for (  String key : mc.getProperties().keySet()) {
    TreeSet<Property> merged=mc.getProperties().get(key);
    if (merged.size() > 1) {
      if (!quiet)       System.out.println(""String_Node_Str"" + key);
      diffCount++;
      for (      Property p : merged) {
        printProperty(p,null,Action.Changed);
      }
      System.out.println();
    }
  }
  if (!quiet)   System.out.println(""String_Node_Str"" + diffCount + ""String_Node_Str"");
  if (!quiet)   System.out.println(""String_Node_Str"");
}",0.9078805325656712
26186,"/** 
 * @param metric
 * @return
 */
public boolean contains(final Metric metric){
  if (metric == this.rate) {
    return true;
  }
 else   if (this.intervals.values().contains(metric)) {
    return true;
  }
 else   if (this.sinceGauges.contains(metric)) {
    return true;
  }
 else   if (metric == this.timer) {
    return true;
  }
 else   if (this.counters.values().contains(metric)) {
    return true;
  }
 else   if (this.histograms.values().contains(metric)) {
    return true;
  }
 else   if (this.gauges.values().contains(metric)) {
    return true;
  }
 else   if (this.cachedGauges.values().contains(metric)) {
    return true;
  }
  return false;
}","/** 
 * @param metric
 * @return
 */
public boolean contains(final Metric metric){
  if (metric == this.rate) {
    return true;
  }
 else   if (this.intervals.values().contains(metric)) {
    return true;
  }
 else   if (this.sinceGauges.contains(metric)) {
    return true;
  }
 else   if (metric == this.timer) {
    return true;
  }
 else   if (this.counters.values().contains(metric)) {
    return true;
  }
 else   if (this.histograms.values().contains(metric)) {
    return true;
  }
 else   if (this.meters.values().contains(metric)) {
    return true;
  }
 else   if (this.gauges.values().contains(metric)) {
    return true;
  }
 else   if (this.cachedGauges.values().contains(metric)) {
    return true;
  }
  return false;
}",0.9470672389127324
26187,"/** 
 * @param cachedGaugeDefinition
 */
public void addCachedGaugeDefinition(final CachedGaugeDefinition cachedGaugeDefinition){
  if (cachedGaugeDefinition != null) {
    String subName=cachedGaugeDefinition.getName();
    if (subName == null) {
      subName=CachedGaugeDefinition.getNextDefaultName();
    }
    String lclName=MetricUtils.calculateFullMetricName(this.fullName,subName);
    LOGGER.debug(MARKER,""String_Node_Str"",lclName,cachedGaugeDefinition);
    CachedGauge<Object> cachedGauge=new CachedGauge<Object>(cachedGaugeDefinition.getDuration(),cachedGaugeDefinition.getDurationUnit()){
      @Override protected Object loadValue(){
        if (MetricGroup.this.lastExchange != null) {
          return cachedGaugeDefinition.getExpression().evaluate(MetricGroup.this.lastExchange,Object.class);
        }
 else {
          return null;
        }
      }
    }
;
    this.cachedGauges.put(cachedGaugeDefinition,cachedGauge);
  }
}","/** 
 * @param cachedGaugeDefinition
 */
public void addCachedGaugeDefinition(final CachedGaugeDefinition cachedGaugeDefinition){
  if (cachedGaugeDefinition != null) {
    String subName=cachedGaugeDefinition.getName();
    if (subName == null) {
      subName=CachedGaugeDefinition.getNextDefaultName();
    }
    String lclName=MetricUtils.calculateFullMetricName(this.fullName,subName);
    LOGGER.debug(MARKER,""String_Node_Str"",lclName,cachedGaugeDefinition);
    CachedGauge<Object> cachedGauge=new CachedGauge<Object>(cachedGaugeDefinition.getDuration(),cachedGaugeDefinition.getDurationUnit()){
      @Override protected Object loadValue(){
        if (MetricGroup.this.lastExchange != null) {
          return cachedGaugeDefinition.getExpression().evaluate(MetricGroup.this.lastExchange,Object.class);
        }
 else {
          return null;
        }
      }
    }
;
    this.metricRegistry.register(lclName,cachedGauge);
    this.cachedGauges.put(cachedGaugeDefinition,cachedGauge);
  }
}",0.9717223650385604
26188,"/** 
 * @param gaugeDefinition
 */
public void addGaugeDefinition(final GaugeDefinition gaugeDefinition){
  if (gaugeDefinition != null) {
    String subName=gaugeDefinition.getName();
    if (subName == null) {
      subName=GaugeDefinition.getNextDefaultName();
    }
    String lclName=MetricUtils.calculateFullMetricName(this.fullName,subName);
    LOGGER.debug(MARKER,""String_Node_Str"",lclName,gaugeDefinition);
    Gauge<Object> gauge=new Gauge<Object>(){
      @Override public Object getValue(){
        if (MetricGroup.this.lastExchange != null) {
          return gaugeDefinition.getExpression().evaluate(MetricGroup.this.lastExchange,Object.class);
        }
 else {
          return null;
        }
      }
    }
;
    this.gauges.put(gaugeDefinition,gauge);
  }
}","/** 
 * @param gaugeDefinition
 */
public void addGaugeDefinition(final GaugeDefinition gaugeDefinition){
  if (gaugeDefinition != null) {
    String subName=gaugeDefinition.getName();
    if (subName == null) {
      subName=GaugeDefinition.getNextDefaultName();
    }
    String lclName=MetricUtils.calculateFullMetricName(this.fullName,subName);
    LOGGER.debug(MARKER,""String_Node_Str"",lclName,gaugeDefinition);
    Gauge<Object> gauge=new Gauge<Object>(){
      @Override public Object getValue(){
        if (MetricGroup.this.lastExchange != null) {
          return gaugeDefinition.getExpression().evaluate(MetricGroup.this.lastExchange,Object.class);
        }
 else {
          return null;
        }
      }
    }
;
    this.metricRegistry.register(lclName,gauge);
    this.gauges.put(gaugeDefinition,gauge);
  }
}",0.9693941286695816
26189,"/** 
 * @param gauges the gauges to set
 */
public void setGauges(final String gauges){
  List<GaugeDefinition> gaugeDefinitions;
  try {
    gaugeDefinitions=GSON.fromJson(gauges,GsonHelper.GAUGE_DEFINITIONS_TYPE);
  }
 catch (  Exception e) {
    GaugeDefinition gaugeDefinition=GSON.fromJson(gauges,GsonHelper.GAUGE_DEFINITION_TYPE);
    gaugeDefinitions=new ArrayList<GaugeDefinition>();
    gaugeDefinitions.add(gaugeDefinition);
  }
  for (  GaugeDefinition gaugeDefinition : this.gaugeDefinitions) {
    gaugeDefinition.createExpression(getCamelContext());
  }
  this.gaugeDefinitions=gaugeDefinitions;
}","/** 
 * @param gauges the gauges to set
 */
public void setGauges(final String gauges){
  List<GaugeDefinition> gaugeDefinitions;
  try {
    gaugeDefinitions=GSON.fromJson(gauges,GsonHelper.GAUGE_DEFINITIONS_TYPE);
  }
 catch (  Exception e) {
    GaugeDefinition gaugeDefinition=GSON.fromJson(gauges,GsonHelper.GAUGE_DEFINITION_TYPE);
    gaugeDefinitions=new ArrayList<GaugeDefinition>();
    gaugeDefinitions.add(gaugeDefinition);
  }
  this.gaugeDefinitions=gaugeDefinitions;
  for (  GaugeDefinition gaugeDefinition : this.gaugeDefinitions) {
    gaugeDefinition.createExpression(getCamelContext());
  }
}",0.9312602291325696
26190,"/** 
 * @param cachedGauges the cachedGauges to set
 */
public void setCachedGauges(final String cachedGauges){
  List<CachedGaugeDefinition> cacheGaugeDefinitions;
  try {
    cacheGaugeDefinitions=GSON.fromJson(cachedGauges,CACHED_GAUGE_DEFINITIONS_TYPE);
  }
 catch (  Exception e) {
    CachedGaugeDefinition cachedGaugeDefinition=GSON.fromJson(cachedGauges,CACHED_GAUGE_DEFINITION_TYPE);
    cacheGaugeDefinitions=new ArrayList<CachedGaugeDefinition>();
    cacheGaugeDefinitions.add(cachedGaugeDefinition);
  }
  for (  CachedGaugeDefinition cachedGaugeDefinition : cacheGaugeDefinitions) {
    cachedGaugeDefinition.createExpression(getCamelContext());
  }
  this.cachedGaugeDefinitions=cacheGaugeDefinitions;
}","/** 
 * @param cachedGauges the cachedGauges to set
 */
public void setCachedGauges(final String cachedGauges){
  List<CachedGaugeDefinition> cacheGaugeDefinitions;
  try {
    cacheGaugeDefinitions=GSON.fromJson(cachedGauges,CACHED_GAUGE_DEFINITIONS_TYPE);
  }
 catch (  Exception e) {
    CachedGaugeDefinition cachedGaugeDefinition=GSON.fromJson(cachedGauges,CACHED_GAUGE_DEFINITION_TYPE);
    cacheGaugeDefinitions=new ArrayList<CachedGaugeDefinition>();
    cacheGaugeDefinitions.add(cachedGaugeDefinition);
  }
  this.cachedGaugeDefinitions=cacheGaugeDefinitions;
  for (  CachedGaugeDefinition cachedGaugeDefinition : cacheGaugeDefinitions) {
    cachedGaugeDefinition.createExpression(getCamelContext());
  }
}",0.926183844011142
26191,"/** 
 * @param value
 * @param runtimeValue
 * @param runtimeSimpleValue
 * @param creatingExchange
 * @return
 */
public static String evaluateValue(final String value,final String runtimeValue,final String runtimeSimpleValue,final Exchange creatingExchange){
  final String evaluatedValue;
  if (creatingExchange == null) {
    evaluatedValue=value;
  }
 else {
    if (runtimeSimpleValue == null) {
      evaluatedValue=runtimeValue;
    }
 else {
      evaluatedValue=evaluateExpression(runtimeSimpleValue,creatingExchange,String.class);
    }
  }
  return evaluatedValue;
}","/** 
 * @param value
 * @param runtimeValue
 * @param runtimeSimpleValue
 * @param creatingExchange
 * @return
 */
public static String evaluateValue(final String value,final String runtimeValue,final String runtimeSimpleValue,final Exchange creatingExchange){
  if (creatingExchange != null) {
    final String evaluatedValue;
    if (runtimeSimpleValue == null) {
      evaluatedValue=runtimeValue;
    }
 else {
      evaluatedValue=evaluateExpression(runtimeSimpleValue,creatingExchange,String.class);
    }
    if (evaluatedValue != null) {
      return evaluatedValue;
    }
  }
  return value;
}",0.8661016949152542
26192,"/** 
 * @param deltaInNanos
 */
private void updateAllIntervals(final long deltaInNanos){
  for (  Entry<TimeUnit,Histogram> entry : this.intervals.entrySet()) {
    long delta=entry.getKey().convert(deltaInNanos,TimeUnit.NANOSECONDS);
    LOGGER.info(""String_Node_Str"",entry.getKey(),delta);
    entry.getValue().update(delta);
  }
}","/** 
 * @param deltaInNanos
 */
private void updateAllIntervals(final long deltaInNanos){
  for (  Entry<TimeUnit,Histogram> entry : this.intervals.entrySet()) {
    Histogram histogram=entry.getValue();
    long delta=entry.getKey().convert(deltaInNanos,TimeUnit.NANOSECONDS);
    LOGGER.info(""String_Node_Str"",entry.getKey(),delta);
    LOGGER.info(""String_Node_Str"",histogram);
    LOGGER.info(""String_Node_Str"",histogram.getSnapshot().get99thPercentile());
    histogram.update(delta);
    LOGGER.info(""String_Node_Str"",histogram.getSnapshot().get99thPercentile());
  }
}",0.6996699669966997
26193,"@Override public ConsoleReporterDefinition applyAsOverride(final ConsoleReporterDefinition override){
  ConsoleReporterDefinition consoleReporterDefinition=new ConsoleReporterDefinition();
  consoleReporterDefinition.setName(this.name);
  consoleReporterDefinition.setDurationUnit(this.durationUnit);
  consoleReporterDefinition.setRateUnit(this.rateUnit);
  consoleReporterDefinition.setPeriodDuration(this.periodDuration);
  consoleReporterDefinition.setPeriodDurationUnit(this.periodDurationUnit);
  consoleReporterDefinition.setFilter(this.filter);
  consoleReporterDefinition.setNameIfNotNull(override.getName());
  consoleReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  consoleReporterDefinition.setRateUnitIfNotNull(override.getDurationUnit());
  consoleReporterDefinition.setPeriodDurationIfNotNull(override.getPeriodDuration());
  consoleReporterDefinition.setPeriodDurationUnitIfNotNull(override.getPeriodDurationUnit());
  consoleReporterDefinition.setFilterIfNotNull(override.getFilter());
  return consoleReporterDefinition;
}","@Override public ConsoleReporterDefinition applyAsOverride(final ConsoleReporterDefinition override){
  ConsoleReporterDefinition consoleReporterDefinition=new ConsoleReporterDefinition();
  consoleReporterDefinition.setName(this.name);
  consoleReporterDefinition.setDurationUnit(this.durationUnit);
  consoleReporterDefinition.setRateUnit(this.rateUnit);
  consoleReporterDefinition.setPeriodDuration(this.periodDuration);
  consoleReporterDefinition.setPeriodDurationUnit(this.periodDurationUnit);
  consoleReporterDefinition.setFilter(this.filter);
  consoleReporterDefinition.setNameIfNotNull(override.getName());
  consoleReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  consoleReporterDefinition.setRateUnitIfNotNull(override.getRateUnit());
  consoleReporterDefinition.setPeriodDurationIfNotNull(override.getPeriodDuration());
  consoleReporterDefinition.setPeriodDurationUnitIfNotNull(override.getPeriodDurationUnit());
  consoleReporterDefinition.setFilterIfNotNull(override.getFilter());
  return consoleReporterDefinition;
}",0.9943609022556392
26194,"@Override public CsvReporterDefinition applyAsOverride(final CsvReporterDefinition override){
  CsvReporterDefinition csvReporterDefinition=new CsvReporterDefinition();
  csvReporterDefinition.setName(this.name);
  csvReporterDefinition.setDurationUnit(this.durationUnit);
  csvReporterDefinition.setRateUnit(this.rateUnit);
  csvReporterDefinition.setPeriodDuration(this.periodDuration);
  csvReporterDefinition.setPeriodDurationUnit(this.periodDurationUnit);
  csvReporterDefinition.setFilter(this.filter);
  csvReporterDefinition.setDirectory(this.directory);
  csvReporterDefinition.setNameIfNotNull(override.getName());
  csvReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  csvReporterDefinition.setRateUnitIfNotNull(override.getDurationUnit());
  csvReporterDefinition.setPeriodDurationIfNotNull(override.getPeriodDuration());
  csvReporterDefinition.setPeriodDurationUnitIfNotNull(override.getPeriodDurationUnit());
  csvReporterDefinition.setFilterIfNotNull(override.getFilter());
  csvReporterDefinition.setDirectoryIfNotNull(override.getDirectory());
  return csvReporterDefinition;
}","@Override public CsvReporterDefinition applyAsOverride(final CsvReporterDefinition override){
  CsvReporterDefinition csvReporterDefinition=new CsvReporterDefinition();
  csvReporterDefinition.setName(this.name);
  csvReporterDefinition.setDurationUnit(this.durationUnit);
  csvReporterDefinition.setRateUnit(this.rateUnit);
  csvReporterDefinition.setPeriodDuration(this.periodDuration);
  csvReporterDefinition.setPeriodDurationUnit(this.periodDurationUnit);
  csvReporterDefinition.setFilter(this.filter);
  csvReporterDefinition.setDirectory(this.directory);
  csvReporterDefinition.setNameIfNotNull(override.getName());
  csvReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  csvReporterDefinition.setRateUnitIfNotNull(override.getRateUnit());
  csvReporterDefinition.setPeriodDurationIfNotNull(override.getPeriodDuration());
  csvReporterDefinition.setPeriodDurationUnitIfNotNull(override.getPeriodDurationUnit());
  csvReporterDefinition.setFilterIfNotNull(override.getFilter());
  csvReporterDefinition.setDirectoryIfNotNull(override.getDirectory());
  return csvReporterDefinition;
}",0.9946332737030412
26195,"@Override public GraphiteReporterDefinition applyAsOverride(final GraphiteReporterDefinition override){
  GraphiteReporterDefinition graphiteReporterDefinition=new GraphiteReporterDefinition();
  graphiteReporterDefinition.setName(this.name);
  graphiteReporterDefinition.setDurationUnit(this.durationUnit);
  graphiteReporterDefinition.setRateUnit(this.rateUnit);
  graphiteReporterDefinition.setPeriodDuration(this.periodDuration);
  graphiteReporterDefinition.setPeriodDurationUnit(this.periodDurationUnit);
  graphiteReporterDefinition.setHost(this.host);
  graphiteReporterDefinition.setPort(this.port);
  graphiteReporterDefinition.setPrefix(this.prefix);
  graphiteReporterDefinition.setFilter(this.filter);
  graphiteReporterDefinition.setNameIfNotNull(override.getName());
  graphiteReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  graphiteReporterDefinition.setRateUnitIfNotNull(override.getDurationUnit());
  graphiteReporterDefinition.setPeriodDurationIfNotNull(override.getPeriodDuration());
  graphiteReporterDefinition.setPeriodDurationUnitIfNotNull(override.getPeriodDurationUnit());
  graphiteReporterDefinition.setHostIfNotNull(override.getHost());
  graphiteReporterDefinition.setPortIfNotNull(override.getPort());
  graphiteReporterDefinition.setPrefixIfNotNull(override.getPrefix());
  graphiteReporterDefinition.setFilterIfNotNull(override.getFilter());
  return graphiteReporterDefinition;
}","@Override public GraphiteReporterDefinition applyAsOverride(final GraphiteReporterDefinition override){
  GraphiteReporterDefinition graphiteReporterDefinition=new GraphiteReporterDefinition();
  graphiteReporterDefinition.setName(this.name);
  graphiteReporterDefinition.setDurationUnit(this.durationUnit);
  graphiteReporterDefinition.setRateUnit(this.rateUnit);
  graphiteReporterDefinition.setPeriodDuration(this.periodDuration);
  graphiteReporterDefinition.setPeriodDurationUnit(this.periodDurationUnit);
  graphiteReporterDefinition.setHost(this.host);
  graphiteReporterDefinition.setPort(this.port);
  graphiteReporterDefinition.setPrefix(this.prefix);
  graphiteReporterDefinition.setFilter(this.filter);
  graphiteReporterDefinition.setNameIfNotNull(override.getName());
  graphiteReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  graphiteReporterDefinition.setRateUnitIfNotNull(override.getRateUnit());
  graphiteReporterDefinition.setPeriodDurationIfNotNull(override.getPeriodDuration());
  graphiteReporterDefinition.setPeriodDurationUnitIfNotNull(override.getPeriodDurationUnit());
  graphiteReporterDefinition.setHostIfNotNull(override.getHost());
  graphiteReporterDefinition.setPortIfNotNull(override.getPort());
  graphiteReporterDefinition.setPrefixIfNotNull(override.getPrefix());
  graphiteReporterDefinition.setFilterIfNotNull(override.getFilter());
  return graphiteReporterDefinition;
}",0.995827538247566
26196,"@Override public JmxReporterDefinition applyAsOverride(final JmxReporterDefinition override){
  JmxReporterDefinition jmxReporterDefinition=new JmxReporterDefinition();
  jmxReporterDefinition.setName(this.name);
  jmxReporterDefinition.setDomain(this.domain);
  jmxReporterDefinition.setDurationUnit(this.durationUnit);
  jmxReporterDefinition.setRateUnit(this.rateUnit);
  jmxReporterDefinition.setFilter(this.filter);
  jmxReporterDefinition.setNameIfNotNull(override.getName());
  jmxReporterDefinition.setDomainIfNotNull(override.getDomain());
  jmxReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  jmxReporterDefinition.setRateUnitIfNotNull(override.getDurationUnit());
  jmxReporterDefinition.setFilterIfNotNull(override.getFilter());
  return jmxReporterDefinition;
}","@Override public JmxReporterDefinition applyAsOverride(final JmxReporterDefinition override){
  JmxReporterDefinition jmxReporterDefinition=new JmxReporterDefinition();
  jmxReporterDefinition.setName(this.name);
  jmxReporterDefinition.setDomain(this.domain);
  jmxReporterDefinition.setDurationUnit(this.durationUnit);
  jmxReporterDefinition.setRateUnit(this.rateUnit);
  jmxReporterDefinition.setFilter(this.filter);
  jmxReporterDefinition.setNameIfNotNull(override.getName());
  jmxReporterDefinition.setDomainIfNotNull(override.getDomain());
  jmxReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  jmxReporterDefinition.setRateUnitIfNotNull(override.getRateUnit());
  jmxReporterDefinition.setFilterIfNotNull(override.getFilter());
  return jmxReporterDefinition;
}",0.9924812030075189
26197,"@Override public Slf4jReporterDefinition applyAsOverride(final Slf4jReporterDefinition override){
  Slf4jReporterDefinition slf4jReporterDefinition=new Slf4jReporterDefinition();
  slf4jReporterDefinition.setName(this.name);
  slf4jReporterDefinition.setDurationUnit(this.durationUnit);
  slf4jReporterDefinition.setRateUnit(this.rateUnit);
  slf4jReporterDefinition.setPeriodDuration(this.periodDuration);
  slf4jReporterDefinition.setPeriodDurationUnit(this.periodDurationUnit);
  slf4jReporterDefinition.setFilter(this.filter);
  slf4jReporterDefinition.setLoggerName(this.loggerName);
  slf4jReporterDefinition.setMarkerName(this.markerName);
  slf4jReporterDefinition.setNameIfNotNull(override.getName());
  slf4jReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  slf4jReporterDefinition.setRateUnitIfNotNull(override.getDurationUnit());
  slf4jReporterDefinition.setPeriodDurationIfNotNull(override.getPeriodDuration());
  slf4jReporterDefinition.setPeriodDurationUnitIfNotNull(override.getPeriodDurationUnit());
  slf4jReporterDefinition.setFilterIfNotNull(override.getFilter());
  slf4jReporterDefinition.setLoggerNameIfNotNull(override.getLoggerName());
  slf4jReporterDefinition.setMarkerNameIfNotNull(override.getMarkerName());
  return slf4jReporterDefinition;
}","@Override public Slf4jReporterDefinition applyAsOverride(final Slf4jReporterDefinition override){
  Slf4jReporterDefinition slf4jReporterDefinition=new Slf4jReporterDefinition();
  slf4jReporterDefinition.setName(this.name);
  slf4jReporterDefinition.setDurationUnit(this.durationUnit);
  slf4jReporterDefinition.setRateUnit(this.rateUnit);
  slf4jReporterDefinition.setPeriodDuration(this.periodDuration);
  slf4jReporterDefinition.setPeriodDurationUnit(this.periodDurationUnit);
  slf4jReporterDefinition.setFilter(this.filter);
  slf4jReporterDefinition.setLoggerName(this.loggerName);
  slf4jReporterDefinition.setMarkerName(this.markerName);
  slf4jReporterDefinition.setNameIfNotNull(override.getName());
  slf4jReporterDefinition.setDurationUnitIfNotNull(override.getDurationUnit());
  slf4jReporterDefinition.setRateUnitIfNotNull(override.getRateUnit());
  slf4jReporterDefinition.setPeriodDurationIfNotNull(override.getPeriodDuration());
  slf4jReporterDefinition.setPeriodDurationUnitIfNotNull(override.getPeriodDurationUnit());
  slf4jReporterDefinition.setFilterIfNotNull(override.getFilter());
  slf4jReporterDefinition.setLoggerNameIfNotNull(override.getLoggerName());
  slf4jReporterDefinition.setMarkerNameIfNotNull(override.getMarkerName());
  return slf4jReporterDefinition;
}",0.9953703703703703
26198,"/** 
 * @param uri
 * @param metricsComponent
 * @param name
 * @param parameters
 * @throws Exception
 */
public MetricsEndpoint(final String uri,final MetricsComponent metricsComponent,final String name,final Map<String,Object> parameters) throws Exception {
  super(uri,metricsComponent);
  LOGGER.debug(MARKER,""String_Node_Str"",uri,metricsComponent,parameters);
  this.metricsComponent=metricsComponent;
  this.name=name;
  warnIfTimingStopIsUsedWithOtherParameters(parameters);
  EndpointHelper.setProperties(getCamelContext(),this,parameters);
switch (this.timingAction) {
case STOP:
    LOGGER.debug(MARKER,""String_Node_Str"",this.timingAction);
  break;
default :
this.metricsComponent.registerName(this.name);
initializeMetricGroup(this.name);
break;
}
}","/** 
 * @param uri
 * @param metricsComponent
 * @param name
 * @param parameters
 * @throws Exception
 */
public MetricsEndpoint(final String uri,final MetricsComponent metricsComponent,final String name,final Map<String,Object> parameters) throws Exception {
  super(uri,metricsComponent);
  LOGGER.info(MARKER,""String_Node_Str"",uri,metricsComponent,parameters);
  this.metricsComponent=metricsComponent;
  this.name=name;
  warnIfTimingStopIsUsedWithOtherParameters(parameters);
  EndpointHelper.setProperties(getCamelContext(),this,parameters);
switch (this.timingAction) {
case STOP:
    LOGGER.debug(MARKER,""String_Node_Str"",this.timingAction);
  break;
default :
initializeMetricGroup(this.name);
break;
}
}",0.4823848238482385
26199,"/** 
 * @param metricRegistry
 * @return
 */
public Slf4jReporter buildReporter(final MetricRegistry metricRegistry,final Exchange creatingExchange,final MetricGroup metricGroup){
  Slf4jReporterDefinition definitionWithDefaults=getReporterDefinitionWithDefaults();
  final String filterValue=evaluateValue(definitionWithDefaults.getFilter(),definitionWithDefaults.getRuntimeFilter(),definitionWithDefaults.getRuntimeSimpleFilter(),creatingExchange);
  final String loggerNameValue=evaluateValue(definitionWithDefaults.getFilter(),definitionWithDefaults.getRuntimeFilter(),definitionWithDefaults.getRuntimeSimpleFilter(),creatingExchange);
  final String markerNameValue=evaluateValue(definitionWithDefaults.getFilter(),definitionWithDefaults.getRuntimeFilter(),definitionWithDefaults.getRuntimeSimpleFilter(),creatingExchange);
  Slf4jReporter slf4jReporter=Slf4jReporter.forRegistry(metricRegistry).convertDurationsTo(definitionWithDefaults.getDurationUnit()).convertRatesTo(definitionWithDefaults.getRateUnit()).filter(new MetricFilter(){
    @Override public boolean matches(    final String name,    final Metric metric){
      if (!metricGroup.contains(metric)) {
        return false;
      }
      if (name == null || filterValue == null) {
        return true;
      }
      boolean result=name.matches(filterValue);
      return result;
    }
  }
).outputTo(LoggerFactory.getLogger(loggerNameValue)).markWith(MarkerFactory.getMarker(markerNameValue)).build();
  return slf4jReporter;
}","/** 
 * @param metricRegistry
 * @return
 */
public Slf4jReporter buildReporter(final MetricRegistry metricRegistry,final Exchange creatingExchange,final MetricGroup metricGroup){
  Slf4jReporterDefinition definitionWithDefaults=getReporterDefinitionWithDefaults();
  final String filterValue=evaluateValue(definitionWithDefaults.getFilter(),definitionWithDefaults.getRuntimeFilter(),definitionWithDefaults.getRuntimeSimpleFilter(),creatingExchange);
  final String loggerNameValue=evaluateValue(definitionWithDefaults.getLoggerName(),definitionWithDefaults.getRuntimeLoggerName(),definitionWithDefaults.getRuntimeSimpleLoggerName(),creatingExchange);
  final String markerNameValue=evaluateValue(definitionWithDefaults.getMarkerName(),definitionWithDefaults.getRuntimeMarkerName(),definitionWithDefaults.getRuntimeSimpleMarkerName(),creatingExchange);
  Slf4jReporter slf4jReporter=Slf4jReporter.forRegistry(metricRegistry).convertDurationsTo(definitionWithDefaults.getDurationUnit()).convertRatesTo(definitionWithDefaults.getRateUnit()).filter(new MetricFilter(){
    @Override public boolean matches(    final String name,    final Metric metric){
      if (!metricGroup.contains(metric)) {
        return false;
      }
      if (name == null || filterValue == null) {
        return true;
      }
      boolean result=name.matches(filterValue);
      return result;
    }
  }
).outputTo(LoggerFactory.getLogger(loggerNameValue)).markWith(MarkerFactory.getMarker(markerNameValue)).build();
  return slf4jReporter;
}",0.9681486396814863
26200,"/** 
 * @param exchange
 */
public void mark(final Exchange exchange){
  long deltaInNanos=lastExchangeDelta();
  this.lastExchange=exchange;
  this.lastExchangeTime=System.nanoTime();
  this.exchangeRate.mark();
  updateAllIntervals(deltaInNanos);
}","/** 
 * @param exchange
 */
public void mark(final Exchange exchange){
  long deltaInNanos=lastExchangeDelta();
  this.lastExchange=exchange;
  this.lastExchangeTime=System.nanoTime();
  this.exchangeRate.mark();
  if (this.haveProcessedAtLeastOneExchange) {
    this.haveProcessedAtLeastOneExchange=true;
    updateAllIntervals(deltaInNanos);
  }
}",0.8347245409015025
26201,"@Override public void process(final Exchange exchange) throws Exception {
  LOGGER.debug(MARKER,""String_Node_Str"",exchange);
  if (this.haveProcessedAtLeastOneExchange) {
    this.haveProcessedAtLeastOneExchange=true;
    Context internalContext=null;
    if (this.endpoint.isInternalTimerEnabled()) {
      Timer internalTimer=this.endpoint.getInternalTimer();
      if (internalTimer != null) {
        internalContext=internalTimer.time();
      }
    }
    try {
switch (this.endpoint.getTimingAction()) {
case START:
        startTimer(exchange);
case NOOP:
      this.endpoint.mark(exchange);
    addOptionalCounter(exchange);
  addOptionalHistogram(exchange);
break;
case STOP:
stopTimer(exchange);
break;
}
}
  finally {
if (internalContext != null) {
internalContext.stop();
}
}
}
}","@Override public void process(final Exchange exchange) throws Exception {
  LOGGER.debug(MARKER,""String_Node_Str"",exchange);
  Context internalContext=null;
  if (this.endpoint.isInternalTimerEnabled()) {
    Timer internalTimer=this.endpoint.getInternalTimer();
    if (internalTimer != null) {
      internalContext=internalTimer.time();
    }
  }
  try {
switch (this.endpoint.getTimingAction()) {
case START:
      startTimer(exchange);
case NOOP:
    this.endpoint.mark(exchange);
  addOptionalCounter(exchange);
addOptionalHistogram(exchange);
break;
case STOP:
stopTimer(exchange);
break;
}
}
  finally {
if (internalContext != null) {
internalContext.stop();
}
}
}",0.7778537252221462
26202,"/** 
 */
public MetricsComponent(final ReporterDefinition... newReporterDefinitions){
  super(MetricsEndpoint.class);
  LOGGER.info(MARKER,""String_Node_Str"",(Object[])newReporterDefinitions);
  for (  ReporterDefinition reporterDefinition : newReporterDefinitions) {
    String reporterDefinitionName=reporterDefinition.getName();
    if (reporterDefinitionName != null && this.reporterDefinitions.containsKey(reporterDefinitionName)) {
      throw new RuntimeCamelException(""String_Node_Str"" + reporterDefinitionName);
    }
    this.reporterDefinitions.put(reporterDefinitionName,reporterDefinition);
  }
}","/** 
 * @param newReporterDefinitions
 */
public MetricsComponent(final ReporterDefinition... newReporterDefinitions){
  super(MetricsEndpoint.class);
  LOGGER.info(MARKER,""String_Node_Str"",(Object[])newReporterDefinitions);
  for (  ReporterDefinition reporterDefinition : newReporterDefinitions) {
    String reporterDefinitionName=reporterDefinition.getName();
    if (reporterDefinitionName != null && this.reporterDefinitions.containsKey(reporterDefinitionName)) {
      throw new RuntimeCamelException(""String_Node_Str"" + reporterDefinitionName);
    }
    this.reporterDefinitions.put(reporterDefinitionName,reporterDefinition);
  }
}",0.9735788630904724
26203,"/** 
 * @param uri
 * @param metricsComponent
 * @param name
 * @param parameters
 * @throws Exception
 */
public MetricsEndpoint(final String uri,final MetricsComponent metricsComponent,final String name,final Map<String,Object> parameters) throws Exception {
  super(uri,metricsComponent);
  LOGGER.debug(MARKER,""String_Node_Str"",uri,metricsComponent,parameters);
  this.metricsComponent=metricsComponent;
  this.name=name;
  this.metricsComponent.registerName(this.name);
  this.metricRegistry=new MetricRegistry();
  LoggingMetricRegistryListener listener=new LoggingMetricRegistryListener(LOGGER,MARKER,LoggingMetricRegistryListener.Level.INFO);
  this.metricRegistry.addListener(listener);
  warnIfTimingStopIsUsedWithOtherParameters(parameters);
  EndpointHelper.setProperties(getCamelContext(),this,parameters);
switch (this.timingAction) {
case STOP:
    LOGGER.debug(MARKER,""String_Node_Str"",this.timingAction);
  break;
default :
initializeMetrics();
break;
}
}","/** 
 * @param uri
 * @param metricsComponent
 * @param name
 * @param parameters
 * @throws Exception
 */
public MetricsEndpoint(final String uri,final MetricsComponent metricsComponent,final String name,final Map<String,Object> parameters) throws Exception {
  super(uri,metricsComponent);
  LOGGER.debug(MARKER,""String_Node_Str"",uri,metricsComponent,parameters);
  this.metricsComponent=metricsComponent;
  this.name=name;
  this.metricRegistry=new MetricRegistry();
  LoggingMetricRegistryListener listener=new LoggingMetricRegistryListener(LOGGER,MARKER,LoggingMetricRegistryListener.Level.INFO);
  this.metricRegistry.addListener(listener);
  warnIfTimingStopIsUsedWithOtherParameters(parameters);
  EndpointHelper.setProperties(getCamelContext(),this,parameters);
switch (this.timingAction) {
case STOP:
    LOGGER.debug(MARKER,""String_Node_Str"",this.timingAction);
  break;
default :
this.metricsComponent.registerName(this.name);
initializeMetrics();
break;
}
}",0.9505664263645726
26204,"/** 
 * @param value
 * @param type
 * @return
 */
public static <T>T parse(final String value,final Class<T> type){
  if (Boolean.class.isAssignableFrom(type)) {
    type.cast(parseBoolean(value));
  }
 else   if (TimeUnit.class.isAssignableFrom(type)) {
    type.cast(parseTimeUnit(value));
  }
  return null;
}","/** 
 * @param value
 * @param type
 * @return
 */
public static <T>T parse(final String value,final Class<T> type){
  if (Boolean.class.isAssignableFrom(type)) {
    return type.cast(parseBoolean(value));
  }
 else   if (TimeUnit.class.isAssignableFrom(type)) {
    return type.cast(parseTimeUnit(value));
  }
  return null;
}",0.978125
26205,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setActionBarContentView(R.layout.insight_vote);
  SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
  accessToken=prefs.getString(""String_Node_Str"",null);
  userName=prefs.getString(""String_Node_Str"",null);
  insightList=new ArrayList<InsightListItem>();
  cxt=this;
  radioGroup=(RadioGroup)findViewById(R.id.agreeDisagreeButtons);
  radioAgree=(RadioButton)findViewById(R.id.buttonAgree);
  radioAgree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      agree();
    }
  }
);
  radioDisagree=(RadioButton)findViewById(R.id.buttonDisagree);
  radioDisagree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      disagree();
    }
  }
);
  pager=(ViewPager)findViewById(R.id.insightPager);
  pager.setAdapter(new InsightListPagerAdapter());
  pager.setOnPageChangeListener(new MyPageChangeListener());
  if (accessToken == null) {
    openConnectScreen();
    return;
  }
  final ActivityData data=(ActivityData)getLastNonConfigurationInstance();
  if (data != null) {
    insightList=data.insightList;
    currentInsightIndex=data.currentInsightIndex;
  }
 else {
    String alertTitle=""String_Node_Str"";
    if (userName != null) {
      alertTitle=userName;
    }
    loadingInsightsDialog=ProgressDialog.show(this,alertTitle,getResources().getText(R.string.loading_insights),true);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
    fetchNextInsights();
  }
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setActionBarContentView(R.layout.insight_vote);
  SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
  accessToken=prefs.getString(""String_Node_Str"",null);
  userName=prefs.getString(""String_Node_Str"",null);
  insightList=new ArrayList<InsightListItem>();
  cxt=this;
  radioGroup=(RadioGroup)findViewById(R.id.agreeDisagreeButtons);
  radioAgree=(RadioButton)findViewById(R.id.buttonAgree);
  radioAgree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      agree();
    }
  }
);
  radioDisagree=(RadioButton)findViewById(R.id.buttonDisagree);
  radioDisagree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      disagree();
    }
  }
);
  pager=(ViewPager)findViewById(R.id.insightPager);
  pager.setAdapter(new InsightListPagerAdapter());
  pager.setOnPageChangeListener(new MyPageChangeListener());
  if (accessToken == null) {
    openConnectScreen();
    return;
  }
  final ActivityData data=(ActivityData)getLastNonConfigurationInstance();
  if (data != null) {
    insightList=data.insightList;
    currentInsightIndex=data.currentInsightIndex;
  }
 else {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
    showDialog(DIALOG_LOADING_INSIGHTS_ID);
    fetchNextInsights();
  }
}",0.9114331723027376
26206,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setActionBarContentView(R.layout.insight_vote);
  SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
  accessToken=prefs.getString(""String_Node_Str"",null);
  userName=prefs.getString(""String_Node_Str"",null);
  insightList=new ArrayList<InsightListItem>();
  cxt=this;
  radioGroup=(RadioGroup)findViewById(R.id.agreeDisagreeButtons);
  radioAgree=(RadioButton)findViewById(R.id.buttonAgree);
  radioAgree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      agree();
    }
  }
);
  radioDisagree=(RadioButton)findViewById(R.id.buttonDisagree);
  radioDisagree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      disagree();
    }
  }
);
  pager=(ViewPager)findViewById(R.id.insightPager);
  pager.setAdapter(new InsightListPagerAdapter());
  pager.setOnPageChangeListener(new MyPageChangeListener());
  if (accessToken == null) {
    openConnectScreen();
    return;
  }
  final ActivityData data=(ActivityData)getLastNonConfigurationInstance();
  if (data != null) {
    insightList=data.insightList;
    currentInsightIndex=data.currentInsightIndex;
  }
 else {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
    showDialog(DIALOG_LOADING_INSIGHTS_ID);
    fetchNextInsights();
  }
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setActionBarContentView(R.layout.insight_vote);
  SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
  accessToken=prefs.getString(""String_Node_Str"",null);
  userName=prefs.getString(""String_Node_Str"",null);
  insightList=new ArrayList<InsightListItem>();
  cxt=this;
  radioGroup=(RadioGroup)findViewById(R.id.agreeDisagreeButtons);
  radioAgree=(RadioButton)findViewById(R.id.buttonAgree);
  radioAgree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      agree();
    }
  }
);
  radioDisagree=(RadioButton)findViewById(R.id.buttonDisagree);
  radioDisagree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      disagree();
    }
  }
);
  pager=(ViewPager)findViewById(R.id.insightPager);
  pager.setAdapter(new InsightListPagerAdapter());
  pager.setOnPageChangeListener(new MyPageChangeListener());
  if (accessToken == null) {
    openConnectScreen();
    return;
  }
  final ActivityData data=(ActivityData)getLastNonConfigurationInstance();
  if (data != null) {
    insightList=data.insightList;
    currentInsightIndex=data.currentInsightIndex;
  }
  if (insightList.isEmpty()) {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
    showDialog(DIALOG_LOADING_INSIGHTS_ID);
    fetchNextInsights();
  }
}",0.989495086411386
26207,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.insight_vote);
  SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
  accessToken=prefs.getString(""String_Node_Str"",null);
  userName=prefs.getString(""String_Node_Str"",null);
  insightList=new ArrayList<InsightListItem>();
  cxt=this;
  radioGroup=(RadioGroup)findViewById(R.id.agreeDisagreeButtons);
  radioAgree=(RadioButton)findViewById(R.id.buttonAgree);
  radioAgree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      agree();
    }
  }
);
  radioDisagree=(RadioButton)findViewById(R.id.buttonDisagree);
  radioDisagree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      disagree();
    }
  }
);
  pager=(ViewPager)findViewById(R.id.insightPager);
  pager.setAdapter(new InsightListPagerAdapter());
  pager.setOnPageChangeListener(new MyPageChangeListener());
  final ActivityData data=(ActivityData)getLastNonConfigurationInstance();
  if (data != null) {
    insightList=data.insightList;
    currentInsightIndex=data.currentInsightIndex;
  }
 else {
    String alertTitle=""String_Node_Str"";
    if (userName != null) {
      alertTitle=userName;
    }
    loadingInsightsDialog=ProgressDialog.show(this,alertTitle,getResources().getText(R.string.loading_insights),true);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
    fetchNextInsights();
  }
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.insight_vote);
  SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
  accessToken=prefs.getString(""String_Node_Str"",null);
  userName=prefs.getString(""String_Node_Str"",null);
  insightList=new ArrayList<InsightListItem>();
  cxt=this;
  radioGroup=(RadioGroup)findViewById(R.id.agreeDisagreeButtons);
  radioAgree=(RadioButton)findViewById(R.id.buttonAgree);
  radioAgree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      agree();
    }
  }
);
  radioDisagree=(RadioButton)findViewById(R.id.buttonDisagree);
  radioDisagree.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      disagree();
    }
  }
);
  pager=(ViewPager)findViewById(R.id.insightPager);
  pager.setAdapter(new InsightListPagerAdapter());
  pager.setOnPageChangeListener(new MyPageChangeListener());
  if (accessToken == null) {
    openConnectScreen();
    return;
  }
  final ActivityData data=(ActivityData)getLastNonConfigurationInstance();
  if (data != null) {
    insightList=data.insightList;
    currentInsightIndex=data.currentInsightIndex;
  }
 else {
    String alertTitle=""String_Node_Str"";
    if (userName != null) {
      alertTitle=userName;
    }
    loadingInsightsDialog=ProgressDialog.show(this,alertTitle,getResources().getText(R.string.loading_insights),true);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
    fetchNextInsights();
  }
}",0.9780839073262368
26208,"public void onPageStarted(WebView view,String url,Bitmap favicon){
  Log.v(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str"");
  int start=url.indexOf(FRAGMENT);
  if (start > -1) {
    String accessToken=url.substring(start + FRAGMENT.length(),url.length());
    Log.v(""String_Node_Str"",""String_Node_Str"" + accessToken + ""String_Node_Str"");
    SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
    Editor editor=prefs.edit();
    editor.putString(""String_Node_Str"",accessToken);
    editor.commit();
    Intent homeActivity=new Intent(WebViewActivity.this,HomeActivity.class);
    startActivity(homeActivity);
  }
}","public void onPageStarted(WebView view,String url,Bitmap favicon){
  int start=url.indexOf(FRAGMENT);
  if (start > -1) {
    String accessToken=url.substring(start + FRAGMENT.length(),url.length());
    Log.v(""String_Node_Str"",""String_Node_Str"" + accessToken + ""String_Node_Str"");
    SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
    Editor editor=prefs.edit();
    editor.putString(""String_Node_Str"",accessToken);
    editor.commit();
    Intent homeActivity=new Intent(WebViewActivity.this,HomeActivity.class);
    startActivity(homeActivity);
  }
}",0.9427662957074722
26209,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_webview);
  String url=BeansightApi.DOMAIN + ""String_Node_Str"";
  WebView webView=(WebView)findViewById(R.id.webkitWebView);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.setWebViewClient(new WebViewClient(){
    public void onPageStarted(    WebView view,    String url,    Bitmap favicon){
      Log.v(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str"");
      int start=url.indexOf(FRAGMENT);
      if (start > -1) {
        String accessToken=url.substring(start + FRAGMENT.length(),url.length());
        Log.v(""String_Node_Str"",""String_Node_Str"" + accessToken + ""String_Node_Str"");
        SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
        Editor editor=prefs.edit();
        editor.putString(""String_Node_Str"",accessToken);
        editor.commit();
        Intent homeActivity=new Intent(WebViewActivity.this,HomeActivity.class);
        startActivity(homeActivity);
      }
    }
    public void onPageFinished(    WebView view,    String url){
      int start=url.indexOf(FRAGMENT);
      if (start > -1) {
        CookieManager.getInstance().removeAllCookie();
        Log.v(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
);
  webView.loadUrl(url);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_webview);
  String url=BeansightApi.DOMAIN + ""String_Node_Str"";
  WebView webView=(WebView)findViewById(R.id.webkitWebView);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.setWebViewClient(new WebViewClient(){
    public void onPageStarted(    WebView view,    String url,    Bitmap favicon){
      int start=url.indexOf(FRAGMENT);
      if (start > -1) {
        String accessToken=url.substring(start + FRAGMENT.length(),url.length());
        Log.v(""String_Node_Str"",""String_Node_Str"" + accessToken + ""String_Node_Str"");
        SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
        Editor editor=prefs.edit();
        editor.putString(""String_Node_Str"",accessToken);
        editor.commit();
        Intent homeActivity=new Intent(WebViewActivity.this,HomeActivity.class);
        startActivity(homeActivity);
      }
    }
    public void onPageFinished(    WebView view,    String url){
      int start=url.indexOf(FRAGMENT);
      if (start > -1) {
        CookieManager.getInstance().removeAllCookie();
        Log.v(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
);
  webView.loadUrl(url);
}",0.9715781600598354
26210,"public static InsightDetailResponse show(String accessToken,String id) throws NotAuthenticatedException, IOException, ServerErrorException {
  Log.v(""String_Node_Str"",String.format(""String_Node_Str"",accessToken,id));
  InsightDetailResponse insightDetailResponse=null;
  String result=generateRequest(""String_Node_Str"",accessToken).data(""String_Node_Str"",id).asString();
  Gson gson=new Gson();
  try {
    insightDetailResponse=gson.fromJson(result,InsightDetailResponse.class);
  }
 catch (  JsonSyntaxException e) {
    throw new ServerErrorException(e);
  }
  return insightDetailResponse;
}","public static InsightDetailResponse show(String accessToken,String id) throws NotAuthenticatedException, IOException, ServerErrorException {
  InsightDetailResponse insightDetailResponse=null;
  String result=generateRequest(""String_Node_Str"",accessToken).data(""String_Node_Str"",id).asString();
  Gson gson=new Gson();
  try {
    insightDetailResponse=gson.fromJson(result,InsightDetailResponse.class);
  }
 catch (  JsonSyntaxException e) {
    throw new ServerErrorException(e);
  }
  return insightDetailResponse;
}",0.5816876122082585
26211,"private static HttpRequestBuilder generateRequest(String apiAction,String accessToken){
  String url=String.format(""String_Node_Str"" + apiAction,DOMAIN);
  return Http.get(url).use(client).data(""String_Node_Str"",accessToken);
}","private static HttpRequestBuilder generateRequest(String apiAction,String accessToken){
  HttpClient client=new DefaultHttpClient();
  String url=String.format(""String_Node_Str"" + apiAction,DOMAIN);
  return Http.get(url).use(client).data(""String_Node_Str"",accessToken);
}",0.9098196392785572
26212,"public void onPageStarted(WebView view,String url,Bitmap favicon){
  String fragment=""String_Node_Str"";
  int start=url.indexOf(fragment);
  if (start > -1) {
    String accessToken=url.substring(start + fragment.length(),url.length());
    Log.v(""String_Node_Str"",""String_Node_Str"" + accessToken + ""String_Node_Str"");
    SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
    Editor editor=prefs.edit();
    editor.putString(""String_Node_Str"",accessToken);
    editor.commit();
    Intent homeActivity=new Intent(WebViewActivity.this,HomeActivity.class);
    startActivity(homeActivity);
  }
}","public void onPageStarted(WebView view,String url,Bitmap favicon){
  Log.v(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str"");
  int start=url.indexOf(FRAGMENT);
  if (start > -1) {
    String accessToken=url.substring(start + FRAGMENT.length(),url.length());
    Log.v(""String_Node_Str"",""String_Node_Str"" + accessToken + ""String_Node_Str"");
    SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
    Editor editor=prefs.edit();
    editor.putString(""String_Node_Str"",accessToken);
    editor.commit();
    Intent homeActivity=new Intent(WebViewActivity.this,HomeActivity.class);
    startActivity(homeActivity);
  }
}",0.8972972972972973
26213,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_webview);
  String url=BeansightApi.domain + ""String_Node_Str"";
  WebView webView=(WebView)findViewById(R.id.webkitWebView);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.setWebViewClient(new WebViewClient(){
    public void onPageStarted(    WebView view,    String url,    Bitmap favicon){
      String fragment=""String_Node_Str"";
      int start=url.indexOf(fragment);
      if (start > -1) {
        String accessToken=url.substring(start + fragment.length(),url.length());
        Log.v(""String_Node_Str"",""String_Node_Str"" + accessToken + ""String_Node_Str"");
        SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
        Editor editor=prefs.edit();
        editor.putString(""String_Node_Str"",accessToken);
        editor.commit();
        Intent homeActivity=new Intent(WebViewActivity.this,HomeActivity.class);
        startActivity(homeActivity);
      }
    }
  }
);
  webView.loadUrl(url);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_webview);
  String url=BeansightApi.DOMAIN + ""String_Node_Str"";
  WebView webView=(WebView)findViewById(R.id.webkitWebView);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.setWebViewClient(new WebViewClient(){
    public void onPageStarted(    WebView view,    String url,    Bitmap favicon){
      Log.v(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str"");
      int start=url.indexOf(FRAGMENT);
      if (start > -1) {
        String accessToken=url.substring(start + FRAGMENT.length(),url.length());
        Log.v(""String_Node_Str"",""String_Node_Str"" + accessToken + ""String_Node_Str"");
        SharedPreferences prefs=getSharedPreferences(BeansightApplication.BEANSIGHT_PREFS,0);
        Editor editor=prefs.edit();
        editor.putString(""String_Node_Str"",accessToken);
        editor.commit();
        Intent homeActivity=new Intent(WebViewActivity.this,HomeActivity.class);
        startActivity(homeActivity);
      }
    }
    public void onPageFinished(    WebView view,    String url){
      int start=url.indexOf(FRAGMENT);
      if (start > -1) {
        CookieManager.getInstance().removeAllCookie();
        Log.v(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
);
  webView.loadUrl(url);
}",0.8402270884022709
26214,"private static HttpRequestBuilder generateRequest(String apiAction,String accessToken){
  String url=String.format(""String_Node_Str"" + apiAction,domain);
  return Http.get(url).use(client).data(""String_Node_Str"",accessToken);
}","private static HttpRequestBuilder generateRequest(String apiAction,String accessToken){
  String url=String.format(""String_Node_Str"" + apiAction,DOMAIN);
  return Http.get(url).use(client).data(""String_Node_Str"",accessToken);
}",0.973568281938326
26215,"public void reduce(TextPairWC termFile,Iterable<TermInfo> termInfos,Context context) throws IOException, InterruptedException {
  TermInfo[] termInfos_Array=Iterables.toArray(termInfos,TermInfo.class);
  IntWritable df=new IntWritable(termInfos_Array.length);
  context.write(new TextIntWC(termFile.getFirst(),df),new TermInfoArray(termInfos_Array));
}","public void reduce(TextPairWC termFile,Iterable<TermInfo> termInfos,Context context) throws IOException, InterruptedException {
  ArrayList<TermInfo> termInfos_lst=new ArrayList<TermInfo>();
  for (  TermInfo termInfo : termInfos)   termInfos_lst.add((TermInfo)WritableUtils.clone(termInfo,context.getConfiguration()));
  TermInfo[] termInfos_Array=termInfos_lst.toArray(new TermInfo[termInfos_lst.size()]);
  IntWritable df=new IntWritable(termInfos_Array.length);
  context.write(new TextIntWC(termFile.getFirst(),df),new TermInfoArray(termInfos_Array));
}",0.6813186813186813
26216,"/** 
 * Compare an elastic and a raw transform loaded from file. The result is expressed using the warping index and displayed in the Log window.
 * @param elasticTransfPath complete path to elastic transform file
 * @param rawTransfPath complete path to raw transform file
 */
public static void compareElasticRawTransforms(final String elasticTransfPath,final String rawTransfPath){
  final MainDialog md=bUnwarpJ_.getMainDialog();
  if (null == md) {
    IJ.log(""String_Node_Str"");
    return;
  }
  int intervals=MiscTools.numberOfIntervalsOfTransformation(elasticTransfPath);
  double[][] cx=new double[intervals + 3][intervals + 3];
  double[][] cy=new double[intervals + 3][intervals + 3];
  MiscTools.loadTransformation(elasticTransfPath,cx,cy);
  final double[][] transformation_x=new double[md.getTarget().getHeight()][md.getTarget().getWidth()];
  final double[][] transformation_y=new double[md.getTarget().getHeight()][md.getTarget().getWidth()];
  MiscTools.loadRawTransformation(rawTransfPath,transformation_x,transformation_y);
  double warpingIndex=MiscTools.warpingIndex(md.getSourceImp(),md.getTargetImp(),intervals,cx,cy,transformation_x,transformation_y);
  if (warpingIndex != -1)   IJ.log(""String_Node_Str"" + warpingIndex);
 else   IJ.log(""String_Node_Str"" + ""String_Node_Str"");
}","/** 
 * Compare an elastic and a raw transform loaded from file. The result is expressed using the warping index and displayed in the Log window.
 * @param elasticTransfPath complete path to elastic transform file
 * @param rawTransfPath complete path to raw transform file
 */
public static void compareElasticRawTransforms(final String elasticTransfPath,final String rawTransfPath){
  final MainDialog md=bUnwarpJ_.getMainDialog();
  if (null == md) {
    IJ.log(""String_Node_Str"");
    return;
  }
  int intervals=MiscTools.numberOfIntervalsOfTransformation(elasticTransfPath);
  double[][] cx=new double[intervals + 3][intervals + 3];
  double[][] cy=new double[intervals + 3][intervals + 3];
  MiscTools.loadTransformation(elasticTransfPath,cx,cy);
  final double[][] transformation_x=new double[md.getTarget().getHeight()][md.getTarget().getWidth()];
  final double[][] transformation_y=new double[md.getTarget().getHeight()][md.getTarget().getWidth()];
  MiscTools.loadRawTransformation(rawTransfPath,transformation_x,transformation_y);
  double warpingIndex=MiscTools.rawWarpingIndex(md.getSourceImp(),md.getTargetImp(),intervals,cx,cy,transformation_x,transformation_y);
  if (warpingIndex != -1)   IJ.log(""String_Node_Str"" + warpingIndex);
 else   IJ.log(""String_Node_Str"" + ""String_Node_Str"");
}",0.9980835569183596
26217,"/** 
 * Compare two opposite transformations (direct and inverse) represented by B-splines through the warping index.
 */
private void compareOppositeElasticTransformations(){
  OpenDialog od=new OpenDialog(""String_Node_Str"",""String_Node_Str"");
  String path=od.getDirectory();
  String filename=od.getFileName();
  if ((path == null) || (filename == null)) {
    return;
  }
  final String directTransfFilename=path + filename;
  int intervals=MiscTools.numberOfIntervalsOfTransformation(directTransfFilename);
  double[][] cx_direct=new double[intervals + 3][intervals + 3];
  double[][] cy_direct=new double[intervals + 3][intervals + 3];
  MiscTools.loadTransformation(directTransfFilename,cx_direct,cy_direct);
  od=new OpenDialog(""String_Node_Str"",""String_Node_Str"");
  path=od.getDirectory();
  filename=od.getFileName();
  if ((path == null) || (filename == null)) {
    return;
  }
  final String inverseTransfFilename=path + filename;
  intervals=MiscTools.numberOfIntervalsOfTransformation(inverseTransfFilename);
  double[][] cx_inverse=new double[intervals + 3][intervals + 3];
  double[][] cy_inverse=new double[intervals + 3][intervals + 3];
  MiscTools.loadTransformation(inverseTransfFilename,cx_inverse,cy_inverse);
  double warpingIndex=MiscTools.warpingIndex(this.sourceImp,this.targetImp,intervals,cx_direct,cy_direct,cx_inverse,cy_inverse);
  if (warpingIndex != -1)   IJ.log(""String_Node_Str"" + warpingIndex);
 else   IJ.log(""String_Node_Str"");
  record(IODialog.COMPARE_OPPOSITE_ELASTIC,directTransfFilename,inverseTransfFilename);
}","/** 
 * Compare two opposite transformations (direct and inverse) represented by B-splines through the warping index.
 */
private void compareOppositeElasticTransformations(){
  OpenDialog od=new OpenDialog(""String_Node_Str"",""String_Node_Str"");
  String path=od.getDirectory();
  String filename=od.getFileName();
  if ((path == null) || (filename == null)) {
    return;
  }
  final String directTransfFilename=path + filename;
  int intervals=MiscTools.numberOfIntervalsOfTransformation(directTransfFilename);
  double[][] cx_direct=new double[intervals + 3][intervals + 3];
  double[][] cy_direct=new double[intervals + 3][intervals + 3];
  MiscTools.loadTransformation(directTransfFilename,cx_direct,cy_direct);
  od=new OpenDialog(""String_Node_Str"",""String_Node_Str"");
  path=od.getDirectory();
  filename=od.getFileName();
  if ((path == null) || (filename == null)) {
    return;
  }
  final String inverseTransfFilename=path + filename;
  intervals=MiscTools.numberOfIntervalsOfTransformation(inverseTransfFilename);
  double[][] cx_inverse=new double[intervals + 3][intervals + 3];
  double[][] cy_inverse=new double[intervals + 3][intervals + 3];
  MiscTools.loadTransformation(inverseTransfFilename,cx_inverse,cy_inverse);
  double warpingIndex=MiscTools.warpingIndex(this.sourceImp,this.targetImp,intervals,cx_direct,cy_direct,cx_inverse,cy_inverse);
  if (warpingIndex != -1)   IJ.log(""String_Node_Str"" + warpingIndex);
 else   IJ.log(""String_Node_Str"");
  record(IODialog.COMPARE_OPPOSITE_ELASTIC,directTransfFilename,inverseTransfFilename,targetImp.getTitle(),sourceImp.getTitle());
}",0.9866920152091256
26218,"/** 
 * Prepare for interpolation and interpolate  fromSub = true --> The interpolation is done from the subsampled version of the image else: fromCurrent=true  --> The interpolation is done from the current image in the pyramid. fromCurrent=false --> The interpolation is done from the original image.
 * @param x x- point coordinate
 * @param y y- point coordinate
 * @param fromSub flat to determine to do the interpolation from the subsampled version of the image 
 * @param fromCurrent flag to determine the image to do the interpolation frominterpolated value
 */
public double prepareForInterpolationAndInterpolateI(double x,double y,boolean fromSub,boolean fromCurrent){
  int widthToUse=0;
  int heightToUse=0;
  final int[] xIndex=new int[4];
  final int[] yIndex=new int[4];
  final double[] xWeight=new double[4];
  final double[] dxWeight=new double[4];
  final double[] yWeight=new double[4];
  final double[] dyWeight=new double[4];
  if (fromSub && this.subCoeffs != null) {
    widthToUse=this.subWidth;
    heightToUse=this.subHeight;
  }
 else   if (fromCurrent) {
    widthToUse=currentWidth;
    heightToUse=currentHeight;
  }
 else {
    widthToUse=width;
    heightToUse=height;
  }
  int ix=(int)x;
  int iy=(int)y;
  int twiceWidthToUse=2 * widthToUse;
  int twiceHeightToUse=2 * heightToUse;
  int p=(0.0 <= x) ? (ix + 2) : (ix + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceWidthToUse <= q)       q-=twiceWidthToUse * (q / twiceWidthToUse);
      xIndex[k]=(widthToUse <= q) ? (twiceWidthToUse - 1 - q) : (q);
    }
 else     xIndex[k]=(p < 0 || p >= widthToUse) ? (-1) : (p);
  }
  p=(0.0 <= y) ? (iy + 2) : (iy + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceHeightToUse <= q)       q-=twiceHeightToUse * (q / twiceHeightToUse);
      yIndex[k]=(heightToUse <= q) ? (twiceHeightToUse - 1 - q) : (q);
    }
 else     yIndex[k]=(p < 0 || p >= heightToUse) ? (-1) : (p);
  }
  double ex=x - ((0.0 <= x) ? (ix) : (ix - 1));
  double ey=y - ((0.0 <= y) ? (iy) : (iy - 1));
  double s=1.0F - ex;
  dxWeight[0]=0.5F * ex * ex;
  xWeight[0]=ex * dxWeight[0] / 3.0F;
  dxWeight[3]=-0.5F * s * s;
  xWeight[3]=s * dxWeight[3] / -3.0F;
  dxWeight[1]=1.0F - 2.0F * dxWeight[0] + dxWeight[3];
  xWeight[1]=MathTools.Bspline03(x - ix - 1);
  dxWeight[2]=1.5F * ex * (ex - 4.0F / 3.0F);
  xWeight[2]=2.0F / 3.0F - (2.0F - ex) * dxWeight[0];
  double t=1.0F - ey;
  dyWeight[0]=0.5F * ey * ey;
  yWeight[0]=ey * dyWeight[0] / 3.0F;
  dyWeight[3]=-0.5F * t * t;
  yWeight[3]=t * dyWeight[3] / -3.0F;
  dyWeight[1]=1.0F - 2.0F * dyWeight[0] + dyWeight[3];
  yWeight[1]=2.0F / 3.0F + (1.0F + ey) * dyWeight[3];
  dyWeight[2]=1.5F * ey * (ey - 4.0F / 3.0F);
  yWeight[2]=2.0F / 3.0F - (2.0F - ey) * dyWeight[0];
  double ival=0.0F;
  for (int j=0; j < 4; j++) {
    s=0.0F;
    iy=yIndex[j];
    if (iy != -1) {
      p=iy * widthToUse;
      for (int i=0; i < 4; i++) {
        ix=xIndex[i];
        if (ix != -1) {
          if (fromSub && this.subCoeffs != null)           s+=xWeight[i] * this.subCoeffs[p + ix];
 else           if (fromCurrent)           s+=xWeight[i] * currentCoefficient[p + ix];
 else           s+=xWeight[i] * coefficient[p + ix];
        }
      }
      ival+=yWeight[j] * s;
    }
  }
  return ival;
}","/** 
 * Prepare for interpolation and interpolate <ul> <li>fromSub = true: The interpolation is done from the subsampled version of the image</li> </ul> <p> else: </p> <ul> <li>fromCurrent=true: The interpolation is done from the current image in the pyramid.</li> <li>fromCurrent=false: The interpolation is done from the original image. </li> </ul>
 * @param x x- point coordinate
 * @param y y- point coordinate
 * @param fromSub flat to determine to do the interpolation from thesubsampled version of the image
 * @param fromCurrent flag to determine the image to do the interpolation frominterpolated value
 */
public double prepareForInterpolationAndInterpolateI(double x,double y,boolean fromSub,boolean fromCurrent){
  int widthToUse=0;
  int heightToUse=0;
  final int[] xIndex=new int[4];
  final int[] yIndex=new int[4];
  final double[] xWeight=new double[4];
  final double[] dxWeight=new double[4];
  final double[] yWeight=new double[4];
  final double[] dyWeight=new double[4];
  if (fromSub && this.subCoeffs != null) {
    widthToUse=this.subWidth;
    heightToUse=this.subHeight;
  }
 else   if (fromCurrent) {
    widthToUse=currentWidth;
    heightToUse=currentHeight;
  }
 else {
    widthToUse=width;
    heightToUse=height;
  }
  int ix=(int)x;
  int iy=(int)y;
  int twiceWidthToUse=2 * widthToUse;
  int twiceHeightToUse=2 * heightToUse;
  int p=(0.0 <= x) ? (ix + 2) : (ix + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceWidthToUse <= q)       q-=twiceWidthToUse * (q / twiceWidthToUse);
      xIndex[k]=(widthToUse <= q) ? (twiceWidthToUse - 1 - q) : (q);
    }
 else     xIndex[k]=(p < 0 || p >= widthToUse) ? (-1) : (p);
  }
  p=(0.0 <= y) ? (iy + 2) : (iy + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceHeightToUse <= q)       q-=twiceHeightToUse * (q / twiceHeightToUse);
      yIndex[k]=(heightToUse <= q) ? (twiceHeightToUse - 1 - q) : (q);
    }
 else     yIndex[k]=(p < 0 || p >= heightToUse) ? (-1) : (p);
  }
  double ex=x - ((0.0 <= x) ? (ix) : (ix - 1));
  double ey=y - ((0.0 <= y) ? (iy) : (iy - 1));
  double s=1.0F - ex;
  dxWeight[0]=0.5F * ex * ex;
  xWeight[0]=ex * dxWeight[0] / 3.0F;
  dxWeight[3]=-0.5F * s * s;
  xWeight[3]=s * dxWeight[3] / -3.0F;
  dxWeight[1]=1.0F - 2.0F * dxWeight[0] + dxWeight[3];
  xWeight[1]=MathTools.Bspline03(x - ix - 1);
  dxWeight[2]=1.5F * ex * (ex - 4.0F / 3.0F);
  xWeight[2]=2.0F / 3.0F - (2.0F - ex) * dxWeight[0];
  double t=1.0F - ey;
  dyWeight[0]=0.5F * ey * ey;
  yWeight[0]=ey * dyWeight[0] / 3.0F;
  dyWeight[3]=-0.5F * t * t;
  yWeight[3]=t * dyWeight[3] / -3.0F;
  dyWeight[1]=1.0F - 2.0F * dyWeight[0] + dyWeight[3];
  yWeight[1]=2.0F / 3.0F + (1.0F + ey) * dyWeight[3];
  dyWeight[2]=1.5F * ey * (ey - 4.0F / 3.0F);
  yWeight[2]=2.0F / 3.0F - (2.0F - ey) * dyWeight[0];
  double ival=0.0F;
  for (int j=0; j < 4; j++) {
    s=0.0F;
    iy=yIndex[j];
    if (iy != -1) {
      p=iy * widthToUse;
      for (int i=0; i < 4; i++) {
        ix=xIndex[i];
        if (ix != -1) {
          if (fromSub && this.subCoeffs != null)           s+=xWeight[i] * this.subCoeffs[p + ix];
 else           if (fromCurrent)           s+=xWeight[i] * currentCoefficient[p + ix];
 else           s+=xWeight[i] * coefficient[p + ix];
        }
      }
      ival+=yWeight[j] * s;
    }
  }
  return ival;
}",0.9366053169734152
26219,"/** 
 * Prepare for interpolation and interpolate the image value and its derivatives fromSub = true --> The interpolation is done from the subsampled version of the image else: fromCurrent=true  --> The interpolation is done from the current image in the pyramid. fromCurrent=false --> The interpolation is done from the original image.
 * @param x x- point coordinate
 * @param y y- point coordinate
 * @param D output, interpolation the X and Y derivatives of the image
 * @param fromSub flat to determine to do the interpolation from the subsampled version of the image 
 * @param fromCurrent flag to determine the image to do the interpolation frominterpolated value
 */
public double prepareForInterpolationAndInterpolateIAndD(double x,double y,double D[],boolean fromSub,boolean fromCurrent){
  int widthToUse=0;
  int heightToUse=0;
  final int[] xIndex=new int[4];
  final int[] yIndex=new int[4];
  final double[] xWeight=new double[4];
  final double[] dxWeight=new double[4];
  final double[] yWeight=new double[4];
  final double[] dyWeight=new double[4];
  if (fromSub && this.subCoeffs != null) {
    widthToUse=this.subWidth;
    heightToUse=this.subHeight;
  }
 else   if (fromCurrent) {
    widthToUse=currentWidth;
    heightToUse=currentHeight;
  }
 else {
    widthToUse=width;
    heightToUse=height;
  }
  int ix=(int)x;
  int iy=(int)y;
  int twiceWidthToUse=2 * widthToUse;
  int twiceHeightToUse=2 * heightToUse;
  int p=(0.0 <= x) ? (ix + 2) : (ix + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceWidthToUse <= q)       q-=twiceWidthToUse * (q / twiceWidthToUse);
      xIndex[k]=(widthToUse <= q) ? (twiceWidthToUse - 1 - q) : (q);
    }
 else     xIndex[k]=(p < 0 || p >= widthToUse) ? (-1) : (p);
  }
  p=(0.0 <= y) ? (iy + 2) : (iy + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceHeightToUse <= q)       q-=twiceHeightToUse * (q / twiceHeightToUse);
      yIndex[k]=(heightToUse <= q) ? (twiceHeightToUse - 1 - q) : (q);
    }
 else     yIndex[k]=(p < 0 || p >= heightToUse) ? (-1) : (p);
  }
  double ex=x - ((0.0 <= x) ? (ix) : (ix - 1));
  double ey=y - ((0.0 <= y) ? (iy) : (iy - 1));
  double s=1.0F - ex;
  dxWeight[0]=0.5F * ex * ex;
  xWeight[0]=ex * dxWeight[0] / 3.0F;
  dxWeight[3]=-0.5F * s * s;
  xWeight[3]=s * dxWeight[3] / -3.0F;
  dxWeight[1]=1.0F - 2.0F * dxWeight[0] + dxWeight[3];
  xWeight[1]=MathTools.Bspline03(x - ix - 1);
  dxWeight[2]=1.5F * ex * (ex - 4.0F / 3.0F);
  xWeight[2]=2.0F / 3.0F - (2.0F - ex) * dxWeight[0];
  double t=1.0F - ey;
  dyWeight[0]=0.5F * ey * ey;
  yWeight[0]=ey * dyWeight[0] / 3.0F;
  dyWeight[3]=-0.5F * t * t;
  yWeight[3]=t * dyWeight[3] / -3.0F;
  dyWeight[1]=1.0F - 2.0F * dyWeight[0] + dyWeight[3];
  yWeight[1]=2.0F / 3.0F + (1.0F + ey) * dyWeight[3];
  dyWeight[2]=1.5F * ey * (ey - 4.0F / 3.0F);
  yWeight[2]=2.0F / 3.0F - (2.0F - ey) * dyWeight[0];
  double ival=0.0F;
  for (int j=0; j < 4; j++) {
    s=0.0F;
    iy=yIndex[j];
    if (iy != -1) {
      p=iy * widthToUse;
      for (int i=0; i < 4; i++) {
        ix=xIndex[i];
        if (ix != -1) {
          if (fromSub && this.subCoeffs != null)           s+=xWeight[i] * this.subCoeffs[p + ix];
 else           if (fromCurrent)           s+=xWeight[i] * currentCoefficient[p + ix];
 else           s+=xWeight[i] * coefficient[p + ix];
        }
      }
      ival+=yWeight[j] * s;
    }
  }
  D[0]=D[1]=0.0F;
  for (int j=0; j < 4; j++) {
    double sx=0.0F, sy=0.0F;
    iy=yIndex[j];
    if (iy != -1) {
      p=iy * widthToUse;
      for (int i=0; i < 4; i++) {
        ix=xIndex[i];
        if (ix != -1) {
          double c;
          if (fromSub && this.subCoeffs != null)           c=this.subCoeffs[p + ix];
 else           if (fromCurrent)           c=currentCoefficient[p + ix];
 else           c=coefficient[p + ix];
          sx+=dxWeight[i] * c;
          sy+=xWeight[i] * c;
        }
      }
      D[0]+=yWeight[j] * sx;
      D[1]+=dyWeight[j] * sy;
    }
  }
  return ival;
}","/** 
 * Prepare for interpolation and interpolate the image value and its derivatives <ul> <li>fromSub = true: The interpolation is done from the subsampled version of the image</li> </ul> <p> else: </p> <ul> <li>fromCurrent=true: The interpolation is done from the current image in the pyramid.</li> <li>fromCurrent=false: The interpolation is done from the original image. </li> </ul>
 * @param x x- point coordinate
 * @param y y- point coordinate
 * @param D output, interpolation the X and Y derivatives of the image
 * @param fromSub flat to determine to do the interpolation from thesubsampled version of the image
 * @param fromCurrent flag to determine the image to do the interpolation frominterpolated value
 */
public double prepareForInterpolationAndInterpolateIAndD(double x,double y,double D[],boolean fromSub,boolean fromCurrent){
  int widthToUse=0;
  int heightToUse=0;
  final int[] xIndex=new int[4];
  final int[] yIndex=new int[4];
  final double[] xWeight=new double[4];
  final double[] dxWeight=new double[4];
  final double[] yWeight=new double[4];
  final double[] dyWeight=new double[4];
  if (fromSub && this.subCoeffs != null) {
    widthToUse=this.subWidth;
    heightToUse=this.subHeight;
  }
 else   if (fromCurrent) {
    widthToUse=currentWidth;
    heightToUse=currentHeight;
  }
 else {
    widthToUse=width;
    heightToUse=height;
  }
  int ix=(int)x;
  int iy=(int)y;
  int twiceWidthToUse=2 * widthToUse;
  int twiceHeightToUse=2 * heightToUse;
  int p=(0.0 <= x) ? (ix + 2) : (ix + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceWidthToUse <= q)       q-=twiceWidthToUse * (q / twiceWidthToUse);
      xIndex[k]=(widthToUse <= q) ? (twiceWidthToUse - 1 - q) : (q);
    }
 else     xIndex[k]=(p < 0 || p >= widthToUse) ? (-1) : (p);
  }
  p=(0.0 <= y) ? (iy + 2) : (iy + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceHeightToUse <= q)       q-=twiceHeightToUse * (q / twiceHeightToUse);
      yIndex[k]=(heightToUse <= q) ? (twiceHeightToUse - 1 - q) : (q);
    }
 else     yIndex[k]=(p < 0 || p >= heightToUse) ? (-1) : (p);
  }
  double ex=x - ((0.0 <= x) ? (ix) : (ix - 1));
  double ey=y - ((0.0 <= y) ? (iy) : (iy - 1));
  double s=1.0F - ex;
  dxWeight[0]=0.5F * ex * ex;
  xWeight[0]=ex * dxWeight[0] / 3.0F;
  dxWeight[3]=-0.5F * s * s;
  xWeight[3]=s * dxWeight[3] / -3.0F;
  dxWeight[1]=1.0F - 2.0F * dxWeight[0] + dxWeight[3];
  xWeight[1]=MathTools.Bspline03(x - ix - 1);
  dxWeight[2]=1.5F * ex * (ex - 4.0F / 3.0F);
  xWeight[2]=2.0F / 3.0F - (2.0F - ex) * dxWeight[0];
  double t=1.0F - ey;
  dyWeight[0]=0.5F * ey * ey;
  yWeight[0]=ey * dyWeight[0] / 3.0F;
  dyWeight[3]=-0.5F * t * t;
  yWeight[3]=t * dyWeight[3] / -3.0F;
  dyWeight[1]=1.0F - 2.0F * dyWeight[0] + dyWeight[3];
  yWeight[1]=2.0F / 3.0F + (1.0F + ey) * dyWeight[3];
  dyWeight[2]=1.5F * ey * (ey - 4.0F / 3.0F);
  yWeight[2]=2.0F / 3.0F - (2.0F - ey) * dyWeight[0];
  double ival=0.0F;
  for (int j=0; j < 4; j++) {
    s=0.0F;
    iy=yIndex[j];
    if (iy != -1) {
      p=iy * widthToUse;
      for (int i=0; i < 4; i++) {
        ix=xIndex[i];
        if (ix != -1) {
          if (fromSub && this.subCoeffs != null)           s+=xWeight[i] * this.subCoeffs[p + ix];
 else           if (fromCurrent)           s+=xWeight[i] * currentCoefficient[p + ix];
 else           s+=xWeight[i] * coefficient[p + ix];
        }
      }
      ival+=yWeight[j] * s;
    }
  }
  D[0]=D[1]=0.0F;
  for (int j=0; j < 4; j++) {
    double sx=0.0F, sy=0.0F;
    iy=yIndex[j];
    if (iy != -1) {
      p=iy * widthToUse;
      for (int i=0; i < 4; i++) {
        ix=xIndex[i];
        if (ix != -1) {
          double c;
          if (fromSub && this.subCoeffs != null)           c=this.subCoeffs[p + ix];
 else           if (fromCurrent)           c=currentCoefficient[p + ix];
 else           c=coefficient[p + ix];
          sx+=dxWeight[i] * c;
          sy+=xWeight[i] * c;
        }
      }
      D[0]+=yWeight[j] * sx;
      D[1]+=dyWeight[j] * sy;
    }
  }
  return ival;
}",0.9475723453202568
26220,"/** 
 * fromCurrent=true  --> The interpolation is prepared to be done from the current image in the pyramid. fromCurrent=false --> The interpolation is prepared to be done from the original image.
 * @param x x- point coordinate
 * @param y y- point coordinate
 * @param fromCurrent flag to determine the image to do the interpolation from
 */
public void prepareForInterpolation(double x,double y,boolean fromCurrent){
  this.fromCurrent=fromCurrent;
  if (fromCurrent) {
    widthToUse=currentWidth;
    heightToUse=currentHeight;
  }
 else {
    widthToUse=width;
    heightToUse=height;
  }
  int ix=(int)x;
  int iy=(int)y;
  int twiceWidthToUse=2 * widthToUse;
  int twiceHeightToUse=2 * heightToUse;
  int p=(0.0 <= x) ? (ix + 2) : (ix + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceWidthToUse <= q)       q-=twiceWidthToUse * (q / twiceWidthToUse);
      xIndex[k]=(widthToUse <= q) ? (twiceWidthToUse - 1 - q) : (q);
    }
 else     xIndex[k]=(p < 0 || p >= widthToUse) ? (-1) : (p);
  }
  p=(0.0 <= y) ? (iy + 2) : (iy + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceHeightToUse <= q)       q-=twiceHeightToUse * (q / twiceHeightToUse);
      yIndex[k]=(heightToUse <= q) ? (twiceHeightToUse - 1 - q) : (q);
    }
 else     yIndex[k]=(p < 0 || p >= heightToUse) ? (-1) : (p);
  }
  double ex=x - ((0.0 <= x) ? (ix) : (ix - 1));
  double ey=y - ((0.0 <= y) ? (iy) : (iy - 1));
  double s=1.0F - ex;
  dxWeight[0]=0.5F * ex * ex;
  xWeight[0]=ex * dxWeight[0] / 3.0F;
  dxWeight[3]=-0.5F * s * s;
  xWeight[3]=s * dxWeight[3] / -3.0F;
  dxWeight[1]=1.0F - 2.0F * dxWeight[0] + dxWeight[3];
  xWeight[1]=MathTools.Bspline03(x - ix - 1);
  dxWeight[2]=1.5F * ex * (ex - 4.0F / 3.0F);
  xWeight[2]=2.0F / 3.0F - (2.0F - ex) * dxWeight[0];
  d2xWeight[0]=ex;
  d2xWeight[1]=s - 2 * ex;
  d2xWeight[2]=ex - 2 * s;
  d2xWeight[3]=s;
  double t=1.0F - ey;
  dyWeight[0]=0.5F * ey * ey;
  yWeight[0]=ey * dyWeight[0] / 3.0F;
  dyWeight[3]=-0.5F * t * t;
  yWeight[3]=t * dyWeight[3] / -3.0F;
  dyWeight[1]=1.0F - 2.0F * dyWeight[0] + dyWeight[3];
  yWeight[1]=2.0F / 3.0F + (1.0F + ey) * dyWeight[3];
  dyWeight[2]=1.5F * ey * (ey - 4.0F / 3.0F);
  yWeight[2]=2.0F / 3.0F - (2.0F - ey) * dyWeight[0];
  d2yWeight[0]=ey;
  d2yWeight[1]=t - 2 * ey;
  d2yWeight[2]=ey - 2 * t;
  d2yWeight[3]=t;
}","/** 
 * If   {@code fromCurrent} is true, the interpolation is prepared to be donefrom the current image in the pyramid. Otherwise, the interpolation is prepared to be done from the original image.
 * @param x x- point coordinate
 * @param y y- point coordinate
 * @param fromCurrent flag to determine the image to do the interpolation from
 */
public void prepareForInterpolation(double x,double y,boolean fromCurrent){
  this.fromCurrent=fromCurrent;
  if (fromCurrent) {
    widthToUse=currentWidth;
    heightToUse=currentHeight;
  }
 else {
    widthToUse=width;
    heightToUse=height;
  }
  int ix=(int)x;
  int iy=(int)y;
  int twiceWidthToUse=2 * widthToUse;
  int twiceHeightToUse=2 * heightToUse;
  int p=(0.0 <= x) ? (ix + 2) : (ix + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceWidthToUse <= q)       q-=twiceWidthToUse * (q / twiceWidthToUse);
      xIndex[k]=(widthToUse <= q) ? (twiceWidthToUse - 1 - q) : (q);
    }
 else     xIndex[k]=(p < 0 || p >= widthToUse) ? (-1) : (p);
  }
  p=(0.0 <= y) ? (iy + 2) : (iy + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceHeightToUse <= q)       q-=twiceHeightToUse * (q / twiceHeightToUse);
      yIndex[k]=(heightToUse <= q) ? (twiceHeightToUse - 1 - q) : (q);
    }
 else     yIndex[k]=(p < 0 || p >= heightToUse) ? (-1) : (p);
  }
  double ex=x - ((0.0 <= x) ? (ix) : (ix - 1));
  double ey=y - ((0.0 <= y) ? (iy) : (iy - 1));
  double s=1.0F - ex;
  dxWeight[0]=0.5F * ex * ex;
  xWeight[0]=ex * dxWeight[0] / 3.0F;
  dxWeight[3]=-0.5F * s * s;
  xWeight[3]=s * dxWeight[3] / -3.0F;
  dxWeight[1]=1.0F - 2.0F * dxWeight[0] + dxWeight[3];
  xWeight[1]=MathTools.Bspline03(x - ix - 1);
  dxWeight[2]=1.5F * ex * (ex - 4.0F / 3.0F);
  xWeight[2]=2.0F / 3.0F - (2.0F - ex) * dxWeight[0];
  d2xWeight[0]=ex;
  d2xWeight[1]=s - 2 * ex;
  d2xWeight[2]=ex - 2 * s;
  d2xWeight[3]=s;
  double t=1.0F - ey;
  dyWeight[0]=0.5F * ey * ey;
  yWeight[0]=ey * dyWeight[0] / 3.0F;
  dyWeight[3]=-0.5F * t * t;
  yWeight[3]=t * dyWeight[3] / -3.0F;
  dyWeight[1]=1.0F - 2.0F * dyWeight[0] + dyWeight[3];
  yWeight[1]=2.0F / 3.0F + (1.0F + ey) * dyWeight[3];
  dyWeight[2]=1.5F * ey * (ey - 4.0F / 3.0F);
  yWeight[2]=2.0F / 3.0F - (2.0F - ey) * dyWeight[0];
  d2yWeight[0]=ey;
  d2yWeight[1]=t - 2 * ey;
  d2yWeight[2]=ey - 2 * t;
  d2yWeight[3]=t;
}",0.0915750915750915
26221,"/** 
 * Convert an elastic transform to raw format and save it to file.
 * @param rawTransfPath complete path to input raw transform file
 * @param elasticTransfPath complete path to output elastic transform file
 * @param intervals number of intervals in the B-spline grid
 */
public static void convertToElastic(final String rawTransfPath,final String elasticTransfPath,final String strIntervals){
  final MainDialog md=bUnwarpJ_.getMainDialog();
  if (null == md) {
    IJ.log(""String_Node_Str"");
    return;
  }
  final int intervals=Integer.parseInt(strIntervals);
  final double[][] transformation_x=new double[md.getTarget().getHeight()][md.getTarget().getWidth()];
  final double[][] transformation_y=new double[md.getTarget().getHeight()][md.getTarget().getWidth()];
  MiscTools.loadRawTransformation(rawTransfPath,transformation_x,transformation_y);
  double[][] cx=new double[intervals + 3][intervals + 3];
  double[][] cy=new double[intervals + 3][intervals + 3];
  MiscTools.convertRawTransformationToBSpline(md.getTargetImp(),intervals,transformation_x,transformation_y,cx,cy);
  MiscTools.saveElasticTransformation(intervals,cx,cy,elasticTransfPath);
}","/** 
 * Convert an elastic transform to raw format and save it to file.
 * @param rawTransfPath complete path to input raw transform file
 * @param elasticTransfPath complete path to output elastic transform file
 * @param strIntervals number of intervals in the B-spline grid
 */
public static void convertToElastic(final String rawTransfPath,final String elasticTransfPath,final String strIntervals){
  final MainDialog md=bUnwarpJ_.getMainDialog();
  if (null == md) {
    IJ.log(""String_Node_Str"");
    return;
  }
  final int intervals=Integer.parseInt(strIntervals);
  final double[][] transformation_x=new double[md.getTarget().getHeight()][md.getTarget().getWidth()];
  final double[][] transformation_y=new double[md.getTarget().getHeight()][md.getTarget().getWidth()];
  MiscTools.loadRawTransformation(rawTransfPath,transformation_x,transformation_y);
  double[][] cx=new double[intervals + 3][intervals + 3];
  double[][] cy=new double[intervals + 3][intervals + 3];
  MiscTools.convertRawTransformationToBSpline(md.getTargetImp(),intervals,transformation_x,transformation_y,cx,cy);
  MiscTools.saveElasticTransformation(intervals,cx,cy,elasticTransfPath);
}",0.9978605049208388
26222,"/** 
 * <p> Ref: A. Muoz-Barrutia, T. Blu, M. Unser, ""Least-Squares Image Resizing Using Finite Differences,"" IEEE Transactions on Image Processing, vol. 10, n. 9, September 2001. Use: out(x) = input(x/scale); scale > 1 expansion; a < 1 reduction. Use n=n2 if (n1==-1) the standard method (interpolation and resampling) is applied. If (n=n1=n2), the orthogonal projection is computed. The error is the minimum in the least-squares sense. If ((n1 > -1) && (n1<n2)), the oblique projection is computed. The error is slightly greater than the case above. </p>
 * @param input input signal
 * @param n degree of the interpolation spline. It can vary from 0 to 3.
 * @param n1 degree of the analysis spline. It can vary from -1 to 3.
 * @param n2 degree of the synthesis spline. It can vary from 0 to 3. 
 * @param scale zoom factor (scale > 1 expansion; scale < 1 reduction)
 * @param coefOrSamples if working with coefficients coefOrSamples is true; if working with samples coefOrSamples is false
 * @return out signal
 */
public static double[] resize1D(double[] input,int n,int n1,int n2,double scale,boolean coefOrSamples){
  int nxIn=input.length;
  double bb=Math.round(((nxIn - 1) * scale) * 1 / scale);
  while ((nxIn - 1 - bb) != 0) {
    nxIn=nxIn + 1;
    bb=Math.round(((nxIn - 1) * scale) * 1 / scale);
  }
  int nxOut=(int)Math.round((nxIn - 1) * scale) + 1;
  double[] out=new double[nxOut];
  double[] coef=null;
  if (coefOrSamples == false) {
    if (n < 2)     coef=input;
 else {
      double[] pole=tableOfPoles(n);
      double tolerance=1e-11;
      coef=convertToInterpCoef(input,pole,tolerance);
    }
  }
  double[] integ=new double[input.length];
  double med=0;
  if (n1 == -1) {
    integ=input;
    med=0;
  }
  if (n1 == 0) {
    med=integSA(input,integ);
  }
  if (n1 == 1) {
    med=integSA(input,integ);
    integ=integAS(integ);
  }
  if (n1 == 2) {
    med=integSA(input,integ);
    integ=integAS(integ);
    integSA(integ,integ);
  }
  if (n1 == 3) {
    med=integSA(input,integ);
    integ=integAS(integ);
    integSA(integ,integ);
    integ=integAS(integ);
  }
  double[] resize=resampling(integ,nxIn,nxOut,scale,n1,n + n1 + 1);
  double[] fd=null;
  if (n1 == -1)   fd=resize;
 else   if (n1 == 0)   fd=finDiffAS(resize);
 else   if (n1 == 1) {
    fd=finDiffSA(resize);
    fd=finDiffAS(fd);
  }
 else   if (n1 == 2) {
    fd=finDiffAS(resize);
    fd=finDiffSA(fd);
    fd=finDiffAS(fd);
  }
 else   if (n1 == 3) {
    fd=finDiffSA(resize);
    fd=finDiffAS(fd);
    fd=finDiffSA(fd);
    fd=finDiffAS(fd);
  }
  final int n11=n1 + 1;
  final int val1=(n11 * 0.5 == (int)Math.floor(n11 * 0.5)) ? (int)(n11 * 0.5) : (int)Math.floor(n11 * 0.5) + 1;
  double[] fdShort=new double[nxOut];
  for (int i=0; i < nxOut; i++)   fdShort[i]=fd[val1 + i] + med;
  double[] coefFull=null;
  if ((n1 + n2 + 1) < 2)   coefFull=fdShort;
 else {
    double[] pole=tableOfPoles(n1 + n2 + 1);
    double tolerance=1e-11;
    coefFull=convertToInterpCoef(fdShort,pole,tolerance);
  }
  if (coefOrSamples == true) {
    if (n2 < 2)     out=coefFull;
 else {
      double[] samples=tableOfSamples(n2);
      out=convertToSamples(coefFull,samples);
    }
  }
  return out;
}","/** 
 * <p> Ref: A. Muoz-Barrutia, T. Blu, M. Unser, ""Least-Squares Image Resizing Using Finite Differences,"" IEEE Transactions on Image Processing, vol. 10, n. 9, September 2001. </p> <p> Use:   {@code out(x) = input(x/scale)};   {@code scale > 1} expansion;{@code a < 1} reduction.</p> <p> Use  {@code n=n2}: </p> <ul> <li>if   {@code (n1==-1)} the standard method (interpolation and resampling)is applied.</li> <li>If  {@code (n=n1=n2)}, the orthogonal projection is computed. The error is the minimum in the least-squares sense.</li> <li>If   {@code ((n1 > -1) && (n1<n2))}, the oblique projection is computed. The error is slightly greater than the case above.</li> </ul>
 * @param input input signal
 * @param n degree of the interpolation spline. It can vary from 0 to 3.
 * @param n1 degree of the analysis spline. It can vary from -1 to 3.
 * @param n2 degree of the synthesis spline. It can vary from 0 to 3.
 * @param scale zoom factor ({@code scale > 1} expansion; {@code scale < 1}reduction)
 * @param coefOrSamples if working with coefficients coefOrSamples is true; ifworking with samples coefOrSamples is false
 * @return out signal
 */
public static double[] resize1D(double[] input,int n,int n1,int n2,double scale,boolean coefOrSamples){
  int nxIn=input.length;
  double bb=Math.round(((nxIn - 1) * scale) * 1 / scale);
  while ((nxIn - 1 - bb) != 0) {
    nxIn=nxIn + 1;
    bb=Math.round(((nxIn - 1) * scale) * 1 / scale);
  }
  int nxOut=(int)Math.round((nxIn - 1) * scale) + 1;
  double[] out=new double[nxOut];
  double[] coef=null;
  if (coefOrSamples == false) {
    if (n < 2)     coef=input;
 else {
      double[] pole=tableOfPoles(n);
      double tolerance=1e-11;
      coef=convertToInterpCoef(input,pole,tolerance);
    }
  }
  double[] integ=new double[input.length];
  double med=0;
  if (n1 == -1) {
    integ=input;
    med=0;
  }
  if (n1 == 0) {
    med=integSA(input,integ);
  }
  if (n1 == 1) {
    med=integSA(input,integ);
    integ=integAS(integ);
  }
  if (n1 == 2) {
    med=integSA(input,integ);
    integ=integAS(integ);
    integSA(integ,integ);
  }
  if (n1 == 3) {
    med=integSA(input,integ);
    integ=integAS(integ);
    integSA(integ,integ);
    integ=integAS(integ);
  }
  double[] resize=resampling(integ,nxIn,nxOut,scale,n1,n + n1 + 1);
  double[] fd=null;
  if (n1 == -1)   fd=resize;
 else   if (n1 == 0)   fd=finDiffAS(resize);
 else   if (n1 == 1) {
    fd=finDiffSA(resize);
    fd=finDiffAS(fd);
  }
 else   if (n1 == 2) {
    fd=finDiffAS(resize);
    fd=finDiffSA(fd);
    fd=finDiffAS(fd);
  }
 else   if (n1 == 3) {
    fd=finDiffSA(resize);
    fd=finDiffAS(fd);
    fd=finDiffSA(fd);
    fd=finDiffAS(fd);
  }
  final int n11=n1 + 1;
  final int val1=(n11 * 0.5 == (int)Math.floor(n11 * 0.5)) ? (int)(n11 * 0.5) : (int)Math.floor(n11 * 0.5) + 1;
  double[] fdShort=new double[nxOut];
  for (int i=0; i < nxOut; i++)   fdShort[i]=fd[val1 + i] + med;
  double[] coefFull=null;
  if ((n1 + n2 + 1) < 2)   coefFull=fdShort;
 else {
    double[] pole=tableOfPoles(n1 + n2 + 1);
    double tolerance=1e-11;
    coefFull=convertToInterpCoef(fdShort,pole,tolerance);
  }
  if (coefOrSamples == true) {
    if (n2 < 2)     out=coefFull;
 else {
      double[] samples=tableOfSamples(n2);
      out=convertToSamples(coefFull,samples);
    }
  }
  return out;
}",0.975894365115922
26223,"/** 
 * Apply the final transformation (multi-thread version).
 * @param intervals number of intervals in the deformation
 * @param cx x- deformation coefficients
 * @param cy y- deformation coefficients
 * @param bIsReverse flag to determine the transformation direction (target-source=FALSE or source-target=TRUE)
 * @return output images (depending on the output level)
 */
private ImagePlus applyTransformationMultiThread(final int intervals,final double[][] cx,final double[][] cy,boolean bIsReverse){
  BSplineModel auxTarget=target;
  BSplineModel auxSource=source;
  Mask auxTargetMsk=targetMsk;
  Mask auxSourceMsk=sourceMsk;
  int auxTargetWidth=this.originalTargetIP.getWidth();
  int auxTargetHeight=this.originalTargetIP.getHeight();
  ImageProcessor originalIP=this.originalSourceIP;
  if (bIsReverse) {
    auxTarget=source;
    auxSource=target;
    auxTargetMsk=sourceMsk;
    auxSourceMsk=targetMsk;
    auxTargetWidth=this.originalSourceIP.getWidth();
    auxTargetHeight=this.originalSourceIP.getHeight();
    originalIP=this.originalTargetIP;
  }
  ImagePlus output_ip=null;
  final ImageStack is=new ImageStack(auxTargetWidth,auxTargetHeight);
  final String s=bIsReverse ? new String(""String_Node_Str"") : new String(""String_Node_Str"");
  BSplineModel swx=new BSplineModel(cx);
  BSplineModel swy=new BSplineModel(cy);
  if (!(originalIP instanceof ColorProcessor)) {
    final FloatProcessor fp=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    final FloatProcessor fp_mask=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    final FloatProcessor fp_target=new FloatProcessor(auxTargetWidth,auxTargetHeight,auxTarget.getOriginalImage());
    if (auxSource.getOriginalImageWidth() > auxSource.getWidth()) {
      auxSource=new BSplineModel(originalIP,false,1);
      auxSource.setPyramidDepth(0);
      auxSource.startPyramids();
      try {
        auxSource.getThread().join();
      }
 catch (      InterruptedException e) {
        IJ.error(""String_Node_Str"" + e);
      }
    }
    int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetHeight / nproc;
    if (auxTargetHeight % 2 != 0)     block_height++;
    int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    FloatProcessor[] fp_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fp_mask_tile=new FloatProcessor[nThreads];
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetWidth,block_height);
      fp_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fp_mask_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      threads[i]=new Thread(new GrayscaleResultTileMaker(swx,swy,auxSource,auxTargetWidth,auxTargetHeight,auxTargetMsk,auxSourceMsk,rects[i],fp_tile[i],fp_mask_tile[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      fp.insert(fp_tile[i],rects[i].x,rects[i].y);
      fp_tile[i]=null;
      fp_mask.insert(fp_mask_tile[i],rects[i].x,rects[i].y);
      fp_mask_tile[i]=null;
      rects[i]=null;
    }
    fp.resetMinAndMax();
    is.addSlice(""String_Node_Str"" + s + ""String_Node_Str"",fp);
    is.addSlice(""String_Node_Str"",fp_target);
    is.addSlice(""String_Node_Str"",fp_mask);
  }
 else {
    BSplineModel sourceR=new BSplineModel(((ColorProcessor)originalIP).toFloat(0,null),false,1);
    sourceR.setPyramidDepth(0);
    sourceR.startPyramids();
    BSplineModel sourceG=new BSplineModel(((ColorProcessor)originalIP).toFloat(1,null),false,1);
    sourceG.setPyramidDepth(0);
    sourceG.startPyramids();
    BSplineModel sourceB=new BSplineModel(((ColorProcessor)originalIP).toFloat(2,null),false,1);
    sourceB.setPyramidDepth(0);
    sourceB.startPyramids();
    try {
      sourceR.getThread().join();
      sourceG.getThread().join();
      sourceB.getThread().join();
    }
 catch (    InterruptedException e) {
      IJ.error(""String_Node_Str"" + e);
    }
    ColorProcessor cp=new ColorProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpR=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpG=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpB=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    ColorProcessor cp_mask=new ColorProcessor(auxTargetWidth,auxTargetHeight);
    int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetHeight / nproc;
    if (auxTargetHeight % 2 != 0)     block_height++;
    int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    FloatProcessor[] fpR_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fpG_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fpB_tile=new FloatProcessor[nThreads];
    ColorProcessor[] cp_mask_tile=new ColorProcessor[nThreads];
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetWidth,block_height);
      fpR_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fpG_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fpB_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      cp_mask_tile[i]=new ColorProcessor(rects[i].width,rects[i].height);
      threads[i]=new Thread(new ColorResultTileMaker(swx,swy,sourceR,sourceG,sourceB,auxTargetWidth,auxTargetHeight,auxTargetMsk,auxSourceMsk,rects[i],fpR_tile[i],fpG_tile[i],fpB_tile[i],cp_mask_tile[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      fpR.insert(fpR_tile[i],rects[i].x,rects[i].y);
      fpG.insert(fpG_tile[i],rects[i].x,rects[i].y);
      fpB.insert(fpB_tile[i],rects[i].x,rects[i].y);
      fpR_tile[i]=null;
      fpG_tile[i]=null;
      fpB_tile[i]=null;
      cp_mask.insert(cp_mask_tile[i],rects[i].x,rects[i].y);
      cp_mask_tile[i]=null;
      rects[i]=null;
    }
    cp.setPixels(0,fpR);
    cp.setPixels(1,fpG);
    cp.setPixels(2,fpB);
    cp.resetMinAndMax();
    is.addSlice(""String_Node_Str"" + s + ""String_Node_Str"",cp);
    is.addSlice(""String_Node_Str"",bIsReverse ? this.originalSourceIP : this.originalTargetIP);
    is.addSlice(""String_Node_Str"",cp_mask);
  }
  if (outputLevel == 2) {
    computeDeformationVectors(intervals,cx,cy,is,bIsReverse);
    computeDeformationGrid(intervals,cx,cy,is,bIsReverse);
  }
  output_ip=new ImagePlus(""String_Node_Str"" + s + ""String_Node_Str"",is);
  output_ip.setSlice(1);
  output_ip.getProcessor().resetMinAndMax();
  return output_ip;
}","/** 
 * Apply the final transformation (multi-thread version).
 * @param intervals number of intervals in the deformation
 * @param cx x- deformation coefficients
 * @param cy y- deformation coefficients
 * @param bIsReverse flag to determine the transformation direction (target-source=FALSE or source-target=TRUE)
 * @return output images (depending on the output level)
 */
private ImagePlus applyTransformationMultiThread(final int intervals,final double[][] cx,final double[][] cy,boolean bIsReverse){
  BSplineModel auxTarget=target;
  BSplineModel auxSource=source;
  Mask auxTargetMsk=targetMsk;
  Mask auxSourceMsk=sourceMsk;
  int auxTargetWidth=this.originalTargetIP.getWidth();
  int auxTargetHeight=this.originalTargetIP.getHeight();
  ImageProcessor originalIP=this.originalSourceIP;
  if (bIsReverse) {
    auxTarget=source;
    auxSource=target;
    auxTargetMsk=sourceMsk;
    auxSourceMsk=targetMsk;
    auxTargetWidth=this.originalSourceIP.getWidth();
    auxTargetHeight=this.originalSourceIP.getHeight();
    originalIP=this.originalTargetIP;
  }
  ImagePlus output_ip=null;
  final ImageStack is=new ImageStack(auxTargetWidth,auxTargetHeight);
  final String s=bIsReverse ? new String(""String_Node_Str"") : new String(""String_Node_Str"");
  BSplineModel swx=new BSplineModel(cx);
  BSplineModel swy=new BSplineModel(cy);
  if (!(originalIP instanceof ColorProcessor)) {
    final FloatProcessor fp=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    final FloatProcessor fp_mask=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    final FloatProcessor fp_target=new FloatProcessor(auxTargetWidth,auxTargetHeight,auxTarget.getOriginalImage());
    if (auxSource.getOriginalImageWidth() > auxSource.getWidth()) {
      auxSource=new BSplineModel(originalIP,false,1);
      auxSource.setPyramidDepth(0);
      auxSource.startPyramids();
      try {
        auxSource.getThread().join();
      }
 catch (      InterruptedException e) {
        IJ.error(""String_Node_Str"" + e);
      }
    }
    int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetHeight / nproc;
    int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    FloatProcessor[] fp_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fp_mask_tile=new FloatProcessor[nThreads];
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetWidth,block_height);
      fp_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fp_mask_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      threads[i]=new Thread(new GrayscaleResultTileMaker(swx,swy,auxSource,auxTargetWidth,auxTargetHeight,auxTargetMsk,auxSourceMsk,rects[i],fp_tile[i],fp_mask_tile[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      fp.insert(fp_tile[i],rects[i].x,rects[i].y);
      fp_tile[i]=null;
      fp_mask.insert(fp_mask_tile[i],rects[i].x,rects[i].y);
      fp_mask_tile[i]=null;
      rects[i]=null;
    }
    fp.resetMinAndMax();
    is.addSlice(""String_Node_Str"" + s + ""String_Node_Str"",fp);
    is.addSlice(""String_Node_Str"",fp_target);
    is.addSlice(""String_Node_Str"",fp_mask);
  }
 else {
    BSplineModel sourceR=new BSplineModel(((ColorProcessor)originalIP).toFloat(0,null),false,1);
    sourceR.setPyramidDepth(0);
    sourceR.startPyramids();
    BSplineModel sourceG=new BSplineModel(((ColorProcessor)originalIP).toFloat(1,null),false,1);
    sourceG.setPyramidDepth(0);
    sourceG.startPyramids();
    BSplineModel sourceB=new BSplineModel(((ColorProcessor)originalIP).toFloat(2,null),false,1);
    sourceB.setPyramidDepth(0);
    sourceB.startPyramids();
    try {
      sourceR.getThread().join();
      sourceG.getThread().join();
      sourceB.getThread().join();
    }
 catch (    InterruptedException e) {
      IJ.error(""String_Node_Str"" + e);
    }
    ColorProcessor cp=new ColorProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpR=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpG=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpB=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    ColorProcessor cp_mask=new ColorProcessor(auxTargetWidth,auxTargetHeight);
    int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetHeight / nproc;
    int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    FloatProcessor[] fpR_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fpG_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fpB_tile=new FloatProcessor[nThreads];
    ColorProcessor[] cp_mask_tile=new ColorProcessor[nThreads];
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetWidth,block_height);
      fpR_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fpG_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fpB_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      cp_mask_tile[i]=new ColorProcessor(rects[i].width,rects[i].height);
      threads[i]=new Thread(new ColorResultTileMaker(swx,swy,sourceR,sourceG,sourceB,auxTargetWidth,auxTargetHeight,auxTargetMsk,auxSourceMsk,rects[i],fpR_tile[i],fpG_tile[i],fpB_tile[i],cp_mask_tile[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      fpR.insert(fpR_tile[i],rects[i].x,rects[i].y);
      fpG.insert(fpG_tile[i],rects[i].x,rects[i].y);
      fpB.insert(fpB_tile[i],rects[i].x,rects[i].y);
      fpR_tile[i]=null;
      fpG_tile[i]=null;
      fpB_tile[i]=null;
      cp_mask.insert(cp_mask_tile[i],rects[i].x,rects[i].y);
      cp_mask_tile[i]=null;
      rects[i]=null;
    }
    cp.setPixels(0,fpR);
    cp.setPixels(1,fpG);
    cp.setPixels(2,fpB);
    cp.resetMinAndMax();
    is.addSlice(""String_Node_Str"" + s + ""String_Node_Str"",cp);
    is.addSlice(""String_Node_Str"",bIsReverse ? this.originalSourceIP : this.originalTargetIP);
    is.addSlice(""String_Node_Str"",cp_mask);
  }
  if (outputLevel == 2) {
    computeDeformationVectors(intervals,cx,cy,is,bIsReverse);
    computeDeformationGrid(intervals,cx,cy,is,bIsReverse);
  }
  output_ip=new ImagePlus(""String_Node_Str"" + s + ""String_Node_Str"",is);
  output_ip.setSlice(1);
  output_ip.getProcessor().resetMinAndMax();
  return output_ip;
}",0.485487753079428
26224,"/** 
 * Method to update a current output (multi-thread).
 * @param c B-spline coefficients
 * @param intervals number of intervals in the deformation
 * @param bIsReverse flag to decide the deformation direction (source-target, target-source)
 */
private void update_current_output(final double[] c,int intervals,boolean bIsReverse){
  int cYdim=intervals + 3;
  int cXdim=cYdim;
  int Nk=cYdim * cXdim;
  BSplineModel auxTarget=target;
  BSplineModel auxSource=source;
  Mask auxTargetMsk=targetMsk;
  Mask auxSourceMsk=sourceMsk;
  BSplineModel swx=swxTargetToSource;
  BSplineModel swy=swyTargetToSource;
  int auxTargetWidth=this.targetWidth;
  int auxTargetHeight=this.targetHeight;
  int auxTargetCurrentWidth=this.targetCurrentWidth;
  int auxTargetCurrentHeight=this.targetCurrentHeight;
  int auxSourceWidth=this.sourceWidth;
  int auxSourceHeight=this.sourceHeight;
  ImagePlus auxSourceImp=this.sourceImp;
  ImagePlus output_ip=this.output_ip_1;
  double auxFactorWidth=this.targetFactorWidth;
  double auxFactorHeight=this.targetFactorHeight;
  double subFactorWidth=target.isSubOutput() ? (target.getWidth() / target.getSubWidth()) : 1;
  double subFactorHeight=target.isSubOutput() ? (target.getHeight() / target.getSubHeight()) : 1;
  if (bIsReverse) {
    auxTarget=source;
    auxSource=target;
    auxTargetMsk=sourceMsk;
    auxSourceMsk=targetMsk;
    swx=swxSourceToTarget;
    swy=swySourceToTarget;
    auxTargetWidth=this.sourceWidth;
    auxTargetHeight=this.sourceHeight;
    auxTargetCurrentWidth=sourceCurrentWidth;
    auxTargetCurrentHeight=sourceCurrentHeight;
    auxSourceWidth=this.targetWidth;
    auxSourceHeight=this.targetHeight;
    auxSourceImp=this.targetImp;
    output_ip=this.output_ip_2;
    auxFactorWidth=this.sourceFactorWidth;
    auxFactorHeight=this.sourceFactorHeight;
    subFactorWidth=source.isSubOutput() ? (source.getWidth() / source.getSubWidth()) : 1;
    subFactorHeight=source.isSubOutput() ? (source.getHeight() / source.getSubHeight()) : 1;
  }
  swx.setCoefficients(c,cYdim,cXdim,0);
  swy.setCoefficients(c,cYdim,cXdim,Nk);
  FloatProcessor fp=(FloatProcessor)output_ip.getProcessor();
  int uv=0;
  int nproc=Runtime.getRuntime().availableProcessors();
  int block_height=auxTargetHeight / ((int)subFactorHeight * nproc);
  if (auxTargetHeight % 2 != 0)   block_height++;
  int nThreads=nproc;
  Thread[] threads=new Thread[nThreads];
  Rectangle[] rects=new Rectangle[nThreads];
  FloatProcessor[] fp_tile=new FloatProcessor[nThreads];
  for (int i=0; i < nThreads; i++) {
    int x_start=i * block_height;
    if (nThreads - 1 == i)     block_height=auxTargetHeight / (int)subFactorWidth - i * block_height;
    rects[i]=new Rectangle(0,x_start,auxTargetWidth / (int)subFactorWidth,block_height);
    fp_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
    threads[i]=new Thread(new OutputTileMaker(swx,swy,auxSource,auxTarget,auxSourceMsk,auxTargetMsk,auxFactorWidth * subFactorWidth,auxFactorHeight * subFactorHeight,auxTargetCurrentHeight,auxTargetCurrentWidth,rects[i],fp_tile[i]));
    threads[i].start();
  }
  for (int i=0; i < nThreads; i++) {
    try {
      threads[i].join();
      threads[i]=null;
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  for (int i=0; i < nThreads; i++) {
    fp.insert(fp_tile[i],rects[i].x,rects[i].y);
    fp_tile[i]=null;
    rects[i]=null;
  }
  double min_val=output_ip.getProcessor().getMin();
  double max_val=output_ip.getProcessor().getMax();
  fp.setMinAndMax(min_val,max_val);
  output_ip.updateAndDraw();
  auxTargetHeight=bIsReverse ? this.originalSourceIP.getHeight() : this.originalTargetIP.getHeight();
  auxTargetWidth=bIsReverse ? this.originalSourceIP.getWidth() : this.originalTargetIP.getWidth();
  auxSourceHeight=bIsReverse ? this.originalTargetIP.getHeight() : this.originalSourceIP.getHeight();
  auxSourceWidth=bIsReverse ? this.originalTargetIP.getWidth() : this.originalSourceIP.getWidth();
  auxFactorWidth=(double)auxTargetCurrentWidth / auxTargetWidth;
  auxFactorHeight=(double)auxTargetCurrentHeight / auxTargetHeight;
  int stepv=Math.min(Math.max(10,auxTargetHeight / 15),60);
  int stepu=Math.min(Math.max(10,auxTargetWidth / 15),60);
  final double transformedImage[][]=new double[auxSourceHeight][auxSourceWidth];
  double grid_colour=-1e-10;
  uv=0;
  for (int v=0; v < auxSourceHeight; v++)   for (int u=0; u < auxSourceWidth; u++, uv++) {
    transformedImage[v][u]=auxSource.getOriginalImage()[uv];
    if (transformedImage[v][u] > grid_colour)     grid_colour=transformedImage[v][u];
  }
  for (int v=0; v < auxTargetHeight + stepv; v+=stepv)   for (int u=0; u < auxTargetWidth + stepu; u+=stepu) {
    double down_u=u * auxFactorWidth;
    double down_v=v * auxFactorHeight;
    final double tv=(double)(down_v * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
    final double tu=(double)(down_u * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
    swx.prepareForInterpolation(tu,tv,ORIGINAL);
    double x=swx.interpolateI();
    swy.prepareForInterpolation(tu,tv,ORIGINAL);
    double y=swy.interpolateI();
    double up_x=x / auxFactorWidth;
    double up_y=y / auxFactorHeight;
    int uh=u + stepu;
    if (uh < auxTargetWidth + stepu) {
      final double down_uh=uh * auxFactorWidth;
      final double tuh=(double)(down_uh * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
      swx.prepareForInterpolation(tuh,tv,ORIGINAL);
      final double xh=swx.interpolateI();
      swy.prepareForInterpolation(tuh,tv,ORIGINAL);
      final double yh=swy.interpolateI();
      final double up_xh=xh / auxFactorWidth;
      final double up_yh=yh / auxFactorHeight;
      MiscTools.drawLine(transformedImage,(int)Math.round(up_x),(int)Math.round(up_y),(int)Math.round(up_xh),(int)Math.round(up_yh),grid_colour);
    }
    int vv=v + stepv;
    if (vv < auxTargetHeight + stepv) {
      double down_vv=vv * auxFactorHeight;
      final double tvv=(double)(down_vv * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
      swx.prepareForInterpolation(tu,tvv,ORIGINAL);
      double xv=swx.interpolateI();
      swy.prepareForInterpolation(tu,tvv,ORIGINAL);
      double yv=swy.interpolateI();
      double up_xv=xv / auxFactorWidth;
      double up_yv=yv / auxFactorHeight;
      MiscTools.drawLine(transformedImage,(int)Math.round(up_x),(int)Math.round(up_y),(int)Math.round(up_xv),(int)Math.round(up_yv),grid_colour);
    }
  }
  FloatProcessor fpg=new FloatProcessor(auxSourceWidth,auxSourceHeight);
  for (int v=0; v < auxSourceHeight; v++)   for (int u=0; u < auxSourceWidth; u++)   fpg.setf(u,v,(float)transformedImage[v][u]);
  min_val=auxSourceImp.getProcessor().getMin();
  max_val=auxSourceImp.getProcessor().getMax();
  fpg.setMinAndMax(min_val,max_val);
  if (auxSourceImp.getImageStackSize() < 2)   auxSourceImp.setProcessor(auxSourceImp.getTitle(),fpg);
 else {
    final ImageProcessor ipToDisplay;
    if (auxSourceImp.getProcessor() instanceof ByteProcessor)     ipToDisplay=fpg.convertToByte(false);
 else     if (auxSourceImp.getProcessor() instanceof ShortProcessor)     ipToDisplay=fpg.convertToShort(false);
 else     ipToDisplay=fpg;
    auxSourceImp.setProcessor(auxSourceImp.getTitle(),ipToDisplay);
  }
  auxSourceImp.updateImage();
}","/** 
 * Method to update a current output (multi-thread).
 * @param c B-spline coefficients
 * @param intervals number of intervals in the deformation
 * @param bIsReverse flag to decide the deformation direction (source-target, target-source)
 */
private void update_current_output(final double[] c,int intervals,boolean bIsReverse){
  int cYdim=intervals + 3;
  int cXdim=cYdim;
  int Nk=cYdim * cXdim;
  BSplineModel auxTarget=target;
  BSplineModel auxSource=source;
  Mask auxTargetMsk=targetMsk;
  Mask auxSourceMsk=sourceMsk;
  BSplineModel swx=swxTargetToSource;
  BSplineModel swy=swyTargetToSource;
  int auxTargetWidth=this.targetWidth;
  int auxTargetHeight=this.targetHeight;
  int auxTargetCurrentWidth=this.targetCurrentWidth;
  int auxTargetCurrentHeight=this.targetCurrentHeight;
  int auxSourceWidth=this.sourceWidth;
  int auxSourceHeight=this.sourceHeight;
  ImagePlus auxSourceImp=this.sourceImp;
  ImagePlus output_ip=this.output_ip_1;
  double auxFactorWidth=this.targetFactorWidth;
  double auxFactorHeight=this.targetFactorHeight;
  double subFactorWidth=target.isSubOutput() ? (target.getWidth() / target.getSubWidth()) : 1;
  double subFactorHeight=target.isSubOutput() ? (target.getHeight() / target.getSubHeight()) : 1;
  if (bIsReverse) {
    auxTarget=source;
    auxSource=target;
    auxTargetMsk=sourceMsk;
    auxSourceMsk=targetMsk;
    swx=swxSourceToTarget;
    swy=swySourceToTarget;
    auxTargetWidth=this.sourceWidth;
    auxTargetHeight=this.sourceHeight;
    auxTargetCurrentWidth=sourceCurrentWidth;
    auxTargetCurrentHeight=sourceCurrentHeight;
    auxSourceWidth=this.targetWidth;
    auxSourceHeight=this.targetHeight;
    auxSourceImp=this.targetImp;
    output_ip=this.output_ip_2;
    auxFactorWidth=this.sourceFactorWidth;
    auxFactorHeight=this.sourceFactorHeight;
    subFactorWidth=source.isSubOutput() ? (source.getWidth() / source.getSubWidth()) : 1;
    subFactorHeight=source.isSubOutput() ? (source.getHeight() / source.getSubHeight()) : 1;
  }
  swx.setCoefficients(c,cYdim,cXdim,0);
  swy.setCoefficients(c,cYdim,cXdim,Nk);
  FloatProcessor fp=(FloatProcessor)output_ip.getProcessor();
  int uv=0;
  int nproc=Runtime.getRuntime().availableProcessors();
  int block_height=auxTargetHeight / ((int)subFactorHeight * nproc);
  int nThreads=nproc;
  Thread[] threads=new Thread[nThreads];
  Rectangle[] rects=new Rectangle[nThreads];
  FloatProcessor[] fp_tile=new FloatProcessor[nThreads];
  for (int i=0; i < nThreads; i++) {
    int x_start=i * block_height;
    if (nThreads - 1 == i)     block_height=auxTargetHeight / (int)subFactorWidth - i * block_height;
    rects[i]=new Rectangle(0,x_start,auxTargetWidth / (int)subFactorWidth,block_height);
    fp_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
    threads[i]=new Thread(new OutputTileMaker(swx,swy,auxSource,auxTarget,auxSourceMsk,auxTargetMsk,auxFactorWidth * subFactorWidth,auxFactorHeight * subFactorHeight,auxTargetCurrentHeight,auxTargetCurrentWidth,rects[i],fp_tile[i]));
    threads[i].start();
  }
  for (int i=0; i < nThreads; i++) {
    try {
      threads[i].join();
      threads[i]=null;
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  for (int i=0; i < nThreads; i++) {
    fp.insert(fp_tile[i],rects[i].x,rects[i].y);
    fp_tile[i]=null;
    rects[i]=null;
  }
  double min_val=output_ip.getProcessor().getMin();
  double max_val=output_ip.getProcessor().getMax();
  fp.setMinAndMax(min_val,max_val);
  output_ip.updateAndDraw();
  auxTargetHeight=bIsReverse ? this.originalSourceIP.getHeight() : this.originalTargetIP.getHeight();
  auxTargetWidth=bIsReverse ? this.originalSourceIP.getWidth() : this.originalTargetIP.getWidth();
  auxSourceHeight=bIsReverse ? this.originalTargetIP.getHeight() : this.originalSourceIP.getHeight();
  auxSourceWidth=bIsReverse ? this.originalTargetIP.getWidth() : this.originalSourceIP.getWidth();
  auxFactorWidth=(double)auxTargetCurrentWidth / auxTargetWidth;
  auxFactorHeight=(double)auxTargetCurrentHeight / auxTargetHeight;
  int stepv=Math.min(Math.max(10,auxTargetHeight / 15),60);
  int stepu=Math.min(Math.max(10,auxTargetWidth / 15),60);
  final double transformedImage[][]=new double[auxSourceHeight][auxSourceWidth];
  double grid_colour=-1e-10;
  uv=0;
  for (int v=0; v < auxSourceHeight; v++)   for (int u=0; u < auxSourceWidth; u++, uv++) {
    transformedImage[v][u]=auxSource.getOriginalImage()[uv];
    if (transformedImage[v][u] > grid_colour)     grid_colour=transformedImage[v][u];
  }
  for (int v=0; v < auxTargetHeight + stepv; v+=stepv)   for (int u=0; u < auxTargetWidth + stepu; u+=stepu) {
    double down_u=u * auxFactorWidth;
    double down_v=v * auxFactorHeight;
    final double tv=(double)(down_v * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
    final double tu=(double)(down_u * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
    swx.prepareForInterpolation(tu,tv,ORIGINAL);
    double x=swx.interpolateI();
    swy.prepareForInterpolation(tu,tv,ORIGINAL);
    double y=swy.interpolateI();
    double up_x=x / auxFactorWidth;
    double up_y=y / auxFactorHeight;
    int uh=u + stepu;
    if (uh < auxTargetWidth + stepu) {
      final double down_uh=uh * auxFactorWidth;
      final double tuh=(double)(down_uh * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
      swx.prepareForInterpolation(tuh,tv,ORIGINAL);
      final double xh=swx.interpolateI();
      swy.prepareForInterpolation(tuh,tv,ORIGINAL);
      final double yh=swy.interpolateI();
      final double up_xh=xh / auxFactorWidth;
      final double up_yh=yh / auxFactorHeight;
      MiscTools.drawLine(transformedImage,(int)Math.round(up_x),(int)Math.round(up_y),(int)Math.round(up_xh),(int)Math.round(up_yh),grid_colour);
    }
    int vv=v + stepv;
    if (vv < auxTargetHeight + stepv) {
      double down_vv=vv * auxFactorHeight;
      final double tvv=(double)(down_vv * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
      swx.prepareForInterpolation(tu,tvv,ORIGINAL);
      double xv=swx.interpolateI();
      swy.prepareForInterpolation(tu,tvv,ORIGINAL);
      double yv=swy.interpolateI();
      double up_xv=xv / auxFactorWidth;
      double up_yv=yv / auxFactorHeight;
      MiscTools.drawLine(transformedImage,(int)Math.round(up_x),(int)Math.round(up_y),(int)Math.round(up_xv),(int)Math.round(up_yv),grid_colour);
    }
  }
  FloatProcessor fpg=new FloatProcessor(auxSourceWidth,auxSourceHeight);
  for (int v=0; v < auxSourceHeight; v++)   for (int u=0; u < auxSourceWidth; u++)   fpg.setf(u,v,(float)transformedImage[v][u]);
  min_val=auxSourceImp.getProcessor().getMin();
  max_val=auxSourceImp.getProcessor().getMax();
  fpg.setMinAndMax(min_val,max_val);
  if (auxSourceImp.getImageStackSize() < 2)   auxSourceImp.setProcessor(auxSourceImp.getTitle(),fpg);
 else {
    final ImageProcessor ipToDisplay;
    if (auxSourceImp.getProcessor() instanceof ByteProcessor)     ipToDisplay=fpg.convertToByte(false);
 else     if (auxSourceImp.getProcessor() instanceof ShortProcessor)     ipToDisplay=fpg.convertToShort(false);
 else     ipToDisplay=fpg;
    auxSourceImp.setProcessor(auxSourceImp.getTitle(),ipToDisplay);
  }
  auxSourceImp.updateImage();
}",0.9965583700440528
26225,"/** 
 * Calculate the geometric error between the source-target and target-source deformations. The corresponding coefficients are assumed to be at swxTargetToSource, swyTargetToSource, swxSourceToTarget and swySourceToTarget. Multi-thread version.
 * @param intervals Input: Number of intervals for the deformation
 * @param grad Output: Gradient of the function
 * @return geometric error between the source-target and target-source deformations.
 */
private double evaluateConsistencyMultiThread(final int intervals,double[] grad){
  double f_direct=0.0;
  double f_inverse=0.0;
  final int nproc=Runtime.getRuntime().availableProcessors();
  int block_height_target=this.targetCurrentHeight / nproc;
  if (this.targetCurrentHeight % 2 != 0)   block_height_target++;
  int block_height_source=this.sourceCurrentHeight / nproc;
  if (this.sourceCurrentHeight % 2 != 0)   block_height_source++;
  final int nThreads=nproc;
  Thread[] threads=new Thread[nThreads];
  Rectangle[] rect_target=new Rectangle[nThreads];
  Rectangle[] rect_source=new Rectangle[nThreads];
  final double[][] grad_direct=new double[nThreads][grad.length];
  final double[][] grad_inverse=new double[nThreads][grad.length];
  final double[][] result=new double[nThreads][4];
  int n_direct=0;
  int n_inverse=0;
  for (int i=0; i < nThreads; i++) {
    int y_start_target=i * block_height_target;
    int y_start_source=i * block_height_source;
    if (nThreads - 1 == i) {
      block_height_target=this.targetCurrentHeight - i * block_height_target;
      block_height_source=this.sourceCurrentHeight - i * block_height_source;
    }
    rect_target[i]=new Rectangle(0,y_start_target,this.targetCurrentHeight,block_height_target);
    rect_source[i]=new Rectangle(0,y_start_source,this.sourceCurrentHeight,block_height_source);
    threads[i]=new Thread(new EvaluateConsistencyTile(this,grad_direct[i],grad_inverse[i],result[i],rect_target[i],rect_source[i]));
    threads[i].start();
  }
  for (int i=0; i < nThreads; i++) {
    try {
      threads[i].join();
      threads[i]=null;
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  for (int i=0; i < nThreads; i++) {
    f_direct+=result[i][0];
    n_direct+=result[i][1];
    f_inverse+=result[i][2];
    n_inverse+=result[i][3];
  }
  f_direct/=n_direct;
  f_inverse/=n_inverse;
  for (int i=0; i < nThreads; i++) {
    for (int j=0; j < grad.length; j++)     grad[j]+=(grad_direct[i][j] / n_direct) + (grad_inverse[i][j] / n_inverse);
  }
  this.partialDirectConsitencyError=this.consistencyWeight * f_direct;
  this.partialInverseConsitencyError=this.consistencyWeight * f_inverse;
  double consistencyDirectError=(n_direct == 0) ? 1.0 / FLT_EPSILON : (this.consistencyWeight * f_direct);
  double consistencyInverseError=(n_inverse == 0) ? 1.0 / FLT_EPSILON : (this.consistencyWeight * f_inverse);
  if (showMarquardtOptim) {
    IJ.log(""String_Node_Str"" + consistencyDirectError);
    IJ.log(""String_Node_Str"" + consistencyInverseError);
  }
  if (n_direct == 0 || n_inverse == 0)   return 1 / FLT_EPSILON;
  return (this.consistencyWeight * (f_direct + f_inverse));
}","/** 
 * Calculate the geometric error between the source-target and target-source deformations. The corresponding coefficients are assumed to be at swxTargetToSource, swyTargetToSource, swxSourceToTarget and swySourceToTarget. Multi-thread version.
 * @param intervals Input: Number of intervals for the deformation
 * @param grad Output: Gradient of the function
 * @return geometric error between the source-target and target-source deformations.
 */
private double evaluateConsistencyMultiThread(final int intervals,double[] grad){
  double f_direct=0.0;
  double f_inverse=0.0;
  final int nproc=Runtime.getRuntime().availableProcessors();
  int block_height_target=this.targetCurrentHeight / nproc;
  int block_height_source=this.sourceCurrentHeight / nproc;
  final int nThreads=nproc;
  Thread[] threads=new Thread[nThreads];
  Rectangle[] rect_target=new Rectangle[nThreads];
  Rectangle[] rect_source=new Rectangle[nThreads];
  final double[][] grad_direct=new double[nThreads][grad.length];
  final double[][] grad_inverse=new double[nThreads][grad.length];
  final double[][] result=new double[nThreads][4];
  int n_direct=0;
  int n_inverse=0;
  for (int i=0; i < nThreads; i++) {
    int y_start_target=i * block_height_target;
    int y_start_source=i * block_height_source;
    if (nThreads - 1 == i) {
      block_height_target=this.targetCurrentHeight - i * block_height_target;
      block_height_source=this.sourceCurrentHeight - i * block_height_source;
    }
    rect_target[i]=new Rectangle(0,y_start_target,this.targetCurrentWidth,block_height_target);
    rect_source[i]=new Rectangle(0,y_start_source,this.sourceCurrentWidth,block_height_source);
    threads[i]=new Thread(new EvaluateConsistencyTile(this,grad_direct[i],grad_inverse[i],result[i],rect_target[i],rect_source[i]));
    threads[i].start();
  }
  for (int i=0; i < nThreads; i++) {
    try {
      threads[i].join();
      threads[i]=null;
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  for (int i=0; i < nThreads; i++) {
    f_direct+=result[i][0];
    n_direct+=result[i][1];
    f_inverse+=result[i][2];
    n_inverse+=result[i][3];
  }
  f_direct/=n_direct;
  f_inverse/=n_inverse;
  for (int i=0; i < nThreads; i++) {
    for (int j=0; j < grad.length; j++)     grad[j]+=(grad_direct[i][j] / n_direct) + (grad_inverse[i][j] / n_inverse);
  }
  this.partialDirectConsitencyError=this.consistencyWeight * f_direct;
  this.partialInverseConsitencyError=this.consistencyWeight * f_inverse;
  double consistencyDirectError=(n_direct == 0) ? 1.0 / FLT_EPSILON : (this.consistencyWeight * f_direct);
  double consistencyInverseError=(n_inverse == 0) ? 1.0 / FLT_EPSILON : (this.consistencyWeight * f_inverse);
  if (showMarquardtOptim) {
    IJ.log(""String_Node_Str"" + consistencyDirectError);
    IJ.log(""String_Node_Str"" + consistencyInverseError);
  }
  if (n_direct == 0 || n_inverse == 0)   return 1 / FLT_EPSILON;
  return (this.consistencyWeight * (f_direct + f_inverse));
}",0.965472312703583
26226,"/** 
 * Evaluate the similarity between the source and the target images but also the transformation regularization and and landmarks energy term if necessary. Multi-threading version.
 * @param c Input: Deformation coefficients
 * @param intervals Input: Number of intervals for the deformation
 * @param grad Output: Gradient of the similarity
 * @param only_image Input: if true, only the image term is considered and not the regularization
 * @param bIsReverse Input: flag to determine the transformation direction (target-source=FALSE or source-target=TRUE)
 * @return images similarity value
 */
private double evaluateSimilarityMultiThread(final double[] c,final int intervals,double[] grad,final boolean only_image,boolean bIsReverse){
  final BSplineModel auxTarget=(!bIsReverse) ? target : source;
  final BSplineModel auxSource=(!bIsReverse) ? source : target;
  final Mask auxTargetMsk=(!bIsReverse) ? targetMsk : sourceMsk;
  final Mask auxSourceMsk=(!bIsReverse) ? sourceMsk : targetMsk;
  final PointHandler auxTargetPh=(!bIsReverse) ? targetPh : sourcePh;
  final PointHandler auxSourcePh=(!bIsReverse) ? sourcePh : targetPh;
  final BSplineModel swx=(!bIsReverse) ? swxTargetToSource : swxSourceToTarget;
  final BSplineModel swy=(!bIsReverse) ? swyTargetToSource : swySourceToTarget;
  final double auxFactorWidth=(!bIsReverse) ? this.target.getFactorWidth() : this.sourceFactorWidth;
  final double auxFactorHeight=(!bIsReverse) ? this.target.getFactorHeight() : this.sourceFactorHeight;
  final double P11[][]=(!bIsReverse) ? this.P11_TargetToSource : this.P11_SourceToTarget;
  final double P12[][]=(!bIsReverse) ? this.P12_TargetToSource : this.P12_SourceToTarget;
  final double P22[][]=(!bIsReverse) ? this.P22_TargetToSource : this.P12_SourceToTarget;
  final int auxTargetCurrentWidth=(!bIsReverse) ? this.targetCurrentWidth : this.sourceCurrentWidth;
  final int auxTargetCurrentHeight=(!bIsReverse) ? this.targetCurrentHeight : this.sourceCurrentHeight;
  final int cYdim=intervals + 3;
  final int cXdim=cYdim;
  final int Nk=cYdim * cXdim;
  final int twiceNk=2 * Nk;
  final double[] vgradreg=new double[grad.length];
  final double[] vgradland=new double[grad.length];
  swx.setCoefficients(c,cYdim,cXdim,0);
  swy.setCoefficients(c,cYdim,cXdim,Nk);
  for (int k=0; k < twiceNk; k++)   vgradreg[k]=vgradland[k]=grad[k]=0.0F;
  double imageSimilarity=0.0;
  if (imageWeight != 0) {
    final int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetCurrentHeight / nproc;
    if (auxTargetCurrentHeight % 2 != 0)     block_height++;
    final int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    final double[][] grad_thread=new double[nThreads][grad.length];
    final double[][] result=new double[nThreads][2];
    int n=0;
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetCurrentHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetCurrentWidth,block_height);
      threads[i]=new Thread(new EvaluateSimilarityTile(auxTarget,auxSource,auxTargetMsk,auxSourceMsk,swx,swy,auxFactorWidth,auxFactorHeight,intervals,grad_thread[i],result[i],rects[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      imageSimilarity+=result[i][0];
      n+=result[i][1];
    }
    imageSimilarity/=n;
    for (int i=0; i < nThreads; i++) {
      for (int j=0; j < grad.length; j++)       grad[j]+=(grad_thread[i][j] / n);
    }
  }
  double regularization=0.0;
  if (!only_image) {
    for (int i=0; i < Nk; i++)     for (int j=0; j < Nk; j++) {
      regularization+=c[i] * P11[i][j] * c[j] + c[Nk + i] * P22[i][j] * c[Nk + j] + c[i] * P12[i][j] * c[Nk + j];
      vgradreg[i]+=2 * P11[i][j] * c[j];
      vgradreg[Nk + i]+=2 * P22[i][j] * c[Nk + j];
      vgradreg[i]+=P12[i][j] * c[Nk + j];
      vgradreg[Nk + i]+=P12[j][i] * c[j];
    }
    regularization*=1.0 / (auxTargetCurrentHeight * auxTargetCurrentWidth);
    for (int k=0; k < twiceNk; k++)     vgradreg[k]*=1.0 / (auxTargetCurrentHeight * auxTargetCurrentWidth);
  }
  double landmarkError=0.0;
  int K=0;
  if (auxTargetPh != null)   K=auxTargetPh.getPoints().size();
  if (landmarkWeight != 0) {
    Vector<Point> sourceVector=null;
    if (auxSourcePh != null)     sourceVector=auxSourcePh.getPoints();
 else     sourceVector=new Vector<Point>();
    Vector<Point> targetVector=null;
    if (auxTargetPh != null)     targetVector=auxTargetPh.getPoints();
 else     targetVector=new Vector<Point>();
    for (int kp=0; kp < K; kp++) {
      final Point sourcePoint=(Point)sourceVector.elementAt(kp);
      final Point targetPoint=(Point)targetVector.elementAt(kp);
      double u=auxFactorWidth * (double)targetPoint.x;
      double v=auxFactorHeight * (double)targetPoint.y;
      double tu=(double)(u * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
      double tv=(double)(v * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
      swx.prepareForInterpolation(tu,tv,false);
      double x=swx.interpolateI();
      swy.prepareForInterpolation(tu,tv,false);
      double y=swy.interpolateI();
      double dx=auxFactorWidth * (double)sourcePoint.x - x;
      double dy=auxFactorHeight * (double)sourcePoint.y - y;
      landmarkError+=dx * dx + dy * dy;
      for (int l=0; l < 4; l++)       for (int m=0; m < 4; m++) {
        if (swx.yIndex[l] == -1 || swx.xIndex[m] == -1)         continue;
        int k=swx.yIndex[l] * cYdim + swx.xIndex[m];
        vgradland[k]-=dx * swx.getWeightI(l,m);
        vgradland[k + Nk]-=dy * swy.getWeightI(l,m);
      }
    }
  }
  if (K != 0) {
    landmarkError*=landmarkWeight / K;
    double aux=2.0 * landmarkWeight / K;
    for (int k=0; k < twiceNk; k++)     vgradland[k]*=aux;
  }
  if (only_image)   landmarkError=0;
  for (int k=0; k < twiceNk; k++)   grad[k]+=vgradreg[k] + vgradland[k];
  if (showMarquardtOptim) {
    String s=bIsReverse ? new String(""String_Node_Str"") : new String(""String_Node_Str"");
    if (imageWeight != 0) {
      IJ.log(""String_Node_Str"" + s + ""String_Node_Str""+ imageSimilarity);
      if (bIsReverse)       this.partialInverseSimilarityError=imageSimilarity;
 else       this.partialDirectSimilarityError=imageSimilarity;
    }
    if (landmarkWeight != 0) {
      IJ.log(""String_Node_Str"" + s + ""String_Node_Str""+ landmarkError);
      if (bIsReverse)       this.partialInverseLandmarkError=landmarkError;
 else       this.partialDirectLandmarkError=landmarkError;
    }
    if (divWeight != 0 || curlWeight != 0) {
      IJ.log(""String_Node_Str"" + s + ""String_Node_Str""+ regularization);
      if (bIsReverse)       this.partialInverseRegularizationError=regularization;
 else       this.partialDirectRegularizationError=regularization;
    }
  }
  return imageSimilarity + landmarkError + regularization;
}","/** 
 * Evaluate the similarity between the source and the target images but also the transformation regularization and and landmarks energy term if necessary. Multi-threading version.
 * @param c Input: Deformation coefficients
 * @param intervals Input: Number of intervals for the deformation
 * @param grad Output: Gradient of the similarity
 * @param only_image Input: if true, only the image term is considered and not the regularization
 * @param bIsReverse Input: flag to determine the transformation direction (target-source=FALSE or source-target=TRUE)
 * @return images similarity value
 */
private double evaluateSimilarityMultiThread(final double[] c,final int intervals,double[] grad,final boolean only_image,boolean bIsReverse){
  final BSplineModel auxTarget=(!bIsReverse) ? target : source;
  final BSplineModel auxSource=(!bIsReverse) ? source : target;
  final Mask auxTargetMsk=(!bIsReverse) ? targetMsk : sourceMsk;
  final Mask auxSourceMsk=(!bIsReverse) ? sourceMsk : targetMsk;
  final PointHandler auxTargetPh=(!bIsReverse) ? targetPh : sourcePh;
  final PointHandler auxSourcePh=(!bIsReverse) ? sourcePh : targetPh;
  final BSplineModel swx=(!bIsReverse) ? swxTargetToSource : swxSourceToTarget;
  final BSplineModel swy=(!bIsReverse) ? swyTargetToSource : swySourceToTarget;
  final double auxFactorWidth=(!bIsReverse) ? this.target.getFactorWidth() : this.sourceFactorWidth;
  final double auxFactorHeight=(!bIsReverse) ? this.target.getFactorHeight() : this.sourceFactorHeight;
  final double P11[][]=(!bIsReverse) ? this.P11_TargetToSource : this.P11_SourceToTarget;
  final double P12[][]=(!bIsReverse) ? this.P12_TargetToSource : this.P12_SourceToTarget;
  final double P22[][]=(!bIsReverse) ? this.P22_TargetToSource : this.P12_SourceToTarget;
  final int auxTargetCurrentWidth=(!bIsReverse) ? this.targetCurrentWidth : this.sourceCurrentWidth;
  final int auxTargetCurrentHeight=(!bIsReverse) ? this.targetCurrentHeight : this.sourceCurrentHeight;
  final int cYdim=intervals + 3;
  final int cXdim=cYdim;
  final int Nk=cYdim * cXdim;
  final int twiceNk=2 * Nk;
  final double[] vgradreg=new double[grad.length];
  final double[] vgradland=new double[grad.length];
  swx.setCoefficients(c,cYdim,cXdim,0);
  swy.setCoefficients(c,cYdim,cXdim,Nk);
  for (int k=0; k < twiceNk; k++)   vgradreg[k]=vgradland[k]=grad[k]=0.0F;
  double imageSimilarity=0.0;
  if (imageWeight != 0) {
    final int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetCurrentHeight / nproc;
    final int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    final double[][] grad_thread=new double[nThreads][grad.length];
    final double[][] result=new double[nThreads][2];
    int n=0;
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetCurrentHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetCurrentWidth,block_height);
      threads[i]=new Thread(new EvaluateSimilarityTile(auxTarget,auxSource,auxTargetMsk,auxSourceMsk,swx,swy,auxFactorWidth,auxFactorHeight,intervals,grad_thread[i],result[i],rects[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      imageSimilarity+=result[i][0];
      n+=result[i][1];
    }
    imageSimilarity/=n;
    for (int i=0; i < nThreads; i++) {
      for (int j=0; j < grad.length; j++)       grad[j]+=(grad_thread[i][j] / n);
    }
  }
  double regularization=0.0;
  if (!only_image) {
    for (int i=0; i < Nk; i++)     for (int j=0; j < Nk; j++) {
      regularization+=c[i] * P11[i][j] * c[j] + c[Nk + i] * P22[i][j] * c[Nk + j] + c[i] * P12[i][j] * c[Nk + j];
      vgradreg[i]+=2 * P11[i][j] * c[j];
      vgradreg[Nk + i]+=2 * P22[i][j] * c[Nk + j];
      vgradreg[i]+=P12[i][j] * c[Nk + j];
      vgradreg[Nk + i]+=P12[j][i] * c[j];
    }
    regularization*=1.0 / (auxTargetCurrentHeight * auxTargetCurrentWidth);
    for (int k=0; k < twiceNk; k++)     vgradreg[k]*=1.0 / (auxTargetCurrentHeight * auxTargetCurrentWidth);
  }
  double landmarkError=0.0;
  int K=0;
  if (auxTargetPh != null)   K=auxTargetPh.getPoints().size();
  if (landmarkWeight != 0) {
    Vector<Point> sourceVector=null;
    if (auxSourcePh != null)     sourceVector=auxSourcePh.getPoints();
 else     sourceVector=new Vector<Point>();
    Vector<Point> targetVector=null;
    if (auxTargetPh != null)     targetVector=auxTargetPh.getPoints();
 else     targetVector=new Vector<Point>();
    for (int kp=0; kp < K; kp++) {
      final Point sourcePoint=(Point)sourceVector.elementAt(kp);
      final Point targetPoint=(Point)targetVector.elementAt(kp);
      double u=auxFactorWidth * (double)targetPoint.x;
      double v=auxFactorHeight * (double)targetPoint.y;
      double tu=(double)(u * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
      double tv=(double)(v * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
      swx.prepareForInterpolation(tu,tv,false);
      double x=swx.interpolateI();
      swy.prepareForInterpolation(tu,tv,false);
      double y=swy.interpolateI();
      double dx=auxFactorWidth * (double)sourcePoint.x - x;
      double dy=auxFactorHeight * (double)sourcePoint.y - y;
      landmarkError+=dx * dx + dy * dy;
      for (int l=0; l < 4; l++)       for (int m=0; m < 4; m++) {
        if (swx.yIndex[l] == -1 || swx.xIndex[m] == -1)         continue;
        int k=swx.yIndex[l] * cYdim + swx.xIndex[m];
        vgradland[k]-=dx * swx.getWeightI(l,m);
        vgradland[k + Nk]-=dy * swy.getWeightI(l,m);
      }
    }
  }
  if (K != 0) {
    landmarkError*=landmarkWeight / K;
    double aux=2.0 * landmarkWeight / K;
    for (int k=0; k < twiceNk; k++)     vgradland[k]*=aux;
  }
  if (only_image)   landmarkError=0;
  for (int k=0; k < twiceNk; k++)   grad[k]+=vgradreg[k] + vgradland[k];
  if (showMarquardtOptim) {
    String s=bIsReverse ? new String(""String_Node_Str"") : new String(""String_Node_Str"");
    if (imageWeight != 0) {
      IJ.log(""String_Node_Str"" + s + ""String_Node_Str""+ imageSimilarity);
      if (bIsReverse)       this.partialInverseSimilarityError=imageSimilarity;
 else       this.partialDirectSimilarityError=imageSimilarity;
    }
    if (landmarkWeight != 0) {
      IJ.log(""String_Node_Str"" + s + ""String_Node_Str""+ landmarkError);
      if (bIsReverse)       this.partialInverseLandmarkError=landmarkError;
 else       this.partialDirectLandmarkError=landmarkError;
    }
    if (divWeight != 0 || curlWeight != 0) {
      IJ.log(""String_Node_Str"" + s + ""String_Node_Str""+ regularization);
      if (bIsReverse)       this.partialInverseRegularizationError=regularization;
 else       this.partialDirectRegularizationError=regularization;
    }
  }
  return imageSimilarity + landmarkError + regularization;
}",0.9956856920574298
26227,"/** 
 * Method to update a current output (multi-thread).
 * @param c B-spline coefficients
 * @param intervals number of intervals in the deformation
 * @param bIsReverse flag to decide the deformation direction (source-target, target-source)
 */
private void update_current_output(final double[] c,int intervals,boolean bIsReverse){
  int cYdim=intervals + 3;
  int cXdim=cYdim;
  int Nk=cYdim * cXdim;
  BSplineModel auxTarget=target;
  BSplineModel auxSource=source;
  Mask auxTargetMsk=targetMsk;
  Mask auxSourceMsk=sourceMsk;
  BSplineModel swx=swxTargetToSource;
  BSplineModel swy=swyTargetToSource;
  int auxTargetWidth=this.targetWidth;
  int auxTargetHeight=this.targetHeight;
  int auxTargetCurrentWidth=this.targetCurrentWidth;
  int auxTargetCurrentHeight=this.targetCurrentHeight;
  int auxSourceWidth=this.sourceWidth;
  int auxSourceHeight=this.sourceHeight;
  ImagePlus auxSourceImp=this.sourceImp;
  ImagePlus output_ip=this.output_ip_1;
  double auxFactorWidth=this.targetFactorWidth;
  double auxFactorHeight=this.targetFactorHeight;
  double subFactorWidth=target.isSubOutput() ? (target.getWidth() / target.getSubWidth()) : 1;
  double subFactorHeight=target.isSubOutput() ? (target.getHeight() / target.getSubHeight()) : 1;
  if (bIsReverse) {
    auxTarget=source;
    auxSource=target;
    auxTargetMsk=sourceMsk;
    auxSourceMsk=targetMsk;
    swx=swxSourceToTarget;
    swy=swySourceToTarget;
    auxTargetWidth=this.sourceWidth;
    auxTargetHeight=this.sourceHeight;
    auxTargetCurrentWidth=sourceCurrentWidth;
    auxTargetCurrentHeight=sourceCurrentHeight;
    auxSourceWidth=this.targetWidth;
    auxSourceHeight=this.targetHeight;
    auxSourceImp=this.targetImp;
    output_ip=this.output_ip_2;
    auxFactorWidth=this.sourceFactorWidth;
    auxFactorHeight=this.sourceFactorHeight;
    subFactorWidth=source.isSubOutput() ? (source.getWidth() / source.getSubWidth()) : 1;
    subFactorHeight=source.isSubOutput() ? (source.getHeight() / source.getSubHeight()) : 1;
  }
  swx.setCoefficients(c,cYdim,cXdim,0);
  swy.setCoefficients(c,cYdim,cXdim,Nk);
  FloatProcessor fp=(FloatProcessor)output_ip.getProcessor();
  int uv=0;
  int nproc=Runtime.getRuntime().availableProcessors();
  int block_height=auxTargetHeight / ((int)subFactorHeight * nproc);
  if (auxTargetHeight % 2 != 0)   block_height++;
  int nThreads=nproc;
  Thread[] threads=new Thread[nThreads];
  Rectangle[] rects=new Rectangle[nThreads];
  FloatProcessor[] fp_tile=new FloatProcessor[nThreads];
  for (int i=0; i < nThreads; i++) {
    int x_start=i * block_height;
    if (nThreads - 1 == i)     block_height=auxTargetHeight / (int)subFactorWidth - i * block_height;
    rects[i]=new Rectangle(0,x_start,auxTargetWidth / (int)subFactorWidth,block_height);
    fp_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
    threads[i]=new Thread(new OutputTileMaker(swx,swy,auxSource,auxTarget,auxSourceMsk,auxTargetMsk,auxFactorWidth * subFactorWidth,auxFactorHeight * subFactorHeight,auxTargetCurrentHeight,auxTargetCurrentWidth,rects[i],fp_tile[i]));
    threads[i].start();
  }
  for (int i=0; i < nThreads; i++) {
    try {
      threads[i].join();
      threads[i]=null;
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  for (int i=0; i < nThreads; i++) {
    fp.insert(fp_tile[i],rects[i].x,rects[i].y);
    fp_tile[i]=null;
    rects[i]=null;
  }
  double min_val=output_ip.getProcessor().getMin();
  double max_val=output_ip.getProcessor().getMax();
  fp.setMinAndMax(min_val,max_val);
  output_ip.updateAndDraw();
  auxTargetHeight=bIsReverse ? this.originalSourceIP.getHeight() : this.originalTargetIP.getHeight();
  auxTargetWidth=bIsReverse ? this.originalSourceIP.getWidth() : this.originalTargetIP.getWidth();
  auxSourceHeight=bIsReverse ? this.originalTargetIP.getHeight() : this.originalSourceIP.getHeight();
  auxSourceWidth=bIsReverse ? this.originalTargetIP.getWidth() : this.originalSourceIP.getWidth();
  auxFactorWidth=(double)auxTargetCurrentWidth / auxTargetWidth;
  auxFactorHeight=(double)auxTargetCurrentHeight / auxTargetHeight;
  int stepv=Math.min(Math.max(10,auxTargetHeight / 15),60);
  int stepu=Math.min(Math.max(10,auxTargetWidth / 15),60);
  final double transformedImage[][]=new double[auxSourceHeight][auxSourceWidth];
  double grid_colour=-1e-10;
  uv=0;
  for (int v=0; v < auxSourceHeight; v++)   for (int u=0; u < auxSourceWidth; u++, uv++) {
    transformedImage[v][u]=auxSource.getOriginalImage()[uv];
    if (transformedImage[v][u] > grid_colour)     grid_colour=transformedImage[v][u];
  }
  for (int v=0; v < auxTargetHeight + stepv; v+=stepv)   for (int u=0; u < auxTargetWidth + stepu; u+=stepu) {
    double down_u=u * auxFactorWidth;
    double down_v=v * auxFactorHeight;
    final double tv=(double)(down_v * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
    final double tu=(double)(down_u * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
    swx.prepareForInterpolation(tu,tv,ORIGINAL);
    double x=swx.interpolateI();
    swy.prepareForInterpolation(tu,tv,ORIGINAL);
    double y=swy.interpolateI();
    double up_x=x / auxFactorWidth;
    double up_y=y / auxFactorHeight;
    int uh=u + stepu;
    if (uh < auxTargetWidth + stepu) {
      final double down_uh=uh * auxFactorWidth;
      final double tuh=(double)(down_uh * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
      swx.prepareForInterpolation(tuh,tv,ORIGINAL);
      final double xh=swx.interpolateI();
      swy.prepareForInterpolation(tuh,tv,ORIGINAL);
      final double yh=swy.interpolateI();
      final double up_xh=xh / auxFactorWidth;
      final double up_yh=yh / auxFactorHeight;
      MiscTools.drawLine(transformedImage,(int)Math.round(up_x),(int)Math.round(up_y),(int)Math.round(up_xh),(int)Math.round(up_yh),grid_colour);
    }
    int vv=v + stepv;
    if (vv < auxTargetHeight + stepv) {
      double down_vv=vv * auxFactorHeight;
      final double tvv=(double)(down_vv * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
      swx.prepareForInterpolation(tu,tvv,ORIGINAL);
      double xv=swx.interpolateI();
      swy.prepareForInterpolation(tu,tvv,ORIGINAL);
      double yv=swy.interpolateI();
      double up_xv=xv / auxFactorWidth;
      double up_yv=yv / auxFactorHeight;
      MiscTools.drawLine(transformedImage,(int)Math.round(up_x),(int)Math.round(up_y),(int)Math.round(up_xv),(int)Math.round(up_yv),grid_colour);
    }
  }
  FloatProcessor fpg=new FloatProcessor(auxSourceWidth,auxSourceHeight);
  for (int v=0; v < auxSourceHeight; v++)   for (int u=0; u < auxSourceWidth; u++)   fpg.putPixelValue(u,v,transformedImage[v][u]);
  min_val=auxSourceImp.getProcessor().getMin();
  max_val=auxSourceImp.getProcessor().getMax();
  fpg.setMinAndMax(min_val,max_val);
  auxSourceImp.setProcessor(auxSourceImp.getTitle(),fpg);
  auxSourceImp.updateImage();
}","/** 
 * Method to update a current output (multi-thread).
 * @param c B-spline coefficients
 * @param intervals number of intervals in the deformation
 * @param bIsReverse flag to decide the deformation direction (source-target, target-source)
 */
private void update_current_output(final double[] c,int intervals,boolean bIsReverse){
  int cYdim=intervals + 3;
  int cXdim=cYdim;
  int Nk=cYdim * cXdim;
  BSplineModel auxTarget=target;
  BSplineModel auxSource=source;
  Mask auxTargetMsk=targetMsk;
  Mask auxSourceMsk=sourceMsk;
  BSplineModel swx=swxTargetToSource;
  BSplineModel swy=swyTargetToSource;
  int auxTargetWidth=this.targetWidth;
  int auxTargetHeight=this.targetHeight;
  int auxTargetCurrentWidth=this.targetCurrentWidth;
  int auxTargetCurrentHeight=this.targetCurrentHeight;
  int auxSourceWidth=this.sourceWidth;
  int auxSourceHeight=this.sourceHeight;
  ImagePlus auxSourceImp=this.sourceImp;
  ImagePlus output_ip=this.output_ip_1;
  double auxFactorWidth=this.targetFactorWidth;
  double auxFactorHeight=this.targetFactorHeight;
  double subFactorWidth=target.isSubOutput() ? (target.getWidth() / target.getSubWidth()) : 1;
  double subFactorHeight=target.isSubOutput() ? (target.getHeight() / target.getSubHeight()) : 1;
  if (bIsReverse) {
    auxTarget=source;
    auxSource=target;
    auxTargetMsk=sourceMsk;
    auxSourceMsk=targetMsk;
    swx=swxSourceToTarget;
    swy=swySourceToTarget;
    auxTargetWidth=this.sourceWidth;
    auxTargetHeight=this.sourceHeight;
    auxTargetCurrentWidth=sourceCurrentWidth;
    auxTargetCurrentHeight=sourceCurrentHeight;
    auxSourceWidth=this.targetWidth;
    auxSourceHeight=this.targetHeight;
    auxSourceImp=this.targetImp;
    output_ip=this.output_ip_2;
    auxFactorWidth=this.sourceFactorWidth;
    auxFactorHeight=this.sourceFactorHeight;
    subFactorWidth=source.isSubOutput() ? (source.getWidth() / source.getSubWidth()) : 1;
    subFactorHeight=source.isSubOutput() ? (source.getHeight() / source.getSubHeight()) : 1;
  }
  swx.setCoefficients(c,cYdim,cXdim,0);
  swy.setCoefficients(c,cYdim,cXdim,Nk);
  FloatProcessor fp=(FloatProcessor)output_ip.getProcessor();
  int uv=0;
  int nproc=Runtime.getRuntime().availableProcessors();
  int block_height=auxTargetHeight / ((int)subFactorHeight * nproc);
  if (auxTargetHeight % 2 != 0)   block_height++;
  int nThreads=nproc;
  Thread[] threads=new Thread[nThreads];
  Rectangle[] rects=new Rectangle[nThreads];
  FloatProcessor[] fp_tile=new FloatProcessor[nThreads];
  for (int i=0; i < nThreads; i++) {
    int x_start=i * block_height;
    if (nThreads - 1 == i)     block_height=auxTargetHeight / (int)subFactorWidth - i * block_height;
    rects[i]=new Rectangle(0,x_start,auxTargetWidth / (int)subFactorWidth,block_height);
    fp_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
    threads[i]=new Thread(new OutputTileMaker(swx,swy,auxSource,auxTarget,auxSourceMsk,auxTargetMsk,auxFactorWidth * subFactorWidth,auxFactorHeight * subFactorHeight,auxTargetCurrentHeight,auxTargetCurrentWidth,rects[i],fp_tile[i]));
    threads[i].start();
  }
  for (int i=0; i < nThreads; i++) {
    try {
      threads[i].join();
      threads[i]=null;
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  for (int i=0; i < nThreads; i++) {
    fp.insert(fp_tile[i],rects[i].x,rects[i].y);
    fp_tile[i]=null;
    rects[i]=null;
  }
  double min_val=output_ip.getProcessor().getMin();
  double max_val=output_ip.getProcessor().getMax();
  fp.setMinAndMax(min_val,max_val);
  output_ip.updateAndDraw();
  auxTargetHeight=bIsReverse ? this.originalSourceIP.getHeight() : this.originalTargetIP.getHeight();
  auxTargetWidth=bIsReverse ? this.originalSourceIP.getWidth() : this.originalTargetIP.getWidth();
  auxSourceHeight=bIsReverse ? this.originalTargetIP.getHeight() : this.originalSourceIP.getHeight();
  auxSourceWidth=bIsReverse ? this.originalTargetIP.getWidth() : this.originalSourceIP.getWidth();
  auxFactorWidth=(double)auxTargetCurrentWidth / auxTargetWidth;
  auxFactorHeight=(double)auxTargetCurrentHeight / auxTargetHeight;
  int stepv=Math.min(Math.max(10,auxTargetHeight / 15),60);
  int stepu=Math.min(Math.max(10,auxTargetWidth / 15),60);
  final double transformedImage[][]=new double[auxSourceHeight][auxSourceWidth];
  double grid_colour=-1e-10;
  uv=0;
  for (int v=0; v < auxSourceHeight; v++)   for (int u=0; u < auxSourceWidth; u++, uv++) {
    transformedImage[v][u]=auxSource.getOriginalImage()[uv];
    if (transformedImage[v][u] > grid_colour)     grid_colour=transformedImage[v][u];
  }
  for (int v=0; v < auxTargetHeight + stepv; v+=stepv)   for (int u=0; u < auxTargetWidth + stepu; u+=stepu) {
    double down_u=u * auxFactorWidth;
    double down_v=v * auxFactorHeight;
    final double tv=(double)(down_v * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
    final double tu=(double)(down_u * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
    swx.prepareForInterpolation(tu,tv,ORIGINAL);
    double x=swx.interpolateI();
    swy.prepareForInterpolation(tu,tv,ORIGINAL);
    double y=swy.interpolateI();
    double up_x=x / auxFactorWidth;
    double up_y=y / auxFactorHeight;
    int uh=u + stepu;
    if (uh < auxTargetWidth + stepu) {
      final double down_uh=uh * auxFactorWidth;
      final double tuh=(double)(down_uh * intervals) / (double)(auxTargetCurrentWidth - 1) + 1.0F;
      swx.prepareForInterpolation(tuh,tv,ORIGINAL);
      final double xh=swx.interpolateI();
      swy.prepareForInterpolation(tuh,tv,ORIGINAL);
      final double yh=swy.interpolateI();
      final double up_xh=xh / auxFactorWidth;
      final double up_yh=yh / auxFactorHeight;
      MiscTools.drawLine(transformedImage,(int)Math.round(up_x),(int)Math.round(up_y),(int)Math.round(up_xh),(int)Math.round(up_yh),grid_colour);
    }
    int vv=v + stepv;
    if (vv < auxTargetHeight + stepv) {
      double down_vv=vv * auxFactorHeight;
      final double tvv=(double)(down_vv * intervals) / (double)(auxTargetCurrentHeight - 1) + 1.0F;
      swx.prepareForInterpolation(tu,tvv,ORIGINAL);
      double xv=swx.interpolateI();
      swy.prepareForInterpolation(tu,tvv,ORIGINAL);
      double yv=swy.interpolateI();
      double up_xv=xv / auxFactorWidth;
      double up_yv=yv / auxFactorHeight;
      MiscTools.drawLine(transformedImage,(int)Math.round(up_x),(int)Math.round(up_y),(int)Math.round(up_xv),(int)Math.round(up_yv),grid_colour);
    }
  }
  FloatProcessor fpg=new FloatProcessor(auxSourceWidth,auxSourceHeight);
  for (int v=0; v < auxSourceHeight; v++)   for (int u=0; u < auxSourceWidth; u++)   fpg.putPixelValue(u,v,transformedImage[v][u]);
  min_val=auxSourceImp.getProcessor().getMin();
  max_val=auxSourceImp.getProcessor().getMax();
  fpg.setMinAndMax(min_val,max_val);
  if (auxSourceImp.getImageStackSize() < 2)   auxSourceImp.setProcessor(auxSourceImp.getTitle(),fpg);
 else {
    final ImageProcessor ipToDisplay;
    if (auxSourceImp.getProcessor() instanceof ByteProcessor)     ipToDisplay=fpg.convertToByte(false);
 else     if (auxSourceImp.getProcessor() instanceof ShortProcessor)     ipToDisplay=fpg.convertToShort(false);
 else     ipToDisplay=fpg;
    auxSourceImp.setProcessor(auxSourceImp.getTitle(),ipToDisplay);
  }
  auxSourceImp.updateImage();
}",0.9649432178881286
26228,"/** 
 * Save the transformation.
 * @param intervals number of intervals in the deformation
 * @param cx x- deformation coefficients
 * @param cy y- deformation coefficients
 * @param bIsReverse flat to determine the transformation direction
 */
private void saveTransformation(int intervals,double[][] cx,double[][] cy,boolean bIsReverse){
  String filename=fn_tnf_1;
  if (bIsReverse)   filename=fn_tnf_2;
  if (filename.equals(""String_Node_Str"")) {
    if (this.dialog.isMacroCall()) {
      if (bIsReverse) {
        int i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
        int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 26);
        filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 27) : dialog.getMacroArgs().substring(i0 + 27,i1);
      }
 else {
        int i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
        int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 27);
        filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 28) : dialog.getMacroArgs().substring(i0 + 28,i1);
      }
    }
 else {
      File dir=new File(""String_Node_Str"");
      String path=""String_Node_Str"";
      try {
        path=dir.getCanonicalPath() + ""String_Node_Str"";
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      filename=(bIsReverse) ? targetImp.getTitle() : sourceImp.getTitle();
      String sDirection=(bIsReverse) ? ""String_Node_Str"" : ""String_Node_Str"";
      String new_filename=""String_Node_Str"";
      int dot=filename.lastIndexOf('.');
      if (dot == -1)       new_filename=filename + sDirection + ""String_Node_Str"";
 else       new_filename=filename.substring(0,dot) + sDirection + ""String_Node_Str"";
      filename=path + filename;
      if (outputLevel > -1 && this.dialog != null && this.dialog.isMacroCall() == false) {
        final SaveDialog sd=new SaveDialog(""String_Node_Str"" + sDirection + ""String_Node_Str"",new_filename,""String_Node_Str"");
        path=sd.getDirectory();
        filename=sd.getFileName();
        if ((path == null) || (filename == null))         return;
        filename=path + filename;
      }
 else       filename=new_filename;
    }
  }
  MiscTools.saveElasticTransformation(intervals,cx,cy,filename);
}","/** 
 * Save the transformation.
 * @param intervals number of intervals in the deformation
 * @param cx x- deformation coefficients
 * @param cy y- deformation coefficients
 * @param bIsReverse flat to determine the transformation direction
 */
private void saveTransformation(int intervals,double[][] cx,double[][] cy,boolean bIsReverse){
  String filename=fn_tnf_1;
  if (bIsReverse)   filename=fn_tnf_2;
  if (filename.equals(""String_Node_Str"")) {
    if (this.dialog.isMacroCall()) {
      if (false == bIsReverse) {
        int i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
        int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 26);
        filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 27) : dialog.getMacroArgs().substring(i0 + 27,i1);
      }
 else {
        int i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
        int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 27);
        filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 28) : dialog.getMacroArgs().substring(i0 + 28,i1);
      }
    }
 else {
      File dir=new File(""String_Node_Str"");
      String path=""String_Node_Str"";
      try {
        path=dir.getCanonicalPath() + ""String_Node_Str"";
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      filename=(bIsReverse) ? targetImp.getTitle() : sourceImp.getTitle();
      String sDirection=(bIsReverse) ? ""String_Node_Str"" : ""String_Node_Str"";
      String new_filename=""String_Node_Str"";
      int dot=filename.lastIndexOf('.');
      if (dot == -1)       new_filename=filename + sDirection + ""String_Node_Str"";
 else       new_filename=filename.substring(0,dot) + sDirection + ""String_Node_Str"";
      filename=path + filename;
      if (outputLevel > -1 && this.dialog != null && this.dialog.isMacroCall() == false) {
        final SaveDialog sd=new SaveDialog(""String_Node_Str"" + sDirection + ""String_Node_Str"",new_filename,""String_Node_Str"");
        path=sd.getDirectory();
        filename=sd.getFileName();
        if ((path == null) || (filename == null))         return;
        filename=path + filename;
      }
 else       filename=new_filename;
    }
  }
  MiscTools.saveElasticTransformation(intervals,cx,cy,filename);
}",0.9979825151311366
26229,"/** 
 * Save the transformation.
 * @param intervals number of intervals in the deformation
 * @param cx x- deformation coefficients
 * @param cy y- deformation coefficients
 * @param bIsReverse flat to determine the transformation direction
 */
private void saveTransformation(int intervals,double[][] cx,double[][] cy,boolean bIsReverse){
  String filename=fn_tnf_1;
  if (bIsReverse)   filename=fn_tnf_2;
  if (filename.equals(""String_Node_Str"")) {
    if (this.dialog.isMacroCall()) {
      if (false == bIsReverse) {
        int i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
        int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 26);
        filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 27) : dialog.getMacroArgs().substring(i0 + 27,i1);
      }
 else {
        int i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
        int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 27);
        filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 28) : dialog.getMacroArgs().substring(i0 + 28,i1);
      }
    }
 else {
      File dir=new File(""String_Node_Str"");
      String path=""String_Node_Str"";
      try {
        path=dir.getCanonicalPath() + ""String_Node_Str"";
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      filename=(bIsReverse) ? targetImp.getTitle() : sourceImp.getTitle();
      String sDirection=(bIsReverse) ? ""String_Node_Str"" : ""String_Node_Str"";
      String new_filename=""String_Node_Str"";
      int dot=filename.lastIndexOf('.');
      if (dot == -1)       new_filename=filename + sDirection + ""String_Node_Str"";
 else       new_filename=filename.substring(0,dot) + sDirection + ""String_Node_Str"";
      filename=path + filename;
      if (outputLevel > -1 && this.dialog != null && this.dialog.isMacroCall() == false) {
        final SaveDialog sd=new SaveDialog(""String_Node_Str"" + sDirection + ""String_Node_Str"",new_filename,""String_Node_Str"");
        path=sd.getDirectory();
        filename=sd.getFileName();
        if ((path == null) || (filename == null))         return;
        filename=path + filename;
      }
 else       filename=new_filename;
    }
  }
  MiscTools.saveElasticTransformation(intervals,cx,cy,filename);
}","/** 
 * Save the transformation.
 * @param intervals number of intervals in the deformation
 * @param cx x- deformation coefficients
 * @param cy y- deformation coefficients
 * @param bIsReverse flat to determine the transformation direction
 */
private void saveTransformation(int intervals,double[][] cx,double[][] cy,boolean bIsReverse){
  String filename=fn_tnf_1;
  if (bIsReverse)   filename=fn_tnf_2;
  if (filename.equals(""String_Node_Str"")) {
    if (this.dialog.isMacroCall()) {
      if (false == bIsReverse) {
        int i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
        if (i0 == -1) {
          i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
          int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 26);
          filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 27) : dialog.getMacroArgs().substring(i0 + 27,i1);
        }
 else {
          int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 26);
          filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 28) : dialog.getMacroArgs().substring(i0 + 28,i1);
        }
        if (filename.length() == 0)         filename=""String_Node_Str"" + sourceImp.getTitle() + ""String_Node_Str"";
      }
 else {
        int i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
        if (i0 == -1) {
          i0=dialog.getMacroArgs().indexOf(""String_Node_Str"");
          int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 27);
          filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 28) : dialog.getMacroArgs().substring(i0 + 28,i1);
        }
 else {
          int i1=dialog.getMacroArgs().indexOf(""String_Node_Str"",i0 + 27);
          filename=i1 == -1 ? dialog.getMacroArgs().substring(i0 + 29) : dialog.getMacroArgs().substring(i0 + 29,i1);
        }
        if (filename.length() == 0)         filename=""String_Node_Str"" + targetImp.getTitle() + ""String_Node_Str"";
      }
    }
 else {
      File dir=new File(""String_Node_Str"");
      String path=""String_Node_Str"";
      try {
        path=dir.getCanonicalPath() + ""String_Node_Str"";
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      filename=(bIsReverse) ? targetImp.getTitle() : sourceImp.getTitle();
      String sDirection=(bIsReverse) ? ""String_Node_Str"" : ""String_Node_Str"";
      String new_filename=""String_Node_Str"";
      int dot=filename.lastIndexOf('.');
      if (dot == -1)       new_filename=filename + sDirection + ""String_Node_Str"";
 else       new_filename=filename.substring(0,dot) + sDirection + ""String_Node_Str"";
      filename=path + filename;
      if (outputLevel > -1 && this.dialog != null && this.dialog.isMacroCall() == false) {
        final SaveDialog sd=new SaveDialog(""String_Node_Str"" + sDirection + ""String_Node_Str"",new_filename,""String_Node_Str"");
        path=sd.getDirectory();
        filename=sd.getFileName();
        if ((path == null) || (filename == null))         return;
        filename=path + filename;
      }
 else       filename=new_filename;
    }
  }
  MiscTools.saveElasticTransformation(intervals,cx,cy,filename);
}",0.8099173553719008
26230,"/** 
 * Apply the final transformation (multi-thread version).
 * @param intervals number of intervals in the deformation
 * @param cx x- deformation coefficients
 * @param cy y- deformation coefficients
 * @param bIsReverse flag to determine the transformation direction (target-source=FALSE or source-target=TRUE)
 * @return output images (depending on the output level)
 */
private ImagePlus applyTransformationMultiThread(final int intervals,final double[][] cx,final double[][] cy,boolean bIsReverse){
  BSplineModel auxTarget=target;
  BSplineModel auxSource=source;
  Mask auxTargetMsk=targetMsk;
  Mask auxSourceMsk=sourceMsk;
  int auxTargetWidth=this.originalTargetIP.getWidth();
  int auxTargetHeight=this.originalTargetIP.getHeight();
  ImageProcessor originalIP=this.originalSourceIP;
  if (bIsReverse) {
    auxTarget=source;
    auxSource=target;
    auxTargetMsk=sourceMsk;
    auxSourceMsk=targetMsk;
    auxTargetWidth=this.originalSourceIP.getWidth();
    auxTargetHeight=this.originalSourceIP.getHeight();
    originalIP=this.originalTargetIP;
  }
  ImagePlus output_ip=null;
  final ImageStack is=new ImageStack(auxTargetWidth,auxTargetHeight);
  final String s=bIsReverse ? new String(""String_Node_Str"") : new String(""String_Node_Str"");
  BSplineModel swx=new BSplineModel(cx);
  BSplineModel swy=new BSplineModel(cy);
  if (!(originalIP instanceof ColorProcessor)) {
    final FloatProcessor fp=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    final FloatProcessor fp_mask=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    final FloatProcessor fp_target=new FloatProcessor(auxTargetWidth,auxTargetHeight,auxTarget.getImage());
    int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetHeight / nproc;
    if (auxTargetHeight % 2 != 0)     block_height++;
    int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    FloatProcessor[] fp_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fp_mask_tile=new FloatProcessor[nThreads];
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetWidth,block_height);
      fp_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fp_mask_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      threads[i]=new Thread(new GrayscaleResultTileMaker(swx,swy,auxSource,auxTargetWidth,auxTargetHeight,auxTargetMsk,auxSourceMsk,rects[i],fp_tile[i],fp_mask_tile[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      fp.insert(fp_tile[i],rects[i].x,rects[i].y);
      fp_tile[i]=null;
      fp_mask.insert(fp_mask_tile[i],rects[i].x,rects[i].y);
      fp_mask_tile[i]=null;
      rects[i]=null;
    }
    fp.resetMinAndMax();
    is.addSlice(""String_Node_Str"" + s + ""String_Node_Str"",fp);
    is.addSlice(""String_Node_Str"",fp_target);
    is.addSlice(""String_Node_Str"",fp_mask);
  }
 else {
    BSplineModel sourceR=new BSplineModel(((ColorProcessor)originalIP).toFloat(0,null),false,1);
    sourceR.setPyramidDepth(0);
    sourceR.startPyramids();
    BSplineModel sourceG=new BSplineModel(((ColorProcessor)originalIP).toFloat(1,null),false,1);
    sourceG.setPyramidDepth(0);
    sourceG.startPyramids();
    BSplineModel sourceB=new BSplineModel(((ColorProcessor)originalIP).toFloat(2,null),false,1);
    sourceB.setPyramidDepth(0);
    sourceB.startPyramids();
    try {
      sourceR.getThread().join();
      sourceG.getThread().join();
      sourceB.getThread().join();
    }
 catch (    InterruptedException e) {
      IJ.error(""String_Node_Str"" + e);
    }
    ColorProcessor cp=new ColorProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpR=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpG=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpB=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    ColorProcessor cp_mask=new ColorProcessor(auxTargetWidth,auxTargetHeight);
    int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetHeight / nproc;
    if (auxTargetHeight % 2 != 0)     block_height++;
    int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    FloatProcessor[] fpR_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fpG_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fpB_tile=new FloatProcessor[nThreads];
    ColorProcessor[] cp_mask_tile=new ColorProcessor[nThreads];
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetWidth,block_height);
      fpR_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fpG_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fpB_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      cp_mask_tile[i]=new ColorProcessor(rects[i].width,rects[i].height);
      threads[i]=new Thread(new ColorResultTileMaker(swx,swy,sourceR,sourceG,sourceB,auxTargetWidth,auxTargetHeight,auxTargetMsk,auxSourceMsk,rects[i],fpR_tile[i],fpG_tile[i],fpB_tile[i],cp_mask_tile[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      fpR.insert(fpR_tile[i],rects[i].x,rects[i].y);
      fpG.insert(fpG_tile[i],rects[i].x,rects[i].y);
      fpB.insert(fpB_tile[i],rects[i].x,rects[i].y);
      fpR_tile[i]=null;
      fpG_tile[i]=null;
      fpB_tile[i]=null;
      cp_mask.insert(cp_mask_tile[i],rects[i].x,rects[i].y);
      cp_mask_tile[i]=null;
      rects[i]=null;
    }
    cp.setPixels(0,fpR);
    cp.setPixels(1,fpG);
    cp.setPixels(2,fpB);
    cp.resetMinAndMax();
    is.addSlice(""String_Node_Str"" + s + ""String_Node_Str"",cp);
    is.addSlice(""String_Node_Str"",bIsReverse ? this.originalSourceIP : this.originalTargetIP);
    is.addSlice(""String_Node_Str"",cp_mask);
  }
  if (outputLevel == 2) {
    computeDeformationVectors(intervals,cx,cy,is,bIsReverse);
    computeDeformationGrid(intervals,cx,cy,is,bIsReverse);
  }
  output_ip=new ImagePlus(""String_Node_Str"" + s + ""String_Node_Str"",is);
  output_ip.setSlice(1);
  output_ip.getProcessor().resetMinAndMax();
  return output_ip;
}","/** 
 * Apply the final transformation (multi-thread version).
 * @param intervals number of intervals in the deformation
 * @param cx x- deformation coefficients
 * @param cy y- deformation coefficients
 * @param bIsReverse flag to determine the transformation direction (target-source=FALSE or source-target=TRUE)
 * @return output images (depending on the output level)
 */
private ImagePlus applyTransformationMultiThread(final int intervals,final double[][] cx,final double[][] cy,boolean bIsReverse){
  BSplineModel auxTarget=target;
  BSplineModel auxSource=source;
  Mask auxTargetMsk=targetMsk;
  Mask auxSourceMsk=sourceMsk;
  int auxTargetWidth=this.originalTargetIP.getWidth();
  int auxTargetHeight=this.originalTargetIP.getHeight();
  ImageProcessor originalIP=this.originalSourceIP;
  if (bIsReverse) {
    auxTarget=source;
    auxSource=target;
    auxTargetMsk=sourceMsk;
    auxSourceMsk=targetMsk;
    auxTargetWidth=this.originalSourceIP.getWidth();
    auxTargetHeight=this.originalSourceIP.getHeight();
    originalIP=this.originalTargetIP;
  }
  ImagePlus output_ip=null;
  final ImageStack is=new ImageStack(auxTargetWidth,auxTargetHeight);
  final String s=bIsReverse ? new String(""String_Node_Str"") : new String(""String_Node_Str"");
  BSplineModel swx=new BSplineModel(cx);
  BSplineModel swy=new BSplineModel(cy);
  if (!(originalIP instanceof ColorProcessor)) {
    final FloatProcessor fp=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    final FloatProcessor fp_mask=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    final FloatProcessor fp_target=new FloatProcessor(auxTargetWidth,auxTargetHeight,auxTarget.getOriginalImage());
    if (auxSource.getOriginalImageWidth() > auxSource.getWidth()) {
      auxSource=new BSplineModel(originalIP,false,1);
      auxSource.setPyramidDepth(0);
      auxSource.startPyramids();
      try {
        auxSource.getThread().join();
      }
 catch (      InterruptedException e) {
        IJ.error(""String_Node_Str"" + e);
      }
    }
    int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetHeight / nproc;
    if (auxTargetHeight % 2 != 0)     block_height++;
    int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    FloatProcessor[] fp_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fp_mask_tile=new FloatProcessor[nThreads];
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetWidth,block_height);
      fp_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fp_mask_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      threads[i]=new Thread(new GrayscaleResultTileMaker(swx,swy,auxSource,auxTargetWidth,auxTargetHeight,auxTargetMsk,auxSourceMsk,rects[i],fp_tile[i],fp_mask_tile[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      fp.insert(fp_tile[i],rects[i].x,rects[i].y);
      fp_tile[i]=null;
      fp_mask.insert(fp_mask_tile[i],rects[i].x,rects[i].y);
      fp_mask_tile[i]=null;
      rects[i]=null;
    }
    fp.resetMinAndMax();
    is.addSlice(""String_Node_Str"" + s + ""String_Node_Str"",fp);
    is.addSlice(""String_Node_Str"",fp_target);
    is.addSlice(""String_Node_Str"",fp_mask);
  }
 else {
    BSplineModel sourceR=new BSplineModel(((ColorProcessor)originalIP).toFloat(0,null),false,1);
    sourceR.setPyramidDepth(0);
    sourceR.startPyramids();
    BSplineModel sourceG=new BSplineModel(((ColorProcessor)originalIP).toFloat(1,null),false,1);
    sourceG.setPyramidDepth(0);
    sourceG.startPyramids();
    BSplineModel sourceB=new BSplineModel(((ColorProcessor)originalIP).toFloat(2,null),false,1);
    sourceB.setPyramidDepth(0);
    sourceB.startPyramids();
    try {
      sourceR.getThread().join();
      sourceG.getThread().join();
      sourceB.getThread().join();
    }
 catch (    InterruptedException e) {
      IJ.error(""String_Node_Str"" + e);
    }
    ColorProcessor cp=new ColorProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpR=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpG=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    FloatProcessor fpB=new FloatProcessor(auxTargetWidth,auxTargetHeight);
    ColorProcessor cp_mask=new ColorProcessor(auxTargetWidth,auxTargetHeight);
    int nproc=Runtime.getRuntime().availableProcessors();
    int block_height=auxTargetHeight / nproc;
    if (auxTargetHeight % 2 != 0)     block_height++;
    int nThreads=nproc;
    Thread[] threads=new Thread[nThreads];
    Rectangle[] rects=new Rectangle[nThreads];
    FloatProcessor[] fpR_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fpG_tile=new FloatProcessor[nThreads];
    FloatProcessor[] fpB_tile=new FloatProcessor[nThreads];
    ColorProcessor[] cp_mask_tile=new ColorProcessor[nThreads];
    for (int i=0; i < nThreads; i++) {
      int y_start=i * block_height;
      if (nThreads - 1 == i)       block_height=auxTargetHeight - i * block_height;
      rects[i]=new Rectangle(0,y_start,auxTargetWidth,block_height);
      fpR_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fpG_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      fpB_tile[i]=new FloatProcessor(rects[i].width,rects[i].height);
      cp_mask_tile[i]=new ColorProcessor(rects[i].width,rects[i].height);
      threads[i]=new Thread(new ColorResultTileMaker(swx,swy,sourceR,sourceG,sourceB,auxTargetWidth,auxTargetHeight,auxTargetMsk,auxSourceMsk,rects[i],fpR_tile[i],fpG_tile[i],fpB_tile[i],cp_mask_tile[i]));
      threads[i].start();
    }
    for (int i=0; i < nThreads; i++) {
      try {
        threads[i].join();
        threads[i]=null;
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    for (int i=0; i < nThreads; i++) {
      fpR.insert(fpR_tile[i],rects[i].x,rects[i].y);
      fpG.insert(fpG_tile[i],rects[i].x,rects[i].y);
      fpB.insert(fpB_tile[i],rects[i].x,rects[i].y);
      fpR_tile[i]=null;
      fpG_tile[i]=null;
      fpB_tile[i]=null;
      cp_mask.insert(cp_mask_tile[i],rects[i].x,rects[i].y);
      cp_mask_tile[i]=null;
      rects[i]=null;
    }
    cp.setPixels(0,fpR);
    cp.setPixels(1,fpG);
    cp.setPixels(2,fpB);
    cp.resetMinAndMax();
    is.addSlice(""String_Node_Str"" + s + ""String_Node_Str"",cp);
    is.addSlice(""String_Node_Str"",bIsReverse ? this.originalSourceIP : this.originalTargetIP);
    is.addSlice(""String_Node_Str"",cp_mask);
  }
  if (outputLevel == 2) {
    computeDeformationVectors(intervals,cx,cy,is,bIsReverse);
    computeDeformationGrid(intervals,cx,cy,is,bIsReverse);
  }
  output_ip=new ImagePlus(""String_Node_Str"" + s + ""String_Node_Str"",is);
  output_ip.setSlice(1);
  output_ip.getProcessor().resetMinAndMax();
  return output_ip;
}",0.9746434231378764
26231,"/** 
 * Build the coefficients pyramid.
 */
private void buildCoefficientPyramid(){
  int fullWidth;
  int fullHeight;
  double[] fullDual=new double[width * height];
  int halfWidth=width;
  int halfHeight=height;
  basicToCardinal2D(coefficient,fullDual,width,height,7);
  int extraSteps=(int)Math.round(Math.log((double)this.maxImageSubsamplingFactor) / Math.log(2));
  for (int depth=1; ((depth <= (pyramidDepth + extraSteps)) && (!t.isInterrupted())); depth++) {
    IJ.showStatus(""String_Node_Str"");
    IJ.showProgress((double)depth / (pyramidDepth + extraSteps));
    fullWidth=halfWidth;
    fullHeight=halfHeight;
    halfWidth/=2;
    halfHeight/=2;
    if (fullWidth <= BSplineModel.min_image_size || fullHeight <= BSplineModel.min_image_size) {
      if (this.bSubsampledOutput)       IJ.log(""String_Node_Str"" + fullWidth + ""String_Node_Str""+ fullHeight);
      cpyramid.push(fullDual);
      cpyramid.push(new Integer(fullHeight));
      cpyramid.push(new Integer(fullWidth));
      halfWidth*=2;
      halfHeight*=2;
      continue;
    }
    final double[] halfDual=getHalfDual2D(fullDual,fullWidth,fullHeight);
    final double[] halfCoefficient=getBasicFromCardinal2D(halfDual,halfWidth,halfHeight,7);
    if (depth >= extraSteps) {
      if (this.bSubsampledOutput)       IJ.log(""String_Node_Str"" + halfWidth + ""String_Node_Str""+ halfHeight);
      cpyramid.push(halfCoefficient);
      cpyramid.push(new Integer(halfHeight));
      cpyramid.push(new Integer(halfWidth));
    }
    fullDual=halfDual;
    if (this.bSubsampledOutput && halfWidth == this.subWidth) {
      this.subCoeffs=halfCoefficient;
    }
  }
  smallestWidth=halfWidth;
  smallestHeight=halfHeight;
  currentDepth=pyramidDepth + 1;
}","/** 
 * Build the coefficients pyramid.
 */
private void buildCoefficientPyramid(){
  int fullWidth;
  int fullHeight;
  double[] fullDual=new double[width * height];
  int halfWidth=width;
  int halfHeight=height;
  basicToCardinal2D(coefficient,fullDual,width,height,7);
  for (int depth=1; ((depth <= pyramidDepth) && (!t.isInterrupted())); depth++) {
    IJ.showStatus(""String_Node_Str"");
    IJ.showProgress((double)depth / pyramidDepth);
    fullWidth=halfWidth;
    fullHeight=halfHeight;
    halfWidth/=2;
    halfHeight/=2;
    if (fullWidth <= BSplineModel.min_image_size || fullHeight <= BSplineModel.min_image_size) {
      if (this.bSubsampledOutput)       IJ.log(""String_Node_Str"" + fullWidth + ""String_Node_Str""+ fullHeight);
      cpyramid.push(fullDual);
      cpyramid.push(new Integer(fullHeight));
      cpyramid.push(new Integer(fullWidth));
      halfWidth*=2;
      halfHeight*=2;
      continue;
    }
    final double[] halfDual=getHalfDual2D(fullDual,fullWidth,fullHeight);
    final double[] halfCoefficient=getBasicFromCardinal2D(halfDual,halfWidth,halfHeight,7);
    if (this.bSubsampledOutput)     IJ.log(""String_Node_Str"" + halfWidth + ""String_Node_Str""+ halfHeight);
    cpyramid.push(halfCoefficient);
    cpyramid.push(new Integer(halfHeight));
    cpyramid.push(new Integer(halfWidth));
    fullDual=halfDual;
    if (this.bSubsampledOutput && halfWidth == this.subWidth) {
      this.subCoeffs=halfCoefficient;
    }
  }
  smallestWidth=halfWidth;
  smallestHeight=halfHeight;
  currentDepth=pyramidDepth + 1;
}",0.9464668094218416
26232,"/** 
 * Start the image precomputations. The computation of the B-spline coefficients of the full-size image is not interruptible; all other methods are.
 */
public void run(){
  if (image == null && ip != null) {
    image=new double[width * height];
    MiscTools.extractImage(ip,image);
  }
  coefficient=getBasicFromCardinal2D();
  buildCoefficientPyramid();
  if (isTarget || this.bSubsampledOutput)   buildImagePyramid();
}","/** 
 * Start the image pre-computations. The computation of the B-spline coefficients of the full-size image is not interruptible; all other methods are.
 */
public void run(){
  if (image == null && ip != null) {
    this.original_image=new double[width * height];
    this.originalHeight=this.height;
    this.originalWidth=this.width;
    MiscTools.extractImage(ip,this.original_image);
    if (this.maxImageSubsamplingFactor != 0) {
      final float scaleFactor=(float)(1.0f / this.maxImageSubsamplingFactor);
      this.ip=MiscTools.scale(ip,scaleFactor);
      this.width=ip.getWidth();
      this.height=ip.getHeight();
    }
    this.image=new double[width * height];
    MiscTools.extractImage(ip,this.image);
    if (this.width <= this.subWidth) {
      this.subWidth=this.width;
      this.subHeight=this.height;
      this.subImage=this.image;
    }
  }
  coefficient=getBasicFromCardinal2D();
  buildCoefficientPyramid();
  if (isTarget || this.bSubsampledOutput)   buildImagePyramid();
}",0.5893854748603352
26233,"/** 
 * Build the image pyramid.
 */
private void buildImagePyramid(){
  int fullWidth;
  int fullHeight;
  double[] fullDual=new double[width * height];
  int halfWidth=width;
  int halfHeight=height;
  cardinalToDual2D(image,fullDual,width,height,3);
  int extraSteps=(int)Math.round(Math.log((double)this.maxImageSubsamplingFactor) / Math.log(2));
  for (int depth=1; ((depth <= (pyramidDepth + extraSteps)) && (!t.isInterrupted())); depth++) {
    IJ.showStatus(""String_Node_Str"");
    IJ.showProgress((double)depth / (pyramidDepth + extraSteps));
    fullWidth=halfWidth;
    fullHeight=halfHeight;
    halfWidth/=2;
    halfHeight/=2;
    if (fullWidth <= BSplineModel.min_image_size || fullHeight <= BSplineModel.min_image_size) {
      if (this.bSubsampledOutput)       IJ.log(""String_Node_Str"" + fullWidth + ""String_Node_Str""+ fullHeight);
      imgpyramid.push(fullDual);
      imgpyramid.push(new Integer(fullHeight));
      imgpyramid.push(new Integer(fullWidth));
      halfWidth*=2;
      halfHeight*=2;
      continue;
    }
    final double[] halfDual=getHalfDual2D(fullDual,fullWidth,fullHeight);
    final double[] halfImage=new double[halfWidth * halfHeight];
    dualToCardinal2D(halfDual,halfImage,halfWidth,halfHeight,3);
    if (depth >= extraSteps) {
      if (this.bSubsampledOutput)       IJ.log(""String_Node_Str"" + halfWidth + ""String_Node_Str""+ halfHeight);
      imgpyramid.push(halfImage);
      imgpyramid.push(new Integer(halfHeight));
      imgpyramid.push(new Integer(halfWidth));
    }
    fullDual=halfDual;
    if (this.bSubsampledOutput && halfWidth == this.subWidth) {
      this.subImage=halfDual;
    }
  }
  while (halfWidth > this.subWidth) {
    fullWidth=halfWidth;
    fullHeight=halfHeight;
    halfWidth/=2;
    halfHeight/=2;
    final double[] halfDual=getHalfDual2D(fullDual,fullWidth,fullHeight);
    final double[] halfImage=new double[halfWidth * halfHeight];
    dualToCardinal2D(halfDual,halfImage,halfWidth,halfHeight,3);
    fullDual=halfDual;
    if (this.bSubsampledOutput && halfWidth == this.subWidth) {
      this.subImage=halfDual;
    }
  }
}","/** 
 * Build the image pyramid.
 */
private void buildImagePyramid(){
  int fullWidth;
  int fullHeight;
  double[] fullDual=new double[width * height];
  int halfWidth=width;
  int halfHeight=height;
  cardinalToDual2D(image,fullDual,width,height,3);
  for (int depth=1; depth <= pyramidDepth && !t.isInterrupted(); depth++) {
    IJ.showStatus(""String_Node_Str"");
    IJ.showProgress((double)depth / pyramidDepth);
    fullWidth=halfWidth;
    fullHeight=halfHeight;
    halfWidth/=2;
    halfHeight/=2;
    if (fullWidth <= BSplineModel.min_image_size || fullHeight <= BSplineModel.min_image_size) {
      if (this.bSubsampledOutput)       IJ.log(""String_Node_Str"" + fullWidth + ""String_Node_Str""+ fullHeight);
      imgpyramid.push(fullDual);
      imgpyramid.push(new Integer(fullHeight));
      imgpyramid.push(new Integer(fullWidth));
      halfWidth*=2;
      halfHeight*=2;
      continue;
    }
    final double[] halfDual=getHalfDual2D(fullDual,fullWidth,fullHeight);
    final double[] halfImage=new double[halfWidth * halfHeight];
    dualToCardinal2D(halfDual,halfImage,halfWidth,halfHeight,3);
    if (this.bSubsampledOutput)     IJ.log(""String_Node_Str"" + halfWidth + ""String_Node_Str""+ halfHeight);
    imgpyramid.push(halfImage);
    imgpyramid.push(new Integer(halfHeight));
    imgpyramid.push(new Integer(halfWidth));
    fullDual=halfDual;
    if (this.bSubsampledOutput && halfWidth == this.subWidth) {
      this.subImage=halfDual;
    }
  }
  while (halfWidth > this.subWidth) {
    fullWidth=halfWidth;
    fullHeight=halfHeight;
    halfWidth/=2;
    halfHeight/=2;
    final double[] halfDual=getHalfDual2D(fullDual,fullWidth,fullHeight);
    final double[] halfImage=new double[halfWidth * halfHeight];
    dualToCardinal2D(halfDual,halfImage,halfWidth,halfHeight,3);
    fullDual=halfDual;
    if (this.bSubsampledOutput && halfWidth == this.subWidth) {
      this.subImage=halfDual;
    }
  }
}",0.9521448053558146
26234,"/** 
 * fromCurrent=true  --> The interpolation is prepared to be done from the current image in the pyramid. fromCurrent=false --> The interpolation is prepared to be done from the original image.
 * @param x x- point coordinate
 * @param y y- point coordinate
 * @param fromCurrent flag to determine the image to do the interpolation from
 */
public void prepareForInterpolation(double x,double y,boolean fromCurrent){
  this.x=x;
  this.y=y;
  this.fromCurrent=fromCurrent;
  if (fromCurrent) {
    widthToUse=currentWidth;
    heightToUse=currentHeight;
  }
 else {
    widthToUse=width;
    heightToUse=height;
  }
  int ix=(int)x;
  int iy=(int)y;
  int twiceWidthToUse=2 * widthToUse;
  int twiceHeightToUse=2 * heightToUse;
  int p=(0.0 <= x) ? (ix + 2) : (ix + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceWidthToUse <= q)       q-=twiceWidthToUse * (q / twiceWidthToUse);
      xIndex[k]=(widthToUse <= q) ? (twiceWidthToUse - 1 - q) : (q);
    }
 else     xIndex[k]=(p < 0 || p >= widthToUse) ? (-1) : (p);
  }
  p=(0.0 <= y) ? (iy + 2) : (iy + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceHeightToUse <= q)       q-=twiceHeightToUse * (q / twiceHeightToUse);
      yIndex[k]=(heightToUse <= q) ? (twiceHeightToUse - 1 - q) : (q);
    }
 else     yIndex[k]=(p < 0 || p >= heightToUse) ? (-1) : (p);
  }
  double ex=x - ((0.0 <= x) ? (ix) : (ix - 1));
  double ey=y - ((0.0 <= y) ? (iy) : (iy - 1));
  double s=1.0F - ex;
  dxWeight[0]=0.5F * ex * ex;
  xWeight[0]=ex * dxWeight[0] / 3.0F;
  dxWeight[3]=-0.5F * s * s;
  xWeight[3]=s * dxWeight[3] / -3.0F;
  dxWeight[1]=1.0F - 2.0F * dxWeight[0] + dxWeight[3];
  xWeight[1]=MathTools.Bspline03(x - ix - 1);
  dxWeight[2]=1.5F * ex * (ex - 4.0F / 3.0F);
  xWeight[2]=2.0F / 3.0F - (2.0F - ex) * dxWeight[0];
  d2xWeight[0]=ex;
  d2xWeight[1]=s - 2 * ex;
  d2xWeight[2]=ex - 2 * s;
  d2xWeight[3]=s;
  double t=1.0F - ey;
  dyWeight[0]=0.5F * ey * ey;
  yWeight[0]=ey * dyWeight[0] / 3.0F;
  dyWeight[3]=-0.5F * t * t;
  yWeight[3]=t * dyWeight[3] / -3.0F;
  dyWeight[1]=1.0F - 2.0F * dyWeight[0] + dyWeight[3];
  yWeight[1]=2.0F / 3.0F + (1.0F + ey) * dyWeight[3];
  dyWeight[2]=1.5F * ey * (ey - 4.0F / 3.0F);
  yWeight[2]=2.0F / 3.0F - (2.0F - ey) * dyWeight[0];
  d2yWeight[0]=ey;
  d2yWeight[1]=t - 2 * ey;
  d2yWeight[2]=ey - 2 * t;
  d2yWeight[3]=t;
}","/** 
 * fromCurrent=true  --> The interpolation is prepared to be done from the current image in the pyramid. fromCurrent=false --> The interpolation is prepared to be done from the original image.
 * @param x x- point coordinate
 * @param y y- point coordinate
 * @param fromCurrent flag to determine the image to do the interpolation from
 */
public void prepareForInterpolation(double x,double y,boolean fromCurrent){
  this.fromCurrent=fromCurrent;
  if (fromCurrent) {
    widthToUse=currentWidth;
    heightToUse=currentHeight;
  }
 else {
    widthToUse=width;
    heightToUse=height;
  }
  int ix=(int)x;
  int iy=(int)y;
  int twiceWidthToUse=2 * widthToUse;
  int twiceHeightToUse=2 * heightToUse;
  int p=(0.0 <= x) ? (ix + 2) : (ix + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceWidthToUse <= q)       q-=twiceWidthToUse * (q / twiceWidthToUse);
      xIndex[k]=(widthToUse <= q) ? (twiceWidthToUse - 1 - q) : (q);
    }
 else     xIndex[k]=(p < 0 || p >= widthToUse) ? (-1) : (p);
  }
  p=(0.0 <= y) ? (iy + 2) : (iy + 1);
  for (int k=0; k < 4; p--, k++) {
    if (coefficientsAreMirrored) {
      int q=(p < 0) ? (-1 - p) : (p);
      if (twiceHeightToUse <= q)       q-=twiceHeightToUse * (q / twiceHeightToUse);
      yIndex[k]=(heightToUse <= q) ? (twiceHeightToUse - 1 - q) : (q);
    }
 else     yIndex[k]=(p < 0 || p >= heightToUse) ? (-1) : (p);
  }
  double ex=x - ((0.0 <= x) ? (ix) : (ix - 1));
  double ey=y - ((0.0 <= y) ? (iy) : (iy - 1));
  double s=1.0F - ex;
  dxWeight[0]=0.5F * ex * ex;
  xWeight[0]=ex * dxWeight[0] / 3.0F;
  dxWeight[3]=-0.5F * s * s;
  xWeight[3]=s * dxWeight[3] / -3.0F;
  dxWeight[1]=1.0F - 2.0F * dxWeight[0] + dxWeight[3];
  xWeight[1]=MathTools.Bspline03(x - ix - 1);
  dxWeight[2]=1.5F * ex * (ex - 4.0F / 3.0F);
  xWeight[2]=2.0F / 3.0F - (2.0F - ex) * dxWeight[0];
  d2xWeight[0]=ex;
  d2xWeight[1]=s - 2 * ex;
  d2xWeight[2]=ex - 2 * s;
  d2xWeight[3]=s;
  double t=1.0F - ey;
  dyWeight[0]=0.5F * ey * ey;
  yWeight[0]=ey * dyWeight[0] / 3.0F;
  dyWeight[3]=-0.5F * t * t;
  yWeight[3]=t * dyWeight[3] / -3.0F;
  dyWeight[1]=1.0F - 2.0F * dyWeight[0] + dyWeight[3];
  yWeight[1]=2.0F / 3.0F + (1.0F + ey) * dyWeight[3];
  dyWeight[2]=1.5F * ey * (ey - 4.0F / 3.0F);
  yWeight[2]=2.0F / 3.0F - (2.0F - ey) * dyWeight[0];
  d2yWeight[0]=ey;
  d2yWeight[1]=t - 2 * ey;
  d2yWeight[2]=ey - 2 * t;
  d2yWeight[3]=t;
}",0.9951397326852977
26235,"/** 
 * @param c
 * @param width
 * @param height
 */
public double[] reduceCoeffsBy2(double[] c,int width,int height){
  double[] fullDual=new double[width * height];
  int halfWidth=width / 2;
  int halfHeight=height / 2;
  basicToCardinal2D(c,fullDual,width,height,7);
  final double[] halfDual=getHalfDual2D(fullDual,width,height);
  final double[] halfCoefficient=getBasicFromCardinal2D(halfDual,halfWidth,halfHeight,7);
  return halfCoefficient;
}","/** 
 * Reduce coefficients by a factor of 2 (beta)
 * @param c
 * @param width
 * @param height
 */
public double[] reduceCoeffsBy2(double[] c,int width,int height){
  double[] fullDual=new double[width * height];
  int halfWidth=width / 2;
  int halfHeight=height / 2;
  basicToCardinal2D(c,fullDual,width,height,7);
  final double[] halfDual=getHalfDual2D(fullDual,width,height);
  final double[] halfCoefficient=getBasicFromCardinal2D(halfDual,halfWidth,halfHeight,7);
  return halfCoefficient;
}",0.950682056663169
26236,"/** 
 * Get image.
 * @return the full-size image.
 */
public double[] getImage(){
  return image;
}","/** 
 * Get image (at the maximum resolution size determined by the scaling).
 * @return the less scaled image.
 */
public double[] getImage(){
  return image;
}",0.7203065134099617
26237,"/** 
 * Perform the registration
 */
public void run(){
  IJ.showStatus(""String_Node_Str"");
  if (target.getWidth() > BSplineModel.MAX_OUTPUT_SIZE || target.getHeight() > BSplineModel.MAX_OUTPUT_SIZE || source.getWidth() > BSplineModel.MAX_OUTPUT_SIZE || source.getHeight() > BSplineModel.MAX_OUTPUT_SIZE)   IJ.log(""String_Node_Str"");
  source.startPyramids();
  target.startPyramids();
  dialog.joinThreads();
  final ImagePlus[] output_ip=initializeOutputIPs();
  if (this.accurate_mode == MainDialog.MONO_MODE)   this.consistencyWeight=0.0;
  final Transformation warp=new Transformation(sourceImp,targetImp,source,target,sourcePh,targetPh,sourceMsk,targetMsk,sourceAffineMatrix,targetAffineMatrix,min_scale_deformation,max_scale_deformation,min_scale_image,divWeight,curlWeight,landmarkWeight,imageWeight,consistencyWeight,stopThreshold,outputLevel,showMarquardtOptim,accurate_mode,maxImageSubsamplingFactor,dialog.isSaveTransformationSet(),""String_Node_Str"",""String_Node_Str"",output_ip[0],output_ip[1],dialog);
  IJ.showStatus(""String_Node_Str"");
  long start=System.currentTimeMillis();
  if (this.accurate_mode == MainDialog.MONO_MODE) {
    warp.doUnidirectionalRegistration();
    if (this.dialog.isSaveTransformationSet())     warp.saveDirectTransformation();
    if (source.isSubOutput()) {
      IJ.log(""String_Node_Str"");
    }
    warp.showDirectResults();
  }
 else {
    warp.doRegistration();
    if (this.dialog.isSaveTransformationSet()) {
      warp.saveDirectTransformation();
      warp.saveInverseTransformation();
    }
    if (source.isSubOutput()) {
      IJ.log(""String_Node_Str"");
    }
    warp.showDirectResults();
    if (target.isSubOutput()) {
      IJ.log(""String_Node_Str"");
    }
    warp.showInverseResults();
  }
  long stop=System.currentTimeMillis();
  if (outputLevel == 2)   IJ.write(""String_Node_Str"" + (stop - start) + ""String_Node_Str"");
  dialog.restoreAll();
  dialog.freeMemory();
}","/** 
 * Perform the registration
 */
public void run(){
  IJ.showStatus(""String_Node_Str"");
  if (target.getWidth() > BSplineModel.MAX_OUTPUT_SIZE || target.getHeight() > BSplineModel.MAX_OUTPUT_SIZE || source.getWidth() > BSplineModel.MAX_OUTPUT_SIZE || source.getHeight() > BSplineModel.MAX_OUTPUT_SIZE)   IJ.log(""String_Node_Str"");
  source.startPyramids();
  target.startPyramids();
  dialog.joinThreads();
  final ImagePlus[] output_ip=initializeOutputIPs();
  if (this.accurate_mode == MainDialog.MONO_MODE)   this.consistencyWeight=0.0;
  final Transformation warp=new Transformation(sourceImp,targetImp,source,target,sourcePh,targetPh,sourceMsk,targetMsk,sourceAffineMatrix,targetAffineMatrix,min_scale_deformation,max_scale_deformation,min_scale_image,divWeight,curlWeight,landmarkWeight,imageWeight,consistencyWeight,stopThreshold,outputLevel,showMarquardtOptim,accurate_mode,""String_Node_Str"",""String_Node_Str"",output_ip[0],output_ip[1],dialog);
  IJ.showStatus(""String_Node_Str"");
  long start=System.currentTimeMillis();
  if (this.accurate_mode == MainDialog.MONO_MODE) {
    warp.doUnidirectionalRegistration();
    if (this.dialog.isSaveTransformationSet())     warp.saveDirectTransformation();
    if (source.isSubOutput()) {
      IJ.log(""String_Node_Str"");
    }
    warp.showDirectResults();
  }
 else {
    warp.doRegistration();
    if (this.dialog.isSaveTransformationSet()) {
      warp.saveDirectTransformation();
      warp.saveInverseTransformation();
    }
    if (source.isSubOutput()) {
      IJ.log(""String_Node_Str"");
    }
    warp.showDirectResults();
    if (target.isSubOutput()) {
      IJ.log(""String_Node_Str"");
    }
    warp.showInverseResults();
  }
  long stop=System.currentTimeMillis();
  if (outputLevel == 2)   IJ.write(""String_Node_Str"" + (stop - start) + ""String_Node_Str"");
  dialog.restoreAll();
  dialog.freeMemory();
}",0.9844777690081558
26238,"/** 
 * Create target image.
 */
private void createTargetImage(){
  if (this.bMacro) {
    String macroOptions=Macro.getOptions();
    Choice thisChoice=this.targetChoice;
    String item=thisChoice.getSelectedItem();
    item=Macro.getValue(macroOptions,""String_Node_Str"",item);
    for (int i=0; i < this.imageList.length; i++)     if ((this.imageList[i].getTitle()).equals(item)) {
      this.targetChoiceIndex=i;
      break;
    }
  }
  targetImp=imageList[targetChoiceIndex];
  if (this.targetImp.getStackSize() > 1)   this.originalTargetIP=this.targetImp.getStack().getProcessor(1);
 else   this.originalTargetIP=this.targetImp.getProcessor();
  target=new BSplineModel(targetImp.getProcessor(),true,(int)Math.pow(2,this.maxImageSubsamplingFactor));
  this.computeImagePyramidDepth();
  target.setPyramidDepth(imagePyramidDepth + min_scale_image);
  targetIc=targetImp.getWindow().getCanvas();
  if (targetImp.getStackSize() == 1) {
    targetMsk=new Mask(targetImp.getProcessor(),false);
  }
 else {
    targetMsk=new Mask(targetImp.getStack().getProcessor(2),true);
  }
  targetPh=new PointHandler(targetImp,tb,targetMsk,this);
  tb.setTarget(targetImp,targetPh);
}","/** 
 * Create target image.
 */
private void createTargetImage(){
  if (this.bMacro) {
    String macroOptions=Macro.getOptions();
    Choice thisChoice=this.targetChoice;
    String item=thisChoice.getSelectedItem();
    item=Macro.getValue(macroOptions,""String_Node_Str"",item);
    for (int i=0; i < this.imageList.length; i++)     if ((this.imageList[i].getTitle()).equals(item)) {
      this.targetChoiceIndex=i;
      break;
    }
  }
  targetImp=imageList[targetChoiceIndex];
  if (this.targetImp.getStackSize() > 1)   this.originalTargetIP=this.targetImp.getStack().getProcessor(1);
 else   this.originalTargetIP=this.targetImp.getProcessor();
  this.target=new BSplineModel(targetImp.getProcessor(),true,(int)Math.pow(2,this.maxImageSubsamplingFactor));
  this.computeImagePyramidDepth();
  this.target.setPyramidDepth(imagePyramidDepth + min_scale_image);
  this.targetIc=targetImp.getWindow().getCanvas();
  if (targetImp.getStackSize() == 1) {
    this.targetMsk=new Mask(targetImp.getProcessor(),false);
  }
 else {
    this.targetMsk=new Mask(targetImp.getStack().getProcessor(2),true);
  }
  this.targetPh=new PointHandler(targetImp,tb,targetMsk,this);
  this.tb.setTarget(targetImp,targetPh);
}",0.9853249475890984
26239,"/** 
 * Action to be taken when choices change.
 * @param e item event
 */
public void itemStateChanged(ItemEvent e){
  super.itemStateChanged(e);
  Object o=e.getSource();
  if (!(o instanceof Choice))   return;
  Choice originChoice=(Choice)o;
  if (originChoice == this.sourceChoice) {
    final int newChoiceIndex=originChoice.getSelectedIndex();
    if (sourceChoiceIndex != newChoiceIndex) {
      if (targetChoiceIndex != newChoiceIndex) {
        sourceChoiceIndex=newChoiceIndex;
        ungrayImage(sourcePh.getPointAction());
        cancelSource();
        targetPh.removePoints();
        targetImp.setRoi(this.previousTargetRoi);
        createSourceImage(bIsReverse);
        loadPointRoiAsLandmarks();
        setSecondaryPointHandlers();
      }
 else {
        targetChoiceIndex=sourceChoiceIndex;
        sourceChoiceIndex=newChoiceIndex;
        this.targetChoice.select(targetChoiceIndex);
        permuteImages(bIsReverse);
      }
    }
  }
 else   if (originChoice == this.targetChoice) {
    final int newChoiceIndex=originChoice.getSelectedIndex();
    if (targetChoiceIndex != newChoiceIndex) {
      if (sourceChoiceIndex != newChoiceIndex) {
        targetChoiceIndex=newChoiceIndex;
        ungrayImage(targetPh.getPointAction());
        cancelTarget();
        sourcePh.removePoints();
        sourceImp.setRoi(this.previousSourceRoi);
        createTargetImage();
        loadPointRoiAsLandmarks();
        setSecondaryPointHandlers();
      }
 else {
        sourceChoiceIndex=targetChoiceIndex;
        targetChoiceIndex=newChoiceIndex;
        this.sourceChoice.select(sourceChoiceIndex);
        permuteImages(bIsReverse);
      }
    }
  }
 else   if (originChoice == this.modeChoice) {
    final int accurate_mode=originChoice.getSelectedIndex();
    if (accurate_mode == MainDialog.MONO_MODE)     this.consistencyWeightTextField.setEnabled(false);
 else     this.consistencyWeightTextField.setEnabled(true);
  }
 else   if (originChoice == this.minScaleChoice) {
    final int new_min_scale_deformation=originChoice.getSelectedIndex();
    int new_max_scale_deformation=max_scale_deformation;
    if (max_scale_deformation < new_min_scale_deformation)     new_max_scale_deformation=new_min_scale_deformation;
    if (new_min_scale_deformation != min_scale_deformation || new_max_scale_deformation != max_scale_deformation) {
      min_scale_deformation=new_min_scale_deformation;
      max_scale_deformation=new_max_scale_deformation;
      computeImagePyramidDepth();
      restartModelThreads(bIsReverse);
    }
    this.minScaleChoice.select(min_scale_deformation);
    this.maxScaleChoice.select(max_scale_deformation);
  }
 else   if (originChoice == this.maxScaleChoice) {
    final int new_max_scale_deformation=originChoice.getSelectedIndex();
    int new_min_scale_deformation=min_scale_deformation;
    if (new_max_scale_deformation < min_scale_deformation)     new_min_scale_deformation=new_max_scale_deformation;
    if (new_max_scale_deformation != max_scale_deformation || new_min_scale_deformation != min_scale_deformation) {
      min_scale_deformation=new_min_scale_deformation;
      max_scale_deformation=new_max_scale_deformation;
      computeImagePyramidDepth();
      restartModelThreads(bIsReverse);
    }
    this.maxScaleChoice.select(max_scale_deformation);
    this.minScaleChoice.select(min_scale_deformation);
  }
}","/** 
 * Action to be taken when choices change.
 * @param e item event
 */
public void itemStateChanged(ItemEvent e){
  super.itemStateChanged(e);
  Object o=e.getSource();
  if (!(o instanceof Choice))   return;
  Choice originChoice=(Choice)o;
  if (originChoice == this.sourceChoice) {
    final int newChoiceIndex=originChoice.getSelectedIndex();
    if (sourceChoiceIndex != newChoiceIndex) {
      if (targetChoiceIndex != newChoiceIndex) {
        sourceChoiceIndex=newChoiceIndex;
        ungrayImage(sourcePh.getPointAction());
        cancelSource();
        createSourceImage(bIsReverse);
        ungrayImage(targetPh.getPointAction());
        targetPh.removePoints();
        targetImp.setRoi(this.previousTargetRoi);
        loadPointRoiAsLandmarks();
        setSecondaryPointHandlers();
      }
 else {
        targetChoiceIndex=sourceChoiceIndex;
        sourceChoiceIndex=newChoiceIndex;
        this.targetChoice.select(targetChoiceIndex);
        permuteImages(bIsReverse);
      }
    }
  }
 else   if (originChoice == this.targetChoice) {
    final int newChoiceIndex=originChoice.getSelectedIndex();
    if (targetChoiceIndex != newChoiceIndex) {
      if (sourceChoiceIndex != newChoiceIndex) {
        targetChoiceIndex=newChoiceIndex;
        ungrayImage(targetPh.getPointAction());
        cancelTarget();
        createTargetImage();
        ungrayImage(this.sourcePh.getPointAction());
        sourcePh.removePoints();
        sourceImp.setRoi(this.previousSourceRoi);
        loadPointRoiAsLandmarks();
        setSecondaryPointHandlers();
      }
 else {
        sourceChoiceIndex=targetChoiceIndex;
        targetChoiceIndex=newChoiceIndex;
        this.sourceChoice.select(sourceChoiceIndex);
        permuteImages(bIsReverse);
      }
    }
  }
 else   if (originChoice == this.modeChoice) {
    final int accurate_mode=originChoice.getSelectedIndex();
    if (accurate_mode == MainDialog.MONO_MODE)     this.consistencyWeightTextField.setEnabled(false);
 else     this.consistencyWeightTextField.setEnabled(true);
  }
 else   if (originChoice == this.minScaleChoice) {
    final int new_min_scale_deformation=originChoice.getSelectedIndex();
    int new_max_scale_deformation=max_scale_deformation;
    if (max_scale_deformation < new_min_scale_deformation)     new_max_scale_deformation=new_min_scale_deformation;
    if (new_min_scale_deformation != min_scale_deformation || new_max_scale_deformation != max_scale_deformation) {
      min_scale_deformation=new_min_scale_deformation;
      max_scale_deformation=new_max_scale_deformation;
      computeImagePyramidDepth();
      restartModelThreads(bIsReverse);
    }
    this.minScaleChoice.select(min_scale_deformation);
    this.maxScaleChoice.select(max_scale_deformation);
  }
 else   if (originChoice == this.maxScaleChoice) {
    final int new_max_scale_deformation=originChoice.getSelectedIndex();
    int new_min_scale_deformation=min_scale_deformation;
    if (new_max_scale_deformation < min_scale_deformation)     new_min_scale_deformation=new_max_scale_deformation;
    if (new_max_scale_deformation != max_scale_deformation || new_min_scale_deformation != min_scale_deformation) {
      min_scale_deformation=new_min_scale_deformation;
      max_scale_deformation=new_max_scale_deformation;
      computeImagePyramidDepth();
      restartModelThreads(bIsReverse);
    }
    this.maxScaleChoice.select(max_scale_deformation);
    this.minScaleChoice.select(min_scale_deformation);
  }
}",0.9649250473002474
26240,"/** 
 * Create the source image.
 * @param bIsReverse determines the transformation direction (source-target=TRUE or target-source=FALSE)
 */
private void createSourceImage(boolean bIsReverse){
  if (this.bMacro) {
    String macroOptions=Macro.getOptions();
    Choice thisChoice=this.sourceChoice;
    String item=thisChoice.getSelectedItem();
    item=Macro.getValue(macroOptions,""String_Node_Str"",item);
    for (int i=0; i < this.imageList.length; i++)     if ((this.imageList[i].getTitle()).equals(item)) {
      this.sourceChoiceIndex=i;
      break;
    }
  }
  sourceImp=imageList[sourceChoiceIndex];
  if (this.sourceImp.getStackSize() > 1)   this.originalSourceIP=this.sourceImp.getStack().getProcessor(1);
 else   this.originalSourceIP=this.sourceImp.getProcessor();
  source=new BSplineModel(sourceImp.getProcessor(),bIsReverse,(int)Math.pow(2,this.maxImageSubsamplingFactor));
  this.computeImagePyramidDepth();
  source.setPyramidDepth(imagePyramidDepth + min_scale_image);
  sourceIc=sourceImp.getWindow().getCanvas();
  if (sourceImp.getStackSize() == 1) {
    sourceMsk=new Mask(sourceImp.getProcessor(),false);
  }
 else {
    sourceMsk=new Mask(sourceImp.getStack().getProcessor(2),true);
  }
  sourcePh=new PointHandler(sourceImp,tb,sourceMsk,this);
  tb.setSource(sourceImp,sourcePh);
}","/** 
 * Create the source image, i.e. initialize the B-spline model for the source image. The resolution pyramid is not started here, but in startPyramids. 
 * @param bIsReverse determines the transformation direction (source-target=TRUE or target-source=FALSE)
 */
private void createSourceImage(boolean bIsReverse){
  if (this.bMacro) {
    String macroOptions=Macro.getOptions();
    Choice thisChoice=this.sourceChoice;
    String item=thisChoice.getSelectedItem();
    item=Macro.getValue(macroOptions,""String_Node_Str"",item);
    for (int i=0; i < this.imageList.length; i++)     if ((this.imageList[i].getTitle()).equals(item)) {
      this.sourceChoiceIndex=i;
      break;
    }
  }
  sourceImp=imageList[sourceChoiceIndex];
  if (this.sourceImp.getStackSize() > 1)   this.originalSourceIP=this.sourceImp.getStack().getProcessor(1);
 else   this.originalSourceIP=this.sourceImp.getProcessor();
  source=new BSplineModel(sourceImp.getProcessor(),bIsReverse,(int)Math.pow(2,this.maxImageSubsamplingFactor));
  this.computeImagePyramidDepth();
  source.setPyramidDepth(imagePyramidDepth + min_scale_image);
  sourceIc=sourceImp.getWindow().getCanvas();
  if (sourceImp.getStackSize() == 1) {
    sourceMsk=new Mask(sourceImp.getProcessor(),false);
  }
 else {
    sourceMsk=new Mask(sourceImp.getStack().getProcessor(2),true);
  }
  sourcePh=new PointHandler(sourceImp,tb,sourceMsk,this);
  tb.setSource(sourceImp,sourcePh);
}",0.954014598540146
26241,"public void adjustmentValueChanged(AdjustmentEvent adjustmentEvent){
  MainDialog.this.maxImageSubsamplingFactor=Integer.parseInt(resamplingTextField.getText());
}","public void adjustmentValueChanged(AdjustmentEvent adjustmentEvent){
  MainDialog.this.maxImageSubsamplingFactor=Integer.parseInt(resamplingTextField.getText());
  source.setSubsamplingFactor(MainDialog.this.maxImageSubsamplingFactor);
  target.setSubsamplingFactor(MainDialog.this.maxImageSubsamplingFactor);
}",0.6877637130801688
26242,"/** 
 * Create a new instance of MainDialog.
 * @param parentWindow pointer to the parent window
 * @param imageList list of images from ImageJ
 * @param mode default registration mode (0 = Fast, 1 = Accurate, 2 = Mono)
 * @param maxImageSubsamplingFactor subsampling factor at highest resolution level
 * @param min_scale_deformation default minimum scale deformation value
 * @param max_scale_deformation default maximum scale deformation value
 * @param divWeight default divergence weight
 * @param curlWeight default curl weight
 * @param landmarkWeight default landmarks weight
 * @param imageWeight default image similarity weight
 * @param consistencyWeight default consistency weight
 * @param stopThreshold default stopping threshold
 * @param richOutput default verbose flag
 * @param saveTransformation default save transformations flag
 */
public MainDialog(final Frame parentWindow,final ImagePlus[] imageList,final int mode,final int maxImageSubsamplingFactor,final int min_scale_deformation,final int max_scale_deformation,final double divWeight,final double curlWeight,final double landmarkWeight,final double imageWeight,final double consistencyWeight,final double stopThreshold,final boolean richOutput,final boolean saveTransformation){
  super(""String_Node_Str"",null);
  setModal(false);
  this.imageList=imageList;
  this.mode=mode;
  this.maxImageSubsamplingFactor=maxImageSubsamplingFactor;
  this.min_scale_deformation=min_scale_deformation;
  this.max_scale_deformation=max_scale_deformation;
  this.divWeight=divWeight;
  this.curlWeight=curlWeight;
  this.landmarkWeight=landmarkWeight;
  this.imageWeight=imageWeight;
  this.consistencyWeight=consistencyWeight;
  this.stopThreshold=stopThreshold;
  this.richOutput=richOutput;
  this.saveTransformation=saveTransformation;
  String[] titles=new String[imageList.length];
  for (int i=0; i < titles.length; ++i)   titles[i]=imageList[i].getTitle();
  addChoice(""String_Node_Str"",titles,titles[sourceChoiceIndex]);
  this.sourceChoice=(Choice)super.getChoices().lastElement();
  addChoice(""String_Node_Str"",titles,titles[targetChoiceIndex]);
  this.targetChoice=(Choice)super.getChoices().lastElement();
  String[] sRegistrationModes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  addChoice(""String_Node_Str"",sRegistrationModes,sRegistrationModes[this.mode]);
  this.modeChoice=(Choice)super.getChoices().lastElement();
  this.addSlider(""String_Node_Str"",0,7,this.maxImageSubsamplingFactor);
  this.resamplingSlider=(Scrollbar)(super.getSliders().lastElement());
  this.resamplingSlider.addAdjustmentListener(new AdjustmentListener(){
    public void adjustmentValueChanged(    AdjustmentEvent adjustmentEvent){
      MainDialog.this.maxImageSubsamplingFactor=Integer.parseInt(resamplingTextField.getText());
    }
  }
);
  this.resamplingTextField=(TextField)(super.getNumericFields().lastElement());
  this.resamplingTextField.setEnabled(false);
  addMessage(""String_Node_Str"");
  String[] sMinScaleDeformationChoices={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  addChoice(""String_Node_Str"",sMinScaleDeformationChoices,sMinScaleDeformationChoices[this.min_scale_deformation]);
  this.minScaleChoice=(Choice)super.getChoices().lastElement();
  String[] sMaxScaleDeformationChoices={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  addChoice(""String_Node_Str"",sMaxScaleDeformationChoices,sMaxScaleDeformationChoices[this.max_scale_deformation]);
  this.maxScaleChoice=(Choice)super.getChoices().lastElement();
  addNumericField(""String_Node_Str"",this.divWeight,1);
  addNumericField(""String_Node_Str"",this.curlWeight,1);
  addNumericField(""String_Node_Str"",this.landmarkWeight,1);
  addNumericField(""String_Node_Str"",this.imageWeight,1);
  addNumericField(""String_Node_Str"",this.consistencyWeight,1);
  this.consistencyWeightTextField=(TextField)super.getNumericFields().lastElement();
  if (this.mode == MainDialog.MONO_MODE) {
    this.bIsReverse=false;
    this.consistencyWeightTextField.setEnabled(false);
  }
  addNumericField(""String_Node_Str"",this.stopThreshold,2);
  addCheckbox(""String_Node_Str"",this.richOutput);
  addCheckbox(""String_Node_Str"",this.saveTransformation);
  this.bMacro=Macro.getOptions() != null;
  createSourceImage(bIsReverse);
  createTargetImage();
  loadPointRoiAsLandmarks();
  setSecondaryPointHandlers();
}","/** 
 * Create a new instance of MainDialog.
 * @param parentWindow pointer to the parent window
 * @param imageList list of images from ImageJ
 * @param mode default registration mode (0 = Fast, 1 = Accurate, 2 = Mono)
 * @param maxImageSubsamplingFactor subsampling factor at highest resolution level
 * @param min_scale_deformation default minimum scale deformation value
 * @param max_scale_deformation default maximum scale deformation value
 * @param divWeight default divergence weight
 * @param curlWeight default curl weight
 * @param landmarkWeight default landmarks weight
 * @param imageWeight default image similarity weight
 * @param consistencyWeight default consistency weight
 * @param stopThreshold default stopping threshold
 * @param richOutput default verbose flag
 * @param saveTransformation default save transformations flag
 */
public MainDialog(final Frame parentWindow,final ImagePlus[] imageList,final int mode,final int maxImageSubsamplingFactor,final int min_scale_deformation,final int max_scale_deformation,final double divWeight,final double curlWeight,final double landmarkWeight,final double imageWeight,final double consistencyWeight,final double stopThreshold,final boolean richOutput,final boolean saveTransformation){
  super(""String_Node_Str"",null);
  setModal(false);
  this.imageList=imageList;
  this.mode=mode;
  this.maxImageSubsamplingFactor=maxImageSubsamplingFactor;
  this.min_scale_deformation=min_scale_deformation;
  this.max_scale_deformation=max_scale_deformation;
  this.divWeight=divWeight;
  this.curlWeight=curlWeight;
  this.landmarkWeight=landmarkWeight;
  this.imageWeight=imageWeight;
  this.consistencyWeight=consistencyWeight;
  this.stopThreshold=stopThreshold;
  this.richOutput=richOutput;
  this.saveTransformation=saveTransformation;
  String[] titles=new String[imageList.length];
  for (int i=0; i < titles.length; ++i)   titles[i]=imageList[i].getTitle();
  addChoice(""String_Node_Str"",titles,titles[sourceChoiceIndex]);
  this.sourceChoice=(Choice)super.getChoices().lastElement();
  addChoice(""String_Node_Str"",titles,titles[targetChoiceIndex]);
  this.targetChoice=(Choice)super.getChoices().lastElement();
  String[] sRegistrationModes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  addChoice(""String_Node_Str"",sRegistrationModes,sRegistrationModes[this.mode]);
  this.modeChoice=(Choice)super.getChoices().lastElement();
  this.addSlider(""String_Node_Str"",0,7,this.maxImageSubsamplingFactor);
  this.resamplingSlider=(Scrollbar)(super.getSliders().lastElement());
  this.resamplingSlider.addAdjustmentListener(new AdjustmentListener(){
    public void adjustmentValueChanged(    AdjustmentEvent adjustmentEvent){
      MainDialog.this.maxImageSubsamplingFactor=Integer.parseInt(resamplingTextField.getText());
      source.setSubsamplingFactor(MainDialog.this.maxImageSubsamplingFactor);
      target.setSubsamplingFactor(MainDialog.this.maxImageSubsamplingFactor);
    }
  }
);
  this.resamplingTextField=(TextField)(super.getNumericFields().lastElement());
  this.resamplingTextField.setEnabled(false);
  addMessage(""String_Node_Str"");
  String[] sMinScaleDeformationChoices={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  addChoice(""String_Node_Str"",sMinScaleDeformationChoices,sMinScaleDeformationChoices[this.min_scale_deformation]);
  this.minScaleChoice=(Choice)super.getChoices().lastElement();
  String[] sMaxScaleDeformationChoices={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  addChoice(""String_Node_Str"",sMaxScaleDeformationChoices,sMaxScaleDeformationChoices[this.max_scale_deformation]);
  this.maxScaleChoice=(Choice)super.getChoices().lastElement();
  addNumericField(""String_Node_Str"",this.divWeight,1);
  addNumericField(""String_Node_Str"",this.curlWeight,1);
  addNumericField(""String_Node_Str"",this.landmarkWeight,1);
  addNumericField(""String_Node_Str"",this.imageWeight,1);
  addNumericField(""String_Node_Str"",this.consistencyWeight,1);
  this.consistencyWeightTextField=(TextField)super.getNumericFields().lastElement();
  if (this.mode == MainDialog.MONO_MODE) {
    this.bIsReverse=false;
    this.consistencyWeightTextField.setEnabled(false);
  }
  addNumericField(""String_Node_Str"",this.stopThreshold,2);
  addCheckbox(""String_Node_Str"",this.richOutput);
  addCheckbox(""String_Node_Str"",this.saveTransformation);
  this.bMacro=Macro.getOptions() != null;
  createSourceImage(bIsReverse);
  createTargetImage();
  loadPointRoiAsLandmarks();
  setSecondaryPointHandlers();
}",0.9826125724476148
26243,"/** 
 * Ungray image. It restores the original version of the image (without mask).
 * @param pa point action pointer
 */
public void ungrayImage(final PointAction pa){
  if (pa == sourcePh.getPointAction()) {
    if (this.sourceImp != null && this.sourceImp.getProcessor() != null) {
      this.sourceImp.setProcessor(sourceImp.getTitle(),this.originalSourceIP);
      sourceImp.updateImage();
    }
  }
 else {
    if (this.targetImp != null && this.targetImp.getProcessor() != null) {
      this.targetImp.setProcessor(this.targetImp.getTitle(),this.originalTargetIP);
      targetImp.updateImage();
    }
  }
}","/** 
 * Ungray image. It restores the original version of the image (without mask).
 * @param pa point action pointer
 */
public void ungrayImage(final PointAction pa){
  if (sourcePh != null && pa == sourcePh.getPointAction()) {
    if (this.sourceImp != null && this.sourceImp.getProcessor() != null) {
      this.sourceImp.setProcessor(sourceImp.getTitle(),this.originalSourceIP);
      this.sourceImp.updateImage();
    }
  }
 else {
    if (this.targetImp != null && this.targetImp.getProcessor() != null) {
      this.targetImp.setProcessor(this.targetImp.getTitle(),this.originalTargetIP);
      targetImp.updateImage();
    }
  }
}",0.980047885075818
26244,"/** 
 * Gives the least-squares solution to (A * x = b) such that (A^T * A)^-1 * A^T * b = x is a vector of size (column), where A is a (line x column) matrix, and where b is a vector of size (line). The result may differ from that obtained by a singular-value decomposition in the cases where the least-squares solution is not uniquely defined (SVD returns the solution of least norm, not QR).
 * @param A An input matrix A[line][column] of size (line x column)
 * @param b An input vector b[line] of size (line)
 * @return An output vector x[column] of size (column)
 */
public static double[] linearLeastSquares(final double[][] A,final double[] b){
  final int lines=A.length;
  final int columns=A[0].length;
  final double[][] Q=new double[lines][columns];
  final double[][] R=new double[columns][columns];
  final double[] x=new double[columns];
  double s;
  for (int i=0; (i < lines); i++) {
    for (int j=0; (j < columns); j++) {
      Q[i][j]=A[i][j];
    }
  }
  QRdecomposition(Q,R);
  for (int i=0; (i < columns); i++) {
    s=0.0F;
    for (int j=0; (j < lines); j++) {
      s+=Q[j][i] * b[j];
    }
    x[i]=s;
  }
  for (int i=columns - 1; (0 <= i); i--) {
    s=R[i][i];
    if ((s * s) == 0.0F) {
      x[i]=0.0F;
    }
 else {
      x[i]/=s;
    }
    for (int j=i - 1; (0 <= j); j--) {
      x[j]-=R[j][i] * x[i];
    }
  }
  return (x);
}","/** 
 * Gives the least-squares solution to (A * x = b) such that (A^T * A)^-1 * A^T * b = x is a vector of size (column), where A is a (line x column) matrix, and where b is a vector of size (line). The result may differ from that obtained by a singular-value decomposition in the cases where the least-squares solution is not uniquely defined (SVD returns the solution of least norm, not QR).
 * @param A An input matrix A[line][column] of size (line x column)
 * @param b An input vector b[line] of size (line)
 * @return An output vector x[column] of size (column)
 */
public static double[] linearLeastSquares(final double[][] A,final double[] b){
  if (A == null || A.length == 0)   return null;
  final int lines=A.length;
  final int columns=A[0].length;
  final double[][] Q=new double[lines][columns];
  final double[][] R=new double[columns][columns];
  final double[] x=new double[columns];
  double s;
  for (int i=0; (i < lines); i++) {
    for (int j=0; (j < columns); j++) {
      Q[i][j]=A[i][j];
    }
  }
  QRdecomposition(Q,R);
  for (int i=0; (i < columns); i++) {
    s=0.0F;
    for (int j=0; (j < lines); j++) {
      s+=Q[j][i] * b[j];
    }
    x[i]=s;
  }
  for (int i=columns - 1; (0 <= i); i--) {
    s=R[i][i];
    if ((s * s) == 0.0F) {
      x[i]=0.0F;
    }
 else {
      x[i]/=s;
    }
    for (int j=i - 1; (0 <= j); j--) {
      x[j]-=R[j][i] * x[i];
    }
  }
  return (x);
}",0.9823423423423424
26245,"/** 
 * ($$$$) eg: $$aaa$$$$bbb$$ccc$$    aaa,bbb
 * @param templet 
 * @param split 
 * @return 
 */
public static Set<String> getParamNames(String templet,String split){
  Set<String> paramNames=new HashSet<String>();
  int start=0, end=0;
  while (end < templet.length()) {
    start=templet.indexOf(split,end) + split.length();
    if (start == -1) {
      break;
    }
    end=templet.indexOf(split,start);
    if (end == -1) {
      break;
    }
    paramNames.add(templet.substring(start,end));
    end=end + split.length();
  }
  return paramNames;
}","/** 
 * ($$$$) eg: $$aaa$$$$bbb$$ccc$$    aaa,bbb
 * @param templet 
 * @param split 
 * @return 
 */
public static Set<String> getParamNames(String templet,String split){
  Set<String> paramNames=new HashSet<String>();
  int start=0, end=0;
  while (end < templet.length()) {
    start=templet.indexOf(split,end);
    if (start == -1) {
      break;
    }
    start=start + split.length();
    end=templet.indexOf(split,start);
    if (end == -1) {
      break;
    }
    paramNames.add(templet.substring(start,end));
    end=end + split.length();
  }
  return paramNames;
}",0.9578860445912468
26246,"@Override public void channelRead(final ChannelHandlerContext ctx,Object msg) throws Exception {
  if (!(msg instanceof HttpObject) || !(((HttpObject)msg).getDecoderResult().isSuccess())) {
    sendError(ctx,HttpResponseStatus.BAD_REQUEST,null);
  }
  HttpObject httpObject=(HttpObject)msg;
  messageQueue.add(httpObject);
  if (tunnelEstablished) {
    processQueuedMessages(ctx);
    return;
  }
  if (msg instanceof HttpRequest) {
    request=(HttpRequest)msg;
    try {
      requestUri=new URI(request.getUri());
    }
 catch (    URISyntaxException e) {
      sendError(ctx,HttpResponseStatus.BAD_REQUEST,null);
      return;
    }
    String hostHeaderValue=request.headers().get(HOST);
    requestedHost=getRequestedHost(requestUri,hostHeaderValue);
    if (requestedHost == null) {
      sendError(ctx,HttpResponseStatus.BAD_REQUEST,null);
      return;
    }
    VirtualHostConfig vhost=virtualHosts.get(requestedHost.getName());
    if (vhost == null) {
      sendError(ctx,HttpResponseStatus.SERVICE_UNAVAILABLE,null);
      return;
    }
    destinationHost=parseHost(vhost.getBalance().getMembers().iterator().next());
    connectToDestination(ctx,destinationHost);
  }
}","@Override public void channelRead(final ChannelHandlerContext ctx,Object msg) throws Exception {
  if (!(msg instanceof HttpObject) || !(((HttpObject)msg).getDecoderResult().isSuccess())) {
    sendError(ctx,HttpResponseStatus.BAD_REQUEST,null);
  }
  HttpObject httpObject=(HttpObject)msg;
  messageQueue.add(httpObject);
  if (tunnelEstablished) {
    processQueuedMessages(ctx);
    return;
  }
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)msg;
    try {
      requestUri=new URI(request.getUri());
    }
 catch (    URISyntaxException e) {
      sendError(ctx,HttpResponseStatus.BAD_REQUEST,null);
      return;
    }
    String hostHeaderValue=request.headers().get(HOST);
    requestedHost=getRequestedHost(requestUri,hostHeaderValue);
    if (requestedHost == null) {
      sendError(ctx,HttpResponseStatus.BAD_REQUEST,null);
      return;
    }
    VirtualHostConfig vhost=virtualHosts.get(requestedHost.getName());
    if (vhost == null) {
      sendError(ctx,HttpResponseStatus.SERVICE_UNAVAILABLE,null);
      return;
    }
    destinationHost=parseHost(vhost.getBalance().getMembers().iterator().next());
    connectToDestination(ctx,destinationHost);
  }
}",0.9949622166246852
26247,"private void onTunnelMessage(final ChannelHandlerContext ctx,Object msg) throws Exception {
  Object outboundMsg=msg;
  ensureBuf(ctx);
  if (msg instanceof HttpRequest) {
    boolean authcRequired=false;
    String decodedPath=requestUri.getPath();
    for (    String pattern : stormpathConfig.getAuthenticate()) {
      if (pathMatcher.match(pattern,decodedPath)) {
        authcRequired=true;
        break;
      }
    }
    buf.writeBytes(ascii(request.getMethod()));
    buf.writeByte(SP);
    buf.writeBytes(utf8(request.getUri()));
    buf.writeByte(SP);
    buf.writeBytes(ascii(request.getProtocolVersion()));
    appendCrlf(buf);
    String authzHeaderValue=null;
    boolean xForwardedForSet=false;
    boolean xForwardedHostSet=false;
    writeHeader(buf,HOST.toString(),toHttpHostString(destinationHost));
    HttpHeaders headers=request.headers();
    if (!headers.isEmpty()) {
      for (      Map.Entry<String,String> header : headers) {
        String headerName=header.getKey();
        String headerValue=header.getValue();
        if (headerName.equalsIgnoreCase(""String_Node_Str"")) {
          xForwardedHostSet=true;
        }
        if (headerName.equalsIgnoreCase(""String_Node_Str"")) {
          headerValue+=""String_Node_Str"" + getHost(ctx.channel().remoteAddress()).getName();
          xForwardedForSet=true;
        }
        if (headerName.equalsIgnoreCase(HOST.toString())) {
          continue;
        }
        if (headerName.equalsIgnoreCase(AUTHORIZATION.toString())) {
          authzHeaderValue=headerValue;
          continue;
        }
        writeHeader(buf,headerName,headerValue);
      }
    }
    if (!xForwardedHostSet) {
      String headerValue=toHttpHostString(requestedHost);
      writeHeader(buf,""String_Node_Str"",headerValue);
    }
    if (!xForwardedForSet) {
      writeHeader(buf,""String_Node_Str"",getHost(ctx.channel().remoteAddress()).getName());
    }
    boolean writeAuthzHeader=authzHeaderValue != null;
    if (authcRequired) {
      if (authzHeaderValue != null && authzHeaderValue.toLowerCase().trim().startsWith(""String_Node_Str"")) {
        int lastSpaceIndex=authzHeaderValue.lastIndexOf(' ');
        String schemeValue=authzHeaderValue.substring(lastSpaceIndex + 1);
        String decoded=Base64.decodeToString(schemeValue);
        String username;
        String password=null;
        int colonIndex=decoded.lastIndexOf(':');
        if (colonIndex > 0) {
          username=decoded.substring(0,colonIndex);
          if (colonIndex < (decoded.length() - 1)) {
            password=decoded.substring(colonIndex + 1);
          }
        }
 else {
          username=decoded;
        }
        String clientHost=getHost(ctx.channel().remoteAddress()).getName();
        UsernamePasswordRequest request=new UsernamePasswordRequest(username,password,clientHost);
        try {
          AuthenticationResult result=this.application.authenticateAccount(request);
          writeHeader(buf,""String_Node_Str"",result.getAccount().getHref());
          writeAuthzHeader=false;
        }
 catch (        ResourceException e) {
          sendBasicAuthcChallenge(ctx);
          return;
        }
      }
 else {
        sendBasicAuthcChallenge(ctx);
        return;
      }
    }
    if (writeAuthzHeader) {
      writeHeader(buf,AUTHORIZATION,authzHeaderValue);
    }
    appendCrlf(buf);
    outboundMsg=buf;
    RequestEvent event=new RequestEvent(-1,buf.readableBytes());
    this.eventBus.post(event);
  }
  if (msg instanceof HttpContent) {
    HttpContent content=(HttpContent)msg;
    outboundMsg=content.content();
  }
  if (outboundChannel.isActive()) {
    outboundChannel.writeAndFlush(outboundMsg).addListener(new ChannelFutureListener(){
      @Override public void operationComplete(      ChannelFuture future) throws Exception {
        if (future.isSuccess()) {
          ctx.channel().read();
        }
 else {
          future.channel().close();
        }
      }
    }
);
  }
}","private void onTunnelMessage(final ChannelHandlerContext ctx,Object msg) throws Exception {
  Object outboundMsg=msg;
  ensureBuf(ctx);
  if (msg instanceof HttpRequest) {
    request=(HttpRequest)msg;
    boolean authcRequired=false;
    String decodedPath=requestUri.getPath();
    for (    String pattern : stormpathConfig.getAuthenticate()) {
      if (pathMatcher.match(pattern,decodedPath)) {
        authcRequired=true;
        break;
      }
    }
    buf.writeBytes(ascii(request.getMethod()));
    buf.writeByte(SP);
    buf.writeBytes(utf8(request.getUri()));
    buf.writeByte(SP);
    buf.writeBytes(ascii(request.getProtocolVersion()));
    appendCrlf(buf);
    String authzHeaderValue=null;
    boolean xForwardedForSet=false;
    boolean xForwardedHostSet=false;
    writeHeader(buf,HOST.toString(),toHttpHostString(destinationHost));
    HttpHeaders headers=request.headers();
    if (!headers.isEmpty()) {
      for (      Map.Entry<String,String> header : headers) {
        String headerName=header.getKey();
        String headerValue=header.getValue();
        if (headerName.equalsIgnoreCase(""String_Node_Str"")) {
          xForwardedHostSet=true;
        }
        if (headerName.equalsIgnoreCase(""String_Node_Str"")) {
          headerValue+=""String_Node_Str"" + getHost(ctx.channel().remoteAddress()).getName();
          xForwardedForSet=true;
        }
        if (headerName.equalsIgnoreCase(HOST.toString())) {
          continue;
        }
        if (headerName.equalsIgnoreCase(AUTHORIZATION.toString())) {
          authzHeaderValue=headerValue;
          continue;
        }
        writeHeader(buf,headerName,headerValue);
      }
    }
    if (!xForwardedHostSet) {
      String headerValue=toHttpHostString(requestedHost);
      writeHeader(buf,""String_Node_Str"",headerValue);
    }
    if (!xForwardedForSet) {
      writeHeader(buf,""String_Node_Str"",getHost(ctx.channel().remoteAddress()).getName());
    }
    boolean writeAuthzHeader=authzHeaderValue != null;
    if (authcRequired) {
      if (authzHeaderValue != null && authzHeaderValue.toLowerCase().trim().startsWith(""String_Node_Str"")) {
        int lastSpaceIndex=authzHeaderValue.lastIndexOf(' ');
        String schemeValue=authzHeaderValue.substring(lastSpaceIndex + 1);
        String decoded=Base64.decodeToString(schemeValue);
        String username;
        String password=null;
        int colonIndex=decoded.lastIndexOf(':');
        if (colonIndex > 0) {
          username=decoded.substring(0,colonIndex);
          if (colonIndex < (decoded.length() - 1)) {
            password=decoded.substring(colonIndex + 1);
          }
        }
 else {
          username=decoded;
        }
        String clientHost=getHost(ctx.channel().remoteAddress()).getName();
        UsernamePasswordRequest request=new UsernamePasswordRequest(username,password,clientHost);
        try {
          AuthenticationResult result=this.application.authenticateAccount(request);
          writeHeader(buf,""String_Node_Str"",result.getAccount().getHref());
          writeAuthzHeader=false;
        }
 catch (        ResourceException e) {
          sendBasicAuthcChallenge(ctx);
          return;
        }
      }
 else {
        sendBasicAuthcChallenge(ctx);
        return;
      }
    }
    if (writeAuthzHeader) {
      writeHeader(buf,AUTHORIZATION,authzHeaderValue);
    }
    appendCrlf(buf);
    outboundMsg=buf;
    RequestEvent event=new RequestEvent(-1,buf.readableBytes());
    this.eventBus.post(event);
  }
  if (msg instanceof HttpContent) {
    HttpContent content=(HttpContent)msg;
    outboundMsg=content.content();
  }
  if (outboundChannel.isActive()) {
    outboundChannel.writeAndFlush(outboundMsg).addListener(new ChannelFutureListener(){
      @Override public void operationComplete(      ChannelFuture future) throws Exception {
        if (future.isSuccess()) {
          ctx.channel().read();
        }
 else {
          future.channel().close();
        }
      }
    }
);
  }
}",0.9962311557788944
26248,"protected void calculateLegendOffsets(RectF offsets){
  offsets.left=0.f;
  offsets.right=0.f;
  offsets.top=0.f;
  offsets.bottom=0.f;
  if (mLegend != null && mLegend.isEnabled() && !mLegend.isDrawInsideEnabled()) {
switch (mLegend.getOrientation()) {
case VERTICAL:
switch (mLegend.getHorizontalAlignment()) {
case LEFT:
        offsets.left+=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getXOffset();
      break;
case RIGHT:
    offsets.right+=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getXOffset();
  break;
case CENTER:
switch (mLegend.getVerticalAlignment()) {
case TOP:
  offsets.top+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
case BOTTOM:
offsets.bottom+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
default :
break;
}
}
break;
case HORIZONTAL:
switch (mLegend.getVerticalAlignment()) {
case TOP:
offsets.top+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
if (getXAxis().isEnabled() && getXAxis().isDrawLabelsEnabled()) offsets.top+=getXAxis().mLabelRotatedHeight;
break;
case BOTTOM:
offsets.bottom+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
if (getXAxis().isEnabled() && getXAxis().isDrawLabelsEnabled()) offsets.bottom+=getXAxis().mLabelRotatedHeight;
break;
default :
break;
}
break;
}
}
}","protected void calculateLegendOffsets(RectF offsets){
  offsets.left=0.f;
  offsets.right=0.f;
  offsets.top=0.f;
  offsets.bottom=0.f;
  if (mLegend != null && mLegend.isEnabled() && !mLegend.isDrawInsideEnabled()) {
switch (mLegend.getOrientation()) {
case VERTICAL:
switch (mLegend.getHorizontalAlignment()) {
case LEFT:
        offsets.left+=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getXOffset();
      break;
case RIGHT:
    offsets.right+=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getXOffset();
  break;
case CENTER:
switch (mLegend.getVerticalAlignment()) {
case TOP:
  offsets.top+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
case BOTTOM:
offsets.bottom+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
default :
break;
}
}
break;
case HORIZONTAL:
switch (mLegend.getVerticalAlignment()) {
case TOP:
offsets.top+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
case BOTTOM:
offsets.bottom+=Math.min(mLegend.mNeededHeight,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent()) + mLegend.getYOffset();
break;
default :
break;
}
break;
}
}
}",0.9122349102773246
26249,"@Override public void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    calculateLegendOffsets(mOffsetsBuffer);
    offsetLeft+=mOffsetsBuffer.left;
    offsetTop+=mOffsetsBuffer.top;
    offsetRight+=mOffsetsBuffer.right;
    offsetBottom+=mOffsetsBuffer.bottom;
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getPaintAxisLabels());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getPaintAxisLabels());
    }
    if (mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled()) {
      float xlabelheight=mXAxis.mLabelRotatedHeight + mXAxis.getYOffset();
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    offsetTop+=getExtraTopOffset();
    offsetRight+=getExtraRightOffset();
    offsetBottom+=getExtraBottomOffset();
    offsetLeft+=getExtraLeftOffset();
    float minOffset=Utils.convertDpToPixel(mMinOffset);
    mViewPortHandler.restrainViewPort(Math.max(minOffset,offsetLeft),Math.max(minOffset,offsetTop),Math.max(minOffset,offsetRight),Math.max(minOffset,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override public void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    calculateLegendOffsets(mOffsetsBuffer);
    offsetLeft+=mOffsetsBuffer.left;
    offsetTop+=mOffsetsBuffer.top;
    offsetRight+=mOffsetsBuffer.right;
    offsetBottom+=mOffsetsBuffer.bottom;
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getPaintAxisLabels());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getPaintAxisLabels());
    }
    if (mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled()) {
      float xLabelHeight=mXAxis.mLabelRotatedHeight + mXAxis.getYOffset();
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xLabelHeight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xLabelHeight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xLabelHeight;
        offsetTop+=xLabelHeight;
      }
    }
    offsetTop+=getExtraTopOffset();
    offsetRight+=getExtraRightOffset();
    offsetBottom+=getExtraBottomOffset();
    offsetLeft+=getExtraLeftOffset();
    float minOffset=Utils.convertDpToPixel(mMinOffset);
    mViewPortHandler.restrainViewPort(Math.max(minOffset,offsetLeft),Math.max(minOffset,offsetTop),Math.max(minOffset,offsetRight),Math.max(minOffset,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.9944506104328524
26250,"private void setupChart(LineChart chart,LineData data,int color){
  ((LineDataSet)data.getDataSetByIndex(0)).setCircleColorHole(color);
  chart.getDescription().setEnabled(false);
  chart.setDrawGridBackground(false);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setViewPortOffsets(10,0,10,0);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setEnabled(false);
  chart.getAxisLeft().setEnabled(false);
  chart.getAxisLeft().setSpaceTop(40);
  chart.getAxisLeft().setSpaceBottom(40);
  chart.getAxisRight().setEnabled(false);
  chart.getXAxis().setEnabled(false);
  chart.animateX(2500);
}","private void setupChart(LineChart chart,LineData data,int color){
  ((LineDataSet)data.getDataSetByIndex(0)).setCircleHoleColor(color);
  chart.getDescription().setEnabled(false);
  chart.setDrawGridBackground(false);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setViewPortOffsets(10,0,10,0);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setEnabled(false);
  chart.getAxisLeft().setEnabled(false);
  chart.getAxisLeft().setSpaceTop(40);
  chart.getAxisLeft().setSpaceBottom(40);
  chart.getAxisRight().setEnabled(false);
  chart.getXAxis().setEnabled(false);
  chart.animateX(2500);
}",0.994413407821229
26251,"@Override public DataSet<BarEntry> copy(){
  List<BarEntry> yVals=new ArrayList<BarEntry>();
  yVals.clear();
  for (int i=0; i < mValues.size(); i++) {
    yVals.add(mValues.get(i).copy());
  }
  BarDataSet copied=new BarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mStackSize=mStackSize;
  copied.mBarShadowColor=mBarShadowColor;
  copied.mStackLabels=mStackLabels;
  copied.mHighLightColor=mHighLightColor;
  copied.mHighLightAlpha=mHighLightAlpha;
  return copied;
}","protected void copy(BarDataSet barDataSet){
  super.copy(barDataSet);
  barDataSet.mStackSize=mStackSize;
  barDataSet.mBarShadowColor=mBarShadowColor;
  barDataSet.mBarBorderWidth=mBarBorderWidth;
  barDataSet.mStackLabels=mStackLabels;
  barDataSet.mHighLightAlpha=mHighLightAlpha;
}",0.3704663212435233
26252,"@Override public List<GradientColor> getGradientColors(){
  return gradientColors;
}","@Override public List<GradientColor> getGradientColors(){
  return mGradientColors;
}",0.9822485207100592
26253,"/** 
 * Sets the start and end color for gradient color, ONLY color that should be used for this DataSet.
 * @param startColor
 * @param endColor
 */
public void setGradientColor(int startColor,int endColor){
  gradientColor=new GradientColor(startColor,endColor);
}","/** 
 * Sets the start and end color for gradient color, ONLY color that should be used for this DataSet.
 * @param startColor
 * @param endColor
 */
public void setGradientColor(int startColor,int endColor){
  mGradientColor=new GradientColor(startColor,endColor);
}",0.9943714821763602
26254,"/** 
 * Sets the start and end color for gradient colors, ONLY color that should be used for this DataSet.
 * @param gradientColors
 */
public void setGradientColors(List<GradientColor> gradientColors){
  this.gradientColors=gradientColors;
}","/** 
 * Sets the start and end color for gradient colors, ONLY color that should be used for this DataSet.
 * @param gradientColors
 */
public void setGradientColors(List<GradientColor> gradientColors){
  this.mGradientColors=gradientColors;
}",0.9938144329896909
26255,"@Override public GradientColor getGradientColor(int index){
  return gradientColors.get(index % gradientColors.size());
}","@Override public GradientColor getGradientColor(int index){
  return mGradientColors.get(index % mGradientColors.size());
}",0.9754098360655736
26256,"@Override public DataSet<BubbleEntry> copy(){
  List<BubbleEntry> yVals=new ArrayList<BubbleEntry>();
  for (int i=0; i < mValues.size(); i++) {
    yVals.add(mValues.get(i).copy());
  }
  BubbleDataSet copied=new BubbleDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","protected void copy(BubbleDataSet bubbleDataSet){
  bubbleDataSet.mHighlightCircleWidth=mHighlightCircleWidth;
  bubbleDataSet.mNormalizeSize=mNormalizeSize;
}",0.3170731707317073
26257,"@Override public DataSet<CandleEntry> copy(){
  List<CandleEntry> yVals=new ArrayList<CandleEntry>();
  yVals.clear();
  for (int i=0; i < mValues.size(); i++) {
    yVals.add(mValues.get(i).copy());
  }
  CandleDataSet copied=new CandleDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShadowWidth=mShadowWidth;
  copied.mShowCandleBar=mShowCandleBar;
  copied.mBarSpace=mBarSpace;
  copied.mHighLightColor=mHighLightColor;
  copied.mIncreasingPaintStyle=mIncreasingPaintStyle;
  copied.mDecreasingPaintStyle=mDecreasingPaintStyle;
  copied.mShadowColor=mShadowColor;
  return copied;
}","protected void copy(CandleDataSet candleDataSet){
  super.copy(candleDataSet);
  candleDataSet.mShadowWidth=mShadowWidth;
  candleDataSet.mShowCandleBar=mShowCandleBar;
  candleDataSet.mBarSpace=mBarSpace;
  candleDataSet.mShadowColorSameAsCandle=mShadowColorSameAsCandle;
  candleDataSet.mHighLightColor=mHighLightColor;
  candleDataSet.mIncreasingPaintStyle=mIncreasingPaintStyle;
  candleDataSet.mDecreasingPaintStyle=mDecreasingPaintStyle;
  candleDataSet.mNeutralColor=mNeutralColor;
  candleDataSet.mIncreasingColor=mIncreasingColor;
  candleDataSet.mDecreasingColor=mDecreasingColor;
  candleDataSet.mShadowColor=mShadowColor;
}",0.0340080971659919
26258,"/** 
 * Provides an exact copy of the DataSet this method is used on.
 * @return
 */
public abstract DataSet<T> copy();","/** 
 * @param dataSet
 */
protected void copy(DataSet dataSet){
  super.copy(dataSet);
}",0.3942307692307692
26259,"@Override public DataSet<Entry> copy(){
  List<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mValues.size(); i++) {
    yVals.add(mValues.get(i).copy());
  }
  LineDataSet copied=new LineDataSet(yVals,getLabel());
  copied.mMode=mMode;
  copied.mColors=mColors;
  copied.mCircleRadius=mCircleRadius;
  copied.mCircleHoleRadius=mCircleHoleRadius;
  copied.mCircleColors=mCircleColors;
  copied.mDashPathEffect=mDashPathEffect;
  copied.mDrawCircles=mDrawCircles;
  copied.mDrawCircleHole=mDrawCircleHole;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","protected void copy(LineDataSet lineDataSet){
  super.copy(lineDataSet);
  lineDataSet.mCircleColors=mCircleColors;
  lineDataSet.mCircleHoleColor=mCircleHoleColor;
  lineDataSet.mCircleHoleRadius=mCircleHoleRadius;
  lineDataSet.mCircleRadius=mCircleRadius;
  lineDataSet.mCubicIntensity=mCubicIntensity;
  lineDataSet.mDashPathEffect=mDashPathEffect;
  lineDataSet.mDrawCircleHole=mDrawCircleHole;
  lineDataSet.mDrawCircles=mDrawCircleHole;
  lineDataSet.mFillFormatter=mFillFormatter;
  lineDataSet.mMode=mMode;
}",0.2124542124542124
26260,"@Override public int getCircleHoleColor(){
  return mCircleColorHole;
}","@Override public int getCircleHoleColor(){
  return mCircleHoleColor;
}",0.943661971830986
26261,"protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
      visibleAngleCount++;
    }
  }
  final float sliceSpace=visibleAngleCount <= 1 ? 0.f : getSliceSpace(dataSet);
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getY()) > Utils.FLOAT_EPSILON)) {
      if (!mChart.needsHighlight(j)) {
        final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
        float arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
        if (sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
          if (accountForSliceSpacing) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            if (accountForSliceSpacing) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
  MPPointF.recycleInstance(center);
}","protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
      visibleAngleCount++;
    }
  }
  final float sliceSpace=visibleAngleCount <= 1 ? 0.f : getSliceSpace(dataSet);
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getY()) > Utils.FLOAT_EPSILON)) {
      if (!mChart.needsHighlight(j)) {
        final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
        float arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
        if (sweepAngleOuter >= 360.f && sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
          if (accountForSliceSpacing) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter >= 360.f && sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f > Utils.FLOAT_EPSILON) {
            if (accountForSliceSpacing) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
  MPPointF.recycleInstance(center);
}",0.9875095036385358
26262,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float angle;
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  final RectF highlightedCircleBox=mDrawHighlightedRectF;
  highlightedCircleBox.set(0,0,0,0);
  for (int i=0; i < indices.length; i++) {
    int index=(int)indices[i].getX();
    if (index >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    final int entryCount=set.getEntryCount();
    int visibleAngleCount=0;
    for (int j=0; j < entryCount; j++) {
      if ((Math.abs(set.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
        visibleAngleCount++;
      }
    }
    if (index == 0)     angle=0.f;
 else     angle=absoluteAngles[index - 1] * phaseX;
    final float sliceSpace=visibleAngleCount <= 1 ? 0.f : set.getSliceSpace();
    float sliceAngle=drawAngles[index];
    float innerRadius=userInnerRadius;
    float shift=set.getSelectionShift();
    final float highlightedRadius=radius + shift;
    highlightedCircleBox.set(mChart.getCircleBox());
    highlightedCircleBox.inset(-shift,-shift);
    final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
    mRenderPaint.setColor(set.getColor(index));
    final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
    final float sliceSpaceAngleShifted=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * highlightedRadius);
    final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
    float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
    if (sweepAngleOuter < 0.f) {
      sweepAngleOuter=0.f;
    }
    final float startAngleShifted=rotationAngle + (angle + sliceSpaceAngleShifted / 2.f) * phaseY;
    float sweepAngleShifted=(sliceAngle - sliceSpaceAngleShifted) * phaseY;
    if (sweepAngleShifted < 0.f) {
      sweepAngleShifted=0.f;
    }
    mPathBuffer.reset();
    if (sweepAngleOuter % 360f == 0.f) {
      mPathBuffer.addCircle(center.x,center.y,highlightedRadius,Path.Direction.CW);
    }
 else {
      mPathBuffer.moveTo(center.x + highlightedRadius * (float)Math.cos(startAngleShifted * Utils.FDEG2RAD),center.y + highlightedRadius * (float)Math.sin(startAngleShifted * Utils.FDEG2RAD));
      mPathBuffer.arcTo(highlightedCircleBox,startAngleShifted,sweepAngleShifted);
    }
    float sliceSpaceRadius=0.f;
    if (accountForSliceSpacing) {
      sliceSpaceRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD),startAngleOuter,sweepAngleOuter);
    }
    mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
    if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
      if (accountForSliceSpacing) {
        float minSpacedRadius=sliceSpaceRadius;
        if (minSpacedRadius < 0.f)         minSpacedRadius=-minSpacedRadius;
        innerRadius=Math.max(innerRadius,minSpacedRadius);
      }
      final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
      final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
      float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
      if (sweepAngleInner < 0.f) {
        sweepAngleInner=0.f;
      }
      final float endAngleInner=startAngleInner + sweepAngleInner;
      if (sweepAngleOuter % 360f == 0.f) {
        mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
      }
 else {
        mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
        mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
      }
    }
 else {
      if (sweepAngleOuter % 360f != 0.f) {
        if (accountForSliceSpacing) {
          final float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
          final float arcEndPointX=center.x + sliceSpaceRadius * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
          final float arcEndPointY=center.y + sliceSpaceRadius * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
          mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
        }
 else {
          mPathBuffer.lineTo(center.x,center.y);
        }
      }
    }
    mPathBuffer.close();
    mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
  }
  MPPointF.recycleInstance(center);
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float angle;
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  final RectF highlightedCircleBox=mDrawHighlightedRectF;
  highlightedCircleBox.set(0,0,0,0);
  for (int i=0; i < indices.length; i++) {
    int index=(int)indices[i].getX();
    if (index >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    final int entryCount=set.getEntryCount();
    int visibleAngleCount=0;
    for (int j=0; j < entryCount; j++) {
      if ((Math.abs(set.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
        visibleAngleCount++;
      }
    }
    if (index == 0)     angle=0.f;
 else     angle=absoluteAngles[index - 1] * phaseX;
    final float sliceSpace=visibleAngleCount <= 1 ? 0.f : set.getSliceSpace();
    float sliceAngle=drawAngles[index];
    float innerRadius=userInnerRadius;
    float shift=set.getSelectionShift();
    final float highlightedRadius=radius + shift;
    highlightedCircleBox.set(mChart.getCircleBox());
    highlightedCircleBox.inset(-shift,-shift);
    final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
    mRenderPaint.setColor(set.getColor(index));
    final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
    final float sliceSpaceAngleShifted=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * highlightedRadius);
    final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
    float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
    if (sweepAngleOuter < 0.f) {
      sweepAngleOuter=0.f;
    }
    final float startAngleShifted=rotationAngle + (angle + sliceSpaceAngleShifted / 2.f) * phaseY;
    float sweepAngleShifted=(sliceAngle - sliceSpaceAngleShifted) * phaseY;
    if (sweepAngleShifted < 0.f) {
      sweepAngleShifted=0.f;
    }
    mPathBuffer.reset();
    if (sweepAngleOuter >= 360.f && sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
      mPathBuffer.addCircle(center.x,center.y,highlightedRadius,Path.Direction.CW);
    }
 else {
      mPathBuffer.moveTo(center.x + highlightedRadius * (float)Math.cos(startAngleShifted * Utils.FDEG2RAD),center.y + highlightedRadius * (float)Math.sin(startAngleShifted * Utils.FDEG2RAD));
      mPathBuffer.arcTo(highlightedCircleBox,startAngleShifted,sweepAngleShifted);
    }
    float sliceSpaceRadius=0.f;
    if (accountForSliceSpacing) {
      sliceSpaceRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD),startAngleOuter,sweepAngleOuter);
    }
    mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
    if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
      if (accountForSliceSpacing) {
        float minSpacedRadius=sliceSpaceRadius;
        if (minSpacedRadius < 0.f)         minSpacedRadius=-minSpacedRadius;
        innerRadius=Math.max(innerRadius,minSpacedRadius);
      }
      final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
      final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
      float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
      if (sweepAngleInner < 0.f) {
        sweepAngleInner=0.f;
      }
      final float endAngleInner=startAngleInner + sweepAngleInner;
      if (sweepAngleOuter >= 360.f && sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
        mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
      }
 else {
        mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
        mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
      }
    }
 else {
      if (sweepAngleOuter % 360f > Utils.FLOAT_EPSILON) {
        if (accountForSliceSpacing) {
          final float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
          final float arcEndPointX=center.x + sliceSpaceRadius * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
          final float arcEndPointY=center.y + sliceSpaceRadius * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
          mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
        }
 else {
          mPathBuffer.lineTo(center.x,center.y);
        }
      }
    }
    mPathBuffer.close();
    mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
  }
  MPPointF.recycleInstance(center);
}",0.985987989705462
26263,"/** 
 * Draws the zero line.
 */
protected void drawZeroLine(Canvas c){
  int clipRestoreCount=c.save();
  mZeroLineClippingRect.set(mViewPortHandler.getContentRect());
  mZeroLineClippingRect.inset(0.f,-mYAxis.getZeroLineWidth() / 2.f);
  c.clipRect(mLimitLineClippingRect);
  MPPointD pos=mTrans.getPixelForValues(0f,0f);
  mZeroLinePaint.setColor(mYAxis.getZeroLineColor());
  mZeroLinePaint.setStrokeWidth(mYAxis.getZeroLineWidth());
  Path zeroLinePath=mDrawZeroLinePath;
  zeroLinePath.reset();
  zeroLinePath.moveTo(mViewPortHandler.contentLeft(),(float)pos.y - 1);
  zeroLinePath.lineTo(mViewPortHandler.contentRight(),(float)pos.y - 1);
  c.drawPath(zeroLinePath,mZeroLinePaint);
  c.restoreToCount(clipRestoreCount);
}","/** 
 * Draws the zero line.
 */
protected void drawZeroLine(Canvas c){
  int clipRestoreCount=c.save();
  mZeroLineClippingRect.set(mViewPortHandler.getContentRect());
  mZeroLineClippingRect.inset(0.f,-mYAxis.getZeroLineWidth() / 2.f);
  c.clipRect(mZeroLineClippingRect);
  MPPointD pos=mTrans.getPixelForValues(0f,0f);
  mZeroLinePaint.setColor(mYAxis.getZeroLineColor());
  mZeroLinePaint.setStrokeWidth(mYAxis.getZeroLineWidth());
  Path zeroLinePath=mDrawZeroLinePath;
  zeroLinePath.reset();
  zeroLinePath.moveTo(mViewPortHandler.contentLeft(),(float)pos.y - 1);
  zeroLinePath.lineTo(mViewPortHandler.contentRight(),(float)pos.y - 1);
  c.drawPath(zeroLinePath,mZeroLinePaint);
  c.restoreToCount(clipRestoreCount);
}",0.9938144329896909
26264,"/** 
 * Sets up the axis values. Computes the desired number of labels between the two given extremes.
 * @return
 */
protected void computeAxisValues(float min,float max){
  float yMin=min;
  float yMax=max;
  int labelCount=mAxis.getLabelCount();
  double range=Math.abs(yMax - yMin);
  if (labelCount == 0 || range <= 0) {
    mAxis.mEntries=new float[]{};
    mAxis.mEntryCount=0;
    return;
  }
  double rawInterval=range / labelCount;
  if (Double.isInfinite(rawInterval)) {
    rawInterval=range > 0.0 && !Double.isInfinite(range) ? range : 1.0;
  }
  double interval=Utils.roundToNextSignificant(rawInterval);
  if (mAxis.isGranularityEnabled())   interval=interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;
  double intervalMagnitude=Utils.roundToNextSignificant(Math.pow(10,(int)Math.log10(interval)));
  int intervalSigDigit=(int)(interval / intervalMagnitude);
  if (intervalSigDigit > 5) {
    interval=Math.floor(10 * intervalMagnitude);
  }
  boolean centeringEnabled=mAxis.isCenterAxisLabelsEnabled();
  int n=centeringEnabled ? 1 : 0;
  if (mAxis.isForceLabelsEnabled()) {
    float step=(float)range / (float)(labelCount - 1);
    mAxis.mEntryCount=labelCount;
    if (mAxis.mEntries.length < labelCount) {
      mAxis.mEntries=new float[labelCount];
    }
    float v=min;
    for (int i=0; i < labelCount; i++) {
      mAxis.mEntries[i]=v;
      v+=step;
    }
    n=labelCount;
  }
 else {
    double first=interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;
    if (centeringEnabled) {
      first-=interval;
    }
    double last=interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);
    double f;
    int i;
    if (interval != 0.0) {
      for (f=first; f <= last; f+=interval) {
        ++n;
      }
    }
    mAxis.mEntryCount=n;
    if (mAxis.mEntries.length < n) {
      mAxis.mEntries=new float[n];
    }
    for (f=first, i=0; i < n; f+=interval, ++i) {
      if (f == 0.0)       f=0.0;
      mAxis.mEntries[i]=(float)f;
    }
  }
  if (interval < 1) {
    mAxis.mDecimals=(int)Math.ceil(-Math.log10(interval));
  }
 else {
    mAxis.mDecimals=0;
  }
  if (centeringEnabled) {
    if (mAxis.mCenteredEntries.length < n) {
      mAxis.mCenteredEntries=new float[n];
    }
    float offset=(mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;
    for (int i=0; i < n; i++) {
      mAxis.mCenteredEntries[i]=mAxis.mEntries[i] + offset;
    }
  }
}","/** 
 * Sets up the axis values. Computes the desired number of labels between the two given extremes.
 * @return
 */
protected void computeAxisValues(float min,float max){
  float yMin=min;
  float yMax=max;
  int labelCount=mAxis.getLabelCount();
  double range=Math.abs(yMax - yMin);
  if (labelCount == 0 || range <= 0 || Double.isInfinite(range)) {
    mAxis.mEntries=new float[]{};
    mAxis.mCenteredEntries=new float[]{};
    mAxis.mEntryCount=0;
    return;
  }
  double rawInterval=range / labelCount;
  double interval=Utils.roundToNextSignificant(rawInterval);
  if (mAxis.isGranularityEnabled())   interval=interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;
  double intervalMagnitude=Utils.roundToNextSignificant(Math.pow(10,(int)Math.log10(interval)));
  int intervalSigDigit=(int)(interval / intervalMagnitude);
  if (intervalSigDigit > 5) {
    interval=Math.floor(10 * intervalMagnitude);
  }
  boolean centeringEnabled=mAxis.isCenterAxisLabelsEnabled();
  int n=centeringEnabled ? 1 : 0;
  if (mAxis.isForceLabelsEnabled()) {
    float step=(float)range / (float)(labelCount - 1);
    mAxis.mEntryCount=labelCount;
    if (mAxis.mEntries.length < labelCount) {
      mAxis.mEntries=new float[labelCount];
    }
    float v=min;
    for (int i=0; i < labelCount; i++) {
      mAxis.mEntries[i]=v;
      v+=step;
    }
    n=labelCount;
  }
 else {
    double first=interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;
    if (centeringEnabled) {
      first-=interval;
    }
    double last=interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);
    double f;
    int i;
    if (interval != 0.0) {
      for (f=first; f <= last; f+=interval) {
        ++n;
      }
    }
    mAxis.mEntryCount=n;
    if (mAxis.mEntries.length < n) {
      mAxis.mEntries=new float[n];
    }
    for (f=first, i=0; i < n; f+=interval, ++i) {
      if (f == 0.0)       f=0.0;
      mAxis.mEntries[i]=(float)f;
    }
  }
  if (interval < 1) {
    mAxis.mDecimals=(int)Math.ceil(-Math.log10(interval));
  }
 else {
    mAxis.mDecimals=0;
  }
  if (centeringEnabled) {
    if (mAxis.mCenteredEntries.length < n) {
      mAxis.mCenteredEntries=new float[n];
    }
    float offset=(mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;
    for (int i=0; i < n; i++) {
      mAxis.mCenteredEntries[i]=mAxis.mEntries[i] + offset;
    }
  }
}",0.9612661391087048
26265,"@Override protected void computeAxisValues(float min,float max){
  float yMin=min;
  float yMax=max;
  int labelCount=mAxis.getLabelCount();
  double range=Math.abs(yMax - yMin);
  if (labelCount == 0 || range <= 0) {
    mAxis.mEntries=new float[]{};
    mAxis.mEntryCount=0;
    return;
  }
  double rawInterval=range / labelCount;
  if (Double.isInfinite(rawInterval)) {
    rawInterval=range > 0.0 && !Double.isInfinite(range) ? range : 1.0;
  }
  double interval=Utils.roundToNextSignificant(rawInterval);
  if (mAxis.isGranularityEnabled())   interval=interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;
  double intervalMagnitude=Utils.roundToNextSignificant(Math.pow(10,(int)Math.log10(interval)));
  int intervalSigDigit=(int)(interval / intervalMagnitude);
  if (intervalSigDigit > 5) {
    interval=Math.floor(10 * intervalMagnitude);
  }
  boolean centeringEnabled=mAxis.isCenterAxisLabelsEnabled();
  int n=centeringEnabled ? 1 : 0;
  if (mAxis.isForceLabelsEnabled()) {
    float step=(float)range / (float)(labelCount - 1);
    mAxis.mEntryCount=labelCount;
    if (mAxis.mEntries.length < labelCount) {
      mAxis.mEntries=new float[labelCount];
    }
    float v=min;
    for (int i=0; i < labelCount; i++) {
      mAxis.mEntries[i]=v;
      v+=step;
    }
    n=labelCount;
  }
 else {
    double first=interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;
    if (centeringEnabled) {
      first-=interval;
    }
    double last=interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);
    double f;
    int i;
    if (interval != 0.0) {
      for (f=first; f <= last; f+=interval) {
        ++n;
      }
    }
    n++;
    mAxis.mEntryCount=n;
    if (mAxis.mEntries.length < n) {
      mAxis.mEntries=new float[n];
    }
    for (f=first, i=0; i < n; f+=interval, ++i) {
      if (f == 0.0)       f=0.0;
      mAxis.mEntries[i]=(float)f;
    }
  }
  if (interval < 1) {
    mAxis.mDecimals=(int)Math.ceil(-Math.log10(interval));
  }
 else {
    mAxis.mDecimals=0;
  }
  if (centeringEnabled) {
    if (mAxis.mCenteredEntries.length < n) {
      mAxis.mCenteredEntries=new float[n];
    }
    float offset=(mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;
    for (int i=0; i < n; i++) {
      mAxis.mCenteredEntries[i]=mAxis.mEntries[i] + offset;
    }
  }
  mAxis.mAxisMinimum=mAxis.mEntries[0];
  mAxis.mAxisMaximum=mAxis.mEntries[n - 1];
  mAxis.mAxisRange=Math.abs(mAxis.mAxisMaximum - mAxis.mAxisMinimum);
}","@Override protected void computeAxisValues(float min,float max){
  float yMin=min;
  float yMax=max;
  int labelCount=mAxis.getLabelCount();
  double range=Math.abs(yMax - yMin);
  if (labelCount == 0 || range <= 0 || Double.isInfinite(range)) {
    mAxis.mEntries=new float[]{};
    mAxis.mCenteredEntries=new float[]{};
    mAxis.mEntryCount=0;
    return;
  }
  double rawInterval=range / labelCount;
  double interval=Utils.roundToNextSignificant(rawInterval);
  if (mAxis.isGranularityEnabled())   interval=interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;
  double intervalMagnitude=Utils.roundToNextSignificant(Math.pow(10,(int)Math.log10(interval)));
  int intervalSigDigit=(int)(interval / intervalMagnitude);
  if (intervalSigDigit > 5) {
    interval=Math.floor(10 * intervalMagnitude);
  }
  boolean centeringEnabled=mAxis.isCenterAxisLabelsEnabled();
  int n=centeringEnabled ? 1 : 0;
  if (mAxis.isForceLabelsEnabled()) {
    float step=(float)range / (float)(labelCount - 1);
    mAxis.mEntryCount=labelCount;
    if (mAxis.mEntries.length < labelCount) {
      mAxis.mEntries=new float[labelCount];
    }
    float v=min;
    for (int i=0; i < labelCount; i++) {
      mAxis.mEntries[i]=v;
      v+=step;
    }
    n=labelCount;
  }
 else {
    double first=interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;
    if (centeringEnabled) {
      first-=interval;
    }
    double last=interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);
    double f;
    int i;
    if (interval != 0.0) {
      for (f=first; f <= last; f+=interval) {
        ++n;
      }
    }
    n++;
    mAxis.mEntryCount=n;
    if (mAxis.mEntries.length < n) {
      mAxis.mEntries=new float[n];
    }
    for (f=first, i=0; i < n; f+=interval, ++i) {
      if (f == 0.0)       f=0.0;
      mAxis.mEntries[i]=(float)f;
    }
  }
  if (interval < 1) {
    mAxis.mDecimals=(int)Math.ceil(-Math.log10(interval));
  }
 else {
    mAxis.mDecimals=0;
  }
  if (centeringEnabled) {
    if (mAxis.mCenteredEntries.length < n) {
      mAxis.mCenteredEntries=new float[n];
    }
    float offset=(mAxis.mEntries[1] - mAxis.mEntries[0]) / 2f;
    for (int i=0; i < n; i++) {
      mAxis.mCenteredEntries[i]=mAxis.mEntries[i] + offset;
    }
  }
  mAxis.mAxisMinimum=mAxis.mEntries[0];
  mAxis.mAxisMaximum=mAxis.mEntries[n - 1];
  mAxis.mAxisRange=Math.abs(mAxis.mAxisMaximum - mAxis.mAxisMinimum);
}",0.9621335504885994
26266,"/** 
 * Returns the Description object of the chart.
 * @return
 */
public Description getDescription(){
  return mDescription;
}","/** 
 * Returns the Description object of the chart that is responsible for holding all information related to the description text that is displayed in the bottom right corner of the chart (by default).
 * @return
 */
public Description getDescription(){
  return mDescription;
}",0.6308068459657702
26267,"@Override public void drawValues(Canvas c){
  MPPointF center=mChart.getCenterCircleBox();
  float radius=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final float holeRadiusPercent=mChart.getHoleRadius() / 100.f;
  float labelRadiusOffset=radius / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    labelRadiusOffset=(radius - (radius * holeRadiusPercent)) / 2f;
  }
  final float labelRadius=radius - labelRadiusOffset;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  float yValueSum=data.getYValueSum();
  boolean drawEntryLabels=mChart.isDrawEntryLabelsEnabled();
  float angle;
  int xIndex=0;
  c.save();
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    final boolean drawValues=dataSet.isDrawValuesEnabled();
    if (!drawValues && !drawEntryLabels)     continue;
    final PieDataSet.ValuePosition xValuePosition=dataSet.getXValuePosition();
    final PieDataSet.ValuePosition yValuePosition=dataSet.getYValuePosition();
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    IValueFormatter formatter=dataSet.getValueFormatter();
    int entryCount=dataSet.getEntryCount();
    mValueLinePaint.setColor(dataSet.getValueLineColor());
    mValueLinePaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getValueLineWidth()));
    float offset=Utils.convertDpToPixel(5.f);
    final float sliceSpace=getSliceSpace(dataSet);
    for (int j=0; j < entryCount; j++) {
      PieEntry entry=dataSet.getEntryForIndex(j);
      if (xIndex == 0)       angle=0.f;
 else       angle=absoluteAngles[xIndex - 1] * phaseX;
      final float sliceAngle=drawAngles[xIndex];
      final float sliceSpaceMiddleAngle=sliceSpace / (Utils.FDEG2RAD * labelRadius);
      final float angleOffset=(sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;
      angle=angle + angleOffset;
      final float transformedAngle=rotationAngle + angle * phaseY;
      float value=mChart.isUsePercentValuesEnabled() ? entry.getY() / yValueSum * 100f : entry.getY();
      final float sliceXBase=(float)Math.cos(transformedAngle * Utils.FDEG2RAD);
      final float sliceYBase=(float)Math.sin(transformedAngle * Utils.FDEG2RAD);
      final boolean drawXOutside=drawEntryLabels && xValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawYOutside=drawValues && yValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawXInside=drawEntryLabels && xValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      final boolean drawYInside=drawValues && yValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      if (drawXOutside || drawYOutside) {
        final float valueLineLength1=dataSet.getValueLinePart1Length();
        final float valueLineLength2=dataSet.getValueLinePart2Length();
        final float valueLinePart1OffsetPercentage=dataSet.getValueLinePart1OffsetPercentage() / 100.f;
        float pt2x, pt2y;
        float labelPtx, labelPty;
        float line1Radius;
        if (mChart.isDrawHoleEnabled())         line1Radius=(radius - (radius * holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * holeRadiusPercent);
 else         line1Radius=radius * valueLinePart1OffsetPercentage;
        final float polyline2Width=dataSet.isValueLineVariableLength() ? labelRadius * valueLineLength2 * (float)Math.abs(Math.sin(transformedAngle * Utils.FDEG2RAD)) : labelRadius * valueLineLength2;
        final float pt0x=line1Radius * sliceXBase + center.x;
        final float pt0y=line1Radius * sliceYBase + center.y;
        final float pt1x=labelRadius * (1 + valueLineLength1) * sliceXBase + center.x;
        final float pt1y=labelRadius * (1 + valueLineLength1) * sliceYBase + center.y;
        if (transformedAngle % 360.0 >= 90.0 && transformedAngle % 360.0 <= 270.0) {
          pt2x=pt1x - polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.RIGHT);
          labelPtx=pt2x - offset;
          labelPty=pt2y;
        }
 else {
          pt2x=pt1x + polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.LEFT);
          labelPtx=pt2x + offset;
          labelPty=pt2y;
        }
        if (dataSet.getValueLineColor() != ColorTemplate.COLOR_NONE) {
          c.drawLine(pt0x,pt0y,pt1x,pt1y,mValueLinePaint);
          c.drawLine(pt1x,pt1y,pt2x,pt2y,mValueLinePaint);
        }
        if (drawXOutside && drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),labelPtx,labelPty + lineHeight);
          }
        }
 else         if (drawXOutside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),labelPtx,labelPty + lineHeight / 2.f);
          }
        }
 else         if (drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty + lineHeight / 2.f,dataSet.getValueTextColor(j));
        }
      }
      if (drawXInside || drawYInside) {
        float x=labelRadius * sliceXBase + center.x;
        float y=labelRadius * sliceYBase + center.y;
        mValuePaint.setTextAlign(Align.CENTER);
        if (drawXInside && drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),x,y + lineHeight);
          }
        }
 else         if (drawXInside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),x,y + lineHeight / 2f);
          }
        }
 else         if (drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f,dataSet.getValueTextColor(j));
        }
      }
      xIndex++;
    }
  }
  MPPointF.recycleInstance(center);
  c.restore();
}","@Override public void drawValues(Canvas c){
  MPPointF center=mChart.getCenterCircleBox();
  float radius=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final float holeRadiusPercent=mChart.getHoleRadius() / 100.f;
  float labelRadiusOffset=radius / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    labelRadiusOffset=(radius - (radius * holeRadiusPercent)) / 2f;
  }
  final float labelRadius=radius - labelRadiusOffset;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  float yValueSum=data.getYValueSum();
  boolean drawEntryLabels=mChart.isDrawEntryLabelsEnabled();
  float angle;
  int xIndex=0;
  c.save();
  float offset=Utils.convertDpToPixel(5.f);
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    final boolean drawValues=dataSet.isDrawValuesEnabled();
    if (!drawValues && !drawEntryLabels)     continue;
    final PieDataSet.ValuePosition xValuePosition=dataSet.getXValuePosition();
    final PieDataSet.ValuePosition yValuePosition=dataSet.getYValuePosition();
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    IValueFormatter formatter=dataSet.getValueFormatter();
    int entryCount=dataSet.getEntryCount();
    mValueLinePaint.setColor(dataSet.getValueLineColor());
    mValueLinePaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getValueLineWidth()));
    final float sliceSpace=getSliceSpace(dataSet);
    for (int j=0; j < entryCount; j++) {
      PieEntry entry=dataSet.getEntryForIndex(j);
      if (xIndex == 0)       angle=0.f;
 else       angle=absoluteAngles[xIndex - 1] * phaseX;
      final float sliceAngle=drawAngles[xIndex];
      final float sliceSpaceMiddleAngle=sliceSpace / (Utils.FDEG2RAD * labelRadius);
      final float angleOffset=(sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;
      angle=angle + angleOffset;
      final float transformedAngle=rotationAngle + angle * phaseY;
      float value=mChart.isUsePercentValuesEnabled() ? entry.getY() / yValueSum * 100f : entry.getY();
      final float sliceXBase=(float)Math.cos(transformedAngle * Utils.FDEG2RAD);
      final float sliceYBase=(float)Math.sin(transformedAngle * Utils.FDEG2RAD);
      final boolean drawXOutside=drawEntryLabels && xValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawYOutside=drawValues && yValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawXInside=drawEntryLabels && xValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      final boolean drawYInside=drawValues && yValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      if (drawXOutside || drawYOutside) {
        final float valueLineLength1=dataSet.getValueLinePart1Length();
        final float valueLineLength2=dataSet.getValueLinePart2Length();
        final float valueLinePart1OffsetPercentage=dataSet.getValueLinePart1OffsetPercentage() / 100.f;
        float pt2x, pt2y;
        float labelPtx, labelPty;
        float line1Radius;
        if (mChart.isDrawHoleEnabled())         line1Radius=(radius - (radius * holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * holeRadiusPercent);
 else         line1Radius=radius * valueLinePart1OffsetPercentage;
        final float polyline2Width=dataSet.isValueLineVariableLength() ? labelRadius * valueLineLength2 * (float)Math.abs(Math.sin(transformedAngle * Utils.FDEG2RAD)) : labelRadius * valueLineLength2;
        final float pt0x=line1Radius * sliceXBase + center.x;
        final float pt0y=line1Radius * sliceYBase + center.y;
        final float pt1x=labelRadius * (1 + valueLineLength1) * sliceXBase + center.x;
        final float pt1y=labelRadius * (1 + valueLineLength1) * sliceYBase + center.y;
        if (transformedAngle % 360.0 >= 90.0 && transformedAngle % 360.0 <= 270.0) {
          pt2x=pt1x - polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.RIGHT);
          if (drawXOutside)           mEntryLabelsPaint.setTextAlign(Align.RIGHT);
          labelPtx=pt2x - offset;
          labelPty=pt2y;
        }
 else {
          pt2x=pt1x + polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.LEFT);
          if (drawXOutside)           mEntryLabelsPaint.setTextAlign(Align.LEFT);
          labelPtx=pt2x + offset;
          labelPty=pt2y;
        }
        if (dataSet.getValueLineColor() != ColorTemplate.COLOR_NONE) {
          c.drawLine(pt0x,pt0y,pt1x,pt1y,mValueLinePaint);
          c.drawLine(pt1x,pt1y,pt2x,pt2y,mValueLinePaint);
        }
        if (drawXOutside && drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),labelPtx,labelPty + lineHeight);
          }
        }
 else         if (drawXOutside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),labelPtx,labelPty + lineHeight / 2.f);
          }
        }
 else         if (drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty + lineHeight / 2.f,dataSet.getValueTextColor(j));
        }
      }
      if (drawXInside || drawYInside) {
        float x=labelRadius * sliceXBase + center.x;
        float y=labelRadius * sliceYBase + center.y;
        mValuePaint.setTextAlign(Align.CENTER);
        if (drawXInside && drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),x,y + lineHeight);
          }
        }
 else         if (drawXInside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            drawEntryLabel(c,entry.getLabel(),x,y + lineHeight / 2f);
          }
        }
 else         if (drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f,dataSet.getValueTextColor(j));
        }
      }
      xIndex++;
    }
  }
  MPPointF.recycleInstance(center);
  c.restore();
}",0.9797602984363838
26268,"protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
      visibleAngleCount++;
    }
  }
  final float sliceSpace=visibleAngleCount <= 1 ? 0.f : getSliceSpace(dataSet);
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getY()) > Utils.FLOAT_EPSILON)) {
      if (!mChart.needsHighlight(j)) {
        final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=0.f, arcStartPointY=0.f;
        if (sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
          arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
          if (accountForSliceSpacing) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            if (accountForSliceSpacing) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
  MPPointF.recycleInstance(center);
}","protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  final MPPointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getY()) > Utils.FLOAT_EPSILON)) {
      visibleAngleCount++;
    }
  }
  final float sliceSpace=visibleAngleCount <= 1 ? 0.f : getSliceSpace(dataSet);
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getY()) > Utils.FLOAT_EPSILON)) {
      if (!mChart.needsHighlight(j)) {
        final boolean accountForSliceSpacing=sliceSpace > 0.f && sliceAngle <= 180.f;
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
        float arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
        if (sweepAngleOuter % 360f <= Utils.FLOAT_EPSILON) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || accountForSliceSpacing)) {
          if (accountForSliceSpacing) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            if (accountForSliceSpacing) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
  MPPointF.recycleInstance(center);
}",0.9598516255727688
26269,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setProgress(10);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  mChart.setUsePercentValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setExtraOffsets(5,10,5,5);
  mChart.setDragDecelerationFrictionCoef(0.95f);
  mChart.setCenterTextTypeface(mTfLight);
  mChart.setCenterText(generateCenterSpannableText());
  mChart.setDrawHoleEnabled(true);
  mChart.setHoleColor(Color.WHITE);
  mChart.setTransparentCircleColor(Color.WHITE);
  mChart.setTransparentCircleAlpha(110);
  mChart.setHoleRadius(58f);
  mChart.setTransparentCircleRadius(61f);
  mChart.setDrawCenterText(true);
  mChart.setRotationAngle(0);
  mChart.setRotationEnabled(true);
  mChart.setHighlightPerTapEnabled(true);
  mChart.setOnChartValueSelectedListener(this);
  setData(4,100);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuad);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(0f);
  l.setYOffset(0f);
  mChart.setEntryLabelColor(Color.WHITE);
  mChart.setEntryLabelTypeface(mTfRegular);
  mChart.setEntryLabelTextSize(12f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(4);
  mSeekBarY.setProgress(10);
  mChart=(PieChart)findViewById(R.id.chart1);
  mChart.setUsePercentValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setExtraOffsets(5,10,5,5);
  mChart.setDragDecelerationFrictionCoef(0.95f);
  mChart.setCenterTextTypeface(mTfLight);
  mChart.setCenterText(generateCenterSpannableText());
  mChart.setDrawHoleEnabled(true);
  mChart.setHoleColor(Color.WHITE);
  mChart.setTransparentCircleColor(Color.WHITE);
  mChart.setTransparentCircleAlpha(110);
  mChart.setHoleRadius(58f);
  mChart.setTransparentCircleRadius(61f);
  mChart.setDrawCenterText(true);
  mChart.setRotationAngle(0);
  mChart.setRotationEnabled(true);
  mChart.setHighlightPerTapEnabled(true);
  mChart.setOnChartValueSelectedListener(this);
  setData(4,100);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuad);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(0f);
  l.setYOffset(0f);
  mChart.setEntryLabelColor(Color.WHITE);
  mChart.setEntryLabelTypeface(mTfRegular);
  mChart.setEntryLabelTextSize(12f);
}",0.93595166163142
26270,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setTouchEnabled(true);
  mChart.setMaxHighlightDistance(50f);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(mTfLight);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(mTfLight);
  yl.setAxisMinValue(0f);
  mChart.getAxisRight().setEnabled(false);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(mTfLight);
  xl.setDrawGridLines(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setTouchEnabled(true);
  mChart.setMaxHighlightDistance(50f);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(mTfLight);
  l.setXOffset(5f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(mTfLight);
  yl.setAxisMinValue(0f);
  mChart.getAxisRight().setEnabled(false);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(mTfLight);
  xl.setDrawGridLines(false);
}",0.9924012158054712
26271,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseY=mAnimator.getPhaseY();
  float[] circlesBuffer=mCirclesBuffer;
  circlesBuffer[0]=0;
  circlesBuffer[1]=0;
  List<ILineDataSet> dataSets=mChart.getLineData().getDataSets();
  final int dataSetCount=dataSets.size();
  for (int i=0; i < dataSetCount; i++) {
    ILineDataSet dataSet=dataSets.get(i);
    DataSetImageCache imageCache;
    if (mImageCaches.containsKey(dataSet)) {
      imageCache=mImageCaches.get(dataSet);
    }
 else {
      imageCache=new DataSetImageCache();
      mImageCaches.put(dataSet,imageCache);
    }
    imageCache.ensureCircleCache(dataSet.getCircleColorCount());
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled() || dataSet.getEntryCount() == 0)     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    if (mXBoundsBuffer == null) {
      mXBoundsBuffer=getXBounds(mChart,dataSet);
    }
 else {
      mXBoundsBuffer.set(mChart,dataSet);
    }
    XBounds bounds=mXBoundsBuffer;
    float circleRadius=dataSet.getCircleRadius();
    float circleHoleRadius=dataSet.getCircleHoleRadius();
    boolean drawCircleHole=dataSet.isDrawCircleHoleEnabled() && circleHoleRadius < circleRadius && circleHoleRadius > 0.f;
    boolean drawTransparentCircleHole=drawCircleHole && dataSet.getCircleHoleColor() == ColorTemplate.COLOR_NONE;
    int boundsRangeCount=bounds.range + bounds.min;
    for (int j=bounds.min; j <= boundsRangeCount; j++) {
      Entry e=dataSet.getEntryForIndex(j);
      if (e == null)       break;
      circlesBuffer[0]=e.getX();
      circlesBuffer[1]=e.getY() * phaseY;
      trans.pointValuesToPixel(circlesBuffer);
      if (!mViewPortHandler.isInBoundsRight(circlesBuffer[0]))       break;
      if (!mViewPortHandler.isInBoundsLeft(circlesBuffer[0]) || !mViewPortHandler.isInBoundsY(circlesBuffer[1]))       continue;
      final int circleColor=dataSet.getCircleColor(j);
      mRenderPaint.setColor(circleColor);
      Bitmap circleBitmap=null;
      final int dataSetColorCount=imageCache.circleColors.length;
      int colorIndex;
      for (colorIndex=0; colorIndex < dataSetColorCount; colorIndex++) {
        int tempColor=imageCache.circleColors[colorIndex];
        Bitmap tempBitmap=imageCache.circleBitmaps[colorIndex];
        if (tempColor == circleColor) {
          circleBitmap=tempBitmap;
          break;
        }
 else         if (tempBitmap == null) {
          break;
        }
      }
      if (circleBitmap == null) {
        Bitmap.Config conf=Bitmap.Config.ARGB_8888;
        circleBitmap=Bitmap.createBitmap((int)circleRadius * 2,(int)circleRadius * 2,conf);
        Canvas canvas=new Canvas(circleBitmap);
        imageCache.circleBitmaps[colorIndex]=circleBitmap;
        imageCache.circleColors[colorIndex]=circleColor;
        if (drawTransparentCircleHole) {
          mCirclePathBuffer.reset();
          mCirclePathBuffer.addCircle(circleRadius,circleRadius,circleRadius,Path.Direction.CW);
          mCirclePathBuffer.addCircle(circleHoleRadius,circleHoleRadius,circleHoleRadius,Path.Direction.CCW);
          canvas.drawPath(mCirclePathBuffer,mRenderPaint);
        }
 else {
          canvas.drawCircle(circleRadius,circleRadius,circleRadius,mRenderPaint);
          if (drawCircleHole) {
            canvas.drawCircle(circleRadius,circleRadius,circleHoleRadius,mCirclePaintInner);
          }
        }
      }
      if (circleBitmap != null) {
        c.drawBitmap(circleBitmap,circlesBuffer[0] - circleRadius,circlesBuffer[1] - circleRadius,mRenderPaint);
      }
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseY=mAnimator.getPhaseY();
  float[] circlesBuffer=mCirclesBuffer;
  circlesBuffer[0]=0;
  circlesBuffer[1]=0;
  List<ILineDataSet> dataSets=mChart.getLineData().getDataSets();
  final int dataSetCount=dataSets.size();
  for (int i=0; i < dataSetCount; i++) {
    ILineDataSet dataSet=dataSets.get(i);
    DataSetImageCache imageCache;
    if (mImageCaches.containsKey(dataSet)) {
      imageCache=mImageCaches.get(dataSet);
    }
 else {
      imageCache=new DataSetImageCache();
      mImageCaches.put(dataSet,imageCache);
    }
    imageCache.ensureCircleCache(dataSet.getCircleColorCount());
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled() || dataSet.getEntryCount() == 0)     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    if (mXBoundsBuffer == null) {
      mXBoundsBuffer=getXBounds(mChart,dataSet);
    }
 else {
      mXBoundsBuffer.set(mChart,dataSet);
    }
    XBounds bounds=mXBoundsBuffer;
    float circleRadius=dataSet.getCircleRadius();
    float circleHoleRadius=dataSet.getCircleHoleRadius();
    boolean drawCircleHole=dataSet.isDrawCircleHoleEnabled() && circleHoleRadius < circleRadius && circleHoleRadius > 0.f;
    boolean drawTransparentCircleHole=drawCircleHole && dataSet.getCircleHoleColor() == ColorTemplate.COLOR_NONE;
    int boundsRangeCount=bounds.range + bounds.min;
    for (int j=bounds.min; j <= boundsRangeCount; j++) {
      Entry e=dataSet.getEntryForIndex(j);
      if (e == null)       break;
      circlesBuffer[0]=e.getX();
      circlesBuffer[1]=e.getY() * phaseY;
      trans.pointValuesToPixel(circlesBuffer);
      if (!mViewPortHandler.isInBoundsRight(circlesBuffer[0]))       break;
      if (!mViewPortHandler.isInBoundsLeft(circlesBuffer[0]) || !mViewPortHandler.isInBoundsY(circlesBuffer[1]))       continue;
      final int circleColor=dataSet.getCircleColor(j);
      mRenderPaint.setColor(circleColor);
      Bitmap circleBitmap=null;
      final int dataSetColorCount=imageCache.circleColors.length;
      int colorIndex;
      for (colorIndex=0; colorIndex < dataSetColorCount; colorIndex++) {
        int tempColor=imageCache.circleColors[colorIndex];
        Bitmap tempBitmap=imageCache.circleBitmaps[colorIndex];
        if (tempColor == circleColor) {
          circleBitmap=tempBitmap;
          break;
        }
 else         if (tempBitmap == null) {
          break;
        }
      }
      if (circleBitmap == null) {
        Bitmap.Config conf=Bitmap.Config.ARGB_8888;
        circleBitmap=Bitmap.createBitmap((int)(circleRadius * 2.1),(int)(circleRadius * 2.1),conf);
        Canvas canvas=new Canvas(circleBitmap);
        imageCache.circleBitmaps[colorIndex]=circleBitmap;
        imageCache.circleColors[colorIndex]=circleColor;
        if (drawTransparentCircleHole) {
          mCirclePathBuffer.reset();
          mCirclePathBuffer.addCircle(circleRadius,circleRadius,circleRadius,Path.Direction.CW);
          mCirclePathBuffer.addCircle(circleRadius,circleRadius,circleHoleRadius,Path.Direction.CCW);
          canvas.drawPath(mCirclePathBuffer,mRenderPaint);
        }
 else {
          canvas.drawCircle(circleRadius,circleRadius,circleRadius,mRenderPaint);
          if (drawCircleHole) {
            canvas.drawCircle(circleRadius,circleRadius,circleHoleRadius,mCirclePaintInner);
          }
        }
      }
      if (circleBitmap != null) {
        c.drawBitmap(circleBitmap,circlesBuffer[0] - circleRadius,circlesBuffer[1] - circleRadius,mRenderPaint);
      }
    }
  }
}",0.9978201634877384
26272,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param high         - the highlight object
 * @param callListener - call the listener
 */
public void highlightValue(Highlight high,boolean callListener){
  Entry e=null;
  if (high == null)   mIndicesToHighlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    e=mData.getEntryForHighlight(high);
    if (e == null) {
      mIndicesToHighlight=null;
      high=null;
    }
 else {
      mIndicesToHighlight=new Highlight[]{high};
    }
  }
  if (callListener && mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      mSelectionListener.onValueSelected(e,high);
    }
  }
  invalidate();
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param high         - the highlight object
 * @param callListener - call the listener
 */
public void highlightValue(Highlight high,boolean callListener){
  Entry e=null;
  if (high == null)   mIndicesToHighlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    e=mData.getEntryForHighlight(high);
    if (e == null) {
      mIndicesToHighlight=null;
      high=null;
    }
 else {
      mIndicesToHighlight=new Highlight[]{high};
    }
  }
  setLastHighlighted(mIndicesToHighlight);
  if (callListener && mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      mSelectionListener.onValueSelected(e,high);
    }
  }
  invalidate();
}",0.9753015508328546
26273,"/** 
 * Highlights the values at the given indices in the given DataSets. Provide null or an empty array to undo all highlighting. This should be used to programmatically highlight values. This DOES NOT generate a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightValues(Highlight[] highs){
  mIndicesToHighlight=highs;
  if (highs == null || highs.length <= 0 || highs[0] == null) {
    mChartTouchListener.setLastHighlighted(null);
  }
 else {
    mChartTouchListener.setLastHighlighted(highs[0]);
  }
  invalidate();
}","/** 
 * Highlights the values at the given indices in the given DataSets. Provide null or an empty array to undo all highlighting. This should be used to programmatically highlight values. This DOES NOT generate a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightValues(Highlight[] highs){
  mIndicesToHighlight=highs;
  setLastHighlighted(highs);
  invalidate();
}",0.8012486992715921
26274,"/** 
 * Performs all necessary operations needed for dragging.
 * @param event
 */
private void performDrag(MotionEvent event){
  mLastGesture=ChartGesture.DRAG;
  mMatrix.set(mSavedMatrix);
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  float dX, dY;
  if (mChart.isAnyAxisInverted() && mClosestDataSetToTouch != null && mChart.getAxis(mClosestDataSetToTouch.getAxisDependency()).isInverted()) {
    if (mChart instanceof HorizontalBarChart) {
      dX=-(event.getX() - mTouchStartPoint.x);
      dY=event.getY() - mTouchStartPoint.y;
    }
 else {
      dX=event.getX() - mTouchStartPoint.x;
      dY=-(event.getY() - mTouchStartPoint.y);
    }
  }
 else {
    dX=event.getX() - mTouchStartPoint.x;
    dY=event.getY() - mTouchStartPoint.y;
  }
  mMatrix.postTranslate(dX,dY);
  if (l != null)   l.onChartTranslate(event,dX,dY);
}","/** 
 * Performs all necessary operations needed for dragging.
 * @param event
 */
private void performDrag(MotionEvent event){
  mLastGesture=ChartGesture.DRAG;
  mMatrix.set(mSavedMatrix);
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  float dX, dY;
  if (inverted()) {
    if (mChart instanceof HorizontalBarChart) {
      dX=-(event.getX() - mTouchStartPoint.x);
      dY=event.getY() - mTouchStartPoint.y;
    }
 else {
      dX=event.getX() - mTouchStartPoint.x;
      dY=-(event.getY() - mTouchStartPoint.y);
    }
  }
 else {
    dX=event.getX() - mTouchStartPoint.x;
    dY=event.getY() - mTouchStartPoint.y;
  }
  mMatrix.postTranslate(dX,dY);
  if (l != null)   l.onChartTranslate(event,dX,dY);
}",0.3657142857142857
26275,"/** 
 * returns the correct translation depending on the provided x and y touch points
 * @param x
 * @param y
 * @return
 */
public PointF getTrans(float x,float y){
  ViewPortHandler vph=mChart.getViewPortHandler();
  float xTrans=x - vph.offsetLeft();
  float yTrans=0f;
  if (mChart.isAnyAxisInverted() && mClosestDataSetToTouch != null && mChart.isInverted(mClosestDataSetToTouch.getAxisDependency())) {
    yTrans=-(y - vph.offsetTop());
  }
 else {
    yTrans=-(mChart.getMeasuredHeight() - y - vph.offsetBottom());
  }
  return new PointF(xTrans,yTrans);
}","/** 
 * returns the correct translation depending on the provided x and y touch points
 * @param x
 * @param y
 * @return
 */
public PointF getTrans(float x,float y){
  ViewPortHandler vph=mChart.getViewPortHandler();
  float xTrans=x - vph.offsetLeft();
  float yTrans=0f;
  if (inverted()) {
    yTrans=-(y - vph.offsetTop());
  }
 else {
    yTrans=-(mChart.getMeasuredHeight() - y - vph.offsetBottom());
  }
  return new PointF(xTrans,yTrans);
}",0.5903257650542941
26276,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(mTfLight);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(false);
  xl.setGridLineWidth(0.3f);
  xl.setGranularity(10f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(mTfLight);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setAxisMinValue(0f);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(mTfLight);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  yr.setAxisMinValue(0f);
  setData(12,50);
  mChart.setFitBars(true);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(mTfLight);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(false);
  xl.setGranularity(10f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(mTfLight);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setAxisMinValue(0f);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(mTfLight);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  yr.setAxisMinValue(0f);
  setData(12,50);
  mChart.setFitBars(true);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9910077519379844
26277,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartGestureListener(this);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  LimitLine llXAxis=new LimitLine(10f,""String_Node_Str"");
  llXAxis.setLineWidth(4f);
  llXAxis.enableDashedLine(10f,10f,0f);
  llXAxis.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
  llXAxis.setTextSize(10f);
  XAxis xAxis=mChart.getXAxis();
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.RIGHT_TOP);
  ll1.setTextSize(10f);
  ll1.setTypeface(tf);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
  ll2.setTextSize(10f);
  ll2.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.enableGridDashedLine(10f,10f,0f);
  leftAxis.setDrawZeroLine(false);
  leftAxis.setDrawLimitLinesBehindData(true);
  mChart.getAxisRight().setEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartGestureListener(this);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  LimitLine llXAxis=new LimitLine(10f,""String_Node_Str"");
  llXAxis.setLineWidth(4f);
  llXAxis.enableDashedLine(10f,10f,0f);
  llXAxis.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
  llXAxis.setTextSize(10f);
  XAxis xAxis=mChart.getXAxis();
  xAxis.enableGridDashedLine(10f,10f,0f);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.RIGHT_TOP);
  ll1.setTextSize(10f);
  ll1.setTypeface(tf);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.RIGHT_BOTTOM);
  ll2.setTextSize(10f);
  ll2.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.enableGridDashedLine(10f,10f,0f);
  leftAxis.setDrawZeroLine(false);
  leftAxis.setDrawLimitLinesBehindData(true);
  mChart.getAxisRight().setEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}",0.9910333048676344
26278,"/** 
 * Set this to true to make the highlight operation full-bar oriented, false to make it highlight single values (relevant only for stacked). Default: false
 * @param enabled
 */
public void setHighlightFullBarEnabled(boolean enabled){
  mHighlightFullBarEnabled=enabled;
}","/** 
 * Set this to true to make the highlight operation full-bar oriented, false to make it highlight single values (relevant only for stacked). If enabled, highlighting operations will highlight the whole bar, even if only a single stack entry was tapped. Default: false
 * @param enabled
 */
public void setHighlightFullBarEnabled(boolean enabled){
  mHighlightFullBarEnabled=enabled;
}",0.8318318318318318
26279,"/** 
 * Highlights the value at the given x-position in the given DataSet. Provide -1 as the dataSetIndex to undo all highlighting.
 * @param x
 * @param dataSetIndex
 * @param stackIndex the index inside the stack - only relevant for stacked entries
 */
public void highlightValue(float x,int dataSetIndex,int stackIndex){
  highlightValue(new Highlight(x,dataSetIndex,stackIndex),false);
}","/** 
 * Highlights the value at the given x-position in the given DataSet. Provide -1 as the dataSetIndex to undo all highlighting.
 * @param x
 * @param dataSetIndex
 * @param stackIndex   the index inside the stack - only relevant for stacked entries
 */
public void highlightValue(float x,int dataSetIndex,int stackIndex){
  highlightValue(new Highlight(x,dataSetIndex,stackIndex),false);
}",0.9974489795918368
26280,"@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] positions=new float[mXAxis.mEntryCount * 2];
  for (int i=0; i < positions.length; i+=2) {
    positions[i]=mXAxis.mEntries[i / 2];
  }
  mTrans.pointValuesToPixel(positions);
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  mGridPaint.setPathEffect(mXAxis.getGridDashPathEffect());
  Path gridLinePath=new Path();
  for (int i=0; i < positions.length; i+=2) {
    float x=positions[i];
    if (x >= mViewPortHandler.offsetLeft() && x <= mViewPortHandler.getChartWidth()) {
      gridLinePath.moveTo(x,mViewPortHandler.contentBottom());
      gridLinePath.lineTo(x,mViewPortHandler.contentTop());
      c.drawPath(gridLinePath,mGridPaint);
    }
    gridLinePath.reset();
  }
}","@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] positions=new float[mXAxis.mEntryCount * 2];
  for (int i=0; i < positions.length; i+=2) {
    positions[i]=mXAxis.mEntries[i / 2];
    positions[i + 1]=mXAxis.mEntries[i / 2];
  }
  mTrans.pointValuesToPixel(positions);
  setupGridPaint();
  Path gridLinePath=new Path();
  for (int i=0; i < positions.length; i+=2) {
    drawGridLine(c,positions[i],positions[i + 1],gridLinePath);
  }
}",0.4147398843930636
26281,"/** 
 * Enabled/disable granularity control on axis value intervals. If enabled, the axis interval is not allowed to go below a certain granularity. Default: false
 * @param enabled
 */
public void setGranularityEnabled(boolean enabled){
  mGranularityEnabled=true;
}","/** 
 * Enabled/disable granularity control on axis value intervals. If enabled, the axis interval is not allowed to go below a certain granularity. Default: false
 * @param enabled
 */
public void setGranularityEnabled(boolean enabled){
  mGranularityEnabled=enabled;
}",0.9795158286778398
26282,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BUBBLECHART.
 * @param data
 * @return
 */
public float[] generateTransformedValuesBubble(IBubbleDataSet data,float phaseY,int from,int to){
  final int count=(int)Math.ceil(to - from) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    Entry e=data.getEntryForIndex(j / 2 + from);
    if (e != null) {
      valuePoints[j]=e.getX();
      valuePoints[j + 1]=e.getY() * phaseY;
    }
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BUBBLECHART.
 * @param data
 * @return
 */
public float[] generateTransformedValuesBubble(IBubbleDataSet data,float phaseY,int from,int to){
  final int count=(to - from + 1) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    Entry e=data.getEntryForIndex(j / 2 + from);
    if (e != null) {
      valuePoints[j]=e.getX();
      valuePoints[j + 1]=e.getY() * phaseY;
    }
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}",0.9852700490998364
26283,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the CANDLESTICKCHART.
 * @param data
 * @return
 */
public float[] generateTransformedValuesCandle(ICandleDataSet data,float phaseX,float phaseY,int from,int to){
  final int count=(int)Math.ceil((to - from) * phaseX) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    CandleEntry e=data.getEntryForIndex(j / 2 + from);
    if (e != null) {
      valuePoints[j]=e.getX();
      valuePoints[j + 1]=e.getHigh() * phaseY;
    }
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the CANDLESTICKCHART.
 * @param data
 * @return
 */
public float[] generateTransformedValuesCandle(ICandleDataSet data,float phaseX,float phaseY,int from,int to){
  final int count=(int)((to - from) * phaseX + 1) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    CandleEntry e=data.getEntryForIndex(j / 2 + from);
    if (e != null) {
      valuePoints[j]=e.getX();
      valuePoints[j + 1]=e.getHigh() * phaseY;
    }
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}",0.990023023791251
26284,"/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      IDataSet dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof IBarDataSet && ((IBarDataSet)dataSet).isStacked()) {
        IBarDataSet bds=(IBarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof IPieDataSet) {
        IPieDataSet pds=(IPieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          labels.add(pds.getEntryForIndex(j).getLabel());
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else       if (dataSet instanceof ICandleDataSet && ((ICandleDataSet)dataSet).getDecreasingColor() != ColorTemplate.COLOR_NONE) {
        colors.add(((ICandleDataSet)dataSet).getDecreasingColor());
        colors.add(((ICandleDataSet)dataSet).getIncreasingColor());
        labels.add(null);
        labels.add(dataSet.getLabel());
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}","/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      IDataSet dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof IBarDataSet && ((IBarDataSet)dataSet).isStacked()) {
        IBarDataSet bds=(IBarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof IPieDataSet) {
        IPieDataSet pds=(IPieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          labels.add(pds.getEntryForIndex(j).getLabel());
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else       if (dataSet instanceof ICandleDataSet && ((ICandleDataSet)dataSet).getDecreasingColor() != ColorTemplate.COLOR_NONE) {
        int decreasingColor=((ICandleDataSet)dataSet).getDecreasingColor();
        colors.add(decreasingColor);
        int increasingColor=((ICandleDataSet)dataSet).getIncreasingColor();
        colors.add(increasingColor);
        labels.add(null);
        labels.add(dataSet.getLabel());
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}",0.9708302169035152
26285,"protected void prepareBarHighlight(float x,float y1,float y2,float barWidthHalf,Transformer trans){
  float left=x - barWidthHalf;
  float right=x + barWidthHalf;
  float top=y1;
  float bottom=y2;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","protected void prepareBarHighlight(float x,float y1,float y2,float barWidthHalf,Transformer trans){
  float left=x - barWidthHalf;
  float right=x + barWidthHalf;
  float top=y1;
  float bottom=y2;
  mBarRect.set(left,top,right,bottom);
  trans.rectToPixelPhase(mBarRect,mAnimator.getPhaseY());
}",0.983108108108108
26286,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BarData barData=mChart.getBarData();
  for (  Highlight high : indices) {
    final int minDataSetIndex=high.getDataSetIndex() == -1 ? 0 : high.getDataSetIndex();
    final int maxDataSetIndex=high.getDataSetIndex() == -1 ? barData.getDataSetCount() : (high.getDataSetIndex() + 1);
    if (maxDataSetIndex - minDataSetIndex < 1)     continue;
    for (int dataSetIndex=minDataSetIndex; dataSetIndex < maxDataSetIndex; dataSetIndex++) {
      IBarDataSet set=barData.getDataSetByIndex(dataSetIndex);
      if (set == null || !set.isHighlightEnabled())       continue;
      Transformer trans=mChart.getTransformer(set.getAxisDependency());
      mHighlightPaint.setColor(set.getHighLightColor());
      mHighlightPaint.setAlpha(set.getHighLightAlpha());
      float x=high.getX();
      BarEntry e=set.getEntryForXPos(x);
      if (e == null)       continue;
      boolean isStack=high.getStackIndex() < 0 ? false : true;
      final float y1;
      final float y2;
      if (isStack) {
        y1=high.getRange().from;
        y2=high.getRange().to;
      }
 else {
        y1=e.getY();
        y2=0.f;
      }
      prepareBarHighlight(e.getX(),y1,y2,barData.getBarWidth() / 2f,trans);
      c.drawRect(mBarRect,mHighlightPaint);
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BarData barData=mChart.getBarData();
  for (  Highlight high : indices) {
    final int minDataSetIndex=high.getDataSetIndex() == -1 ? 0 : high.getDataSetIndex();
    final int maxDataSetIndex=high.getDataSetIndex() == -1 ? barData.getDataSetCount() : (high.getDataSetIndex() + 1);
    if (maxDataSetIndex - minDataSetIndex < 1)     continue;
    for (int dataSetIndex=minDataSetIndex; dataSetIndex < maxDataSetIndex; dataSetIndex++) {
      IBarDataSet set=barData.getDataSetByIndex(dataSetIndex);
      if (set == null || !set.isHighlightEnabled())       continue;
      Transformer trans=mChart.getTransformer(set.getAxisDependency());
      mHighlightPaint.setColor(set.getHighLightColor());
      mHighlightPaint.setAlpha(set.getHighLightAlpha());
      float x=high.getX();
      BarEntry e=set.getEntryForXPos(x);
      float entryIndex=set.getEntryIndex(e);
      if (e == null || entryIndex > set.getEntryCount() * mAnimator.getPhaseX())       continue;
      boolean isStack=high.getStackIndex() < 0 ? false : true;
      final float y1;
      final float y2;
      if (isStack) {
        y1=high.getRange().from;
        y2=high.getRange().to;
      }
 else {
        y1=e.getY();
        y2=0.f;
      }
      prepareBarHighlight(e.getX(),y1,y2,barData.getBarWidth() / 2f,trans);
      c.drawRect(mBarRect,mHighlightPaint);
    }
  }
}",0.9615525448553645
26287,"@Override protected void prepareBarHighlight(float x,float y1,float y2,float barWidthHalf,Transformer trans){
  float top=x - barWidthHalf;
  float bottom=x + barWidthHalf;
  float left=y1;
  float right=y2;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","@Override protected void prepareBarHighlight(float x,float y1,float y2,float barWidthHalf,Transformer trans){
  float top=x - barWidthHalf;
  float bottom=x + barWidthHalf;
  float left=y1;
  float right=y2;
  mBarRect.set(left,top,right,bottom);
  trans.rectToPixelPhaseHorizontal(mBarRect,mAnimator.getPhaseY());
}",0.9678456591639872
26288,"/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixel(RectF r,float phaseY){
  r.top*=phaseY;
  r.bottom*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}","/** 
 * Transform a rectangle with all matrices.
 * @param r
 */
public void rectValueToPixel(RectF r){
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}",0.8107074569789675
26289,"/** 
 * Constructor for bubbles.
 * @param xValue
 * @param yValue
 * @param bubbleSize
 */
public RealmDemoData(float xValue,float yValue,float bubbleSize){
  this.xValue=xValue;
  this.yValue=yValue;
  this.bubbleSize=bubbleSize;
}","/** 
 * Constructor for pie chart.
 * @param yValue
 * @param label
 */
public RealmDemoData(float yValue,String label){
  this.yValue=yValue;
  this.label=label;
}",0.7002518891687658
26290,"protected void writeToDBPie(){
  mRealm.beginTransaction();
  mRealm.clear(RealmDemoData.class);
  float value1=15f + (float)(Math.random() * 8f);
  float value2=15f + (float)(Math.random() * 8f);
  float value3=15f + (float)(Math.random() * 8f);
  float value4=15f + (float)(Math.random() * 8f);
  float value5=100f - value1 - value2- value3- value4;
  float[] values=new float[]{value1,value2,value3,value4,value5};
  String[] xValues=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < values.length; i++) {
    RealmDemoData d=new RealmDemoData(i,values[i]);
    mRealm.copyToRealm(d);
  }
  mRealm.commitTransaction();
}","protected void writeToDBPie(){
  mRealm.beginTransaction();
  mRealm.clear(RealmDemoData.class);
  float value1=15f + (float)(Math.random() * 8f);
  float value2=15f + (float)(Math.random() * 8f);
  float value3=15f + (float)(Math.random() * 8f);
  float value4=15f + (float)(Math.random() * 8f);
  float value5=100f - value1 - value2- value3- value4;
  float[] values=new float[]{value1,value2,value3,value4,value5};
  String[] labels=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < values.length; i++) {
    RealmDemoData d=new RealmDemoData(values[i],labels[i]);
    mRealm.copyToRealm(d);
  }
  mRealm.commitTransaction();
}",0.97647897362794
26291,"private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmPieDataSet<RealmDemoData> set=new RealmPieDataSet<RealmDemoData>(result,""String_Node_Str"");
  set.setColors(ColorTemplate.VORDIPLOM_COLORS);
  set.setLabel(""String_Node_Str"");
  set.setSliceSpace(2);
  PieData data=new PieData(set);
  styleData(data);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(12f);
  mChart.setData(data);
  mChart.animateY(1400);
}","private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmPieDataSet<RealmDemoData> set=new RealmPieDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"");
  set.setColors(ColorTemplate.VORDIPLOM_COLORS);
  set.setLabel(""String_Node_Str"");
  set.setSliceSpace(2);
  PieData data=new PieData(set);
  styleData(data);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(12f);
  mChart.setData(data);
  mChart.animateY(1400);
}",0.9815573770491804
26292,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart_noseekbar);
  mChart=(RadarChart)findViewById(R.id.chart1);
  setup(mChart);
  mChart.getYAxis().setEnabled(false);
  mChart.setWebAlpha(180);
  mChart.setWebColorInner(Color.DKGRAY);
  mChart.setWebColor(Color.GRAY);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart_noseekbar);
  mChart=(RadarChart)findViewById(R.id.chart1);
  setup(mChart);
  mChart.getYAxis().setEnabled(false);
  mChart.getXAxis().setEnabled(false);
  mChart.setWebAlpha(180);
  mChart.setWebColorInner(Color.DKGRAY);
  mChart.setWebColor(Color.GRAY);
}",0.9606458123107972
26293,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_realm_wiki);
  lineChart=(LineChart)findViewById(R.id.lineChart);
  barChart=(BarChart)findViewById(R.id.barChart);
  setup(lineChart);
  setup(barChart);
  lineChart.setExtraBottomOffset(5f);
  barChart.setExtraBottomOffset(5f);
  lineChart.getAxisLeft().setDrawGridLines(false);
  lineChart.getXAxis().setDrawGridLines(false);
  barChart.getAxisLeft().setDrawGridLines(false);
  barChart.getXAxis().setDrawGridLines(false);
  barChart.getXAxis().setCenterAxisLabels(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_realm_wiki);
  lineChart=(LineChart)findViewById(R.id.lineChart);
  barChart=(BarChart)findViewById(R.id.barChart);
  setup(lineChart);
  setup(barChart);
  lineChart.setExtraBottomOffset(5f);
  barChart.setExtraBottomOffset(5f);
  lineChart.getAxisLeft().setDrawGridLines(false);
  lineChart.getXAxis().setDrawGridLines(false);
  lineChart.getXAxis().setLabelCount(5);
  lineChart.getXAxis().setGranularity(1f);
  barChart.getAxisLeft().setDrawGridLines(false);
  barChart.getXAxis().setDrawGridLines(false);
  barChart.getXAxis().setLabelCount(5);
  barChart.getXAxis().setGranularity(1f);
}",0.8981422165278667
26294,"private void setData(){
  final RealmResults<Score> results=mRealm.allObjects(Score.class);
  AxisValueFormatter formatter=new AxisValueFormatter(){
    @Override public String getFormattedValue(    float value,    AxisBase axis){
      return results.get((int)value).getPlayerName();
    }
    @Override public int getDecimalDigits(){
      return 0;
    }
  }
;
  lineChart.getXAxis().setValueFormatter(formatter);
  barChart.getXAxis().setValueFormatter(formatter);
  RealmLineDataSet<Score> lineDataSet=new RealmLineDataSet<Score>(results,""String_Node_Str"",""String_Node_Str"");
  lineDataSet.setDrawCubic(false);
  lineDataSet.setLabel(""String_Node_Str"");
  lineDataSet.setDrawCircleHole(false);
  lineDataSet.setColor(ColorTemplate.rgb(""String_Node_Str""));
  lineDataSet.setCircleColor(ColorTemplate.rgb(""String_Node_Str""));
  lineDataSet.setLineWidth(1.8f);
  lineDataSet.setCircleSize(3.6f);
  ArrayList<ILineDataSet> dataSets=new ArrayList<ILineDataSet>();
  dataSets.add(lineDataSet);
  LineData lineData=new LineData(dataSets);
  styleData(lineData);
  lineChart.setData(lineData);
  lineChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
  RealmBarDataSet<Score> barDataSet=new RealmBarDataSet<Score>(results,""String_Node_Str"",""String_Node_Str"");
  barDataSet.setColors(new int[]{ColorTemplate.rgb(""String_Node_Str""),ColorTemplate.rgb(""String_Node_Str"")});
  barDataSet.setLabel(""String_Node_Str"");
  ArrayList<IBarDataSet> barDataSets=new ArrayList<IBarDataSet>();
  barDataSets.add(barDataSet);
  BarData barData=new BarData(barDataSets);
  styleData(barData);
  barChart.setData(barData);
  barChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}","private void setData(){
  final RealmResults<Score> results=mRealm.allObjects(Score.class);
  AxisValueFormatter formatter=new AxisValueFormatter(){
    @Override public String getFormattedValue(    float value,    AxisBase axis){
      return results.get((int)value).getPlayerName();
    }
    @Override public int getDecimalDigits(){
      return 0;
    }
  }
;
  lineChart.getXAxis().setValueFormatter(formatter);
  barChart.getXAxis().setValueFormatter(formatter);
  RealmLineDataSet<Score> lineDataSet=new RealmLineDataSet<Score>(results,""String_Node_Str"",""String_Node_Str"");
  lineDataSet.setDrawCubic(false);
  lineDataSet.setLabel(""String_Node_Str"");
  lineDataSet.setDrawCircleHole(false);
  lineDataSet.setColor(ColorTemplate.rgb(""String_Node_Str""));
  lineDataSet.setCircleColor(ColorTemplate.rgb(""String_Node_Str""));
  lineDataSet.setLineWidth(1.8f);
  lineDataSet.setCircleSize(3.6f);
  ArrayList<ILineDataSet> dataSets=new ArrayList<ILineDataSet>();
  dataSets.add(lineDataSet);
  LineData lineData=new LineData(dataSets);
  styleData(lineData);
  lineChart.setData(lineData);
  lineChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
  RealmBarDataSet<Score> barDataSet=new RealmBarDataSet<Score>(results,""String_Node_Str"",""String_Node_Str"");
  barDataSet.setColors(new int[]{ColorTemplate.rgb(""String_Node_Str""),ColorTemplate.rgb(""String_Node_Str"")});
  barDataSet.setLabel(""String_Node_Str"");
  ArrayList<IBarDataSet> barDataSets=new ArrayList<IBarDataSet>();
  barDataSets.add(barDataSet);
  BarData barData=new BarData(barDataSets);
  styleData(barData);
  barChart.setData(barData);
  barChart.setFitBars(true);
  barChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}",0.9913972115099378
26295,"/** 
 * Constructor that takes the realm RealmResults, sorts & stores them.
 * @param results
 * @param yValuesField
 * @param xIndexField
 */
public RealmLineScatterCandleRadarDataSet(RealmResults<T> results,String yValuesField,String xIndexField){
  super(results,yValuesField,xIndexField);
}","/** 
 * Constructor that takes the realm RealmResults, sorts & stores them.
 * @param results
 * @param xValueField
 * @param yValuesField
 */
public RealmLineScatterCandleRadarDataSet(RealmResults<T> results,String xValueField,String yValuesField){
  super(results,xValueField,yValuesField);
}",0.8197278911564626
26296,"/** 
 * Constructor for creating a LineDataSet with realm data.
 * @param result      the queried results from the realm database
 * @param highField   the name of the field in your data object that represents the ""high"" yValue
 * @param lowField    the name of the field in your data object that represents the ""low"" yValue
 * @param openField   the name of the field in your data object that represents the ""open"" yValue
 * @param closeField  the name of the field in your data object that represents the ""close"" yValue
 * @param xIndexField the name of the field in your data object that represents the xPx-index
 */
public RealmCandleDataSet(RealmResults<T> result,String highField,String lowField,String openField,String closeField,String xIndexField){
  super(result,null,xIndexField);
  this.mHighField=highField;
  this.mLowField=lowField;
  this.mOpenField=openField;
  this.mCloseField=closeField;
  build(this.results);
  calcMinMax();
}","/** 
 * Constructor for creating a LineDataSet with realm data.
 * @param result      the queried results from the realm database
 * @param xValueField the name of the field in your data object that represents the ""x"" value
 * @param highField   the name of the field in your data object that represents the ""high"" value
 * @param lowField    the name of the field in your data object that represents the ""low"" value
 * @param openField   the name of the field in your data object that represents the ""open"" value
 * @param closeField  the name of the field in your data object that represents the ""close"" value
 */
public RealmCandleDataSet(RealmResults<T> result,String xValueField,String highField,String lowField,String openField,String closeField){
  super(result,xValueField,null);
  this.mHighField=highField;
  this.mLowField=lowField;
  this.mOpenField=openField;
  this.mCloseField=closeField;
  build(this.results);
  calcMinMax();
}",0.8255813953488372
26297,"public CandleEntry buildEntryFromResultObject(T realmObject,int xIndex){
  DynamicRealmObject dynamicObject=new DynamicRealmObject(realmObject);
  return new CandleEntry(mXValuesField == null ? xIndex : dynamicObject.getFloat(mXValuesField),dynamicObject.getFloat(mHighField),dynamicObject.getFloat(mLowField),dynamicObject.getFloat(mOpenField),dynamicObject.getFloat(mCloseField));
}","@Override public CandleEntry buildEntryFromResultObject(T realmObject,float x){
  DynamicRealmObject dynamicObject=new DynamicRealmObject(realmObject);
  return new CandleEntry(mXValuesField == null ? x : dynamicObject.getFloat(mXValuesField),dynamicObject.getFloat(mHighField),dynamicObject.getFloat(mLowField),dynamicObject.getFloat(mOpenField),dynamicObject.getFloat(mCloseField));
}",0.961038961038961
26298,"/** 
 * Constructor for creating a PieDataSet with realm data.
 * @param result       the queried results from the realm database
 * @param yValuesField the name of the field in your data object that represents the yPx-yValue
 */
public RealmPieDataSet(RealmResults<T> result,String yValuesField){
  super(result,yValuesField);
  build(this.results);
  calcMinMax();
}","public RealmPieDataSet(RealmResults<T> result,String yValuesField,String labelField){
  super(result,yValuesField);
  this.mLabelField=labelField;
  build(this.results);
  calcMinMax();
}",0.4972972972972973
26299,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float radius=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final float holeRadiusPercent=mChart.getHoleRadius() / 100.f;
  float labelRadiusOffset=radius / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    labelRadiusOffset=(radius - (radius * holeRadiusPercent)) / 2f;
  }
  final float labelRadius=radius - labelRadiusOffset;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  float yValueSum=data.getYValueSum();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  float angle;
  int xIndex=0;
  c.save();
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    final boolean drawYVals=dataSet.isDrawValuesEnabled();
    if (!drawYVals && !drawXVals)     continue;
    final PieDataSet.ValuePosition xValuePosition=dataSet.getXValuePosition();
    final PieDataSet.ValuePosition yValuePosition=dataSet.getYValuePosition();
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    ValueFormatter formatter=dataSet.getValueFormatter();
    int entryCount=dataSet.getEntryCount();
    mValueLinePaint.setColor(dataSet.getValueLineColor());
    mValueLinePaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getValueLineWidth()));
    float offset=Utils.convertDpToPixel(5.f);
    for (int j=0; j < entryCount; j++) {
      PieEntry entry=dataSet.getEntryForIndex(j);
      if (xIndex == 0)       angle=0.f;
 else       angle=absoluteAngles[xIndex - 1] * phaseX;
      final float sliceAngle=drawAngles[xIndex];
      final float sliceSpace=dataSet.getSliceSpace();
      final float sliceSpaceMiddleAngle=sliceSpace / (Utils.FDEG2RAD * labelRadius);
      final float angleOffset=(sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;
      angle=angle + angleOffset;
      final float transformedAngle=rotationAngle + angle * phaseY;
      float value=mChart.isUsePercentValuesEnabled() ? entry.getY() / yValueSum * 100f : entry.getY();
      final float sliceXBase=(float)Math.cos(transformedAngle * Utils.FDEG2RAD);
      final float sliceYBase=(float)Math.sin(transformedAngle * Utils.FDEG2RAD);
      final boolean drawXOutside=drawXVals && xValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawYOutside=drawYVals && yValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawXInside=drawXVals && xValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      final boolean drawYInside=drawYVals && yValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      if (drawXOutside || drawYOutside) {
        final float valueLineLength1=dataSet.getValueLinePart1Length();
        final float valueLineLength2=dataSet.getValueLinePart2Length();
        final float valueLinePart1OffsetPercentage=dataSet.getValueLinePart1OffsetPercentage() / 100.f;
        float pt2x, pt2y;
        float labelPtx, labelPty;
        float line1Radius;
        if (mChart.isDrawHoleEnabled())         line1Radius=(radius - (radius * holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * holeRadiusPercent);
 else         line1Radius=radius * valueLinePart1OffsetPercentage;
        final float polyline2Width=dataSet.isValueLineVariableLength() ? labelRadius * valueLineLength2 * (float)Math.abs(Math.sin(transformedAngle * Utils.FDEG2RAD)) : labelRadius * valueLineLength2;
        final float pt0x=line1Radius * sliceXBase + center.x;
        final float pt0y=line1Radius * sliceYBase + center.y;
        final float pt1x=labelRadius * (1 + valueLineLength1) * sliceXBase + center.x;
        final float pt1y=labelRadius * (1 + valueLineLength1) * sliceYBase + center.y;
        if (transformedAngle % 360.0 >= 90.0 && transformedAngle % 360.0 <= 270.0) {
          pt2x=pt1x - polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.RIGHT);
          labelPtx=pt2x - offset;
          labelPty=pt2y;
        }
 else {
          pt2x=pt1x + polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.LEFT);
          labelPtx=pt2x + offset;
          labelPty=pt2y;
        }
        if (dataSet.getValueLineColor() != ColorTemplate.COLOR_NONE) {
          c.drawLine(pt0x,pt0y,pt1x,pt1y,mValueLinePaint);
          c.drawLine(pt1x,pt1y,pt2x,pt2y,mValueLinePaint);
        }
        if (drawXOutside && drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount()) {
            c.drawText(entry.getLabel(),labelPtx,labelPty + lineHeight,mValuePaint);
          }
        }
 else         if (drawXOutside) {
          if (j < data.getEntryCount()) {
            mValuePaint.setColor(dataSet.getValueTextColor(j));
            c.drawText(entry.getLabel(),labelPtx,labelPty + lineHeight / 2.f,mValuePaint);
          }
        }
 else         if (drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty + lineHeight / 2.f,dataSet.getValueTextColor(j));
        }
      }
      if (drawXInside || drawYInside) {
        float x=labelRadius * sliceXBase + center.x;
        float y=labelRadius * sliceYBase + center.y;
        mValuePaint.setTextAlign(Align.CENTER);
        if (drawXInside && drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount()) {
            c.drawText(entry.getLabel(),x,y + lineHeight,mValuePaint);
          }
        }
 else         if (drawXInside) {
          if (j < data.getEntryCount()) {
            mValuePaint.setColor(dataSet.getValueTextColor(j));
            c.drawText(entry.getLabel(),x,y + lineHeight / 2f,mValuePaint);
          }
        }
 else         if (drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f,dataSet.getValueTextColor(j));
        }
      }
      xIndex++;
    }
  }
  c.restore();
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float radius=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final float holeRadiusPercent=mChart.getHoleRadius() / 100.f;
  float labelRadiusOffset=radius / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    labelRadiusOffset=(radius - (radius * holeRadiusPercent)) / 2f;
  }
  final float labelRadius=radius - labelRadiusOffset;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  float yValueSum=data.getYValueSum();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  float angle;
  int xIndex=0;
  c.save();
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    final boolean drawYVals=dataSet.isDrawValuesEnabled();
    if (!drawYVals && !drawXVals)     continue;
    final PieDataSet.ValuePosition xValuePosition=dataSet.getXValuePosition();
    final PieDataSet.ValuePosition yValuePosition=dataSet.getYValuePosition();
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    ValueFormatter formatter=dataSet.getValueFormatter();
    int entryCount=dataSet.getEntryCount();
    mValueLinePaint.setColor(dataSet.getValueLineColor());
    mValueLinePaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getValueLineWidth()));
    float offset=Utils.convertDpToPixel(5.f);
    for (int j=0; j < entryCount; j++) {
      PieEntry entry=dataSet.getEntryForIndex(j);
      if (xIndex == 0)       angle=0.f;
 else       angle=absoluteAngles[xIndex - 1] * phaseX;
      final float sliceAngle=drawAngles[xIndex];
      final float sliceSpace=dataSet.getSliceSpace();
      final float sliceSpaceMiddleAngle=sliceSpace / (Utils.FDEG2RAD * labelRadius);
      final float angleOffset=(sliceAngle - sliceSpaceMiddleAngle / 2.f) / 2.f;
      angle=angle + angleOffset;
      final float transformedAngle=rotationAngle + angle * phaseY;
      float value=mChart.isUsePercentValuesEnabled() ? entry.getY() / yValueSum * 100f : entry.getY();
      final float sliceXBase=(float)Math.cos(transformedAngle * Utils.FDEG2RAD);
      final float sliceYBase=(float)Math.sin(transformedAngle * Utils.FDEG2RAD);
      final boolean drawXOutside=drawXVals && xValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawYOutside=drawYVals && yValuePosition == PieDataSet.ValuePosition.OUTSIDE_SLICE;
      final boolean drawXInside=drawXVals && xValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      final boolean drawYInside=drawYVals && yValuePosition == PieDataSet.ValuePosition.INSIDE_SLICE;
      if (drawXOutside || drawYOutside) {
        final float valueLineLength1=dataSet.getValueLinePart1Length();
        final float valueLineLength2=dataSet.getValueLinePart2Length();
        final float valueLinePart1OffsetPercentage=dataSet.getValueLinePart1OffsetPercentage() / 100.f;
        float pt2x, pt2y;
        float labelPtx, labelPty;
        float line1Radius;
        if (mChart.isDrawHoleEnabled())         line1Radius=(radius - (radius * holeRadiusPercent)) * valueLinePart1OffsetPercentage + (radius * holeRadiusPercent);
 else         line1Radius=radius * valueLinePart1OffsetPercentage;
        final float polyline2Width=dataSet.isValueLineVariableLength() ? labelRadius * valueLineLength2 * (float)Math.abs(Math.sin(transformedAngle * Utils.FDEG2RAD)) : labelRadius * valueLineLength2;
        final float pt0x=line1Radius * sliceXBase + center.x;
        final float pt0y=line1Radius * sliceYBase + center.y;
        final float pt1x=labelRadius * (1 + valueLineLength1) * sliceXBase + center.x;
        final float pt1y=labelRadius * (1 + valueLineLength1) * sliceYBase + center.y;
        if (transformedAngle % 360.0 >= 90.0 && transformedAngle % 360.0 <= 270.0) {
          pt2x=pt1x - polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.RIGHT);
          labelPtx=pt2x - offset;
          labelPty=pt2y;
        }
 else {
          pt2x=pt1x + polyline2Width;
          pt2y=pt1y;
          mValuePaint.setTextAlign(Align.LEFT);
          labelPtx=pt2x + offset;
          labelPty=pt2y;
        }
        if (dataSet.getValueLineColor() != ColorTemplate.COLOR_NONE) {
          c.drawLine(pt0x,pt0y,pt1x,pt1y,mValueLinePaint);
          c.drawLine(pt1x,pt1y,pt2x,pt2y,mValueLinePaint);
        }
        if (drawXOutside && drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            c.drawText(entry.getLabel(),labelPtx,labelPty + lineHeight,mValuePaint);
          }
        }
 else         if (drawXOutside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            mValuePaint.setColor(dataSet.getValueTextColor(j));
            c.drawText(entry.getLabel(),labelPtx,labelPty + lineHeight / 2.f,mValuePaint);
          }
        }
 else         if (drawYOutside) {
          drawValue(c,formatter,value,entry,0,labelPtx,labelPty + lineHeight / 2.f,dataSet.getValueTextColor(j));
        }
      }
      if (drawXInside || drawYInside) {
        float x=labelRadius * sliceXBase + center.x;
        float y=labelRadius * sliceYBase + center.y;
        mValuePaint.setTextAlign(Align.CENTER);
        if (drawXInside && drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y,dataSet.getValueTextColor(j));
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            c.drawText(entry.getLabel(),x,y + lineHeight,mValuePaint);
          }
        }
 else         if (drawXInside) {
          if (j < data.getEntryCount() && entry.getLabel() != null) {
            mValuePaint.setColor(dataSet.getValueTextColor(j));
            c.drawText(entry.getLabel(),x,y + lineHeight / 2f,mValuePaint);
          }
        }
 else         if (drawYInside) {
          drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f,dataSet.getValueTextColor(j));
        }
      }
      xIndex++;
    }
  }
  c.restore();
}",0.9910371318822024
26300,"/** 
 * Returns the lowest xPx-index (yValue on the xPx-axis) that is still visible on the chart.
 * @return
 */
@Override public float getLowestVisibleX(){
  PointD pos=getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
  return (float)Math.min(mXAxis.mAxisMinimum,pos.x);
}","/** 
 * Returns the lowest xPx-index (yValue on the xPx-axis) that is still visible on the chart.
 * @return
 */
@Override public float getLowestVisibleX(){
  PointD pos=getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
  return (float)Math.max(mXAxis.mAxisMinimum,pos.x);
}",0.9942528735632185
26301,"@Override public float getLowestVisibleX(){
  PointD pos=getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
  return (float)Math.min(mXAxis.mAxisMinimum,pos.y);
}","@Override public float getLowestVisibleX(){
  PointD pos=getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
  return (float)Math.max(mXAxis.mAxisMinimum,pos.y);
}",0.9914893617021276
26302,"public static List<BarEntry> loadBarEntriesFromAssets(AssetManager am,String path){
  List<BarEntry> entries=new ArrayList<BarEntry>();
  BufferedReader reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(am.open(path),""String_Node_Str""));
    String line=reader.readLine();
    while (line != null) {
      String[] split=line.split(""String_Node_Str"");
      entries.add(new BarEntry(Float.parseFloat(split[1]),Integer.parseInt(split[0])));
      line=reader.readLine();
    }
  }
 catch (  IOException e) {
    Log.e(LOG,e.toString());
  }
 finally {
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      IOException e) {
        Log.e(LOG,e.toString());
      }
    }
  }
  return entries;
}","public static List<BarEntry> loadBarEntriesFromAssets(AssetManager am,String path){
  List<BarEntry> entries=new ArrayList<BarEntry>();
  BufferedReader reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(am.open(path),""String_Node_Str""));
    String line=reader.readLine();
    while (line != null) {
      String[] split=line.split(""String_Node_Str"");
      entries.add(new BarEntry(Float.parseFloat(split[1]),Float.parseFloat(split[0])));
      line=reader.readLine();
    }
  }
 catch (  IOException e) {
    Log.e(LOG,e.toString());
  }
 finally {
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      IOException e) {
        Log.e(LOG,e.toString());
      }
    }
  }
  return entries;
}",0.9798657718120806
26303,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart_noseekbar);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setBackgroundColor(Color.WHITE);
  mChart.setExtraTopOffset(-30f);
  mChart.setExtraBottomOffset(10f);
  mChart.setExtraLeftOffset(70f);
  mChart.setExtraRightOffset(70f);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setTextColor(Color.LTGRAY);
  xAxis.setTextSize(13f);
  YAxis left=mChart.getAxisLeft();
  left.setDrawLabels(false);
  left.setStartAtZero(false);
  left.setSpaceTop(25f);
  left.setSpaceBottom(25f);
  left.setDrawAxisLine(false);
  left.setDrawGridLines(false);
  left.setDrawZeroLine(true);
  left.setZeroLineColor(Color.GRAY);
  left.setZeroLineWidth(0.7f);
  mChart.getAxisRight().setEnabled(false);
  mChart.getLegend().setEnabled(false);
  List<Data> data=new ArrayList<>();
  data.add(new Data(0,-224.1f,""String_Node_Str""));
  data.add(new Data(1,238.5f,""String_Node_Str""));
  data.add(new Data(2,1280.1f,""String_Node_Str""));
  data.add(new Data(3,-442.3f,""String_Node_Str""));
  data.add(new Data(4,-2280.1f,""String_Node_Str""));
  setData(data);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart_noseekbar);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setBackgroundColor(Color.WHITE);
  mChart.setExtraTopOffset(-30f);
  mChart.setExtraBottomOffset(10f);
  mChart.setExtraLeftOffset(70f);
  mChart.setExtraRightOffset(70f);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setTextColor(Color.LTGRAY);
  xAxis.setTextSize(13f);
  xAxis.setAxisMinValue(0f);
  xAxis.setAxisMaxValue(5f);
  xAxis.setLabelCount(5);
  xAxis.setCenterAxisLabels(true);
  xAxis.setGranularity(1f);
  YAxis left=mChart.getAxisLeft();
  left.setDrawLabels(false);
  left.setStartAtZero(false);
  left.setSpaceTop(25f);
  left.setSpaceBottom(25f);
  left.setDrawAxisLine(false);
  left.setDrawGridLines(false);
  left.setDrawZeroLine(true);
  left.setZeroLineColor(Color.GRAY);
  left.setZeroLineWidth(0.7f);
  mChart.getAxisRight().setEnabled(false);
  mChart.getLegend().setEnabled(false);
  final List<Data> data=new ArrayList<>();
  data.add(new Data(0.5f,-224.1f,""String_Node_Str""));
  data.add(new Data(1.5f,238.5f,""String_Node_Str""));
  data.add(new Data(2.5f,1280.1f,""String_Node_Str""));
  data.add(new Data(3.5f,-442.3f,""String_Node_Str""));
  data.add(new Data(4.5f,-2280.1f,""String_Node_Str""));
  xAxis.setValueFormatter(new AxisValueFormatter(){
    @Override public String getFormattedValue(    float value,    AxisBase axis){
      return data.get(Math.min(Math.max((int)value,0),data.size() - 1)).xAxisValue;
    }
    @Override public int getDecimalDigits(){
      return 0;
    }
  }
);
  setData(data);
}",0.8713235294117647
26304,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<IBarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      IBarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      BarBuffer buffer=mBarBuffers[i];
      if (!dataSet.isStacked()) {
        for (int j=0; j < buffer.buffer.length * mAnimator.getPhaseX(); j+=4) {
          float x=(buffer.buffer[j] + buffer.buffer[j + 2]) / 2f;
          if (!mViewPortHandler.isInBoundsRight(x))           break;
          if (!mViewPortHandler.isInBoundsY(buffer.buffer[j + 1]) || !mViewPortHandler.isInBoundsLeft(x))           continue;
          BarEntry entry=dataSet.getEntryForIndex(j / 4);
          float val=entry.getY();
          drawValue(c,dataSet.getValueFormatter(),val,entry,i,x,buffer.buffer[j + 1] + (val >= 0 ? posOffset : negOffset),dataSet.getValueTextColor(j / 4));
        }
      }
 else {
        Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
        int bufferIndex=0;
        int index=0;
        while (index < dataSet.getEntryCount() * mAnimator.getPhaseX()) {
          BarEntry entry=dataSet.getEntryForIndex(index);
          float[] vals=entry.getYVals();
          float x=(buffer.buffer[bufferIndex] + buffer.buffer[bufferIndex + 2]) / 2f;
          int color=dataSet.getValueTextColor(index);
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(x))             break;
            if (!mViewPortHandler.isInBoundsY(buffer.buffer[bufferIndex + 1]) || !mViewPortHandler.isInBoundsLeft(x))             continue;
            drawValue(c,dataSet.getValueFormatter(),entry.getY(),entry,i,x,buffer.buffer[bufferIndex + 1] + (entry.getY() >= 0 ? posOffset : negOffset),color);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-entry.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,dataSet.getValueFormatter(),vals[k / 2],entry,i,x,y,color);
            }
          }
          bufferIndex=vals == null ? bufferIndex + 4 : bufferIndex + 4 * vals.length;
          index++;
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<IBarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      IBarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      BarBuffer buffer=mBarBuffers[i];
      if (!dataSet.isStacked()) {
        for (int j=0; j < buffer.buffer.length * mAnimator.getPhaseX(); j+=4) {
          float x=(buffer.buffer[j] + buffer.buffer[j + 2]) / 2f;
          if (!mViewPortHandler.isInBoundsRight(x))           break;
          if (!mViewPortHandler.isInBoundsY(buffer.buffer[j + 1]) || !mViewPortHandler.isInBoundsLeft(x))           continue;
          BarEntry entry=dataSet.getEntryForIndex(j / 4);
          float val=entry.getY();
          drawValue(c,dataSet.getValueFormatter(),val,entry,i,x,val >= 0 ? (buffer.buffer[j + 1] + posOffset) : (buffer.buffer[j + 3] + negOffset),dataSet.getValueTextColor(j / 4));
        }
      }
 else {
        Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
        int bufferIndex=0;
        int index=0;
        while (index < dataSet.getEntryCount() * mAnimator.getPhaseX()) {
          BarEntry entry=dataSet.getEntryForIndex(index);
          float[] vals=entry.getYVals();
          float x=(buffer.buffer[bufferIndex] + buffer.buffer[bufferIndex + 2]) / 2f;
          int color=dataSet.getValueTextColor(index);
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(x))             break;
            if (!mViewPortHandler.isInBoundsY(buffer.buffer[bufferIndex + 1]) || !mViewPortHandler.isInBoundsLeft(x))             continue;
            drawValue(c,dataSet.getValueFormatter(),entry.getY(),entry,i,x,buffer.buffer[bufferIndex + 1] + (entry.getY() >= 0 ? posOffset : negOffset),color);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-entry.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,dataSet.getValueFormatter(),vals[k / 2],entry,i,x,y,color);
            }
          }
          bufferIndex=vals == null ? bufferIndex + 4 : bufferIndex + 4 * vals.length;
          index++;
        }
      }
    }
  }
}",0.9934325157485592
26305,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BarData barData=mChart.getBarData();
  int setCount=barData.getDataSetCount();
  for (  Highlight high : indices) {
    final int minDataSetIndex=high.getDataSetIndex() == -1 ? 0 : high.getDataSetIndex();
    final int maxDataSetIndex=high.getDataSetIndex() == -1 ? barData.getDataSetCount() : (high.getDataSetIndex() + 1);
    if (maxDataSetIndex - minDataSetIndex < 1)     continue;
    for (int dataSetIndex=minDataSetIndex; dataSetIndex < maxDataSetIndex; dataSetIndex++) {
      IBarDataSet set=barData.getDataSetByIndex(dataSetIndex);
      if (set == null || !set.isHighlightEnabled())       continue;
      Transformer trans=mChart.getTransformer(set.getAxisDependency());
      mHighlightPaint.setColor(set.getHighLightColor());
      mHighlightPaint.setAlpha(set.getHighLightAlpha());
      float x=high.getX();
      BarEntry e=set.getEntryForXPos(x);
      int entryIndex=set.getEntryIndex(e);
      if (e == null)       continue;
      boolean isStack=high.getStackIndex() < 0 ? false : true;
      final float y1;
      final float y2;
      if (isStack) {
        y1=high.getRange().from;
        y2=high.getRange().to;
      }
 else {
        y1=e.getY();
        y2=0.f;
      }
      prepareBarHighlight(e.getX(),y1,y2,barData.getBarWidth() / 2f,trans);
      c.drawRect(mBarRect,mHighlightPaint);
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BarData barData=mChart.getBarData();
  for (  Highlight high : indices) {
    final int minDataSetIndex=high.getDataSetIndex() == -1 ? 0 : high.getDataSetIndex();
    final int maxDataSetIndex=high.getDataSetIndex() == -1 ? barData.getDataSetCount() : (high.getDataSetIndex() + 1);
    if (maxDataSetIndex - minDataSetIndex < 1)     continue;
    for (int dataSetIndex=minDataSetIndex; dataSetIndex < maxDataSetIndex; dataSetIndex++) {
      IBarDataSet set=barData.getDataSetByIndex(dataSetIndex);
      if (set == null || !set.isHighlightEnabled())       continue;
      Transformer trans=mChart.getTransformer(set.getAxisDependency());
      mHighlightPaint.setColor(set.getHighLightColor());
      mHighlightPaint.setAlpha(set.getHighLightAlpha());
      float x=high.getX();
      BarEntry e=set.getEntryForXPos(x);
      int entryIndex=set.getEntryIndex(e);
      if (e == null)       continue;
      boolean isStack=high.getStackIndex() < 0 ? false : true;
      final float y1;
      final float y2;
      if (isStack) {
        y1=high.getRange().from;
        y2=high.getRange().to;
      }
 else {
        y1=e.getY();
        y2=0.f;
      }
      prepareBarHighlight(e.getX(),y1,y2,barData.getBarWidth() / 2f,trans);
      c.drawRect(mBarRect,mHighlightPaint);
    }
  }
}",0.9847494553376906
26306,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragDecelerationFrictionCoef(0.9f);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setHighlightPerDragEnabled(true);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextSize(11f);
  l.setTextColor(Color.WHITE);
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextSize(12f);
  xAxis.setTextColor(Color.WHITE);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setSpaceBetweenLabels(1);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setAxisMinValue(0f);
  leftAxis.setDrawGridLines(true);
  leftAxis.setGranularityEnabled(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setAxisMaxValue(900);
  rightAxis.setAxisMinValue(-200);
  rightAxis.setDrawGridLines(false);
  rightAxis.setDrawZeroLine(false);
  rightAxis.setGranularityEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragDecelerationFrictionCoef(0.9f);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setHighlightPerDragEnabled(true);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextSize(11f);
  l.setTextColor(Color.WHITE);
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextSize(11f);
  xAxis.setTextColor(Color.WHITE);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setSpaceBetweenLabels(1);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setAxisMinValue(0f);
  leftAxis.setDrawGridLines(true);
  leftAxis.setGranularityEnabled(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setAxisMaxValue(900);
  rightAxis.setAxisMinValue(-200);
  rightAxis.setDrawGridLines(false);
  rightAxis.setDrawZeroLine(false);
  rightAxis.setGranularityEnabled(false);
}",0.9995361781076066
26307,"@Override public void notifyDataSetChanged(){
  if (mData == null) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  if (mRenderer != null)   mRenderer.initBuffers();
  calcMinMax();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum,mAxisLeft.isInverted());
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum,mAxisRight.isInverted());
  if (mLegend != null)   mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mData == null) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  if (mRenderer != null)   mRenderer.initBuffers();
  calcMinMax();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum,mAxisLeft.isInverted());
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum,mAxisRight.isInverted());
  mXAxisRenderer.computeAxis(mXAxis.mAxisMinimum,mXAxis.mAxisMaximum,false);
  if (mLegend != null)   mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}",0.9376518218623482
26308,"@Override public void renderAxisLabels(Canvas c){
  if (!mXAxis.isEnabled() || !mXAxis.isDrawLabelsEnabled())   return;
  float yoffset=mXAxis.getYOffset();
  mAxisLabelPaint.setTypeface(mXAxis.getTypeface());
  mAxisLabelPaint.setTextSize(mXAxis.getTextSize());
  mAxisLabelPaint.setColor(mXAxis.getTextColor());
  if (mXAxis.getPosition() == XAxisPosition.TOP) {
    drawLabels(c,mViewPortHandler.contentTop() - yoffset,new PointF(0.5f,1.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.TOP_INSIDE) {
    drawLabels(c,mViewPortHandler.contentTop() + yoffset + mXAxis.mLabelRotatedHeight,new PointF(0.5f,1.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
    drawLabels(c,mViewPortHandler.contentBottom() + yoffset,new PointF(0.5f,0.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE) {
    drawLabels(c,mViewPortHandler.contentBottom() - yoffset - mXAxis.mLabelRotatedHeight,new PointF(0.5f,0.0f));
  }
 else {
    drawLabels(c,mViewPortHandler.contentTop() - yoffset,new PointF(0.5f,1.0f));
    drawLabels(c,mViewPortHandler.contentBottom() + yoffset,new PointF(0.5f,0.0f));
  }
}","@Override public void renderAxisLabels(Canvas c){
  if (!mXAxis.isEnabled() || !mXAxis.isDrawLabelsEnabled())   return;
  float yoffset=mXAxis.getYOffset();
  mAxisLabelPaint.setTypeface(mXAxis.getTypeface());
  mAxisLabelPaint.setTextSize(mXAxis.getTextSize());
  mAxisLabelPaint.setColor(mXAxis.getTextColor());
  if (mXAxis.getPosition() == XAxisPosition.TOP) {
    drawLabels(c,mViewPortHandler.contentTop() - yoffset,new PointF(0.5f,0.9f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.TOP_INSIDE) {
    drawLabels(c,mViewPortHandler.contentTop() + yoffset + mXAxis.mLabelRotatedHeight,new PointF(0.5f,1.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
    drawLabels(c,mViewPortHandler.contentBottom() + yoffset,new PointF(0.5f,0.0f));
  }
 else   if (mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE) {
    drawLabels(c,mViewPortHandler.contentBottom() - yoffset - mXAxis.mLabelRotatedHeight,new PointF(0.5f,0.0f));
  }
 else {
    drawLabels(c,mViewPortHandler.contentTop() - yoffset,new PointF(0.5f,1.0f));
    drawLabels(c,mViewPortHandler.contentBottom() + yoffset,new PointF(0.5f,0.0f));
  }
}",0.9973637961335676
26309,"public void renderLegend(Canvas c){
  if (!mLegend.isEnabled())   return;
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  float labelLineHeight=Utils.getLineHeight(mLegendLabelPaint);
  float labelLineSpacing=Utils.getLineSpacing(mLegendLabelPaint) + mLegend.getYEntrySpace();
  float formYOffset=labelLineHeight - Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") / 2.f;
  String[] labels=mLegend.getLabels();
  int[] colors=mLegend.getColors();
  float formToTextSpace=mLegend.getFormToTextSpace();
  float xEntrySpace=mLegend.getXEntrySpace();
  Legend.LegendDirection direction=mLegend.getDirection();
  float formSize=mLegend.getFormSize();
  float stackSpace=mLegend.getStackSpace();
  float posX, posY;
  float yoffset=mLegend.getYOffset();
  float xoffset=mLegend.getXOffset();
  Legend.LegendPosition legendPosition=mLegend.getPosition();
switch (legendPosition) {
case BELOW_CHART_LEFT:
case BELOW_CHART_RIGHT:
case BELOW_CHART_CENTER:
case ABOVE_CHART_LEFT:
case ABOVE_CHART_RIGHT:
case ABOVE_CHART_CENTER:
{
      float contentWidth=mViewPortHandler.contentWidth();
      float originPosX;
      if (legendPosition == Legend.LegendPosition.BELOW_CHART_LEFT || legendPosition == Legend.LegendPosition.ABOVE_CHART_LEFT) {
        originPosX=mViewPortHandler.contentLeft() + xoffset;
        if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)         originPosX+=mLegend.mNeededWidth;
      }
 else       if (legendPosition == Legend.LegendPosition.BELOW_CHART_RIGHT || legendPosition == Legend.LegendPosition.ABOVE_CHART_RIGHT) {
        originPosX=mViewPortHandler.contentRight() - xoffset;
        if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)         originPosX-=mLegend.mNeededWidth;
      }
 else       originPosX=mViewPortHandler.contentLeft() + contentWidth / 2.f;
      FSize[] calculatedLineSizes=mLegend.getCalculatedLineSizes();
      FSize[] calculatedLabelSizes=mLegend.getCalculatedLabelSizes();
      Boolean[] calculatedLabelBreakPoints=mLegend.getCalculatedLabelBreakPoints();
      posX=originPosX;
      if (legendPosition == Legend.LegendPosition.ABOVE_CHART_LEFT || legendPosition == Legend.LegendPosition.ABOVE_CHART_RIGHT || legendPosition == Legend.LegendPosition.ABOVE_CHART_CENTER) {
        posY=0.f;
      }
 else {
        posY=mViewPortHandler.getChartHeight() - yoffset - mLegend.mNeededHeight;
      }
      int lineIndex=0;
      for (int i=0, count=labels.length; i < count; i++) {
        if (i < calculatedLabelBreakPoints.length && calculatedLabelBreakPoints[i]) {
          posX=originPosX;
          posY+=labelLineHeight + labelLineSpacing;
        }
        if (posX == originPosX && legendPosition == Legend.LegendPosition.BELOW_CHART_CENTER && lineIndex < calculatedLineSizes.length) {
          posX+=(direction == Legend.LegendDirection.RIGHT_TO_LEFT ? calculatedLineSizes[lineIndex].width : -calculatedLineSizes[lineIndex].width) / 2.f;
          lineIndex++;
        }
        boolean drawingForm=colors[i] != ColorTemplate.COLOR_SKIP;
        boolean isStacked=labels[i] == null;
        if (drawingForm) {
          if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)           posX-=formSize;
          drawForm(c,posX,posY + formYOffset,i,mLegend);
          if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)           posX+=formSize;
        }
        if (!isStacked) {
          if (drawingForm)           posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -formToTextSpace : formToTextSpace;
          if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)           posX-=calculatedLabelSizes[i].width;
          drawLabel(c,posX,posY + labelLineHeight,labels[i]);
          if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)           posX+=calculatedLabelSizes[i].width;
          posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -xEntrySpace : xEntrySpace;
        }
 else         posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -stackSpace : stackSpace;
      }
    }
  break;
case PIECHART_CENTER:
case RIGHT_OF_CHART:
case RIGHT_OF_CHART_CENTER:
case RIGHT_OF_CHART_INSIDE:
case LEFT_OF_CHART:
case LEFT_OF_CHART_CENTER:
case LEFT_OF_CHART_INSIDE:
{
  float stack=0f;
  boolean wasStacked=false;
  if (legendPosition == Legend.LegendPosition.PIECHART_CENTER) {
    posX=mViewPortHandler.getChartWidth() / 2f + (direction == Legend.LegendDirection.LEFT_TO_RIGHT ? -mLegend.mTextWidthMax / 2f : mLegend.mTextWidthMax / 2f);
    posY=mViewPortHandler.getChartHeight() / 2f - mLegend.mNeededHeight / 2f + mLegend.getYOffset();
  }
 else {
    boolean isRightAligned=legendPosition == Legend.LegendPosition.RIGHT_OF_CHART || legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_CENTER || legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_INSIDE;
    if (isRightAligned) {
      posX=mViewPortHandler.getChartWidth() - xoffset;
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       posX-=mLegend.mTextWidthMax;
    }
 else {
      posX=xoffset;
      if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)       posX+=mLegend.mTextWidthMax;
    }
    if (legendPosition == Legend.LegendPosition.RIGHT_OF_CHART || legendPosition == Legend.LegendPosition.LEFT_OF_CHART) {
      posY=mViewPortHandler.contentTop() + yoffset;
    }
 else     if (legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_CENTER || legendPosition == Legend.LegendPosition.LEFT_OF_CHART_CENTER) {
      posY=mViewPortHandler.getChartHeight() / 2f - mLegend.mNeededHeight / 2f;
    }
 else {
      posY=mViewPortHandler.contentTop() + yoffset;
    }
  }
  for (int i=0; i < labels.length; i++) {
    Boolean drawingForm=colors[i] != ColorTemplate.COLOR_SKIP;
    float x=posX;
    if (drawingForm) {
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       x+=stack;
 else       x-=formSize - stack;
      drawForm(c,x,posY + formYOffset,i,mLegend);
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       x+=formSize;
    }
    if (labels[i] != null) {
      if (drawingForm && !wasStacked)       x+=direction == Legend.LegendDirection.LEFT_TO_RIGHT ? formToTextSpace : -formToTextSpace;
 else       if (wasStacked)       x=posX;
      if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)       x-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
      if (!wasStacked) {
        drawLabel(c,x,posY + labelLineHeight,labels[i]);
      }
 else {
        posY+=labelLineHeight + labelLineSpacing;
        drawLabel(c,x,posY + labelLineHeight,labels[i]);
      }
      posY+=labelLineHeight + labelLineSpacing;
      stack=0f;
    }
 else {
      stack+=formSize + stackSpace;
      wasStacked=true;
    }
  }
}
break;
}
}","public void renderLegend(Canvas c){
  if (!mLegend.isEnabled())   return;
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  float labelLineHeight=Utils.getLineHeight(mLegendLabelPaint);
  float labelLineSpacing=Utils.getLineSpacing(mLegendLabelPaint) + mLegend.getYEntrySpace();
  float formYOffset=labelLineHeight - Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") / 2.f;
  String[] labels=mLegend.getLabels();
  int[] colors=mLegend.getColors();
  float formToTextSpace=mLegend.getFormToTextSpace();
  float xEntrySpace=mLegend.getXEntrySpace();
  Legend.LegendDirection direction=mLegend.getDirection();
  float formSize=mLegend.getFormSize();
  float stackSpace=mLegend.getStackSpace();
  float posX, posY;
  float yoffset=mLegend.getYOffset();
  float xoffset=mLegend.getXOffset();
  Legend.LegendPosition legendPosition=mLegend.getPosition();
switch (legendPosition) {
case BELOW_CHART_LEFT:
case BELOW_CHART_RIGHT:
case BELOW_CHART_CENTER:
case ABOVE_CHART_LEFT:
case ABOVE_CHART_RIGHT:
case ABOVE_CHART_CENTER:
{
      float contentWidth=mViewPortHandler.contentWidth();
      float originPosX;
      if (legendPosition == Legend.LegendPosition.BELOW_CHART_LEFT || legendPosition == Legend.LegendPosition.ABOVE_CHART_LEFT) {
        originPosX=mViewPortHandler.contentLeft() + xoffset;
        if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)         originPosX+=mLegend.mNeededWidth;
      }
 else       if (legendPosition == Legend.LegendPosition.BELOW_CHART_RIGHT || legendPosition == Legend.LegendPosition.ABOVE_CHART_RIGHT) {
        originPosX=mViewPortHandler.contentRight() - xoffset;
        if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)         originPosX-=mLegend.mNeededWidth;
      }
 else       originPosX=mViewPortHandler.contentLeft() + contentWidth / 2.f - mLegend.mNeededWidth / 2f;
      FSize[] calculatedLineSizes=mLegend.getCalculatedLineSizes();
      FSize[] calculatedLabelSizes=mLegend.getCalculatedLabelSizes();
      Boolean[] calculatedLabelBreakPoints=mLegend.getCalculatedLabelBreakPoints();
      posX=originPosX;
      if (legendPosition == Legend.LegendPosition.ABOVE_CHART_LEFT || legendPosition == Legend.LegendPosition.ABOVE_CHART_RIGHT || legendPosition == Legend.LegendPosition.ABOVE_CHART_CENTER) {
        posY=0.f;
      }
 else {
        posY=mViewPortHandler.getChartHeight() - yoffset - mLegend.mNeededHeight;
      }
      int lineIndex=0;
      for (int i=0, count=labels.length; i < count; i++) {
        if (i < calculatedLabelBreakPoints.length && calculatedLabelBreakPoints[i]) {
          posX=originPosX;
          posY+=labelLineHeight + labelLineSpacing;
        }
        if (posX == originPosX && legendPosition == Legend.LegendPosition.BELOW_CHART_CENTER && lineIndex < calculatedLineSizes.length) {
          posX+=(direction == Legend.LegendDirection.RIGHT_TO_LEFT ? calculatedLineSizes[lineIndex].width : -calculatedLineSizes[lineIndex].width) / 2.f;
          lineIndex++;
        }
        boolean drawingForm=colors[i] != ColorTemplate.COLOR_SKIP;
        boolean isStacked=labels[i] == null;
        if (drawingForm) {
          if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)           posX-=formSize;
          drawForm(c,posX,posY + formYOffset,i,mLegend);
          if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)           posX+=formSize;
        }
        if (!isStacked) {
          if (drawingForm)           posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -formToTextSpace : formToTextSpace;
          if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)           posX-=calculatedLabelSizes[i].width;
          drawLabel(c,posX,posY + labelLineHeight,labels[i]);
          if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)           posX+=calculatedLabelSizes[i].width;
          posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -xEntrySpace : xEntrySpace;
        }
 else         posX+=direction == Legend.LegendDirection.RIGHT_TO_LEFT ? -stackSpace : stackSpace;
      }
    }
  break;
case PIECHART_CENTER:
case RIGHT_OF_CHART:
case RIGHT_OF_CHART_CENTER:
case RIGHT_OF_CHART_INSIDE:
case LEFT_OF_CHART:
case LEFT_OF_CHART_CENTER:
case LEFT_OF_CHART_INSIDE:
{
  float stack=0f;
  boolean wasStacked=false;
  if (legendPosition == Legend.LegendPosition.PIECHART_CENTER) {
    posX=mViewPortHandler.getChartWidth() / 2f + (direction == Legend.LegendDirection.LEFT_TO_RIGHT ? -mLegend.mTextWidthMax / 2f : mLegend.mTextWidthMax / 2f);
    posY=mViewPortHandler.getChartHeight() / 2f - mLegend.mNeededHeight / 2f + mLegend.getYOffset();
  }
 else {
    boolean isRightAligned=legendPosition == Legend.LegendPosition.RIGHT_OF_CHART || legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_CENTER || legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_INSIDE;
    if (isRightAligned) {
      posX=mViewPortHandler.getChartWidth() - xoffset;
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       posX-=mLegend.mTextWidthMax;
    }
 else {
      posX=xoffset;
      if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)       posX+=mLegend.mTextWidthMax;
    }
    if (legendPosition == Legend.LegendPosition.RIGHT_OF_CHART || legendPosition == Legend.LegendPosition.LEFT_OF_CHART) {
      posY=mViewPortHandler.contentTop() + yoffset;
    }
 else     if (legendPosition == Legend.LegendPosition.RIGHT_OF_CHART_CENTER || legendPosition == Legend.LegendPosition.LEFT_OF_CHART_CENTER) {
      posY=mViewPortHandler.getChartHeight() / 2f - mLegend.mNeededHeight / 2f;
    }
 else {
      posY=mViewPortHandler.contentTop() + yoffset;
    }
  }
  for (int i=0; i < labels.length; i++) {
    Boolean drawingForm=colors[i] != ColorTemplate.COLOR_SKIP;
    float x=posX;
    if (drawingForm) {
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       x+=stack;
 else       x-=formSize - stack;
      drawForm(c,x,posY + formYOffset,i,mLegend);
      if (direction == Legend.LegendDirection.LEFT_TO_RIGHT)       x+=formSize;
    }
    if (labels[i] != null) {
      if (drawingForm && !wasStacked)       x+=direction == Legend.LegendDirection.LEFT_TO_RIGHT ? formToTextSpace : -formToTextSpace;
 else       if (wasStacked)       x=posX;
      if (direction == Legend.LegendDirection.RIGHT_TO_LEFT)       x-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]);
      if (!wasStacked) {
        drawLabel(c,x,posY + labelLineHeight,labels[i]);
      }
 else {
        posY+=labelLineHeight + labelLineSpacing;
        drawLabel(c,x,posY + labelLineHeight,labels[i]);
      }
      posY+=labelLineHeight + labelLineSpacing;
      stack=0f;
    }
 else {
      stack+=formSize + stackSpace;
      wasStacked=true;
    }
  }
}
break;
}
}",0.99795051968965
26310,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mData == null)   return;
  long starttime=System.currentTimeMillis();
  calcModulus();
  mXAxisRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  mRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  if (mAutoScaleMinMaxEnabled) {
    final int lowestVisibleXIndex=getLowestVisibleXIndex();
    final int highestVisibleXIndex=getHighestVisibleXIndex();
    if (mAutoScaleLastLowestVisibleXIndex == null || mAutoScaleLastLowestVisibleXIndex != lowestVisibleXIndex || mAutoScaleLastHighestVisibleXIndex == null || mAutoScaleLastHighestVisibleXIndex != highestVisibleXIndex) {
      calcMinMax();
      calculateOffsets();
      mAutoScaleLastLowestVisibleXIndex=lowestVisibleXIndex;
      mAutoScaleLastHighestVisibleXIndex=highestVisibleXIndex;
    }
  }
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  if (mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (!mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (!mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (!mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  if (valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHighlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mData == null)   return;
  long starttime=System.currentTimeMillis();
  calcModulus();
  mXAxisRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  mRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  if (mAutoScaleMinMaxEnabled) {
    final int lowestVisibleXIndex=getLowestVisibleXIndex();
    final int highestVisibleXIndex=getHighestVisibleXIndex();
    if (mAutoScaleLastLowestVisibleXIndex == null || mAutoScaleLastLowestVisibleXIndex != lowestVisibleXIndex || mAutoScaleLastHighestVisibleXIndex == null || mAutoScaleLastHighestVisibleXIndex != highestVisibleXIndex) {
      calcMinMax();
      calculateOffsets();
      mAutoScaleLastLowestVisibleXIndex=lowestVisibleXIndex;
      mAutoScaleLastHighestVisibleXIndex=highestVisibleXIndex;
    }
  }
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  if (mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHighlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  if (!mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (!mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (!mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.942412169503803
26311,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  float[] pts=new float[2];
  if (mKeepPositionOnRotation) {
    pts[0]=mViewPortHandler.contentLeft();
    pts[1]=mViewPortHandler.contentTop();
    getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  }
  super.onSizeChanged(w,h,oldw,oldh);
  if (mKeepPositionOnRotation) {
    getTransformer(AxisDependency.LEFT).pointValuesToPixel(pts);
    mViewPortHandler.centerViewPort(pts,this);
  }
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  float[] pts=new float[2];
  if (mKeepPositionOnRotation) {
    pts[0]=mViewPortHandler.contentLeft();
    pts[1]=mViewPortHandler.contentTop();
    getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  }
  super.onSizeChanged(w,h,oldw,oldh);
  if (mKeepPositionOnRotation) {
    getTransformer(AxisDependency.LEFT).pointValuesToPixel(pts);
    mViewPortHandler.centerViewPort(pts,this);
  }
 else {
    mViewPortHandler.refresh(mViewPortHandler.getMatrixTouch(),this,true);
  }
}",0.9151219512195122
26312,"/** 
 * Draws the provided path in filled mode with the provided color and alpha. Special thanks to Angelo Suzuki (https://github.com/tinsukE) for this.
 * @param c
 * @param filledPath
 * @param fillColor
 * @param fillAlpha
 */
protected void drawFilledPath(Canvas c,Path filledPath,int fillColor,int fillAlpha){
  c.save();
  c.clipPath(filledPath);
  int color=(fillAlpha << 24) | (fillColor & 0xffffff);
  c.drawColor(color);
  c.restore();
}","/** 
 * Draws the provided path in filled mode with the provided color and alpha. Special thanks to Angelo Suzuki (https://github.com/tinsukE) for this.
 * @param c
 * @param filledPath
 * @param fillColor
 * @param fillAlpha
 */
protected void drawFilledPath(Canvas c,Path filledPath,int fillColor,int fillAlpha){
  int color=(fillAlpha << 24) | (fillColor & 0xffffff);
  if (clipPathSupported()) {
    c.save();
    c.clipPath(filledPath);
    c.drawColor(color);
    c.restore();
  }
 else {
    Paint.Style previous=mRenderPaint.getStyle();
    int previousColor=mRenderPaint.getColor();
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setColor(color);
    c.drawPath(filledPath,mRenderPaint);
    mRenderPaint.setColor(previousColor);
    mRenderPaint.setStyle(previous);
  }
}",0.6371681415929203
26313,"@Override protected void calcMinMax(){
  super.calcMinMax();
  calcAngles();
}","@Override protected void calcMinMax(){
  calcAngles();
}",0.835820895522388
26314,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setViewPortOffsets(0,20,0,0);
  mChart.setBackgroundColor(Color.rgb(104,241,175));
  mChart.setDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis x=mChart.getXAxis();
  x.setEnabled(false);
  YAxis y=mChart.getAxisLeft();
  y.setTypeface(tf);
  y.setLabelCount(6,false);
  y.setTextColor(Color.WHITE);
  y.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
  y.setDrawGridLines(false);
  y.setAxisLineColor(Color.WHITE);
  mChart.getAxisRight().setEnabled(false);
  setData(45,100);
  mChart.getLegend().setEnabled(false);
  mChart.animateXY(2000,2000);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setViewPortOffsets(0,0,0,0);
  mChart.setBackgroundColor(Color.rgb(104,241,175));
  mChart.setDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis x=mChart.getXAxis();
  x.setEnabled(false);
  YAxis y=mChart.getAxisLeft();
  y.setTypeface(tf);
  y.setLabelCount(6,false);
  y.setTextColor(Color.WHITE);
  y.setPosition(YAxis.YAxisLabelPosition.INSIDE_CHART);
  y.setDrawGridLines(false);
  y.setAxisLineColor(Color.WHITE);
  mChart.getAxisRight().setEnabled(false);
  setData(45,100);
  mChart.getLegend().setEnabled(false);
  mChart.animateXY(2000,2000);
  mChart.invalidate();
}",0.9996538594669436
26315,"protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  float sliceSpace=dataSet.getSliceSpace();
  final PointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final float userInnerRadius=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled() ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getVal()) > 0.000001)) {
      visibleAngleCount++;
    }
  }
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceOuterAngle=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceOuterAngle / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceOuterAngle) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=0.f, arcStartPointY=0.f;
        if (sweepAngleOuter % 360f == 0.f) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
          arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        if (sliceSpace > 0.f) {
          innerRadius=Math.max(innerRadius,calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter));
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (innerRadius > 0.0) {
          final float sliceSpaceInnerAngle=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceInnerAngle / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceInnerAngle) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            mPathBuffer.lineTo(center.x,center.y);
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
}","protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=0;
  float rotationAngle=mChart.getRotationAngle();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  final RectF circleBox=mChart.getCircleBox();
  final int entryCount=dataSet.getEntryCount();
  final float[] drawAngles=mChart.getDrawAngles();
  float sliceSpace=dataSet.getSliceSpace();
  final PointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  int visibleAngleCount=0;
  for (int j=0; j < entryCount; j++) {
    if ((Math.abs(dataSet.getEntryForIndex(j).getVal()) > 0.000001)) {
      visibleAngleCount++;
    }
  }
  for (int j=0; j < entryCount; j++) {
    float sliceAngle=drawAngles[j];
    float innerRadius=userInnerRadius;
    Entry e=dataSet.getEntryForIndex(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
        final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
        float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
        if (sweepAngleOuter < 0.f) {
          sweepAngleOuter=0.f;
        }
        mPathBuffer.reset();
        float arcStartPointX=0.f, arcStartPointY=0.f;
        if (sweepAngleOuter % 360f == 0.f) {
          mPathBuffer.addCircle(center.x,center.y,radius,Path.Direction.CW);
        }
 else {
          arcStartPointX=center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD);
          arcStartPointY=center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD);
          mPathBuffer.moveTo(arcStartPointX,arcStartPointY);
          mPathBuffer.arcTo(circleBox,startAngleOuter,sweepAngleOuter);
        }
        mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
        if (drawInnerArc && (innerRadius > 0.f || sliceSpace > 0.f)) {
          if (sliceSpace > 0.f) {
            float minSpacedRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
            if (minSpacedRadius < 0.f)             minSpacedRadius=-minSpacedRadius;
            innerRadius=Math.max(innerRadius,minSpacedRadius);
          }
          final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
          final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
          float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
          if (sweepAngleInner < 0.f) {
            sweepAngleInner=0.f;
          }
          final float endAngleInner=startAngleInner + sweepAngleInner;
          if (sweepAngleOuter % 360f == 0.f) {
            mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
          }
 else {
            mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
            mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
          }
        }
 else {
          if (sweepAngleOuter % 360f != 0.f) {
            if (sliceSpace > 0.f) {
              float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
              float sliceSpaceOffset=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,arcStartPointX,arcStartPointY,startAngleOuter,sweepAngleOuter);
              float arcEndPointX=center.x + sliceSpaceOffset * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
              float arcEndPointY=center.y + sliceSpaceOffset * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
              mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
            }
 else {
              mPathBuffer.lineTo(center.x,center.y);
            }
          }
        }
        mPathBuffer.close();
        mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
      }
    }
    angle+=sliceAngle * phaseX;
  }
}",0.8238361266294227
26316,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float angle;
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  final PointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final float userInnerRadius=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled() ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  final RectF highlightedCircleBox=new RectF();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    final int entryCount=set.getEntryCount();
    int visibleAngleCount=0;
    for (int j=0; j < entryCount; j++) {
      if ((Math.abs(set.getEntryForIndex(j).getVal()) > 0.000001)) {
        visibleAngleCount++;
      }
    }
    if (xIndex == 0)     angle=0.f;
 else     angle=absoluteAngles[xIndex - 1] * phaseX;
    float sliceSpace=set.getSliceSpace();
    float sliceAngle=drawAngles[xIndex];
    final float sliceSpaceOuterAngle=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
    float innerRadius=userInnerRadius;
    float shift=set.getSelectionShift();
    final float highlightedRadius=radius + shift;
    highlightedCircleBox.set(mChart.getCircleBox());
    highlightedCircleBox.inset(-shift,-shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    final float startAngleOuter=rotationAngle + (angle + sliceSpaceOuterAngle / 2.f) * phaseY;
    float sweepAngleOuter=(sliceAngle - sliceSpaceOuterAngle) * phaseY;
    if (sweepAngleOuter < 0.f) {
      sweepAngleOuter=0.f;
    }
    mPathBuffer.reset();
    if (sweepAngleOuter % 360f == 0.f) {
      mPathBuffer.addCircle(center.x,center.y,highlightedRadius,Path.Direction.CW);
    }
 else {
      mPathBuffer.moveTo(center.x + highlightedRadius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + highlightedRadius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD));
      mPathBuffer.arcTo(highlightedCircleBox,startAngleOuter,sweepAngleOuter);
    }
    if (sliceSpace > 0.f) {
      innerRadius=Math.max(innerRadius,calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD),startAngleOuter,sweepAngleOuter));
    }
    mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
    if (innerRadius > 0.0) {
      final float sliceSpaceInnerAngle=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
      final float startAngleInner=rotationAngle + (angle + sliceSpaceInnerAngle / 2.f) * phaseY;
      float sweepAngleInner=(sliceAngle - sliceSpaceInnerAngle) * phaseY;
      if (sweepAngleInner < 0.f) {
        sweepAngleInner=0.f;
      }
      final float endAngleInner=startAngleInner + sweepAngleInner;
      if (sweepAngleOuter % 360f == 0.f) {
        mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
      }
 else {
        mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
        mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
      }
    }
 else {
      if (sweepAngleOuter % 360f != 0.f) {
        mPathBuffer.lineTo(center.x,center.y);
      }
    }
    mPathBuffer.close();
    mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float angle;
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  final PointF center=mChart.getCenterCircleBox();
  final float radius=mChart.getRadius();
  final boolean drawInnerArc=mChart.isDrawHoleEnabled() && !mChart.isDrawSlicesUnderHoleEnabled();
  final float userInnerRadius=drawInnerArc ? radius * (mChart.getHoleRadius() / 100.f) : 0.f;
  final RectF highlightedCircleBox=new RectF();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    final int entryCount=set.getEntryCount();
    int visibleAngleCount=0;
    for (int j=0; j < entryCount; j++) {
      if ((Math.abs(set.getEntryForIndex(j).getVal()) > 0.000001)) {
        visibleAngleCount++;
      }
    }
    if (xIndex == 0)     angle=0.f;
 else     angle=absoluteAngles[xIndex - 1] * phaseX;
    float sliceSpace=set.getSliceSpace();
    float sliceAngle=drawAngles[xIndex];
    float innerRadius=userInnerRadius;
    float shift=set.getSelectionShift();
    final float highlightedRadius=radius + shift;
    highlightedCircleBox.set(mChart.getCircleBox());
    highlightedCircleBox.inset(-shift,-shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    final float sliceSpaceAngleOuter=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * radius);
    final float sliceSpaceAngleShifted=visibleAngleCount == 1 ? 0.f : sliceSpace / (Utils.FDEG2RAD * highlightedRadius);
    final float startAngleOuter=rotationAngle + (angle + sliceSpaceAngleOuter / 2.f) * phaseY;
    float sweepAngleOuter=(sliceAngle - sliceSpaceAngleOuter) * phaseY;
    if (sweepAngleOuter < 0.f) {
      sweepAngleOuter=0.f;
    }
    final float startAngleShifted=rotationAngle + (angle + sliceSpaceAngleShifted / 2.f) * phaseY;
    float sweepAngleShifted=(sliceAngle - sliceSpaceAngleShifted) * phaseY;
    if (sweepAngleShifted < 0.f) {
      sweepAngleShifted=0.f;
    }
    mPathBuffer.reset();
    if (sweepAngleOuter % 360f == 0.f) {
      mPathBuffer.addCircle(center.x,center.y,highlightedRadius,Path.Direction.CW);
    }
 else {
      mPathBuffer.moveTo(center.x + highlightedRadius * (float)Math.cos(startAngleShifted * Utils.FDEG2RAD),center.y + highlightedRadius * (float)Math.sin(startAngleShifted * Utils.FDEG2RAD));
      mPathBuffer.arcTo(highlightedCircleBox,startAngleShifted,sweepAngleShifted);
    }
    float sliceSpaceRadius=0.f;
    if (sliceSpace > 0.f) {
      sliceSpaceRadius=calculateMinimumRadiusForSpacedSlice(center,radius,sliceAngle * phaseY,center.x + radius * (float)Math.cos(startAngleOuter * Utils.FDEG2RAD),center.y + radius * (float)Math.sin(startAngleOuter * Utils.FDEG2RAD),startAngleOuter,sweepAngleOuter);
    }
    mInnerRectBuffer.set(center.x - innerRadius,center.y - innerRadius,center.x + innerRadius,center.y + innerRadius);
    if (drawInnerArc && (innerRadius > 0.f || sliceSpace > 0.f)) {
      if (sliceSpace > 0.f) {
        float minSpacedRadius=sliceSpaceRadius;
        if (minSpacedRadius < 0.f)         minSpacedRadius=-minSpacedRadius;
        innerRadius=Math.max(innerRadius,minSpacedRadius);
      }
      final float sliceSpaceAngleInner=visibleAngleCount == 1 || innerRadius == 0.f ? 0.f : sliceSpace / (Utils.FDEG2RAD * innerRadius);
      final float startAngleInner=rotationAngle + (angle + sliceSpaceAngleInner / 2.f) * phaseY;
      float sweepAngleInner=(sliceAngle - sliceSpaceAngleInner) * phaseY;
      if (sweepAngleInner < 0.f) {
        sweepAngleInner=0.f;
      }
      final float endAngleInner=startAngleInner + sweepAngleInner;
      if (sweepAngleOuter % 360f == 0.f) {
        mPathBuffer.addCircle(center.x,center.y,innerRadius,Path.Direction.CCW);
      }
 else {
        mPathBuffer.lineTo(center.x + innerRadius * (float)Math.cos(endAngleInner * Utils.FDEG2RAD),center.y + innerRadius * (float)Math.sin(endAngleInner * Utils.FDEG2RAD));
        mPathBuffer.arcTo(mInnerRectBuffer,endAngleInner,-sweepAngleInner);
      }
    }
 else {
      if (sweepAngleOuter % 360f != 0.f) {
        if (sliceSpace > 0.0) {
          final float angleMiddle=startAngleOuter + sweepAngleOuter / 2.f;
          final float arcEndPointX=center.x + sliceSpaceRadius * (float)Math.cos(angleMiddle * Utils.FDEG2RAD);
          final float arcEndPointY=center.y + sliceSpaceRadius * (float)Math.sin(angleMiddle * Utils.FDEG2RAD);
          mPathBuffer.lineTo(arcEndPointX,arcEndPointY);
        }
 else {
          mPathBuffer.lineTo(center.x,center.y);
        }
      }
    }
    mPathBuffer.close();
    mBitmapCanvas.drawPath(mPathBuffer,mRenderPaint);
  }
}",0.4464407550602683
26317,"/** 
 * Performs the all operations necessary for pinch and axis zoom.
 * @param event
 */
private void performZoom(MotionEvent event){
  if (event.getPointerCount() >= 2) {
    OnChartGestureListener l=mChart.getOnChartGestureListener();
    float totalDist=spacing(event);
    if (totalDist > 10f) {
      PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
      if (mTouchMode == PINCH_ZOOM) {
        mLastGesture=ChartGesture.PINCH_ZOOM;
        float scale=totalDist / mSavedDist;
        boolean isZoomingOut=(scale < 1);
        boolean canZoomMoreX=isZoomingOut ? mChart.getViewPortHandler().canZoomOutMoreX() : mChart.getViewPortHandler().canZoomInMoreX();
        float scaleX=(mChart.isScaleXEnabled()) ? scale : 1f;
        float scaleY=(mChart.isScaleYEnabled()) ? scale : 1f;
        if (mChart.isScaleYEnabled() || canZoomMoreX) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(scaleX,scaleY,t.x,t.y);
          if (l != null)           l.onChartScale(event,scaleX,scaleY);
        }
      }
 else       if (mTouchMode == X_ZOOM && mChart.isScaleXEnabled()) {
        mLastGesture=ChartGesture.X_ZOOM;
        float xDist=getXDist(event);
        float scaleX=xDist / mSavedXDist;
        boolean isZoomingOut=(scaleX < 1);
        boolean canZoomMoreX=isZoomingOut ? mChart.getViewPortHandler().canZoomOutMoreX() : mChart.getViewPortHandler().canZoomInMoreX();
        if (canZoomMoreX) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(scaleX,1f,t.x,t.y);
          if (l != null)           l.onChartScale(event,scaleX,1f);
        }
      }
 else       if (mTouchMode == Y_ZOOM && mChart.isScaleYEnabled()) {
        mLastGesture=ChartGesture.Y_ZOOM;
        float yDist=getYDist(event);
        float scaleY=yDist / mSavedYDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(1f,scaleY,t.x,t.y);
        if (l != null)         l.onChartScale(event,1f,scaleY);
      }
    }
  }
}","/** 
 * Performs the all operations necessary for pinch and axis zoom.
 * @param event
 */
private void performZoom(MotionEvent event){
  if (event.getPointerCount() >= 2) {
    OnChartGestureListener l=mChart.getOnChartGestureListener();
    float totalDist=spacing(event);
    if (totalDist > mMinScalePointerDistance) {
      PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
      ViewPortHandler h=mChart.getViewPortHandler();
      if (mTouchMode == PINCH_ZOOM) {
        mLastGesture=ChartGesture.PINCH_ZOOM;
        float scale=totalDist / mSavedDist;
        boolean isZoomingOut=(scale < 1);
        boolean canZoomMoreX=isZoomingOut ? h.canZoomOutMoreX() : h.canZoomInMoreX();
        boolean canZoomMoreY=isZoomingOut ? h.canZoomOutMoreY() : h.canZoomInMoreY();
        float scaleX=(mChart.isScaleXEnabled()) ? scale : 1f;
        float scaleY=(mChart.isScaleYEnabled()) ? scale : 1f;
        if (canZoomMoreY || canZoomMoreX) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(scaleX,scaleY,t.x,t.y);
          if (l != null)           l.onChartScale(event,scaleX,scaleY);
        }
      }
 else       if (mTouchMode == X_ZOOM && mChart.isScaleXEnabled()) {
        mLastGesture=ChartGesture.X_ZOOM;
        float xDist=getXDist(event);
        float scaleX=xDist / mSavedXDist;
        boolean isZoomingOut=(scaleX < 1);
        boolean canZoomMoreX=isZoomingOut ? h.canZoomOutMoreX() : h.canZoomInMoreX();
        if (canZoomMoreX) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(scaleX,1f,t.x,t.y);
          if (l != null)           l.onChartScale(event,scaleX,1f);
        }
      }
 else       if (mTouchMode == Y_ZOOM && mChart.isScaleYEnabled()) {
        mLastGesture=ChartGesture.Y_ZOOM;
        float yDist=getYDist(event);
        float scaleY=yDist / mSavedYDist;
        boolean isZoomingOut=(scaleY < 1);
        boolean canZoomMoreY=isZoomingOut ? h.canZoomOutMoreY() : h.canZoomInMoreY();
        if (canZoomMoreY) {
          mMatrix.set(mSavedMatrix);
          mMatrix.postScale(1f,scaleY,t.x,t.y);
          if (l != null)           l.onChartScale(event,1f,scaleY);
        }
      }
    }
  }
}",0.874909266876361
26318,"public BarLineChartTouchListener(BarLineChartBase<? extends BarLineScatterCandleBubbleData<? extends IBarLineScatterCandleBubbleDataSet<? extends Entry>>> chart,Matrix touchMatrix){
  super(chart);
  this.mMatrix=touchMatrix;
  this.mDragTriggerDist=Utils.convertDpToPixel(3f);
}","public BarLineChartTouchListener(BarLineChartBase<? extends BarLineScatterCandleBubbleData<? extends IBarLineScatterCandleBubbleDataSet<? extends Entry>>> chart,Matrix touchMatrix){
  super(chart);
  this.mMatrix=touchMatrix;
  this.mDragTriggerDist=Utils.convertDpToPixel(3f);
  this.mMinScalePointerDistance=Utils.convertDpToPixel(3.5f);
}",0.9
26319,"/** 
 * Highlights upon dragging, generates callbacks for the selection-listener.
 * @param e
 */
private void performHighlightDrag(MotionEvent e){
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h != null && !h.equalTo(mLastHighlighted)) {
    mLastHighlighted=h;
    mChart.highlightTouch(h);
  }
}","/** 
 * Highlights upon dragging, generates callbacks for the selection-listener.
 * @param e
 */
private void performHighlightDrag(MotionEvent e){
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h != null && !h.equalTo(mLastHighlighted)) {
    mLastHighlighted=h;
    mChart.highlightValue(h,true);
  }
}",0.9709035222052068
26320,"/** 
 * limits the maximum scale and X translation of the given matrix
 * @param matrix
 */
public void limitTransAndScale(Matrix matrix,RectF content){
  matrix.getValues(matrixBuffer);
  float curTransX=matrixBuffer[Matrix.MTRANS_X];
  float curScaleX=matrixBuffer[Matrix.MSCALE_X];
  float curTransY=matrixBuffer[Matrix.MTRANS_Y];
  float curScaleY=matrixBuffer[Matrix.MSCALE_Y];
  mScaleX=Math.min(Math.max(mMinScaleX,curScaleX),mMaxScaleX);
  mScaleY=Math.min(Math.max(mMinScaleY,curScaleY),mMaxScaleY);
  float width=0f;
  float height=0f;
  if (content != null) {
    width=content.width();
    height=content.height();
  }
  float maxTransX=-width * (mScaleX - 1f);
  float newTransX=Math.min(Math.max(curTransX,maxTransX - mTransOffsetX),mTransOffsetX);
  mTransX=newTransX;
  float maxTransY=height * (mScaleY - 1f);
  float newTransY=Math.max(Math.min(curTransY,maxTransY + mTransOffsetY),-mTransOffsetY);
  mTransY=newTransY;
  matrixBuffer[Matrix.MTRANS_X]=mTransX;
  matrixBuffer[Matrix.MSCALE_X]=mScaleX;
  matrixBuffer[Matrix.MTRANS_Y]=mTransY;
  matrixBuffer[Matrix.MSCALE_Y]=mScaleY;
  matrix.setValues(matrixBuffer);
}","/** 
 * limits the maximum scale and X translation of the given matrix
 * @param matrix
 */
public void limitTransAndScale(Matrix matrix,RectF content){
  matrix.getValues(matrixBuffer);
  float curTransX=matrixBuffer[Matrix.MTRANS_X];
  float curScaleX=matrixBuffer[Matrix.MSCALE_X];
  float curTransY=matrixBuffer[Matrix.MTRANS_Y];
  float curScaleY=matrixBuffer[Matrix.MSCALE_Y];
  mScaleX=Math.min(Math.max(mMinScaleX,curScaleX),mMaxScaleX);
  mScaleY=Math.min(Math.max(mMinScaleY,curScaleY),mMaxScaleY);
  float width=0f;
  float height=0f;
  if (content != null) {
    width=content.width();
    height=content.height();
  }
  float maxTransX=-width * (mScaleX - 1f);
  mTransX=Math.min(Math.max(curTransX,maxTransX - mTransOffsetX),mTransOffsetX);
  float maxTransY=height * (mScaleY - 1f);
  mTransY=Math.max(Math.min(curTransY,maxTransY + mTransOffsetY),-mTransOffsetY);
  matrixBuffer[Matrix.MTRANS_X]=mTransX;
  matrixBuffer[Matrix.MSCALE_X]=mScaleX;
  matrixBuffer[Matrix.MTRANS_Y]=mTransY;
  matrixBuffer[Matrix.MSCALE_Y]=mScaleY;
  matrix.setValues(matrixBuffer);
}",0.9720216606498197
26321,"public BarLineChartTouchListener(BarLineChartBase<? extends BarLineScatterCandleBubbleData<? extends IBarLineScatterCandleBubbleDataSet<? extends Entry>>> chart,Matrix touchMatrix){
  super(chart);
  this.mMatrix=touchMatrix;
}","public BarLineChartTouchListener(BarLineChartBase<? extends BarLineScatterCandleBubbleData<? extends IBarLineScatterCandleBubbleDataSet<? extends Entry>>> chart,Matrix touchMatrix){
  super(chart);
  this.mMatrix=touchMatrix;
  this.mDragTriggerDist=Utils.convertDpToPixel(3f);
}",0.8972332015810277
26322,"@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(event);
  if (event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
    if (mVelocityTracker != null) {
      mVelocityTracker.recycle();
      mVelocityTracker=null;
    }
  }
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && (!mChart.isScaleXEnabled() && !mChart.isScaleYEnabled()))   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    startAction(event);
  stopDeceleration();
saveTouchStart(event);
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
mChart.disableScroll();
saveTouchStart(event);
mSavedXDist=getXDist(event);
mSavedYDist=getYDist(event);
mSavedDist=spacing(event);
if (mSavedDist > 10f) {
if (mChart.isPinchZoomEnabled()) {
  mTouchMode=PINCH_ZOOM;
}
 else {
  if (mSavedXDist > mSavedYDist)   mTouchMode=X_ZOOM;
 else   mTouchMode=Y_ZOOM;
}
}
midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleXEnabled() || mChart.isScaleYEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 5f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut() && mChart.isDragEnabled()) {
mTouchMode=DRAG;
}
 else {
mLastGesture=ChartGesture.DRAG;
if (mChart.isHighlightPerDragEnabled()) performHighlightDrag(event);
}
}
 else if (mChart.isDragEnabled()) {
mLastGesture=ChartGesture.DRAG;
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
final VelocityTracker velocityTracker=mVelocityTracker;
final int pointerId=event.getPointerId(0);
velocityTracker.computeCurrentVelocity(1000,Utils.getMaximumFlingVelocity());
final float velocityY=velocityTracker.getYVelocity(pointerId);
final float velocityX=velocityTracker.getXVelocity(pointerId);
if (Math.abs(velocityX) > Utils.getMinimumFlingVelocity() || Math.abs(velocityY) > Utils.getMinimumFlingVelocity()) {
if (mTouchMode == DRAG && mChart.isDragDecelerationEnabled()) {
stopDeceleration();
mDecelerationLastTime=AnimationUtils.currentAnimationTimeMillis();
mDecelerationCurrentPoint=new PointF(event.getX(),event.getY());
mDecelerationVelocity=new PointF(velocityX,velocityY);
Utils.postInvalidateOnAnimation(mChart);
}
}
if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM || mTouchMode == POST_ZOOM) {
mChart.calculateOffsets();
mChart.postInvalidate();
}
mTouchMode=NONE;
mChart.enableScroll();
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
endAction(event);
break;
case MotionEvent.ACTION_POINTER_UP:
Utils.velocityTrackerPointerUpCleanUpIfNecessary(event,mVelocityTracker);
mTouchMode=POST_ZOOM;
break;
case MotionEvent.ACTION_CANCEL:
mTouchMode=NONE;
endAction(event);
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart,true);
return true;
}","@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(event);
  if (event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
    if (mVelocityTracker != null) {
      mVelocityTracker.recycle();
      mVelocityTracker=null;
    }
  }
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && (!mChart.isScaleXEnabled() && !mChart.isScaleYEnabled()))   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    startAction(event);
  stopDeceleration();
saveTouchStart(event);
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
mChart.disableScroll();
saveTouchStart(event);
mSavedXDist=getXDist(event);
mSavedYDist=getYDist(event);
mSavedDist=spacing(event);
if (mSavedDist > 10f) {
if (mChart.isPinchZoomEnabled()) {
  mTouchMode=PINCH_ZOOM;
}
 else {
  if (mSavedXDist > mSavedYDist)   mTouchMode=X_ZOOM;
 else   mTouchMode=Y_ZOOM;
}
}
midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleXEnabled() || mChart.isScaleYEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > mDragTriggerDist) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut() && mChart.isDragEnabled()) {
mTouchMode=DRAG;
}
 else {
mLastGesture=ChartGesture.DRAG;
if (mChart.isHighlightPerDragEnabled()) performHighlightDrag(event);
}
}
 else if (mChart.isDragEnabled()) {
mLastGesture=ChartGesture.DRAG;
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
final VelocityTracker velocityTracker=mVelocityTracker;
final int pointerId=event.getPointerId(0);
velocityTracker.computeCurrentVelocity(1000,Utils.getMaximumFlingVelocity());
final float velocityY=velocityTracker.getYVelocity(pointerId);
final float velocityX=velocityTracker.getXVelocity(pointerId);
if (Math.abs(velocityX) > Utils.getMinimumFlingVelocity() || Math.abs(velocityY) > Utils.getMinimumFlingVelocity()) {
if (mTouchMode == DRAG && mChart.isDragDecelerationEnabled()) {
stopDeceleration();
mDecelerationLastTime=AnimationUtils.currentAnimationTimeMillis();
mDecelerationCurrentPoint=new PointF(event.getX(),event.getY());
mDecelerationVelocity=new PointF(velocityX,velocityY);
Utils.postInvalidateOnAnimation(mChart);
}
}
if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM || mTouchMode == POST_ZOOM) {
mChart.calculateOffsets();
mChart.postInvalidate();
}
mTouchMode=NONE;
mChart.enableScroll();
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
endAction(event);
break;
case MotionEvent.ACTION_POINTER_UP:
Utils.velocityTrackerPointerUpCleanUpIfNecessary(event,mVelocityTracker);
mTouchMode=POST_ZOOM;
break;
case MotionEvent.ACTION_CANCEL:
mTouchMode=NONE;
endAction(event);
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart,true);
return true;
}",0.9972493887530562
26323,"protected void drawDataSet(Canvas c,IBarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(dataSet);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,IBarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(dataSet);
  trans.pointValuesToPixel(buffer.buffer);
  if (mChart.isDrawBarShadowEnabled()) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
    }
  }
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}",0.8320368769806972
26324,"protected void drawValue(Canvas c,String valueText,float x,float y){
  c.drawText(valueText,x,y,mValuePaint);
}","protected void drawValue(Canvas c,String valueText,float x,float y,int color){
  mValuePaint.setColor(color);
  c.drawText(valueText,x,y,mValuePaint);
}",0.844106463878327
26325,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<IBarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    final boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      IBarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      final float halfTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      float[] valuePoints=getTransformedValues(trans,dataSet,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          BarEntry e=dataSet.getEntryForIndex(j / 2);
          float val=e.getVal();
          String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,formattedValue,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=dataSet.getEntryForIndex(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,formattedValue,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,formattedValue,x,y + halfTextHeight);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<IBarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    final boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      IBarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      final float halfTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      float[] valuePoints=getTransformedValues(trans,dataSet,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          BarEntry e=dataSet.getEntryForIndex(j / 2);
          float val=e.getVal();
          String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,formattedValue,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight,dataSet.getValueTextColor(j / 2));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=dataSet.getEntryForIndex(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,formattedValue,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight,dataSet.getValueTextColor(j / 2));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String formattedValue=formatter.getFormattedValue(val,e,i,mViewPortHandler);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,formattedValue);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,formattedValue,x,y + halfTextHeight,dataSet.getValueTextColor(j / 2));
            }
          }
        }
      }
    }
  }
}",0.9899298138541348
26326,"@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0 || end >= mYVals.size())   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}","@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0 || end >= mYVals.size())   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i <= endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    float ymin=yMin(entry);
    float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}",0.991890205864005
26327,"@Override public boolean onDoubleTap(MotionEvent e){
  mLastGesture=ChartGesture.DOUBLE_TAP;
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(mChart.isScaleXEnabled() ? 1.4f : 1f,mChart.isScaleYEnabled() ? 1.4f : 1f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}","@Override public boolean onDoubleTap(MotionEvent e){
  mLastGesture=ChartGesture.DOUBLE_TAP;
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(mChart.isScaleXEnabled() ? 1.4f : 1f,mChart.isScaleYEnabled() ? 1.4f : 1f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}",0.971379011274935
26328,"/** 
 * sets the color that is used for filling the line surface
 * @param color
 */
public void setFillColor(int color){
  mFillColor=color;
}","/** 
 * sets the color that is used for filling the line surface
 * @param color
 */
public void setFillColor(int color){
  mFillColor=color;
  mFillDrawable=null;
}",0.9285714285714286
26329,"protected void drawDataSet(Canvas c,IRadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  Path surface=new Path();
  boolean hasMovedToPoint=false;
  for (int j=0; j < dataSet.getEntryCount(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=dataSet.getEntryForIndex(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (Float.isNaN(p.x))     continue;
    if (!hasMovedToPoint) {
      surface.moveTo(p.x,p.y);
      hasMovedToPoint=true;
    }
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
  final Drawable drawable=dataSet.getFillDrawable();
  if (drawable != null) {
    drawFilledPath(c,surface,drawable);
  }
 else {
    drawFilledPath(c,surface,dataSet.getFillColor(),dataSet.getFillAlpha());
  }
}","protected void drawDataSet(Canvas c,IRadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  Path surface=new Path();
  boolean hasMovedToPoint=false;
  for (int j=0; j < dataSet.getEntryCount(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=dataSet.getEntryForIndex(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (Float.isNaN(p.x))     continue;
    if (!hasMovedToPoint) {
      surface.moveTo(p.x,p.y);
      hasMovedToPoint=true;
    }
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  final Drawable drawable=dataSet.getFillDrawable();
  if (drawable != null) {
    drawFilledPath(c,surface,drawable);
  }
 else {
    drawFilledPath(c,surface,dataSet.getFillColor(),dataSet.getFillAlpha());
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}",0.8108831400535237
26330,"public void setFloatValue(Float value){
  this.floatValue=value;
}","public void setFloatValue(float value){
  this.floatValue=value;
}",0.9848484848484848
26331,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(dataSet);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 3]))     break;
    if (!mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 1]))     continue;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(mViewPortHandler.contentLeft(),buffer.buffer[j + 1],mViewPortHandler.contentRight(),buffer.buffer[j + 3],mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}","@Override protected void drawDataSet(Canvas c,IBarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(dataSet);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 3]))     break;
    if (!mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 1]))     continue;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(mViewPortHandler.contentLeft(),buffer.buffer[j + 1],mViewPortHandler.contentRight(),buffer.buffer[j + 3],mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}",0.9752431476569408
26332,"/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      IDataSet dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof IBarDataSet && ((IBarDataSet)dataSet).isStacked()) {
        IBarDataSet bds=(IBarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof IPieDataSet) {
        List<String> xVals=data.getXVals();
        IPieDataSet pds=(IPieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
          labels.add(xVals.get(j));
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}","/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      IDataSet dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof IBarDataSet && ((IBarDataSet)dataSet).isStacked()) {
        IBarDataSet bds=(IBarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof IPieDataSet) {
        List<String> xVals=data.getXVals();
        IPieDataSet pds=(IPieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
          labels.add(xVals.get(j));
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else       if (dataSet instanceof ICandleDataSet && ((ICandleDataSet)dataSet).getDecreasingColor() != ColorTemplate.COLOR_NONE) {
        colors.add(((ICandleDataSet)dataSet).getDecreasingColor());
        colors.add(((ICandleDataSet)dataSet).getIncreasingColor());
        labels.add(null);
        labels.add(dataSet.getLabel());
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}",0.9318136372725456
26333,"/** 
 * performs all kinds of initialization calculations, such as min-max and value count and sum
 */
protected void init(){
  checkLegal();
  calcMinMax(mLastStart,mLastEnd);
  calcYValueSum();
  calcYValueCount();
  calcXValAverageLength();
}","/** 
 * performs all kinds of initialization calculations, such as min-max and value count and sum
 */
protected void init(){
  checkLegal();
  calcMinMax(mLastStart,mLastEnd);
  calcYValueCount();
  calcXValAverageLength();
}",0.9596602972399152
26334,"/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param e
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    T set=mDataSets.get(dataSetIndex);
    if (mYValCount == 0) {
      mYMin=val;
      mYMax=val;
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        mLeftAxisMax=e.getVal();
        mLeftAxisMin=e.getVal();
      }
 else {
        mRightAxisMax=e.getVal();
        mRightAxisMin=e.getVal();
      }
    }
 else {
      if (mYMax < val)       mYMax=val;
      if (mYMin > val)       mYMin=val;
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
    }
    mYValCount+=1;
    mYValueSum+=val;
    handleEmptyAxis(getFirstLeft(),getFirstRight());
    set.addEntry(e);
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param e
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    T set=mDataSets.get(dataSetIndex);
    if (mYValCount == 0) {
      mYMin=val;
      mYMax=val;
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        mLeftAxisMax=e.getVal();
        mLeftAxisMin=e.getVal();
      }
 else {
        mRightAxisMax=e.getVal();
        mRightAxisMin=e.getVal();
      }
    }
 else {
      if (mYMax < val)       mYMax=val;
      if (mYMin > val)       mYMin=val;
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
    }
    mYValCount+=1;
    handleEmptyAxis(getFirstLeft(),getFirstRight());
    set.addEntry(e);
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}",0.9915356711003628
26335,"/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (d == null)   return;
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mDataSets.size() <= 0) {
    mYMax=d.getYMax();
    mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      mLeftAxisMax=d.getYMax();
      mLeftAxisMin=d.getYMin();
    }
 else {
      mRightAxisMax=d.getYMax();
      mRightAxisMin=d.getYMin();
    }
  }
 else {
    if (mYMax < d.getYMax())     mYMax=d.getYMax();
    if (mYMin > d.getYMin())     mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      if (mLeftAxisMax < d.getYMax())       mLeftAxisMax=d.getYMax();
      if (mLeftAxisMin > d.getYMin())       mLeftAxisMin=d.getYMin();
    }
 else {
      if (mRightAxisMax < d.getYMax())       mRightAxisMax=d.getYMax();
      if (mRightAxisMin > d.getYMin())       mRightAxisMin=d.getYMin();
    }
  }
  mDataSets.add(d);
  handleEmptyAxis(getFirstLeft(),getFirstRight());
}","/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (d == null)   return;
  mYValCount+=d.getEntryCount();
  if (mDataSets.size() <= 0) {
    mYMax=d.getYMax();
    mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      mLeftAxisMax=d.getYMax();
      mLeftAxisMin=d.getYMin();
    }
 else {
      mRightAxisMax=d.getYMax();
      mRightAxisMin=d.getYMin();
    }
  }
 else {
    if (mYMax < d.getYMax())     mYMax=d.getYMax();
    if (mYMin > d.getYMin())     mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      if (mLeftAxisMax < d.getYMax())       mLeftAxisMax=d.getYMax();
      if (mLeftAxisMin > d.getYMin())       mLeftAxisMin=d.getYMin();
    }
 else {
      if (mRightAxisMax < d.getYMax())       mRightAxisMax=d.getYMax();
      if (mRightAxisMin > d.getYMin())       mRightAxisMin=d.getYMin();
    }
  }
  mDataSets.add(d);
  handleEmptyAxis(getFirstLeft(),getFirstRight());
}",0.9838709677419356
26336,"/** 
 * Creates a new DataSet object with the given values it represents. Also, a label that describes the DataSet can be specified. The label can also be used to retrieve the DataSet from a ChartData object.
 * @param yVals
 * @param label
 */
public DataSet(List<T> yVals,String label){
  this.mLabel=label;
  this.mYVals=yVals;
  if (mYVals == null)   mYVals=new ArrayList<T>();
  mColors=new ArrayList<Integer>();
  mColors.add(Color.rgb(140,234,255));
  calcMinMax(mLastStart,mLastEnd);
  calcYValueSum();
}","/** 
 * Creates a new DataSet object with the given values it represents. Also, a label that describes the DataSet can be specified. The label can also be used to retrieve the DataSet from a ChartData object.
 * @param yVals
 * @param label
 */
public DataSet(List<T> yVals,String label){
  this.mLabel=label;
  this.mYVals=yVals;
  if (mYVals == null)   mYVals=new ArrayList<T>();
  mColors=new ArrayList<Integer>();
  mColors.add(Color.rgb(140,234,255));
  calcMinMax(mLastStart,mLastEnd);
}",0.981094527363184
26337,"/** 
 * Removes the first Entry (at index 0) of this DataSet from the entries array. Returns true if successful, false if not.
 * @return
 */
public boolean removeFirst(){
  T entry=mYVals.remove(0);
  boolean removed=entry != null;
  if (removed) {
    float val=entry.getVal();
    mYValueSum-=val;
    calcMinMax(mLastStart,mLastEnd);
  }
  return removed;
}","/** 
 * Removes the first Entry (at index 0) of this DataSet from the entries array. Returns true if successful, false if not.
 * @return
 */
public boolean removeFirst(){
  T entry=mYVals.remove(0);
  boolean removed=entry != null;
  if (removed) {
    float val=entry.getVal();
    calcMinMax(mLastStart,mLastEnd);
  }
  return removed;
}",0.9101283880171184
26338,"/** 
 * Use this method to tell the data set that the underlying data has changed
 */
public void notifyDataSetChanged(){
  calcMinMax(mLastStart,mLastEnd);
  calcYValueSum();
}","/** 
 * Use this method to tell the data set that the underlying data has changed
 */
public void notifyDataSetChanged(){
  calcMinMax(mLastStart,mLastEnd);
}",0.9432835820895522
26339,"/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to the end of the list. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntry(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYValueSum+=val;
  mYVals.add((T)e);
}","/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to the end of the list. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntry(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYVals.add((T)e);
}",0.9831111111111112
26340,"/** 
 * Removes the last Entry (at index size-1) of this DataSet from the entries array. Returns true if successful, false if not.
 * @return
 */
public boolean removeLast(){
  if (mYVals.size() <= 0)   return false;
  T entry=mYVals.remove(mYVals.size() - 1);
  boolean removed=entry != null;
  if (removed) {
    float val=entry.getVal();
    mYValueSum-=val;
    calcMinMax(mLastStart,mLastEnd);
  }
  return removed;
}","/** 
 * Removes the last Entry (at index size-1) of this DataSet from the entries array. Returns true if successful, false if not.
 * @return
 */
public boolean removeLast(){
  if (mYVals.size() <= 0)   return false;
  T entry=mYVals.remove(mYVals.size() - 1);
  boolean removed=entry != null;
  if (removed) {
    float val=entry.getVal();
    calcMinMax(mLastStart,mLastEnd);
  }
  return removed;
}",0.9744835965978128
26341,"/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntryOrdered(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYValueSum+=val;
  if (mYVals.size() > 0 && mYVals.get(mYVals.size() - 1).getXIndex() > e.getXIndex()) {
    int closestIndex=getEntryIndex(e.getXIndex(),Rounding.UP);
    mYVals.add(closestIndex,(T)e);
    return;
  }
  mYVals.add((T)e);
}","/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntryOrdered(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  if (mYVals.size() > 0 && mYVals.get(mYVals.size() - 1).getXIndex() > e.getXIndex()) {
    int closestIndex=getEntryIndex(e.getXIndex(),Rounding.UP);
    mYVals.add(closestIndex,(T)e);
    return;
  }
  mYVals.add((T)e);
}",0.9881619937694704
26342,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_bubblechart_noseekbar);
  mChart=(BubbleChart)findViewById(R.id.chart1);
  setup(mChart);
  mChart.getXAxis().setDrawGridLines(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_bubblechart_noseekbar);
  mChart=(BubbleChart)findViewById(R.id.chart1);
  setup(mChart);
  mChart.getXAxis().setDrawGridLines(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.setPinchZoom(true);
}",0.9084423305588584
26343,"private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBubbleDataSet<RealmDemoData> set=new RealmBubbleDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  set.setLabel(""String_Node_Str"");
  set.setColors(ColorTemplate.COLORFUL_COLORS);
  ArrayList<IBubbleDataSet> dataSets=new ArrayList<IBubbleDataSet>();
  dataSets.add(set);
  BubbleData data=new BubbleData(result,""String_Node_Str"",dataSets);
  styleData(data);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}","private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBubbleDataSet<RealmDemoData> set=new RealmBubbleDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  set.setLabel(""String_Node_Str"");
  set.setColors(ColorTemplate.COLORFUL_COLORS,110);
  ArrayList<IBubbleDataSet> dataSets=new ArrayList<IBubbleDataSet>();
  dataSets.add(set);
  BubbleData data=new BubbleData(result,""String_Node_Str"",dataSets);
  styleData(data);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}",0.9966159052453468
26344,"@Override protected void onResume(){
  super.onResume();
  writeToDBBubble(12);
  setData();
}","@Override protected void onResume(){
  super.onResume();
  writeToDBBubble(10);
  setData();
}",0.9893617021276596
26345,"@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}","@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0 || end >= mYVals.size())   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}",0.9849056603773584
26346,"@Override public void calcMinMax(int start,int end){
  if (mValues == null)   return;
  if (mValues.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mValues.size() - 1;
 else   endValue=end;
  mYMin=yMin(mValues.get(start));
  mYMax=yMax(mValues.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mValues.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}","@Override public void calcMinMax(int start,int end){
  if (mValues == null)   return;
  if (mValues.size() == 0)   return;
  int endValue;
  if (end == 0 || end >= mValues.size())   endValue=mValues.size() - 1;
 else   endValue=end;
  mYMin=yMin(mValues.get(start));
  mYMax=yMax(mValues.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mValues.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}",0.9844042420461634
26347,"private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBarDataSet<RealmDemoData> set=new RealmBarDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"");
  System.out.println(""String_Node_Str"" + set.getStackSize());
  set.setValueTextSize(9f);
  set.setColors(getColors(set.getStackSize()));
  set.setLabel(""String_Node_Str"");
  set.setStackLabels(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  System.out.println(""String_Node_Str"" + set.getStackSize());
  ArrayList<IBarDataSet> dataSets=new ArrayList<IBarDataSet>();
  dataSets.add(set);
  BarData data=new BarData(result,""String_Node_Str"",dataSets);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}","private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBarDataSet<RealmDemoData> set=new RealmBarDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  set.setValueTextSize(9f);
  set.setColors(getColors(set.getStackSize()));
  set.setLabel(""String_Node_Str"");
  set.setStackLabels(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  ArrayList<IBarDataSet> dataSets=new ArrayList<IBarDataSet>();
  dataSets.add(set);
  BarData data=new BarData(result,""String_Node_Str"",dataSets);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}",0.9019337016574586
26348,"@Override protected void onResume(){
  super.onResume();
  writeToDBStack(4);
  setData();
}","@Override protected void onResume(){
  super.onResume();
  writeToDBStack(200);
  setData();
}",0.978494623655914
26349,"public RealmFloat(float value){
  this.value=value;
}","public RealmFloat(float floatValue){
  this.floatValue=floatValue;
}",0.8264462809917356
26350,"public RealmBarDataSet(RealmResults<T> results,String yValuesField,String xIndexField){
  super(results,yValuesField,xIndexField);
  mHighLightColor=Color.rgb(0,0,0);
  calcStackSize();
}","/** 
 * Constructor for supporting stacked values.
 * @param results
 * @param yValuesField
 * @param xIndexField
 * @param stackValueFieldName
 */
public RealmBarDataSet(RealmResults<T> results,String yValuesField,String xIndexField,String stackValueFieldName){
  super(results,yValuesField,xIndexField);
  this.mStackValueFieldName=stackValueFieldName;
  mHighLightColor=Color.rgb(0,0,0);
  buildData(this.results);
}",0.5742574257425742
26351,"@Override public void build(RealmResults<T> results){
  for (  T realmObject : results) {
    DynamicRealmObject dynamicObject=new DynamicRealmObject(realmObject);
    try {
      float value=dynamicObject.getFloat(mValuesField);
      mValues.add(new BarEntry(value,dynamicObject.getInt(mIndexField)));
    }
 catch (    IllegalArgumentException e) {
      DynamicRealmList list=dynamicObject.getList(mValuesField);
      float[] values=new float[list.size()];
      int i=0;
      for (      DynamicRealmObject o : list) {
        values[i]=o.getFloat(""String_Node_Str"");
        i++;
      }
      mValues.add(new BarEntry(values,dynamicObject.getInt(mIndexField)));
    }
  }
  calcStackSize();
}","@Override public void build(RealmResults<T> results){
}",0.1456953642384106
26352,"@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i <= endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}","@Override public void calcMinMax(int start,int end){
  if (mYVals == null)   return;
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mYMin=yMin(mYVals.get(start));
  mYMax=yMax(mYVals.get(start));
  for (int i=start; i < endValue; i++) {
    final BubbleEntry entry=mYVals.get(i);
    final float ymin=yMin(entry);
    final float ymax=yMax(entry);
    if (ymin < mYMin) {
      mYMin=ymin;
    }
    if (ymax > mYMax) {
      mYMax=ymax;
    }
    final float xmin=xMin(entry);
    final float xmax=xMax(entry);
    if (xmin < mXMin) {
      mXMin=xmin;
    }
    if (xmax > mXMax) {
      mXMax=xmax;
    }
    final float size=largestSize(entry);
    if (size > mMaxSize) {
      mMaxSize=size;
    }
  }
}",0.9993618379068284
26353,"/** 
 * Returns the lowest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getLowestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] <= 0) ? 0 : (int)(pts[0] + 1);
}","/** 
 * Returns the lowest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getLowestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] <= 0) ? 0 : (int)Math.round(pts[0] + 1.0f);
}",0.9819694868238558
26354,"/** 
 * Returns the highest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getHighestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentRight(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] >= mData.getXValCount()) ? mData.getXValCount() - 1 : (int)pts[0];
}","/** 
 * Returns the highest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getHighestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentRight(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (Math.round(pts[0]) >= mData.getXValCount()) ? mData.getXValCount() - 1 : (int)Math.round(pts[0]);
}",0.9703703703703704
26355,"/** 
 * Returns the first Entry index found at the given xIndex with binary search. If the no Entry at the specified x-index is found, this method returns the index at the closest x-index. Returns -1 if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param x
 * @return
 */
public int getEntryIndex(int x){
  int low=0;
  int high=mYVals.size() - 1;
  int closest=-1;
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      while (m > 0 && mYVals.get(m - 1).getXIndex() == x)       m--;
      return m;
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
    closest=m;
  }
  return closest;
}","/** 
 * Returns the first Entry index found at the given xIndex with binary search. If the no Entry at the specified x-index is found, this method returns the index as determined by the given rounding mode. Returns -1 if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param x
 * @return
 */
public int getEntryIndex(int x,Rounding rounding){
  int low=0;
  int high=mYVals.size() - 1;
  int closest=-1;
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      while (m > 0 && mYVals.get(m - 1).getXIndex() == x)       m--;
      return m;
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
    closest=m;
  }
  if (closest != -1) {
    int closestXIndex=mYVals.get(closest).getXIndex();
    if (rounding == Rounding.UP) {
      if (closestXIndex < x && closest < mYVals.size() - 1) {
        ++closest;
      }
    }
 else     if (rounding == Rounding.DOWN) {
      if (closestXIndex > x && closest > 0) {
        --closest;
      }
    }
  }
  return closest;
}",0.7653276955602537
26356,"/** 
 * Returns the first Entry object found at the given xIndex with binary search. If the no Entry at the specified x-index is found, this method returns the index at the closest x-index. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param x
 * @return
 */
public T getEntryForXIndex(int x){
  int index=getEntryIndex(x);
  if (index > -1)   return mYVals.get(index);
  return null;
}","/** 
 * Returns the first Entry object found at the given xIndex with binary search. If the no Entry at the specified x-index is found, this method returns the index as determined by the given rounding mode. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param x
 * @return
 */
public T getEntryForXIndex(int x,Rounding rounding){
  int index=getEntryIndex(x,rounding);
  if (index > -1)   return mYVals.get(index);
  return null;
}",0.9164265129682996
26357,"/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntryOrdered(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYValueSum+=val;
  if (mYVals.size() > 0 && mYVals.get(mYVals.size() - 1).getXIndex() > e.getXIndex()) {
    int closestIndex=getEntryIndex(e.getXIndex());
    if (mYVals.get(closestIndex).getXIndex() < e.getXIndex())     closestIndex++;
    mYVals.add(closestIndex,(T)e);
    return;
  }
  mYVals.add((T)e);
}","/** 
 * Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
 * @param e
 */
@SuppressWarnings(""String_Node_Str"") public void addEntryOrdered(Entry e){
  if (e == null)   return;
  float val=e.getVal();
  if (mYVals == null) {
    mYVals=new ArrayList<T>();
  }
  if (mYVals.size() == 0) {
    mYMax=val;
    mYMin=val;
  }
 else {
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
  }
  mYValueSum+=val;
  if (mYVals.size() > 0 && mYVals.get(mYVals.size() - 1).getXIndex() > e.getXIndex()) {
    int closestIndex=getEntryIndex(e.getXIndex(),Rounding.UP);
    mYVals.add(closestIndex,(T)e);
    return;
  }
  mYVals.add((T)e);
}",0.9256198347107438
26358,"/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,List<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int diff=(entryFrom == entryTo) ? 1 : 0;
  int minx=Math.max(dataSet.getEntryPosition(entryFrom) - diff,0);
  int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryPosition(entryTo) + 1),entries.size());
  int range=(maxx - minx) * 4 - 4;
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.limitFrom(minx);
  buffer.limitTo(maxx);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < range; j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,0,range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,minx,maxx,trans);
  }
}","/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,List<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4 - 4;
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.limitFrom(minx);
  buffer.limitTo(maxx);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < range; j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,0,range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,minx,maxx,trans);
  }
}",0.9195516811955168
26359,"@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int diff=(entryFrom == entryTo) ? 1 : 0;
      int minx=Math.max(dataSet.getEntryPosition(entryFrom) - diff,0);
      int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryPosition(entryTo) + 1),entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        Entry entry=entries.get(j / 2 + minx);
        drawValue(c,dataSet.getValueFormatter(),entry.getVal(),entry,i,x,y - valOffset);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        Entry entry=entries.get(j / 2 + minx);
        drawValue(c,dataSet.getValueFormatter(),entry.getVal(),entry,i,x,y - valOffset);
      }
    }
  }
}",0.9034109021357986
26360,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int diff=(entryFrom == entryTo) ? 1 : 0;
  int minx=Math.max(dataSet.getEntryPosition(entryFrom) - diff,0);
  int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryPosition(entryTo) + 1),entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry prevPrev=entries.get(minx);
    Entry prev=entries.get(minx);
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(cur.getXIndex() - prev.getXIndex()) * intensity;
    prevDy=(cur.getVal() - prev.getVal()) * intensity;
    curDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    curDy=(next.getVal() - cur.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 1, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j == 1 ? 0 : j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry prevPrev=entries.get(minx);
    Entry prev=entries.get(minx);
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(cur.getXIndex() - prev.getXIndex()) * intensity;
    prevDy=(cur.getVal() - prev.getVal()) * intensity;
    curDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    curDy=(next.getVal() - cur.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 1, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j == 1 ? 0 : j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9546940681924334
26361,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled() || dataSet.getEntryCount() == 0)     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int diff=(entryFrom == entryTo) ? 1 : 0;
    int minx=Math.max(dataSet.getEntryPosition(entryFrom) - diff,0);
    int maxx=Math.min(Math.max(minx + 2,dataSet.getEntryPosition(entryTo) + 1),entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled() || dataSet.getEntryCount() == 0)     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX,DataSet.Rounding.DOWN);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX,DataSet.Rounding.UP);
    int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.9230344827586208
26362,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart_noseekbar);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  leftAxis.setTypeface(tf);
  mChart.getXAxis().setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  leftAxis.setTypeface(tf);
  mChart.getXAxis().setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
}",0.9848812095032398
26363,"private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmLineDataSet<RealmDemoData> set=new RealmLineDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"");
  set.setValueTextSize(9f);
  ArrayList<ILineDataSet> dataSets=new ArrayList<ILineDataSet>();
  dataSets.add(set);
  LineData data=new LineData(result,""String_Node_Str"",dataSets);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}","private void setData(){
  RealmResults<RealmDemoData> result=mRealm.allObjects(RealmDemoData.class);
  RealmBarDataSet<RealmDemoData> set=new RealmBarDataSet<RealmDemoData>(result,""String_Node_Str"",""String_Node_Str"");
  set.setValueTextSize(9f);
  ArrayList<IBarDataSet> dataSets=new ArrayList<IBarDataSet>();
  dataSets.add(set);
  BarData data=new BarData(result,""String_Node_Str"",dataSets);
  mChart.setData(data);
  mChart.animateY(1400,Easing.EasingOption.EaseInOutQuart);
}",0.9564315352697096
26364,"protected static List<String> toXVals(RealmResults<? extends RealmObject> result,String xValuesField){
  List<String> xVals=new ArrayList<>();
  for (  RealmObject object : result) {
    DynamicRealmObject dynamicObject=new DynamicRealmObject(object);
    xVals.add(dynamicObject.getString(xValuesField));
  }
  return xVals;
}","/** 
 * Transforms the given Realm-ResultSet into a String array by using the provided xValuesField.
 * @param result
 * @param xValuesField
 * @return
 */
protected static List<String> toXVals(RealmResults<? extends RealmObject> result,String xValuesField){
  List<String> xVals=new ArrayList<>();
  for (  RealmObject object : result) {
    DynamicRealmObject dynamicObject=new DynamicRealmObject(object);
    xVals.add(dynamicObject.getString(xValuesField));
  }
  return xVals;
}",0.8074074074074075
26365,"@Override public String[] getStackLabels(){
  return new String[0];
}","@Override public String[] getStackLabels(){
  return null;
}",0.8837209302325582
26366,"/** 
 * Returns the maximum number of bars that can be stacked upon another in this DataSet.
 * @return
 */
int getStackSize();","/** 
 * Returns the maximum number of bars that can be stacked upon another in this DataSet. This should return 1 for non stacked bars, and > 1 for stacked bars.
 * @return
 */
int getStackSize();",0.7863777089783281
26367,"@Override public void initBuffers(){
  BarData barData=mChart.getBarData();
  mBarBuffers=new BarBuffer[barData.getDataSetCount()];
  for (int i=0; i < mBarBuffers.length; i++) {
    IBarDataSet set=barData.getDataSetByIndex(i);
    mBarBuffers[i]=new BarBuffer(set.getEntryCount() * 4 * set.getStackSize(),barData.getGroupSpace(),barData.getDataSetCount(),set.isStacked());
  }
}","@Override public void initBuffers(){
  BarData barData=mChart.getBarData();
  mBarBuffers=new BarBuffer[barData.getDataSetCount()];
  for (int i=0; i < mBarBuffers.length; i++) {
    IBarDataSet set=barData.getDataSetByIndex(i);
    mBarBuffers[i]=new BarBuffer(set.getEntryCount() * 4 * (set.isStacked() ? set.getStackSize() : 1),barData.getGroupSpace(),barData.getDataSetCount(),set.isStacked());
  }
}",0.7908163265306123
26368,"@Override public void initBuffers(){
  BarData barData=mChart.getBarData();
  mBarBuffers=new HorizontalBarBuffer[barData.getDataSetCount()];
  for (int i=0; i < mBarBuffers.length; i++) {
    IBarDataSet set=barData.getDataSetByIndex(i);
    mBarBuffers[i]=new HorizontalBarBuffer(set.getEntryCount() * 4 * set.getStackSize(),barData.getGroupSpace(),barData.getDataSetCount(),set.isStacked());
  }
}","@Override public void initBuffers(){
  BarData barData=mChart.getBarData();
  mBarBuffers=new HorizontalBarBuffer[barData.getDataSetCount()];
  for (int i=0; i < mBarBuffers.length; i++) {
    IBarDataSet set=barData.getDataSetByIndex(i);
    mBarBuffers[i]=new HorizontalBarBuffer(set.getEntryCount() * 4 * (set.isStacked() ? set.getStackSize() : 1),barData.getGroupSpace(),barData.getDataSetCount(),set.isStacked());
  }
}",0.8009708737864077
26369,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHole:
{
    if (mChart.isDrawHoleEnabled())     mChart.setDrawHoleEnabled(false);
 else     mChart.setDrawHoleEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionDrawCenter:
{
  if (mChart.isDrawCenterTextEnabled())   mChart.setDrawCenterText(false);
 else   mChart.setDrawCenterText(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleXVals:
{
mChart.setDrawSliceText(!mChart.isDrawSliceTextEnabled());
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
case R.id.actionTogglePercent:
mChart.setUsePercentValues(!mChart.isUsePercentValuesEnabled());
mChart.invalidate();
break;
case R.id.animateX:
{
mChart.animateX(1400);
break;
}
case R.id.animateY:
{
mChart.animateY(1400);
break;
}
case R.id.animateXY:
{
mChart.animateXY(1400,1400);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      IDataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHole:
{
    if (mChart.isDrawHoleEnabled())     mChart.setDrawHoleEnabled(false);
 else     mChart.setDrawHoleEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionDrawCenter:
{
  if (mChart.isDrawCenterTextEnabled())   mChart.setDrawCenterText(false);
 else   mChart.setDrawCenterText(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleXVals:
{
mChart.setDrawSliceText(!mChart.isDrawSliceTextEnabled());
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
case R.id.actionTogglePercent:
mChart.setUsePercentValues(!mChart.isUsePercentValuesEnabled());
mChart.invalidate();
break;
case R.id.animateX:
{
mChart.animateX(1400);
break;
}
case R.id.animateY:
{
mChart.animateY(1400);
break;
}
case R.id.animateXY:
{
mChart.animateXY(1400,1400);
break;
}
}
return true;
}",0.9995838535164376
26370,"public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  data.setDrawValues(false);
  mChart.setData(data);
  mChart.invalidate();
}","public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<IRadarDataSet> sets=new ArrayList<IRadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  data.setDrawValues(false);
  mChart.setData(data);
  mChart.invalidate();
}",0.9990982867448152
26371,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.getData() != null) {
      mChart.getData().setHighlightEnabled(!mChart.getData().isHighlightEnabled());
      mChart.invalidate();
    }
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.notifyDataSetChanged();
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360,Easing.EasingOption.EaseInCubic);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      IDataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.getData() != null) {
      mChart.getData().setHighlightEnabled(!mChart.getData().isHighlightEnabled());
      mChart.invalidate();
    }
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<IRadarDataSet> sets=(ArrayList<IRadarDataSet>)mChart.getData().getDataSets();
for (IRadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.notifyDataSetChanged();
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360,Easing.EasingOption.EaseInCubic);
break;
}
}
return true;
}",0.9988186650915536
26372,"/** 
 * Set to true if the DataSet should be drawn filled (surface), and not just as a line, disabling this will give great performance boost! default: false
 * @param filled
 */
public void setDrawFilled(boolean filled){
  mDrawFilled=filled;
}","@Override public void setDrawFilled(boolean filled){
  mDrawFilled=filled;
}",0.4361370716510903
26373,"/** 
 * Returns the index of the DataSet this x-index belongs to.
 * @param xIndex
 * @return
 */
public int getDataSetIndexForIndex(int xIndex){
  List<? extends DataSet<? extends Entry>> dataSets=mData.getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    if (dataSets.get(i).getEntryForXIndex(xIndex) != null)     return i;
  }
  return -1;
}","/** 
 * Returns the index of the DataSet this x-index belongs to.
 * @param xIndex
 * @return
 */
public int getDataSetIndexForIndex(int xIndex){
  List<IPieDataSet> dataSets=mData.getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    if (dataSets.get(i).getEntryForXIndex(xIndex) != null)     return i;
  }
  return -1;
}",0.9343065693430656
26374,"/** 
 * calculates the needed angles for the chart slices
 */
private void calcAngles(){
  mDrawAngles=new float[mData.getYValCount()];
  mAbsoluteAngles=new float[mData.getYValCount()];
  List<PieDataSet> dataSets=mData.getDataSets();
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    PieDataSet set=dataSets.get(i);
    List<Entry> entries=set.getYVals();
    for (int j=0; j < entries.size(); j++) {
      mDrawAngles[cnt]=calcAngle(Math.abs(entries.get(j).getVal()));
      if (cnt == 0) {
        mAbsoluteAngles[cnt]=mDrawAngles[cnt];
      }
 else {
        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];
      }
      cnt++;
    }
  }
}","/** 
 * calculates the needed angles for the chart slices
 */
private void calcAngles(){
  mDrawAngles=new float[mData.getYValCount()];
  mAbsoluteAngles=new float[mData.getYValCount()];
  List<IPieDataSet> dataSets=mData.getDataSets();
  int cnt=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    IPieDataSet set=dataSets.get(i);
    List<Entry> entries=set.getYVals();
    for (int j=0; j < entries.size(); j++) {
      mDrawAngles[cnt]=calcAngle(Math.abs(entries.get(j).getVal()));
      if (cnt == 0) {
        mAbsoluteAngles[cnt]=mDrawAngles[cnt];
      }
 else {
        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];
      }
      cnt++;
    }
  }
}",0.9985358711566618
26375,"/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
public List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    final float yVal=dataSet.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    vals.add(new SelectionDetail(yVal,i,dataSet));
  }
  return vals;
}","/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
public List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    IDataSet<?> dataSet=mData.getDataSetByIndex(i);
    final float yVal=dataSet.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    vals.add(new SelectionDetail(yVal,i,dataSet));
  }
  return vals;
}",0.9992992291520671
26376,"@Override public Entry getEntryForXIndex(int x){
  return null;
}","@Override public Entry getEntryForXIndex(int xIndex){
  return null;
}",0.9629629629629628
26377,"@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  IPieDataSet set : pieData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9992301770592764
26378,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0, maxEntry=Math.min((int)Math.ceil(entries.size() * mAnimator.getPhaseX()),entries.size()); j < maxEntry; j++) {
      Entry entry=entries.get(j);
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entry.getVal() / data.getYValueSum() * 100f : entry.getVal();
      ValueFormatter formatter=dataSet.getValueFormatter();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        drawValue(c,formatter,value,entry,0,x,y);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight / 2f,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f);
      }
      cnt++;
    }
  }
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<IPieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    IPieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") + Utils.convertDpToPixel(4f);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0, maxEntry=Math.min((int)Math.ceil(entries.size() * mAnimator.getPhaseX()),entries.size()); j < maxEntry; j++) {
      Entry entry=entries.get(j);
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entry.getVal() / data.getYValueSum() * 100f : entry.getVal();
      ValueFormatter formatter=dataSet.getValueFormatter();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        drawValue(c,formatter,value,entry,0,x,y);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight / 2f,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        drawValue(c,formatter,value,entry,0,x,y + lineHeight / 2f);
      }
      cnt++;
    }
  }
}",0.9995240361732508
26379,"/** 
 * This gives all pie-slices a rounded edge.
 * @param c
 */
protected void drawRoundedSlices(Canvas c){
  if (!mChart.isDrawRoundedSlicesEnabled())   return;
  PieDataSet dataSet=mChart.getData().getDataSet();
  if (!dataSet.isVisible())   return;
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float circleRadius=(r - (r * mChart.getHoleRadius() / 100f)) / 2f;
  List<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  float angle=mChart.getRotationAngle();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[j];
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      float x=(float)((r - circleRadius) * Math.cos(Math.toRadians((angle + newangle) * mAnimator.getPhaseY())) + center.x);
      float y=(float)((r - circleRadius) * Math.sin(Math.toRadians((angle + newangle) * mAnimator.getPhaseY())) + center.y);
      mRenderPaint.setColor(dataSet.getColor(j));
      mBitmapCanvas.drawCircle(x,y,circleRadius,mRenderPaint);
    }
    angle+=newangle * mAnimator.getPhaseX();
  }
}","/** 
 * This gives all pie-slices a rounded edge.
 * @param c
 */
protected void drawRoundedSlices(Canvas c){
  if (!mChart.isDrawRoundedSlicesEnabled())   return;
  IPieDataSet dataSet=mChart.getData().getDataSet();
  if (!dataSet.isVisible())   return;
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float circleRadius=(r - (r * mChart.getHoleRadius() / 100f)) / 2f;
  List<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  float angle=mChart.getRotationAngle();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[j];
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      float x=(float)((r - circleRadius) * Math.cos(Math.toRadians((angle + newangle) * mAnimator.getPhaseY())) + center.x);
      float y=(float)((r - circleRadius) * Math.sin(Math.toRadians((angle + newangle) * mAnimator.getPhaseY())) + center.y);
      mRenderPaint.setColor(dataSet.getColor(j));
      mBitmapCanvas.drawCircle(x,y,circleRadius,mRenderPaint);
    }
    angle+=newangle * mAnimator.getPhaseX();
  }
}",0.9995435874030124
26380,"protected void drawDataSet(Canvas c,PieDataSet dataSet){
  float angle=mChart.getRotationAngle();
  List<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[j];
    float sliceSpace=dataSet.getSliceSpace();
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        mBitmapCanvas.drawArc(mChart.getCircleBox(),(angle + sliceSpace / 2f) * mAnimator.getPhaseY(),(newangle - sliceSpace / 2f) * mAnimator.getPhaseY(),true,mRenderPaint);
      }
    }
    angle+=newangle * mAnimator.getPhaseX();
  }
}","protected void drawDataSet(Canvas c,IPieDataSet dataSet){
  float angle=mChart.getRotationAngle();
  List<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[j];
    float sliceSpace=dataSet.getSliceSpace();
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        mBitmapCanvas.drawArc(mChart.getCircleBox(),(angle + sliceSpace / 2f) * mAnimator.getPhaseY(),(newangle - sliceSpace / 2f) * mAnimator.getPhaseY(),true,mRenderPaint);
      }
    }
    angle+=newangle * mAnimator.getPhaseX();
  }
}",0.9993485342019544
26381,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float rotationAngle=mChart.getRotationAngle();
  float angle=0f;
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    PieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    if (xIndex == 0)     angle=rotationAngle;
 else     angle=rotationAngle + absoluteAngles[xIndex - 1];
    angle*=mAnimator.getPhaseY();
    float sliceDegrees=drawAngles[xIndex];
    float shift=set.getSelectionShift();
    RectF circleBox=mChart.getCircleBox();
    RectF highlighted=new RectF(circleBox.left - shift,circleBox.top - shift,circleBox.right + shift,circleBox.bottom + shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    mBitmapCanvas.drawArc(highlighted,angle + set.getSliceSpace() / 2f,sliceDegrees * mAnimator.getPhaseY() - set.getSliceSpace() / 2f,true,mRenderPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float rotationAngle=mChart.getRotationAngle();
  float angle=0f;
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    IPieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    if (xIndex == 0)     angle=rotationAngle;
 else     angle=rotationAngle + absoluteAngles[xIndex - 1];
    angle*=mAnimator.getPhaseY();
    float sliceDegrees=drawAngles[xIndex];
    float shift=set.getSelectionShift();
    RectF circleBox=mChart.getCircleBox();
    RectF highlighted=new RectF(circleBox.left - shift,circleBox.top - shift,circleBox.right + shift,circleBox.bottom + shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    mBitmapCanvas.drawArc(highlighted,angle + set.getSliceSpace() / 2f,sliceDegrees * mAnimator.getPhaseY() - set.getSliceSpace() / 2f,true,mRenderPaint);
  }
}",0.999553770638108
26382,"@Override public void drawData(Canvas c){
  RadarData radarData=mChart.getData();
  for (  RadarDataSet set : radarData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  RadarData radarData=mChart.getData();
  for (  IRadarDataSet set : radarData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9977116704805492
26383,"protected void drawDataSet(Canvas c,RadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  List<Entry> entries=dataSet.getYVals();
  Path surface=new Path();
  boolean hasMovedToPoint=false;
  for (int j=0; j < entries.size(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=entries.get(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (Float.isNaN(p.x))     continue;
    if (!hasMovedToPoint) {
      surface.moveTo(p.x,p.y);
      hasMovedToPoint=true;
    }
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  if (dataSet.isDrawFilledEnabled()) {
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setAlpha(dataSet.getFillAlpha());
    c.drawPath(surface,mRenderPaint);
    mRenderPaint.setAlpha(255);
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}","protected void drawDataSet(Canvas c,IRadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  List<Entry> entries=dataSet.getYVals();
  Path surface=new Path();
  boolean hasMovedToPoint=false;
  for (int j=0; j < entries.size(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=entries.get(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (Float.isNaN(p.x))     continue;
    if (!hasMovedToPoint) {
      surface.moveTo(p.x,p.y);
      hasMovedToPoint=true;
    }
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  if (dataSet.isDrawFilledEnabled()) {
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setAlpha(dataSet.getFillAlpha());
    c.drawPath(surface,mRenderPaint);
    mRenderPaint.setAlpha(255);
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}",0.9995604395604396
26384,"@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry entry=entries.get(j);
      PointF p=Utils.getPosition(center,(entry.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      drawValue(c,dataSet.getValueFormatter(),entry.getVal(),entry,i,p.x,p.y - yoffset);
    }
  }
}","@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    IRadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry entry=entries.get(j);
      PointF p=Utils.getPosition(center,(entry.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      drawValue(c,dataSet.getValueFormatter(),entry.getVal(),entry,i,p.x,p.y - yoffset);
    }
  }
}",0.9993861264579496
26385,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    if (e == null || e.getXIndex() != xIndex)     continue;
    int j=set.getEntryIndex(e);
    float y=(e.getVal() - mChart.getYChartMin());
    if (Float.isNaN(y))     continue;
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,p.y};
    drawHighlightLines(c,pts,set);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    IRadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    if (e == null || e.getXIndex() != xIndex)     continue;
    int j=set.getEntryIndex(e);
    float y=(e.getVal() - mChart.getYChartMin());
    if (Float.isNaN(y))     continue;
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,p.y};
    drawHighlightLines(c,pts,set);
  }
}",0.9993891264508248
26386,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val1=(float)(Math.random() * mult) + mult / 3;
    yVals1.add(new BarEntry((int)val1,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add((int)yVals1.get(i).getVal() + ""String_Node_Str"");
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColors(ColorTemplate.VORDIPLOM_COLORS);
  set1.setDrawValues(false);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val1=(float)(Math.random() * mult) + mult / 3;
    yVals1.add(new BarEntry((int)val1,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add((int)yVals1.get(i).getVal() + ""String_Node_Str"");
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColors(ColorTemplate.VORDIPLOM_COLORS);
  set1.setDrawValues(false);
  ArrayList<IBarDataSet> dataSets=new ArrayList<IBarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
  mChart.invalidate();
}",0.998968008255934
26387,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.getData() != null) {
      mChart.getData().setHighlightEnabled(!mChart.getData().isHighlightEnabled());
      mChart.invalidate();
    }
    break;
  }
case R.id.actionTogglePinch:
{
  if (mChart.isPinchZoomEnabled())   mChart.setPinchZoom(false);
 else   mChart.setPinchZoom(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleAutoScaleMinMax:
{
mChart.setAutoScaleMinMaxEnabled(!mChart.isAutoScaleMinMaxEnabled());
mChart.notifyDataSetChanged();
break;
}
case R.id.actionToggleHighlightArrow:
{
if (mChart.isDrawHighlightArrowEnabled()) mChart.setDrawHighlightArrow(false);
 else mChart.setDrawHighlightArrow(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,25);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToGallery(""String_Node_Str"" + System.currentTimeMillis(),50)) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      IDataSet set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.getData() != null) {
      mChart.getData().setHighlightEnabled(!mChart.getData().isHighlightEnabled());
      mChart.invalidate();
    }
    break;
  }
case R.id.actionTogglePinch:
{
  if (mChart.isPinchZoomEnabled())   mChart.setPinchZoom(false);
 else   mChart.setPinchZoom(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleAutoScaleMinMax:
{
mChart.setAutoScaleMinMaxEnabled(!mChart.isAutoScaleMinMaxEnabled());
mChart.notifyDataSetChanged();
break;
}
case R.id.actionToggleHighlightArrow:
{
if (mChart.isDrawHighlightArrowEnabled()) mChart.setDrawHighlightArrow(false);
 else mChart.setDrawHighlightArrow(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,25);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToGallery(""String_Node_Str"" + System.currentTimeMillis(),50)) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}",0.998968540484786
26388,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  RealmLineDataSet set1=new RealmLineDataSet();
  ArrayList<RealmLineDataSet> dataSets=new ArrayList<RealmLineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(null,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  RealmLineDataSet set1=new RealmLineDataSet();
  ArrayList<RealmLineDataSet> dataSets=new ArrayList<RealmLineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData();
  mChart.setData(data);
}",0.9887640449438202
26389,"@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
  mXChartMin=-0.5f;
  mXChartMax=(float)mData.getXValCount() - 0.5f;
  if (mRenderer != null) {
    for (    BubbleDataSet set : mData.getDataSets()) {
      final float xmin=set.getXMin();
      final float xmax=set.getXMax();
      if (xmin < mXChartMin)       mXChartMin=xmin;
      if (xmax > mXChartMax)       mXChartMax=xmax;
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
  mXChartMin=-0.5f;
  mXChartMax=(float)mData.getXValCount() - 0.5f;
  if (mRenderer != null) {
    for (    IBubbleDataSet set : mData.getDataSets()) {
      final float xmin=set.getXMin();
      final float xmax=set.getXMax();
      if (xmin < mXChartMin)       mXChartMin=xmin;
      if (xmax > mXChartMax)       mXChartMax=xmax;
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}",0.9990205680705192
26390,"@Override protected void calcMinMax(){
  super.calcMinMax();
  if (getBarData() != null || getCandleData() != null || getBubbleData() != null) {
    mXChartMin=-0.5f;
    mXChartMax=mData.getXVals().size() - 0.5f;
    if (getBubbleData() != null) {
      for (      BubbleDataSet set : getBubbleData().getDataSets()) {
        final float xmin=set.getXMin();
        final float xmax=set.getXMax();
        if (xmin < mXChartMin)         mXChartMin=xmin;
        if (xmax > mXChartMax)         mXChartMax=xmax;
      }
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (getBarData() != null || getCandleData() != null || getBubbleData() != null) {
    mXChartMin=-0.5f;
    mXChartMax=mData.getXVals().size() - 0.5f;
    if (getBubbleData() != null) {
      for (      IBubbleDataSet set : getBubbleData().getDataSets()) {
        final float xmin=set.getXMin();
        final float xmax=set.getXMax();
        if (xmin < mXChartMin)         mXChartMin=xmin;
        if (xmax > mXChartMax)         mXChartMax=xmax;
      }
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}",0.9991311902693312
26391,"@Override public RectF getBarBounds(BarEntry e){
  BarDataSet set=mData.getDataSetForEntry(e);
  if (set == null)   return null;
  float barspace=set.getBarSpace();
  float y=e.getVal();
  float x=e.getXIndex();
  float spaceHalf=barspace / 2f;
  float top=x - 0.5f + spaceHalf;
  float bottom=x + 0.5f - spaceHalf;
  float left=y >= 0 ? y : 0;
  float right=y <= 0 ? y : 0;
  RectF bounds=new RectF(left,top,right,bottom);
  getTransformer(set.getAxisDependency()).rectValueToPixel(bounds);
  return bounds;
}","@Override public RectF getBarBounds(BarEntry e){
  IBarDataSet set=mData.getDataSetForEntry(e);
  if (set == null)   return null;
  float barspace=set.getBarSpace();
  float y=e.getVal();
  float x=e.getXIndex();
  float spaceHalf=barspace / 2f;
  float top=x - 0.5f + spaceHalf;
  float bottom=x + 0.5f - spaceHalf;
  float left=y >= 0 ? y : 0;
  float right=y <= 0 ? y : 0;
  RectF bounds=new RectF(left,top,right,bottom);
  getTransformer(set.getAxisDependency()).rectValueToPixel(bounds);
  return bounds;
}",0.9990205680705192
26392,"/** 
 * Returns true if this DataSet is stacked (stacksize > 1) or not.
 * @return
 */
public boolean isStacked(){
  return mStackSize > 1 ? true : false;
}","@Override public boolean isStacked(){
  return mStackSize > 1 ? true : false;
}",0.6297872340425532
26393,"/** 
 * Returns the alpha value (transparency) that is used for drawing the highlight indicator.
 * @return
 */
public int getHighLightAlpha(){
  return mHighLightAlpha;
}","@Override public int getHighLightAlpha(){
  return mHighLightAlpha;
}",0.525
26394,"/** 
 * Returns the color used for drawing the bar-shadows. The bar shadows is a surface behind the bar that indicates the maximum value.
 * @return
 */
public int getBarShadowColor(){
  return mBarShadowColor;
}","@Override public int getBarShadowColor(){
  return mBarShadowColor;
}",0.4483985765124555
26395,"/** 
 * returns the space between bars as the actual value (0 - 1.0f)
 * @return
 */
public float getBarSpace(){
  return mBarSpace;
}","@Override public float getBarSpace(){
  return mBarSpace;
}",0.5492227979274611
26396,"/** 
 * Returns the maximum number of bars that can be stacked upon another in this DataSet.
 * @return
 */
public int getStackSize(){
  return mStackSize;
}","@Override public int getStackSize(){
  return mStackSize;
}",0.4907407407407407
26397,"public float getHighlightCircleWidth(){
  return mHighlightCircleWidth;
}","@Override public float getHighlightCircleWidth(){
  return mHighlightCircleWidth;
}",0.935897435897436
26398,"public float getXMax(){
  return mXMax;
}","@Override public float getXMax(){
  return mXMax;
}",0.8913043478260869
26399,"public float getMaxSize(){
  return mMaxSize;
}","@Override public float getMaxSize(){
  return mMaxSize;
}",0.903846153846154
26400,"public float getXMin(){
  return mXMin;
}","@Override public float getXMin(){
  return mXMin;
}",0.8913043478260869
26401,"/** 
 * Returns the decreasing color.
 * @return
 */
public int getDecreasingColor(){
  return mDecreasingColor;
}","@Override public int getDecreasingColor(){
  return mDecreasingColor;
}",0.7027027027027027
26402,"/** 
 * Is the shadow color same as the candle color?
 * @return
 */
public boolean getShadowColorSameAsCandle(){
  return mShadowColorSameAsCandle;
}","@Override public boolean getShadowColorSameAsCandle(){
  return mShadowColorSameAsCandle;
}",0.6887966804979253
26403,"/** 
 * Returns paint style when open > close
 * @return
 */
public Paint.Style getDecreasingPaintStyle(){
  return mDecreasingPaintStyle;
}","@Override public Paint.Style getDecreasingPaintStyle(){
  return mDecreasingPaintStyle;
}",0.7336244541484717
26404,"/** 
 * Returns paint style when open <= close
 * @return
 */
public Paint.Style getIncreasingPaintStyle(){
  return mIncreasingPaintStyle;
}","@Override public Paint.Style getIncreasingPaintStyle(){
  return mIncreasingPaintStyle;
}",0.7304347826086957
26405,"/** 
 * Returns shadow color for all entries
 * @return
 */
public int getShadowColor(){
  return mShadowColor;
}","@Override public int getShadowColor(){
  return mShadowColor;
}",0.6704545454545454
26406,"/** 
 * Returns the width of the candle-shadow-line in pixels.
 * @return
 */
public float getShadowWidth(){
  return mShadowWidth;
}","@Override public float getShadowWidth(){
  return mShadowWidth;
}",0.5959595959595959
26407,"/** 
 * Returns the increasing color.
 * @return
 */
public int getIncreasingColor(){
  return mIncreasingColor;
}","@Override public int getIncreasingColor(){
  return mIncreasingColor;
}",0.7027027027027027
26408,"/** 
 * Returns the space that is left out on the left and right side of each candle.
 * @return
 */
public float getBodySpace(){
  return mBodySpace;
}","@Override public float getBodySpace(){
  return mBodySpace;
}",0.5446009389671361
26409,"@Override public int getXOffset(){
  return -(getWidth() / 2);
}","@Override public int getXOffset(float xpos){
  return -(getWidth() / 2);
}",0.927536231884058
26410,"@Override public int getYOffset(){
  return -getHeight();
}","@Override public int getYOffset(float ypos){
  return -getHeight();
}",0.921875
26411,"@Override public int getXOffset(){
  return -(getWidth() / 2);
}","@Override public int getXOffset(float xpos){
  return -(getWidth() / 2);
}",0.927536231884058
26412,"@Override public int getYOffset(){
  return -getHeight();
}","@Override public int getYOffset(float ypos){
  return -getHeight();
}",0.921875
26413,"/** 
 * Use this to return the desired offset you wish the MarkerView to have on the x-axis. By returning -(getWidth() / 2) you will center the MarkerView horizontally.
 * @return
 */
public abstract int getXOffset();","/** 
 * Use this to return the desired offset you wish the MarkerView to have on the x-axis. By returning -(getWidth() / 2) you will center the MarkerView horizontally.
 * @param xpos the position on the x-axis in pixels where the marker is drawn
 * @return
 */
public abstract int getXOffset(float xpos);",0.8314176245210728
26414,"/** 
 * This method enables a specified custom MarkerView to update it's content everytime the MarkerView is redrawn.
 * @param e The Entry the MarkerView belongs to. This can also be any subclass of Entry, like BarEntry or CandleEntry, simply cast it at runtime.
 * @param highlight the highlight object contains information about the highlighted value such as it's dataset-index, the selected range or stack-index (only stacked bar entries).
 */
public abstract void refreshContent(Entry e,Highlight highlight);","/** 
 * This method enables a specified custom MarkerView to update it's content everytime the MarkerView is redrawn.
 * @param e         The Entry the MarkerView belongs to. This can also be any subclass of Entry, like BarEntry orCandleEntry, simply cast it at runtime.
 * @param highlight the highlight object contains information about the highlighted value such as it's dataset-index, theselected range or stack-index (only stacked bar entries).
 */
public abstract void refreshContent(Entry e,Highlight highlight);",0.9903100775193798
26415,"/** 
 * Draws the MarkerView on the given position on the screen with the given Canvas object.
 * @param canvas
 * @param posx
 * @param posy
 */
public void draw(Canvas canvas,float posx,float posy){
  posx+=getXOffset();
  posy+=getYOffset();
  canvas.translate(posx,posy);
  draw(canvas);
  canvas.translate(-posx,-posy);
}","/** 
 * Draws the MarkerView on the given position on the screen with the given Canvas object.
 * @param canvas
 * @param posx
 * @param posy
 */
public void draw(Canvas canvas,float posx,float posy){
  posx+=getXOffset(posx);
  posy+=getYOffset(posy);
  canvas.translate(posx,posy);
  draw(canvas);
  canvas.translate(-posx,-posy);
}",0.987878787878788
26416,"/** 
 * Use this to return the desired position offset you wish the MarkerView to have on the y-axis. By returning -getHeight() you will cause the MarkerView to be above the selected value.
 * @return
 */
public abstract int getYOffset();","/** 
 * Use this to return the desired position offset you wish the MarkerView to have on the y-axis. By returning -getHeight() you will cause the MarkerView to be above the selected value.
 * @param ypos the position on the y-axis in pixels where the marker is drawn
 * @return
 */
public abstract int getYOffset(float ypos);",0.8439716312056738
26417,"@Override public void calculateOffsets(){
  super.calculateOffsets();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float radius=diameter / 2f;
  PointF c=getCenterOffsets();
  final List<PieDataSet> dataSets=mData.getDataSets();
  float maxShift=0.f;
  for (int i=0; i < dataSets.size(); i++) {
    final float shift=dataSets.get(i).getSelectionShift();
    if (shift > maxShift)     maxShift=shift;
  }
  final float halfMaxShift=maxShift / 2.f;
  mCircleBox.set(c.x - radius + halfMaxShift,c.y - radius + halfMaxShift,c.x + radius - halfMaxShift,c.y + radius - halfMaxShift);
}","@Override public void calculateOffsets(){
  super.calculateOffsets();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float radius=diameter / 2f;
  PointF c=getCenter();
  float shift=mData.getDataSet().getSelectionShift();
  mCircleBox.set(c.x - radius + shift,c.y - radius + shift,c.x + radius - shift,c.y + radius - shift);
}",0.4595744680851064
26418,"@Override public void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    float fullLegendWidth=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getFormSize() + mLegend.getFormToTextSpace();
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      float yOffset=getRequiredLegendOffset();
      legendBottom=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
 else     if (mLegend.getPosition() == LegendPosition.ABOVE_CHART_LEFT || mLegend.getPosition() == LegendPosition.ABOVE_CHART_RIGHT || mLegend.getPosition() == LegendPosition.ABOVE_CHART_CENTER) {
      float yOffset=getRequiredLegendOffset();
      legendTop=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float minOffset=Utils.convertDpToPixel(mMinOffset);
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled() && x.isDrawLabelsEnabled()) {
      minOffset=Math.max(minOffset,x.mLabelWidth);
    }
  }
  legendTop+=getExtraTopOffset();
  legendRight+=getExtraRightOffset();
  legendBottom+=getExtraBottomOffset();
  legendLeft+=getExtraLeftOffset();
  float offsetLeft=Math.max(minOffset,legendLeft);
  float offsetTop=Math.max(minOffset,legendTop);
  float offsetRight=Math.max(minOffset,legendRight);
  float offsetBottom=Math.max(minOffset,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}","@Override public void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    float fullLegendWidth=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getFormSize() + mLegend.getFormToTextSpace();
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      float yOffset=getRequiredLegendOffset();
      legendBottom=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
 else     if (mLegend.getPosition() == LegendPosition.ABOVE_CHART_LEFT || mLegend.getPosition() == LegendPosition.ABOVE_CHART_RIGHT || mLegend.getPosition() == LegendPosition.ABOVE_CHART_CENTER) {
      float yOffset=getRequiredLegendOffset();
      legendTop=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float minOffset=0f;
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled() && x.isDrawLabelsEnabled()) {
      minOffset=x.mLabelWidth;
    }
  }
  legendTop+=getExtraTopOffset();
  legendRight+=getExtraRightOffset();
  legendBottom+=getExtraBottomOffset();
  legendLeft+=getExtraLeftOffset();
  float offsetLeft=Math.max(minOffset,legendLeft);
  float offsetTop=Math.max(minOffset,legendTop);
  float offsetRight=Math.max(minOffset,legendRight);
  float offsetBottom=Math.max(minOffset,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}",0.9932934131736528
26419,"private SpannableString generateCenterSpannableText(){
  SpannableString s=new SpannableString(""String_Node_Str"");
  s.setSpan(new RelativeSizeSpan(1.7f),0,14,0);
  return s;
}","private SpannableString generateCenterSpannableText(){
  SpannableString s=new SpannableString(""String_Node_Str"");
  s.setSpan(new RelativeSizeSpan(1.7f),0,14,0);
  s.setSpan(new StyleSpan(Typeface.NORMAL),14,s.length() - 15,0);
  s.setSpan(new ForegroundColorSpan(Color.GRAY),14,s.length() - 15,0);
  s.setSpan(new RelativeSizeSpan(.8f),14,s.length() - 15,0);
  s.setSpan(new StyleSpan(Typeface.ITALIC),s.length() - 14,s.length(),0);
  return s;
}",0.5544871794871795
26420,"/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  SpannableString centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();
    RectF holeRect=mRectBuffer[0];
    holeRect.left=center.x - innerRadius;
    holeRect.top=center.y - innerRadius;
    holeRect.right=center.x + innerRadius;
    holeRect.bottom=center.y + innerRadius;
    RectF boundingRect=mRectBuffer[1];
    boundingRect.set(holeRect);
    float radiusPercent=mChart.getCenterTextRadiusPercent();
    if (radiusPercent > 0.0) {
      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);
    }
    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {
      mCenterTextLastBounds.set(boundingRect);
      mCenterTextLastValue=centerText;
      float width=mCenterTextLastBounds.width();
      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_NORMAL,1.f,0.f,false);
    }
    float layoutHeight=mCenterTextLayout.getHeight();
    c.save();
    c.translate(boundingRect.centerX(),boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);
    mCenterTextLayout.draw(c);
    c.restore();
  }
}","/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  SpannableString centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();
    RectF holeRect=mRectBuffer[0];
    holeRect.left=center.x - innerRadius;
    holeRect.top=center.y - innerRadius;
    holeRect.right=center.x + innerRadius;
    holeRect.bottom=center.y + innerRadius;
    RectF boundingRect=mRectBuffer[1];
    boundingRect.set(holeRect);
    float radiusPercent=mChart.getCenterTextRadiusPercent();
    if (radiusPercent > 0.0) {
      boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);
    }
    if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {
      mCenterTextLastBounds.set(boundingRect);
      mCenterTextLastValue=centerText;
      float width=mCenterTextLastBounds.width();
      mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(width),1.f),Layout.Alignment.ALIGN_CENTER,1.f,0.f,false);
    }
    float layoutHeight=mCenterTextLayout.getHeight();
    c.save();
    c.translate(boundingRect.left,boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);
    mCenterTextLayout.draw(c);
    c.restore();
  }
}",0.9930366333636088
26421,"public PieChartRenderer(PieChart chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(animator,viewPortHandler);
  mChart=chart;
  mHolePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHolePaint.setColor(Color.WHITE);
  mHolePaint.setStyle(Style.FILL);
  mTransparentCirclePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTransparentCirclePaint.setColor(Color.WHITE);
  mTransparentCirclePaint.setStyle(Style.FILL);
  mTransparentCirclePaint.setAlpha(100);
  mCenterTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mCenterTextPaint.setColor(Color.BLACK);
  mCenterTextPaint.setTextSize(Utils.convertDpToPixel(12f));
  mCenterTextPaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(13f));
  mValuePaint.setColor(Color.WHITE);
  mValuePaint.setTextAlign(Align.CENTER);
}","public PieChartRenderer(PieChart chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(animator,viewPortHandler);
  mChart=chart;
  mHolePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHolePaint.setColor(Color.WHITE);
  mHolePaint.setStyle(Style.FILL);
  mTransparentCirclePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTransparentCirclePaint.setColor(Color.WHITE);
  mTransparentCirclePaint.setStyle(Style.FILL);
  mTransparentCirclePaint.setAlpha(100);
  mCenterTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mCenterTextPaint.setColor(Color.BLACK);
  mCenterTextPaint.setTextSize(Utils.convertDpToPixel(12f));
  mValuePaint.setTextSize(Utils.convertDpToPixel(13f));
  mValuePaint.setColor(Color.WHITE);
  mValuePaint.setTextAlign(Align.CENTER);
}",0.9699680511182108
26422,"/** 
 * Sets the number of web-lines that should be skipped on chart web before the next one is drawn. This targets the lines that come from the center of the RadarChart.
 * @param count if count = 1 -> 1 line is skipped in between
 */
public void setSkipWebLineCount(int count){
  if (count < 0)   count=0;
  mWebModulus=count + 1;
}","/** 
 * Sets the number of web-lines that should be skipped on chart web before the next one is drawn. This targets the lines that come from the center of the RadarChart.
 * @param count if count = 1 -> 1 line is skipped in between
 */
public void setSkipWebLineCount(int count){
  mSkipWebLineCount=Math.max(0,count);
}",0.8807339449541285
26423,"/** 
 * Returns the modulus that is used for skipping web-lines.
 * @return
 */
public int getSkipWebLineCount(){
  return mWebModulus;
}","/** 
 * Returns the modulus that is used for skipping web-lines.
 * @return
 */
public int getSkipWebLineCount(){
  return mSkipWebLineCount;
}",0.9428571428571428
26424,"protected void drawCubicFill(LineDataSet dataSet,Path spline,Transformer trans,int from,int to){
  float fillMin=dataSet.getFillFormatter().getFillLinePosition(dataSet,mChart);
  spline.lineTo(to - 1,fillMin);
  spline.lineTo(from,fillMin);
  spline.close();
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  trans.pathValueToPixel(spline);
  mBitmapCanvas.drawPath(spline,mRenderPaint);
  mRenderPaint.setAlpha(255);
}","protected void drawCubicFill(LineDataSet dataSet,Path spline,Transformer trans,int from,int to){
  if (to - from <= 1)   return;
  float fillMin=dataSet.getFillFormatter().getFillLinePosition(dataSet,mChart);
  spline.lineTo(to - 1,fillMin);
  spline.lineTo(from,fillMin);
  spline.close();
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  trans.pathValueToPixel(spline);
  mBitmapCanvas.drawPath(spline,mRenderPaint);
  mRenderPaint.setAlpha(255);
}",0.9696969696969696
26425,"protected void drawWeb(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  float rotationangle=mChart.getRotationAngle();
  PointF center=mChart.getCenterOffsets();
  mWebPaint.setStrokeWidth(mChart.getWebLineWidth());
  mWebPaint.setColor(mChart.getWebColor());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  for (int i=0; i < mChart.getData().getXValCount(); i+=mChart.getSkipWebLineCount()) {
    PointF p=Utils.getPosition(center,mChart.getYRange() * factor,sliceangle * i + rotationangle);
    c.drawLine(center.x,center.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mChart.getWebLineWidthInner());
  mWebPaint.setColor(mChart.getWebColorInner());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  int labelCount=mChart.getYAxis().mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mChart.getData().getXValCount(); i++) {
      float r=(mChart.getYAxis().mEntries[j] - mChart.getYChartMin()) * factor;
      PointF p1=Utils.getPosition(center,r,sliceangle * i + rotationangle);
      PointF p2=Utils.getPosition(center,r,sliceangle * (i + 1) + rotationangle);
      c.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}","protected void drawWeb(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  float rotationangle=mChart.getRotationAngle();
  PointF center=mChart.getCenterOffsets();
  mWebPaint.setStrokeWidth(mChart.getWebLineWidth());
  mWebPaint.setColor(mChart.getWebColor());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  final int xIncrements=1 + mChart.getSkipWebLineCount();
  for (int i=0; i < mChart.getData().getXValCount(); i+=xIncrements) {
    PointF p=Utils.getPosition(center,mChart.getYRange() * factor,sliceangle * i + rotationangle);
    c.drawLine(center.x,center.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mChart.getWebLineWidthInner());
  mWebPaint.setColor(mChart.getWebColorInner());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  int labelCount=mChart.getYAxis().mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mChart.getData().getXValCount(); i++) {
      float r=(mChart.getYAxis().mEntries[j] - mChart.getYChartMin()) * factor;
      PointF p1=Utils.getPosition(center,r,sliceangle * i + rotationangle);
      PointF p2=Utils.getPosition(center,r,sliceangle * (i + 1) + rotationangle);
      c.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}",0.9599007854485324
26426,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      final float y1;
      final float y2;
      if (isStack) {
        y1=h.getRange().from;
        y2=h.getRange().to * mAnimator.getPhaseY();
      }
 else {
        y1=e.getVal();
        y2=0.f;
      }
      prepareBarHighlight(x,y1,y2,barspaceHalf,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        float[] values=new float[9];
        trans.getPixelToValueMatrix().getValues(values);
        final float xToYRel=Math.abs(values[Matrix.MSCALE_Y] / values[Matrix.MSCALE_X]);
        final float arrowWidth=set.getBarSpace() / 2.f;
        final float arrowHeight=arrowWidth * xToYRel;
        final float yArrow=y1 > -y2 ? y1 : y1;
        Path arrow=new Path();
        arrow.moveTo(x + 0.4f,yArrow + offsetY);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY - arrowHeight);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY + arrowHeight);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      final float y1;
      final float y2;
      if (isStack) {
        y1=h.getRange().from;
        y2=h.getRange().to;
      }
 else {
        y1=e.getVal();
        y2=0.f;
      }
      prepareBarHighlight(x,y1,y2,barspaceHalf,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        float[] values=new float[9];
        trans.getPixelToValueMatrix().getValues(values);
        final float xToYRel=Math.abs(values[Matrix.MSCALE_Y] / values[Matrix.MSCALE_X]);
        final float arrowWidth=set.getBarSpace() / 2.f;
        final float arrowHeight=arrowWidth * xToYRel;
        final float yArrow=(y1 > -y2 ? y1 : y1) * mAnimator.getPhaseY();
        Path arrow=new Path();
        arrow.moveTo(x + 0.4f,yArrow + offsetY);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY - arrowHeight);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY + arrowHeight);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.988431281813975
26427,"/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixelHorizontal(RectF r,float phaseY){
  if (r.left > 0)   r.left*=phaseY;
 else   r.right*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}","/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixelHorizontal(RectF r,float phaseY){
  r.left*=phaseY;
  r.right*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}",0.963963963963964
26428,"/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixel(RectF r,float phaseY){
  if (r.top > 0)   r.top*=phaseY;
 else   r.bottom*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}","/** 
 * Transform a rectangle with all matrices with potential animation phases.
 * @param r
 * @param phaseY
 */
public void rectValueToPixel(RectF r,float phaseY){
  r.top*=phaseY;
  r.bottom*=phaseY;
  mMatrixValueToPx.mapRect(r);
  mViewPortHandler.getMatrixTouch().mapRect(r);
  mMatrixOffset.mapRect(r);
}",0.9643410852713178
26429,"@Override protected float[] getMarkerPosition(Entry e,Highlight highlight){
  int dataSetIndex=highlight.getDataSetIndex();
  float xPos=e.getXIndex();
  float yPos=e.getVal();
  if (this instanceof BarChart) {
    BarData bd=(BarData)mData;
    float space=bd.getGroupSpace();
    int setCount=mData.getDataSetCount();
    int i=e.getXIndex();
    if (this instanceof HorizontalBarChart) {
      float y=i + i * (setCount - 1) + dataSetIndex + space * i + space / 2f;
      yPos=y;
      BarEntry entry=(BarEntry)e;
      if (entry.getVals() != null) {
        xPos=highlight.getRange().to;
      }
 else {
        xPos=e.getVal();
      }
    }
 else {
      float x=i + i * (setCount - 1) + dataSetIndex + space * i + space / 2f;
      xPos=x;
      BarEntry entry=(BarEntry)e;
      if (entry.getVals() != null) {
        yPos=highlight.getRange().to;
      }
 else {
        yPos=e.getVal();
      }
    }
  }
  float[] pts=new float[]{xPos,yPos * mAnimator.getPhaseY()};
  getTransformer(mData.getDataSetByIndex(dataSetIndex).getAxisDependency()).pointValuesToPixel(pts);
  return pts;
}","@Override protected float[] getMarkerPosition(Entry e,Highlight highlight){
  int dataSetIndex=highlight.getDataSetIndex();
  float xPos=e.getXIndex();
  float yPos=e.getVal();
  if (this instanceof BarChart) {
    BarData bd=(BarData)mData;
    float space=bd.getGroupSpace();
    int setCount=mData.getDataSetCount();
    int i=e.getXIndex();
    if (this instanceof HorizontalBarChart) {
      float y=i + i * (setCount - 1) + dataSetIndex + space * i + space / 2f;
      yPos=y;
      BarEntry entry=(BarEntry)e;
      if (entry.getVals() != null) {
        xPos=highlight.getRange().to;
      }
 else {
        xPos=e.getVal();
      }
      xPos*=mAnimator.getPhaseY();
    }
 else {
      float x=i + i * (setCount - 1) + dataSetIndex + space * i + space / 2f;
      xPos=x;
      BarEntry entry=(BarEntry)e;
      if (entry.getVals() != null) {
        yPos=highlight.getRange().to;
      }
 else {
        yPos=e.getVal();
      }
      yPos*=mAnimator.getPhaseY();
    }
  }
 else {
    yPos*=mAnimator.getPhaseY();
  }
  float[] pts=new float[]{xPos,yPos};
  getTransformer(mData.getDataSetByIndex(dataSetIndex).getAxisDependency()).pointValuesToPixel(pts);
  return pts;
}",0.9389547650417216
26430,"@Override protected void calcMinMax(){
  super.calcMinMax();
  if (getBarData() != null || getCandleData() != null || getBubbleData() != null) {
    mXChartMin=-0.5f;
    mXChartMax=mData.getXVals().size() - 0.5f;
    if (getBubbleData() != null) {
      for (      BubbleDataSet set : getBubbleData().getDataSets()) {
        final float xmin=set.getXMin();
        final float xmax=set.getXMax();
        if (xmin < mXChartMin)         mXChartMin=xmin;
        if (xmax > mXChartMax)         mXChartMax=xmax;
      }
    }
  }
 else {
    mXChartMin=0f;
    mXChartMax=mData.getXValCount() - 1;
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (getBarData() != null || getCandleData() != null || getBubbleData() != null) {
    mXChartMin=-0.5f;
    mXChartMax=mData.getXVals().size() - 0.5f;
    if (getBubbleData() != null) {
      for (      BubbleDataSet set : getBubbleData().getDataSets()) {
        final float xmin=set.getXMin();
        final float xmax=set.getXMax();
        if (xmin < mXChartMin)         mXChartMin=xmin;
        if (xmax > mXChartMax)         mXChartMax=xmax;
      }
    }
  }
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}",0.8739770867430442
26431,"@Override public void calculateOffsets(){
  super.calculateOffsets();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float boxSize=diameter / 2f;
  PointF c=getCenterOffsets();
  mCircleBox.set(c.x - boxSize,c.y - boxSize,c.x + boxSize,c.y + boxSize);
}","@Override public void calculateOffsets(){
  super.calculateOffsets();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float radius=diameter / 2f;
  PointF c=getCenterOffsets();
  final List<PieDataSet> dataSets=mData.getDataSets();
  float maxShift=0.f;
  for (int i=0; i < dataSets.size(); i++) {
    final float shift=dataSets.get(i).getSelectionShift();
    if (shift > maxShift)     maxShift=shift;
  }
  final float halfMaxShift=maxShift / 2.f;
  mCircleBox.set(c.x - radius + halfMaxShift,c.y - radius + halfMaxShift,c.x + radius - halfMaxShift,c.y + radius - halfMaxShift);
}",0.441108545034642
26432,"@Override protected void calcMinMax(int start,int end){
  if (mYVals.size() == 0)   return;
  List<CandleEntry> entries=mYVals;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mLastStart=start;
  mLastEnd=endValue;
  mYMin=mYVals.get(start).getLow();
  mYMax=mYVals.get(start).getHigh();
  for (int i=start + 1; i <= endValue; i++) {
    CandleEntry e=entries.get(i);
    if (e.getLow() < mYMin)     mYMin=e.getLow();
    if (e.getHigh() > mYMax)     mYMax=e.getHigh();
  }
}","@Override protected void calcMinMax(int start,int end){
  if (mYVals.size() == 0)   return;
  List<CandleEntry> entries=mYVals;
  int endValue;
  if (end == 0 || end >= mYVals.size())   endValue=mYVals.size() - 1;
 else   endValue=end;
  mLastStart=start;
  mLastEnd=endValue;
  mYMin=mYVals.get(start).getLow();
  mYMax=mYVals.get(start).getHigh();
  for (int i=start + 1; i <= endValue; i++) {
    CandleEntry e=entries.get(i);
    if (e.getLow() < mYMin)     mYMin=e.getLow();
    if (e.getHigh() > mYMax)     mYMax=e.getHigh();
  }
}",0.9771428571428572
26433,"@Override public void drawData(Canvas c){
  BarData barData=mChart.getBarData();
  for (int i=0; i < barData.getDataSetCount(); i++) {
    BarDataSet set=barData.getDataSetByIndex(i);
    if (set.isVisible()) {
      drawDataSet(c,set,i);
    }
  }
}","@Override public void drawData(Canvas c){
  BarData barData=mChart.getBarData();
  for (int i=0; i < barData.getDataSetCount(); i++) {
    BarDataSet set=barData.getDataSetByIndex(i);
    if (set.isVisible() && set.getEntryCount() > 0) {
      drawDataSet(c,set,i);
    }
  }
}",0.9487666034155596
26434,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}",0.9953366365491112
26435,"@Override public void drawData(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  for (  BubbleDataSet set : bubbleData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  for (  BubbleDataSet set : bubbleData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9370629370629372
26436,"@Override public void drawValues(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  if (bubbleData == null)   return;
  if (bubbleData.getYValCount() < (int)(Math.ceil((float)(mChart.getMaxVisibleCount()) * mViewPortHandler.getScaleX()))) {
    final List<BubbleDataSet> dataSets=bubbleData.getDataSets();
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
    for (    BubbleDataSet dataSet : dataSets) {
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      final float phaseX=mAnimator.getPhaseX();
      final float phaseY=mAnimator.getPhaseY();
      final float alpha=phaseX == 1 ? phaseY : phaseX;
      int valueTextColor=dataSet.getValueTextColor();
      valueTextColor=Color.argb(Math.round(255.f * alpha),Color.red(valueTextColor),Color.green(valueTextColor),Color.blue(valueTextColor));
      mValuePaint.setColor(valueTextColor);
      final List<BubbleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
      final float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesBubble(entries,phaseX,phaseY,minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))         continue;
        final BubbleEntry entry=entries.get(j / 2 + minx);
        final float val=entry.getSize();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y + (0.5f * lineHeight),mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  if (bubbleData == null)   return;
  if (bubbleData.getYValCount() < (int)(Math.ceil((float)(mChart.getMaxVisibleCount()) * mViewPortHandler.getScaleX()))) {
    final List<BubbleDataSet> dataSets=bubbleData.getDataSets();
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
    for (    BubbleDataSet dataSet : dataSets) {
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      final float phaseX=mAnimator.getPhaseX();
      final float phaseY=mAnimator.getPhaseY();
      final float alpha=phaseX == 1 ? phaseY : phaseX;
      int valueTextColor=dataSet.getValueTextColor();
      valueTextColor=Color.argb(Math.round(255.f * alpha),Color.red(valueTextColor),Color.green(valueTextColor),Color.blue(valueTextColor));
      mValuePaint.setColor(valueTextColor);
      final List<BubbleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
      final float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesBubble(entries,phaseX,phaseY,minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))         continue;
        final BubbleEntry entry=entries.get(j / 2 + minx);
        final float val=entry.getSize();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y + (0.5f * lineHeight),mValuePaint);
      }
    }
  }
}",0.9916098584163608
26437,"@Override public void drawData(Canvas c){
  CandleData candleData=mChart.getCandleData();
  for (  CandleDataSet set : candleData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  CandleData candleData=mChart.getCandleData();
  for (  CandleDataSet set : candleData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9370629370629372
26438,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    if (dataSet.getShadowColorSameAsCandle()) {
      if (e.getOpen() > e.getClose())       mRenderPaint.setColor(dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getDecreasingColor());
 else       if (e.getOpen() < e.getClose())       mRenderPaint.setColor(dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getIncreasingColor());
 else       mRenderPaint.setColor(dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getShadowColor());
    }
 else {
      mRenderPaint.setColor(dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getShadowColor());
    }
    mRenderPaint.setStyle(Paint.Style.STROKE);
    c.drawLine(shadowBuffer.buffer[j],shadowBuffer.buffer[j + 1],shadowBuffer.buffer[j + 2],shadowBuffer.buffer[j + 3],mRenderPaint);
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(dataSet.getShadowColor());
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  int minx=Math.max(mMinX,0);
  int maxx=Math.min(mMaxX + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    if (dataSet.getShadowColorSameAsCandle()) {
      if (e.getOpen() > e.getClose())       mRenderPaint.setColor(dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getDecreasingColor());
 else       if (e.getOpen() < e.getClose())       mRenderPaint.setColor(dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getIncreasingColor());
 else       mRenderPaint.setColor(dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getShadowColor());
    }
 else {
      mRenderPaint.setColor(dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ? dataSet.getColor(j) : dataSet.getShadowColor());
    }
    mRenderPaint.setStyle(Paint.Style.STROKE);
    c.drawLine(shadowBuffer.buffer[j],shadowBuffer.buffer[j + 1],shadowBuffer.buffer[j + 2],shadowBuffer.buffer[j + 3],mRenderPaint);
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(dataSet.getShadowColor());
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.9721706864564008
26439,"@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      int minx=Math.max(mMinX,0);
      int maxx=Math.min(mMaxX + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}",0.9058561897702
26440,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    final boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      final float halfTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          String valueText=formatter.getFormattedValue(val);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,valueText,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String valueText=formatter.getFormattedValue(val);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,valueText,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String valueText=formatter.getFormattedValue(val);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,valueText,x,y + halfTextHeight);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    final boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      final float halfTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          String valueText=formatter.getFormattedValue(val);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,valueText,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String valueText=formatter.getFormattedValue(val);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,valueText,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1] + halfTextHeight);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String valueText=formatter.getFormattedValue(val);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,valueText,x,y + halfTextHeight);
            }
          }
        }
      }
    }
  }
}",0.9966237602869804
26441,"@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}",0.9804205946337926
26442,"@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}",0.9893617021276596
26443,"@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
 else     return;
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.978756884343037
26444,"@Override public void drawData(Canvas c){
  RadarData radarData=mChart.getData();
  for (  RadarDataSet set : radarData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  RadarData radarData=mChart.getData();
  for (  RadarDataSet set : radarData.getDataSets()) {
    if (set.isVisible() && set.getEntryCount() > 0)     drawDataSet(c,set);
  }
}",0.9339853300733496
26445,"@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry e=entries.get(j);
      PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      c.drawText(dataSet.getValueFormatter().getFormattedValue(e.getVal()),p.x,p.y - yoffset,mValuePaint);
    }
  }
}","@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry e=entries.get(j);
      PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      c.drawText(dataSet.getValueFormatter().getFormattedValue(e.getVal()),p.x,p.y - yoffset,mValuePaint);
    }
  }
}",0.9801980198019802
26446,"@Override public void drawValues(Canvas c){
  if (mChart.getScatterData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<ScatterDataSet> dataSets=mChart.getScatterData().getDataSets();
    for (int i=0; i < mChart.getScatterData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      List<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if ((!mViewPortHandler.isInBoundsLeft(positions[j]) || !mViewPortHandler.isInBoundsY(positions[j + 1])))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getScatterData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<ScatterDataSet> dataSets=mChart.getScatterData().getDataSets();
    for (int i=0; i < mChart.getScatterData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled() || dataSet.getEntryCount() == 0)       continue;
      applyValueTextStyle(dataSet);
      List<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if ((!mViewPortHandler.isInBoundsLeft(positions[j]) || !mViewPortHandler.isInBoundsY(positions[j + 1])))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}",0.986277873070326
26447,"@Override public void onValueSelected(Entry e,int dataSetIndex,Highlight h){
  BarEntry entry=(BarEntry)e;
  if (entry.isStacked())   Log.i(""String_Node_Str"",""String_Node_Str"" + entry.getVals()[h.getStackIndex()]);
 else   Log.i(""String_Node_Str"",""String_Node_Str"" + entry.getVal());
}","@Override public void onValueSelected(Entry e,int dataSetIndex,Highlight h){
  BarEntry entry=(BarEntry)e;
  if (entry.getVals() != null)   Log.i(""String_Node_Str"",""String_Node_Str"" + entry.getVals()[h.getStackIndex()]);
 else   Log.i(""String_Node_Str"",""String_Node_Str"" + entry.getVal());
}",0.9548611111111112
26448,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=0f;
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + value;
          negY=yStart;
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.9838662364329716
26449,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=0f;
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                negY+=value;
                y=negY;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(4.5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!dataSet.isStacked()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=-e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                y=negY;
                negY-=value;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}",0.9889916336415676
26450,"@Override protected void calcMinMax(){
  if (mAutoScaleMinMaxEnabled)   mData.calcMinMax(getLowestVisibleXIndex(),getHighestVisibleXIndex());
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled()) {
    if (mAxisLeft.mAxisMinimum < 0f && mAxisLeft.mAxisMaximum < 0f) {
      mAxisLeft.mAxisMaximum=0f;
    }
 else     if (mAxisLeft.mAxisMinimum >= 0f) {
      mAxisLeft.mAxisMinimum=0f;
    }
  }
  if (mAxisRight.isStartAtZeroEnabled()) {
    if (mAxisRight.mAxisMinimum < 0.0 && mAxisRight.mAxisMaximum < 0.0) {
      mAxisRight.mAxisMaximum=0f;
    }
 else     if (mAxisRight.mAxisMinimum >= 0f) {
      mAxisRight.mAxisMinimum=0f;
    }
  }
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  if (mAutoScaleMinMaxEnabled)   mData.calcMinMax(getLowestVisibleXIndex(),getHighestVisibleXIndex());
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  if (mAxisLeft.isStartAtZeroEnabled()) {
    if (minLeft < 0.f && maxLeft < 0.f) {
      mAxisLeft.mAxisMinimum=Math.min(0.f,!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft));
      mAxisLeft.mAxisMaximum=0.f;
    }
 else     if (minLeft >= 0.0) {
      mAxisLeft.mAxisMinimum=0.f;
      mAxisLeft.mAxisMaximum=Math.max(0.f,!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft));
    }
 else {
      mAxisLeft.mAxisMinimum=Math.min(0.f,!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft));
      mAxisLeft.mAxisMaximum=Math.max(0.f,!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft));
    }
  }
 else {
    mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : (minLeft - bottomSpaceLeft);
    mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : (maxLeft + topSpaceLeft);
  }
  if (mAxisRight.isStartAtZeroEnabled()) {
    if (minRight < 0.f && maxRight < 0.f) {
      mAxisRight.mAxisMinimum=Math.min(0.f,!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight));
      mAxisRight.mAxisMaximum=0.f;
    }
 else     if (minRight >= 0.f) {
      mAxisRight.mAxisMinimum=0.f;
      mAxisRight.mAxisMaximum=Math.max(0.f,!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight));
    }
 else {
      mAxisRight.mAxisMinimum=Math.min(0.f,!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight));
      mAxisRight.mAxisMaximum=Math.max(0.f,!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight));
    }
  }
 else {
    mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : (minRight - bottomSpaceRight);
    mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : (maxRight + topSpaceRight);
  }
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.5679779158040028
26451,"@Override public void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    float fullLegendWidth=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getFormSize() + mLegend.getFormToTextSpace();
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      float yOffset=getRequiredBottomOffset();
      legendBottom=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float min=Utils.convertDpToPixel(10f);
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled()) {
      min=Math.max(Utils.convertDpToPixel(10f),x.mLabelWidth);
    }
  }
  legendTop+=getExtraTopOffset();
  legendRight+=getExtraRightOffset();
  legendBottom+=getExtraBottomOffset();
  legendLeft+=getExtraLeftOffset();
  float offsetLeft=Math.max(min,legendLeft);
  float offsetTop=Math.max(min,legendTop);
  float offsetRight=Math.max(min,legendRight);
  float offsetBottom=Math.max(min,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}","@Override public void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    float fullLegendWidth=Math.min(mLegend.mNeededWidth,mViewPortHandler.getChartWidth() * mLegend.getMaxSizePercent()) + mLegend.getFormSize() + mLegend.getFormToTextSpace();
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=fullLegendWidth + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=fullLegendWidth + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      float yOffset=getRequiredBottomOffset();
      legendBottom=Math.min(mLegend.mNeededHeight + yOffset,mViewPortHandler.getChartHeight() * mLegend.getMaxSizePercent());
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float min=Utils.convertDpToPixel(10f);
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled() && x.isDrawLabelsEnabled()) {
      min=Math.max(Utils.convertDpToPixel(10f),x.mLabelWidth);
    }
  }
  legendTop+=getExtraTopOffset();
  legendRight+=getExtraRightOffset();
  legendBottom+=getExtraBottomOffset();
  legendLeft+=getExtraLeftOffset();
  float offsetLeft=Math.max(min,legendLeft);
  float offsetTop=Math.max(min,legendTop);
  float offsetRight=Math.max(min,legendRight);
  float offsetBottom=Math.max(min,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}",0.9964375247394116
26452,"@Override protected float getRequiredBaseOffset(){
  return mXAxis.isEnabled() ? mXAxis.mLabelWidth : Utils.convertDpToPixel(10f);
}","@Override protected float getRequiredBaseOffset(){
  return mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled() ? mXAxis.mLabelWidth : Utils.convertDpToPixel(10f);
}",0.8918918918918919
26453,"@Override protected void calcMinMax(){
  super.calcMinMax();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  float leftRange=Math.abs(maxLeft - (mYAxis.isStartAtZeroEnabled() ? 0 : minLeft));
  float topSpaceLeft=leftRange / 100f * mYAxis.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mYAxis.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mYAxis.mAxisMaximum=!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mYAxis.mAxisMinimum=!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : minLeft - bottomSpaceLeft;
  if (mYAxis.isStartAtZeroEnabled())   mYAxis.mAxisMinimum=Math.min(0f,mYAxis.mAxisMinimum);
  mYAxis.mAxisRange=Math.abs(mYAxis.mAxisMaximum - mYAxis.mAxisMinimum);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  float leftRange=Math.abs(maxLeft - (mYAxis.isStartAtZeroEnabled() ? 0 : minLeft));
  float topSpaceLeft=leftRange / 100f * mYAxis.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mYAxis.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  if (mYAxis.isStartAtZeroEnabled()) {
    if (minLeft < 0.f && maxLeft < 0.f) {
      mYAxis.mAxisMinimum=Math.min(0.f,!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : (minLeft - bottomSpaceLeft));
      mYAxis.mAxisMaximum=0.f;
    }
 else     if (minLeft >= 0.0) {
      mYAxis.mAxisMinimum=0.f;
      mYAxis.mAxisMaximum=Math.max(0.f,!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : (maxLeft + topSpaceLeft));
    }
 else {
      mYAxis.mAxisMinimum=Math.min(0.f,!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : (minLeft - bottomSpaceLeft));
      mYAxis.mAxisMaximum=Math.max(0.f,!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : (maxLeft + topSpaceLeft));
    }
  }
 else {
    mYAxis.mAxisMinimum=!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : (minLeft - bottomSpaceLeft);
    mYAxis.mAxisMaximum=!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : (maxLeft + topSpaceLeft);
  }
  mYAxis.mAxisRange=Math.abs(mYAxis.mAxisMaximum - mYAxis.mAxisMinimum);
}",0.6012412723041117
26454,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  data.setValueTextSize(10f);
  data.setValueTypeface(tf);
  mChart.setDrawValueAboveBar(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
    yVals1.add(new BarEntry((float)(Math.random() * range),i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  data.setValueTextSize(10f);
  data.setValueTypeface(tf);
  mChart.setData(data);
}",0.7259842519685039
26455,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + e.getXIndex() * dataSetOffset + mDataSetIndex + mGroupSpace * e.getXIndex() + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.9919308357348704
26456,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float bottom=x - barWidth + barSpaceHalf;
      float top=x + barWidth - barSpaceHalf;
      float left, right;
      if (mInverted) {
        left=y >= 0 ? y : 0;
        right=y <= 0 ? y : 0;
      }
 else {
        right=y >= 0 ? y : 0;
        left=y <= 0 ? y : 0;
      }
      if (right > 0)       right*=phaseY;
 else       left*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float bottom=x - barWidth + barSpaceHalf;
        float top=x + barWidth - barSpaceHalf;
        float left, right;
        if (mInverted) {
          left=y >= yStart ? y : yStart;
          right=y <= yStart ? y : yStart;
        }
 else {
          right=y >= yStart ? y : yStart;
          left=y <= yStart ? y : yStart;
        }
        right*=phaseY;
        left*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + e.getXIndex() * dataSetOffset + mDataSetIndex + mGroupSpace * e.getXIndex() + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float bottom=x - barWidth + barSpaceHalf;
      float top=x + barWidth - barSpaceHalf;
      float left, right;
      if (mInverted) {
        left=y >= 0 ? y : 0;
        right=y <= 0 ? y : 0;
      }
 else {
        right=y >= 0 ? y : 0;
        left=y <= 0 ? y : 0;
      }
      if (right > 0)       right*=phaseY;
 else       left*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=-e.getNegativeSum();
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + Math.abs(value);
          negY+=Math.abs(value);
        }
        float bottom=x - barWidth + barSpaceHalf;
        float top=x + barWidth - barSpaceHalf;
        float left, right;
        if (mInverted) {
          left=y >= yStart ? y : yStart;
          right=y <= yStart ? y : yStart;
        }
 else {
          right=y >= yStart ? y : yStart;
          left=y <= yStart ? y : yStart;
        }
        right*=phaseY;
        left*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.9919401266551524
26457,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BARCHART.
 * @param entries
 * @param dataSet the dataset index
 * @return
 */
public float[] generateTransformedValuesBarChart(List<? extends Entry> entries,int dataSet,BarData bd,float phaseY){
  float[] valuePoints=new float[entries.size() * 2];
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int j=0; j < valuePoints.length; j+=2) {
    Entry e=entries.get(j / 2);
    float x=e.getXIndex() + (j / 2 * (setCount - 1)) + dataSet+ space * (j / 2) + space / 2f;
    float y=e.getVal();
    valuePoints[j]=x;
    valuePoints[j + 1]=y * phaseY;
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BARCHART.
 * @param entries
 * @param dataSet the dataset index
 * @return
 */
public float[] generateTransformedValuesBarChart(List<? extends Entry> entries,int dataSet,BarData bd,float phaseY){
  float[] valuePoints=new float[entries.size() * 2];
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int j=0; j < valuePoints.length; j+=2) {
    Entry e=entries.get(j / 2);
    int i=e.getXIndex();
    float x=e.getXIndex() + i * (setCount - 1) + dataSet + space * i + space / 2f;
    float y=e.getVal();
    valuePoints[j]=x;
    valuePoints[j + 1]=y * phaseY;
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}",0.9641943734015346
26458,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BARCHART.
 * @param entries
 * @param dataSet the dataset index
 * @return
 */
public float[] generateTransformedValuesHorizontalBarChart(List<? extends Entry> entries,int dataSet,BarData bd,float phaseY){
  float[] valuePoints=new float[entries.size() * 2];
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int j=0; j < valuePoints.length; j+=2) {
    Entry e=entries.get(j / 2);
    float x=e.getXIndex() + (j / 2 * (setCount - 1)) + dataSet+ space * (j / 2) + space / 2f;
    float y=e.getVal();
    valuePoints[j]=y * phaseY;
    valuePoints[j + 1]=x;
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BARCHART.
 * @param entries
 * @param dataSet the dataset index
 * @return
 */
public float[] generateTransformedValuesHorizontalBarChart(List<? extends Entry> entries,int dataSet,BarData bd,float phaseY){
  float[] valuePoints=new float[entries.size() * 2];
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int j=0; j < valuePoints.length; j+=2) {
    Entry e=entries.get(j / 2);
    int i=e.getXIndex();
    float x=e.getXIndex() + i * (setCount - 1) + dataSet + space * i + space / 2f;
    float y=e.getVal();
    valuePoints[j]=y * phaseY;
    valuePoints[j + 1]=x;
  }
  getValueToPixelMatrix().mapPoints(valuePoints);
  return valuePoints;
}",0.9646464646464646
26459,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleLineValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets()) {
        if (set instanceof LineDataSet)         set.setDrawValues(!set.isDrawValuesEnabled());
      }
      mChart.invalidate();
      break;
    }
case R.id.actionToggleBarValues:
{
    for (    DataSet<?> set : mChart.getData().getDataSets()) {
      if (set instanceof BarDataSet)       set.setDrawValues(!set.isDrawValuesEnabled());
    }
    mChart.invalidate();
    break;
  }
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleLineValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets()) {
        if (set instanceof LineDataSet)         set.setDrawValues(!set.isDrawValuesEnabled());
      }
      mChart.invalidate();
      break;
    }
case R.id.actionToggleBarValues:
{
    CombinedData data=new CombinedData(mMonths);
    data.setData(generateLineData());
    mChart.setData(data);
    mChart.invalidate();
    break;
  }
}
return true;
}",0.7839020122484689
26460,"/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
protected List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  float[] pts=new float[2];
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    if (!dataSet.isHighlightEnabled())     continue;
    float yVal=dataSet.getYValForXIndex(xIndex);
    pts[1]=yVal;
    getTransformer(dataSet.getAxisDependency()).pointValuesToPixel(pts);
    if (!Float.isNaN(pts[1])) {
      vals.add(new SelectionDetail(pts[1],i,dataSet));
    }
  }
  return vals;
}","/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
protected List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  float[] pts=new float[2];
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    if (!dataSet.isHighlightEnabled())     continue;
    final float yVal=dataSet.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    pts[1]=yVal;
    getTransformer(dataSet.getAxisDependency()).pointValuesToPixel(pts);
    if (!Float.isNaN(pts[1])) {
      vals.add(new SelectionDetail(pts[1],i,dataSet));
    }
  }
  return vals;
}",0.9740474875759249
26461,"/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
public List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    float yVal=dataSet.getYValForXIndex(xIndex);
    if (!Float.isNaN(yVal)) {
      vals.add(new SelectionDetail(yVal,i,dataSet));
    }
  }
  return vals;
}","/** 
 * Returns an array of SelectionDetail objects for the given x-index. The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @return
 */
public List<SelectionDetail> getSelectionDetailsAtIndex(int xIndex){
  List<SelectionDetail> vals=new ArrayList<SelectionDetail>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<?> dataSet=mData.getDataSetByIndex(i);
    final float yVal=dataSet.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    vals.add(new SelectionDetail(yVal,i,dataSet));
  }
  return vals;
}",0.9386026817219478
26462,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float yValue=set.getYValForXIndex(xIndex);
    if (yValue == Float.NaN)     continue;
    float y=yValue * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    final float yVal=set.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    float y=yVal * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.992744860943168
26463,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    ScatterDataSet set=mChart.getScatterData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float yValue=set.getYValForXIndex(xIndex);
    if (yValue == Float.NaN)     continue;
    float y=yValue * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    ScatterDataSet set=mChart.getScatterData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    final float yVal=set.getYValForXIndex(xIndex);
    if (yVal == Float.NaN)     continue;
    float y=yVal * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.992619926199262
26464,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_age_distribution);
  setTitle(""String_Node_Str"");
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.getAxisLeft().setEnabled(false);
  mChart.getAxisRight().setStartAtZero(false);
  mChart.getAxisRight().setAxisMaxValue(25f);
  mChart.getAxisRight().setAxisMinValue(-25f);
  mChart.getAxisRight().setLabelCount(7);
  mChart.getAxisRight().setValueFormatter(new CustomFormatter());
  mChart.getAxisRight().setTextSize(9f);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setTextSize(9f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
  ArrayList<BarEntry> yValues=new ArrayList<BarEntry>();
  yValues.add(new BarEntry(new float[]{-10,10},0));
  yValues.add(new BarEntry(new float[]{-12,13},1));
  yValues.add(new BarEntry(new float[]{-15,15},2));
  yValues.add(new BarEntry(new float[]{-17,17},3));
  yValues.add(new BarEntry(new float[]{-19,20},4));
  yValues.add(new BarEntry(new float[]{-19,19},5));
  yValues.add(new BarEntry(new float[]{-16,16},6));
  yValues.add(new BarEntry(new float[]{-13,14},7));
  yValues.add(new BarEntry(new float[]{-10,11},8));
  yValues.add(new BarEntry(new float[]{-5,6},9));
  yValues.add(new BarEntry(new float[]{-1,2},10));
  BarDataSet set=new BarDataSet(yValues,""String_Node_Str"");
  set.setValueFormatter(new CustomFormatter());
  set.setValueTextSize(7f);
  set.setAxisDependency(YAxis.AxisDependency.RIGHT);
  set.setBarSpacePercent(50f);
  set.setColors(new int[]{Color.rgb(67,67,72),Color.rgb(124,181,236)});
  set.setStackLabels(new String[]{""String_Node_Str"",""String_Node_Str""});
  String[] xVals=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  BarData data=new BarData(xVals,set);
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_age_distribution);
  setTitle(""String_Node_Str"");
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.getAxisLeft().setEnabled(false);
  mChart.getAxisRight().setStartAtZero(false);
  mChart.getAxisRight().setAxisMaxValue(25f);
  mChart.getAxisRight().setAxisMinValue(-25f);
  mChart.getAxisRight().setLabelCount(7);
  mChart.getAxisRight().setValueFormatter(new CustomFormatter());
  mChart.getAxisRight().setTextSize(9f);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setTextSize(9f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
  ArrayList<BarEntry> yValues=new ArrayList<BarEntry>();
  yValues.add(new BarEntry(new float[]{-10,10},0));
  yValues.add(new BarEntry(new float[]{-12,13},1));
  yValues.add(new BarEntry(new float[]{-15,15},2));
  yValues.add(new BarEntry(new float[]{-17,17},3));
  yValues.add(new BarEntry(new float[]{-19,20},4));
  yValues.add(new BarEntry(new float[]{-19,19},5));
  yValues.add(new BarEntry(new float[]{-16,16},6));
  yValues.add(new BarEntry(new float[]{-13,14},7));
  yValues.add(new BarEntry(new float[]{-10,11},8));
  yValues.add(new BarEntry(new float[]{-5,6},9));
  yValues.add(new BarEntry(new float[]{-1,2},10));
  BarDataSet set=new BarDataSet(yValues,""String_Node_Str"");
  set.setValueFormatter(new CustomFormatter());
  set.setValueTextSize(7f);
  set.setAxisDependency(YAxis.AxisDependency.RIGHT);
  set.setBarSpacePercent(40f);
  set.setColors(new int[]{Color.rgb(67,67,72),Color.rgb(124,181,236)});
  set.setStackLabels(new String[]{""String_Node_Str"",""String_Node_Str""});
  String[] xVals=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  BarData data=new BarData(xVals,set);
  mChart.setData(data);
  mChart.invalidate();
}",0.999607535321821
26465,"/** 
 * This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
 * @param set
 * @param xIndex
 * @param dataSetIndex
 * @param yValue
 * @return
 */
protected Highlight getStackedHighlight(BarDataSet set,int xIndex,int dataSetIndex,double yValue){
  BarEntry entry=set.getEntryForXIndex(xIndex);
  if (entry != null) {
    int stackIndex=getClosestStackIndex(entry,(float)yValue);
    Highlight h=new Highlight(xIndex,dataSetIndex,stackIndex);
    return h;
  }
 else   return null;
}","/** 
 * This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
 * @param set
 * @param xIndex
 * @param dataSetIndex
 * @param yValue
 * @return
 */
protected Highlight getStackedHighlight(BarDataSet set,int xIndex,int dataSetIndex,double yValue){
  BarEntry entry=set.getEntryForXIndex(xIndex);
  if (entry != null) {
    Range[] ranges=getRanges(entry);
    int stackIndex=getClosestStackIndex(ranges,(float)yValue);
    Highlight h=new Highlight(xIndex,dataSetIndex,stackIndex,ranges[stackIndex]);
    return h;
  }
 else   return null;
}",0.9413823272090988
26466,"/** 
 * Returns the index of the closest value inside the values array (for stacked barchart) to the value given as a parameter.
 * @param e
 * @param value
 * @return
 */
protected int getClosestStackIndex(BarEntry e,float value){
  Range[] ranges=getRanges(e);
  int stackIndex=0;
  for (  Range range : ranges) {
    if (range.contains(value))     return stackIndex;
 else     stackIndex++;
  }
  int length=ranges.length - 1;
  return (value > ranges[length].to) ? length : 0;
}","/** 
 * Returns the index of the closest value inside the values array / ranges (stacked barchart) to the value given as a parameter.
 * @param ranges
 * @param value
 * @return
 */
protected int getClosestStackIndex(Range[] ranges,float value){
  int stackIndex=0;
  for (  Range range : ranges) {
    if (range.contains(value))     return stackIndex;
 else     stackIndex++;
  }
  int length=ranges.length - 1;
  return (value > ranges[length].to) ? length : 0;
}",0.9186906019007391
26467,"protected Range[] getRanges(BarEntry entry){
  float[] values=entry.getVals();
  float negRemain=-entry.getNegativeSum();
  float posRemain=0f;
  Range[] ranges=new Range[values.length];
  for (int i=0; i < ranges.length; i++) {
    float value=values[i];
    if (value < 0) {
      ranges[i]=new Range(negRemain,negRemain + Math.abs(value));
      negRemain+=Math.abs(value);
    }
 else {
      ranges[i]=new Range(posRemain,posRemain + value);
      posRemain+=value;
    }
  }
  return ranges;
}","/** 
 * Splits up the stack-values of the given bar-entry into Range objects.
 * @param entry
 * @return
 */
protected Range[] getRanges(BarEntry entry){
  float[] values=entry.getVals();
  if (values == null)   return null;
  float negRemain=-entry.getNegativeSum();
  float posRemain=0f;
  Range[] ranges=new Range[values.length];
  for (int i=0; i < ranges.length; i++) {
    float value=values[i];
    if (value < 0) {
      ranges[i]=new Range(negRemain,negRemain + Math.abs(value));
      negRemain+=Math.abs(value);
    }
 else {
      ranges[i]=new Range(posRemain,posRemain + value);
      posRemain+=value;
    }
  }
  return ranges;
}",0.8723776223776224
26468,"/** 
 * Constructor, only used for stacked-barchart.
 * @param x the index of the highlighted value on the x-axis
 * @param val the value at the position the user touched
 * @param dataSet the index of the DataSet the highlighted value belongs to
 * @param stackIndex references which value of a stacked-bar entry has beenselected
 */
public Highlight(int x,int dataSet,int stackIndex){
  this(x,dataSet);
  mStackIndex=stackIndex;
}","/** 
 * Constructor, only used for stacked-barchart.
 * @param x the index of the highlighted value on the x-axis
 * @param dataSet the index of the DataSet the highlighted value belongs to
 * @param stackIndex references which value of a stacked-bar entry has beenselected
 * @param range the range the selected stack-value is in
 */
public Highlight(int x,int dataSet,int stackIndex,Range range){
  this(x,dataSet,stackIndex);
  this.mRange=range;
}",0.4457013574660634
26469,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      final float y1;
      final float y2;
      if (isStack) {
        y1=e.getPositiveSum();
        y2=-e.getNegativeSum();
      }
 else {
        y1=e.getVal();
        y2=0.f;
      }
      prepareBarHighlight(x,y1,y2,barspaceHalf,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        float[] values=new float[9];
        trans.getPixelToValueMatrix().getValues(values);
        final float xToYRel=Math.abs(values[Matrix.MSCALE_Y] / values[Matrix.MSCALE_X]);
        final float arrowWidth=set.getBarSpace() / 2.f;
        final float arrowHeight=arrowWidth * xToYRel;
        final float yArrow=y1 > -y2 ? y1 : y1;
        Path arrow=new Path();
        arrow.moveTo(x + 0.4f,yArrow + offsetY);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY - arrowHeight);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY + arrowHeight);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      final float y1;
      final float y2;
      if (isStack) {
        y1=h.getRange().from;
        y2=h.getRange().to * mAnimator.getPhaseY();
      }
 else {
        y1=e.getVal();
        y2=0.f;
      }
      prepareBarHighlight(x,y1,y2,barspaceHalf,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        float[] values=new float[9];
        trans.getPixelToValueMatrix().getValues(values);
        final float xToYRel=Math.abs(values[Matrix.MSCALE_Y] / values[Matrix.MSCALE_X]);
        final float arrowWidth=set.getBarSpace() / 2.f;
        final float arrowHeight=arrowWidth * xToYRel;
        final float yArrow=y1 > -y2 ? y1 : y1;
        Path arrow=new Path();
        arrow.moveTo(x + 0.4f,yArrow + offsetY);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY - arrowHeight);
        arrow.lineTo(x + 0.4f + arrowWidth,yArrow + offsetY + arrowHeight);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.9802371541501976
26470,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float allPos=e.getPositiveSum();
      float allNeg=e.getNegativeSum();
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          allPos-=value;
          y=value + allPos;
        }
 else {
          allNeg-=Math.abs(value);
          y=value + allNeg;
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= 0 ? y : 0;
          top=y <= 0 ? y : 0;
        }
 else {
          top=y >= 0 ? y : 0;
          bottom=y <= 0 ? y : 0;
        }
        if (top > 0)         top*=phaseY;
 else         bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float bottom, top;
      if (mInverted) {
        bottom=y >= 0 ? y : 0;
        top=y <= 0 ? y : 0;
      }
 else {
        top=y >= 0 ? y : 0;
        bottom=y <= 0 ? y : 0;
      }
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=0f;
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + value;
          negY=yStart;
        }
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom, top;
        if (mInverted) {
          bottom=y >= yStart ? y : yStart;
          top=y <= yStart ? y : yStart;
        }
 else {
          top=y >= yStart ? y : yStart;
          bottom=y <= yStart ? y : yStart;
        }
        top*=phaseY;
        bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.8744019138755981
26471,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float bottom=x - barWidth + barSpaceHalf;
      float top=x + barWidth - barSpaceHalf;
      float left, right;
      if (mInverted) {
        left=y >= 0 ? y : 0;
        right=y <= 0 ? y : 0;
      }
 else {
        right=y >= 0 ? y : 0;
        left=y <= 0 ? y : 0;
      }
      if (right > 0)       right*=phaseY;
 else       left*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float allPos=e.getPositiveSum();
      float allNeg=e.getNegativeSum();
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          allPos-=value;
          y=value + allPos;
        }
 else {
          allNeg-=Math.abs(value);
          y=value + allNeg;
        }
        float bottom=x - barWidth + barSpaceHalf;
        float top=x + barWidth - barSpaceHalf;
        float left, right;
        if (mInverted) {
          left=y >= 0 ? y : 0;
          right=y <= 0 ? y : 0;
        }
 else {
          right=y >= 0 ? y : 0;
          left=y <= 0 ? y : 0;
        }
        if (right > 0)         right*=phaseY;
 else         left*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float bottom=x - barWidth + barSpaceHalf;
      float top=x + barWidth - barSpaceHalf;
      float left, right;
      if (mInverted) {
        left=y >= 0 ? y : 0;
        right=y <= 0 ? y : 0;
      }
 else {
        right=y >= 0 ? y : 0;
        left=y <= 0 ? y : 0;
      }
      if (right > 0)       right*=phaseY;
 else       left*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float posY=0f;
      float negY=0f;
      float yStart=0f;
      for (int k=0; k < vals.length; k++) {
        float value=vals[k];
        if (value >= 0f) {
          y=posY;
          yStart=posY + value;
          posY=yStart;
        }
 else {
          y=negY;
          yStart=negY + value;
          negY=yStart;
        }
        float bottom=x - barWidth + barSpaceHalf;
        float top=x + barWidth - barSpaceHalf;
        float left, right;
        if (mInverted) {
          left=y >= yStart ? y : yStart;
          right=y <= yStart ? y : yStart;
        }
 else {
          right=y >= yStart ? y : yStart;
          left=y <= yStart ? y : yStart;
        }
        right*=phaseY;
        left*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}",0.8722388059701492
26472,"@Override protected void calcMinMax(){
  if (mAutoScaleMinMaxEnabled)   mData.calcMinMax(getLowestVisibleXIndex(),getHighestVisibleXIndex());
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  if (mAutoScaleMinMaxEnabled)   mData.calcMinMax(getLowestVisibleXIndex(),getHighestVisibleXIndex());
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled()) {
    if (mAxisLeft.mAxisMinimum < 0f && mAxisLeft.mAxisMaximum < 0f) {
      mAxisLeft.mAxisMaximum=0f;
    }
 else {
      mAxisLeft.mAxisMinimum=0f;
    }
  }
  if (mAxisRight.isStartAtZeroEnabled()) {
    if (mAxisRight.mAxisMinimum < 0.0 && mAxisRight.mAxisMaximum < 0.0) {
      mAxisRight.mAxisMaximum=0f;
    }
 else {
      mAxisRight.mAxisMinimum=0f;
    }
  }
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.9099548586362556
26473,"/** 
 * calc minimum and maximum y value over all datasets
 */
public void calcMinMax(int start,int end){
  if (mDataSets == null || mDataSets.size() < 1) {
    mYMax=0f;
    mYMin=0f;
  }
 else {
    mLastStart=start;
    mLastEnd=end;
    mYMin=Float.MAX_VALUE;
    mYMax=-Float.MIN_VALUE;
    for (int i=0; i < mDataSets.size(); i++) {
      mDataSets.get(i).calcMinMax(start,end);
      if (mDataSets.get(i).getYMin() < mYMin)       mYMin=mDataSets.get(i).getYMin();
      if (mDataSets.get(i).getYMax() > mYMax)       mYMax=mDataSets.get(i).getYMax();
    }
    if (mYMin == Float.MAX_VALUE) {
      mYMin=0.f;
      mYMax=0.f;
    }
    T firstLeft=getFirstLeft();
    if (firstLeft != null) {
      mLeftAxisMax=firstLeft.getYMax();
      mLeftAxisMin=firstLeft.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {
          if (dataSet.getYMin() < mLeftAxisMin)           mLeftAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mLeftAxisMax)           mLeftAxisMax=dataSet.getYMax();
        }
      }
    }
    T firstRight=getFirstRight();
    if (firstRight != null) {
      mRightAxisMax=firstRight.getYMax();
      mRightAxisMin=firstRight.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {
          if (dataSet.getYMin() < mRightAxisMin)           mRightAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mRightAxisMax)           mRightAxisMax=dataSet.getYMax();
        }
      }
    }
    handleEmptyAxis(firstLeft,firstRight);
  }
}","/** 
 * calc minimum and maximum y value over all datasets
 */
public void calcMinMax(int start,int end){
  if (mDataSets == null || mDataSets.size() < 1) {
    mYMax=0f;
    mYMin=0f;
  }
 else {
    mLastStart=start;
    mLastEnd=end;
    mYMin=Float.MAX_VALUE;
    mYMax=-Float.MAX_VALUE;
    for (int i=0; i < mDataSets.size(); i++) {
      mDataSets.get(i).calcMinMax(start,end);
      if (mDataSets.get(i).getYMin() < mYMin)       mYMin=mDataSets.get(i).getYMin();
      if (mDataSets.get(i).getYMax() > mYMax)       mYMax=mDataSets.get(i).getYMax();
    }
    if (mYMin == Float.MAX_VALUE) {
      mYMin=0.f;
      mYMax=0.f;
    }
    T firstLeft=getFirstLeft();
    if (firstLeft != null) {
      mLeftAxisMax=firstLeft.getYMax();
      mLeftAxisMin=firstLeft.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {
          if (dataSet.getYMin() < mLeftAxisMin)           mLeftAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mLeftAxisMax)           mLeftAxisMax=dataSet.getYMax();
        }
      }
    }
    T firstRight=getFirstRight();
    if (firstRight != null) {
      mRightAxisMax=firstRight.getYMax();
      mRightAxisMin=firstRight.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {
          if (dataSet.getYMin() < mRightAxisMin)           mRightAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mRightAxisMax)           mRightAxisMax=dataSet.getYMax();
        }
      }
    }
    handleEmptyAxis(firstLeft,firstRight);
  }
}",0.9987677141096736
26474,"/** 
 * calc minimum and maximum y value
 */
protected void calcMinMax(int start,int end){
  if (mYVals.size() == 0)   return;
  int endValue;
  if (end == 0)   endValue=mYVals.size() - 1;
 else   endValue=end;
  mLastStart=start;
  mLastEnd=endValue;
  mYMin=Float.MAX_VALUE;
  mYMax=-Float.MIN_VALUE;
  for (int i=start; i <= endValue; i++) {
    Entry e=mYVals.get(i);
    if (e != null && !Float.isNaN(e.getVal())) {
      if (e.getVal() < mYMin)       mYMin=e.getVal();
      if (e.getVal() > mYMax)       mYMax=e.getVal();
    }
  }
  if (mYMin == Float.MAX_VALUE) {
    mYMin=0.f;
    mYMax=0.f;
  }
}","/** 
 * calc minimum and maximum y value
 */
protected void calcMinMax(int start,int end){
  final int yValCount=mYVals.size();
  if (yValCount == 0)   return;
  int endValue;
  if (end == 0 || end >= yValCount)   endValue=yValCount - 1;
 else   endValue=end;
  mLastStart=start;
  mLastEnd=endValue;
  mYMin=Float.MAX_VALUE;
  mYMax=-Float.MAX_VALUE;
  for (int i=start; i <= endValue; i++) {
    Entry e=mYVals.get(i);
    if (e != null && !Float.isNaN(e.getVal())) {
      if (e.getVal() < mYMin)       mYMin=e.getVal();
      if (e.getVal() > mYMax)       mYMax=e.getVal();
    }
  }
  if (mYMin == Float.MAX_VALUE) {
    mYMin=0.f;
    mYMax=0.f;
  }
}",0.9106719367588932
26475,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float allPos=e.getPositiveSum();
            float allNeg=e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                allPos-=value;
                y=value + allPos;
              }
 else {
                allNeg-=Math.abs(value);
                y=value + allNeg;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      float valueTextHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
      posOffset=(drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);
      negOffset=(drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);
      if (isInverted) {
        posOffset=-posOffset - valueTextHeight;
        negOffset=-negOffset - valueTextHeight;
      }
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,formatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,formatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=0f;
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                negY+=value;
                y=negY;
              }
              transformed[k + 1]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,formatter.getFormattedValue(vals[k / 2]),x,y);
            }
          }
        }
      }
    }
  }
}",0.961193165363452
26476,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    if (drawValueAboveBar)     mValuePaint.setTextAlign(Align.LEFT);
 else     mValuePaint.setTextAlign(Align.RIGHT);
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      mYOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          String valueText=formatter.getFormattedValue(val);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,valueText,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1]);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String valueText=formatter.getFormattedValue(val);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,valueText,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1]);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float allPos=e.getPositiveSum();
            float allNeg=e.getNegativeSum();
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                allPos-=value;
                y=value + allPos;
              }
 else {
                allNeg-=Math.abs(value);
                y=value + allNeg;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String valueText=formatter.getFormattedValue(val);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,valueText,x,y);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    List<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    final float valueOffsetPlus=Utils.convertDpToPixel(5f);
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    if (drawValueAboveBar)     mValuePaint.setTextAlign(Align.LEFT);
 else     mValuePaint.setTextAlign(Align.RIGHT);
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      boolean isInverted=mChart.isInverted(dataSet.getAxisDependency());
      applyValueTextStyle(dataSet);
      mYOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          String valueText=formatter.getFormattedValue(val);
          float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
          posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
          negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
          if (isInverted) {
            posOffset=-posOffset - valueTextWidth;
            negOffset=-negOffset - valueTextWidth;
          }
          drawValue(c,valueText,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1]);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            float val=e.getVal();
            String valueText=formatter.getFormattedValue(val);
            float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
            posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
            negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
            if (isInverted) {
              posOffset=-posOffset - valueTextWidth;
              negOffset=-negOffset - valueTextWidth;
            }
            drawValue(c,valueText,valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1]);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            float posY=0f;
            float negY=0f;
            for (int k=0, idx=0; k < transformed.length; k+=2, idx++) {
              float value=vals[idx];
              float y;
              if (value >= 0f) {
                posY+=value;
                y=posY;
              }
 else {
                negY+=value;
                y=negY;
              }
              transformed[k]=y * mAnimator.getPhaseY();
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float val=vals[k / 2];
              String valueText=formatter.getFormattedValue(val);
              float valueTextWidth=Utils.calcTextWidth(mValuePaint,valueText);
              posOffset=(drawValueAboveBar ? valueOffsetPlus : -(valueTextWidth + valueOffsetPlus));
              negOffset=(drawValueAboveBar ? -(valueTextWidth + valueOffsetPlus) : valueOffsetPlus);
              if (isInverted) {
                posOffset=-posOffset - valueTextWidth;
                negOffset=-negOffset - valueTextWidth;
              }
              float x=transformed[k] + (val >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,valueText,x,y);
            }
          }
        }
      }
    }
  }
}",0.9721181856013316
26477,"/** 
 * Prepares a bar for being highlighted.
 * @param x the x-position
 * @param y the y-position
 * @param barspace the space between bars
 * @param from
 * @param trans
 */
protected void prepareBarHighlight(float x,float y,float barspaceHalf,float from,Transformer trans){
  float barWidth=0.5f;
  float left=x - barWidth + barspaceHalf;
  float right=x + barWidth - barspaceHalf;
  float top=y >= from ? y : from;
  float bottom=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","/** 
 * Prepares a bar for being highlighted.
 * @param x the x-position
 * @param y the y-position
 * @param barspaceHalf the space between bars
 * @param from
 * @param trans
 */
protected void prepareBarHighlight(float x,float y,float barspaceHalf,float from,Transformer trans){
  float barWidth=0.5f;
  float left=x - barWidth + barspaceHalf;
  float right=x + barWidth - barspaceHalf;
  float top=y >= from ? y : from;
  float bottom=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}",0.9964093357271095
26478,"@Override public void drawValues(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  if (bubbleData == null)   return;
  if (bubbleData.getYValCount() < (int)(Math.ceil((float)(mChart.getMaxVisibleCount()) * mViewPortHandler.getScaleX()))) {
    final List<BubbleDataSet> dataSets=bubbleData.getDataSets();
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
    for (    BubbleDataSet dataSet : dataSets) {
      if (!dataSet.isDrawValuesEnabled())       continue;
      final float phaseX=mAnimator.getPhaseX();
      final float phaseY=mAnimator.getPhaseY();
      final float alpha=phaseX == 1 ? phaseY : phaseX;
      int valueTextColor=dataSet.getValueTextColor();
      valueTextColor=Color.argb(Math.round(255.f * alpha),Color.red(valueTextColor),Color.green(valueTextColor),Color.blue(valueTextColor));
      mValuePaint.setColor(valueTextColor);
      final List<BubbleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
      final float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesBubble(entries,phaseX,phaseY,minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))         continue;
        final BubbleEntry entry=entries.get(j / 2 + minx);
        final float val=entry.getSize();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y + (0.5f * lineHeight),mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  BubbleData bubbleData=mChart.getBubbleData();
  if (bubbleData == null)   return;
  if (bubbleData.getYValCount() < (int)(Math.ceil((float)(mChart.getMaxVisibleCount()) * mViewPortHandler.getScaleX()))) {
    final List<BubbleDataSet> dataSets=bubbleData.getDataSets();
    float lineHeight=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
    for (    BubbleDataSet dataSet : dataSets) {
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      final float phaseX=mAnimator.getPhaseX();
      final float phaseY=mAnimator.getPhaseY();
      final float alpha=phaseX == 1 ? phaseY : phaseX;
      int valueTextColor=dataSet.getValueTextColor();
      valueTextColor=Color.argb(Math.round(255.f * alpha),Color.red(valueTextColor),Color.green(valueTextColor),Color.blue(valueTextColor));
      mValuePaint.setColor(valueTextColor);
      final List<BubbleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
      final float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesBubble(entries,phaseX,phaseY,minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))         continue;
        final BubbleEntry entry=entries.get(j / 2 + minx);
        final float val=entry.getSize();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y + (0.5f * lineHeight),mValuePaint);
      }
    }
  }
}",0.99038974906567
26479,"/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      DataSet<? extends Entry> dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).isStacked()) {
        BarDataSet bds=(BarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof PieDataSet) {
        List<String> xVals=data.getXVals();
        PieDataSet pds=(PieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
          labels.add(xVals.get(j));
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setColors(colors);
    mLegend.setLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}","/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  if (!mLegend.isLegendCustom()) {
    List<String> labels=new ArrayList<String>();
    List<Integer> colors=new ArrayList<Integer>();
    for (int i=0; i < data.getDataSetCount(); i++) {
      DataSet<? extends Entry> dataSet=data.getDataSetByIndex(i);
      List<Integer> clrs=dataSet.getColors();
      int entryCount=dataSet.getEntryCount();
      if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).isStacked()) {
        BarDataSet bds=(BarDataSet)dataSet;
        String[] sLabels=bds.getStackLabels();
        for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
          labels.add(sLabels[j % sLabels.length]);
          colors.add(clrs.get(j));
        }
        if (bds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(bds.getLabel());
        }
      }
 else       if (dataSet instanceof PieDataSet) {
        List<String> xVals=data.getXVals();
        PieDataSet pds=(PieDataSet)dataSet;
        for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
          labels.add(xVals.get(j));
          colors.add(clrs.get(j));
        }
        if (pds.getLabel() != null) {
          colors.add(ColorTemplate.COLOR_SKIP);
          labels.add(pds.getLabel());
        }
      }
 else {
        for (int j=0; j < clrs.size() && j < entryCount; j++) {
          if (j < clrs.size() - 1 && j < entryCount - 1) {
            labels.add(null);
          }
 else {
            String label=data.getDataSetByIndex(i).getLabel();
            labels.add(label);
          }
          colors.add(clrs.get(j));
        }
      }
    }
    if (mLegend.getExtraColors() != null && mLegend.getExtraLabels() != null) {
      for (      int color : mLegend.getExtraColors())       colors.add(color);
      Collections.addAll(labels,mLegend.getExtraLabels());
    }
    mLegend.setComputedColors(colors);
    mLegend.setComputedLabels(labels);
  }
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint,mViewPortHandler);
}",0.984126984126984
26480,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setValueFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(25f);
  mChart.getAxisRight().setEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  l.setYOffset(0f);
  l.setYEntrySpace(0f);
  l.setTextSize(8f);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setValueFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(30f);
  mChart.getAxisRight().setEnabled(false);
}",0.9756956674885524
26481,"@Override public boolean onDoubleTap(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(1.4f,1.4f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}","@Override public boolean onDoubleTap(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(mChart.isScaleXEnabled() ? 1.4f : 1f,mChart.isScaleYEnabled() ? 1.4f : 1f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}",0.9385796545105566
26482,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  Entry e=null;
  if (high == null)   mIndicesToHightlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    e=mData.getEntryForHighlight(high);
    if (e == null || e.getXIndex() != high.getXIndex()) {
      mIndicesToHightlight=null;
      high=null;
    }
 else {
      mIndicesToHightlight=new Highlight[]{high};
    }
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}",0.7667121418826739
26483,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(Canvas canvas){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mAnimator.getPhaseX()) {
      Entry e=mData.getEntryForHighlight(mIndicesToHightlight[i]);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (!mViewPortHandler.isInBounds(pos[0],pos[1]))       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(canvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(canvas,pos[0],pos[1]);
      }
    }
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(Canvas canvas){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mAnimator.getPhaseX()) {
      Entry e=mData.getEntryForHighlight(mIndicesToHightlight[i]);
      if (e == null || e.getXIndex() != mIndicesToHightlight[i].getXIndex())       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (!mViewPortHandler.isInBounds(pos[0],pos[1]))       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(canvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(canvas,pos[0],pos[1]);
      }
    }
  }
}",0.97682119205298
26484,"/** 
 * Returns the value of the Entry object at the given xIndex. Returns Float.NaN if no value is at the given x-index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public float getYValForXIndex(int xIndex){
  Entry e=getEntryForXIndex(xIndex);
  if (e != null)   return e.getVal();
 else   return Float.NaN;
}","/** 
 * Returns the value of the Entry object at the given xIndex. Returns Float.NaN if no value is at the given x-index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public float getYValForXIndex(int xIndex){
  Entry e=getEntryForXIndex(xIndex);
  if (e != null && e.getXIndex() == xIndex)   return e.getVal();
 else   return Float.NaN;
}",0.9678188319427892
26485,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.9774774774774776
26486,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BubbleData bubbleData=mChart.getBubbleData();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  for (  Highlight indice : indices) {
    BubbleDataSet dataSet=bubbleData.getDataSetByIndex(indice.getDataSetIndex());
    if (dataSet == null || !dataSet.isHighlightEnabled())     continue;
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
    final BubbleEntry entry=(BubbleEntry)bubbleData.getEntryForHighlight(indice);
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    sizeBuffer[0]=0f;
    sizeBuffer[2]=1f;
    trans.pointValuesToPixel(sizeBuffer);
    final float maxBubbleWidth=Math.abs(sizeBuffer[2] - sizeBuffer[0]);
    final float maxBubbleHeight=Math.abs(mViewPortHandler.contentBottom() - mViewPortHandler.contentTop());
    final float referenceSize=Math.min(maxBubbleHeight,maxBubbleWidth);
    pointBuffer[0]=(float)(entry.getXIndex() - minx) * phaseX + (float)minx;
    pointBuffer[1]=(float)(entry.getVal()) * phaseY;
    trans.pointValuesToPixel(pointBuffer);
    float shapeHalf=getShapeSize(entry.getSize(),dataSet.getMaxSize(),referenceSize) / 2f;
    if (!mViewPortHandler.isInBoundsTop(pointBuffer[1] + shapeHalf) || !mViewPortHandler.isInBoundsBottom(pointBuffer[1] - shapeHalf))     continue;
    if (!mViewPortHandler.isInBoundsLeft(pointBuffer[0] + shapeHalf))     continue;
    if (!mViewPortHandler.isInBoundsRight(pointBuffer[0] - shapeHalf))     break;
    if (indice.getXIndex() < minx || indice.getXIndex() >= maxx)     continue;
    final int originalColor=dataSet.getColor(entry.getXIndex());
    Color.RGBToHSV(Color.red(originalColor),Color.green(originalColor),Color.blue(originalColor),_hsvBuffer);
    _hsvBuffer[2]*=0.5f;
    final int color=Color.HSVToColor(Color.alpha(originalColor),_hsvBuffer);
    mHighlightPaint.setColor(color);
    mHighlightPaint.setStrokeWidth(dataSet.getHighlightCircleWidth());
    c.drawCircle(pointBuffer[0],pointBuffer[1],shapeHalf,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  BubbleData bubbleData=mChart.getBubbleData();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  for (  Highlight indice : indices) {
    BubbleDataSet dataSet=bubbleData.getDataSetByIndex(indice.getDataSetIndex());
    if (dataSet == null || !dataSet.isHighlightEnabled())     continue;
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,dataSet.getEntryCount());
    final BubbleEntry entry=(BubbleEntry)bubbleData.getEntryForHighlight(indice);
    if (entry == null || entry.getXIndex() != indice.getXIndex())     continue;
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    sizeBuffer[0]=0f;
    sizeBuffer[2]=1f;
    trans.pointValuesToPixel(sizeBuffer);
    final float maxBubbleWidth=Math.abs(sizeBuffer[2] - sizeBuffer[0]);
    final float maxBubbleHeight=Math.abs(mViewPortHandler.contentBottom() - mViewPortHandler.contentTop());
    final float referenceSize=Math.min(maxBubbleHeight,maxBubbleWidth);
    pointBuffer[0]=(float)(entry.getXIndex() - minx) * phaseX + (float)minx;
    pointBuffer[1]=(float)(entry.getVal()) * phaseY;
    trans.pointValuesToPixel(pointBuffer);
    float shapeHalf=getShapeSize(entry.getSize(),dataSet.getMaxSize(),referenceSize) / 2f;
    if (!mViewPortHandler.isInBoundsTop(pointBuffer[1] + shapeHalf) || !mViewPortHandler.isInBoundsBottom(pointBuffer[1] - shapeHalf))     continue;
    if (!mViewPortHandler.isInBoundsLeft(pointBuffer[0] + shapeHalf))     continue;
    if (!mViewPortHandler.isInBoundsRight(pointBuffer[0] - shapeHalf))     break;
    if (indice.getXIndex() < minx || indice.getXIndex() >= maxx)     continue;
    final int originalColor=dataSet.getColor(entry.getXIndex());
    Color.RGBToHSV(Color.red(originalColor),Color.green(originalColor),Color.blue(originalColor),_hsvBuffer);
    _hsvBuffer[2]*=0.5f;
    final int color=Color.HSVToColor(Color.alpha(originalColor),_hsvBuffer);
    mHighlightPaint.setColor(color);
    mHighlightPaint.setStrokeWidth(dataSet.getHighlightCircleWidth());
    c.drawCircle(pointBuffer[0],pointBuffer[1],shapeHalf,mHighlightPaint);
  }
}",0.9824945295404814
26487,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    CandleDataSet set=mChart.getCandleData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mAnimator.getPhaseY();
    float high=e.getHigh() * mAnimator.getPhaseY();
    float min=mChart.getYChartMin();
    float max=mChart.getYChartMax();
    float[] vertPts=new float[]{xIndex - 0.5f,max,xIndex - 0.5f,min,xIndex + 0.5f,max,xIndex + 0.5f,min};
    float[] horPts=new float[]{mChart.getXChartMin(),low,mChart.getXChartMax(),low,mChart.getXChartMin(),high,mChart.getXChartMax(),high};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(vertPts);
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(horPts);
    c.drawLines(vertPts,mHighlightPaint);
    c.drawLines(horPts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    CandleDataSet set=mChart.getCandleData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null || e.getXIndex() != xIndex)     continue;
    float low=e.getLow() * mAnimator.getPhaseY();
    float high=e.getHigh() * mAnimator.getPhaseY();
    float min=mChart.getYChartMin();
    float max=mChart.getYChartMax();
    float[] vertPts=new float[]{xIndex - 0.5f,max,xIndex - 0.5f,min,xIndex + 0.5f,max,xIndex + 0.5f,min};
    float[] horPts=new float[]{mChart.getXChartMin(),low,mChart.getXChartMax(),low,mChart.getXChartMin(),high,mChart.getXChartMax(),high};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(vertPts);
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(horPts);
    c.drawLines(vertPts,mHighlightPaint);
    c.drawLines(horPts,mHighlightPaint);
  }
}",0.9880266075388028
26488,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float y=set.getYValForXIndex(xIndex) * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float yValue=set.getYValForXIndex(xIndex);
    if (yValue == Float.NaN)     continue;
    float y=yValue * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.957124842370744
26489,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    int j=set.getEntryPosition(e);
    float y=(e.getVal() - mChart.getYChartMin());
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,0,p.x,mViewPortHandler.getChartHeight(),0,p.y,mViewPortHandler.getChartWidth(),p.y};
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    if (e == null || e.getXIndex() != xIndex)     continue;
    int j=set.getEntryPosition(e);
    float y=(e.getVal() - mChart.getYChartMin());
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,0,p.x,mViewPortHandler.getChartHeight(),0,p.y,mViewPortHandler.getChartWidth(),p.y};
    c.drawLines(pts,mHighlightPaint);
  }
}",0.9662921348314608
26490,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    ScatterDataSet set=mChart.getScatterData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float y=set.getYValForXIndex(xIndex) * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    ScatterDataSet set=mChart.getScatterData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null || !set.isHighlightEnabled())     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float yValue=set.getYValForXIndex(xIndex);
    if (yValue == Float.NaN)     continue;
    float y=yValue * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.9563543003851092
26491,"public YAxis(AxisDependency position){
  super();
  this.mAxisDependency=position;
}","public YAxis(AxisDependency position){
  super();
  this.mAxisDependency=position;
  this.mYOffset=0f;
}",0.8936170212765957
26492,"/** 
 * draws the y-axis labels to the screen
 */
@Override public void renderAxisLabels(Canvas c){
  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;
  float[] positions=new float[mYAxis.mEntryCount * 2];
  for (int i=0; i < positions.length; i+=2) {
    positions[i + 1]=mYAxis.mEntries[i / 2];
  }
  mTrans.pointValuesToPixel(positions);
  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());
  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());
  mAxisLabelPaint.setColor(mYAxis.getTextColor());
  float xoffset=mYAxis.getXOffset();
  float yoffset=Utils.calcTextHeight(mAxisLabelPaint,""String_Node_Str"") / 2.5f;
  AxisDependency dependency=mYAxis.getAxisDependency();
  YAxisLabelPosition labelPosition=mYAxis.getLabelPosition();
  float xPos=0f;
  if (dependency == AxisDependency.LEFT) {
    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
      mAxisLabelPaint.setTextAlign(Align.RIGHT);
      xPos=mViewPortHandler.offsetLeft() - xoffset;
    }
 else {
      mAxisLabelPaint.setTextAlign(Align.LEFT);
      xPos=mViewPortHandler.offsetLeft() + xoffset;
    }
  }
 else {
    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
      mAxisLabelPaint.setTextAlign(Align.LEFT);
      xPos=mViewPortHandler.contentRight() + xoffset;
    }
 else {
      mAxisLabelPaint.setTextAlign(Align.RIGHT);
      xPos=mViewPortHandler.contentRight() - xoffset;
    }
  }
  drawYLabels(c,xPos,positions,yoffset);
}","/** 
 * draws the y-axis labels to the screen
 */
@Override public void renderAxisLabels(Canvas c){
  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;
  float[] positions=new float[mYAxis.mEntryCount * 2];
  for (int i=0; i < positions.length; i+=2) {
    positions[i + 1]=mYAxis.mEntries[i / 2];
  }
  mTrans.pointValuesToPixel(positions);
  mAxisLabelPaint.setTypeface(mYAxis.getTypeface());
  mAxisLabelPaint.setTextSize(mYAxis.getTextSize());
  mAxisLabelPaint.setColor(mYAxis.getTextColor());
  float xoffset=mYAxis.getXOffset();
  float yoffset=Utils.calcTextHeight(mAxisLabelPaint,""String_Node_Str"") / 2.5f + mYAxis.getYOffset();
  AxisDependency dependency=mYAxis.getAxisDependency();
  YAxisLabelPosition labelPosition=mYAxis.getLabelPosition();
  float xPos=0f;
  if (dependency == AxisDependency.LEFT) {
    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
      mAxisLabelPaint.setTextAlign(Align.RIGHT);
      xPos=mViewPortHandler.offsetLeft() - xoffset;
    }
 else {
      mAxisLabelPaint.setTextAlign(Align.LEFT);
      xPos=mViewPortHandler.offsetLeft() + xoffset;
    }
  }
 else {
    if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
      mAxisLabelPaint.setTextAlign(Align.LEFT);
      xPos=mViewPortHandler.contentRight() + xoffset;
    }
 else {
      mAxisLabelPaint.setTextAlign(Align.RIGHT);
      xPos=mViewPortHandler.contentRight() - xoffset;
    }
  }
  drawYLabels(c,xPos,positions,yoffset);
}",0.9924085576259488
26493,"@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  mGridPaint.setPathEffect(mXAxis.getGridDashPathEffect());
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (position[0] >= mViewPortHandler.offsetLeft() && position[0] <= mViewPortHandler.getChartWidth()) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}","@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  mGridPaint.setPathEffect(mXAxis.getGridDashPathEffect());
  Path gridLinePath=new Path();
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (position[0] >= mViewPortHandler.offsetLeft() && position[0] <= mViewPortHandler.getChartWidth()) {
      gridLinePath.moveTo(position[0],mViewPortHandler.contentBottom());
      gridLinePath.lineTo(position[0],mViewPortHandler.contentTop());
      c.drawPath(gridLinePath,mGridPaint);
    }
    gridLinePath.reset();
  }
}",0.8763440860215054
26494,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null || !set.isHighlightEnabled())     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=set.getEntryForXIndex(index);
      if (e == null || e.getXIndex() != index)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.986796785304248
26495,"@Override protected void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    if (mLegend != null && mLegend.isEnabled()) {
      if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
        offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART || mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
        offsetLeft+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
        offsetBottom+=mLegend.mTextHeightMax * 3f;
      }
    }
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getPaintAxisLabels());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getPaintAxisLabels());
    }
    float xlabelheight=mXAxis.mLabelHeight * 2f;
    if (mXAxis.isEnabled()) {
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    float min=Utils.convertDpToPixel(10f);
    mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override protected void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    if (mLegend != null && mLegend.isEnabled()) {
      if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
        offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART || mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
        offsetLeft+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
        offsetBottom+=mLegend.mTextHeightMax * 3f;
      }
    }
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getPaintAxisLabels());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getPaintAxisLabels());
    }
    if (mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled()) {
      float xlabelheight=mXAxis.mLabelHeight * 2f;
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    float min=Utils.convertDpToPixel(10f);
    mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.9693106704438148
26496,"/** 
 * Resets all zooming and dragging and makes the chart fit exactly it's bounds.
 */
public Matrix fitScreen(){
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  float[] vals=new float[9];
  save.getValues(vals);
  vals[Matrix.MTRANS_X]=0f;
  vals[Matrix.MTRANS_Y]=0f;
  vals[Matrix.MSCALE_X]=1f;
  vals[Matrix.MSCALE_Y]=1f;
  save.setValues(vals);
  return save;
}","/** 
 * Resets all zooming and dragging and makes the chart fit exactly it's bounds.
 */
public Matrix fitScreen(){
  mMinScaleX=1f;
  mMinScaleY=1f;
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  float[] vals=new float[9];
  save.getValues(vals);
  vals[Matrix.MTRANS_X]=0f;
  vals[Matrix.MTRANS_Y]=0f;
  vals[Matrix.MSCALE_X]=1f;
  vals[Matrix.MSCALE_Y]=1f;
  save.setValues(vals);
  return save;
}",0.9566326530612244
26497,"/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  String centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    if (mChart.isCenterTextWordWrapEnabled()) {
      float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();
      RectF holeRect=mRectBuffer[0];
      holeRect.left=center.x - innerRadius;
      holeRect.top=center.y - innerRadius;
      holeRect.right=center.x + innerRadius;
      holeRect.bottom=center.y + innerRadius;
      RectF boundingRect=mRectBuffer[1];
      boundingRect.set(holeRect);
      float radiusPercent=mChart.getCenterTextRadiusPercent();
      if (radiusPercent > 0.0) {
        boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);
      }
      if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {
        mCenterTextLastBounds.set(boundingRect);
        mCenterTextLastValue=centerText;
        mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(mCenterTextLastBounds.width()),1.f),Layout.Alignment.ALIGN_NORMAL,1.f,0.f,false);
      }
      float layoutWidth=Utils.getStaticLayoutMaxWidth(mCenterTextLayout), layoutHeight=mCenterTextLayout.getHeight();
      c.save();
      c.translate(boundingRect.centerX(),boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);
      mCenterTextLayout.draw(c);
      c.restore();
    }
 else {
      String[] lines=centerText.split(""String_Node_Str"");
      float maxlineheight=0f;
      for (      String line : lines) {
        float curHeight=Utils.calcTextHeight(mCenterTextPaint,line);
        if (curHeight > maxlineheight)         maxlineheight=curHeight;
      }
      float linespacing=maxlineheight * 0.25f;
      float totalheight=maxlineheight * lines.length - linespacing * (lines.length - 1);
      int cnt=lines.length;
      float y=center.y;
      for (int i=0; i < lines.length; i++) {
        String line=lines[lines.length - i - 1];
        c.drawText(line,center.x,y + maxlineheight * cnt - totalheight / 2f,mCenterTextPaint);
        cnt--;
        y-=linespacing;
      }
    }
  }
}","/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  String centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    if (mChart.isCenterTextWordWrapEnabled()) {
      float innerRadius=mChart.isDrawHoleEnabled() && mChart.isHoleTransparent() ? mChart.getRadius() * (mChart.getHoleRadius() / 100f) : mChart.getRadius();
      RectF holeRect=mRectBuffer[0];
      holeRect.left=center.x - innerRadius;
      holeRect.top=center.y - innerRadius;
      holeRect.right=center.x + innerRadius;
      holeRect.bottom=center.y + innerRadius;
      RectF boundingRect=mRectBuffer[1];
      boundingRect.set(holeRect);
      float radiusPercent=mChart.getCenterTextRadiusPercent();
      if (radiusPercent > 0.0) {
        boundingRect.inset((boundingRect.width() - boundingRect.width() * radiusPercent) / 2.f,(boundingRect.height() - boundingRect.height() * radiusPercent) / 2.f);
      }
      if (!centerText.equals(mCenterTextLastValue) || !boundingRect.equals(mCenterTextLastBounds)) {
        mCenterTextLastBounds.set(boundingRect);
        mCenterTextLastValue=centerText;
        mCenterTextLayout=new StaticLayout(centerText,0,centerText.length(),mCenterTextPaint,(int)Math.max(Math.ceil(mCenterTextLastBounds.width()),1.f),Layout.Alignment.ALIGN_NORMAL,1.f,0.f,false);
      }
      float layoutHeight=mCenterTextLayout.getHeight();
      c.save();
      c.translate(boundingRect.centerX(),boundingRect.top + (boundingRect.height() - layoutHeight) / 2.f);
      mCenterTextLayout.draw(c);
      c.restore();
    }
 else {
      String[] lines=centerText.split(""String_Node_Str"");
      float maxlineheight=0f;
      for (      String line : lines) {
        float curHeight=Utils.calcTextHeight(mCenterTextPaint,line);
        if (curHeight > maxlineheight)         maxlineheight=curHeight;
      }
      float linespacing=maxlineheight * 0.25f;
      float totalheight=maxlineheight * lines.length - linespacing * (lines.length - 1);
      int cnt=lines.length;
      float y=center.y;
      for (int i=0; i < lines.length; i++) {
        String line=lines[lines.length - i - 1];
        c.drawText(line,center.x,y + maxlineheight * cnt - totalheight / 2f,mCenterTextPaint);
        cnt--;
        y-=linespacing;
      }
    }
  }
}",0.9874188311688312
26498,"/** 
 * Calculates the total number of y-values across all DataSets the ChartData represents.
 * @return
 */
protected void calcYValueCount(List<? extends DataSet<?>> dataSets){
  mYValCount=0;
  if (dataSets == null)   return;
  int count=0;
  for (int i=0; i < dataSets.size(); i++) {
    count+=dataSets.get(i).getEntryCount();
  }
  mYValCount=count;
}","/** 
 * Calculates the total number of y-values across all DataSets the ChartData represents.
 * @return
 */
protected void calcYValueCount(){
  mYValCount=0;
  if (mDataSets == null)   return;
  int count=0;
  for (int i=0; i < mDataSets.size(); i++) {
    count+=mDataSets.get(i).getEntryCount();
  }
  mYValCount=count;
}",0.9352941176470588
26499,"/** 
 * Call this method to let the CartData know that the underlying data has changed.
 */
public void notifyDataChanged(){
  init(mDataSets);
}","/** 
 * Call this method to let the CartData know that the underlying data has changed.
 */
public void notifyDataChanged(){
  init();
}",0.9679715302491104
26500,"/** 
 * calc minimum and maximum y value over all datasets
 */
protected void calcMinMax(List<? extends DataSet<?>> dataSets){
  if (dataSets == null || dataSets.size() < 1) {
    mYMax=0f;
    mYMin=0f;
  }
 else {
    mYMin=dataSets.get(0).getYMin();
    mYMax=dataSets.get(0).getYMax();
    for (int i=0; i < dataSets.size(); i++) {
      if (dataSets.get(i).getYMin() < mYMin)       mYMin=dataSets.get(i).getYMin();
      if (dataSets.get(i).getYMax() > mYMax)       mYMax=dataSets.get(i).getYMax();
    }
    T firstLeft=getFirstLeft();
    if (firstLeft != null) {
      mLeftAxisMax=firstLeft.getYMax();
      mLeftAxisMin=firstLeft.getYMin();
      for (      DataSet<?> dataSet : dataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {
          if (dataSet.getYMin() < mLeftAxisMin)           mLeftAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mLeftAxisMax)           mLeftAxisMax=dataSet.getYMax();
        }
      }
    }
    T firstRight=getFirstRight();
    if (firstRight != null) {
      mRightAxisMax=firstRight.getYMax();
      mRightAxisMin=firstRight.getYMin();
      for (      DataSet<?> dataSet : dataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {
          if (dataSet.getYMin() < mRightAxisMin)           mRightAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mRightAxisMax)           mRightAxisMax=dataSet.getYMax();
        }
      }
    }
    handleEmptyAxis(firstLeft,firstRight);
  }
}","/** 
 * calc minimum and maximum y value over all datasets
 */
protected void calcMinMax(){
  if (mDataSets == null || mDataSets.size() < 1) {
    mYMax=0f;
    mYMin=0f;
  }
 else {
    mYMin=mDataSets.get(0).getYMin();
    mYMax=mDataSets.get(0).getYMax();
    for (int i=0; i < mDataSets.size(); i++) {
      if (mDataSets.get(i).getYMin() < mYMin)       mYMin=mDataSets.get(i).getYMin();
      if (mDataSets.get(i).getYMax() > mYMax)       mYMax=mDataSets.get(i).getYMax();
    }
    T firstLeft=getFirstLeft();
    if (firstLeft != null) {
      mLeftAxisMax=firstLeft.getYMax();
      mLeftAxisMin=firstLeft.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {
          if (dataSet.getYMin() < mLeftAxisMin)           mLeftAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mLeftAxisMax)           mLeftAxisMax=dataSet.getYMax();
        }
      }
    }
    T firstRight=getFirstRight();
    if (firstRight != null) {
      mRightAxisMax=firstRight.getYMax();
      mRightAxisMin=firstRight.getYMin();
      for (      DataSet<?> dataSet : mDataSets) {
        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {
          if (dataSet.getYMin() < mRightAxisMin)           mRightAxisMin=dataSet.getYMin();
          if (dataSet.getYMax() > mRightAxisMax)           mRightAxisMax=dataSet.getYMax();
        }
      }
    }
    handleEmptyAxis(firstLeft,firstRight);
  }
}",0.6168918918918919
26501,"/** 
 * performs all kinds of initialization calculations, such as min-max and value count and sum
 */
protected void init(List<? extends DataSet<?>> dataSets){
  isLegal(dataSets);
  calcMinMax(dataSets);
  calcYValueSum(dataSets);
  calcYValueCount(dataSets);
  calcXValAverageLength();
}","/** 
 * performs all kinds of initialization calculations, such as min-max and value count and sum
 */
protected void init(){
  isLegal();
  calcMinMax();
  calcYValueSum();
  calcYValueCount();
  calcXValAverageLength();
}",0.7641325536062378
26502,"/** 
 * constructor that takes string array instead of List string
 * @param xVals The values describing the x-axis. Must be at least as longas the highest xIndex in the Entry objects across all DataSets.
 * @param sets the dataset array
 */
public ChartData(String[] xVals,List<T> sets){
  this.mXVals=arrayToList(xVals);
  this.mDataSets=sets;
  init(mDataSets);
}","/** 
 * constructor that takes string array instead of List string
 * @param xVals The values describing the x-axis. Must be at least as longas the highest xIndex in the Entry objects across all DataSets.
 * @param sets the dataset array
 */
public ChartData(String[] xVals,List<T> sets){
  this.mXVals=arrayToList(xVals);
  this.mDataSets=sets;
  init();
}",0.9875518672199172
26503,"/** 
 * Checks if the combination of x-values array and DataSet array is legal or not.
 * @param dataSets
 */
private void isLegal(List<? extends DataSet<?>> dataSets){
  if (dataSets == null)   return;
  for (int i=0; i < dataSets.size(); i++) {
    if (dataSets.get(i).getYVals().size() > mXVals.size()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}","/** 
 * Checks if the combination of x-values array and DataSet array is legal or not.
 */
private void isLegal(){
  if (mDataSets == null)   return;
  for (int i=0; i < mDataSets.size(); i++) {
    if (mDataSets.get(i).getYVals().size() > mXVals.size()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}",0.8547249647390691
26504,"/** 
 * calculates the sum of all y-values in all datasets
 */
protected void calcYValueSum(List<? extends DataSet<?>> dataSets){
  mYValueSum=0;
  if (dataSets == null)   return;
  for (int i=0; i < dataSets.size(); i++) {
    mYValueSum+=Math.abs(dataSets.get(i).getYValueSum());
  }
}","/** 
 * calculates the sum of all y-values in all datasets
 */
protected void calcYValueSum(){
  mYValueSum=0;
  if (mDataSets == null)   return;
  for (int i=0; i < mDataSets.size(); i++) {
    mYValueSum+=Math.abs(mDataSets.get(i).getYValueSum());
  }
}",0.6605166051660517
26505,"public void setData(BubbleData data){
  mBubbleData=data;
  mDataSets.addAll(data.getDataSets());
  init(data.getDataSets());
}","public void setData(BubbleData data){
  mBubbleData=data;
  mDataSets.addAll(data.getDataSets());
  init();
}",0.923728813559322
26506,"/** 
 * Sets the PieDataSet this data object should represent.
 * @param dataSet
 */
public void setDataSet(PieDataSet dataSet){
  mDataSets.clear();
  mDataSets.add(dataSet);
  init(mDataSets);
}","/** 
 * Sets the PieDataSet this data object should represent.
 * @param dataSet
 */
public void setDataSet(PieDataSet dataSet){
  mDataSets.clear();
  mDataSets.add(dataSet);
  init();
}",0.9765013054830288
26507,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360,Easing.EasingOption.EaseInCubic);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.notifyDataSetChanged();
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360,Easing.EasingOption.EaseInCubic);
break;
}
}
return true;
}",0.990704647676162
26508,"@Override protected void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=getFullLegendWidth() + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=getFullLegendWidth() + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=getFullLegendWidth() + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=getFullLegendWidth() + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=getRequiredBottomOffset();
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float min=Utils.convertDpToPixel(10f);
  float offsetLeft=Math.max(min,legendLeft);
  float offsetTop=Math.max(min,legendTop);
  float offsetRight=Math.max(min,legendRight);
  float offsetBottom=Math.max(min,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}","@Override protected void calculateOffsets(){
  float legendLeft=0f, legendRight=0f, legendBottom=0f, legendTop=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=getFullLegendWidth() + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=getFullLegendWidth() + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomRight=new PointF(getWidth() - legendWidth + 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomRight.x,bottomRight.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomRight.x,bottomRight.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendRight=min + diff;
      }
      if (bottomRight.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendRight=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendLeft=getFullLegendWidth() + spacing;
    }
 else     if (mLegend.getPosition() == LegendPosition.LEFT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(8f);
      float legendWidth=getFullLegendWidth() + spacing;
      float legendHeight=mLegend.mNeededHeight + mLegend.mTextHeightMax;
      PointF c=getCenter();
      PointF bottomLeft=new PointF(legendWidth - 15,legendHeight + 15);
      float distLegend=distanceToCenter(bottomLeft.x,bottomLeft.y);
      PointF reference=getPosition(c,getRadius(),getAngleForPoint(bottomLeft.x,bottomLeft.y));
      float distReference=distanceToCenter(reference.x,reference.y);
      float min=Utils.convertDpToPixel(5f);
      if (distLegend < distReference) {
        float diff=distReference - distLegend;
        legendLeft=min + diff;
      }
      if (bottomLeft.y >= c.y && getHeight() - legendWidth > getWidth()) {
        legendLeft=legendWidth;
      }
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=getRequiredBottomOffset();
    }
    legendLeft+=getRequiredBaseOffset();
    legendRight+=getRequiredBaseOffset();
    legendTop+=getRequiredBaseOffset();
  }
  float min=Utils.convertDpToPixel(10f);
  if (this instanceof RadarChart) {
    XAxis x=((RadarChart)this).getXAxis();
    if (x.isEnabled()) {
      min=Math.max(Utils.convertDpToPixel(10f),x.mLabelWidth);
    }
  }
  float offsetLeft=Math.max(min,legendLeft);
  float offsetTop=Math.max(min,legendTop);
  float offsetRight=Math.max(min,legendRight);
  float offsetBottom=Math.max(min,Math.max(getRequiredBaseOffset(),legendBottom));
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
}",0.9728485964104924
26509,"@Override protected float getRequiredBaseOffset(){
  return mXAxis.mLabelWidth;
}","@Override protected float getRequiredBaseOffset(){
  return mXAxis.isEnabled() ? mXAxis.mLabelWidth : Utils.convertDpToPixel(10f);
}",0.7605633802816901
26510,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.997812613926358
26511,"@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}",0.9957476966690292
26512,"/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,List<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4 - 4;
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.limitFrom(minx);
  buffer.limitTo(maxx);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < range; j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,0,range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,minx,maxx,trans);
  }
}","/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,List<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4 - 4;
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.limitFrom(minx);
  buffer.limitTo(maxx);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < range; j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,0,range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,minx,maxx,trans);
  }
}",0.9969024264326276
26513,"@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      if (minx < 0)       minx=0;
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}",0.9859906604402936
26514,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (entries.size() - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (entries.size() - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9981406879454602
26515,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex((mMinX < 0) ? 0 : mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.9965075669383004
26516,"@Override public void drawValues(Canvas c){
  if (mChart.getScatterData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<ScatterDataSet> dataSets=mChart.getScatterData().getDataSets();
    for (int i=0; i < mChart.getScatterData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      List<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if (j != 0 && (!mViewPortHandler.isInBoundsLeft(positions[j]) || !mViewPortHandler.isInBoundsY(positions[j + 1])))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getScatterData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<ScatterDataSet> dataSets=mChart.getScatterData().getDataSets();
    for (int i=0; i < mChart.getScatterData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      List<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if ((!mViewPortHandler.isInBoundsLeft(positions[j]) || !mViewPortHandler.isInBoundsY(positions[j + 1])))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}",0.9956709956709956
26517,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (entries.size() - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=Math.max(dataSet.getEntryPosition(entryFrom),0);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry prevPrev=entries.get(minx);
    Entry prev=entries.get(minx);
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(cur.getXIndex() - prev.getXIndex()) * intensity;
    prevDy=(cur.getVal() - prev.getVal()) * intensity;
    curDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    curDy=(next.getVal() - cur.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 1, count=Math.min(size,entries.size() - 1); j < count; j++) {
      prevPrev=entries.get(j == 1 ? 0 : j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      prev=entries.get(entries.size() - 2);
      cur=entries.get(entries.size() - 1);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9523510971786834
26518,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.BUBBLE,DrawOrder.CANDLE,DrawOrder.LINE,DrawOrder.SCATTER});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setBackgroundColor(Color.WHITE);
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.BUBBLE,DrawOrder.CANDLE,DrawOrder.LINE,DrawOrder.SCATTER});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}",0.9782833505687694
26519,"/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BUBBLECHART.
 * @param entries
 * @return
 */
public float[] generateTransformedValuesBubble(List<? extends Entry> entries,float phaseX,float phaseY,int from,int to){
  final int count=(int)Math.ceil((to - from) * phaseX) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    Entry e=entries.get(j / 2 + from);
    if (e != null) {
      valuePoints[j]=(float)(e.getXIndex() - from) * phaseX + from;
      valuePoints[j + 1]=e.getVal() * phaseY;
    }
  }
  pointValuesToPixel(valuePoints);
  return valuePoints;
}","/** 
 * Transforms an List of Entry into a float array containing the x and y values transformed with all matrices for the BUBBLECHART.
 * @param entries
 * @return
 */
public float[] generateTransformedValuesBubble(List<? extends Entry> entries,float phaseX,float phaseY,int from,int to){
  final int count=(int)Math.ceil(to - from) * 2;
  float[] valuePoints=new float[count];
  for (int j=0; j < count; j+=2) {
    Entry e=entries.get(j / 2 + from);
    if (e != null) {
      valuePoints[j]=(float)(e.getXIndex() - from) * phaseX + from;
      valuePoints[j + 1]=e.getVal() * phaseY;
    }
  }
  pointValuesToPixel(valuePoints);
  return valuePoints;
}",0.9916855631141346
26520,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_realtime_linechart);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  LineData data=new LineData();
  data.setValueTextColor(Color.WHITE);
  mChart.setData(data);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  xl.setDrawGridLines(false);
  xl.setAvoidFirstLastClipping(true);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(Color.WHITE);
  leftAxis.setAxisMaxValue(120f);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_realtime_linechart);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  LineData data=new LineData();
  data.setValueTextColor(Color.WHITE);
  mChart.setData(data);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  xl.setDrawGridLines(false);
  xl.setAvoidFirstLastClipping(true);
  xl.setSpaceBetweenLabels(5);
  xl.setEnabled(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(Color.WHITE);
  leftAxis.setAxisMaxValue(100f);
  leftAxis.setAxisMinValue(0f);
  leftAxis.setStartAtZero(false);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setEnabled(false);
}",0.9566122874002084
26521,"private void addEntry(){
  LineData data=mChart.getData();
  if (data != null) {
    LineDataSet set=data.getDataSetByIndex(0);
    if (set == null) {
      set=createSet();
      data.addDataSet(set);
    }
    data.addXValue(mMonths[data.getXValCount() % 12] + ""String_Node_Str"" + (year + data.getXValCount() / 12));
    data.addEntry(new Entry((float)(Math.random() * 40) + 40f,set.getEntryCount()),0);
    mChart.notifyDataSetChanged();
    mChart.setVisibleXRange(6);
    mChart.moveViewToX(data.getXValCount() - 7);
  }
}","private void addEntry(){
  LineData data=mChart.getData();
  if (data != null) {
    LineDataSet set=data.getDataSetByIndex(0);
    if (set == null) {
      set=createSet();
      data.addDataSet(set);
    }
    data.addXValue(mMonths[data.getXValCount() % 12] + ""String_Node_Str"" + (year + data.getXValCount() / 12));
    data.addEntry(new Entry((float)(Math.random() * 40) + 30f,set.getEntryCount()),0);
    mChart.notifyDataSetChanged();
    mChart.setVisibleXRange(120);
    mChart.moveViewToX(data.getXValCount() - 121);
  }
}",0.9905482041587902
26522,"private LineDataSet createSet(){
  LineDataSet set=new LineDataSet(null,""String_Node_Str"");
  set.setAxisDependency(AxisDependency.LEFT);
  set.setColor(ColorTemplate.getHoloBlue());
  set.setCircleColor(ColorTemplate.getHoloBlue());
  set.setLineWidth(2f);
  set.setCircleSize(4f);
  set.setFillAlpha(65);
  set.setFillColor(ColorTemplate.getHoloBlue());
  set.setHighLightColor(Color.rgb(244,117,117));
  set.setValueTextColor(Color.WHITE);
  set.setValueTextSize(10f);
  return set;
}","private LineDataSet createSet(){
  LineDataSet set=new LineDataSet(null,""String_Node_Str"");
  set.setAxisDependency(AxisDependency.LEFT);
  set.setColor(ColorTemplate.getHoloBlue());
  set.setCircleColor(Color.WHITE);
  set.setLineWidth(2f);
  set.setCircleSize(4f);
  set.setFillAlpha(65);
  set.setFillColor(ColorTemplate.getHoloBlue());
  set.setHighLightColor(Color.rgb(244,117,117));
  set.setValueTextColor(Color.WHITE);
  set.setValueTextSize(9f);
  set.setDrawValues(false);
  return set;
}",0.9421319796954316
26523,"/** 
 * Adds a new x-value to the chart data.
 * @param xVal
 */
public void addXValue(String xVal){
  mXVals.add(xVal);
}","/** 
 * Adds a new x-value to the chart data.
 * @param xVal
 */
public void addXValue(String xVal){
  mXValAverageLength=(mXValAverageLength + xVal.length()) / 2f;
  mXVals.add(xVal);
}",0.7922077922077922
26524,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get((entries.size() > 2) ? 2 : 1);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9945269741985928
26525,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() * 3));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i + 1990) + ""String_Node_Str"");
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals2=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals3=new ArrayList<BarEntry>();
  float mult=mSeekBarY.getProgress() * 1000f;
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals2.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals3.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(Color.rgb(104,241,175));
  BarDataSet set2=new BarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(Color.rgb(164,228,251));
  BarDataSet set3=new BarDataSet(yVals3,""String_Node_Str"");
  set3.setColor(Color.rgb(242,247,158));
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  dataSets.add(set3);
  BarData data=new BarData(xVals,dataSets);
  data.setGroupSpace(80f);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() * 3));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals2=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals3=new ArrayList<BarEntry>();
  float mult=mSeekBarY.getProgress() * 1000f;
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals2.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals3.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(Color.rgb(104,241,175));
  BarDataSet set2=new BarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(Color.rgb(164,228,251));
  BarDataSet set3=new BarDataSet(yVals3,""String_Node_Str"");
  set3.setColor(Color.rgb(242,247,158));
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  dataSets.add(set3);
  BarData data=new BarData(xVals,dataSets);
  data.setGroupSpace(80f);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}",0.9977924944812362
26526,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.LINE});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.CANDLE,DrawOrder.LINE,DrawOrder.SCATTER});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}",0.9808008776741636
26527,"/** 
 * Returns the lowest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
public int getLowestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] <= 0) ? 0 : (int)(pts[0] + 1);
}","/** 
 * Returns the lowest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getLowestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] <= 0) ? 0 : (int)(pts[0] + 1);
}",0.98567335243553
26528,"/** 
 * Returns the highest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
public int getHighestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentRight(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] >= mData.getXValCount()) ? mData.getXValCount() - 1 : (int)pts[0];
}","/** 
 * Returns the highest x-index (value on the x-axis) that is still visible on the chart.
 * @return
 */
@Override public int getHighestVisibleXIndex(){
  float[] pts=new float[]{mViewPortHandler.contentRight(),mViewPortHandler.contentBottom()};
  getTransformer(AxisDependency.LEFT).pixelsToValue(pts);
  return (pts[0] >= mData.getXValCount()) ? mData.getXValCount() - 1 : (int)pts[0];
}",0.9871134020618556
26529,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  if (mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (!mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (!mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (!mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  mXAxisRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  mRenderer.calcXBounds(this,mXAxis.mAxisLabelModulus);
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  if (mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (!mXAxis.isDrawLimitLinesBehindDataEnabled())   mXAxisRenderer.renderLimitLines(canvas);
  if (!mAxisLeft.isDrawLimitLinesBehindDataEnabled())   mAxisRendererLeft.renderLimitLines(canvas);
  if (!mAxisRight.isDrawLimitLinesBehindDataEnabled())   mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.9738313576381122
26530,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}",0.9938375350140056
26531,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.9959970887918488
26532,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    CandleDataSet set=mChart.getCandleData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mAnimator.getPhaseY();
    float high=e.getHigh() * mAnimator.getPhaseY();
    float min=mChart.getYChartMin();
    float max=mChart.getYChartMax();
    float[] vertPts=new float[]{xIndex - 0.5f,max,xIndex - 0.5f,min,xIndex + 0.5f,max,xIndex + 0.5f,min};
    float[] horPts=new float[]{0,low,mChart.getXChartMax(),low,0,high,mChart.getXChartMax(),high};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(vertPts);
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(horPts);
    c.drawLines(vertPts,mHighlightPaint);
    c.drawLines(horPts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    CandleDataSet set=mChart.getCandleData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mAnimator.getPhaseY();
    float high=e.getHigh() * mAnimator.getPhaseY();
    float min=mChart.getYChartMin();
    float max=mChart.getYChartMax();
    float[] vertPts=new float[]{xIndex - 0.5f,max,xIndex - 0.5f,min,xIndex + 0.5f,max,xIndex + 0.5f,min};
    float[] horPts=new float[]{mChart.getXChartMin(),low,mChart.getXChartMax(),low,mChart.getXChartMin(),high,mChart.getXChartMax(),high};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(vertPts);
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(horPts);
    c.drawLines(vertPts,mHighlightPaint);
    c.drawLines(horPts,mHighlightPaint);
  }
}",0.9793427230046948
26533,public abstract void initBuffers();,"/** 
 * Initializes the buffers used for rendering with a new size. Since this method performs memory allocations, it should only be called if necessary.
 */
public abstract void initBuffers();",0.3070175438596491
26534,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 3]))     break;
    if (!mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 1]))     continue;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(mViewPortHandler.contentLeft(),buffer.buffer[j + 1],mViewPortHandler.contentRight(),buffer.buffer[j + 3],mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}","protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 3]))     break;
    if (!mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 1]))     continue;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(mViewPortHandler.contentLeft(),buffer.buffer[j + 1],mViewPortHandler.contentRight(),buffer.buffer[j + 3],mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}",0.9905090595340812
26535,"protected void drawDataSet(Canvas c,LineDataSet dataSet){
  List<Entry> entries=dataSet.getYVals();
  if (entries.size() < 1)   return;
  calcXBounds(mChart.getTransformer(dataSet.getAxisDependency()));
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
  if (dataSet.isDrawCubicEnabled()) {
    drawCubic(c,dataSet,entries);
  }
 else {
    drawLinear(c,dataSet,entries);
  }
  mRenderPaint.setPathEffect(null);
}","protected void drawDataSet(Canvas c,LineDataSet dataSet){
  List<Entry> entries=dataSet.getYVals();
  if (entries.size() < 1)   return;
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
  if (dataSet.isDrawCubicEnabled()) {
    drawCubic(c,dataSet,entries);
  }
 else {
    drawLinear(c,dataSet,entries);
  }
  mRenderPaint.setPathEffect(null);
}",0.9244644870349492
26536,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float y=set.getYValForXIndex(xIndex) * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),0,y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  for (int i=0; i < indices.length; i++) {
    LineDataSet set=mChart.getLineData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    if (xIndex > mChart.getXChartMax() * mAnimator.getPhaseX())     continue;
    float y=set.getYValForXIndex(xIndex) * mAnimator.getPhaseY();
    float[] pts=new float[]{xIndex,mChart.getYChartMax(),xIndex,mChart.getYChartMin(),mChart.getXChartMin(),y,mChart.getXChartMax(),y};
    mChart.getTransformer(set.getAxisDependency()).pointValuesToPixel(pts);
    c.drawLines(pts,mHighlightPaint);
  }
}",0.9847222222222224
26537,"/** 
 * Calculates the minimum and maximum x-value the chart can currently display (with the given zoom level).
 * @param trans
 */
protected void calcXBounds(Transformer trans){
  double minx=trans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),0).x;
  double maxx=trans.getValuesByTouchPoint(mViewPortHandler.contentRight(),0).x;
  if (!Double.isInfinite(minx))   mMinX=(int)minx;
  if (!Double.isInfinite(maxx))   mMaxX=(int)Math.ceil(maxx);
}","/** 
 * Calculates the minimum and maximum x-value the chart can currently display (with the given zoom level).
 * @param chart
 * @param modulus
 */
public void calcXBounds(BarLineScatterCandleDataProvider chart,int xAxisModulus){
  int low=chart.getLowestVisibleXIndex();
  int high=chart.getHighestVisibleXIndex();
  int subLow=(low % xAxisModulus == 0) ? xAxisModulus : 0;
  mMinX=Math.max((low / xAxisModulus) * (xAxisModulus) - subLow,0);
  mMaxX=Math.min((high / xAxisModulus) * (xAxisModulus) + xAxisModulus,(int)chart.getXChartMax());
}",0.3410230692076229
26538,"protected void drawDataSet(Canvas c,ScatterDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<Entry> entries=dataSet.getYVals();
  float shapeHalf=dataSet.getScatterShapeSize() / 2f;
  ScatterShape shape=dataSet.getScatterShape();
  ScatterBuffer buffer=mScatterBuffers[mChart.getScatterData().getIndexOfDataSet(dataSet)];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
switch (shape) {
case SQUARE:
    mRenderPaint.setStyle(Style.FILL);
  for (int i=0; i < buffer.size(); i+=2) {
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i]))     break;
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1]))     continue;
    mRenderPaint.setColor(dataSet.getColor(i / 2));
    c.drawRect(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
  }
break;
case CIRCLE:
mRenderPaint.setStyle(Style.FILL);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawCircle(buffer.buffer[i],buffer.buffer[i + 1],shapeHalf,mRenderPaint);
}
break;
case TRIANGLE:
mRenderPaint.setStyle(Style.FILL);
Path tri=new Path();
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
tri.moveTo(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf);
tri.lineTo(buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.lineTo(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.close();
c.drawPath(tri,mRenderPaint);
tri.reset();
}
break;
case CROSS:
mRenderPaint.setStyle(Style.STROKE);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawLine(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1],buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1],mRenderPaint);
c.drawLine(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i],buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
}
break;
default :
break;
}
}","protected void drawDataSet(Canvas c,ScatterDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<Entry> entries=dataSet.getYVals();
  float shapeHalf=dataSet.getScatterShapeSize() / 2f;
  ScatterShape shape=dataSet.getScatterShape();
  ScatterBuffer buffer=mScatterBuffers[mChart.getScatterData().getIndexOfDataSet(dataSet)];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
switch (shape) {
case SQUARE:
    mRenderPaint.setStyle(Style.FILL);
  for (int i=0; i < buffer.size(); i+=2) {
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i]))     break;
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1]))     continue;
    mRenderPaint.setColor(dataSet.getColor(i / 2));
    c.drawRect(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
  }
break;
case CIRCLE:
mRenderPaint.setStyle(Style.FILL);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawCircle(buffer.buffer[i],buffer.buffer[i + 1],shapeHalf,mRenderPaint);
}
break;
case TRIANGLE:
mRenderPaint.setStyle(Style.FILL);
Path tri=new Path();
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
tri.moveTo(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf);
tri.lineTo(buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.lineTo(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.close();
c.drawPath(tri,mRenderPaint);
tri.reset();
}
break;
case CROSS:
mRenderPaint.setStyle(Style.STROKE);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawLine(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1],buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1],mRenderPaint);
c.drawLine(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i],buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
}
break;
default :
break;
}
}",0.9959588537839824
26539,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX;
  int minx=mMinX;
  if (maxx >= mXAxis.getValues().size())   maxx=mXAxis.getValues().size() - 1;
  if (minx < 0)   minx=0;
  for (int i=minx; i <= maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisLabelPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisLabelPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisLabelPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisLabelPaint);
    }
  }
}",0.9128953771289536
26540,"@Override public void renderAxisLine(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawAxisLineEnabled() || !mXAxis.isEnabled())   return;
  mAxisLinePaint.setColor(mXAxis.getAxisLineColor());
  mAxisLinePaint.setStrokeWidth(mXAxis.getAxisLineWidth());
  if (mXAxis.getPosition() == XAxisPosition.TOP || mXAxis.getPosition() == XAxisPosition.TOP_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop(),mViewPortHandler.contentRight(),mViewPortHandler.contentTop(),mAxisLinePaint);
  }
  if (mXAxis.getPosition() == XAxisPosition.BOTTOM || mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom(),mViewPortHandler.contentRight(),mViewPortHandler.contentBottom(),mAxisLinePaint);
  }
}","@Override public void renderAxisLine(Canvas c){
  if (!mXAxis.isDrawAxisLineEnabled() || !mXAxis.isEnabled())   return;
  mAxisLinePaint.setColor(mXAxis.getAxisLineColor());
  mAxisLinePaint.setStrokeWidth(mXAxis.getAxisLineWidth());
  if (mXAxis.getPosition() == XAxisPosition.TOP || mXAxis.getPosition() == XAxisPosition.TOP_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop(),mViewPortHandler.contentRight(),mViewPortHandler.contentTop(),mAxisLinePaint);
  }
  if (mXAxis.getPosition() == XAxisPosition.BOTTOM || mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom(),mViewPortHandler.contentRight(),mViewPortHandler.contentBottom(),mAxisLinePaint);
  }
}",0.9870276367738297
26541,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.992399565689468
26542,"public boolean isInBoundsRight(float x){
  return mContentRect.right >= x ? true : false;
}","public boolean isInBoundsRight(float x){
  x=(float)((int)(x * 100.f)) / 100.f;
  return mContentRect.right >= x ? true : false;
}",0.8235294117647058
26543,"public boolean isInBoundsBottom(float y){
  return mContentRect.bottom >= y ? true : false;
}","public boolean isInBoundsBottom(float y){
  y=(float)((int)(y * 100.f)) / 100.f;
  return mContentRect.bottom >= y ? true : false;
}",0.8266666666666667
26544,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null || mPathBitmap.getWidth() != mViewPortHandler.getChartWidth() || mPathBitmap.getHeight() != mViewPortHandler.getChartHeight()) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}",0.8875
26545,"@Override public void drawData(Canvas c){
  if (mDrawBitmap == null) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  if (mDrawBitmap == null || mDrawBitmap.getWidth() != mViewPortHandler.getChartWidth() || mDrawBitmap.getHeight() != mViewPortHandler.getChartHeight()) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}",0.8858695652173914
26546,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  set1.setDrawFilled(true);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}",0.984036488027366
26547,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 4) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get((entries.size() > 2) ? 2 : 1);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9863665187064046
26548,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null || (mPathBitmap.getWidth() != (int)mViewPortHandler.getChartWidth()) || (mPathBitmap.getHeight() != (int)mViewPortHandler.getChartHeight())) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}",0.6918918918918919
26549,"@Override public void drawData(Canvas c){
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != (int)mViewPortHandler.getChartWidth()) || (mDrawBitmap.getHeight() != (int)mViewPortHandler.getChartHeight())) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_8888);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  int width=(int)mViewPortHandler.getChartWidth();
  int height=(int)mViewPortHandler.getChartHeight();
  if (mDrawBitmap == null || (mDrawBitmap.getWidth() != width) || (mDrawBitmap.getHeight() != height)) {
    if (width > 0 && height > 0) {
      mDrawBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_4444);
      mBitmapCanvas=new Canvas(mDrawBitmap);
    }
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}",0.7228306655433867
26550,"/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    if (transparentCircleRadius > holeRadius) {
      int color=mTransparentCirclePaint.getColor();
      mTransparentCirclePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mTransparentCirclePaint);
      mTransparentCirclePaint.setColor(color);
    }
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
  }
}","/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    if (transparentCircleRadius > holeRadius && mAnimator.getPhaseX() >= 1f && mAnimator.getPhaseY() >= 1f) {
      int color=mTransparentCirclePaint.getColor();
      mTransparentCirclePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mTransparentCirclePaint);
      mTransparentCirclePaint.setColor(color);
    }
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
  }
}",0.9616336633663366
26551,"/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,List<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  int size=(int)Math.ceil((maxx - minx) * phaseX + minx);
  minx=Math.max(minx - 2,0);
  size=Math.min(size + 2,entries.size());
  if (size - minx >= 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(minx);
    Entry next=entries.get(minx + 1);
    Entry prev=entries.get(minx);
    Entry prevPrev=entries.get(minx);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(minx + 1);
    next=entries.get(minx + (size - minx > 2 ? 2 : 1));
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=minx + 2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get((entries.size() >= 3) ? entries.size() - 3 : entries.size() - 2);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,entryFrom.getXIndex(),entryFrom.getXIndex() + size);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.992399565689468
26552,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else     if (open < close) {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
 else {
      mRenderPaint.setColor(Color.BLACK);
      mRenderPaint.setStyle(Paint.Style.STROKE);
      c.drawLine(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.9645336836179396
26553,"@Override public void feed(List<CandleEntry> entries){
  float size=entries.size() * phaseX;
  for (int i=0; i < size; i++) {
    CandleEntry e=entries.get(i);
    addBody(e.getXIndex() - 0.5f + mBodySpace,e.getClose() * phaseY,e.getXIndex() + 0.5f - mBodySpace,e.getOpen() * phaseY);
  }
  reset();
}","@Override public void feed(List<CandleEntry> entries){
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom; i < size; i++) {
    CandleEntry e=entries.get(i);
    addBody(e.getXIndex() - 0.5f + mBodySpace,e.getClose() * phaseY,e.getXIndex() + 0.5f - mBodySpace,e.getOpen() * phaseY);
  }
  reset();
}",0.8070175438596491
26554,"@Override public void feed(List<CandleEntry> entries){
  float size=entries.size() * phaseX;
  for (int i=0; i < size; i++) {
    CandleEntry e=entries.get(i);
    addShadow(e.getXIndex(),e.getHigh() * phaseY,e.getXIndex(),e.getLow() * phaseY);
  }
  reset();
}","@Override public void feed(List<CandleEntry> entries){
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom; i < size; i++) {
    CandleEntry e=entries.get(i);
    addShadow(e.getXIndex(),e.getHigh() * phaseY,e.getXIndex(),e.getLow() * phaseY);
  }
  reset();
}",0.7787934186471663
26555,"@Override public void feed(List<Entry> entries){
  float size=entries.size() * phaseX;
  for (int i=0; i < size; i++) {
    Entry e=entries.get(i);
    addCircle(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}","@Override public void feed(List<Entry> entries){
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom; i < size; i++) {
    Entry e=entries.get(i);
    addCircle(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}",0.8653421633554084
26556,"@Override public void feed(List<Entry> entries){
  moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
  float size=entries.size() * phaseX;
  for (int i=1; i < size; i++) {
    Entry e=entries.get(i);
    lineTo(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}","@Override public void feed(List<Entry> entries){
  moveTo(entries.get(mFrom).getXIndex(),entries.get(mFrom).getVal());
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom + 1; i < size; i++) {
    Entry e=entries.get(i);
    lineTo(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}",0.8713550600343053
26557,"protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  int range=(mMaxX - mMinX + 1) * 4;
  int from=mMinX * 4;
  int to=mMaxX + 1;
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,from,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < bodyBuffer.size(); j+=4) {
    CandleEntry e=entries.get(j / 4);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,CandleDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  int dataSetIndex=mChart.getCandleData().getIndexOfDataSet(dataSet);
  List<CandleEntry> entries=dataSet.getYVals();
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
  int from=minx * 4;
  int range=(maxx - minx) * 4;
  int to=(int)Math.ceil((maxx - minx) * phaseX + minx);
  CandleShadowBuffer shadowBuffer=mShadowBuffers[dataSetIndex];
  shadowBuffer.setPhases(phaseX,phaseY);
  shadowBuffer.limitFrom(minx);
  shadowBuffer.limitTo(maxx);
  shadowBuffer.feed(entries);
  trans.pointValuesToPixel(shadowBuffer.buffer);
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (dataSet.getShadowColor() == ColorTemplate.COLOR_NONE) {
    mRenderPaint.setColor(dataSet.getColor());
  }
 else {
    mRenderPaint.setColor(dataSet.getShadowColor());
  }
  mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
  c.drawLines(shadowBuffer.buffer,0,range,mRenderPaint);
  CandleBodyBuffer bodyBuffer=mBodyBuffers[dataSetIndex];
  bodyBuffer.setBodySpace(dataSet.getBodySpace());
  bodyBuffer.setPhases(phaseX,phaseY);
  bodyBuffer.limitFrom(minx);
  bodyBuffer.limitTo(maxx);
  bodyBuffer.feed(entries);
  trans.pointValuesToPixel(bodyBuffer.buffer);
  for (int j=0; j < range; j+=4) {
    CandleEntry e=entries.get(j / 4 + minx);
    if (!fitsBounds(e.getXIndex(),mMinX,to))     continue;
    float leftBody=bodyBuffer.buffer[j];
    float open=bodyBuffer.buffer[j + 1];
    float rightBody=bodyBuffer.buffer[j + 2];
    float close=bodyBuffer.buffer[j + 3];
    if (open > close) {
      if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getDecreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());
      c.drawRect(leftBody,close,rightBody,open,mRenderPaint);
    }
 else {
      if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {
        mRenderPaint.setColor(dataSet.getColor(j / 4 + minx));
      }
 else {
        mRenderPaint.setColor(dataSet.getIncreasingColor());
      }
      mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());
      c.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.884438881935753
26558,"@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseY());
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      List<CandleEntry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getHigh();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}",0.8809710258418167
26559,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setProgress(10);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  mChart.setUsePercentValues(true);
  mChart.setHoleColorTransparent(true);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setRotationAngle(0);
  mChart.setRotationEnabled(true);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setCenterText(""String_Node_Str"");
  setData(3,100);
  mChart.animateXY(1500,1500,EasingFunction.EaseInOutQuad,EasingFunction.EaseInOutQuad);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setProgress(10);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  mChart.setUsePercentValues(true);
  mChart.setDescription(""String_Node_Str"");
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setDrawHoleEnabled(true);
  mChart.setHoleColorTransparent(true);
  mChart.setTransparentCircleColor(Color.WHITE);
  mChart.setHoleRadius(58f);
  mChart.setTransparentCircleRadius(61f);
  mChart.setDrawCenterText(true);
  mChart.setRotationAngle(0);
  mChart.setRotationEnabled(true);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setCenterText(""String_Node_Str"");
  setData(3,100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.8517850703209521
26560,"private void setData(int count,float range){
  float mult=range;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count + 1; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 5,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count + 1; i++)   xVals.add(mParties[i % mParties.length]);
  PieDataSet dataSet=new PieDataSet(yVals1,""String_Node_Str"");
  dataSet.setSliceSpace(3f);
  ArrayList<Integer> colors=new ArrayList<Integer>();
  for (  int c : ColorTemplate.VORDIPLOM_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.JOYFUL_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.COLORFUL_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.LIBERTY_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.PASTEL_COLORS)   colors.add(c);
  colors.add(ColorTemplate.getHoloBlue());
  dataSet.setColors(colors);
  PieData data=new PieData(xVals,dataSet);
  data.setValueFormatter(new PercentFormatter());
  data.setValueTextSize(11f);
  data.setValueTextColor(Color.WHITE);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.highlightValues(null);
  mChart.invalidate();
}","private void setData(int count,float range){
  float mult=range;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count + 1; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 5,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count + 1; i++)   xVals.add(mParties[i % mParties.length]);
  PieDataSet dataSet=new PieDataSet(yVals1,""String_Node_Str"");
  dataSet.setSliceSpace(3f);
  dataSet.setSelectionShift(5f);
  ArrayList<Integer> colors=new ArrayList<Integer>();
  for (  int c : ColorTemplate.VORDIPLOM_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.JOYFUL_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.COLORFUL_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.LIBERTY_COLORS)   colors.add(c);
  for (  int c : ColorTemplate.PASTEL_COLORS)   colors.add(c);
  colors.add(ColorTemplate.getHoloBlue());
  dataSet.setColors(colors);
  PieData data=new PieData(xVals,dataSet);
  data.setValueFormatter(new PercentFormatter());
  data.setValueTextSize(11f);
  data.setValueTextColor(Color.WHITE);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.highlightValues(null);
  mChart.invalidate();
}",0.986081822016027
26561,"/** 
 * Set the hole in the center of the PieChart transparent. Thank you, code provided by:
 * @link https://github.com/tbarthel-fr
 * @param enable
 */
public void setHoleColorTransparent(boolean enable){
  if (enable) {
    ((PieChartRenderer)mRenderer).getPaintHole().setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));
  }
 else {
    ((PieChartRenderer)mRenderer).getPaintHole().setXfermode(null);
  }
}","/** 
 * Set the hole in the center of the PieChart transparent. Thank you, code provided by:
 * @link https://github.com/tbarthel-fr
 * @param enable
 */
public void setHoleColorTransparent(boolean enable){
  if (enable) {
    ((PieChartRenderer)mRenderer).getPaintHole().setColor(0xFFFFFFFF);
    ((PieChartRenderer)mRenderer).getPaintHole().setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
  }
 else {
    ((PieChartRenderer)mRenderer).getPaintHole().setXfermode(null);
  }
}",0.908489525909592
26562,"public PieChartRenderer(PieChart chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(animator,viewPortHandler);
  mChart=chart;
  mHolePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHolePaint.setColor(Color.WHITE);
  mCenterTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCenterTextPaint.setColor(Color.BLACK);
  mCenterTextPaint.setTextSize(Utils.convertDpToPixel(12f));
  mCenterTextPaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(13f));
  mValuePaint.setColor(Color.WHITE);
  mValuePaint.setTextAlign(Align.CENTER);
}","public PieChartRenderer(PieChart chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(animator,viewPortHandler);
  mChart=chart;
  mHolePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHolePaint.setColor(Color.WHITE);
  mHolePaint.setStyle(Style.FILL);
  mTransparentCirclePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTransparentCirclePaint.setColor(Color.WHITE);
  mTransparentCirclePaint.setStyle(Style.FILL);
  mCenterTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCenterTextPaint.setColor(Color.BLACK);
  mCenterTextPaint.setTextSize(Utils.convertDpToPixel(12f));
  mCenterTextPaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(13f));
  mValuePaint.setColor(Color.WHITE);
  mValuePaint.setTextAlign(Align.CENTER);
}",0.8556390977443609
26563,"@Override public void drawData(Canvas c){
  if (mDrawBitmap == null) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  if (mDrawBitmap == null || ((int)mViewPortHandler.getChartHeight() != mDrawBitmap.getHeight())) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_8888);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}",0.8753738783649053
26564,"/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    int color=mHolePaint.getColor();
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
    if (transparentCircleRadius > holeRadius) {
      mHolePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mHolePaint);
      mHolePaint.setColor(color);
    }
  }
}","/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    if (transparentCircleRadius > holeRadius) {
      int color=mTransparentCirclePaint.getColor();
      mTransparentCirclePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mTransparentCirclePaint);
      mTransparentCirclePaint.setColor(color);
    }
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
  }
}",0.7226666666666667
26565,"@Override public void drawExtras(Canvas c){
  drawHole(c);
  drawCenterText(c);
}","@Override public void drawExtras(Canvas c){
  drawHole(c);
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
  drawCenterText(c);
}",0.7788461538461539
26566,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 3f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0, maxEntry=Math.min((int)Math.ceil(entries.size() * mAnimator.getPhaseX()),entries.size()); j < maxEntry; j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 10f * 3.6f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0, maxEntry=Math.min((int)Math.ceil(entries.size() * mAnimator.getPhaseX()),entries.size()); j < maxEntry; j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      float lineHeight=Utils.calcTextHeight(mValuePaint,val) + Utils.convertDpToPixel(4f);
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight / 2f,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y + lineHeight / 2f,mValuePaint);
      }
      cnt++;
    }
  }
}",0.9410618606916707
26567,"@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f)   maxLeft=maxLeft + 1f;
  if (rightRange == 0f)   maxRight=maxRight + 1f;
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  if (leftRange == 0f) {
    maxLeft=maxLeft + 1f;
    if (!mAxisLeft.isStartAtZeroEnabled())     minLeft=minLeft - 1f;
  }
  if (rightRange == 0f) {
    maxRight=maxRight + 1f;
    if (!mAxisRight.isStartAtZeroEnabled())     minRight=minRight - 1f;
  }
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.956083916083916
26568,"/** 
 * Sets the one and ONLY color that should be used for this DataSet when open <= close. Internally, this recreates the colors array and adds the specified color.
 * @param color
 */
public void setIncreasingColor(int color){
  mIncreasingColor=color;
}","/** 
 * Sets the one and ONLY color that should be used for this DataSet when open <= close. 
 * @param color
 */
public void setIncreasingColor(int color){
  mIncreasingColor=color;
}",0.8344671201814059
26569,"/** 
 * Sets the one and ONLY color that should be used for this DataSet when open > close. Internally, this recreates the colors array and adds the specified color.
 * @param color
 */
public void setDecreasingColor(int color){
  mDecreasingColor=color;
}","/** 
 * Sets the one and ONLY color that should be used for this DataSet when open > close. 
 * @param color
 */
public void setDecreasingColor(int color){
  mDecreasingColor=color;
}",0.8337129840546698
26570,"@Override public void feed(List<Entry> entries){
  moveTo(entries.get(mFrom).getXIndex(),entries.get(mFrom).getVal());
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom + 1; i < size; i++) {
    Entry e=entries.get(i);
    lineTo(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}","@Override public void feed(List<Entry> entries){
  moveTo(entries.get(mFrom).getXIndex(),entries.get(mFrom).getVal() * phaseY);
  int size=(int)Math.ceil((mTo - mFrom) * phaseX + mFrom);
  for (int i=mFrom + 1; i < size; i++) {
    Entry e=entries.get(i);
    lineTo(e.getXIndex(),e.getVal() * phaseY);
  }
  reset();
}",0.8521462639109698
26571,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleFilled:
{
  ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
  for (  LineDataSet set : sets) {
    if (set.isDrawFilledEnabled())     set.setDrawFilled(false);
 else     set.setDrawFilled(true);
  }
  mChart.invalidate();
  break;
}
case R.id.actionToggleCircles:
{
ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
for (LineDataSet set : sets) {
  if (set.isDrawCirclesEnabled())   set.setDrawCircles(false);
 else   set.setDrawCircles(true);
}
mChart.invalidate();
break;
}
case R.id.actionToggleCubic:
{
ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
for (LineDataSet set : sets) {
if (set.isDrawCubicEnabled()) set.setDrawCubic(false);
 else set.setDrawCubic(true);
}
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.actionTogglePinch:
{
if (mChart.isPinchZoomEnabled()) mChart.setPinchZoom(false);
 else mChart.setPinchZoom(true);
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleAdjustXLegend:
{
XAxis xLabels=mChart.getXAxis();
if (xLabels.isAdjustXLabelsEnabled()) xLabels.setAdjustXLabels(false);
 else xLabels.setAdjustXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,35);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleFilled:
{
  ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
  for (  LineDataSet set : sets) {
    if (set.isDrawFilledEnabled())     set.setDrawFilled(false);
 else     set.setDrawFilled(true);
  }
  mChart.invalidate();
  break;
}
case R.id.actionToggleCircles:
{
ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
for (LineDataSet set : sets) {
  if (set.isDrawCirclesEnabled())   set.setDrawCircles(false);
 else   set.setDrawCircles(true);
}
mChart.invalidate();
break;
}
case R.id.actionToggleCubic:
{
ArrayList<LineDataSet> sets=(ArrayList<LineDataSet>)mChart.getData().getDataSets();
for (LineDataSet set : sets) {
if (set.isDrawCubicEnabled()) set.setDrawCubic(false);
 else set.setDrawCubic(true);
}
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.actionTogglePinch:
{
if (mChart.isPinchZoomEnabled()) mChart.setPinchZoom(false);
 else mChart.setPinchZoom(true);
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000,EasingFunction.EaseInCubic);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleAdjustXLegend:
{
XAxis xLabels=mChart.getXAxis();
if (xLabels.isAdjustXLabelsEnabled()) xLabels.setAdjustXLabels(false);
 else xLabels.setAdjustXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,35);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}",0.9949008498583568
26572,"/** 
 * limits the drawing on the x-axis 
 */
public void limitFrom(int from){
  mFrom=from;
}","/** 
 * limits the drawing on the x-axis 
 */
public void limitFrom(int from){
  if (from < 0)   from=0;
  mFrom=from;
}",0.8785046728971962
26573,"/** 
 * limits the drawing on the x-axis 
 */
public void limitTo(int to){
  mTo=to;
}","/** 
 * limits the drawing on the x-axis 
 */
public void limitTo(int to){
  if (to < 0)   to=0;
  mTo=to;
}",0.8865979381443299
26574,"@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getLineData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      LineDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      int valOffset=(int)(dataSet.getCircleSize() * 1.75f);
      if (!dataSet.isDrawCirclesEnabled())       valOffset=valOffset / 2;
      List<Entry> entries=dataSet.getYVals();
      Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
      Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
      int minx=dataSet.getEntryPosition(entryFrom);
      if (minx < 0)       minx=0;
      int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
      float[] positions=trans.generateTransformedValuesLine(entries,mAnimator.getPhaseX(),mAnimator.getPhaseY(),minx,maxx);
      for (int j=0; j < positions.length; j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2 + minx).getVal();
        c.drawText(dataSet.getValueFormatter().getFormattedValue(val),x,y - valOffset,mValuePaint);
      }
    }
  }
}",0.9886135298057602
26575,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() * 3 + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add((i + 1990) + ""String_Node_Str"");
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals2=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals3=new ArrayList<BarEntry>();
  float mult=mSeekBarY.getProgress() * 1000f;
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals2.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals3.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(Color.rgb(104,241,175));
  BarDataSet set2=new BarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(Color.rgb(164,228,251));
  BarDataSet set3=new BarDataSet(yVals3,""String_Node_Str"");
  set3.setColor(Color.rgb(242,247,158));
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  dataSets.add(set3);
  BarData data=new BarData(xVals,dataSets);
  data.setGroupSpace(80f);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() * 3));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    xVals.add((i + 1990) + ""String_Node_Str"");
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals2=new ArrayList<BarEntry>();
  ArrayList<BarEntry> yVals3=new ArrayList<BarEntry>();
  float mult=mSeekBarY.getProgress() * 1000f;
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals2.add(new BarEntry(val,i));
  }
  for (int i=0; i < mSeekBarX.getProgress(); i++) {
    float val=(float)(Math.random() * mult) + 3;
    yVals3.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(Color.rgb(104,241,175));
  BarDataSet set2=new BarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(Color.rgb(164,228,251));
  BarDataSet set3=new BarDataSet(yVals3,""String_Node_Str"");
  set3.setColor(Color.rgb(242,247,158));
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  dataSets.add(set3);
  BarData data=new BarData(xVals,dataSets);
  data.setGroupSpace(80f);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}",0.997489014438167
26576,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
    for (    Runnable r : mJobs) {
      post(r);
    }
    mJobs.clear();
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    if (mDrawBitmap != null)     mDrawBitmap.recycle();
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
    for (    Runnable r : mJobs) {
      post(r);
    }
    mJobs.clear();
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}",0.948339483394834
26577,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    List<Entry> entries=dataSet.getYVals();
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=Math.min(dataSet.getEntryPosition(entryTo) + 1,entries.size());
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.limitFrom(minx);
    buffer.limitTo(maxx);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0, count=(int)Math.ceil((maxx - minx) * phaseX + minx) * 2; j < count; j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2 + minx);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.9979296066252588
26578,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  List<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  Path limitLinePath=new Path();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=mViewPortHandler.contentLeft();
    pts[2]=mViewPortHandler.contentRight();
    limitLinePath.moveTo(pts[0],pts[1]);
    limitLinePath.lineTo(pts[2],pts[3]);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawPath(limitLinePath,mLimitLinePaint);
    limitLinePath.reset();
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  List<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[2];
  Path limitLinePath=new Path();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setStyle(Paint.Style.STROKE);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    pts[1]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    limitLinePath.moveTo(mViewPortHandler.contentLeft(),pts[1]);
    limitLinePath.lineTo(mViewPortHandler.contentRight(),pts[1]);
    c.drawPath(limitLinePath,mLimitLinePaint);
    limitLinePath.reset();
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setStyle(Paint.Style.FILL_AND_STROKE);
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.8050058207217695
26579,"public YAxisRenderer(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,trans);
  this.mYAxis=yAxis;
  mAxisLabelPaint.setColor(Color.BLACK);
  mAxisLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.FILL_AND_STROKE);
}","public YAxisRenderer(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,trans);
  this.mYAxis=yAxis;
  mAxisLabelPaint.setColor(Color.BLACK);
  mAxisLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.STROKE);
}",0.9869375907111756
26580,"@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData data=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  data.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  data.setValueTextColor(Color.WHITE);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(data);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData data=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  data.setValueTypeface(mTf);
  data.setValueTextColor(Color.BLACK);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(data);
  holder.chart.animateY(700);
  return convertView;
}",0.9647058823529412
26581,"/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  calculateFormatter(data.getYMin(),data.getYMax());
  for (  DataSet<?> set : mData.getDataSets()) {
    if (set.needsDefaultFormatter())     set.setValueFormatter(mDefaultFormatter);
  }
  notifyDataSetChanged();
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null || data.getYValCount() <= 0) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  calculateFormatter(data.getYMin(),data.getYMax());
  for (  DataSet<?> set : mData.getDataSets()) {
    if (set.needsDefaultFormatter())     set.setValueFormatter(mDefaultFormatter);
  }
  notifyDataSetChanged();
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}",0.9763912310286678
26582,"/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  List<String> labels=new ArrayList<String>();
  List<Integer> colors=new ArrayList<Integer>();
  for (int i=0; i < data.getDataSetCount(); i++) {
    DataSet<? extends Entry> dataSet=data.getDataSetByIndex(i);
    List<Integer> clrs=dataSet.getColors();
    int entryCount=dataSet.getEntryCount();
    if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).getStackSize() > 1) {
      BarDataSet bds=(BarDataSet)dataSet;
      String[] sLabels=bds.getStackLabels();
      for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
        labels.add(sLabels[j % sLabels.length]);
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(bds.getLabel());
    }
 else     if (dataSet instanceof PieDataSet) {
      List<String> xVals=data.getXVals();
      PieDataSet pds=(PieDataSet)dataSet;
      for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
        labels.add(xVals.get(j));
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(pds.getLabel());
    }
 else {
      for (int j=0; j < clrs.size() && j < entryCount; j++) {
        if (j < clrs.size() - 1 && j < entryCount - 1) {
          labels.add(null);
        }
 else {
          String label=data.getDataSetByIndex(i).getLabel();
          labels.add(label);
        }
        colors.add(clrs.get(j));
      }
    }
  }
  mLegend.setColors(colors);
  mLegend.setLabels(labels);
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint);
}","/** 
 * Prepares the legend and calculates all needed forms, labels and colors.
 * @param data
 */
public void computeLegend(ChartData<?> data){
  List<String> labels=new ArrayList<String>();
  List<Integer> colors=new ArrayList<Integer>();
  for (int i=0; i < data.getDataSetCount(); i++) {
    DataSet<? extends Entry> dataSet=data.getDataSetByIndex(i);
    List<Integer> clrs=dataSet.getColors();
    int entryCount=dataSet.getEntryCount();
    if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).isStacked()) {
      BarDataSet bds=(BarDataSet)dataSet;
      String[] sLabels=bds.getStackLabels();
      for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
        labels.add(sLabels[j % sLabels.length]);
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(bds.getLabel());
    }
 else     if (dataSet instanceof PieDataSet) {
      List<String> xVals=data.getXVals();
      PieDataSet pds=(PieDataSet)dataSet;
      for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
        labels.add(xVals.get(j));
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(pds.getLabel());
    }
 else {
      for (int j=0; j < clrs.size() && j < entryCount; j++) {
        if (j < clrs.size() - 1 && j < entryCount - 1) {
          labels.add(null);
        }
 else {
          String label=data.getDataSetByIndex(i).getLabel();
          labels.add(label);
        }
        colors.add(clrs.get(j));
      }
    }
  }
  mLegend.setColors(colors);
  mLegend.setLabels(labels);
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  mLegend.calculateDimensions(mLegendLabelPaint);
}",0.994778785380599
26583,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(true);
  xl.setGridLineWidth(0.3f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setGridLineWidth(0.3f);
  yl.setInverted(true);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(tf);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  yr.setInverted(true);
  setData(12,50);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(true);
  xl.setGridLineWidth(0.3f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setGridLineWidth(0.3f);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(tf);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  setData(12,50);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9851668726823238
26584,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 3f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mAnimator.getPhaseX(); j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawXVals=mChart.isDrawSliceTextEnabled();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 3f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  List<PieDataSet> dataSets=data.getDataSets();
  boolean drawXVals=mChart.isDrawSliceTextEnabled();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled() && !drawXVals)     continue;
    applyValueTextStyle(dataSet);
    List<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mAnimator.getPhaseX(); j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}",0.9685916919959472
26585,"/** 
 * Moves the left side of the current viewport to the specified x-index.
 * @param xIndex
 */
public void moveViewToX(int xIndex){
  float[] pts=new float[]{xIndex,0f};
  getTransformer(AxisDependency.LEFT).pointValuesToPixel(pts);
  mViewPortHandler.centerViewPort(pts,this);
}","/** 
 * Moves the left side of the current viewport to the specified x-index.
 * @param xIndex
 */
public void moveViewToX(float xIndex){
  Runnable job=new MoveViewJob(mViewPortHandler,xIndex,0f,getTransformer(AxisDependency.LEFT),this);
  if (mViewPortHandler.hasChartDimens()) {
    post(job);
  }
 else {
    mJobs.add(job);
  }
}",0.6353322528363047
26586,"/** 
 * Centers the viewport to the specified y-value on the y-axis.
 * @param yValue
 * @param axis - which axis should be used as a reference for the y-axis
 */
public void moveViewToY(float yValue,AxisDependency axis){
  float valsInView=getDeltaY(axis) / mViewPortHandler.getScaleY();
  float[] pts=new float[]{0f,yValue + valsInView / 2f};
  getTransformer(axis).pointValuesToPixel(pts);
  mViewPortHandler.centerViewPort(pts,this);
}","/** 
 * Centers the viewport to the specified y-value on the y-axis.
 * @param yValue
 * @param axis - which axis should be used as a reference for the y-axis
 */
public void moveViewToY(float yValue,AxisDependency axis){
  float valsInView=getDeltaY(axis) / mViewPortHandler.getScaleY();
  Runnable job=new MoveViewJob(mViewPortHandler,0f,yValue + valsInView / 2f,getTransformer(axis),this);
  if (mViewPortHandler.hasChartDimens()) {
    post(job);
  }
 else {
    mJobs.add(job);
  }
}",0.6537216828478964
26587,"/** 
 * This will move the left side of the current viewport to the specified x-index on the x-axis, and center the viewport to the specified y-value on the y-axis.
 * @param xIndex
 * @param yValue
 * @param axis - which axis should be used as a reference for the y-axis
 */
public void moveViewTo(int xIndex,float yValue,AxisDependency axis){
  float valsInView=getDeltaY(axis) / mViewPortHandler.getScaleY();
  float[] pts=new float[]{xIndex,yValue + valsInView / 2f};
  getTransformer(axis).pointValuesToPixel(pts);
  mViewPortHandler.centerViewPort(pts,this);
}","/** 
 * This will move the left side of the current viewport to the specified x-index on the x-axis, and center the viewport to the specified y-value on the y-axis.
 * @param xIndex
 * @param yValue
 * @param axis - which axis should be used as a reference for the y-axis
 */
public void moveViewTo(float xIndex,float yValue,AxisDependency axis){
  float valsInView=getDeltaY(axis) / mViewPortHandler.getScaleY();
  Runnable job=new MoveViewJob(mViewPortHandler,xIndex,yValue + valsInView / 2f,getTransformer(axis),this);
  if (mViewPortHandler.hasChartDimens()) {
    post(job);
  }
 else {
    mJobs.add(job);
  }
}",0.7675401521555367
26588,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
    for (    Runnable r : mJobs) {
      post(r);
    }
    mJobs.clear();
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}",0.9213011542497376
26589,"/** 
 * Centers the viewport around the specified position (x-index and y-value) in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method.
 * @param pts the position to center view viewport to
 * @param chart
 * @return save
 */
public synchronized void centerViewPort(final float[] transformedPts,final Chart<?> chart){
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  final float x=transformedPts[0] - offsetLeft();
  final float y=transformedPts[1] - offsetTop();
  save.postTranslate(-x,-y);
  refresh(save,chart,false);
}","/** 
 * Centers the viewport around the specified position (x-index and y-value) in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method.
 * @param pts the position to center view viewport to
 * @param chart
 * @return save
 */
public synchronized void centerViewPort(final float[] transformedPts,final View view){
  Matrix save=new Matrix();
  save.set(mMatrixTouch);
  final float x=transformedPts[0] - offsetLeft();
  final float y=transformedPts[1] - offsetTop();
  Log.i(""String_Node_Str"",""String_Node_Str"" + x + ""String_Node_Str""+ y);
  save.postTranslate(-x,-y);
  refresh(save,view,false);
}",0.9208741522230596
26590,"/** 
 * call this method to refresh the graph with a given matrix
 * @param newMatrix
 * @return
 */
public Matrix refresh(Matrix newMatrix,Chart<?> chart,boolean invalidate){
  mMatrixTouch.set(newMatrix);
  limitTransAndScale(mMatrixTouch,mContentRect);
  chart.invalidate();
  newMatrix.set(mMatrixTouch);
  return newMatrix;
}","/** 
 * call this method to refresh the graph with a given matrix
 * @param newMatrix
 * @return
 */
public Matrix refresh(Matrix newMatrix,View chart,boolean invalidate){
  mMatrixTouch.set(newMatrix);
  limitTransAndScale(mMatrixTouch,mContentRect);
  chart.invalidate();
  newMatrix.set(mMatrixTouch);
  return newMatrix;
}",0.9817073170731708
26591,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  rightAxis.setSpaceTop(15f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  rightAxis.setSpaceTop(15f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
}",0.9980732177263968
26592,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  data.setValueTextSize(10f);
  data.setValueTypeface(mTf);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count - 1; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  yVals1.add(new BarEntry(-20f,count - 1));
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  data.setValueTextSize(10f);
  data.setValueTypeface(mTf);
  mChart.setData(data);
}",0.965665236051502
26593,"@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (!mContainsStacks || vals == null) {
      float left=x - barWidth + barSpaceHalf;
      float right=x + barWidth - barSpaceHalf;
      float top=y >= 0 ? y : 0;
      float bottom=y <= 0 ? y : 0;
      if (top > 0)       top*=phaseY;
 else       bottom*=phaseY;
      addBar(left,top,right,bottom);
    }
 else {
      float all=e.getVal();
      for (int k=0; k < vals.length; k++) {
        all-=vals[k];
        y=vals[k] + all;
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        if (top > 0)         top*=phaseY;
 else         bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
    }
  }
  reset();
}","@Override public void feed(List<BarEntry> entries){
  float size=entries.size() * phaseX;
  int dataSetOffset=(mDataSetCount - 1);
  float barSpaceHalf=mBarSpace / 2f;
  float groupSpaceHalf=mGroupSpace / 2f;
  float barWidth=0.5f;
  for (int i=0; i < size; i++) {
    BarEntry e=entries.get(i);
    float x=e.getXIndex() + i * dataSetOffset + mDataSetIndex + mGroupSpace * i + groupSpaceHalf;
    float y=e.getVal();
    float[] vals=e.getVals();
    if (mInverted) {
      if (!mContainsStacks || vals == null) {
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float bottom=y >= 0 ? y : 0;
        float top=y <= 0 ? y : 0;
        if (top > 0)         top*=phaseY;
 else         bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
 else {
        float all=e.getVal();
        for (int k=0; k < vals.length; k++) {
          all-=vals[k];
          y=vals[k] + all;
          float left=x - barWidth + barSpaceHalf;
          float right=x + barWidth - barSpaceHalf;
          float bottom=y >= 0 ? y : 0;
          float top=y <= 0 ? y : 0;
          if (top > 0)           top*=phaseY;
 else           bottom*=phaseY;
          addBar(left,top,right,bottom);
        }
      }
    }
 else {
      if (!mContainsStacks || vals == null) {
        float left=x - barWidth + barSpaceHalf;
        float right=x + barWidth - barSpaceHalf;
        float top=y >= 0 ? y : 0;
        float bottom=y <= 0 ? y : 0;
        if (top > 0)         top*=phaseY;
 else         bottom*=phaseY;
        addBar(left,top,right,bottom);
      }
 else {
        float all=e.getVal();
        for (int k=0; k < vals.length; k++) {
          all-=vals[k];
          y=vals[k] + all;
          float left=x - barWidth + barSpaceHalf;
          float right=x + barWidth - barSpaceHalf;
          float top=y >= 0 ? y : 0;
          float bottom=y <= 0 ? y : 0;
          if (top > 0)           top*=phaseY;
 else           bottom*=phaseY;
          addBar(left,top,right,bottom);
        }
      }
    }
  }
  reset();
}",0.7015931372549019
26594,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (true) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.9955290611028316
26595,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}","protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}",0.9801249290176036
26596,"/** 
 * Prepares a bar for being highlighted.
 * @param x the x-position
 * @param y the y-position
 * @param barspace the space between bars
 * @param from
 * @param trans
 */
protected void prepareBarHighlight(float x,float y,float barspace,float from,Transformer trans){
  float barWidth=0.5f;
  float spaceHalf=barspace / 2f;
  float left=x - barWidth + spaceHalf;
  float right=x + barWidth - spaceHalf;
  float top=y >= from ? y : from;
  float bottom=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","/** 
 * Prepares a bar for being highlighted.
 * @param x the x-position
 * @param y the y-position
 * @param barspace the space between bars
 * @param from
 * @param trans
 */
protected void prepareBarHighlight(float x,float y,float barspaceHalf,float from,Transformer trans){
  float barWidth=0.5f;
  float left=x - barWidth + barspaceHalf;
  float right=x + barWidth - barspaceHalf;
  float top=y >= from ? y : from;
  float bottom=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}",0.8879082082965578
26597,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null)     continue;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,set.getBarSpace(),from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null)     continue;
    float barspaceHalf=set.getBarSpace() / 2f;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,barspaceHalf,from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.9781232009211284
26598,"@Override protected void prepareBarHighlight(float x,float y,float barspace,float from,Transformer trans){
  float spaceHalf=barspace / 2f;
  float top=x - 0.5f + spaceHalf;
  float bottom=x + 0.5f - spaceHalf;
  float left=y >= from ? y : from;
  float right=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixel(mBarRect,mAnimator.getPhaseY());
}","@Override protected void prepareBarHighlight(float x,float y,float barspaceHalf,float from,Transformer trans){
  float top=x - 0.5f + barspaceHalf;
  float bottom=x + 0.5f - barspaceHalf;
  float left=y >= from ? y : from;
  float right=y <= from ? y : from;
  mBarRect.set(left,top,right,bottom);
  trans.rectValueToPixelHorizontal(mBarRect,mAnimator.getPhaseY());
}",0.92904953145917
26599,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled()) {
        yMin=(float)Math.min(p1.y,p2.y);
      }
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      yMin=(float)p1.y;
      yMax=(float)p2.y;
    }
  }
  computeAxisValues(yMin,yMax);
}",0.8326797385620915
26600,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentHeight() > 10 && !mViewPortHandler.isFullyZoomedOutX()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentRight(),mViewPortHandler.contentTop());
    if (!mYAxis.isInverted()) {
      yMin=(float)p1.x;
      yMax=(float)p2.x;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.x,p2.x);
 else       yMin=0;
      yMax=(float)Math.max(p1.x,p2.x);
    }
  }
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentHeight() > 10 && !mViewPortHandler.isFullyZoomedOutX()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentRight(),mViewPortHandler.contentTop());
    if (!mYAxis.isInverted()) {
      yMin=(float)p1.x;
      yMax=(float)p2.x;
    }
 else {
      yMin=(float)p2.x;
      yMax=(float)p1.x;
    }
  }
  computeAxisValues(yMin,yMax);
}",0.8403693931398417
26601,"protected void drawDataSet(Canvas c,ScatterDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<Entry> entries=dataSet.getYVals();
  float shapeHalf=dataSet.getScatterShapeSize() / 2f;
  ScatterShape shape=dataSet.getScatterShape();
  ScatterBuffer buffer=mScatterBuffers[mChart.getScatterData().getIndexOfDataSet(dataSet)];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
switch (shape) {
case SQUARE:
    mRenderPaint.setStyle(Style.FILL);
  for (int i=0; i < buffer.size(); i+=2) {
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i]))     break;
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1]))     continue;
    mRenderPaint.setColor(dataSet.getColor(i));
    c.drawRect(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
  }
break;
case CIRCLE:
mRenderPaint.setStyle(Style.FILL);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i));
c.drawCircle(buffer.buffer[i],buffer.buffer[i + 1],shapeHalf,mRenderPaint);
}
break;
case TRIANGLE:
mRenderPaint.setStyle(Style.FILL);
Path tri=new Path();
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i));
tri.moveTo(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf);
tri.lineTo(buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.lineTo(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.close();
c.drawPath(tri,mRenderPaint);
tri.reset();
}
break;
case CROSS:
mRenderPaint.setStyle(Style.STROKE);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i));
c.drawLine(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1],buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1],mRenderPaint);
c.drawLine(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i],buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
}
break;
default :
break;
}
}","protected void drawDataSet(Canvas c,ScatterDataSet dataSet){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  List<Entry> entries=dataSet.getYVals();
  float shapeHalf=dataSet.getScatterShapeSize() / 2f;
  ScatterShape shape=dataSet.getScatterShape();
  ScatterBuffer buffer=mScatterBuffers[mChart.getScatterData().getIndexOfDataSet(dataSet)];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
switch (shape) {
case SQUARE:
    mRenderPaint.setStyle(Style.FILL);
  for (int i=0; i < buffer.size(); i+=2) {
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i]))     break;
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1]))     continue;
    mRenderPaint.setColor(dataSet.getColor(i / 2));
    c.drawRect(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
  }
break;
case CIRCLE:
mRenderPaint.setStyle(Style.FILL);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawCircle(buffer.buffer[i],buffer.buffer[i + 1],shapeHalf,mRenderPaint);
}
break;
case TRIANGLE:
mRenderPaint.setStyle(Style.FILL);
Path tri=new Path();
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
tri.moveTo(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf);
tri.lineTo(buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.lineTo(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1] + shapeHalf);
tri.close();
c.drawPath(tri,mRenderPaint);
tri.reset();
}
break;
case CROSS:
mRenderPaint.setStyle(Style.STROKE);
for (int i=0; i < buffer.size(); i+=2) {
if (!mViewPortHandler.isInBoundsRight(buffer.buffer[i])) break;
if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[i]) || !mViewPortHandler.isInBoundsY(buffer.buffer[i + 1])) continue;
mRenderPaint.setColor(dataSet.getColor(i / 2));
c.drawLine(buffer.buffer[i] - shapeHalf,buffer.buffer[i + 1],buffer.buffer[i] + shapeHalf,buffer.buffer[i + 1],mRenderPaint);
c.drawLine(buffer.buffer[i],buffer.buffer[i + 1] - shapeHalf,buffer.buffer[i],buffer.buffer[i + 1] + shapeHalf,mRenderPaint);
}
break;
default :
break;
}
}",0.9970642201834864
26602,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_pie,container,false);
  mChart=(PieChart)v.findViewById(R.id.pieChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str""));
  mChart.setCenterText(""String_Node_Str"");
  mChart.setCenterTextSize(22f);
  mChart.setHoleRadius(45f);
  mChart.setTransparentCircleRadius(50f);
  mChart.setData(generatePieData());
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_pie,container,false);
  mChart=(PieChart)v.findViewById(R.id.pieChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setCenterTextTypeface(tf);
  mChart.setCenterText(""String_Node_Str"");
  mChart.setCenterTextSize(22f);
  mChart.setCenterTextTypeface(tf);
  mChart.setHoleRadius(45f);
  mChart.setTransparentCircleRadius(50f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  mChart.setData(generatePieData());
  return v;
}",0.8744460856720827
26603,"/** 
 * generates less data (1 DataSet, 4 values)
 * @return
 */
protected PieData generatePieData(){
  int count=4;
  ArrayList<Entry> entries1=new ArrayList<Entry>();
  ArrayList<String> xVals=new ArrayList<String>();
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  for (int i=0; i < count; i++) {
    xVals.add(""String_Node_Str"" + (i + 1));
    entries1.add(new Entry((float)(Math.random() * 60) + 40,i));
  }
  PieDataSet ds1=new PieDataSet(entries1,""String_Node_Str"");
  ds1.setColors(ColorTemplate.VORDIPLOM_COLORS);
  ds1.setSliceSpace(2f);
  PieData d=new PieData(xVals,ds1);
  d.setValueTypeface(tf);
  return d;
}","/** 
 * generates less data (1 DataSet, 4 values)
 * @return
 */
protected PieData generatePieData(){
  int count=4;
  ArrayList<Entry> entries1=new ArrayList<Entry>();
  ArrayList<String> xVals=new ArrayList<String>();
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  xVals.add(""String_Node_Str"");
  for (int i=0; i < count; i++) {
    xVals.add(""String_Node_Str"" + (i + 1));
    entries1.add(new Entry((float)(Math.random() * 60) + 40,i));
  }
  PieDataSet ds1=new PieDataSet(entries1,""String_Node_Str"");
  ds1.setColors(ColorTemplate.VORDIPLOM_COLORS);
  ds1.setSliceSpace(2f);
  ds1.setValueTextColor(Color.WHITE);
  ds1.setValueTextSize(12f);
  PieData d=new PieData(xVals,ds1);
  d.setValueTypeface(tf);
  return d;
}",0.9546377792823292
26604,"/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  String centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    String[] lines=centerText.split(""String_Node_Str"");
    float lineHeight=Utils.calcTextHeight(mCenterTextPaint,lines[0]);
    float linespacing=lineHeight * 0.2f;
    float totalheight=lineHeight * lines.length - linespacing * (lines.length - 1);
    int cnt=lines.length;
    float y=center.y;
    for (int i=0; i < lines.length; i++) {
      String line=lines[lines.length - i - 1];
      c.drawText(line,center.x,y + lineHeight * cnt - totalheight / 2f,mCenterTextPaint);
      cnt--;
      y-=linespacing;
    }
  }
}","/** 
 * draws the description text in the center of the pie chart makes most sense when center-hole is enabled
 */
protected void drawCenterText(Canvas c){
  String centerText=mChart.getCenterText();
  if (mChart.isDrawCenterTextEnabled() && centerText != null) {
    PointF center=mChart.getCenterCircleBox();
    String[] lines=centerText.split(""String_Node_Str"");
    float maxlineheight=0f;
    for (    String line : lines) {
      float curHeight=Utils.calcTextHeight(mCenterTextPaint,line);
      if (curHeight > maxlineheight)       maxlineheight=curHeight;
    }
    float linespacing=maxlineheight * 0.25f;
    float totalheight=maxlineheight * lines.length - linespacing * (lines.length - 1);
    int cnt=lines.length;
    float y=center.y;
    for (int i=0; i < lines.length; i++) {
      String line=lines[lines.length - i - 1];
      c.drawText(line,center.x,y + maxlineheight * cnt - totalheight / 2f,mCenterTextPaint);
      cnt--;
      y-=linespacing;
    }
  }
}",0.8310401761144744
26605,"private void setupChart(LineChart chart,LineData data,int color){
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setViewPortOffsets(10,0,10,0);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  chart.getAxisLeft().setEnabled(false);
  chart.getAxisRight().setEnabled(false);
  chart.getXAxis().setEnabled(false);
  chart.animateX(2500);
}","private void setupChart(LineChart chart,LineData data,int color){
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setViewPortOffsets(10,0,10,0);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setEnabled(false);
  chart.getAxisLeft().setEnabled(false);
  chart.getAxisRight().setEnabled(false);
  chart.getXAxis().setEnabled(false);
  chart.animateX(2500);
}",0.9187547456340168
26606,"@Override public void run(){
  mViewPortHandler.restrainViewPort(left,top,right,bottom);
}","@Override public void run(){
  mViewPortHandler.restrainViewPort(left,top,right,bottom);
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.7792207792207793
26607,"/** 
 * Sets custom offsets for the current ViewPort (the offsets on the sides of the actual chart window). Setting this will prevent the chart from automatically calculating it's offsets. Use resetViewPortOffsets() to undo this.
 * @param left
 * @param top
 * @param right
 * @param bottom
 */
public void setViewPortOffsets(final float left,final float top,final float right,final float bottom){
  mCustomViewPortEnabled=true;
  post(new Runnable(){
    @Override public void run(){
      mViewPortHandler.restrainViewPort(left,top,right,bottom);
    }
  }
);
}","/** 
 * Sets custom offsets for the current ViewPort (the offsets on the sides of the actual chart window). Setting this will prevent the chart from automatically calculating it's offsets. Use resetViewPortOffsets() to undo this.
 * @param left
 * @param top
 * @param right
 * @param bottom
 */
public void setViewPortOffsets(final float left,final float top,final float right,final float bottom){
  mCustomViewPortEnabled=true;
  post(new Runnable(){
    @Override public void run(){
      mViewPortHandler.restrainViewPort(left,top,right,bottom);
      prepareOffsetMatrix();
      prepareValuePxMatrix();
    }
  }
);
}",0.9502948609941028
26608,"/** 
 * Sets the size of the area (range on the x-axis) that should be maximum visible at once. If this is e.g. set to 10, no more than 10 values on the x-axis can be viewed at once without scrolling.
 * @param xRange
 */
public void setVisibleXRange(float xRange){
  float xScale=mDeltaX / (xRange + 0.01f);
  mViewPortHandler.setMinimumScaleX(xScale);
}","/** 
 * Sets the size of the area (range on the x-axis) that should be maximum visible at once. If this is e.g. set to 10, no more than 10 values on the x-axis can be viewed at once without scrolling.
 * @param xRange
 */
public void setVisibleXRange(float xRange){
  float xScale=mDeltaX / (xRange);
  mViewPortHandler.setMinimumScaleX(xScale);
}",0.9886039886039886
26609,"/** 
 * Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
 * @param chart
 */
public void prepareMatrixValuePx(float xChartMin,float deltaX,float deltaY,float yChartMin){
  float scaleX=(float)((mViewPortHandler.getChartWidth() - mViewPortHandler.offsetRight() - mViewPortHandler.offsetLeft()) / deltaX);
  float scaleY=(float)((mViewPortHandler.getChartHeight() - mViewPortHandler.offsetTop() - mViewPortHandler.offsetBottom()) / deltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(-xChartMin,-yChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
}","/** 
 * Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
 * @param chart
 */
public void prepareMatrixValuePx(float xChartMin,float deltaX,float deltaY,float yChartMin){
  float scaleX=(float)((mViewPortHandler.contentWidth()) / deltaX);
  float scaleY=(float)((mViewPortHandler.contentHeight()) / deltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(-xChartMin,-yChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
}",0.8534031413612565
26610,"@Override protected void onDraw(Canvas canvas){
  if (mDataNotSet) {
    canvas.drawText(mNoDataText,getWidth() / 2,getHeight() / 2,mInfoPaint);
    if (!TextUtils.isEmpty(mNoDataTextDescription)) {
      float textOffset=-mInfoPaint.ascent() + mInfoPaint.descent();
      canvas.drawText(mNoDataTextDescription,getWidth() / 2,(getHeight() / 2) + textOffset,mInfoPaint);
    }
    return;
  }
  if (!mOffsetsCalculated) {
    calculateOffsets();
    mOffsetsCalculated=true;
  }
}","@Override protected void onDraw(Canvas canvas){
  if (mDataNotSet || mData == null || mData.getYValCount() <= 0) {
    canvas.drawText(mNoDataText,getWidth() / 2,getHeight() / 2,mInfoPaint);
    if (!TextUtils.isEmpty(mNoDataTextDescription)) {
      float textOffset=-mInfoPaint.ascent() + mInfoPaint.descent();
      canvas.drawText(mNoDataTextDescription,getWidth() / 2,(getHeight() / 2) + textOffset,mInfoPaint);
    }
    return;
  }
  if (!mOffsetsCalculated) {
    calculateOffsets();
    mOffsetsCalculated=true;
  }
}",0.9542743538767396
26611,"/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null || data.getYValCount() <= 0) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  calculateFormatter(data.getYMin(),data.getYMax());
  for (  DataSet<?> set : mData.getDataSets()) {
    if (set.needsDefaultFormatter())     set.setValueFormatter(mDefaultFormatter);
  }
  notifyDataSetChanged();
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  calculateFormatter(data.getYMin(),data.getYMax());
  for (  DataSet<?> set : mData.getDataSets()) {
    if (set.needsDefaultFormatter())     set.setValueFormatter(mDefaultFormatter);
  }
  notifyDataSetChanged();
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}",0.9763912310286678
26612,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
}",0.8975526465566306
26613,"/** 
 * callback when a DataSet has been drawn (when lifting the finger) 
 */
@Override public void onDrawFinished(DataSet<?> dataSet){
  Log.i(Chart.LOG_TAG,""String_Node_Str"" + dataSet.toSimpleString());
  mChart.getLegendRenderer().computeLegend(mChart.getData(),mChart.getLegend());
}","/** 
 * callback when a DataSet has been drawn (when lifting the finger) 
 */
@Override public void onDrawFinished(DataSet<?> dataSet){
  Log.i(Chart.LOG_TAG,""String_Node_Str"" + dataSet.toSimpleString());
  mChart.getLegendRenderer().computeLegend(mChart.getData());
}",0.9657657657657658
26614,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  if (mRenderer != null)   mRenderer.initBuffers();
  calcMinMax();
  if (mAxisLeft.needsDefaultFormatter())   mAxisLeft.setValueFormatter(mDefaultFormatter);
  if (mAxisRight.needsDefaultFormatter())   mAxisRight.setValueFormatter(mDefaultFormatter);
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  if (mRenderer != null)   mRenderer.initBuffers();
  calcMinMax();
  if (mAxisLeft.needsDefaultFormatter())   mAxisLeft.setValueFormatter(mDefaultFormatter);
  if (mAxisRight.needsDefaultFormatter())   mAxisRight.setValueFormatter(mDefaultFormatter);
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}",0.9896907216494846
26615,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (true) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (true) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.99761620977354
26616,"/** 
 * initialize all paints and stuff
 */
protected void init(){
  setWillNotDraw(false);
  if (android.os.Build.VERSION.SDK_INT < 11)   mAnimator=new ChartAnimator();
 else   mAnimator=new ChartAnimator(new AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      postInvalidate();
    }
  }
);
  Utils.init(getContext().getResources());
  mDefaultFormatter=new DefaultValueFormatter(1);
  mViewPortHandler=new ViewPortHandler();
  mLegend=new Legend();
  mLegendRenderer=new LegendRenderer(mViewPortHandler);
  mRenderPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mRenderPaint.setStyle(Style.FILL);
  mDescPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mDescPaint.setColor(Color.BLACK);
  mDescPaint.setTextAlign(Align.RIGHT);
  mDescPaint.setTextSize(Utils.convertDpToPixel(9f));
  mInfoPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mInfoPaint.setColor(Color.rgb(247,189,51));
  mInfoPaint.setTextAlign(Align.CENTER);
  mInfoPaint.setTextSize(Utils.convertDpToPixel(12f));
  mDrawPaint=new Paint(Paint.DITHER_FLAG);
  if (mLogEnabled)   Log.i(""String_Node_Str"",""String_Node_Str"");
}","/** 
 * initialize all paints and stuff
 */
protected void init(){
  setWillNotDraw(false);
  if (android.os.Build.VERSION.SDK_INT < 11)   mAnimator=new ChartAnimator();
 else   mAnimator=new ChartAnimator(new AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      postInvalidate();
    }
  }
);
  Utils.init(getContext().getResources());
  mDefaultFormatter=new DefaultValueFormatter(1);
  mViewPortHandler=new ViewPortHandler();
  mLegend=new Legend();
  mLegendRenderer=new LegendRenderer(mViewPortHandler,mLegend);
  mRenderPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mRenderPaint.setStyle(Style.FILL);
  mDescPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mDescPaint.setColor(Color.BLACK);
  mDescPaint.setTextAlign(Align.RIGHT);
  mDescPaint.setTextSize(Utils.convertDpToPixel(9f));
  mInfoPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mInfoPaint.setColor(Color.rgb(247,189,51));
  mInfoPaint.setTextAlign(Align.CENTER);
  mInfoPaint.setTextSize(Utils.convertDpToPixel(12f));
  mDrawPaint=new Paint(Paint.DITHER_FLAG);
  if (mLogEnabled)   Log.i(""String_Node_Str"",""String_Node_Str"");
}",0.9964507542147294
26617,"/** 
 * Returns the Legend object of the chart. This method can be used to customize the automatically generated Legend. IMPORTANT: Since the Legend is generated from data provided by the user (via setData(...) method), this will return NULL if no data has been set for the chart. You need to set data for the chart before calling this method.
 * @return
 */
public Legend getLegend(){
  return mLegend;
}","/** 
 * Returns the Legend object of the chart. This method can be used to get an instance of the legend in order to customize the automatically generated Legend.
 * @return
 */
public Legend getLegend(){
  return mLegend;
}",0.5786963434022258
26618,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mRenderer.drawExtras(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawDescription(canvas);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mRenderer.drawExtras(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawDescription(canvas);
}",0.9892761394101875
26619,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}",0.9506172839506172
26620,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxisLabels(canvas);
  if (mDrawWeb)   mRenderer.drawExtras(canvas);
  mYAxisRenderer.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawDescription(canvas);
  drawMarkers(canvas);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxisLabels(canvas);
  if (mDrawWeb)   mRenderer.drawExtras(canvas);
  mYAxisRenderer.renderLimitLines(canvas);
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas);
  drawDescription(canvas);
  drawMarkers(canvas);
}",0.9926062846580408
26621,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  if (mYAxis.needsDefaultFormatter()) {
    mYAxis.setValueFormatter(mDefaultFormatter);
  }
  mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum,mYAxis.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  if (mYAxis.needsDefaultFormatter()) {
    mYAxis.setValueFormatter(mDefaultFormatter);
  }
  mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum,mYAxis.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegendRenderer.computeLegend(mData);
  calculateOffsets();
}",0.9255583126550868
26622,"/** 
 * draws the description text in the bottom right corner of the chart
 */
protected void drawDescription(Canvas c){
  c.drawText(mDescription,getWidth() - mViewPortHandler.offsetRight() - 10,getHeight() - mViewPortHandler.offsetBottom() - 10,mDescPaint);
}","/** 
 * draws the description text in the bottom right corner of the chart
 */
protected void drawDescription(Canvas c){
  if (!mDescription.equals(""String_Node_Str"")) {
    c.drawText(mDescription,getWidth() - mViewPortHandler.offsetRight() - 10,getHeight() - mViewPortHandler.offsetBottom() - 10,mDescPaint);
  }
}",0.9046793760831888
26623,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.removeAllLimitLines();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.9887417218543046
26624,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (true) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.995550281815485
26625,"/** 
 * Adds a new LimitLine to this axis.
 * @param l
 */
public void addLimitLine(LimitLine l){
  mLimitLines.add(l);
}","/** 
 * Adds a new LimitLine to this axis.
 * @param l
 */
public void addLimitLine(LimitLine l){
  mLimitLines.add(l);
  if (mLimitLines.size() > 6) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}",0.7423312883435583
26626,"/** 
 * Removes all LimitLines from the axis.
 */
public void removeAllLimitLines(){
  mLimitLines=new ArrayList<LimitLine>();
}","/** 
 * Removes all LimitLines from the axis.
 */
public void removeAllLimitLines(){
  mLimitLines.clear();
}",0.8860759493670886
26627,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=mViewPortHandler.contentLeft();
    pts[2]=mViewPortHandler.contentRight();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  Path limitLinePath=new Path();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=mViewPortHandler.contentLeft();
    pts[2]=mViewPortHandler.contentRight();
    limitLinePath.moveTo(pts[0],pts[1]);
    limitLinePath.lineTo(pts[2],pts[3]);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawPath(limitLinePath,mLimitLinePaint);
    limitLinePath.reset();
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.9479519556513704
26628,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  xAxis.setSpaceBetweenLabels(2);
  ValueFormatter custom=new MyValueFormatter();
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(8);
  leftAxis.setValueFormatter(custom);
  leftAxis.setPosition(YAxisLabelPosition.OUTSIDE_CHART);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(8);
  rightAxis.setValueFormatter(custom);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setForm(LegendForm.SQUARE);
  l.setFormSize(9f);
  l.setTextSize(11f);
  l.setXEntrySpace(4f);
}",0.973115137346581
26629,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_performance_linechart);
  mTvCount=(TextView)findViewById(R.id.tvValueCount);
  mSeekBarValues=(SeekBar)findViewById(R.id.seekbarValues);
  mTvCount.setText(""String_Node_Str"");
  mSeekBarValues.setProgress(500);
  mSeekBarValues.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(false);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.getXAxis().setDrawGridLines(false);
  mChart.getXAxis().setDrawAxisLine(false);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_performance_linechart);
  mTvCount=(TextView)findViewById(R.id.tvValueCount);
  mSeekBarValues=(SeekBar)findViewById(R.id.seekbarValues);
  mTvCount.setText(""String_Node_Str"");
  mSeekBarValues.setProgress(500);
  mSeekBarValues.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(false);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.getXAxis().setDrawGridLines(true);
  mChart.getXAxis().setDrawAxisLine(false);
  mChart.invalidate();
}",0.996831145314622
26630,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setColor(Color.BLACK);
  set1.setLineWidth(0.5f);
  set1.setDrawValues(false);
  set1.setDrawCircles(false);
  set1.setDrawCubic(false);
  set1.setDrawFilled(true);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
  Legend l=mChart.getLegend();
  l.setEnabled(false);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setColor(Color.BLACK);
  set1.setLineWidth(0.5f);
  set1.setDrawValues(false);
  set1.setDrawCircles(false);
  set1.setDrawCubic(false);
  set1.setDrawFilled(false);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
  Legend l=mChart.getLegend();
  l.setEnabled(false);
}",0.9951757408683668
26631,"@Override protected void init(){
  super.init();
  mAxisLeft=new YAxis(AxisDependency.LEFT);
  mAxisRight=new YAxis(AxisDependency.RIGHT);
  mXAxis=new XAxis();
  mLeftAxisTransformer=new Transformer(mViewPortHandler);
  mRightAxisTransformer=new Transformer(mViewPortHandler);
  mAxisRendererLeft=new YAxisRenderer(mViewPortHandler,mAxisLeft,mLeftAxisTransformer);
  mAxisRendererRight=new YAxisRenderer(mViewPortHandler,mAxisRight,mRightAxisTransformer);
  mXAxisRenderer=new XAxisRenderer(mViewPortHandler,mXAxis,mLeftAxisTransformer);
  mListener=new BarLineChartTouchListener(this,mViewPortHandler.getMatrixTouch());
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
}","@Override protected void init(){
  super.init();
  mAxisLeft=new YAxis(AxisDependency.LEFT);
  mAxisRight=new YAxis(AxisDependency.RIGHT);
  mXAxis=new XAxis();
  mLeftAxisTransformer=new Transformer(mViewPortHandler);
  mRightAxisTransformer=new Transformer(mViewPortHandler);
  mAxisRendererLeft=new YAxisRenderer(mViewPortHandler,mAxisLeft,mLeftAxisTransformer);
  mAxisRendererRight=new YAxisRenderer(mViewPortHandler,mAxisRight,mRightAxisTransformer);
  mXAxisRenderer=new XAxisRenderer(mViewPortHandler,mXAxis,mLeftAxisTransformer);
  mListener=new BarLineChartTouchListener(this,mViewPortHandler.getMatrixTouch());
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
  mBorderPaint=new Paint();
  mBorderPaint.setStyle(Style.STROKE);
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(Utils.convertDpToPixel(1f));
}",0.9027283511269276
26632,"/** 
 * draws the grid background
 */
protected void drawGridBackground(Canvas c){
  if (!mDrawGridBackground)   return;
  c.drawRect(mViewPortHandler.getContentRect(),mGridBackgroundPaint);
}","/** 
 * draws the grid background
 */
protected void drawGridBackground(Canvas c){
  if (mDrawGridBackground) {
    c.drawRect(mViewPortHandler.getContentRect(),mGridBackgroundPaint);
  }
  if (mDrawBorders) {
    c.drawRect(mViewPortHandler.getContentRect(),mBorderPaint);
  }
}",0.7176220806794055
26633,"@Override protected void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    if (mLegend != null && mLegend.isEnabled()) {
      if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
        offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
        offsetBottom+=mLegend.mTextHeightMax * 3f;
      }
    }
    if (mAxisLeft.isEnabled()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getAxisPaint());
    }
    if (mAxisRight.isEnabled()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getAxisPaint());
    }
    float xlabelheight=mXAxis.mLabelHeight * 2f;
    if (mXAxis.isEnabled()) {
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    float min=Utils.convertDpToPixel(10f);
    mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override protected void calculateOffsets(){
  if (!mCustomViewPortEnabled) {
    float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
    if (mLegend != null && mLegend.isEnabled()) {
      if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
        offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
      }
 else       if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
        offsetBottom+=mLegend.mTextHeightMax * 3f;
      }
    }
    if (mAxisLeft.needsOffset()) {
      offsetLeft+=mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft.getAxisPaint());
    }
    if (mAxisRight.needsOffset()) {
      offsetRight+=mAxisRight.getRequiredWidthSpace(mAxisRendererRight.getAxisPaint());
    }
    float xlabelheight=mXAxis.mLabelHeight * 2f;
    if (mXAxis.isEnabled()) {
      if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
        offsetBottom+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.TOP) {
        offsetTop+=xlabelheight;
      }
 else       if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
        offsetBottom+=xlabelheight;
        offsetTop+=xlabelheight;
      }
    }
    float min=Utils.convertDpToPixel(10f);
    mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
    if (mLogEnabled) {
      Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
      Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
    }
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.989310529128808
26634,"/** 
 * Removes all DataSets (and thereby Entries) from the chart. Does not remove the x-values.
 */
public void clearValues(){
  mData.clearValues();
  invalidate();
}","/** 
 * Removes all DataSets (and thereby Entries) from the chart. Does not remove the x-values. Also refreshes the chart by calling invalidate().
 */
public void clearValues(){
  mData.clearValues();
  invalidate();
}",0.8704663212435233
26635,"@Override protected void calculateOffsets(){
  float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      offsetBottom+=mLegend.mTextHeightMax * 3f;
    }
  }
  if (mAxisLeft.isEnabled()) {
    offsetTop+=mAxisLeft.getRequiredHeightSpace(mAxisRendererLeft.getAxisPaint());
  }
  if (mAxisRight.isEnabled()) {
    offsetBottom+=mAxisRight.getRequiredHeightSpace(mAxisRendererRight.getAxisPaint());
  }
  float xlabelwidth=mXAxis.mLabelWidth;
  if (mXAxis.isEnabled()) {
    if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
      offsetLeft+=xlabelwidth;
    }
 else     if (mXAxis.getPosition() == XAxisPosition.TOP) {
      offsetRight+=xlabelwidth;
    }
 else     if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
      offsetLeft+=xlabelwidth;
      offsetRight+=xlabelwidth;
    }
  }
  float min=Utils.convertDpToPixel(10f);
  mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override protected void calculateOffsets(){
  float offsetLeft=0f, offsetRight=0f, offsetTop=0f, offsetBottom=0f;
  if (mLegend != null && mLegend.isEnabled()) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      offsetRight+=mLegend.mTextWidthMax + mLegend.getXOffset() * 2f;
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      offsetBottom+=mLegend.mTextHeightMax * 3f;
    }
  }
  if (mAxisLeft.needsOffset()) {
    offsetTop+=mAxisLeft.getRequiredHeightSpace(mAxisRendererLeft.getAxisPaint());
  }
  if (mAxisRight.needsOffset()) {
    offsetBottom+=mAxisRight.getRequiredHeightSpace(mAxisRendererRight.getAxisPaint());
  }
  float xlabelwidth=mXAxis.mLabelWidth;
  if (mXAxis.isEnabled()) {
    if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {
      offsetLeft+=xlabelwidth;
    }
 else     if (mXAxis.getPosition() == XAxisPosition.TOP) {
      offsetRight+=xlabelwidth;
    }
 else     if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
      offsetLeft+=xlabelwidth;
      offsetRight+=xlabelwidth;
    }
  }
  float min=Utils.convertDpToPixel(10f);
  mViewPortHandler.restrainViewPort(Math.max(min,offsetLeft),Math.max(min,offsetTop),Math.max(min,offsetRight),Math.max(min,offsetBottom));
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.9886169607285143
26636,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX + 1;
  int minx=mMinX - 1;
  if (maxx > mXAxis.getValues().size())   maxx=mXAxis.getValues().size();
  if (minx < 0)   minx=0;
  for (int i=minx; i < maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX;
  int minx=mMinX;
  if (maxx > mXAxis.getValues().size())   maxx=mXAxis.getValues().size();
  if (minx < 0)   minx=0;
  for (int i=minx; i <= maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}",0.995835261453031
26637,"@Override public void renderGridLines(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  BarData bd=mChart.getData();
  int step=bd.getDataSetCount();
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() - 0.5f;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}","@Override public void renderGridLines(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  BarData bd=mChart.getData();
  int step=bd.getDataSetCount();
  float div=(float)step + (step > 1 ? bd.getGroupSpace() : 0f);
  float min=(float)mMinX / div;
  float max=(float)mMaxX / div;
  for (int i=(int)min; i <= max; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() - 0.5f;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}",0.8782722513089005
26638,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=10; i < count - 10; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.9979946524064172
26639,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setColor(Color.BLACK);
  set1.setLineWidth(0.5f);
  set1.setDrawValues(false);
  set1.setDrawCircles(false);
  set1.setDrawCubic(false);
  set1.setDrawFilled(false);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
  Legend l=mChart.getLegend();
  l.setEnabled(false);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setColor(Color.BLACK);
  set1.setLineWidth(0.5f);
  set1.setDrawValues(false);
  set1.setDrawCircles(false);
  set1.setDrawCubic(false);
  set1.setDrawFilled(true);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
  Legend l=mChart.getLegend();
  l.setEnabled(false);
}",0.9951757408683668
26640,"/** 
 * Set this to true to enable scaling (zooming in and out by gesture) for the chart (this does not effect dragging).
 * @param enabled
 */
public void setScaleEnabled(boolean enabled){
  this.mScaleEnabled=enabled;
}","/** 
 * Set this to true to enable scaling (zooming in and out by gesture) for the chart (this does not effect dragging) on both X- and Y-Axis.
 * @param enabled
 */
public void setScaleEnabled(boolean enabled){
  this.mScaleXEnabled=enabled;
  this.mScaleYEnabled=enabled;
}",0.8911290322580645
26641,"/** 
 * Setting this to true will set the layer-type HARDWARE for the view, false will set layer-type SOFTWARE.
 * @param enabled
 */
public void setHardwareAccelerationEnabled(boolean enabled){
  if (enabled)   setLayerType(View.LAYER_TYPE_HARDWARE,null);
 else   setLayerType(View.LAYER_TYPE_SOFTWARE,null);
}","/** 
 * Setting this to true will set the layer-type HARDWARE for the view, false will set layer-type SOFTWARE.
 * @param enabled
 */
public void setHardwareAccelerationEnabled(boolean enabled){
  if (android.os.Build.VERSION.SDK_INT >= 11) {
    if (enabled)     setLayerType(View.LAYER_TYPE_HARDWARE,null);
 else     setLayerType(View.LAYER_TYPE_SOFTWARE,null);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"");
  }
}",0.8301369863013699
26642,"/** 
 * If set to true, the linechart lines are drawn in cubic-style instead of linear. Default: false
 * @param enabled
 */
public void setDrawCubic(boolean enabled){
  mDrawCubic=enabled;
}","/** 
 * If set to true, the linechart lines are drawn in cubic-style instead of linear. This affects performance! Default: false
 * @param enabled
 */
public void setDrawCubic(boolean enabled){
  mDrawCubic=enabled;
}",0.9362745098039216
26643,"/** 
 * Set to true if the DataSet should be drawn filled (surface), and not just as a line, disabling this will give up to 20% performance boost on large datasets, default: false
 * @param filled
 */
public void setDrawFilled(boolean filled){
  mDrawFilled=filled;
}","/** 
 * Set to true if the DataSet should be drawn filled (surface), and not just as a line, disabling this will give great performance boost! default: false
 * @param filled
 */
public void setDrawFilled(boolean filled){
  mDrawFilled=filled;
}",0.9296875
26644,"/** 
 * Performs the all operations necessary for pinch and axis zoom.
 * @param event
 */
private void performZoom(MotionEvent event){
  if (event.getPointerCount() >= 2) {
    float totalDist=spacing(event);
    if (totalDist > 10f) {
      PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
      if (mTouchMode == PINCH_ZOOM) {
        float scale=totalDist / mSavedDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(scale,scale,t.x,t.y);
      }
 else       if (mTouchMode == X_ZOOM) {
        float xDist=getXDist(event);
        float scaleX=xDist / mSavedXDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(scaleX,1f,t.x,t.y);
      }
 else       if (mTouchMode == Y_ZOOM) {
        float yDist=getYDist(event);
        float scaleY=yDist / mSavedYDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(1f,scaleY,t.x,t.y);
      }
    }
  }
}","/** 
 * Performs the all operations necessary for pinch and axis zoom.
 * @param event
 */
private void performZoom(MotionEvent event){
  if (event.getPointerCount() >= 2) {
    float totalDist=spacing(event);
    if (totalDist > 10f) {
      PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
      if (mTouchMode == PINCH_ZOOM) {
        float scale=totalDist / mSavedDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale((mChart.isScaleXEnabled()) ? scale : 1f,(mChart.isScaleYEnabled()) ? scale : 1f,t.x,t.y);
      }
 else       if (mTouchMode == X_ZOOM && mChart.isScaleXEnabled()) {
        float xDist=getXDist(event);
        float scaleX=xDist / mSavedXDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(scaleX,1f,t.x,t.y);
      }
 else       if (mTouchMode == Y_ZOOM && mChart.isScaleYEnabled()) {
        float yDist=getYDist(event);
        float scaleY=yDist / mSavedYDist;
        mMatrix.set(mSavedMatrix);
        mMatrix.postScale(1f,scaleY,t.x,t.y);
      }
    }
  }
}",0.9253886010362694
26645,"@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && !mChart.isScaleEnabled())   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    saveTouchStart(event);
  break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
  mChart.disableScroll();
  saveTouchStart(event);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
  }
  midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
if (mChart.isDragEnabled()) performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 5f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut()) mTouchMode=DRAG;
}
 else {
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
mTouchMode=NONE;
mChart.enableScroll();
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POST_ZOOM;
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart,true);
return true;
}","@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && (!mChart.isScaleXEnabled() && !mChart.isScaleYEnabled()))   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    saveTouchStart(event);
  break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
  mChart.disableScroll();
  saveTouchStart(event);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
  }
  midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
if (mChart.isDragEnabled()) performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleXEnabled() || mChart.isScaleYEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 5f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut()) mTouchMode=DRAG;
}
 else {
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
mTouchMode=NONE;
mChart.enableScroll();
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POST_ZOOM;
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart,true);
return true;
}",0.9762565525747764
26646,"protected void drawLinear(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size() - 3; j+=2) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 2));
      c.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    int from=mMinX * 4;
    int range=(mMaxX * 4 - mMinX) + 4;
    int to=range + from;
    mRenderPaint.setColor(dataSet.getColor());
    c.drawLines(buffer.buffer,from,to >= buffer.size() ? buffer.size() - from : range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,trans);
  }
}","protected void drawLinear(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=dataSet.getEntryPosition(entryTo);
    int from=minx * 4;
    int range=(maxx * 4 - from) + 4;
    int to=range + from;
    mRenderPaint.setColor(dataSet.getColor());
    c.drawLines(buffer.buffer,from,to >= buffer.size() ? buffer.size() - from : range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,trans);
  }
}",0.9195751138088012
26647,"protected void drawLinearFill(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries,Transformer trans){
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  Path filled=generateFilledPath(entries,mChart.getFillFormatter().getFillLinePosition(dataSet,mChart.getLineData(),mChart.getYChartMax(),mChart.getYChartMin()),mMinX,mMaxX + 1);
  trans.pathValueToPixel(filled);
  c.drawPath(filled,mRenderPaint);
  mRenderPaint.setAlpha(255);
}","protected void drawLinearFill(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries,Transformer trans){
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX - 2);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX + 2);
  int minx=dataSet.getEntryPosition(entryFrom);
  int maxx=dataSet.getEntryPosition(entryTo);
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  Path filled=generateFilledPath(entries,mChart.getFillFormatter().getFillLinePosition(dataSet,mChart.getLineData(),mChart.getYChartMax(),mChart.getYChartMin()),minx,maxx);
  trans.pathValueToPixel(filled);
  c.drawPath(filled,mRenderPaint);
  mRenderPaint.setAlpha(255);
}",0.8186195826645265
26648,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.LINE,DrawOrder.CANDLE});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawOrder(new DrawOrder[]{DrawOrder.BAR,DrawOrder.LINE});
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setDrawGridLines(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTH_SIDED);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  mChart.setData(data);
  mChart.invalidate();
}",0.9905817174515236
26649,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  drawCircles(c);
}",0.982213438735178
26650,"@Override public void drawExtras(Canvas c){
  drawCircles(c);
}","@Override public void drawExtras(Canvas c){
}",0.8333333333333334
26651,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    ArrayList<Entry> entries=dataSet.getYVals();
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0; j < buffer.size(); j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      mRenderPaint.setColor(dataSet.getCircleColor(j / 2));
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    ArrayList<Entry> entries=dataSet.getYVals();
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0; j < buffer.size(); j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      int circleColor=dataSet.getCircleColor(j / 2);
      mRenderPaint.setColor(circleColor);
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled() && circleColor != mCirclePaintInner.getColor())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.946969696969697
26652,"public YAxisRendererHorizontalBarChart(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,yAxis,trans);
}","public YAxisRendererHorizontalBarChart(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,yAxis,trans);
  mLimitLinePaint.setTextAlign(Align.LEFT);
}",0.8658536585365854
26653,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  mChart.setOnChartGestureListener(this);
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}",0.9782833505687694
26654,"@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  performHighlight(e);
  return super.onSingleTapUp(e);
}","@Override public boolean onSingleTapUp(MotionEvent e){
  performHighlight(e);
  return super.onSingleTapUp(e);
}",0.6588235294117647
26655,"@Override public boolean onSingleTapConfirmed(MotionEvent e){
  return super.onSingleTapConfirmed(e);
}","@Override public boolean onSingleTapConfirmed(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  return super.onSingleTapConfirmed(e);
}",0.5527950310559007
26656,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=5; i < count - 5; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  set1.setFillColor(ColorTemplate.getHoloBlue());
  LineData data=new LineData(xVals,set1);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  set1.setFillColor(ColorTemplate.getHoloBlue());
  LineData data=new LineData(xVals,set1);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}",0.9965792474344356
26657,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(9f);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(Color.WHITE);
  set1.setLineWidth(2f);
  set1.setCircleSize(3f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setDrawCircleHole(false);
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.WHITE);
  set2.setLineWidth(2f);
  set2.setCircleSize(3f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setDrawCircleHole(false);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(9f);
  mChart.setData(data);
}",0.7393822393822393
26658,"public LineBuffer(int size){
  super(size);
}","public LineBuffer(int size){
  super((size < 4) ? 4 : size);
}",0.8411214953271028
26659,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}",0.9514767932489452
26660,"protected void drawLinear(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=dataSet.getEntryPosition(entryTo);
    int from=minx * 4;
    int range=(maxx * 4 - from) + 4;
    int to=range + from;
    mRenderPaint.setColor(dataSet.getColor());
    c.drawLines(buffer.buffer,from,to >= buffer.size() ? buffer.size() - from : range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,trans);
  }
}","/** 
 * Draws a normal line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawLinear(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  int dataSetIndex=mChart.getLineData().getIndexOfDataSet(dataSet);
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  Canvas canvas=null;
  if (dataSet.isDashedLineEnabled()) {
    canvas=mBitmapCanvas;
  }
 else {
    canvas=c;
  }
  LineBuffer buffer=mLineBuffers[dataSetIndex];
  buffer.setPhases(phaseX,phaseY);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])) || (!mViewPortHandler.isInBoundsTop(buffer.buffer[j + 1]) && !mViewPortHandler.isInBoundsBottom(buffer.buffer[j + 3])))       continue;
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      canvas.drawLine(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
    Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
    int minx=dataSet.getEntryPosition(entryFrom);
    int maxx=dataSet.getEntryPosition(entryTo);
    int from=minx * 4;
    int range=(maxx * 4 - from) + 4;
    int to=range + from;
    mRenderPaint.setColor(dataSet.getColor());
    canvas.drawLines(buffer.buffer,from,to >= buffer.size() ? buffer.size() - from : range,mRenderPaint);
  }
  mRenderPaint.setPathEffect(null);
  if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
    drawLinearFill(c,dataSet,entries,trans);
  }
}",0.9437837837837838
26661,"@Override public void initBuffers(){
  LineData lineData=mChart.getLineData();
  mLineBuffers=new LineBuffer[lineData.getDataSetCount()];
  for (int i=0; i < mLineBuffers.length; i++) {
    LineDataSet set=lineData.getDataSetByIndex(i);
    int size=lineData.getXValCount() * 4 - 4;
    if (size < 4)     size=4;
    mLineBuffers[i]=new LineBuffer(size);
  }
  mCircleBuffers=new CircleBuffer[lineData.getDataSetCount()];
  for (int i=0; i < mCircleBuffers.length; i++) {
    LineDataSet set=lineData.getDataSetByIndex(i);
    mCircleBuffers[i]=new CircleBuffer(set.getEntryCount() * 2);
  }
}","@Override public void initBuffers(){
  LineData lineData=mChart.getLineData();
  mLineBuffers=new LineBuffer[lineData.getDataSetCount()];
  mCircleBuffers=new CircleBuffer[lineData.getDataSetCount()];
  for (int i=0; i < mLineBuffers.length; i++) {
    LineDataSet set=lineData.getDataSetByIndex(i);
    mLineBuffers[i]=new LineBuffer(set.getEntryCount() * 4 - 4);
    mCircleBuffers[i]=new CircleBuffer(set.getEntryCount() * 2);
  }
}",0.5447470817120622
26662,"protected void drawCubic(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  int minx=mMinX;
  int maxx=mMaxX + 2;
  if (maxx > entries.size())   maxx=entries.size();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  long start=System.currentTimeMillis();
  cubicPath.reset();
  float size=entries.size() * phaseX;
  if (entries.size() > 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(0);
    Entry next=entries.get(1);
    Entry prev=entries.get(0);
    Entry prevPrev=entries.get(0);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  start=System.currentTimeMillis();
  trans.pathValueToPixel(cubicPath);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  start=System.currentTimeMillis();
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","/** 
 * Draws a cubic line.
 * @param c
 * @param dataSet
 * @param entries
 */
protected void drawCubic(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  int minx=mMinX;
  int maxx=mMaxX + 2;
  if (maxx > entries.size())   maxx=entries.size();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  cubicPath.reset();
  float size=entries.size() * phaseX;
  if (entries.size() > 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(0);
    Entry next=entries.get(1);
    Entry prev=entries.get(0);
    Entry prevPrev=entries.get(0);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  trans.pathValueToPixel(cubicPath);
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9189366590088612
26663,"protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    ArrayList<Entry> entries=dataSet.getYVals();
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0; j < buffer.size(); j+=2) {
      mRenderPaint.setColor(dataSet.getCircleColor(j / 2));
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}","protected void drawCircles(Canvas c){
  mRenderPaint.setStyle(Paint.Style.FILL);
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<LineDataSet> dataSets=mChart.getLineData().getDataSets();
  for (int i=0; i < dataSets.size(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (!dataSet.isVisible() || !dataSet.isDrawCirclesEnabled())     continue;
    mCirclePaintInner.setColor(dataSet.getCircleHoleColor());
    Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
    ArrayList<Entry> entries=dataSet.getYVals();
    CircleBuffer buffer=mCircleBuffers[i];
    buffer.setPhases(phaseX,phaseY);
    buffer.feed(entries);
    trans.pointValuesToPixel(buffer.buffer);
    float halfsize=dataSet.getCircleSize() / 2f;
    for (int j=0; j < buffer.size(); j+=2) {
      float x=buffer.buffer[j];
      float y=buffer.buffer[j + 1];
      if (!mViewPortHandler.isInBoundsRight(x))       break;
      if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))       continue;
      mRenderPaint.setColor(dataSet.getCircleColor(j / 2));
      c.drawCircle(x,y,dataSet.getCircleSize(),mRenderPaint);
      if (dataSet.isDrawCircleHoleEnabled())       c.drawCircle(x,y,halfsize,mCirclePaintInner);
    }
  }
}",0.9270833333333334
26664,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX;
  int minx=mMinX;
  if (maxx > mXAxis.getValues().size())   maxx=mXAxis.getValues().size();
  if (minx < 0)   minx=0;
  for (int i=minx; i <= maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  int maxx=mMaxX;
  int minx=mMinX;
  if (maxx >= mXAxis.getValues().size())   maxx=mXAxis.getValues().size() - 1;
  if (minx < 0)   minx=0;
  for (int i=minx; i <= maxx; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}",0.9976841130152848
26665,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground(canvas);
  if (mAxisLeft.isEnabled())   mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  if (mAxisRight.isEnabled())   mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.renderAxisLine(canvas);
  mAxisRendererLeft.renderAxisLine(canvas);
  mAxisRendererRight.renderAxisLine(canvas);
  int clipRestoreCount=canvas.save();
  canvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(canvas);
  mAxisRendererLeft.renderGridLines(canvas);
  mAxisRendererRight.renderGridLines(canvas);
  mRenderer.drawData(canvas);
  mAxisRendererLeft.renderLimitLines(canvas);
  mAxisRendererRight.renderLimitLines(canvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  canvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(canvas);
  mXAxisRenderer.renderAxisLabels(canvas);
  mAxisRendererLeft.renderAxisLabels(canvas);
  mAxisRendererRight.renderAxisLabels(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawMarkers(canvas);
  drawDescription(canvas);
  if (mLogEnabled) {
    long drawtime=(System.currentTimeMillis() - starttime);
    totalTime+=drawtime;
    drawCycles+=1;
    long average=totalTime / drawCycles;
    Log.i(LOG_TAG,""String_Node_Str"" + drawtime + ""String_Node_Str""+ average+ ""String_Node_Str""+ drawCycles);
  }
}",0.9230313795145056
26666,"public boolean isUsePercentValuesEnabled(){
  return mUsePercentValues;
}","/** 
 * Returns true if using percentage values is enabled for the chart.
 * @return
 */
public boolean isUsePercentValuesEnabled(){
  return mUsePercentValues;
}",0.6212765957446809
26667,"/** 
 * Removes the DataSet at the given index in the DataSet array from the data object. Also recalculates all minimum and maximum values. Returns true if a DataSet was removed, false if no DataSet could be removed.
 * @param index
 */
public boolean removeDataSet(int index){
  if (mDataSets == null || index >= mDataSets.size() || index < 0)   return false;
  T set=mDataSets.get(index);
  return removeDataSet(set);
}","/** 
 * Removes the DataSet at the given index in the DataSet array from the data object. Also recalculates all minimum and maximum values. Returns true if a DataSet was removed, false if no DataSet could be removed.
 * @param index
 */
public boolean removeDataSet(int index){
  if (index >= mDataSets.size() || index < 0)   return false;
  T set=mDataSets.get(index);
  return removeDataSet(set);
}",0.9159561510353228
26668,"/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param entry
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    mYValCount+=1;
    mYValueSum+=val;
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
    if (mDataSets == null)     mDataSets=new ArrayList<T>();
    T set=mDataSets.get(dataSetIndex);
    if (set != null) {
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
      handleEmptyAxis(getFirstLeft(),getFirstRight());
      set.addEntry(e);
    }
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param entry
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    mYValCount+=1;
    mYValueSum+=val;
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
    T set=mDataSets.get(dataSetIndex);
    if (set != null) {
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
      handleEmptyAxis(getFirstLeft(),getFirstRight());
      set.addEntry(e);
    }
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}",0.9432692307692307
26669,"/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  mDataSets.add(d);
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mYMax < d.getYMax())   mYMax=d.getYMax();
  if (mYMin > d.getYMin())   mYMin=d.getYMin();
  if (d.getAxisDependency() == AxisDependency.LEFT) {
    if (mLeftAxisMax < d.getYMax())     mLeftAxisMax=d.getYMax();
    if (mLeftAxisMin > d.getYMin())     mLeftAxisMin=d.getYMin();
  }
 else {
    if (mRightAxisMax < d.getYMax())     mRightAxisMax=d.getYMax();
    if (mRightAxisMin > d.getYMin())     mRightAxisMin=d.getYMin();
  }
  handleEmptyAxis(getFirstLeft(),getFirstRight());
}","/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (d == null)   return;
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mDataSets.size() <= 0) {
    mYMax=d.getYMax();
    mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      mLeftAxisMax=d.getYMax();
      mLeftAxisMin=d.getYMin();
    }
 else {
      mRightAxisMax=d.getYMax();
      mRightAxisMin=d.getYMin();
    }
  }
 else {
    if (mYMax < d.getYMax())     mYMax=d.getYMax();
    if (mYMin > d.getYMin())     mYMin=d.getYMin();
    if (d.getAxisDependency() == AxisDependency.LEFT) {
      if (mLeftAxisMax < d.getYMax())       mLeftAxisMax=d.getYMax();
      if (mLeftAxisMin > d.getYMin())       mLeftAxisMin=d.getYMin();
    }
 else {
      if (mRightAxisMax < d.getYMax())       mRightAxisMax=d.getYMax();
      if (mRightAxisMin > d.getYMin())       mRightAxisMin=d.getYMin();
    }
  }
  mDataSets.add(d);
  handleEmptyAxis(getFirstLeft(),getFirstRight());
}",0.6278392545136867
26670,"@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h == null || h.equalTo(mLastHighlighted)) {
    mChart.highlightTouch(null);
    mLastHighlighted=null;
  }
 else {
    mLastHighlighted=h;
    mChart.highlightTouch(h);
  }
  return super.onSingleTapUp(e);
}","@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  performHighlight(e);
  return super.onSingleTapUp(e);
}",0.5449189985272459
26671,"@Override public boolean onDoubleTap(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(1.4f,1.4f,trans.x,trans.y);
    Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}","@Override public boolean onDoubleTap(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartDoubleTapped(e);
    return super.onDoubleTap(e);
  }
  if (mChart.isDoubleTapToZoomEnabled()) {
    PointF trans=getTrans(e.getX(),e.getY());
    mChart.zoom(1.4f,1.4f,trans.x,trans.y);
    if (mChart.isLogEnabled())     Log.i(""String_Node_Str"",""String_Node_Str"" + trans.x + ""String_Node_Str""+ trans.y);
  }
  return super.onDoubleTap(e);
}",0.9672650475184794
26672,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  drawCircles(c);
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
}",0.982213438735178
26673,"@Override public void drawExtras(Canvas c){
}","@Override public void drawExtras(Canvas c){
  drawCircles(c);
}",0.8333333333333334
26674,"@Override public void renderGridLines(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (position[0] >= mViewPortHandler.offsetLeft() && position[0] <= mViewPortHandler.getChartWidth()) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}","@Override public void renderGridLines(Canvas c){
  if (!mXAxis.isDrawGridLinesEnabled() || !mXAxis.isEnabled())   return;
  float[] position=new float[]{0f,0f};
  mGridPaint.setColor(mXAxis.getGridColor());
  mGridPaint.setStrokeWidth(mXAxis.getGridLineWidth());
  for (int i=mMinX; i <= mMaxX; i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (position[0] >= mViewPortHandler.offsetLeft() && position[0] <= mViewPortHandler.getChartWidth()) {
      c.drawLine(position[0],mViewPortHandler.offsetTop(),position[0],mViewPortHandler.contentBottom(),mGridPaint);
    }
  }
}",0.9817893903404592
26675,"@Override public void renderAxisLine(Canvas c){
  if (!mXAxis.isDrawAxisLineEnabled() || !mXAxis.isEnabled())   return;
  mAxisLinePaint.setColor(mXAxis.getAxisLineColor());
  mAxisLinePaint.setStrokeWidth(mXAxis.getAxisLineWidth());
  if (mXAxis.getPosition() == XAxisPosition.TOP || mXAxis.getPosition() == XAxisPosition.TOP_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop(),mViewPortHandler.contentRight(),mViewPortHandler.contentTop(),mAxisLinePaint);
  }
  if (mXAxis.getPosition() == XAxisPosition.BOTTOM || mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom(),mViewPortHandler.contentRight(),mViewPortHandler.contentBottom(),mAxisLinePaint);
  }
}","@Override public void renderAxisLine(Canvas c){
  calcXBounds(mTrans);
  if (!mXAxis.isDrawAxisLineEnabled() || !mXAxis.isEnabled())   return;
  mAxisLinePaint.setColor(mXAxis.getAxisLineColor());
  mAxisLinePaint.setStrokeWidth(mXAxis.getAxisLineWidth());
  if (mXAxis.getPosition() == XAxisPosition.TOP || mXAxis.getPosition() == XAxisPosition.TOP_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop(),mViewPortHandler.contentRight(),mViewPortHandler.contentTop(),mAxisLinePaint);
  }
  if (mXAxis.getPosition() == XAxisPosition.BOTTOM || mXAxis.getPosition() == XAxisPosition.BOTTOM_INSIDE || mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {
    c.drawLine(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom(),mViewPortHandler.contentRight(),mViewPortHandler.contentBottom(),mAxisLinePaint);
  }
}",0.9870276367738297
26676,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  set1.setFillColor(ColorTemplate.getHoloBlue());
  LineData data=new LineData(xVals,set1);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=5; i < count - 5; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  set1.setFillColor(ColorTemplate.getHoloBlue());
  LineData data=new LineData(xVals,set1);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}",0.9965792474344356
26677,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=10; i < count - 10; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(3f);
  set1.setDrawCircleHole(false);
  set1.setValueTextSize(9f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.9979946524064172
26678,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mRenderer.drawData(canvas);
  mRenderer.drawExtras(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawDescription(canvas);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mRenderer.drawData(canvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(canvas,mIndicesToHightlight);
  mRenderer.drawExtras(canvas);
  mRenderer.drawValues(canvas);
  mLegendRenderer.renderLegend(canvas,mLegend);
  drawDescription(canvas);
}",0.920424403183024
26679,"protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  for (int j=0; j < buffer.size(); j+=4) {
    if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))     continue;
    if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))     break;
    if (mChart.isDrawBarShadowEnabled()) {
      c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
    }
    mRenderPaint.setColor(dataSet.getColor(j / 4));
    c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
  }
}","protected void drawDataSet(Canvas c,BarDataSet dataSet,int index){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  calcXBounds(trans);
  mShadowPaint.setColor(dataSet.getBarShadowColor());
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  ArrayList<BarEntry> entries=dataSet.getYVals();
  BarBuffer buffer=mBarBuffers[index];
  buffer.setPhases(phaseX,phaseY);
  buffer.setBarSpace(dataSet.getBarSpace());
  buffer.setDataSet(index);
  buffer.feed(entries);
  trans.pointValuesToPixel(buffer.buffer);
  if (dataSet.getColors().size() > 1) {
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      mRenderPaint.setColor(dataSet.getColor(j / 4));
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
 else {
    mRenderPaint.setColor(dataSet.getColor());
    for (int j=0; j < buffer.size(); j+=4) {
      if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))       continue;
      if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))       break;
      if (mChart.isDrawBarShadowEnabled()) {
        c.drawRect(buffer.buffer[j],mViewPortHandler.contentTop(),buffer.buffer[j + 2],mViewPortHandler.contentBottom(),mShadowPaint);
      }
      c.drawRect(buffer.buffer[j],buffer.buffer[j + 1],buffer.buffer[j + 2],buffer.buffer[j + 3],mRenderPaint);
    }
  }
}",0.7687411598302687
26680,"@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mPathCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  if (mPathBitmap == null) {
    mPathBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mPathBitmap);
  }
  mPathBitmap.eraseColor(Color.TRANSPARENT);
  LineData lineData=mChart.getLineData();
  for (  LineDataSet set : lineData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}",0.9888888888888888
26681,"protected void drawCubicFill(Canvas c,LineDataSet dataSet,Path spline,Transformer trans,int from,int to){
  float fillMin=mChart.getFillFormatter().getFillLinePosition(dataSet,mChart.getLineData(),mChart.getYChartMax(),mChart.getYChartMin());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX);
  spline.lineTo(entryTo.getXIndex(),fillMin);
  spline.lineTo(entryFrom.getXIndex(),fillMin);
  spline.close();
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  trans.pathValueToPixel(spline);
  mPathCanvas.drawPath(spline,mRenderPaint);
  mRenderPaint.setAlpha(255);
}","protected void drawCubicFill(Canvas c,LineDataSet dataSet,Path spline,Transformer trans,int from,int to){
  float fillMin=mChart.getFillFormatter().getFillLinePosition(dataSet,mChart.getLineData(),mChart.getYChartMax(),mChart.getYChartMin());
  Entry entryFrom=dataSet.getEntryForXIndex(mMinX);
  Entry entryTo=dataSet.getEntryForXIndex(mMaxX + 1);
  spline.lineTo(entryTo.getXIndex(),fillMin);
  spline.lineTo(entryFrom.getXIndex(),fillMin);
  spline.close();
  mRenderPaint.setStyle(Paint.Style.FILL);
  mRenderPaint.setColor(dataSet.getFillColor());
  mRenderPaint.setAlpha(dataSet.getFillAlpha());
  trans.pathValueToPixel(spline);
  mBitmapCanvas.drawPath(spline,mRenderPaint);
  mRenderPaint.setAlpha(255);
}",0.9901547116736992
26682,"protected void drawCubic(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  int minx=mMinX;
  int maxx=mMaxX + 2;
  if (maxx > entries.size())   maxx=entries.size();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  long start=System.currentTimeMillis();
  cubicPath.reset();
  float size=entries.size() * phaseX;
  if (entries.size() > 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(0);
    Entry next=entries.get(1);
    Entry prev=entries.get(0);
    Entry prevPrev=entries.get(0);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mPathCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  start=System.currentTimeMillis();
  trans.pathValueToPixel(cubicPath);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  start=System.currentTimeMillis();
  mPathCanvas.drawPath(cubicPath,mRenderPaint);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}","protected void drawCubic(Canvas c,LineDataSet dataSet,ArrayList<Entry> entries){
  Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
  int minx=mMinX;
  int maxx=mMaxX + 2;
  if (maxx > entries.size())   maxx=entries.size();
  float phaseX=mAnimator.getPhaseX();
  float phaseY=mAnimator.getPhaseY();
  float intensity=dataSet.getCubicIntensity();
  long start=System.currentTimeMillis();
  cubicPath.reset();
  float size=entries.size() * phaseX;
  if (entries.size() > 2) {
    float prevDx=0f;
    float prevDy=0f;
    float curDx=0f;
    float curDy=0f;
    Entry cur=entries.get(0);
    Entry next=entries.get(1);
    Entry prev=entries.get(0);
    Entry prevPrev=entries.get(0);
    cubicPath.moveTo(cur.getXIndex(),cur.getVal() * phaseY);
    prevDx=(next.getXIndex() - cur.getXIndex()) * intensity;
    prevDy=(next.getVal() - cur.getVal()) * intensity;
    cur=entries.get(1);
    next=entries.get(2);
    curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
    curDy=(next.getVal() - prev.getVal()) * intensity;
    cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    for (int j=2; j < size - 1; j++) {
      prevPrev=entries.get(j - 2);
      prev=entries.get(j - 1);
      cur=entries.get(j);
      next=entries.get(j + 1);
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
    if (size > entries.size() - 1) {
      cur=entries.get(entries.size() - 1);
      prev=entries.get(entries.size() - 2);
      prevPrev=entries.get(entries.size() - 3);
      next=cur;
      prevDx=(cur.getXIndex() - prevPrev.getXIndex()) * intensity;
      prevDy=(cur.getVal() - prevPrev.getVal()) * intensity;
      curDx=(next.getXIndex() - prev.getXIndex()) * intensity;
      curDy=(next.getVal() - prev.getVal()) * intensity;
      cubicPath.cubicTo(prev.getXIndex() + prevDx,(prev.getVal() + prevDy) * phaseY,cur.getXIndex() - curDx,(cur.getVal() - curDy) * phaseY,cur.getXIndex(),cur.getVal() * phaseY);
    }
  }
  if (dataSet.isDrawFilledEnabled()) {
    cubicFillPath.reset();
    cubicFillPath.addPath(cubicPath);
    drawCubicFill(mBitmapCanvas,dataSet,cubicFillPath,trans,minx,maxx);
  }
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  mRenderPaint.setColor(dataSet.getColor());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  start=System.currentTimeMillis();
  trans.pathValueToPixel(cubicPath);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  start=System.currentTimeMillis();
  mBitmapCanvas.drawPath(cubicPath,mRenderPaint);
  Log.i(""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - start));
  c.drawBitmap(mPathBitmap,0,0,mRenderPaint);
  mRenderPaint.setPathEffect(null);
}",0.9968866749688668
26683,"@Override public void drawData(Canvas c){
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
}","@Override public void drawData(Canvas c){
  if (mDrawBitmap == null) {
    mDrawBitmap=Bitmap.createBitmap((int)mViewPortHandler.getChartWidth(),(int)mViewPortHandler.getChartHeight(),Bitmap.Config.ARGB_4444);
    mBitmapCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
  PieData pieData=mChart.getData();
  for (  PieDataSet set : pieData.getDataSets()) {
    if (set.isVisible())     drawDataSet(c,set);
  }
  c.drawBitmap(mDrawBitmap,0,0,mRenderPaint);
}",0.4166666666666667
26684,"protected void drawDataSet(Canvas c,PieDataSet dataSet){
  float angle=mChart.getRotationAngle();
  int cnt=0;
  ArrayList<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[cnt];
    float sliceSpace=dataSet.getSliceSpace();
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        c.drawArc(mChart.getCircleBox(),angle + sliceSpace / 2f,newangle * mAnimator.getPhaseY() - sliceSpace / 2f,true,mRenderPaint);
      }
    }
    angle+=newangle * mAnimator.getPhaseX();
    cnt++;
  }
}","protected void drawDataSet(Canvas c,PieDataSet dataSet){
  float angle=mChart.getRotationAngle();
  int cnt=0;
  ArrayList<Entry> entries=dataSet.getYVals();
  float[] drawAngles=mChart.getDrawAngles();
  for (int j=0; j < entries.size(); j++) {
    float newangle=drawAngles[cnt];
    float sliceSpace=dataSet.getSliceSpace();
    Entry e=entries.get(j);
    if ((Math.abs(e.getVal()) > 0.000001)) {
      if (!mChart.needsHighlight(e.getXIndex(),mChart.getData().getIndexOfDataSet(dataSet))) {
        mRenderPaint.setColor(dataSet.getColor(j));
        mBitmapCanvas.drawArc(mChart.getCircleBox(),angle + sliceSpace / 2f,newangle * mAnimator.getPhaseY() - sliceSpace / 2f,true,mRenderPaint);
      }
    }
    angle+=newangle * mAnimator.getPhaseX();
    cnt++;
  }
}",0.9908376963350786
26685,"/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    int color=mHolePaint.getColor();
    c.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
    if (transparentCircleRadius > holeRadius) {
      mHolePaint.setColor(color & 0x60FFFFFF);
      c.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mHolePaint);
      mHolePaint.setColor(color);
    }
  }
}","/** 
 * draws the hole in the center of the chart and the transparent circle / hole
 */
protected void drawHole(Canvas c){
  if (mChart.isDrawHoleEnabled()) {
    float transparentCircleRadius=mChart.getTransparentCircleRadius();
    float holeRadius=mChart.getHoleRadius();
    float radius=mChart.getRadius();
    PointF center=mChart.getCenterCircleBox();
    int color=mHolePaint.getColor();
    mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * holeRadius,mHolePaint);
    if (transparentCircleRadius > holeRadius) {
      mHolePaint.setColor(color & 0x60FFFFFF);
      mBitmapCanvas.drawCircle(center.x,center.y,radius / 100 * transparentCircleRadius,mHolePaint);
      mHolePaint.setColor(color);
    }
  }
}",0.980309423347398
26686,"@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 2f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  ArrayList<PieDataSet> dataSets=data.getDataSets();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mAnimator.getPhaseX(); j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawXVals=mChart.isDrawSliceTextEnabled();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}","@Override public void drawValues(Canvas c){
  PointF center=mChart.getCenterCircleBox();
  float r=mChart.getRadius();
  float rotationAngle=mChart.getRotationAngle();
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  float off=r / 3f;
  if (mChart.isDrawHoleEnabled()) {
    off=(r - (r / 100f * mChart.getHoleRadius())) / 2f;
  }
  r-=off;
  PieData data=mChart.getData();
  ArrayList<PieDataSet> dataSets=data.getDataSets();
  int cnt=0;
  for (int i=0; i < dataSets.size(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mAnimator.getPhaseX(); j++) {
      float offset=drawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((rotationAngle + absoluteAngles[cnt] - offset) * mAnimator.getPhaseY())) + center.y);
      float value=mChart.isUsePercentValuesEnabled() ? entries.get(j).getVal() / mChart.getYValueSum() * 100f : entries.get(j).getVal();
      String val=dataSet.getValueFormatter().getFormattedValue(value);
      boolean drawXVals=mChart.isDrawSliceTextEnabled();
      boolean drawYVals=dataSet.isDrawValuesEnabled();
      if (drawXVals && drawYVals) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        c.drawText(val,x,y,mValuePaint);
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (drawXVals && !drawYVals) {
        if (j < data.getXValCount())         c.drawText(data.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!drawXVals && drawYVals) {
        c.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}",0.9994946942900454
26687,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float rotationAngle=mChart.getRotationAngle();
  float angle=0f;
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    if (xIndex == 0)     angle=rotationAngle;
 else     angle=rotationAngle + absoluteAngles[xIndex - 1];
    angle*=mAnimator.getPhaseY();
    float sliceDegrees=drawAngles[xIndex];
    PieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    float shift=set.getSelectionShift();
    RectF circleBox=mChart.getCircleBox();
    RectF highlighted=new RectF(circleBox.left - shift,circleBox.top - shift,circleBox.right + shift,circleBox.bottom + shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    c.drawArc(highlighted,angle + set.getSliceSpace() / 2f,sliceDegrees - set.getSliceSpace() / 2f,true,mRenderPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float rotationAngle=mChart.getRotationAngle();
  float angle=0f;
  float[] drawAngles=mChart.getDrawAngles();
  float[] absoluteAngles=mChart.getAbsoluteAngles();
  for (int i=0; i < indices.length; i++) {
    int xIndex=indices[i].getXIndex();
    if (xIndex >= drawAngles.length)     continue;
    if (xIndex == 0)     angle=rotationAngle;
 else     angle=rotationAngle + absoluteAngles[xIndex - 1];
    angle*=mAnimator.getPhaseY();
    float sliceDegrees=drawAngles[xIndex];
    PieDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    float shift=set.getSelectionShift();
    RectF circleBox=mChart.getCircleBox();
    RectF highlighted=new RectF(circleBox.left - shift,circleBox.top - shift,circleBox.right + shift,circleBox.bottom + shift);
    mRenderPaint.setColor(set.getColor(xIndex));
    mBitmapCanvas.drawArc(highlighted,angle + set.getSliceSpace() / 2f,sliceDegrees - set.getSliceSpace() / 2f,true,mRenderPaint);
  }
}",0.9934024505183788
26688,"/** 
 * Returns the correct Highlight object (including xIndex and dataSet-index) for the specified touch position.
 * @param xPosition
 * @return
 */
protected Highlight getHighlight(double xPosition,double yPosition){
  int setCount=mData.getDataSetCount();
  int valCount=mData.getXValCount();
  if (!mData.isGrouped()) {
    int dataSetIndex=0;
    int xIndex=(int)Math.round(xPosition);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
 else {
    int steps=(int)((float)xPosition / ((float)setCount + mData.getGroupSpace()));
    float groupSpaceSum=mData.getGroupSpace() * (float)steps;
    float baseNoSpace=(float)xPosition - groupSpaceSum;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xPosition + ""String_Node_Str""+ steps+ ""String_Node_Str""+ groupSpaceSum+ ""String_Node_Str""+ baseNoSpace);
    int dataSetIndex=(int)baseNoSpace % setCount;
    int xIndex=(int)baseNoSpace / setCount;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
}","/** 
 * Returns the correct Highlight object (including xIndex and dataSet-index) for the specified touch position.
 * @param xPosition
 * @return
 */
protected Highlight getHighlight(double xPosition,double yPosition){
  int setCount=mData.getDataSetCount();
  int valCount=mData.getXValCount();
  int dataSetIndex=0;
  int xIndex=0;
  if (!mData.isGrouped()) {
    xIndex=(int)Math.round(xPosition);
    if (xIndex < 0) {
      xIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
    }
  }
 else {
    int steps=(int)((float)xPosition / ((float)setCount + mData.getGroupSpace()));
    float groupSpaceSum=mData.getGroupSpace() * (float)steps;
    float baseNoSpace=(float)xPosition - groupSpaceSum;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xPosition + ""String_Node_Str""+ steps+ ""String_Node_Str""+ groupSpaceSum+ ""String_Node_Str""+ baseNoSpace);
    dataSetIndex=(int)baseNoSpace % setCount;
    xIndex=(int)baseNoSpace / setCount;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
  }
  if (!mData.getDataSetByIndex(dataSetIndex).isStacked())   return new Highlight(xIndex,dataSetIndex);
 else   return getStackedHighlight(xIndex,dataSetIndex,yPosition);
}",0.8741258741258742
26689,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}",0.9839326702371844
26690,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    ArrayList<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    posOffset=(drawValueAboveBar ? -Utils.convertDpToPixel(5) : Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f);
    negOffset=(drawValueAboveBar ? Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f : -Utils.convertDpToPixel(5));
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,val,valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset),formatter);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(c,e.getVal(),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset),formatter);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mAnimator.getPhaseY();
              cnt++;
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(c,vals[k / 2],valuePoints[j],transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset),formatter);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    ArrayList<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    posOffset=(drawValueAboveBar ? -Utils.convertDpToPixel(5) : Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f);
    negOffset=(drawValueAboveBar ? Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f : -Utils.convertDpToPixel(5));
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))           break;
          if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,val,valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset),formatter);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsRight(valuePoints[j]))             break;
            if (!mViewPortHandler.isInBoundsY(valuePoints[j + 1]) || !mViewPortHandler.isInBoundsLeft(valuePoints[j]))             continue;
            drawValue(c,e.getVal(),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset),formatter);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mAnimator.getPhaseY();
              cnt++;
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=valuePoints[j];
              float y=transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              if (!mViewPortHandler.isInBoundsRight(x))               break;
              if (!mViewPortHandler.isInBoundsY(y) || !mViewPortHandler.isInBoundsLeft(x))               continue;
              drawValue(c,vals[k / 2],x,y,formatter);
            }
          }
        }
      }
    }
  }
}",0.8891280947255114
26691,"@Override protected void drawValue(Canvas c,float val,float xPos,float yPos,ValueFormatter formatter){
  super.drawValue(c,val,xPos + xOffset,yPos + yOffset,formatter);
}","@Override protected void drawValue(Canvas c,float val,float xPos,float yPos,ValueFormatter formatter){
  super.drawValue(c,val,xPos,yPos + mYOffset,formatter);
}",0.9607250755287008
26692,"public HorizontalBarChartRenderer(BarDataProvider chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(chart,animator,viewPortHandler);
  mValuePaint.setTextAlign(Align.LEFT);
  yOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"");
  xOffset=Utils.convertDpToPixel(4f);
}","public HorizontalBarChartRenderer(BarDataProvider chart,ChartAnimator animator,ViewPortHandler viewPortHandler){
  super(chart,animator,viewPortHandler);
  mValuePaint.setTextAlign(Align.LEFT);
}",0.7942973523421588
26693,"@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    ArrayList<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    posOffset=(drawValueAboveBar ? -Utils.convertDpToPixel(5) : Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f);
    negOffset=(drawValueAboveBar ? Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f : -Utils.convertDpToPixel(5));
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,val,valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset),formatter);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(c,e.getVal(),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset),formatter);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k]=(vals[cnt] + add) * mAnimator.getPhaseY();
              cnt++;
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(c,vals[k / 2],transformed[k],valuePoints[j + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset),formatter);
            }
          }
        }
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (passesCheck()) {
    ArrayList<BarDataSet> dataSets=mChart.getBarData().getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    boolean drawValueAboveBar=mChart.isDrawValueAboveBarEnabled();
    negOffset=drawValueAboveBar ? -Utils.convertDpToPixel(5) : Utils.convertDpToPixel(5);
    posOffset=drawValueAboveBar ? Utils.convertDpToPixel(5) : -Utils.convertDpToPixel(5);
    if (drawValueAboveBar)     mValuePaint.setTextAlign(Align.LEFT);
 else     mValuePaint.setTextAlign(Align.RIGHT);
    for (int i=0; i < mChart.getBarData().getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      applyValueTextStyle(dataSet);
      mYOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") / 2f;
      ValueFormatter formatter=dataSet.getValueFormatter();
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=getTransformedValues(trans,entries,i);
      if (!mChart.isDrawValuesForWholeStackEnabled()) {
        for (int j=0; j < valuePoints.length * mAnimator.getPhaseX(); j+=2) {
          if (!mViewPortHandler.isInBoundsX(valuePoints[j]))           continue;
          if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))           break;
          if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(c,val,valuePoints[j] + (val >= 0 ? posOffset : negOffset),valuePoints[j + 1],formatter);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mAnimator.getPhaseX(); j+=2) {
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            if (!mViewPortHandler.isInBoundsX(valuePoints[j]))             continue;
            if (!mViewPortHandler.isInBoundsTop(valuePoints[j + 1]))             break;
            if (!mViewPortHandler.isInBoundsBottom(valuePoints[j + 1]))             continue;
            drawValue(c,e.getVal(),valuePoints[j] + (e.getVal() >= 0 ? posOffset : negOffset),valuePoints[j + 1],formatter);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k]=(vals[cnt] + add) * mAnimator.getPhaseY();
              cnt++;
            }
            trans.pointValuesToPixel(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              float x=transformed[k] + (vals[k / 2] >= 0 ? posOffset : negOffset);
              float y=valuePoints[j + 1];
              if (!mViewPortHandler.isInBoundsX(x))               continue;
              if (!mViewPortHandler.isInBoundsTop(y))               break;
              if (!mViewPortHandler.isInBoundsBottom(y))               continue;
              drawValue(c,vals[k / 2],x,y,formatter);
            }
          }
        }
      }
    }
  }
}",0.723404255319149
26694,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionTogglePinch:
{
  if (mChart.isPinchZoomEnabled())   mChart.setPinchZoom(false);
 else   mChart.setPinchZoom(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleHighlightArrow:
{
if (mChart.isDrawHighlightArrowEnabled()) mChart.setDrawHighlightArrow(false);
 else mChart.setDrawHighlightArrow(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleAdjustXLegend:
{
XAxis xLabels=mChart.getXAxis();
if (xLabels.isAdjustXLabelsEnabled()) xLabels.setAdjustXLabels(false);
 else xLabels.setAdjustXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,25);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToGallery(""String_Node_Str"" + System.currentTimeMillis(),50)) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionTogglePinch:
{
  if (mChart.isPinchZoomEnabled())   mChart.setPinchZoom(false);
 else   mChart.setPinchZoom(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleHighlightArrow:
{
if (mChart.isDrawHighlightArrowEnabled()) mChart.setDrawHighlightArrow(false);
 else mChart.setDrawHighlightArrow(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
mChart.getAxisLeft().setStartAtZero(!mChart.getAxisLeft().isStartAtZeroEnabled());
mChart.getAxisRight().setStartAtZero(!mChart.getAxisRight().isStartAtZeroEnabled());
mChart.notifyDataSetChanged();
mChart.invalidate();
break;
}
case R.id.animateX:
{
mChart.animateX(3000);
break;
}
case R.id.animateY:
{
mChart.animateY(3000);
break;
}
case R.id.animateXY:
{
mChart.animateXY(3000,3000);
break;
}
case R.id.actionToggleAdjustXLegend:
{
XAxis xLabels=mChart.getXAxis();
if (xLabels.isAdjustXLabelsEnabled()) xLabels.setAdjustXLabels(false);
 else xLabels.setAdjustXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleFilter:
{
Approximator a=new Approximator(ApproximatorType.DOUGLAS_PEUCKER,25);
if (!mChart.isFilteringEnabled()) {
mChart.enableFiltering(a);
}
 else {
mChart.disableFiltering();
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToGallery(""String_Node_Str"" + System.currentTimeMillis(),50)) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
}
return true;
}",0.9922789539227896
26695,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setValueFormatter(new MyValueFormatter());
  mChart.getAxisRight().setValueFormatter(new MyValueFormatter());
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setValueFormatter(new MyValueFormatter());
  mChart.getAxisRight().setValueFormatter(new MyValueFormatter());
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}",0.9855513307984792
26696,"public float getBelowSum(int stackIndex){
  if (mVals == null)   return 0;
  float remainder=0f;
  int index=mVals.length - 1;
  while (index > stackIndex) {
    remainder+=mVals[index];
    index--;
  }
  return remainder;
}","public float getBelowSum(int stackIndex){
  if (mVals == null)   return 0;
  float remainder=0f;
  int index=mVals.length - 1;
  while (index > stackIndex && index >= 0) {
    remainder+=mVals[index];
    index--;
  }
  return remainder;
}",0.9698275862068966
26697,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null)     continue;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=h.getStackIndex() < 0 ? e.getVal() : e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex());
      prepareBar(x,y,set.getBarSpace(),trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  int setCount=mChart.getBarData().getDataSetCount();
  for (int i=0; i < indices.length; i++) {
    Highlight h=indices[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet set=mChart.getBarData().getDataSetByIndex(dataSetIndex);
    if (set == null)     continue;
    Transformer trans=mChart.getTransformer(set.getAxisDependency());
    mHighlightPaint.setColor(set.getHighLightColor());
    mHighlightPaint.setAlpha(set.getHighLightAlpha());
    if (index < mChart.getBarData().getYValCount() && index >= 0 && index < (mChart.getXChartMax() * mAnimator.getPhaseX()) / setCount) {
      BarEntry e=mChart.getBarData().getDataSetByIndex(dataSetIndex).getEntryForXIndex(index);
      if (e == null)       continue;
      float groupspace=mChart.getBarData().getGroupSpace();
      boolean isStack=h.getStackIndex() < 0 ? false : true;
      float x=index * setCount + dataSetIndex + groupspace / 2f + groupspace * index;
      float y=isStack ? e.getVals()[h.getStackIndex()] + e.getBelowSum(h.getStackIndex()) : e.getVal();
      float from=isStack ? e.getBelowSum(h.getStackIndex()) : 0f;
      prepareBarHighlight(x,y,set.getBarSpace(),from,trans);
      c.drawRect(mBarRect,mHighlightPaint);
      if (mChart.isDrawHighlightArrowEnabled()) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mAnimator.getPhaseY() * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        trans.pathValueToPixel(arrow);
        c.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.940713853599516
26698,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setValueFormatter(new MyValueFormatter());
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setValueFormatter(new MyValueFormatter());
  mChart.getAxisRight().setValueFormatter(new MyValueFormatter());
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}",0.9734653465346534
26699,"/** 
 * This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
 * @param xIndex
 * @param dataSet
 * @param yValue
 * @return
 */
protected Highlight getStackedHighlight(int xIndex,int dataSet,double yValue){
  BarEntry entry=mData.getDataSetByIndex(dataSet).getEntryForXIndex(xIndex);
  int stackIndex=entry.getClosestIndexAbove((float)yValue);
  Highlight h=new Highlight(xIndex,dataSet,stackIndex);
  return h;
}","/** 
 * This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
 * @param xIndex
 * @param dataSet
 * @param yValue
 * @return
 */
protected Highlight getStackedHighlight(int xIndex,int dataSet,double yValue){
  BarEntry entry=mData.getDataSetByIndex(dataSet).getEntryForXIndex(xIndex);
  if (entry != null) {
    int stackIndex=entry.getClosestIndexAbove((float)yValue);
    Highlight h=new Highlight(xIndex,dataSet,stackIndex);
    return h;
  }
 else   return null;
}",0.9461077844311376
26700,"/** 
 * Returns the correct Highlight object (including xIndex and dataSet-index) for the specified touch position.
 * @param xPosition
 * @return
 */
protected Highlight getHighlight(double xPosition,double yPosition){
  int setCount=mData.getDataSetCount();
  int valCount=mData.getXValCount();
  if (!mData.isGrouped()) {
    int dataSet=0;
    int xIndex=(int)Math.round(xPosition);
    if (!mData.getDataSetByIndex(dataSet).isStacked())     return new Highlight(xIndex,dataSet);
 else     return getStackedHighlight(xIndex,dataSet,yPosition);
  }
 else {
    int steps=(int)((float)xPosition / ((float)setCount + mData.getGroupSpace()));
    float groupSpaceSum=mData.getGroupSpace() * (float)steps;
    float baseNoSpace=(float)xPosition - groupSpaceSum;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xPosition + ""String_Node_Str""+ steps+ ""String_Node_Str""+ groupSpaceSum+ ""String_Node_Str""+ baseNoSpace);
    int dataSetIndex=(int)baseNoSpace % setCount;
    int xIndex=(int)baseNoSpace / setCount;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
}","/** 
 * Returns the correct Highlight object (including xIndex and dataSet-index) for the specified touch position.
 * @param xPosition
 * @return
 */
protected Highlight getHighlight(double xPosition,double yPosition){
  int setCount=mData.getDataSetCount();
  int valCount=mData.getXValCount();
  if (!mData.isGrouped()) {
    int dataSetIndex=0;
    int xIndex=(int)Math.round(xPosition);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
 else {
    int steps=(int)((float)xPosition / ((float)setCount + mData.getGroupSpace()));
    float groupSpaceSum=mData.getGroupSpace() * (float)steps;
    float baseNoSpace=(float)xPosition - groupSpaceSum;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xPosition + ""String_Node_Str""+ steps+ ""String_Node_Str""+ groupSpaceSum+ ""String_Node_Str""+ baseNoSpace);
    int dataSetIndex=(int)baseNoSpace % setCount;
    int xIndex=(int)baseNoSpace / setCount;
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex);
    if (xIndex < 0) {
      xIndex=0;
      dataSetIndex=0;
    }
 else     if (xIndex >= valCount) {
      xIndex=valCount - 1;
      dataSetIndex=setCount - 1;
    }
    if (dataSetIndex < 0)     dataSetIndex=0;
 else     if (dataSetIndex >= setCount)     dataSetIndex=setCount - 1;
    if (!mData.getDataSetByIndex(dataSetIndex).isStacked())     return new Highlight(xIndex,dataSetIndex);
 else     return getStackedHighlight(xIndex,dataSetIndex,yPosition);
  }
}",0.9123311296349526
26701,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    Log.i(LOG_TAG,""String_Node_Str"" + high.toString());
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex(),high);
    }
  }
}",0.9544715447154472
26702,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas);
  mAxisRendererRight.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  mXAxisRenderer.renderAxis(mDrawCanvas);
  mAxisRendererLeft.renderAxis(mDrawCanvas);
  mAxisRendererRight.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  mLegendRenderer.renderLegend(mDrawCanvas,mLegend);
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas);
  mAxisRendererRight.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  mXAxisRenderer.renderAxisLabels(mDrawCanvas);
  mXAxisRenderer.renderAxisLine(mDrawCanvas);
  mAxisRendererLeft.renderAxisLabels(mDrawCanvas);
  mAxisRendererRight.renderAxisLabels(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  mLegendRenderer.renderLegend(mDrawCanvas,mLegend);
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.9811097992916176
26703,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxis(mDrawCanvas);
  if (mDrawWeb)   mRenderer.drawExtras(mDrawCanvas);
  mYAxisRenderer.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  mLegendRenderer.renderLegend(mDrawCanvas,mLegend);
  drawDescription();
  drawMarkers();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxisLabels(mDrawCanvas);
  if (mDrawWeb)   mRenderer.drawExtras(mDrawCanvas);
  mYAxisRenderer.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxisLabels(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  mLegendRenderer.renderLegend(mDrawCanvas,mLegend);
  drawDescription();
  drawMarkers();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
}",0.9902597402597404
26704,"/** 
 * This method enables a specified custom MarkerView to update it's content everytime the MarkerView is redrawn.
 * @param e The Entry the MarkerView belongs to. This can also be anysubclass of Entry, like BarEntry or CandleEntry.
 * @param dataSetIndex the index of the DataSet the selected value is in
 */
public abstract void refreshContent(Entry e,int dataSetIndex);","/** 
 * This method enables a specified custom MarkerView to update it's content everytime the MarkerView is redrawn.
 * @param e The Entry the MarkerView belongs to. This can also be anysubclass of Entry, like BarEntry or CandleEntry, simply cast it at runtime.
 * @param dataSetIndex the index of the DataSet the selected value is in
 */
public abstract void refreshContent(Entry e,int dataSetIndex);",0.9652509652509652
26705,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextColor(Color.WHITE);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setAxisMaxValue(900);
  rightAxis.setDrawGridLines(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextSize(11f);
  l.setTextColor(Color.WHITE);
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextSize(12f);
  xAxis.setTextColor(Color.WHITE);
  xAxis.setDrawGridLines(false);
  xAxis.setDrawAxisLine(false);
  xAxis.setSpaceBetweenLabels(1);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setAxisMaxValue(900);
  rightAxis.setStartAtZero(false);
  rightAxis.setAxisMinValue(-200);
  rightAxis.setDrawGridLines(false);
}",0.9514255543822596
26706,"public float getRequiredHeightSpace(Paint p){
  String label=getLongestLabel();
  return (float)Utils.calcTextHeight(p,label) + getYOffset() * 2f;
}","public float getRequiredHeightSpace(Paint p){
  p.setTextSize(mTextSize);
  String label=getLongestLabel();
  return (float)Utils.calcTextHeight(p,label) + getYOffset() * 2f;
}",0.9135802469135802
26707,"public float getRequiredWidthSpace(Paint p){
  String label=getLongestLabel();
  return (float)Utils.calcTextWidth(p,label) + getXOffset() * 2f;
}","public float getRequiredWidthSpace(Paint p){
  p.setTextSize(mTextSize);
  String label=getLongestLabel();
  return (float)Utils.calcTextWidth(p,label) + getXOffset() * 2f;
}",0.9125
26708,"/** 
 * Set a custom minimum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetAxisMinValue() to undo this.
 * @param min
 */
public void setAxisMinValue(float min){
  mCustomAxisMin=min;
}","/** 
 * Set a custom minimum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetAxisMinValue() to undo this. Do not forget to call setStartAtZero(false) if you use this method. Otherwise, the axis-minimum value will still be forced to 0.
 * @param min
 */
public void setAxisMinValue(float min){
  mCustomAxisMin=min;
}",0.7993779160186625
26709,"public void computeAxis(float xValAverageLength,ArrayList<String> xValues){
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(xValAverageLength + mXAxis.getSpaceBetweenLabels());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXAxis.mLabelWidth=Utils.calcTextWidth(mAxisPaint,a.toString());
  mXAxis.mLabelHeight=Utils.calcTextHeight(mAxisPaint,""String_Node_Str"");
  mXAxis.setValues(xValues);
}","public void computeAxis(float xValAverageLength,ArrayList<String> xValues){
  mAxisPaint.setTypeface(mXAxis.getTypeface());
  mAxisPaint.setTextSize(mXAxis.getTextSize());
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(xValAverageLength + mXAxis.getSpaceBetweenLabels());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXAxis.mLabelWidth=Utils.calcTextWidth(mAxisPaint,a.toString());
  mXAxis.mLabelHeight=Utils.calcTextHeight(mAxisPaint,""String_Node_Str"");
  mXAxis.setValues(xValues);
}",0.9
26710,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawFilled(true);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTypeface(tf);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((1990 + i) + ""String_Node_Str"");
  }
  ArrayList<Entry> vals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 20;
    vals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(vals1,""String_Node_Str"");
  set1.setDrawCubic(true);
  set1.setCubicIntensity(0.2f);
  set1.setDrawFilled(true);
  set1.setDrawCircles(false);
  set1.setLineWidth(2f);
  set1.setCircleSize(5f);
  set1.setHighLightColor(Color.rgb(244,117,117));
  set1.setColor(Color.rgb(104,241,175));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTypeface(tf);
  data.setValueTextSize(9f);
  data.setDrawValues(false);
  mChart.setData(data);
}",0.9682713347921226
26711,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(true);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(tf);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(true);
  setData(12,50);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawAxisLine(true);
  xl.setDrawGridLines(true);
  xl.setGridLineWidth(0.3f);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setDrawAxisLine(true);
  yl.setDrawGridLines(true);
  yl.setGridLineWidth(0.3f);
  YAxis yr=mChart.getAxisRight();
  yr.setTypeface(tf);
  yr.setDrawAxisLine(true);
  yr.setDrawGridLines(false);
  setData(12,50);
  mChart.animateY(2500);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.979226589964845
26712,"@SuppressLint(""String_Node_Str"") @Override public void onValueSelected(Entry e,int dataSetIndex,Highlight h){
  if (e == null)   return;
  RectF bounds=mChart.getBarBounds((BarEntry)e);
  PointF position=mChart.getPosition(e,AxisDependency.LEFT);
  Log.i(""String_Node_Str"",bounds.toString());
  Log.i(""String_Node_Str"",position.toString());
}","@SuppressLint(""String_Node_Str"") @Override public void onValueSelected(Entry e,int dataSetIndex,Highlight h){
  if (e == null)   return;
  RectF bounds=mChart.getBarBounds((BarEntry)e);
  PointF position=mChart.getPosition(e,mChart.getData().getDataSetByIndex(dataSetIndex).getAxisDependency());
  Log.i(""String_Node_Str"",bounds.toString());
  Log.i(""String_Node_Str"",position.toString());
}",0.7967257844474761
26713,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextSize(10f);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.9896265560165975
26714,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextColor(Color.WHITE);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  data.setValueTextColor(Color.WHITE);
  data.setValueTextSize(9f);
  mChart.setData(data);
}",0.990419557317476
26715,"public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  mChart.setData(data);
  mChart.invalidate();
}","public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  data.setDrawValues(false);
  mChart.setData(data);
  mChart.invalidate();
}",0.9867398262459992
26716,"/** 
 * Returns the bounding box of the specified Entry in the specified DataSet. Returns null if the Entry could not be found in the charts data.
 * @param e
 * @param dataSetIndex
 * @return
 */
public RectF getBarBounds(BarEntry e){
  BarDataSet set=mData.getDataSetForEntry(e);
  if (set == null)   return null;
  float barspace=set.getBarSpace();
  float y=e.getVal();
  float x=e.getXIndex();
  float spaceHalf=barspace / 2f;
  float left=x - 0.5f + spaceHalf;
  float right=x + 0.5f - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  RectF bounds=new RectF(left,top,right,bottom);
  getTransformer(set.getAxisDependency()).rectValueToPixel(bounds);
  return bounds;
}","/** 
 * Returns the bounding box of the specified Entry in the specified DataSet. Returns null if the Entry could not be found in the charts data.
 * @param e
 * @param dataSetIndex
 * @return
 */
public RectF getBarBounds(BarEntry e){
  BarDataSet set=mData.getDataSetForEntry(e);
  if (set == null)   return null;
  float barspace=set.getBarSpace();
  float y=e.getVal();
  float x=e.getXIndex();
  float barWidth=0.5f;
  float spaceHalf=barspace / 2f;
  float left=x - barWidth + spaceHalf;
  float right=x + barWidth - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  RectF bounds=new RectF(left,top,right,bottom);
  getTransformer(set.getAxisDependency()).rectValueToPixel(bounds);
  return bounds;
}",0.9670175438596492
26717,"/** 
 * Returns the position (in pixels) the provided Entry has inside the chart view or null, if the provided Entry is null.
 * @param e
 * @return
 */
public PointF getPosition(Entry e,AxisDependency axis){
  if (e == null)   return null;
  float[] vals=new float[]{e.getXIndex(),e.getVal()};
  if (this instanceof BarChart) {
    BarDataSet set=(BarDataSet)mData.getDataSetForEntry(e);
    if (set != null)     vals[0]+=set.getBarSpace() / 2f;
  }
  getTransformer(axis).pointValuesToPixel(vals);
  return new PointF(vals[0],vals[1]);
}","/** 
 * Returns the position (in pixels) the provided Entry has inside the chart view or null, if the provided Entry is null.
 * @param e
 * @return
 */
public PointF getPosition(Entry e,AxisDependency axis){
  if (e == null)   return null;
  float[] vals=new float[]{e.getXIndex(),e.getVal()};
  getTransformer(axis).pointValuesToPixel(vals);
  return new PointF(vals[0],vals[1]);
}",0.8308026030368764
26718,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setWebLineWidth(1.5f);
  mChart.setWebLineWidthInner(0.75f);
  mChart.setWebAlpha(100);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  setData();
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextSize(9f);
  YAxis yl=mChart.getYAxis();
  yl.setTypeface(tf);
  yl.setLabelCount(5);
  yl.setTextSize(9f);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setWebLineWidth(1.5f);
  mChart.setWebLineWidthInner(0.75f);
  mChart.setWebAlpha(100);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  setData();
  XAxis xAxis=mChart.getXAxis();
  xAxis.setTypeface(tf);
  xAxis.setTextSize(9f);
  YAxis yAxis=mChart.getYAxis();
  yAxis.setTypeface(tf);
  yAxis.setLabelCount(5);
  yAxis.setTextSize(9f);
  yAxis.setStartAtZero(true);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.966373512674599
26719,"public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  mChart.setData(data);
  mChart.invalidate();
}","public void setData(){
  float mult=150;
  int cnt=9;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < cnt; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < cnt; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < cnt; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  set1.setDrawFilled(true);
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(ColorTemplate.VORDIPLOM_COLORS[4]);
  set2.setDrawFilled(true);
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  data.setValueTypeface(tf);
  data.setValueTextSize(8f);
  mChart.setData(data);
  mChart.invalidate();
}",0.986378581493659
26720,"@Override protected void calcMinMax(){
  super.calcMinMax();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float leftRange=Math.abs(maxLeft - (mYAxis.isStartAtZeroEnabled() ? 0 : minLeft));
  float topSpaceLeft=leftRange / 100f * mYAxis.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mYAxis.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mYAxis.mAxisMaximum=!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mYAxis.mAxisMinimum=!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : minLeft - bottomSpaceLeft;
  if (mYAxis.isStartAtZeroEnabled())   mYAxis.mAxisMinimum=0f;
  mYAxis.mAxisRange=Math.abs(mYAxis.mAxisMaximum - mYAxis.mAxisMinimum);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  float leftRange=Math.abs(maxLeft - (mYAxis.isStartAtZeroEnabled() ? 0 : minLeft));
  float topSpaceLeft=leftRange / 100f * mYAxis.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mYAxis.getSpaceBottom();
  mXChartMax=mData.getXVals().size() - 1;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
  mYAxis.mAxisMaximum=!Float.isNaN(mYAxis.getAxisMaxValue()) ? mYAxis.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mYAxis.mAxisMinimum=!Float.isNaN(mYAxis.getAxisMinValue()) ? mYAxis.getAxisMinValue() : minLeft - bottomSpaceLeft;
  if (mYAxis.isStartAtZeroEnabled())   mYAxis.mAxisMinimum=0f;
  mYAxis.mAxisRange=Math.abs(mYAxis.mAxisMaximum - mYAxis.mAxisMinimum);
}",0.950483779169038
26721,"/** 
 * Returns the factor that is needed to transform values into pixels.
 * @return
 */
public float getFactor(){
  RectF content=mViewPortHandler.getContentRect();
  return (float)Math.min(content.width() / 2f,content.height() / 2f) / mYAxis.mAxisMaximum;
}","/** 
 * Returns the factor that is needed to transform values into pixels.
 * @return
 */
public float getFactor(){
  RectF content=mViewPortHandler.getContentRect();
  return (float)Math.min(content.width() / 2f,content.height() / 2f) / mYAxis.mAxisRange;
}",0.9768339768339768
26722,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  if (mYAxis.needsDefaultFormatter()) {
    mYAxis.setValueFormatter(mDefaultFormatter);
  }
  mYAxisRenderer.computeAxis(0f,mYAxis.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  if (mYAxis.needsDefaultFormatter()) {
    mYAxis.setValueFormatter(mDefaultFormatter);
  }
  mYAxisRenderer.computeAxis(mYAxis.mAxisMinimum,mYAxis.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  mLegend=mLegendRenderer.computeLegend(mData,mLegend);
  calculateOffsets();
}",0.9739130434782608
26723,"protected void drawDataSet(Canvas c,RadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  ArrayList<Entry> entries=dataSet.getYVals();
  Path surface=new Path();
  for (int j=0; j < entries.size(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=entries.get(j);
    PointF p=Utils.getPosition(center,e.getVal() * factor,sliceangle * j + mChart.getRotationAngle());
    if (j == 0)     surface.moveTo(p.x,p.y);
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  if (dataSet.isDrawFilledEnabled()) {
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setAlpha(dataSet.getFillAlpha());
    c.drawPath(surface,mRenderPaint);
    mRenderPaint.setAlpha(255);
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}","protected void drawDataSet(Canvas c,RadarDataSet dataSet){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  ArrayList<Entry> entries=dataSet.getYVals();
  Path surface=new Path();
  for (int j=0; j < entries.size(); j++) {
    mRenderPaint.setColor(dataSet.getColor(j));
    Entry e=entries.get(j);
    PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
    if (j == 0)     surface.moveTo(p.x,p.y);
 else     surface.lineTo(p.x,p.y);
  }
  surface.close();
  if (dataSet.isDrawFilledEnabled()) {
    mRenderPaint.setStyle(Paint.Style.FILL);
    mRenderPaint.setAlpha(dataSet.getFillAlpha());
    c.drawPath(surface,mRenderPaint);
    mRenderPaint.setAlpha(255);
  }
  mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
  mRenderPaint.setStyle(Paint.Style.STROKE);
  if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)   c.drawPath(surface,mRenderPaint);
}",0.9871031746031746
26724,"protected void drawWeb(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  float rotationangle=mChart.getRotationAngle();
  PointF center=mChart.getCenterOffsets();
  mWebPaint.setStrokeWidth(mChart.getWebLineWidth());
  mWebPaint.setColor(mChart.getWebColor());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  for (int i=0; i < mChart.getData().getXValCount(); i++) {
    PointF p=Utils.getPosition(center,mChart.getYChartMax() * factor,sliceangle * i + rotationangle);
    c.drawLine(center.x,center.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mChart.getWebLineWidthInner());
  mWebPaint.setColor(mChart.getWebColorInner());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  int labelCount=mChart.getYAxis().mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mChart.getData().getXValCount(); i++) {
      float r=mChart.getYAxis().mEntries[j] * factor;
      PointF p1=Utils.getPosition(center,r,sliceangle * i + rotationangle);
      PointF p2=Utils.getPosition(center,r,sliceangle * (i + 1) + rotationangle);
      c.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}","protected void drawWeb(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  float rotationangle=mChart.getRotationAngle();
  PointF center=mChart.getCenterOffsets();
  mWebPaint.setStrokeWidth(mChart.getWebLineWidth());
  mWebPaint.setColor(mChart.getWebColor());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  for (int i=0; i < mChart.getData().getXValCount(); i++) {
    PointF p=Utils.getPosition(center,mChart.getYRange() * factor,sliceangle * i + rotationangle);
    c.drawLine(center.x,center.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mChart.getWebLineWidthInner());
  mWebPaint.setColor(mChart.getWebColorInner());
  mWebPaint.setAlpha(mChart.getWebAlpha());
  int labelCount=mChart.getYAxis().mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mChart.getData().getXValCount(); i++) {
      float r=(mChart.getYAxis().mEntries[j] - mChart.getYChartMin()) * factor;
      PointF p1=Utils.getPosition(center,r,sliceangle * i + rotationangle);
      PointF p2=Utils.getPosition(center,r,sliceangle * (i + 1) + rotationangle);
      c.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}",0.9830361026533276
26725,"@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry e=entries.get(j);
      PointF p=Utils.getPosition(center,e.getVal() * factor,sliceangle * j + mChart.getRotationAngle());
      c.drawText(dataSet.getValueFormatter().getFormattedValue(e.getVal()),p.x,p.y - yoffset,mValuePaint);
    }
  }
}","@Override public void drawValues(Canvas c){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  float yoffset=Utils.convertDpToPixel(5f);
  for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
    RadarDataSet dataSet=mChart.getData().getDataSetByIndex(i);
    if (!dataSet.isDrawValuesEnabled())     continue;
    applyValueTextStyle(dataSet);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      Entry e=entries.get(j);
      PointF p=Utils.getPosition(center,(e.getVal() - mChart.getYChartMin()) * factor,sliceangle * j + mChart.getRotationAngle());
      c.drawText(dataSet.getValueFormatter().getFormattedValue(e.getVal()),p.x,p.y - yoffset,mValuePaint);
    }
  }
}",0.971938775510204
26726,"@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    int j=set.getEntryPosition(e);
    float y=e.getVal();
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,0,p.x,mViewPortHandler.getChartHeight(),0,p.y,mViewPortHandler.getChartWidth(),p.y};
    c.drawLines(pts,mHighlightPaint);
  }
}","@Override public void drawHighlighted(Canvas c,Highlight[] indices){
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < indices.length; i++) {
    RadarDataSet set=mChart.getData().getDataSetByIndex(indices[i].getDataSetIndex());
    if (set == null)     continue;
    mHighlightPaint.setColor(set.getHighLightColor());
    int xIndex=indices[i].getXIndex();
    Entry e=set.getEntryForXIndex(xIndex);
    int j=set.getEntryPosition(e);
    float y=(e.getVal() - mChart.getYChartMin());
    PointF p=Utils.getPosition(center,y * factor,sliceangle * j + mChart.getRotationAngle());
    float[] pts=new float[]{p.x,0,p.x,mViewPortHandler.getChartHeight(),0,p.y,mViewPortHandler.getChartWidth(),p.y};
    c.drawLines(pts,mHighlightPaint);
  }
}",0.9841075794621028
26727,"@Override public void renderAxisLabels(Canvas c){
  if (!mXAxis.isEnabled() || !mXAxis.isDrawLabelsEnabled())   return;
  mAxisPaint.setTypeface(mXAxis.getTypeface());
  mAxisPaint.setTextSize(mXAxis.getTextSize());
  mAxisPaint.setColor(mXAxis.getTextColor());
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < mXAxis.getValues().size(); i++) {
    String text=mXAxis.getValues().get(i);
    float angle=(sliceangle * i + mChart.getRotationAngle()) % 360f;
    PointF p=Utils.getPosition(center,mChart.getYChartMax() * factor + mXAxis.mLabelWidth / 2f,angle);
    c.drawText(text,p.x,p.y + mXAxis.mLabelHeight / 2f,mAxisPaint);
  }
}","@Override public void renderAxisLabels(Canvas c){
  if (!mXAxis.isEnabled() || !mXAxis.isDrawLabelsEnabled())   return;
  mAxisPaint.setTypeface(mXAxis.getTypeface());
  mAxisPaint.setTextSize(mXAxis.getTextSize());
  mAxisPaint.setColor(mXAxis.getTextColor());
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < mXAxis.getValues().size(); i++) {
    String text=mXAxis.getValues().get(i);
    float angle=(sliceangle * i + mChart.getRotationAngle()) % 360f;
    PointF p=Utils.getPosition(center,mChart.getYRange() * factor + mXAxis.mLabelWidth / 2f,angle);
    c.drawText(text,p.x,p.y + mXAxis.mLabelHeight / 2f,mAxisPaint);
  }
}",0.9910158949550796
26728,"@Override public void renderAxisLabels(Canvas c){
  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;
  mAxisPaint.setTypeface(mYAxis.getTypeface());
  mAxisPaint.setTextSize(mYAxis.getTextSize());
  mAxisPaint.setColor(mYAxis.getTextColor());
  PointF center=mChart.getCenterOffsets();
  float factor=mChart.getFactor();
  int labelCount=mYAxis.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    if (j == labelCount - 1 && mYAxis.isDrawTopYLabelEntryEnabled() == false)     break;
    float r=mYAxis.mEntries[j] * factor;
    PointF p=Utils.getPosition(center,r,mChart.getRotationAngle());
    String label=mYAxis.getFormattedLabel(j);
    c.drawText(label,p.x + 10,p.y,mAxisPaint);
  }
}","@Override public void renderAxisLabels(Canvas c){
  if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())   return;
  mAxisPaint.setTypeface(mYAxis.getTypeface());
  mAxisPaint.setTextSize(mYAxis.getTextSize());
  mAxisPaint.setColor(mYAxis.getTextColor());
  PointF center=mChart.getCenterOffsets();
  float factor=mChart.getFactor();
  int labelCount=mYAxis.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    if (j == labelCount - 1 && mYAxis.isDrawTopYLabelEntryEnabled() == false)     break;
    float r=(mYAxis.mEntries[j] - mYAxis.mAxisMinimum) * factor;
    PointF p=Utils.getPosition(center,r,mChart.getRotationAngle());
    String label=mYAxis.getFormattedLabel(j);
    c.drawText(label,p.x + 10,p.y,mAxisPaint);
  }
}",0.9834254143646408
26729,"@Override public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    float r=l.getLimit() * factor;
    Path limitPath=new Path();
    for (int j=0; j < mChart.getData().getXValCount(); j++) {
      PointF p=Utils.getPosition(center,r,sliceangle * j + mChart.getRotationAngle());
      if (j == 0)       limitPath.moveTo(p.x,p.y);
 else       limitPath.lineTo(p.x,p.y);
    }
    limitPath.close();
    c.drawPath(limitPath,mLimitLinePaint);
  }
}","@Override public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    float r=(l.getLimit() - mChart.getYChartMin()) * factor;
    Path limitPath=new Path();
    for (int j=0; j < mChart.getData().getXValCount(); j++) {
      PointF p=Utils.getPosition(center,r,sliceangle * j + mChart.getRotationAngle());
      if (j == 0)       limitPath.moveTo(p.x,p.y);
 else       limitPath.lineTo(p.x,p.y);
    }
    limitPath.close();
    c.drawPath(limitPath,mLimitLinePaint);
  }
}",0.9733629300776916
26730,"protected boolean passesCheck(){
  return mChart.getBarData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleY();
}","@Override protected boolean passesCheck(){
  return mChart.getBarData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleY();
}",0.9655172413793104
26731,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setCenterXLabelText(true);
  xAxis.setSpaceBetweenLabels(0);
  xAxis.setDrawGridLines(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setSpaceBetweenLabels(0);
  xAxis.setDrawGridLines(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}",0.9839523154516276
26732,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(25f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setValueTypeface(tf);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(25f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setValueTypeface(tf);
}",0.9892833221701272
26733,"@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setCenterXLabelText(true);
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}",0.9845474613686536
26734,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  MyValueFormatter customFormatter=new MyValueFormatter();
  mChart.setValueFormatter(customFormatter);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setFormatter(customFormatter);
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  xLabels.setCenterXLabelText(true);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  MyValueFormatter customFormatter=new MyValueFormatter();
  mChart.setValueFormatter(customFormatter);
  mChart.setDrawValuesForWholeStack(true);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(5);
  yLabels.setFormatter(customFormatter);
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XAxisPosition.TOP);
  mSeekBarX.setProgress(12);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_RIGHT);
  l.setFormSize(8f);
  l.setFormToTextSpace(4f);
  l.setXEntrySpace(6f);
}",0.9861888764464352
26735,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setCenterXLabelText(true);
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(20f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(20f);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(20f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(20f);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}",0.9840109639104614
26736,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    if (mXAxis.isCenterXLabelsEnabled())     position[0]+=0.5f;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i;
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1 && mXAxis.getValues().size() > 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}",0.3828282828282828
26737,"/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
@Override protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  BarData bd=mChart.getData();
  int step=bd.getDataSetCount();
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() + bd.getGroupSpace() / 2f - 0.5f;
    if (mXAxis.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param pos
 */
@Override protected void drawLabels(Canvas c,float pos){
  float[] position=new float[]{0f,0f};
  BarData bd=mChart.getData();
  int step=bd.getDataSetCount();
  for (int i=0; i < mXAxis.getValues().size(); i+=mXAxis.mAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() + bd.getGroupSpace() / 2f;
    if (step > 1) {
      position[0]+=((float)step - 1f) / 2f;
    }
    mTrans.pointValuesToPixel(position);
    if (mViewPortHandler.isInBoundsX(position[0])) {
      String label=mXAxis.getValues().get(i);
      if (mXAxis.isAvoidFirstLastClippingEnabled()) {
        if (i == mXAxis.getValues().size() - 1) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          if (width > mViewPortHandler.offsetRight() * 2 && position[0] + width > mViewPortHandler.getChartWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mAxisPaint,label);
          position[0]+=width / 2;
        }
      }
      c.drawText(label,position[0],pos,mAxisPaint);
    }
  }
}",0.9549071618037136
26738,"/** 
 * Generates an automatically prepared legend depending on the DataSets in the chart and their colors.
 */
public void prepareLegend(){
  ArrayList<String> labels=new ArrayList<String>();
  ArrayList<Integer> colors=new ArrayList<Integer>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<? extends Entry> dataSet=mData.getDataSetByIndex(i);
    ArrayList<Integer> clrs=dataSet.getColors();
    int entryCount=dataSet.getEntryCount();
    if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).getStackSize() > 1) {
      BarDataSet bds=(BarDataSet)dataSet;
      String[] sLabels=bds.getStackLabels();
      for (int j=0; j < clrs.size() && j < entryCount && j < bds.getStackSize(); j++) {
        labels.add(sLabels[j % sLabels.length]);
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(bds.getLabel());
    }
 else     if (dataSet instanceof PieDataSet) {
      ArrayList<String> xVals=mData.getXVals();
      PieDataSet pds=(PieDataSet)dataSet;
      for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
        labels.add(xVals.get(j));
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(pds.getLabel());
    }
 else {
      for (int j=0; j < clrs.size() && j < entryCount; j++) {
        if (j < clrs.size() - 1 && j < entryCount - 1) {
          labels.add(null);
        }
 else {
          String label=mData.getDataSetByIndex(i).getLabel();
          labels.add(label);
        }
        colors.add(clrs.get(j));
      }
    }
  }
  Legend l=new Legend(colors,labels);
  if (mLegend != null) {
    l.apply(mLegend);
  }
  mLegend=l;
}","/** 
 * Generates an automatically prepared legend depending on the DataSets in the chart and their colors.
 */
public void prepareLegend(){
  ArrayList<String> labels=new ArrayList<String>();
  ArrayList<Integer> colors=new ArrayList<Integer>();
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<? extends Entry> dataSet=mData.getDataSetByIndex(i);
    ArrayList<Integer> clrs=dataSet.getColors();
    int entryCount=dataSet.getEntryCount();
    if (dataSet instanceof BarDataSet && ((BarDataSet)dataSet).getStackSize() > 1) {
      BarDataSet bds=(BarDataSet)dataSet;
      String[] sLabels=bds.getStackLabels();
      for (int j=0; j < clrs.size() && j < bds.getStackSize(); j++) {
        labels.add(sLabels[j % sLabels.length]);
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(bds.getLabel());
    }
 else     if (dataSet instanceof PieDataSet) {
      ArrayList<String> xVals=mData.getXVals();
      PieDataSet pds=(PieDataSet)dataSet;
      for (int j=0; j < clrs.size() && j < entryCount && j < xVals.size(); j++) {
        labels.add(xVals.get(j));
        colors.add(clrs.get(j));
      }
      colors.add(-2);
      labels.add(pds.getLabel());
    }
 else {
      for (int j=0; j < clrs.size() && j < entryCount; j++) {
        if (j < clrs.size() - 1 && j < entryCount - 1) {
          labels.add(null);
        }
 else {
          String label=mData.getDataSetByIndex(i).getLabel();
          labels.add(label);
        }
        colors.add(clrs.get(j));
      }
    }
  }
  Legend l=new Legend(colors,labels);
  if (mLegend != null) {
    l.apply(mLegend);
  }
  mLegend=l;
}",0.9945255474452556
26739,"@Override public void notifyDataSetChanged(){
  super.notifyDataSetChanged();
  mYAxisRenderer.computeAxis(0f,mData.getYMax());
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
}","@Override public void notifyDataSetChanged(){
  super.notifyDataSetChanged();
  if (mData != null) {
    mYAxisRenderer.computeAxis(0f,mData.getYMax());
    mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  }
}",0.9300225733634312
26740,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f);
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setDrawValue(true);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  LimitLine ll2=new LimitLine(-30f);
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setDrawValue(true);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  mChart.getAxisLeft().addLimitLine(ll1);
  mChart.getAxisLeft().addLimitLine(ll2);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.8831562974203339
26741,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas,mValueFormatter);
  mAxisRendererRight.renderLimitLines(mDrawCanvas,mValueFormatter);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  mXAxisRenderer.renderAxis(mDrawCanvas);
  mAxisRendererLeft.renderAxis(mDrawCanvas);
  mAxisRendererRight.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas);
  mAxisRendererRight.renderLimitLines(mDrawCanvas);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  mXAxisRenderer.renderAxis(mDrawCanvas);
  mAxisRendererLeft.renderAxis(mDrawCanvas);
  mAxisRendererRight.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.9902498476538696
26742,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxis(mDrawCanvas);
  if (mDrawWeb)   mRenderer.drawExtras(mDrawCanvas);
  mYAxisRenderer.renderLimitLines(mDrawCanvas,mValueFormatter);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawDescription();
  drawMarkers();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  mXAxisRenderer.renderAxis(mDrawCanvas);
  if (mDrawWeb)   mRenderer.drawExtras(mDrawCanvas);
  mYAxisRenderer.renderLimitLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  if (mHighlightEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mYAxisRenderer.renderAxis(mDrawCanvas);
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawDescription();
  drawMarkers();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
}",0.9862306368330463
26743,"/** 
 * Constructor with limit.
 * @param limit
 */
public LimitLine(float limit){
  mLimit=limit;
}","/** 
 * Constructor with limit and label.
 * @param limit - the position (the value) on the y-axis where this lineshould appear
 * @param label - provide """" if no label is required
 */
public LimitLine(float limit,String label){
  mLimit=limit;
  mLabel=label;
}",0.5524861878453039
26744,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c,ValueFormatter valueFormatter){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    if (l.isDrawValueEnabled()) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      String label=valueFormatter.getFormattedValue(l.getLimit());
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(1f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.8996205588133839
26745,"public YAxisRenderer(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,trans);
  this.mYAxis=yAxis;
  mAxisPaint.setColor(Color.BLACK);
  mAxisPaint.setTextSize(Utils.convertDpToPixel(10f));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.STROKE);
}","public YAxisRenderer(ViewPortHandler viewPortHandler,YAxis yAxis,Transformer trans){
  super(viewPortHandler,trans);
  this.mYAxis=yAxis;
  mAxisPaint.setColor(Color.BLACK);
  mAxisPaint.setTextSize(Utils.convertDpToPixel(10f));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.FILL_AND_STROKE);
}",0.9865470852017936
26746,"@Override public void renderLimitLines(Canvas c,ValueFormatter valueFormatter){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    float r=l.getLimit() * factor;
    Path limitPath=new Path();
    for (int j=0; j < mChart.getData().getXValCount(); j++) {
      PointF p=Utils.getPosition(center,r,sliceangle * j + mChart.getRotationAngle());
      if (j == 0)       limitPath.moveTo(p.x,p.y);
 else       limitPath.lineTo(p.x,p.y);
    }
    limitPath.close();
    c.drawPath(limitPath,mLimitLinePaint);
  }
}","@Override public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float sliceangle=mChart.getSliceAngle();
  float factor=mChart.getFactor();
  PointF center=mChart.getCenterOffsets();
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    float r=l.getLimit() * factor;
    Path limitPath=new Path();
    for (int j=0; j < mChart.getData().getXValCount(); j++) {
      PointF p=Utils.getPosition(center,r,sliceangle * j + mChart.getRotationAngle());
      if (j == 0)       limitPath.moveTo(p.x,p.y);
 else       limitPath.lineTo(p.x,p.y);
    }
    limitPath.close();
    c.drawPath(limitPath,mLimitLinePaint);
  }
}",0.9833887043189368
26747,"/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private PieData generateDataPie(int cnt){
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int i=0; i < 4; i++) {
    entries.add(new Entry((int)(Math.random() * 70) + 30,i));
  }
  PieDataSet d=new PieDataSet(entries,""String_Node_Str"");
  d.setSliceSpace(5f);
  d.setColors(ColorTemplate.VORDIPLOM_COLORS);
  PieData cd=new PieData(getQuarters(),d);
  return cd;
}","/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private PieData generateDataPie(int cnt){
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int i=0; i < 4; i++) {
    entries.add(new Entry((int)(Math.random() * 70) + 30,i));
  }
  PieDataSet d=new PieDataSet(entries,""String_Node_Str"");
  d.setSliceSpace(2f);
  d.setColors(ColorTemplate.VORDIPLOM_COLORS);
  PieData cd=new PieData(getQuarters(),d);
  return cd;
}",0.9978021978021978
26748,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}",0.7804627249357327
26749,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setData(getComplexity());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setData(getComplexity());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  return v;
}",0.8282168517308949
26750,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_scatter,container,false);
  mChart=(ScatterChart)v.findViewById(R.id.scatterChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setData(generateScatterData(3,10000,150));
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_scatter,container,false);
  mChart=(ScatterChart)v.findViewById(R.id.scatterChart1);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setData(generateScatterData(3,10000,150));
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setDrawGridLines(false);
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  return v;
}",0.8547763666482606
26751,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setData(generateLineData());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setData(generateLineData());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setStartAtZero(false);
  leftAxis.setAxisMaxValue(1.2f);
  leftAxis.setAxisMinValue(-1.2f);
  mChart.getAxisRight().setEnabled(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setEnabled(false);
  return v;
}",0.8670731707317073
26752,"public BarChartItem(ChartData cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}","public BarChartItem(ChartData<?> cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}",0.9880478087649402
26753,"public ChartItem(ChartData cd){
  this.mChartData=cd;
}","public ChartItem(ChartData<?> cd){
  this.mChartData=cd;
}",0.9734513274336284
26754,"public LineChartItem(ChartData cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}","public LineChartItem(ChartData<?> cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}",0.9881422924901184
26755,"public PieChartItem(ChartData cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}","public PieChartItem(ChartData<?> cd,Context c){
  super(cd);
  mTf=Typeface.createFromAsset(c.getAssets(),""String_Node_Str"");
}",0.9880478087649402
26756,"@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mAxisLeft.isEnabled()) {
    String label=mAxisLeft.getLongestLabel();
    float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
  }
  if (mAxisRight.isEnabled()) {
    String label=mAxisRight.getLongestLabel();
    float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mAxisLeft.isEnabled()) {
    String label=mAxisLeft.getLongestLabel();
    float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
  }
  if (mAxisRight.isEnabled()) {
    String label=mAxisRight.getLongestLabel();
    float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mXAxis.isEnabled()) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.995446584938704
26757,"@Override protected void init(){
  super.init();
  setDrawXLabels(false);
}","@Override protected void init(){
  super.init();
}",0.8
26758,"@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && !mChart.isScaleEnabled())   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    saveTouchStart(event);
  break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
  mChart.disableScroll();
  saveTouchStart(event);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
  }
  midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
if (mChart.isDragEnabled()) performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut()) mTouchMode=DRAG;
}
 else {
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
mTouchMode=NONE;
mChart.enableScroll();
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POST_ZOOM;
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart);
return true;
}","@SuppressLint(""String_Node_Str"") @Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && !mChart.isScaleEnabled())   return true;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    saveTouchStart(event);
  break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() >= 2) {
  mChart.disableScroll();
  saveTouchStart(event);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
  }
  midPoint(mTouchPointCenter,event);
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAG) {
mChart.disableScroll();
if (mChart.isDragEnabled()) performDrag(event);
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
mChart.disableScroll();
if (mChart.isScaleEnabled()) performZoom(event);
}
 else if (mTouchMode == NONE && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 5f) {
if (mChart.hasNoDragOffset()) {
if (!mChart.isFullyZoomedOut()) mTouchMode=DRAG;
}
 else {
mTouchMode=DRAG;
}
}
break;
case MotionEvent.ACTION_UP:
mTouchMode=NONE;
mChart.enableScroll();
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POST_ZOOM;
break;
}
mMatrix=mChart.getViewPortHandler().refresh(mMatrix,mChart);
return true;
}",0.9996848408446264
26759,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
  mDeltaX*=mData.getDataSetCount();
  int maxEntry=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<? extends Entry> set=mData.getDataSetByIndex(i);
    if (maxEntry < set.getEntryCount())     maxEntry=set.getEntryCount();
  }
  float groupSpace=mData.getGroupSpace();
  mDeltaX+=maxEntry * groupSpace;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  mDeltaX++;
  mDeltaX*=mData.getDataSetCount();
  int maxEntry=0;
  for (int i=0; i < mData.getDataSetCount(); i++) {
    DataSet<? extends Entry> set=mData.getDataSetByIndex(i);
    if (maxEntry < set.getEntryCount())     maxEntry=set.getEntryCount();
  }
  float groupSpace=mData.getGroupSpace();
  mDeltaX+=maxEntry * groupSpace;
}",0.9635036496350364
26760,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  calcMinMax(false);
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mAxisRendererLeft.computeAxis(minLeft,maxLeft);
  mAxisRendererRight.computeAxis(minRight,maxRight);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  calcMinMax();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}",0.6089906700593724
26761,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mAxisRendererLeft.computeAxis(minLeft,maxLeft);
  mAxisRendererRight.computeAxis(minRight,maxRight);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas,mValueFormatter);
  mAxisRendererRight.renderLimitLines(mDrawCanvas,mValueFormatter);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  if (mDrawXLabels) {
    mXAxisRenderer.renderAxis(mDrawCanvas);
  }
  if (mDrawYAxis) {
    mAxisRendererLeft.renderAxis(mDrawCanvas);
    mAxisRendererRight.renderAxis(mDrawCanvas);
  }
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawBorder();
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  if (mFilterData) {
    mData=getFilteredData();
    Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
    starttime=System.currentTimeMillis();
  }
 else {
    mData=getData();
  }
  if (mXAxis.isAdjustXLabelsEnabled())   calcModulus();
  drawGridBackground();
  mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum,mAxisLeft.mAxisMaximum);
  mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum,mAxisRight.mAxisMaximum);
  int clipRestoreCount=mDrawCanvas.save();
  mDrawCanvas.clipRect(mViewPortHandler.getContentRect());
  mXAxisRenderer.renderGridLines(mDrawCanvas);
  mAxisRendererLeft.renderGridLines(mDrawCanvas);
  mAxisRendererRight.renderGridLines(mDrawCanvas);
  mRenderer.drawData(mDrawCanvas);
  mAxisRendererLeft.renderLimitLines(mDrawCanvas,mValueFormatter);
  mAxisRendererRight.renderLimitLines(mDrawCanvas,mValueFormatter);
  if (mHighlightEnabled && mHighLightIndicatorEnabled && valuesToHighlight())   mRenderer.drawHighlighted(mDrawCanvas,mIndicesToHightlight);
  mDrawCanvas.restoreToCount(clipRestoreCount);
  mRenderer.drawExtras(mDrawCanvas);
  if (mDrawXLabels) {
    mXAxisRenderer.renderAxis(mDrawCanvas);
  }
  if (mDrawYAxis) {
    mAxisRendererLeft.renderAxis(mDrawCanvas);
    mAxisRendererRight.renderAxis(mDrawCanvas);
  }
  mRenderer.drawValues(mDrawCanvas);
  drawLegend();
  drawBorder();
  drawMarkers();
  drawDescription();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.8792243767313019
26762,"@Override protected void calcMinMax(boolean fixedValues){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mDeltaX=mData.getXVals().size() - 1;
  mDeltaYLeft=Math.abs(maxLeft - minLeft);
  mDeltaYRight=Math.abs(maxRight - minRight);
  mAxisLeft.mAxisMaximum=maxLeft;
  mAxisRight.mAxisMaximum=maxRight;
  mAxisLeft.mAxisMinimum=minLeft;
  mAxisRight.mAxisMinimum=minRight;
}","@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - minLeft);
  float rightRange=Math.abs(maxRight - minRight);
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=minRight - bottomSpaceRight;
  mDeltaYLeft=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mDeltaYRight=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.4571062740076824
26763,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  mDeltaX++;
}",0.8333333333333334
26764,"/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected abstract void calcMinMax(boolean fixedValues);","/** 
 * calcualtes the y-min and y-max value and the y-delta and x-delta value
 */
protected abstract void calcMinMax();",0.9266409266409268
26765,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
}",0.8913043478260869
26766,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  calcAngles();
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  calcAngles();
}",0.8387096774193549
26767,"@Override protected void calcMinMax(boolean fixedValues){
  mDeltaX=mData.getXVals().size() - 1;
}","@Override protected void calcMinMax(){
  mDeltaX=mData.getXVals().size() - 1;
}",0.8926553672316384
26768,"@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax(false);
  prepareLegend();
  calculateOffsets();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax();
  prepareLegend();
  calculateOffsets();
}",0.981549815498155
26769,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (mYAxis.mAxisMaximum <= 0)   mYAxis.mAxisMaximum=1f;
  mYAxis.mAxisMinimum=0;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mYAxis.mAxisMaximum <= 0)   mYAxis.mAxisMaximum=1f;
  mYAxis.mAxisMinimum=0;
}",0.90625
26770,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  if (mDeltaX == 0 && mData.getYValCount() > 0)   mDeltaX=1;
}",0.8913043478260869
26771,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
 else {
      if (mYAxis.isStartAtZeroEnabled()) {
        yMin=0;
      }
    }
  }
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
  }
  computeAxisValues(yMin,yMax);
}",0.9295639674173456
26772,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XLabelPosition.BOTTOM);
  xAxis.setCenterXLabelText(true);
  xAxis.setSpaceBetweenLabels(0);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XLabelPosition.BOTTOM);
  xAxis.setCenterXLabelText(true);
  xAxis.setSpaceBetweenLabels(0);
  xAxis.setDrawGridLines(false);
  mChart.getAxisLeft().setDrawGridLines(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}",0.929055580659738
26773,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  xl.setDrawGridLines(false);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.getAxisRight().setDrawGridLines(false);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9474402730375426
26774,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setFormatter(new LargeValueFormatter());
  mChart.setValueTypeface(tf);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XAxis xl=mChart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setFormatter(new LargeValueFormatter());
  leftAxis.setDrawGridLines(false);
  leftAxis.setSpaceTop(25f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setValueTypeface(tf);
}",0.9396110542476972
26775,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawGridBackground(false);
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(7);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(15);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  XAxis xLabels=mChart.getXAxis();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  YAxis yLabels=mChart.getAxisLeft();
  yLabels.setLabelCount(7);
  yLabels.setDrawGridLines(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(15);
  mSeekBarY.setProgress(100);
}",0.9669724770642202
26776,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawBorder(false);
  mChart.setDrawLegend(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  XAxis x=mChart.getXAxis();
  x.setTypeface(tf);
  YAxis y=mChart.getAxisLeft();
  y.setTypeface(tf);
  y.setLabelCount(5);
  setData(45,100);
  mChart.animateXY(2000,2000);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawBorder(false);
  mChart.setDrawLegend(false);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  XAxis x=mChart.getXAxis();
  x.setTypeface(tf);
  YAxis y=mChart.getAxisLeft();
  y.setTypeface(tf);
  y.setLabelCount(5);
  y.setDrawGridLines(false);
  setData(45,100);
  mChart.animateXY(2000,2000);
  mChart.invalidate();
}",0.9742589703588144
26777,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_horizontalbarchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(HorizontalBarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawBarShadow(false);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9746535991889153
26778,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.LTGRAY);
  setData(20,30);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  xl.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setTextColor(ColorTemplate.getHoloBlue());
  leftAxis.setAxisMaxValue(200f);
  leftAxis.setDrawGridLines(true);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setTypeface(tf);
  rightAxis.setTextColor(Color.RED);
  rightAxis.setDrawGridLines(false);
}",0.9393023894534468
26779,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range / 10);
    float val=(float)(Math.random() * mult) + 500;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range / 2f;
    float val=(float)(Math.random() * mult) + 50;
    yVals1.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals1,""String_Node_Str"");
  set1.setAxisDependency(AxisDependency.LEFT);
  set1.setColor(ColorTemplate.getHoloBlue());
  set1.setCircleColor(ColorTemplate.getHoloBlue());
  set1.setLineWidth(2f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(ColorTemplate.getHoloBlue());
  set1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=range;
    float val=(float)(Math.random() * mult) + 450;
    yVals2.add(new Entry(val,i));
  }
  LineDataSet set2=new LineDataSet(yVals2,""String_Node_Str"");
  set2.setAxisDependency(AxisDependency.RIGHT);
  set2.setColor(Color.RED);
  set2.setCircleColor(Color.RED);
  set2.setLineWidth(2f);
  set2.setCircleSize(4f);
  set2.setFillAlpha(65);
  set2.setFillColor(Color.RED);
  set2.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  dataSets.add(set2);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}",0.9853091902972326
26780,"private void setupChart(LineChart chart,LineData data,int color){
  chart.setDrawBorder(false);
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawVerticalGrid(false);
  chart.setDrawGridBackground(false);
  chart.setGridWidth(1.25f);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setValueTypeface(mTf);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  YAxis y=chart.getAxisLeft();
  y.setTextColor(Color.WHITE);
  y.setTypeface(mTf);
  y.setLabelCount(4);
  XAxis x=chart.getXAxis();
  x.setTextColor(Color.WHITE);
  x.setTypeface(mTf);
  chart.animateX(2500);
}","private void setupChart(LineChart chart,LineData data,int color){
  chart.setDrawBorder(false);
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setGridWidth(1.25f);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setValueTypeface(mTf);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  YAxis y=chart.getAxisLeft();
  y.setTextColor(Color.WHITE);
  y.setTypeface(mTf);
  y.setLabelCount(4);
  XAxis x=chart.getXAxis();
  x.setTextColor(Color.WHITE);
  x.setTypeface(mTf);
  x.setDrawGridLines(false);
  chart.animateX(2500);
}",0.9617422012948792
26781,"@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}",0.9619196661450182
26782,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}",0.9459884635553224
26783,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setData(getComplexity());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_line,container,false);
  mChart=(LineChart)v.findViewById(R.id.lineChart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawXLabels(false);
  mChart.setData(getComplexity());
  mChart.animateX(3000);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YAxis labels=mChart.getAxisLeft();
  labels.setTypeface(tf);
  XAxis xAxis=mChart.getXAxis();
  xAxis.setDrawGridLines(false);
  return v;
}",0.9310113864701942
26784,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  data.setData(generateScatterData());
  data.setData(generateCandleData());
  mChart.setData(data);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_combined);
  mChart=(CombinedChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  CombinedData data=new CombinedData(mMonths);
  data.setData(generateLineData());
  data.setData(generateBarData());
  data.setData(generateCandleData());
  mChart.setData(data);
  mChart.invalidate();
}",0.9718411552346572
26785,"private LineData generateLineData(){
  LineData d=new LineData();
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int index=0; index < itemcount; index++)   entries.add(new Entry(getRandom(),index));
  LineDataSet set=new LineDataSet(entries,""String_Node_Str"");
  set.setColor(Color.RED);
  set.setLineWidth(2.5f);
  set.setCircleColor(Color.RED);
  set.setCircleSize(5f);
  set.setFillColor(Color.RED);
  set.setDrawCubic(true);
  d.addDataSet(set);
  return d;
}","private LineData generateLineData(){
  LineData d=new LineData();
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int index=0; index < itemcount; index++)   entries.add(new Entry(getRandom(),index));
  LineDataSet set=new LineDataSet(entries,""String_Node_Str"");
  set.setColor(Color.RED);
  set.setLineWidth(2.5f);
  set.setCircleColor(Color.RED);
  set.setCircleSize(5f);
  set.setFillColor(Color.RED);
  set.setDrawCubic(true);
  set.setDrawValues(false);
  d.addDataSet(set);
  return d;
}",0.971311475409836
26786,"private CandleData generateCandleData(){
  CandleData d=new CandleData();
  ArrayList<CandleEntry> entries=new ArrayList<CandleEntry>();
  for (int index=0; index < itemcount; index++)   entries.add(new CandleEntry(index,25f,10f,12f,22f));
  CandleDataSet set=new CandleDataSet(entries,""String_Node_Str"");
  set.setColor(Color.rgb(80,80,80));
  d.addDataSet(set);
  return d;
}","private CandleData generateCandleData(){
  CandleData d=new CandleData();
  ArrayList<CandleEntry> entries=new ArrayList<CandleEntry>();
  for (int index=0; index < itemcount; index++)   entries.add(new CandleEntry(index,20f,10f,13f,17f));
  CandleDataSet set=new CandleDataSet(entries,""String_Node_Str"");
  set.setColor(Color.rgb(80,80,80));
  set.setBodySpace(0.3f);
  set.setDrawValues(false);
  d.addDataSet(set);
  return d;
}",0.8589108910891089
26787,"private ScatterData generateScatterData(){
  ScatterData d=new ScatterData();
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int index=0; index < itemcount; index++)   entries.add(new Entry(getRandom(),index));
  ScatterDataSet set=new ScatterDataSet(entries,""String_Node_Str"");
  set.setColor(Color.GREEN);
  set.setScatterShapeSize(7.5f);
  d.addDataSet(set);
  return d;
}","private ScatterData generateScatterData(){
  ScatterData d=new ScatterData();
  ArrayList<Entry> entries=new ArrayList<Entry>();
  for (int index=0; index < itemcount; index++)   entries.add(new Entry(getRandom(),index));
  ScatterDataSet set=new ScatterDataSet(entries,""String_Node_Str"");
  set.setColor(Color.GREEN);
  set.setScatterShapeSize(7.5f);
  set.setDrawValues(false);
  d.addDataSet(set);
  return d;
}",0.905
26788,"@Override protected void calcMinMax(){
  super.calcMinMax();
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}","@Override protected void calcMinMax(){
  super.calcMinMax();
  mXChartMax+=0.5f;
  mDeltaX=Math.abs(mXChartMax - mXChartMin);
}",0.9145299145299144
26789,"@Override public void drawValues(Canvas c){
}","@Override public void drawValues(Canvas c){
  if (mChart.getCandleData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    ArrayList<CandleDataSet> dataSets=mChart.getCandleData().getDataSets();
    for (int i=0; i < dataSets.size(); i++) {
      CandleDataSet dataSet=dataSets.get(i);
      Transformer trans=mChart.getTransformer(dataSet.getAxisDependency());
      if (!dataSet.isDrawValuesEnabled())       continue;
      ArrayList<CandleEntry> entries=dataSet.getYVals();
      float[] positions=trans.generateTransformedValuesCandle(entries,mAnimator.getPhaseY());
      float yOffset=Utils.convertDpToPixel(5f);
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        float x=positions[j];
        float y=positions[j + 1];
        if (!mViewPortHandler.isInBoundsRight(x))         break;
        if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(mChart.getValueFormatter().getFormattedValue(val),x,y - yOffset,mValuePaint);
      }
    }
  }
}",0.0771869639794168
26790,"@Override protected void init(){
  super.init();
  mXAxisRenderer=new XAxisRendererBarChart(mViewPortHandler,mXAxis,mLeftAxisTransformer,this);
}","@Override protected void init(){
  super.init();
  mRenderer=new BarChartRenderer(this,mAnimator,mViewPortHandler);
  mXAxisRenderer=new XAxisRendererBarChart(mViewPortHandler,mXAxis,mLeftAxisTransformer,this);
}",0.8123249299719888
26791,"/** 
 * does all necessary preparations, needed when data is changed or flags that effect the data are changed
 */
@Override public void prepare(){
  if (mDataNotSet)   return;
  calcMinMax(mFixedYValues);
  mAxisRendererLeft.computeAxis(this);
  mAxisRendererRight.computeAxis(this);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}","/** 
 * does all necessary preparations, needed when data is changed or flags that effect the data are changed
 */
@Override public void prepare(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  calcMinMax(mFixedYValues);
  mAxisRendererLeft.computeAxis(this);
  mAxisRendererRight.computeAxis(this);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}",0.8350951374207188
26792,"@Override protected void init(){
  super.init();
  mLeftAxisTransformer=new Transformer(mViewPortHandler);
  mRightAxisTransformer=new Transformer(mViewPortHandler);
  mAxisRendererLeft=new YAxisRenderer(mViewPortHandler,mAxisLeft,mLeftAxisTransformer);
  mAxisRendererRight=new YAxisRenderer(mViewPortHandler,mAxisRight,mRightAxisTransformer);
  mXAxisRenderer=new XAxisRenderer(mViewPortHandler,mXAxis,mLeftAxisTransformer);
  mListener=new BarLineChartTouchListener(this,mViewPortHandler.getMatrixTouch());
  mBorderPaint=new Paint();
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(mGridWidth * 2f);
  mBorderPaint.setStyle(Style.STROKE);
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
}","@Override protected void init(){
  super.init();
  mAxisLeft=new YAxis(AxisDependency.LEFT);
  mAxisRight=new YAxis(AxisDependency.RIGHT);
  mXAxis=new XAxis();
  mLeftAxisTransformer=new Transformer(mViewPortHandler);
  mRightAxisTransformer=new Transformer(mViewPortHandler);
  mAxisRendererLeft=new YAxisRenderer(mViewPortHandler,mAxisLeft,mLeftAxisTransformer);
  mAxisRendererRight=new YAxisRenderer(mViewPortHandler,mAxisRight,mRightAxisTransformer);
  mXAxisRenderer=new XAxisRenderer(mViewPortHandler,mXAxis,mLeftAxisTransformer);
  mListener=new BarLineChartTouchListener(this,mViewPortHandler.getMatrixTouch());
  mBorderPaint=new Paint();
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(mGridWidth * 2f);
  mBorderPaint.setStyle(Style.STROKE);
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
}",0.9347319347319348
26793,"@Override public void notifyDataSetChanged(){
  if (!mFixedYValues) {
    prepare();
    mRightAxisTransformer.prepareMatrixValuePx(this,mDeltaX,mDeltaY);
    mLeftAxisTransformer.prepareMatrixValuePx(this,mDeltaX,mDeltaY);
  }
 else {
    calcMinMax(mFixedYValues);
  }
}","@Override public void notifyDataSetChanged(){
  if (!mFixedYValues) {
    prepare();
    mRightAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaY,mYChartMin);
    mLeftAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaY,mYChartMin);
  }
 else {
    calcMinMax(mFixedYValues);
  }
}",0.5491525423728814
26794,"/** 
 * Sets up all the matrices that will be used for scaling the coordinates to the display. Offset and Value-px.
 */
protected void prepareMatrix(){
  mRightAxisTransformer.prepareMatrixValuePx(this,mDeltaX,mDeltaY);
  mLeftAxisTransformer.prepareMatrixValuePx(this,mDeltaX,mDeltaY);
  mRightAxisTransformer.prepareMatrixOffset(mViewPortHandler,mAxisRight.isInverted());
  mLeftAxisTransformer.prepareMatrixOffset(mViewPortHandler,mAxisLeft.isInverted());
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets up all the matrices that will be used for scaling the coordinates to the display. Offset and Value-px.
 */
protected void prepareMatrix(){
  mRightAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaY,mYChartMin);
  mLeftAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaY,mYChartMin);
  mRightAxisTransformer.prepareMatrixOffset(mViewPortHandler,mAxisRight.isInverted());
  mLeftAxisTransformer.prepareMatrixOffset(mViewPortHandler,mAxisLeft.isInverted());
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
}",0.9423791821561338
26795,"@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  String label=mAxisLeft.getLongestLabel();
  if (mDrawYAxis) {
    if (mAxisLeft.isEnabled()) {
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mYChartMin < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yleft=ylabelwidth;
    }
    if (mAxisRight.isEnabled()) {
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mYChartMin < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yright=ylabelwidth;
    }
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  prepareMatrix();
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mDrawYAxis) {
    if (mAxisLeft.isEnabled()) {
      String label=mAxisLeft.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mYChartMin < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
    }
    if (mAxisRight.isEnabled()) {
      String label=mAxisRight.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mYChartMin < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
    }
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareMatrix();
}",0.9095031173247684
26796,"/** 
 * calculates the modulus for x-labels and grid
 */
protected void calcModulus(){
  float[] values=new float[9];
  mViewPortHandler.getMatrixTouch().getValues(values);
  mXAxis.mXAxisLabelModulus=(int)Math.ceil((mData.getXValCount() * mXAxis.mLabelWidth) / (mViewPortHandler.contentWidth() * values[Matrix.MSCALE_X]));
}","/** 
 * calculates the modulus for x-labels and grid
 */
protected void calcModulus(){
  float[] values=new float[9];
  mViewPortHandler.getMatrixTouch().getValues(values);
  mXAxis.mAxisLabelModulus=(int)Math.ceil((mData.getXValCount() * mXAxis.mLabelWidth) / (mViewPortHandler.contentWidth() * values[Matrix.MSCALE_X]));
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + mXAxis.mAxisLabelModulus + ""String_Node_Str""+ mXAxis.mLabelWidth+ ""String_Node_Str""+ mViewPortHandler.contentWidth());
}",0.787363304981774
26797,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  xl.setDrawGridLines(false);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.getAxisRight().setDrawGridLines(false);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  xl.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setLabelCount(8);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(tf);
  rightAxis.setLabelCount(8);
  mChart.setValueFormatter(new MyValueFormatter());
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.945019404915912
26798,"@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setCenterXLabelText(true);
  xAxis.setPosition(XLabelPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(15f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(15f);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}",0.8625772705658583
26799,"/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private LineData generateDataLine(int cnt){
  ArrayList<Entry> e1=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e1.add(new Entry((int)(Math.random() * 65) + 40,i));
  }
  LineDataSet d1=new LineDataSet(e1,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d1.setLineWidth(3f);
  d1.setCircleSize(5f);
  d1.setHighLightColor(Color.rgb(244,117,117));
  ArrayList<Entry> e2=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e2.add(new Entry(e1.get(i).getVal() - 30,i));
  }
  LineDataSet d2=new LineDataSet(e2,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d2.setLineWidth(3f);
  d2.setCircleSize(5f);
  d2.setHighLightColor(Color.rgb(244,117,117));
  d2.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setCircleColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  ArrayList<LineDataSet> sets=new ArrayList<LineDataSet>();
  sets.add(d1);
  sets.add(d2);
  LineData cd=new LineData(getMonths(),sets);
  return cd;
}","/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private LineData generateDataLine(int cnt){
  ArrayList<Entry> e1=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e1.add(new Entry((int)(Math.random() * 65) + 40,i));
  }
  LineDataSet d1=new LineDataSet(e1,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d1.setLineWidth(3f);
  d1.setCircleSize(5f);
  d1.setHighLightColor(Color.rgb(244,117,117));
  d1.setDrawValues(false);
  ArrayList<Entry> e2=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e2.add(new Entry(e1.get(i).getVal() - 30,i));
  }
  LineDataSet d2=new LineDataSet(e2,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d2.setLineWidth(3f);
  d2.setCircleSize(5f);
  d2.setHighLightColor(Color.rgb(244,117,117));
  d2.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setCircleColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setDrawValues(false);
  ArrayList<LineDataSet> sets=new ArrayList<LineDataSet>();
  sets.add(d1);
  sets.add(d2);
  LineData cd=new LineData(getMonths(),sets);
  return cd;
}",0.9738625363020328
26800,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XAxis xAxis=holder.chart.getXAxis();
  xAxis.setCenterXLabelText(true);
  xAxis.setPosition(XLabelPosition.BOTTOM);
  xAxis.setTypeface(mTf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  leftAxis.setSpaceTop(20f);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setSpaceTop(20f);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}",0.8919585594474593
26801,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_linechart,null);
    holder.chart=(LineChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis yl=holder.chart.getAxisLeft();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData((LineData)mChartData);
  holder.chart.animateX(1000);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_linechart,null);
    holder.chart=(LineChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawGridBackground(false);
  XAxis xl=holder.chart.getXAxis();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  xl.setDrawGridLines(false);
  YAxis leftAxis=holder.chart.getAxisLeft();
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(5);
  YAxis rightAxis=holder.chart.getAxisRight();
  rightAxis.setTypeface(mTf);
  rightAxis.setLabelCount(5);
  rightAxis.setDrawGridLines(false);
  holder.chart.setData((LineData)mChartData);
  holder.chart.animateX(1000);
  return convertView;
}",0.9066232356134636
26802,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_piechart,null);
    holder.chart=(PieChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setHoleRadius(60f);
  holder.chart.setTransparentCircleRadius(65f);
  holder.chart.setCenterText(""String_Node_Str"");
  holder.chart.setCenterTextTypeface(mTf);
  holder.chart.setCenterTextSize(18f);
  holder.chart.setData((PieData)mChartData);
  Legend l=holder.chart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  holder.chart.animateXY(900,900);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_piechart,null);
    holder.chart=(PieChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setHoleRadius(52f);
  holder.chart.setTransparentCircleRadius(57f);
  holder.chart.setCenterText(""String_Node_Str"");
  holder.chart.setCenterTextTypeface(mTf);
  holder.chart.setCenterTextSize(18f);
  holder.chart.setValueTextSize(11f);
  holder.chart.setValueFormatter(new PercentFormatter(holder.chart));
  holder.chart.setData((PieData)mChartData);
  Legend l=holder.chart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  holder.chart.animateXY(900,900);
  return convertView;
}",0.9393617021276596
26803,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setTextColor(Color.WHITE);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XAxis xl=mChart.getXAxis();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YAxis yl=mChart.getAxisLeft();
  yl.setTypeface(tf);
  yl.setTextColor(Color.WHITE);
  yl.setAxisMaxValue(300);
  yl.setAxisMinValue(-100f);
}",0.9833035181872392
26804,"private void prepareValuePxMatrix(){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + mDeltaYLeft + ""String_Node_Str""+ mDeltaYRight);
  mRightAxisTransformer.prepareMatrixValuePx(mDeltaX,mDeltaYRight,mAxisRight.mAxisMinimum);
  mLeftAxisTransformer.prepareMatrixValuePx(mDeltaX,mDeltaYLeft,mAxisLeft.mAxisMinimum);
}","private void prepareValuePxMatrix(){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"" + mAxisLeft.mAxisRange + ""String_Node_Str""+ mAxisRight.mAxisRange);
  mRightAxisTransformer.prepareMatrixValuePx(mDeltaX,mAxisRight.mAxisRange,mAxisRight.mAxisMinimum);
  mLeftAxisTransformer.prepareMatrixValuePx(mDeltaX,mAxisLeft.mAxisRange,mAxisLeft.mAxisMinimum);
}",0.8529411764705882
26805,"@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - minLeft);
  float rightRange=Math.abs(maxRight - minRight);
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=minRight - bottomSpaceRight;
  mDeltaYLeft=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mDeltaYRight=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - minLeft);
  float rightRange=Math.abs(maxRight - minRight);
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.8477157360406091
26806,"/** 
 * Returns the delta-y value (y-value range) of the specified axis.
 * @param axis
 * @return
 */
public float getDeltaY(AxisDependency axis){
  if (axis == AxisDependency.LEFT)   return mDeltaYLeft;
 else   return mDeltaYRight;
}","/** 
 * Returns the delta-y value (y-value range) of the specified axis.
 * @param axis
 * @return
 */
public float getDeltaY(AxisDependency axis){
  if (axis == AxisDependency.LEFT)   return mAxisLeft.mAxisRange;
 else   return mAxisRight.mAxisRange;
}",0.9139344262295082
26807,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
  }
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
  computeAxisValues(yMin,yMax);
}",0.8694690265486725
26808,"/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private LineData generateDataLine(int cnt){
  ArrayList<Entry> e1=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e1.add(new Entry((int)(Math.random() * 65) + 40,i));
  }
  LineDataSet d1=new LineDataSet(e1,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d1.setLineWidth(3f);
  d1.setCircleSize(5f);
  d1.setHighLightColor(Color.rgb(244,117,117));
  d1.setDrawValues(false);
  ArrayList<Entry> e2=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e2.add(new Entry(e1.get(i).getVal() - 30,i));
  }
  LineDataSet d2=new LineDataSet(e2,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d2.setLineWidth(3f);
  d2.setCircleSize(5f);
  d2.setHighLightColor(Color.rgb(244,117,117));
  d2.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setCircleColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setDrawValues(false);
  ArrayList<LineDataSet> sets=new ArrayList<LineDataSet>();
  sets.add(d1);
  sets.add(d2);
  LineData cd=new LineData(getMonths(),sets);
  return cd;
}","/** 
 * generates a random ChartData object with just one DataSet
 * @return
 */
private LineData generateDataLine(int cnt){
  ArrayList<Entry> e1=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e1.add(new Entry((int)(Math.random() * 65) + 40,i));
  }
  LineDataSet d1=new LineDataSet(e1,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d1.setLineWidth(2.5f);
  d1.setCircleSize(4.5f);
  d1.setHighLightColor(Color.rgb(244,117,117));
  d1.setDrawValues(false);
  ArrayList<Entry> e2=new ArrayList<Entry>();
  for (int i=0; i < 12; i++) {
    e2.add(new Entry(e1.get(i).getVal() - 30,i));
  }
  LineDataSet d2=new LineDataSet(e2,""String_Node_Str"" + cnt + ""String_Node_Str"");
  d2.setLineWidth(2.5f);
  d2.setCircleSize(4.5f);
  d2.setHighLightColor(Color.rgb(244,117,117));
  d2.setColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setCircleColor(ColorTemplate.VORDIPLOM_COLORS[0]);
  d2.setDrawValues(false);
  ArrayList<LineDataSet> sets=new ArrayList<LineDataSet>();
  sets.add(d1);
  sets.add(d2);
  LineData cd=new LineData(getMonths(),sets);
  return cd;
}",0.9943609022556392
26809,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHole:
{
    if (mChart.isDrawHoleEnabled())     mChart.setDrawHoleEnabled(false);
 else     mChart.setDrawHoleEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionDrawCenter:
{
  if (mChart.isDrawCenterTextEnabled())   mChart.setDrawCenterText(false);
 else   mChart.setDrawCenterText(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleXVals:
{
mChart.setDrawAxisLabels(!mChart.isDrawAxisLabelsEnabled());
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
case R.id.animateX:
{
mChart.animateX(1800);
break;
}
case R.id.animateY:
{
mChart.animateY(1800);
break;
}
case R.id.animateXY:
{
mChart.animateXY(1800,1800);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHole:
{
    if (mChart.isDrawHoleEnabled())     mChart.setDrawHoleEnabled(false);
 else     mChart.setDrawHoleEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionDrawCenter:
{
  if (mChart.isDrawCenterTextEnabled())   mChart.setDrawCenterText(false);
 else   mChart.setDrawCenterText(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleXVals:
{
mChart.setDrawSliceText(!mChart.isDrawSliceTextEnabled());
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
case R.id.animateX:
{
mChart.animateX(1800);
break;
}
case R.id.animateY:
{
mChart.animateY(1800);
break;
}
case R.id.animateXY:
{
mChart.animateXY(1800,1800);
break;
}
}
return true;
}",0.9842300556586272
26810,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
if (mChart.isDrawXLabelsEnabled()) mChart.setDrawXLabels(false);
 else mChart.setDrawXLabels(true);
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360);
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleValues:
{
      for (      DataSet<?> set : mChart.getData().getDataSets())       set.setDrawValues(!set.isDrawValuesEnabled());
      mChart.invalidate();
      break;
    }
case R.id.actionToggleHighlight:
{
    if (mChart.isHighlightEnabled())     mChart.setHighlightEnabled(false);
 else     mChart.setHighlightEnabled(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleRotate:
{
  if (mChart.isRotationEnabled())   mChart.setRotationEnabled(false);
 else   mChart.setRotationEnabled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleFilled:
{
ArrayList<RadarDataSet> sets=(ArrayList<RadarDataSet>)mChart.getData().getDataSets();
for (RadarDataSet set : sets) {
  if (set.isDrawFilledEnabled())   set.setDrawFilled(false);
 else   set.setDrawFilled(true);
}
mChart.invalidate();
break;
}
case R.id.actionSave:
{
if (mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"")) {
Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
}
 else Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
break;
}
case R.id.actionToggleXLabels:
{
mChart.getXAxis().setEnabled(!mChart.getXAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleYLabels:
{
mChart.getYAxis().setEnabled(!mChart.getYAxis().isEnabled());
mChart.invalidate();
break;
}
case R.id.actionToggleSpin:
{
mChart.spin(2000,mChart.getRotationAngle(),mChart.getRotationAngle() + 360);
break;
}
}
return true;
}",0.9585112873703476
26811,"/** 
 * Returns the position (in pixels) the provided Entry has inside the chart view or null, if the provided Entry is null.
 * @param e
 * @return
 */
public PointF getPosition(Entry e,AxisDependency axis){
  if (e == null)   return null;
  float[] vals=new float[]{e.getXIndex(),e.getVal()};
  if (this instanceof BarChart) {
    BarDataSet set=(BarDataSet)mData.getDataSetForEntry(e);
    if (set != null)     vals[0]+=set.getBarSpace() / 2f;
  }
  if (axis == AxisDependency.LEFT)   mLeftAxisTransformer.pointValuesToPixel(vals);
 else   mRightAxisTransformer.pointValuesToPixel(vals);
  return new PointF(vals[0],vals[1]);
}","/** 
 * Returns the position (in pixels) the provided Entry has inside the chart view or null, if the provided Entry is null.
 * @param e
 * @return
 */
public PointF getPosition(Entry e,AxisDependency axis){
  if (e == null)   return null;
  float[] vals=new float[]{e.getXIndex(),e.getVal()};
  if (this instanceof BarChart) {
    BarDataSet set=(BarDataSet)mData.getDataSetForEntry(e);
    if (set != null)     vals[0]+=set.getBarSpace() / 2f;
  }
  getTransformer(axis).pointValuesToPixel(vals);
  return new PointF(vals[0],vals[1]);
}",0.8964927288280582
26812,"/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=getEntryByDataSetIndex(high.getXIndex(),high.getDataSetIndex());
      mSelectionListener.onValueSelected(e,high.getDataSetIndex());
    }
  }
}","/** 
 * Highlights the value selected by touch gesture. Unlike highlightValues(...), this generates a callback to the OnChartValueSelectedListener.
 * @param highs
 */
public void highlightTouch(Highlight high){
  if (high == null)   mIndicesToHightlight=null;
 else {
    mIndicesToHightlight=new Highlight[]{high};
  }
  invalidate();
  if (mSelectionListener != null) {
    if (!valuesToHighlight())     mSelectionListener.onNothingSelected();
 else {
      Entry e=mData.getEntryForHighlight(high);
      mSelectionListener.onValueSelected(e,high.getDataSetIndex());
    }
  }
}",0.8451882845188284
26813,"@Override protected void onDraw(Canvas canvas){
  if (mDataNotSet) {
    canvas.drawText(mNoDataText,getWidth() / 2,getHeight() / 2,mInfoPaint);
    if (!TextUtils.isEmpty(mNoDataTextDescription)) {
      float textOffset=-mInfoPaint.ascent() + mInfoPaint.descent();
      canvas.drawText(mNoDataTextDescription,getWidth() / 2,(getHeight() / 2) + textOffset,mInfoPaint);
    }
    return;
  }
  if (!mOffsetsCalculated) {
    calculateOffsets();
    mOffsetsCalculated=true;
  }
  if (mDrawBitmap == null || mDrawCanvas == null) {
    mDrawBitmap=Bitmap.createBitmap(getWidth(),getHeight(),Bitmap.Config.ARGB_4444);
    mDrawCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
}","@Override protected void onDraw(Canvas canvas){
  if (mDataNotSet) {
    canvas.drawText(mNoDataText,getWidth() / 2,getHeight() / 2,mInfoPaint);
    if (!TextUtils.isEmpty(mNoDataTextDescription)) {
      float textOffset=-mInfoPaint.ascent() + mInfoPaint.descent();
      canvas.drawText(mNoDataTextDescription,getWidth() / 2,(getHeight() / 2) + textOffset,mInfoPaint);
    }
    return;
  }
  if (!mOffsetsCalculated) {
    calculateOffsets();
    mOffsetsCalculated=true;
  }
  if (mDrawCanvas == null) {
    mDrawCanvas=new Canvas(mDrawBitmap);
  }
  mDrawBitmap.eraseColor(Color.TRANSPARENT);
}",0.9081163859111792
26814,"/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  mData=data;
  notifyDataSetChanged();
  calcFormats(data.getYMin(),data.getYMax());
  Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  notifyDataSetChanged();
  calcFormats(data.getYMin(),data.getYMax());
  Log.i(LOG_TAG,""String_Node_Str"");
}",0.983490566037736
26815,"/** 
 * Clears the chart from all data and refreshes it (by calling invalidate()).
 */
public void clear(){
  mData=null;
  mData=null;
  mDataNotSet=true;
  invalidate();
}","/** 
 * Clears the chart from all data and refreshes it (by calling invalidate()).
 */
public void clear(){
  mData=null;
  mDataNotSet=true;
  invalidate();
}",0.9578313253012049
26816,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mAnimator.getPhaseX()) {
      Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (!mViewPortHandler.isInBounds(pos[0],pos[1]))       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
      }
    }
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mAnimator.getPhaseX()) {
      Entry e=mData.getEntryForHighlight(mIndicesToHightlight[i]);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (!mViewPortHandler.isInBounds(pos[0],pos[1]))       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
      }
    }
  }
}",0.9676044330775788
26817,"@Override public void notifyDataSetChanged(){
  prepare();
  mRightAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaYRight,mAxisRight.mAxisMinimum);
  mLeftAxisTransformer.prepareMatrixValuePx(mViewPortHandler,mDeltaX,mDeltaYLeft,mAxisLeft.mAxisMinimum);
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet) {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
    return;
  }
 else {
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"");
  }
  calcMinMax(false);
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mAxisRendererLeft.computeAxis(minLeft,maxLeft);
  mAxisRendererRight.computeAxis(minRight,maxRight);
  mXAxisRenderer.computeAxis(mData.getXValAverageLength(),mData.getXVals());
  prepareLegend();
  calculateOffsets();
}",0.1357370095440085
26818,"@Override protected void calcMinMax(boolean fixedValues){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mDeltaX=mData.getXVals().size() - 1;
  mDeltaYLeft=Math.abs(maxLeft - minLeft);
  mDeltaYRight=Math.abs(maxRight - minRight);
}","@Override protected void calcMinMax(boolean fixedValues){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  mDeltaX=mData.getXVals().size() - 1;
  mDeltaYLeft=Math.abs(maxLeft - minLeft);
  mDeltaYRight=Math.abs(maxRight - minRight);
  mAxisLeft.mAxisMaximum=maxLeft;
  mAxisRight.mAxisMaximum=maxRight;
  mAxisLeft.mAxisMinimum=minLeft;
  mAxisRight.mAxisMinimum=minRight;
}",0.8507462686567164
26819,"@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mDrawYAxis) {
    if (mAxisLeft.isEnabled()) {
      String label=mAxisLeft.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
    }
    if (mAxisRight.isEnabled()) {
      String label=mAxisRight.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
    }
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareMatrix();
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend && mLegend != null && mLegend.getPosition() != LegendPosition.NONE) {
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(12f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      if (mXAxis.getPosition() == XLabelPosition.TOP)       legendBottom=mLegendLabelPaint.getTextSize() * 3.5f;
 else {
        legendBottom=mLegendLabelPaint.getTextSize() * 2.5f;
      }
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float yleft=0f, yright=0f;
  if (mDrawYAxis) {
    if (mAxisLeft.isEnabled()) {
      String label=mAxisLeft.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererLeft.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yleft=ylabelwidth + mAxisRendererLeft.getXOffset() / 2f;
    }
    if (mAxisRight.isEnabled()) {
      String label=mAxisRight.getLongestLabel();
      float ylabelwidth=Utils.calcTextWidth(mAxisRendererRight.getAxisPaint(),label + (mAxisLeft.mAxisMinimum < 0 ? ""String_Node_Str"" : ""String_Node_Str""));
      yright=ylabelwidth + mAxisRendererRight.getXOffset() / 2f;
    }
  }
  float xtop=0f, xbottom=0f;
  float xlabelheight=Utils.calcTextHeight(mXAxisRenderer.getAxisPaint(),""String_Node_Str"") * 2f;
  if (mDrawXLabels) {
    if (mXAxis.getPosition() == XLabelPosition.BOTTOM) {
      xbottom=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.TOP) {
      xtop=xlabelheight;
    }
 else     if (mXAxis.getPosition() == XLabelPosition.BOTH_SIDED) {
      xbottom=xlabelheight;
      xtop=xlabelheight;
    }
  }
  float min=Utils.convertDpToPixel(11f);
  float offsetBottom=Math.max(min,xbottom + legendBottom);
  float offsetTop=Math.max(min,xtop);
  float offsetLeft=Math.max(min,yleft);
  float offsetRight=Math.max(min,yright + legendRight);
  if (mLegend != null) {
    mLegend.setOffsetTop(offsetTop + min / 3f);
    mLegend.setOffsetLeft(offsetLeft);
  }
  mViewPortHandler.restrainViewPort(offsetLeft,offsetTop,offsetRight,offsetBottom);
  if (mLogEnabled) {
    Log.i(LOG_TAG,""String_Node_Str"" + offsetLeft + ""String_Node_Str""+ offsetTop+ ""String_Node_Str""+ offsetRight+ ""String_Node_Str""+ offsetBottom);
    Log.i(LOG_TAG,""String_Node_Str"" + mViewPortHandler.getContentRect().toString());
  }
  prepareOffsetMatrix();
  prepareValuePxMatrix();
}",0.9944444444444444
26820,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mDrawCanvas=new Canvas(mDrawBitmap);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
  }
  prepare();
  super.onSizeChanged(w,h,oldw,oldh);
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  if (mLogEnabled)   Log.i(LOG_TAG,""String_Node_Str"");
  if (w > 0 && h > 0 && w < 10000 && h < 10000) {
    mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
    mDrawCanvas=new Canvas(mDrawBitmap);
    mViewPortHandler.setChartDimens(w,h);
    if (mLogEnabled)     Log.i(LOG_TAG,""String_Node_Str"" + w + ""String_Node_Str""+ h);
  }
  notifyDataSetChanged();
  super.onSizeChanged(w,h,oldw,oldh);
}",0.9714889123548046
26821,"/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  mData=data;
  prepare();
  calcFormats(data.getYMin(),data.getYMax());
  Log.i(LOG_TAG,""String_Node_Str"");
}","/** 
 * Sets a new data object for the chart. The data object contains all values and information needed for displaying.
 * @param data
 */
public void setData(T data){
  if (data == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return;
  }
  mDataNotSet=false;
  mOffsetsCalculated=false;
  mData=data;
  mData=data;
  notifyDataSetChanged();
  calcFormats(data.getYMin(),data.getYMax());
  Log.i(LOG_TAG,""String_Node_Str"");
}",0.9681978798586572
26822,"@Override public void notifyDataSetChanged(){
  prepare();
}","@Override public void notifyDataSetChanged(){
  if (mDataNotSet)   return;
  calcMinMax(false);
  prepareLegend();
  calculateOffsets();
}",0.6060606060606061
26823,"@Override protected void calculateOffsets(){
  super.calculateOffsets();
  float offset=mData.getGreatestShapeSize() / 2f;
  mViewPortHandler.restrainViewPort(mViewPortHandler.offsetLeft() - offset,mViewPortHandler.offsetTop(),mViewPortHandler.offsetRight() - offset,mViewPortHandler.offsetBottom());
  prepareMatrix();
}","@Override protected void calculateOffsets(){
  super.calculateOffsets();
  float offset=mData.getGreatestShapeSize() / 2f;
  mViewPortHandler.restrainViewPort(mViewPortHandler.offsetLeft() - offset,mViewPortHandler.offsetTop(),mViewPortHandler.offsetRight() - offset,mViewPortHandler.offsetBottom());
  prepareOffsetMatrix();
}",0.9907407407407408
26824,"public void setAxisMinValue(float min){
  mCustomAxisMin=min;
}","/** 
 * Set a custom minimum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetAxisMinValue() to undo this.
 * @param min
 */
public void setAxisMinValue(float min){
  mCustomAxisMin=min;
}",0.39375
26825,"public void resetAxisMaxValue(){
  mCustomAxisMax=Float.NaN;
}","/** 
 * By calling this method, any custom maximum value that has been previously set is reseted, and the calculation is done automatically.
 */
public void resetAxisMaxValue(){
  mCustomAxisMax=Float.NaN;
}",0.4609665427509293
26826,"public void setAxisMaxValue(float max){
  mCustomAxisMax=max;
}","/** 
 * Set a custom maximum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetAxisMaxValue() to undo this.
 * @param max
 */
public void setAxisMaxValue(float max){
  mCustomAxisMax=max;
}",0.39375
26827,"public void resetAxisMinValue(){
  mCustomAxisMin=Float.NaN;
}","/** 
 * By calling this method, any custom minimum value that has been previously set is reseted, and the calculation is done automatically.
 */
public void resetAxisMinValue(){
  mCustomAxisMin=Float.NaN;
}",0.4609665427509293
26828,"@Override public void drawValues(Canvas c){
  if (mChart.getData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    ArrayList<ScatterDataSet> dataSets=mChart.getData().getDataSets();
    for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesLineScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if (j != 0 && !mViewPortHandler.isInBoundsLeft(positions[j - 1]) && !mViewPortHandler.isInBoundsY(positions[j + 1]))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(mChart.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}","@Override public void drawValues(Canvas c){
  if (mChart.getData().getYValCount() < mChart.getMaxVisibleCount() * mViewPortHandler.getScaleX()) {
    ArrayList<ScatterDataSet> dataSets=mChart.getData().getDataSets();
    for (int i=0; i < mChart.getData().getDataSetCount(); i++) {
      ScatterDataSet dataSet=dataSets.get(i);
      if (!dataSet.isDrawValuesEnabled())       continue;
      ArrayList<Entry> entries=dataSet.getYVals();
      float[] positions=mChart.getTransformer(dataSet.getAxisDependency()).generateTransformedValuesLineScatter(entries,mAnimator.getPhaseY());
      float shapeSize=dataSet.getScatterShapeSize();
      for (int j=0; j < positions.length * mAnimator.getPhaseX(); j+=2) {
        if (!mViewPortHandler.isInBoundsRight(positions[j]))         break;
        if (j != 0 && !mViewPortHandler.isInBoundsLeft(positions[j - 1]) && !mViewPortHandler.isInBoundsY(positions[j + 1]))         continue;
        float val=entries.get(j / 2).getVal();
        c.drawText(mChart.getValueFormatter().getFormattedValue(val),positions[j],positions[j + 1] - shapeSize,mValuePaint);
      }
    }
  }
}",0.9733700642791552
26829,"/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
 else {
      if (mYAxis.isStartAtZeroEnabled()) {
        yMin=0;
      }
    }
  }
  mYAxis.mAxisMaximum=yMax;
  mYAxis.mAxisMinimum=yMin;
  computeAxisValues(yMin,yMax);
}","/** 
 * Computes the axis values.
 * @param yMin - the minimum y-value in the data object for this axis
 * @param yMax - the maximum y-value in the data object for this axis
 */
public void computeAxis(float yMin,float yMax){
  if (mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {
    PointD p1=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentTop());
    PointD p2=mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),mViewPortHandler.contentBottom());
    if (!mYAxis.isInverted()) {
      yMin=(float)p2.y;
      yMax=(float)p1.y;
    }
 else {
      if (!mYAxis.isStartAtZeroEnabled())       yMin=(float)Math.min(p1.y,p2.y);
 else       yMin=0;
      yMax=(float)Math.max(p1.y,p2.y);
    }
  }
 else {
    if (!Float.isNaN(mYAxis.getAxisMaxValue())) {
      yMax=mYAxis.getAxisMaxValue();
    }
    if (!Float.isNaN(mYAxis.getAxisMinValue())) {
      yMin=mYAxis.getAxisMinValue();
    }
 else {
      if (mYAxis.isStartAtZeroEnabled()) {
        yMin=0;
      }
    }
  }
  computeAxisValues(yMin,yMax);
}",0.9496402877697842
26830,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c,ValueFormatter valueFormatter){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    if (l.isDrawValueEnabled()) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      String label=valueFormatter.getFormattedValue(l.getLimit());
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c,ValueFormatter valueFormatter){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    if (l.isDrawValueEnabled()) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      String label=valueFormatter.getFormattedValue(l.getLimit());
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.9907735982966644
26831,"/** 
 * Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
 * @param chart
 */
public void prepareMatrixValuePx(ViewPortHandler viewport,float deltaX,float deltaY,float yChartMin){
  float scaleX=(float)((viewport.getChartWidth() - viewport.offsetRight() - viewport.offsetLeft()) / deltaX);
  float scaleY=(float)((viewport.getChartHeight() - viewport.offsetTop() - viewport.offsetBottom()) / deltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(0,-yChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
}","/** 
 * Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
 * @param chart
 */
public void prepareMatrixValuePx(float deltaX,float deltaY,float yChartMin){
  float scaleX=(float)((mViewPortHandler.getChartWidth() - mViewPortHandler.offsetRight() - mViewPortHandler.offsetLeft()) / deltaX);
  float scaleY=(float)((mViewPortHandler.getChartHeight() - mViewPortHandler.offsetTop() - mViewPortHandler.offsetBottom()) / deltaY);
  mMatrixValueToPx.reset();
  mMatrixValueToPx.postTranslate(0,-yChartMin);
  mMatrixValueToPx.postScale(scaleX,-scaleY);
}",0.8896265560165975
26832,"/** 
 * Prepares the matrix that contains all offsets.
 * @param chart
 */
public void prepareMatrixOffset(ViewPortHandler viewport,boolean inverted){
  mMatrixOffset.reset();
  if (!inverted)   mMatrixOffset.postTranslate(viewport.offsetLeft(),viewport.getChartHeight() - viewport.offsetBottom());
 else {
    mMatrixOffset.setTranslate(viewport.offsetLeft(),-viewport.offsetTop());
    mMatrixOffset.postScale(1.0f,-1.0f);
  }
}","/** 
 * Prepares the matrix that contains all offsets.
 * @param chart
 */
public void prepareMatrixOffset(boolean inverted){
  mMatrixOffset.reset();
  if (!inverted)   mMatrixOffset.postTranslate(mViewPortHandler.offsetLeft(),mViewPortHandler.getChartHeight() - mViewPortHandler.offsetBottom());
 else {
    mMatrixOffset.setTranslate(mViewPortHandler.offsetLeft(),-mViewPortHandler.offsetTop());
    mMatrixOffset.postScale(1.0f,-1.0f);
  }
}",0.656
26833,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xl=mChart.getXAxis();
  xl.setPosition(XAxisPosition.BOTTOM);
  xl.setTypeface(tf);
  xl.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setLabelCount(8);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(tf);
  rightAxis.setLabelCount(8);
  mChart.setValueFormatter(new MyValueFormatter());
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawGridBackground(false);
  mChart.setValueTextSize(10f);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XAxis xAxis=mChart.getXAxis();
  xAxis.setPosition(XAxisPosition.BOTTOM);
  xAxis.setTypeface(tf);
  xAxis.setDrawGridLines(false);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.setTypeface(tf);
  leftAxis.setLabelCount(8);
  YAxis rightAxis=mChart.getAxisRight();
  rightAxis.setDrawGridLines(false);
  rightAxis.setTypeface(tf);
  rightAxis.setLabelCount(8);
  mChart.setValueFormatter(new MyValueFormatter());
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9936183790682832
26834,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f,""String_Node_Str"");
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  ll1.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll1.setTextSize(10f);
  LimitLine ll2=new LimitLine(-30f,""String_Node_Str"");
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  ll2.setLabelPosition(LimitLabelPosition.POS_RIGHT);
  ll2.setTextSize(10f);
  YAxis leftAxis=mChart.getAxisLeft();
  leftAxis.addLimitLine(ll1);
  leftAxis.addLimitLine(ll2);
  leftAxis.setAxisMaxValue(220f);
  leftAxis.setAxisMinValue(-50f);
  leftAxis.setStartAtZero(false);
  mChart.getAxisRight().setEnabled(false);
  mChart.setData(data);
}",0.987977369165488
26835,"/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + xOffset;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(1f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}","/** 
 * Draws the LimitLines associated with this axis to the screen.
 * @param c
 */
public void renderLimitLines(Canvas c){
  ArrayList<LimitLine> limitLines=mYAxis.getLimitLines();
  if (limitLines == null || limitLines.size() <= 0)   return;
  float[] pts=new float[4];
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[1]=l.getLimit();
    pts[3]=l.getLimit();
    mTrans.pointValuesToPixel(pts);
    pts[0]=0;
    pts[2]=mViewPortHandler.getChartWidth();
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    c.drawLines(pts,mLimitLinePaint);
    String label=l.getLabel();
    if (label != null && !label.equals(""String_Node_Str"")) {
      float xOffset=Utils.convertDpToPixel(4f);
      float yOffset=l.getLineWidth() + Utils.calcTextHeight(mLimitLinePaint,label) / 2f;
      mLimitLinePaint.setPathEffect(null);
      mLimitLinePaint.setColor(l.getTextColor());
      mLimitLinePaint.setStrokeWidth(0.5f);
      mLimitLinePaint.setTextSize(l.getTextSize());
      if (l.getLabelPosition() == LimitLabelPosition.POS_RIGHT) {
        mLimitLinePaint.setTextAlign(Align.RIGHT);
        c.drawText(label,mViewPortHandler.contentRight() - xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
 else {
        mLimitLinePaint.setTextAlign(Align.LEFT);
        c.drawText(label,mViewPortHandler.offsetLeft() + xOffset,pts[1] - yOffset,mLimitLinePaint);
      }
    }
  }
}",0.980980980980981
26836,"private LineDataSet createSet(){
  LineDataSet set=new LineDataSet(null,""String_Node_Str"");
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  set.setColor(Color.rgb(240,99,99));
  set.setCircleColor(Color.rgb(240,99,99));
  set.setHighLightColor(Color.rgb(190,190,190));
  return set;
}","private LineDataSet createSet(){
  LineDataSet set=new LineDataSet(null,""String_Node_Str"");
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  set.setColor(Color.rgb(240,99,99));
  set.setCircleColor(Color.rgb(240,99,99));
  set.setHighLightColor(Color.rgb(190,190,190));
  set.setAxisDependency(AxisDependency.LEFT);
  return set;
}",0.926751592356688
26837,"private LineData getData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float val=(float)(Math.random() * range) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setLineWidth(1.75f);
  set1.setCircleSize(3f);
  set1.setColor(Color.WHITE);
  set1.setCircleColor(Color.WHITE);
  set1.setHighLightColor(Color.WHITE);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  return data;
}","private LineData getData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float val=(float)(Math.random() * range) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setLineWidth(1.75f);
  set1.setCircleSize(3f);
  set1.setColor(Color.WHITE);
  set1.setCircleColor(Color.WHITE);
  set1.setHighLightColor(Color.WHITE);
  set1.setDrawValues(false);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  return data;
}",0.9799307958477508
26838,"private void setupChart(LineChart chart,LineData data,int color){
  chart.setDrawBorder(false);
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setGridWidth(1.25f);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setValueTypeface(mTf);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  YAxis y=chart.getAxisLeft();
  y.setTextColor(Color.WHITE);
  y.setTypeface(mTf);
  y.setLabelCount(4);
  XAxis x=chart.getXAxis();
  x.setTextColor(Color.WHITE);
  x.setTypeface(mTf);
  x.setDrawGridLines(false);
  chart.animateX(2500);
}","private void setupChart(LineChart chart,LineData data,int color){
  chart.setDrawBorder(false);
  chart.setDescription(""String_Node_Str"");
  chart.setNoDataTextDescription(""String_Node_Str"");
  chart.setDrawGridBackground(false);
  chart.setGridWidth(1.25f);
  chart.setTouchEnabled(true);
  chart.setDragEnabled(true);
  chart.setScaleEnabled(true);
  chart.setPinchZoom(false);
  chart.setBackgroundColor(color);
  chart.setValueTypeface(mTf);
  chart.setData(data);
  Legend l=chart.getLegend();
  l.setForm(LegendForm.CIRCLE);
  l.setFormSize(6f);
  l.setTextColor(Color.WHITE);
  l.setTypeface(mTf);
  YAxis leftAxis=chart.getAxisLeft();
  leftAxis.setTextColor(Color.WHITE);
  leftAxis.setTypeface(mTf);
  leftAxis.setLabelCount(4);
  leftAxis.setDrawGridLines(false);
  chart.getAxisRight().setEnabled(false);
  XAxis x=chart.getXAxis();
  x.setTextColor(Color.WHITE);
  x.setTypeface(mTf);
  x.setDrawGridLines(false);
  chart.animateX(2500);
}",0.9365962180200222
26839,"@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}","@Override protected void calcMinMax(){
  float minLeft=mData.getYMin(AxisDependency.LEFT);
  float maxLeft=mData.getYMax(AxisDependency.LEFT);
  float minRight=mData.getYMin(AxisDependency.RIGHT);
  float maxRight=mData.getYMax(AxisDependency.RIGHT);
  float leftRange=Math.abs(maxLeft - (mAxisLeft.isStartAtZeroEnabled() ? 0 : minLeft));
  float rightRange=Math.abs(maxRight - (mAxisRight.isStartAtZeroEnabled() ? 0 : minRight));
  float topSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceTop();
  float topSpaceRight=rightRange / 100f * mAxisRight.getSpaceTop();
  float bottomSpaceLeft=leftRange / 100f * mAxisLeft.getSpaceBottom();
  float bottomSpaceRight=rightRange / 100f * mAxisRight.getSpaceBottom();
  Log.i(LOG_TAG,""String_Node_Str"" + minLeft + ""String_Node_Str""+ maxLeft);
  mDeltaX=mData.getXVals().size() - 1;
  mAxisLeft.mAxisMaximum=!Float.isNaN(mAxisLeft.getAxisMaxValue()) ? mAxisLeft.getAxisMaxValue() : maxLeft + topSpaceLeft;
  mAxisRight.mAxisMaximum=!Float.isNaN(mAxisRight.getAxisMaxValue()) ? mAxisRight.getAxisMaxValue() : maxRight + topSpaceRight;
  mAxisLeft.mAxisMinimum=!Float.isNaN(mAxisLeft.getAxisMinValue()) ? mAxisLeft.getAxisMinValue() : minLeft - bottomSpaceLeft;
  mAxisRight.mAxisMinimum=!Float.isNaN(mAxisRight.getAxisMinValue()) ? mAxisRight.getAxisMinValue() : minRight - bottomSpaceRight;
  if (mAxisLeft.isStartAtZeroEnabled())   mAxisLeft.mAxisMinimum=0f;
  if (mAxisRight.isStartAtZeroEnabled())   mAxisRight.mAxisMinimum=0f;
  mAxisLeft.mAxisRange=Math.abs(mAxisLeft.mAxisMaximum - mAxisLeft.mAxisMinimum);
  mAxisRight.mAxisRange=Math.abs(mAxisRight.mAxisMaximum - mAxisRight.mAxisMinimum);
}",0.9765844520761786
26840,"/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param e
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  float val=e.getVal();
  mYValCount+=1;
  mYValueSum+=val;
  if (mYMax < val)   mYMax=val;
  if (mYMin > val)   mYMin=val;
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  if (mDataSets.size() > dataSetIndex) {
    T set=mDataSets.get(dataSetIndex);
    if (set != null) {
      set.addEntry(e);
    }
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
 * @param e
 * @param dataSetIndex
 */
public void addEntry(Entry e,int dataSetIndex){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {
    float val=e.getVal();
    mYValCount+=1;
    mYValueSum+=val;
    if (mYMax < val)     mYMax=val;
    if (mYMin > val)     mYMin=val;
    if (mDataSets == null)     mDataSets=new ArrayList<T>();
    T set=mDataSets.get(dataSetIndex);
    if (set != null) {
      if (set.getAxisDependency() == AxisDependency.LEFT) {
        if (mLeftAxisMax < e.getVal())         mLeftAxisMax=e.getVal();
        if (mLeftAxisMin > e.getVal())         mLeftAxisMin=e.getVal();
      }
 else {
        if (mRightAxisMax < e.getVal())         mRightAxisMax=e.getVal();
        if (mRightAxisMin > e.getVal())         mRightAxisMin=e.getVal();
      }
      set.addEntry(e);
    }
  }
 else {
    Log.e(""String_Node_Str"",""String_Node_Str"");
  }
}",0.6069651741293532
26841,"/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  mDataSets.add(d);
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mYMax < d.getYMax())   mYMax=d.getYMax();
  if (mYMin > d.getYMin())   mYMin=d.getYMin();
}","/** 
 * Adds a DataSet dynamically.
 * @param d
 */
public void addDataSet(T d){
  if (mDataSets == null)   mDataSets=new ArrayList<T>();
  mDataSets.add(d);
  mYValCount+=d.getEntryCount();
  mYValueSum+=d.getYValueSum();
  if (mYMax < d.getYMax())   mYMax=d.getYMax();
  if (mYMin > d.getYMin())   mYMin=d.getYMin();
  if (d.getAxisDependency() == AxisDependency.LEFT) {
    if (mLeftAxisMax < d.getYMax())     mLeftAxisMax=d.getYMax();
    if (mLeftAxisMin > d.getYMin())     mLeftAxisMin=d.getYMin();
  }
 else {
    if (mRightAxisMax < d.getYMax())     mRightAxisMax=d.getYMax();
    if (mRightAxisMin > d.getYMin())     mRightAxisMin=d.getYMin();
  }
}",0.65439672801636
26842,"public void setAxisDependency(AxisDependency dependency){
  mAxisDependency=dependency;
}","/** 
 * Set the y-axis this DataSet should be plotted against (either LEFT or RIGHT). Default: LEFT
 * @param dependency
 */
public void setAxisDependency(AxisDependency dependency){
  mAxisDependency=dependency;
}",0.5874587458745875
26843,"public AxisDependency getAxisDependency(){
  return mAxisDependency;
}","/** 
 * Returns the axis this DataSet should be plotted against.
 * @return
 */
public AxisDependency getAxisDependency(){
  return mAxisDependency;
}",0.6363636363636364
26844,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(false);
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XLabels xl=mChart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setFormatter(new LargeValueFormatter());
  mChart.setValueTypeface(tf);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(false);
  mChart.setPinchZoom(false);
  mChart.setValueFormatter(new LargeValueFormatter());
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART_INSIDE);
  l.setTypeface(tf);
  XLabels xl=mChart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setFormatter(new LargeValueFormatter());
  mChart.setValueTypeface(tf);
}",0.9768998995647808
26845,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.97623148467103
26846,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartGestureListener(this);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartGestureListener(this);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}",0.977235235895744
26847,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XLabels xl=mChart.getXLabels();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setTextColor(Color.WHITE);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setValueTextColor(Color.WHITE);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setScaleEnabled(true);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setPinchZoom(true);
  mChart.setBackgroundColor(Color.GRAY);
  setData(45,100);
  mChart.animateX(2500);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  l.setTypeface(tf);
  l.setTextColor(Color.WHITE);
  XLabels xl=mChart.getXLabels();
  xl.setTypeface(tf);
  xl.setTextColor(Color.WHITE);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setTextColor(Color.WHITE);
}",0.9884213499011578
26848,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setDescription(""String_Node_Str"");
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setWebLineWidth(1.5f);
  mChart.setWebLineWidthInner(0.75f);
  mChart.setWebAlpha(100);
  mChart.setDrawYValues(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  setData();
  XLabels xl=mChart.getXLabels();
  xl.setTypeface(tf);
  xl.setTextSize(9f);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(5);
  yl.setTextSize(9f);
  yl.setDrawUnitsInYLabel(true);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setDescription(""String_Node_Str"");
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawUnitsInChart(true);
  mChart.setWebLineWidth(1.5f);
  mChart.setWebLineWidthInner(0.75f);
  mChart.setWebAlpha(100);
  mChart.setDrawYValues(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  setData();
  XLabels xl=mChart.getXLabels();
  xl.setTypeface(tf);
  xl.setTextSize(9f);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(5);
  yl.setTextSize(9f);
  yl.setDrawUnitsInYLabel(true);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9702970297029704
26849,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YLabels labels=mChart.getYLabels();
  labels.setTypeface(tf);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_bar,container,false);
  mChart=new BarChart(getActivity());
  mChart.setDescription(""String_Node_Str"");
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawBarShadow(false);
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  mChart.setData(generateBarData(1,20000,12));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  YLabels labels=mChart.getYLabels();
  labels.setTypeface(tf);
  FrameLayout parent=(FrameLayout)v.findViewById(R.id.parentLayout);
  parent.addView(mChart);
  return v;
}",0.9669381887877336
26850,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_scatter,container,false);
  mChart=(ScatterChart)v.findViewById(R.id.scatterChart1);
  mChart.setDrawYValues(false);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  YLabels labels=mChart.getYLabels();
  labels.setTypeface(tf);
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setData(generateScatterData(3,10000,150));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.frag_simple_scatter,container,false);
  mChart=(ScatterChart)v.findViewById(R.id.scatterChart1);
  mChart.setDrawYValues(false);
  mChart.setDescription(""String_Node_Str"");
  Typeface tf=Typeface.createFromAsset(getActivity().getAssets(),""String_Node_Str"");
  YLabels labels=mChart.getYLabels();
  labels.setTypeface(tf);
  MyMarkerView mv=new MyMarkerView(getActivity(),R.layout.custom_marker_view);
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  mChart.setDrawBorder(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawXLabels(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setData(generateScatterData(3,10000,150));
  Legend l=mChart.getLegend();
  l.setTypeface(tf);
  return v;
}",0.9634727368978296
26851,"/** 
 * set a description text that appears in the bottom right corner of the chart, size = Y-legend text size
 * @param desc
 */
public void setDescription(String desc){
  this.mDescription=desc;
}","/** 
 * set a description text that appears in the bottom right corner of the chart, size = Y-legend text size
 * @param desc
 */
public void setDescription(String desc){
  if (desc == null)   desc=""String_Node_Str"";
  this.mDescription=desc;
}",0.8959276018099548
26852,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX) {
      Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (pos[0] < mOffsetLeft || pos[0] > getWidth() - mOffsetRight || pos[1] < mOffsetTop || pos[1] > getHeight() - mOffsetBottom)       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
    }
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX) {
      Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      if (pos[0] < mOffsetLeft || pos[0] > getWidth() - mOffsetRight || pos[1] < mOffsetTop || pos[1] > getHeight() - mOffsetBottom)       continue;
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.measure(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED));
      mMarkerView.layout(0,0,mMarkerView.getMeasuredWidth(),mMarkerView.getMeasuredHeight());
      if (pos[1] - mMarkerView.getHeight() <= 0) {
        float y=mMarkerView.getHeight() - pos[1];
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1] + y);
      }
 else {
        mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
      }
    }
  }
}",0.9167397020157756
26853,"/** 
 * Set the hole in the center of the PieChart transparent. Thank you, code provided by:
 * @link https://github.com/wogg
 * @param enable
 */
public void setHoleColorTransparent(boolean enable){
  if (enable) {
    mHolePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));
  }
 else {
    mHolePaint.setXfermode(null);
  }
}","/** 
 * Set the hole in the center of the PieChart transparent. Thank you, code provided by:
 * @link https://github.com/tbarthel-fr
 * @param enable
 */
public void setHoleColorTransparent(boolean enable){
  if (enable) {
    mHolePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));
  }
 else {
    mHolePaint.setXfermode(null);
  }
}",0.9784172661870504
26854,"/** 
 * returns the x-offset that is set for the MarkerView
 * @return
 */
public float getXOffset(){
  return mXOffset;
}","/** 
 * Use this to return the desired offset you wish the MarkerView to have on the x-axis. By returning -(getWidth() / 2) you will center the MarkerView horizontally.
 * @return
 */
public abstract int getXOffset();",0.4070796460176991
26855,"/** 
 * Draws the MarkerView on the given position on the screen with the given Canvas object.
 * @param canvas
 * @param posx
 * @param posy
 */
public void draw(Canvas canvas,float posx,float posy){
  posx+=mXOffset;
  posy+=mYOffset;
  canvas.translate(posx,posy);
  draw(canvas);
  canvas.translate(-posx,-posy);
}","/** 
 * Draws the MarkerView on the given position on the screen with the given Canvas object.
 * @param canvas
 * @param posx
 * @param posy
 */
public void draw(Canvas canvas,float posx,float posy){
  posx+=getXOffset();
  posy+=getYOffset();
  canvas.translate(posx,posy);
  draw(canvas);
  canvas.translate(-posx,-posy);
}",0.9813664596273292
26856,"/** 
 * returns the y-offset that is set for the MarkerView
 * @return
 */
public float getYOffset(){
  return mYOffset;
}","/** 
 * Use this to return the desired position offset you wish the MarkerView to have on the y-axis. By returning -getHeight() you will cause the MarkerView to be above the selected value.
 * @return
 */
public abstract int getYOffset();",0.3777777777777777
26857,"/** 
 * sets the size of the description text in pixels, min 7f, max 14f
 * @param size
 */
public void setDescriptionTextSize(float size){
  if (size > 14f)   size=14f;
  if (size < 7f)   size=7f;
  mInfoPaint.setTextSize(Utils.convertDpToPixel(size));
}","/** 
 * sets the size of the description text in pixels, min 6f, max 16f
 * @param size
 */
public void setDescriptionTextSize(float size){
  if (size > 16f)   size=16f;
  if (size < 6f)   size=6f;
  mDescPaint.setTextSize(Utils.convertDpToPixel(size));
}",0.9607843137254902
26858,"/** 
 * Returns the DataSet object with the given label. Search can be case sensitive or not. IMPORTANT: This method does calculations at runtime. Use with care in performance critical situations.
 * @param label
 * @param ignorecase
 * @return
 */
public T getDataSetByLabel(String label,boolean ignorecase){
  int index=getDataSetIndexByLabel(mDataSets,label,ignorecase);
  if (index <= 0 || index >= mDataSets.size())   return null;
 else   return mDataSets.get(index);
}","/** 
 * Returns the DataSet object with the given label. Search can be case sensitive or not. IMPORTANT: This method does calculations at runtime. Use with care in performance critical situations.
 * @param label
 * @param ignorecase
 * @return
 */
public T getDataSetByLabel(String label,boolean ignorecase){
  int index=getDataSetIndexByLabel(mDataSets,label,ignorecase);
  if (index < 0 || index >= mDataSets.size())   return null;
 else   return mDataSets.get(index);
}",0.9989440337909188
26859,"/** 
 * Sets the offsets from the border of the view to the actual chart in every direction manually. Provide density pixels -> they are then rendered to pixels inside the chart
 * @param left
 * @param right
 * @param top
 * @param bottom
 */
public void setOffsets(float left,float top,float right,float bottom){
  mOffsetBottom=Utils.convertDpToPixel(bottom);
  mOffsetLeft=Utils.convertDpToPixel(left);
  mOffsetRight=Utils.convertDpToPixel(right);
  mOffsetTop=Utils.convertDpToPixel(top);
}","/** 
 * Sets the offsets from the border of the view to the actual chart in every direction manually. This method needs to be recalled everytime a new data object is set for the chart. Provide density pixels -> they are then rendered to pixels inside the chart.
 * @param left
 * @param right
 * @param top
 * @param bottom
 */
public void setOffsets(float left,float top,float right,float bottom){
  mOffsetBottom=Utils.convertDpToPixel(bottom);
  mOffsetLeft=Utils.convertDpToPixel(left);
  mOffsetRight=Utils.convertDpToPixel(right);
  mOffsetTop=Utils.convertDpToPixel(top);
  mTrans.prepareMatrixValuePx(this);
  mTrans.prepareMatrixOffset(this);
  prepareContentRect();
}",0.8456947996589941
26860,"/** 
 * Returns the center of the chart taking offsets under consideration. (returns the center of the content rectangle)
 * @return
 */
public PointF getCenterOffsets(){
  return new PointF(mContentRect.centerX(),mContentRect.centerY());
}","/** 
 * Returns the center of the chart taking offsets under consideration. (returns the center of the content rectangle)
 * @return
 */
@Override public PointF getCenterOffsets(){
  return new PointF(mContentRect.centerX(),mContentRect.centerY());
}",0.979591836734694
26861,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor());
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      if (dataSet.getColors() == null || dataSet.getColors().size() > 1) {
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mRenderPaint.setColor(dataSet.getColor(j / 2));
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
 else {
        mRenderPaint.setColor(dataSet.getColor());
        Path line=generateLinePath(entries);
        transformPath(line);
        mDrawCanvas.drawPath(line,mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
    mRenderPaint.setPathEffect(null);
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    if (entries.size() < 1)     continue;
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor());
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      if (dataSet.getColors() == null || dataSet.getColors().size() > 1) {
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mRenderPaint.setColor(dataSet.getColor(j / 2));
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
 else {
        mRenderPaint.setColor(dataSet.getColor());
        Path line=generateLinePath(entries);
        transformPath(line);
        mDrawCanvas.drawPath(line,mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
    mRenderPaint.setPathEffect(null);
  }
}",0.994328922495274
26862,"/** 
 * calculates the average length (in characters) across all x-value strings
 */
private void calcXValAverageLength(){
  if (mXVals.size() == 0) {
    mXValAverageLength=1;
    return;
  }
  float sum=0f;
  for (int i=0; i < mXVals.size(); i++) {
    sum+=mXVals.get(i).length();
  }
  mXValAverageLength=sum / (float)mXVals.size();
}","/** 
 * calculates the average length (in characters) across all x-value strings
 */
private void calcXValAverageLength(){
  if (mXVals.size() == 0) {
    mXValAverageLength=1;
    return;
  }
  float sum=1f;
  for (int i=0; i < mXVals.size(); i++) {
    sum+=mXVals.get(i).length();
  }
  mXValAverageLength=sum / (float)mXVals.size();
}",0.9970414201183432
26863,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  yl.setPosition(YLabelPosition.BOTH_SIDED);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDrawValueAboveBar(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  yl.setPosition(YLabelPosition.BOTH_SIDED);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9883830455259026
26864,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) - 50;
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}",0.9959514170040484
26865,"@Override protected void drawValues(){
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<BarDataSet> dataSets=((BarData)mCurrentData).getDataSets();
    float offset=0f;
    if (mDrawValueAboveBar)     offset=-Utils.convertDpToPixel(5);
 else     offset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=generateTransformedValuesBarChart(entries,i);
      if (!mDrawValuesForWholeStack) {
        for (int j=0; j < valuePoints.length * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(mValueFormatter.getFormattedValue(val),valuePoints[j],valuePoints[j + 1] + offset);
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(mValueFormatter.getFormattedValue(e.getVal()),valuePoints[j],valuePoints[j + 1] + offset);
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mPhaseY;
              cnt++;
            }
            transformPointArray(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(mValueFormatter.getFormattedValue(vals[k / 2]),valuePoints[j],transformed[k + 1] + offset);
            }
          }
        }
      }
    }
  }
}","@Override protected void drawValues(){
  if (mDrawYValues && mCurrentData.getYValCount() < mMaxVisibleCount * mScaleX) {
    ArrayList<BarDataSet> dataSets=((BarData)mCurrentData).getDataSets();
    float posOffset=0f;
    float negOffset=0f;
    if (mDrawValueAboveBar) {
      posOffset=-Utils.convertDpToPixel(5);
      negOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
    }
 else {
      posOffset=Utils.calcTextHeight(mValuePaint,""String_Node_Str"") * 1.5f;
      negOffset=-Utils.convertDpToPixel(5);
    }
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      BarDataSet dataSet=dataSets.get(i);
      ArrayList<BarEntry> entries=dataSet.getYVals();
      float[] valuePoints=generateTransformedValuesBarChart(entries,i);
      if (!mDrawValuesForWholeStack) {
        for (int j=0; j < valuePoints.length * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          float val=entries.get(j / 2).getVal();
          drawValue(val,valuePoints[j],valuePoints[j + 1] + (val >= 0 ? posOffset : negOffset));
        }
      }
 else {
        for (int j=0; j < (valuePoints.length - 1) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (isOffContentLeft(valuePoints[j]) || isOffContentTop(valuePoints[j + 1]) || isOffContentBottom(valuePoints[j + 1]))           continue;
          BarEntry e=entries.get(j / 2);
          float[] vals=e.getVals();
          if (vals == null) {
            drawValue(e.getVal(),valuePoints[j],valuePoints[j + 1] + (e.getVal() >= 0 ? posOffset : negOffset));
          }
 else {
            float[] transformed=new float[vals.length * 2];
            int cnt=0;
            float add=e.getVal();
            for (int k=0; k < transformed.length; k+=2) {
              add-=vals[cnt];
              transformed[k + 1]=(vals[cnt] + add) * mPhaseY;
              cnt++;
            }
            transformPointArray(transformed);
            for (int k=0; k < transformed.length; k+=2) {
              drawValue(vals[k / 2],valuePoints[j],transformed[k + 1] + (vals[k / 2] >= 0 ? posOffset : negOffset));
            }
          }
        }
      }
    }
  }
}",0.898084965881576
26866,"/** 
 * Draws a value at the specified x and y position.
 * @param value
 * @param xPos
 * @param yPos
 */
private void drawValue(String val,float xPos,float yPos){
  if (mDrawUnitInChart) {
    mDrawCanvas.drawText(val + mUnit,xPos,yPos,mValuePaint);
  }
 else {
    mDrawCanvas.drawText(val,xPos,yPos,mValuePaint);
  }
}","/** 
 * Draws a value at the specified x and y position.
 * @param value
 * @param xPos
 * @param yPos
 */
private void drawValue(float val,float xPos,float yPos){
  String value=mValueFormatter.getFormattedValue(val);
  if (mDrawUnitInChart) {
    mDrawCanvas.drawText(value + mUnit,xPos,yPos,mValuePaint);
  }
 else {
    mDrawCanvas.drawText(value,xPos,yPos,mValuePaint);
  }
}",0.8490028490028491
26867,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor());
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      if (dataSet.getColors() == null || dataSet.getColors().size() > 1) {
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mRenderPaint.setColor(dataSet.getColor(j / 2));
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
 else {
        mRenderPaint.setColor(dataSet.getColor());
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
    mRenderPaint.setPathEffect(null);
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor());
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      if (dataSet.getColors() == null || dataSet.getColors().size() > 1) {
        float[] valuePoints=generateTransformedValuesLineScatter(entries);
        for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
          if (isOffContentRight(valuePoints[j]))           break;
          if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))           continue;
          mRenderPaint.setColor(dataSet.getColor(j / 2));
          mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
        }
      }
 else {
        mRenderPaint.setColor(dataSet.getColor());
        Path line=generateLinePath(entries);
        transformPath(line);
        mDrawCanvas.drawPath(line,mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
    mRenderPaint.setPathEffect(null);
  }
}",0.9358129923802144
26868,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) - 50;
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}",0.9959514170040484
26869,"public MyMarkerView(Context context,int layoutResource){
  super(context,layoutResource);
  tvContent=(TextView)findViewById(R.id.tvContent);
}","public MyMarkerView(Context context,int layoutResource){
  super(context,layoutResource);
  tvContent=(TextView)findViewById(R.id.tvContent);
  setOnClickListener(this);
}",0.910828025477707
26870,"@Override public boolean onTouchEvent(MotionEvent event){
  if (mListener == null || mDataNotSet)   return false;
  if (!mTouchEnabled)   return false;
 else   return mListener.onTouch(this,event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  super.onTouchEvent(event);
  if (mListener == null || mDataNotSet)   return false;
  if (!mTouchEnabled)   return false;
 else   return mListener.onTouch(this,event);
}",0.9320843091334896
26871,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  mDrawBitmap=Bitmap.createBitmap(w,h,Bitmap.Config.ARGB_4444);
  mDrawCanvas=new Canvas(mDrawBitmap);
  prepareContentRect();
  prepare();
  super.onSizeChanged(w,h,oldw,oldh);
}",0.6111111111111112
26872,"@Override protected void calculateOffsets(){
  if (mDrawLegend) {
    float legendRight=0f, legendBottom=0f;
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 4f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
    float min=Utils.convertDpToPixel(11f);
    mLegend.setOffsetTop(min);
    mLegend.setOffsetLeft(min);
    mOffsetTop=min;
    mOffsetRight=Math.max(min,legendRight);
    mOffsetBottom=Math.max(min,legendBottom);
    applyCalculatedOffsets();
  }
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend) {
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(13f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 4f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float min=Utils.convertDpToPixel(11f);
  mLegend.setOffsetTop(min);
  mLegend.setOffsetLeft(min);
  mOffsetLeft=min;
  mOffsetTop=min;
  mOffsetRight=Math.max(min,legendRight);
  mOffsetBottom=Math.max(min,legendBottom);
  applyCalculatedOffsets();
}",0.920306168392616
26873,"@Override protected void calculateOffsets(){
  if (mDrawLegend) {
    float legendRight=0f, legendBottom=0f;
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(8f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing+ mXLabels.mLabelWidth;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 5.5f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
    float min=Utils.convertDpToPixel(11f);
    mOffsetBottom=Math.max(mXLabels.mLabelWidth,min);
    mOffsetTop=Math.max(mXLabels.mLabelWidth,min);
    mOffsetRight=Math.max(legendRight,min);
    mOffsetLeft=Math.max(mXLabels.mLabelWidth,min);
    mOffsetBottom=Math.max(mOffsetBottom,legendBottom);
    mOffsetRight=Math.max(mOffsetRight,legendRight / 3f * 2f);
    mLegend.setOffsetTop(min);
    mLegend.setOffsetLeft(min);
    applyCalculatedOffsets();
  }
}","@Override protected void calculateOffsets(){
  float legendRight=0f, legendBottom=0f;
  if (mDrawLegend) {
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART || mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART_CENTER) {
      float spacing=Utils.convertDpToPixel(8f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing+ mXLabels.mLabelWidth;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 5.5f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
  }
  float min=Utils.convertDpToPixel(11f);
  mOffsetBottom=Math.max(mXLabels.mLabelWidth,min);
  mOffsetTop=Math.max(mXLabels.mLabelWidth,min);
  mOffsetRight=Math.max(legendRight,min);
  mOffsetLeft=Math.max(mXLabels.mLabelWidth,min);
  mOffsetBottom=Math.max(mOffsetBottom,legendBottom);
  mOffsetRight=Math.max(mOffsetRight,legendRight / 3f * 2f);
  mLegend.setOffsetTop(min);
  mLegend.setOffsetLeft(min);
  applyCalculatedOffsets();
}",0.9383921863260706
26874,"@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h == null || h.equalTo(mLastHighlighted)) {
    mChart.highlightTouch(null);
    mLastHighlighted=null;
  }
 else {
    mLastHighlighted=h;
    mChart.highlightTouch(h);
  }
  return true;
}","@Override public boolean onSingleTapUp(MotionEvent e){
  OnChartGestureListener l=mChart.getOnChartGestureListener();
  if (l != null) {
    l.onChartSingleTapped(e);
  }
  Highlight h=mChart.getHighlightByTouchPoint(e.getX(),e.getY());
  if (h == null || h.equalTo(mLastHighlighted)) {
    mChart.highlightTouch(null);
    mLastHighlighted=null;
  }
 else {
    mLastHighlighted=h;
    mChart.highlightTouch(h);
  }
  return super.onSingleTapUp(e);
}",0.9705882352941176
26875,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(0);
  mChart.setDrawYLabels(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(0);
  mChart.setDrawYLabels(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  mChart.animateY(2500);
}",0.9877227722772276
26876,"/** 
 * calculates the required number of digits for the values that might be drawn in the chart (if enabled)
 */
protected void calcFormats(){
  if (!mUseCustomFormatter) {
    float reference=0f;
    if (mOriginalData == null || mOriginalData.getXValCount() < 2) {
      reference=Math.max(Math.abs(mYChartMin),Math.abs(mYChartMax));
    }
 else {
      reference=mDeltaY;
    }
    int digits=Utils.getFormatDigits(reference);
    StringBuffer b=new StringBuffer();
    for (int i=0; i < digits; i++) {
      if (i == 0)       b.append(""String_Node_Str"");
      b.append(""String_Node_Str"");
    }
    mValueFormat=new DecimalFormat(""String_Node_Str"" + b.toString());
  }
}","/** 
 * calculates the required number of digits for the values that might be drawn in the chart (if enabled)
 */
protected void calcFormats(){
  if (!mUseCustomFormatter) {
    float reference=0f;
    if (mOriginalData == null || mOriginalData.getXValCount() < 2) {
      reference=Math.max(Math.abs(mYChartMin),Math.abs(mYChartMax));
    }
 else {
      reference=mDeltaY;
    }
    int digits=Utils.getDecimals(reference);
    StringBuffer b=new StringBuffer();
    for (int i=0; i < digits; i++) {
      if (i == 0)       b.append(""String_Node_Str"");
      b.append(""String_Node_Str"");
    }
    mValueFormat=new DecimalFormat(""String_Node_Str"" + b.toString());
  }
}",0.9881129271916792
26877,"@Override protected void drawValues(){
  if (!mDrawXVals && !mDrawYValues)   return;
  PointF center=getCenterCircleBox();
  float r=getRadius();
  float off=r / 2f;
  if (mDrawHole) {
    off=(r - (r / 100f * mHoleRadiusPercent)) / 2f;
  }
  r-=off;
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      float offset=mDrawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((mRotationAngle + mAbsoluteAngles[cnt] - offset) * mPhaseY)) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((mRotationAngle + mAbsoluteAngles[cnt] - offset) * mPhaseY)) + center.y);
      String val=""String_Node_Str"";
      float value=entries.get(j).getVal();
      if (mUsePercentValues)       val=mValueFormat.format(getPercentOfTotal(value)) + ""String_Node_Str"";
 else       val=mValueFormat.format(value);
      if (mDrawUnitInChart)       val=val + mUnit;
      if (mDrawXVals && mDrawYValues) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        mDrawCanvas.drawText(val,x,y,mValuePaint);
        mDrawCanvas.drawText(mCurrentData.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (mDrawXVals && !mDrawYValues) {
        mDrawCanvas.drawText(mCurrentData.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!mDrawXVals && mDrawYValues) {
        mDrawCanvas.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}","@Override protected void drawValues(){
  if (!mDrawXVals && !mDrawYValues)   return;
  PointF center=getCenterCircleBox();
  float r=getRadius();
  float off=r / 2f;
  if (mDrawHole) {
    off=(r - (r / 100f * mHoleRadiusPercent)) / 2f;
  }
  r-=off;
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      float offset=mDrawAngles[cnt] / 2;
      float x=(float)(r * Math.cos(Math.toRadians((mRotationAngle + mAbsoluteAngles[cnt] - offset) * mPhaseY)) + center.x);
      float y=(float)(r * Math.sin(Math.toRadians((mRotationAngle + mAbsoluteAngles[cnt] - offset) * mPhaseY)) + center.y);
      String val=""String_Node_Str"";
      float value=entries.get(j).getVal();
      if (mUsePercentValues)       val=mValueFormat.format(Math.abs(getPercentOfTotal(value))) + ""String_Node_Str"";
 else       val=mValueFormat.format(value);
      if (mDrawUnitInChart)       val=val + mUnit;
      if (mDrawXVals && mDrawYValues) {
        float lineHeight=(mValuePaint.ascent() + mValuePaint.descent()) * 1.6f;
        y-=lineHeight / 2;
        mDrawCanvas.drawText(val,x,y,mValuePaint);
        mDrawCanvas.drawText(mCurrentData.getXVals().get(j),x,y + lineHeight,mValuePaint);
      }
 else       if (mDrawXVals && !mDrawYValues) {
        mDrawCanvas.drawText(mCurrentData.getXVals().get(j),x,y,mValuePaint);
      }
 else       if (!mDrawXVals && mDrawYValues) {
        mDrawCanvas.drawText(val,x,y,mValuePaint);
      }
      cnt++;
    }
  }
}",0.9969915764139592
26878,"@Override protected void drawData(){
  float angle=mRotationAngle;
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      float newangle=mDrawAngles[cnt];
      float sliceSpace=dataSet.getSliceSpace();
      if (!needsHighlight(entries.get(j).getXIndex(),i)) {
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawArc(mCircleBox,angle + sliceSpace / 2f,newangle * mPhaseY - sliceSpace / 2f,true,mRenderPaint);
      }
      angle+=newangle * mPhaseX;
      cnt++;
    }
  }
}","@Override protected void drawData(){
  float angle=mRotationAngle;
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet dataSet=dataSets.get(i);
    ArrayList<Entry> entries=dataSet.getYVals();
    for (int j=0; j < entries.size(); j++) {
      float newangle=mDrawAngles[cnt];
      float sliceSpace=dataSet.getSliceSpace();
      Entry e=entries.get(j);
      if ((Math.abs(e.getVal()) > 0.000001)) {
        if (!needsHighlight(e.getXIndex(),i)) {
          mRenderPaint.setColor(dataSet.getColor(j));
          mDrawCanvas.drawArc(mCircleBox,angle + sliceSpace / 2f,newangle * mPhaseY - sliceSpace / 2f,true,mRenderPaint);
        }
      }
      angle+=newangle * mPhaseX;
      cnt++;
    }
  }
}",0.92998678996037
26879,"/** 
 * calculates the needed angles for the chart slices
 */
private void calcAngles(){
  mDrawAngles=new float[mCurrentData.getYValCount()];
  mAbsoluteAngles=new float[mCurrentData.getYValCount()];
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet set=dataSets.get(i);
    ArrayList<Entry> entries=set.getYVals();
    for (int j=0; j < entries.size(); j++) {
      mDrawAngles[cnt]=calcAngle(entries.get(j).getVal());
      if (cnt == 0) {
        mAbsoluteAngles[cnt]=mDrawAngles[cnt];
      }
 else {
        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];
      }
      cnt++;
    }
  }
}","/** 
 * calculates the needed angles for the chart slices
 */
private void calcAngles(){
  mDrawAngles=new float[mCurrentData.getYValCount()];
  mAbsoluteAngles=new float[mCurrentData.getYValCount()];
  ArrayList<PieDataSet> dataSets=mCurrentData.getDataSets();
  int cnt=0;
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    PieDataSet set=dataSets.get(i);
    ArrayList<Entry> entries=set.getYVals();
    for (int j=0; j < entries.size(); j++) {
      mDrawAngles[cnt]=calcAngle(Math.abs(entries.get(j).getVal()));
      if (cnt == 0) {
        mAbsoluteAngles[cnt]=mDrawAngles[cnt];
      }
 else {
        mAbsoluteAngles[cnt]=mAbsoluteAngles[cnt - 1] + mDrawAngles[cnt];
      }
      cnt++;
    }
  }
}",0.993006993006993
26880,"/** 
 * enable this to force the y-axis labels to always start at zero
 * @param enabled
 */
public void setStartAtZero(boolean enabled){
  this.mStartAtZero=enabled;
  prepare();
  prepareMatrix();
  calculateOffsets();
}","/** 
 * enable this to force the y-axis labels to always start at zero
 * @param enabled
 */
public void setStartAtZero(boolean enabled){
  this.mStartAtZero=enabled;
  prepare();
  prepareMatrix();
}",0.9478672985781992
26881,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 4f);
  }
  if (mDrawLegend) {
    mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
    mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight() / 3 * 2);
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  applyCalculatedOffsets();
}","@Override protected void calculateOffsets(){
  if (mDrawLegend) {
    float legendRight=0f, legendBottom=0f;
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(7f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 4f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
    float min=Utils.convertDpToPixel(11f);
    mLegend.setOffsetTop(min);
    mLegend.setOffsetLeft(min);
    mOffsetTop=Math.max(mLegend.getFullHeight(mLegendLabelPaint),min);
    applyCalculatedOffsets();
  }
}",0.5968008825151683
26882,"@Override public void prepare(){
  if (mDataNotSet)   return;
  calcMinMax(false);
  prepareLegend();
}","@Override public void prepare(){
  if (mDataNotSet)   return;
  calcMinMax(false);
  prepareLegend();
  calculateOffsets();
}",0.9035087719298246
26883,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 5.5f);
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  if (mDrawLegend) {
    mOffsetBottom=Math.max(mXLabels.mLabelWidth,mOffsetBottom);
    mOffsetTop=Math.max(mXLabels.mLabelWidth,mOffsetTop);
    mOffsetRight=Math.max(mXLabels.mLabelWidth,mOffsetRight);
    mOffsetLeft=Math.max(mXLabels.mLabelWidth,mOffsetLeft);
    mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
    mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight() / 3 * 2);
  }
  applyCalculatedOffsets();
}","@Override protected void calculateOffsets(){
  if (mDrawLegend) {
    float legendRight=0f, legendBottom=0f;
    if (mLegend == null)     return;
    if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
      float spacing=Utils.convertDpToPixel(7f);
      legendRight=mLegend.getMaximumEntryLength(mLegendLabelPaint) + mLegend.getFormSize() + mLegend.getFormToTextSpace()+ spacing;
      mLegendLabelPaint.setTextAlign(Align.LEFT);
    }
 else     if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
      legendBottom=mLegendLabelPaint.getTextSize() * 5.5f;
    }
    mLegend.setOffsetBottom(legendBottom);
    mLegend.setOffsetRight(legendRight);
    float min=Utils.convertDpToPixel(11f);
    mOffsetBottom=Math.max(mXLabels.mLabelWidth,min);
    mOffsetTop=Math.max(mXLabels.mLabelWidth,min);
    mOffsetRight=Math.max(mXLabels.mLabelWidth,min);
    mOffsetLeft=Math.max(mXLabels.mLabelWidth,min);
    mOffsetBottom=Math.max(mOffsetBottom,legendBottom);
    mOffsetRight=Math.max(mOffsetRight,legendRight / 3f * 2f);
    mLegend.setOffsetTop(min);
    mLegend.setOffsetLeft(min);
    applyCalculatedOffsets();
  }
}",0.5071151358344114
26884,"/** 
 * calculates the full width the fully drawn legend will use in pixels
 * @return
 */
public float getFullWidth(Paint labelpaint){
  float width=0f;
  for (int i=0; i < mLegendLabels.length; i++) {
    if (mLegendLabels[i] != null) {
      if (mColors[i] != -1)       width+=mFormSize + mFormToTextSpace;
      width+=Utils.calcTextWidth(labelpaint,mLegendLabels[i]) + mXEntrySpace;
    }
 else {
      width+=mFormSize + mStackSpace;
    }
  }
  return width;
}","/** 
 * calculates the full width the fully drawn legend will use in pixels
 * @return
 */
public float getFullWidth(Paint labelpaint){
  float width=0f;
  for (int i=0; i < mLegendLabels.length; i++) {
    if (mLegendLabels[i] != null) {
      if (mColors[i] != -2)       width+=mFormSize + mFormToTextSpace;
      width+=Utils.calcTextWidth(labelpaint,mLegendLabels[i]) + mXEntrySpace;
    }
 else {
      width+=mFormSize + mStackSpace;
    }
  }
  return width;
}",0.9978586723768736
26885,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_colored_lines);
  mCharts[0]=(LineChart)findViewById(R.id.chart1);
  mCharts[1]=(LineChart)findViewById(R.id.chart2);
  mCharts[2]=(LineChart)findViewById(R.id.chart3);
  mCharts[3]=(LineChart)findViewById(R.id.chart4);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  LineData data=getData(36,100);
  for (int i=0; i < mCharts.length; i++)   setupChart(mCharts[i],data,mColors[i % mColors.length] & 0x90FFFFFF);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_colored_lines);
  mCharts[0]=(LineChart)findViewById(R.id.chart1);
  mCharts[1]=(LineChart)findViewById(R.id.chart2);
  mCharts[2]=(LineChart)findViewById(R.id.chart3);
  mCharts[3]=(LineChart)findViewById(R.id.chart4);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  LineData data=getData(36,100);
  for (int i=0; i < mCharts.length; i++)   setupChart(mCharts[i],data,mColors[i % mColors.length]);
}",0.9902912621359224
26886,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setRotationAngle(0);
  mChart.setDrawXValues(true);
  mChart.setRotationEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_CENTER);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setRotationAngle(0);
  mChart.setDrawXValues(true);
  mChart.setRotationEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9933035714285714
26887,"/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
 * @param x
 * @param y
 * @return
 */
@Override public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double base=xTouchVal;
  if (xTouchVal < 0 || xTouchVal > mDeltaX)   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int setCount=mOriginalData.getDataSetCount();
  int valCount=setCount * mOriginalData.getXValCount();
  BarData bd=(BarData)mCurrentData;
  float space=(float)(((float)valCount / (float)setCount) / (mDeltaX / base));
  float reduction=(float)space * bd.getGroupSpace();
  int xIndex=(int)((base - reduction) / setCount);
  int dataSetIndex=((int)(base - reduction)) % setCount;
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}","/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
 * @param x
 * @param y
 * @return
 */
@Override public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet || mCurrentData == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double base=xTouchVal;
  if (xTouchVal < 0 || xTouchVal > mDeltaX)   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int setCount=mOriginalData.getDataSetCount();
  int valCount=setCount * mOriginalData.getXValCount();
  BarData bd=(BarData)mCurrentData;
  float space=(float)(((float)valCount / (float)setCount) / (mDeltaX / base));
  float reduction=(float)space * bd.getGroupSpace();
  int xIndex=(int)((base - reduction) / setCount);
  int dataSetIndex=((int)(base - reduction)) % setCount;
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.9901960784313726
26888,"/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the Line-, Scatter-, or CandleStick-Chart.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset)   return null;
  if (this instanceof CandleStickChart)   base-=0.5;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (xTouchVal - base > 0.5) {
    xIndex=(int)base + 1;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=Utils.getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}","/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the Line-, Scatter-, or CandleStick-Chart.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet || mCurrentData == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset)   return null;
  if (this instanceof CandleStickChart)   base-=0.5;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (xTouchVal - base > 0.5) {
    xIndex=(int)base + 1;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=Utils.getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.9904686258935664
26889,"/** 
 * Returns the actual position in pixels of the MarkerView for the given Entry in the given DataSet.
 * @param xIndex
 * @param dataSetIndex
 * @return
 */
private float[] getMarkerPosition(Entry e,int dataSetIndex){
  float xPos=(float)e.getXIndex();
  if (this instanceof CandleStickChart)   xPos+=0.5f;
 else   if (this instanceof BarChart) {
    BarData bd=(BarData)mCurrentData;
    float space=bd.getGroupSpace();
    float j=mCurrentData.getDataSetByIndex(dataSetIndex).getEntryPosition(e);
    float x=(j * (mCurrentData.getDataSetCount() - 1)) + dataSetIndex + space * j + space / 2f + 0.5f;
    xPos+=x;
  }
 else   if (this instanceof RadarChart) {
    RadarChart rc=(RadarChart)this;
    float angle=rc.getSliceAngle() * e.getXIndex() + rc.getRotationAngle();
    float val=e.getVal() * rc.getFactor();
    PointF c=getCenter();
    PointF p=new PointF((float)(c.x + val * Math.cos(Math.toRadians(angle))),(float)(c.y + val * Math.sin(Math.toRadians(angle))));
    return new float[]{p.x,p.y};
  }
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  return pts;
}","/** 
 * Returns the actual position in pixels of the MarkerView for the given Entry in the given DataSet.
 * @param xIndex
 * @param dataSetIndex
 * @return
 */
private float[] getMarkerPosition(Entry e,int dataSetIndex){
  float xPos=(float)e.getXIndex();
  if (this instanceof CandleStickChart)   xPos+=0.5f;
 else   if (this instanceof BarChart) {
    BarData bd=(BarData)mCurrentData;
    float space=bd.getGroupSpace();
    float j=mCurrentData.getDataSetByIndex(dataSetIndex).getEntryPosition(e);
    float x=(j * (mCurrentData.getDataSetCount() - 1)) + dataSetIndex + space * j + space / 2f + 0.5f;
    xPos+=x;
  }
 else   if (this instanceof RadarChart) {
    RadarChart rc=(RadarChart)this;
    float angle=rc.getSliceAngle() * e.getXIndex() + rc.getRotationAngle();
    float val=e.getVal() * rc.getFactor();
    PointF c=getCenterOffsets();
    PointF p=new PointF((float)(c.x + val * Math.cos(Math.toRadians(angle))),(float)(c.y + val * Math.sin(Math.toRadians(angle))));
    return new float[]{p.x,p.y};
  }
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  return pts;
}",0.9968623935454952
26890,"/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  float formSize=mLegend.getFormSize();
  float formTextSpaceAndForm=mLegend.getFormToTextSpace() + formSize;
  float stackSpace=mLegend.getStackSpace();
  float textSize=mLegend.getTextSize();
  float textDrop=(Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mLegend.getOffsetLeft();
  posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  if (labels[i] != null) {
    if (mLegend.getColors()[i] != -2)     posX+=formTextSpaceAndForm;
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
  }
 else {
    posX+=formSize + stackSpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - getOffsetRight();
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
if (mLegend.getColors()[i] != -2) posX-=formTextSpaceAndForm;
}
 else {
posX-=stackSpace + formSize;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
}
break;
case RIGHT_OF_CHART:
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint) - formTextSpaceAndForm;
posY=mLegend.getOffsetTop();
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
float x=posX;
if (mLegend.getColors()[i] != -2) x+=formTextSpaceAndForm;
posY+=textDrop;
mLegend.drawLabel(mDrawCanvas,x,posY,mLegendLabelPaint,i);
}
 else {
posY+=textSize * 1.2f + formSize;
mLegend.drawLabel(mDrawCanvas,posX,posY,mLegendLabelPaint,i);
}
posY+=mLegend.getYEntrySpace();
stack=0f;
}
 else {
stack+=formSize + stackSpace;
wasStacked=true;
}
}
break;
case BELOW_CHART_CENTER:
float fullSize=mLegend.getFullWidth(mLegendLabelPaint);
posX=getWidth() / 2f - fullSize / 2f;
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (mLegend.getColors()[i] != -2) posX+=formTextSpaceAndForm;
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
}
 else {
posX+=formSize + stackSpace;
}
}
break;
}
}","/** 
 * draws the legend
 */
protected void drawLegend(){
  if (!mDrawLegend || mLegend == null)   return;
  String[] labels=mLegend.getLegendLabels();
  Typeface tf=mLegend.getTypeface();
  if (tf != null)   mLegendLabelPaint.setTypeface(tf);
  mLegendLabelPaint.setTextSize(mLegend.getTextSize());
  mLegendLabelPaint.setColor(mLegend.getTextColor());
  float formSize=mLegend.getFormSize();
  float formTextSpaceAndForm=mLegend.getFormToTextSpace() + formSize;
  float stackSpace=mLegend.getStackSpace();
  float textSize=mLegend.getTextSize();
  float textDrop=(Utils.calcTextHeight(mLegendLabelPaint,""String_Node_Str"") + formSize) / 2f;
  float posX, posY;
switch (mLegend.getPosition()) {
case BELOW_CHART_LEFT:
    posX=mLegend.getOffsetLeft();
  posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
  mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
  if (labels[i] != null) {
    if (mLegend.getColors()[i] != -2)     posX+=formTextSpaceAndForm;
    mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
    posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
  }
 else {
    posX+=formSize + stackSpace;
  }
}
break;
case BELOW_CHART_RIGHT:
posX=getWidth() - getOffsetRight();
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=labels.length - 1; i >= 0; i--) {
if (labels[i] != null) {
posX-=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
if (mLegend.getColors()[i] != -2) posX-=formTextSpaceAndForm;
}
 else {
posX-=stackSpace + formSize;
}
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
}
break;
case RIGHT_OF_CHART:
posX=getWidth() - mLegend.getMaximumEntryLength(mLegendLabelPaint) - formTextSpaceAndForm;
posY=mLegend.getOffsetTop();
float stack=0f;
boolean wasStacked=false;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX + stack,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (!wasStacked) {
float x=posX;
if (mLegend.getColors()[i] != -2) x+=formTextSpaceAndForm;
posY+=textDrop;
mLegend.drawLabel(mDrawCanvas,x,posY,mLegendLabelPaint,i);
}
 else {
posY+=textSize * 1.2f + formSize;
mLegend.drawLabel(mDrawCanvas,posX,posY,mLegendLabelPaint,i);
}
posY+=mLegend.getYEntrySpace();
stack=0f;
}
 else {
stack+=formSize + stackSpace;
wasStacked=true;
}
}
break;
case BELOW_CHART_CENTER:
float fullSize=mLegend.getFullWidth(mLegendLabelPaint);
posX=getWidth() / 2f - fullSize / 2f;
posY=getHeight() - mLegend.getOffsetBottom() / 2f - formSize / 2f;
for (int i=0; i < labels.length; i++) {
mLegend.drawForm(mDrawCanvas,posX,posY,mLegendFormPaint,i);
if (labels[i] != null) {
if (mLegend.getColors()[i] != -2) posX+=formTextSpaceAndForm;
mLegend.drawLabel(mDrawCanvas,posX,posY + textDrop,mLegendLabelPaint,i);
posX+=Utils.calcTextWidth(mLegendLabelPaint,labels[i]) + mLegend.getXEntrySpace();
}
 else {
posX+=formSize + stackSpace;
}
}
Log.i(LOG_TAG,""String_Node_Str"" + mContentRect.bottom + ""String_Node_Str""+ getHeight()+ ""String_Node_Str""+ posY+ ""String_Node_Str""+ formSize);
break;
}
}",0.9762744469381212
26891,"/** 
 * returns the center point of the chart in pixels
 * @return
 */
public PointF getCenter(){
  return new PointF(getWidth() / 2f,getHeight() / 2f);
}","/** 
 * Returns the center point of the chart (the whole View) in pixels.
 * @return
 */
public PointF getCenter(){
  return new PointF(getWidth() / 2f,getHeight() / 2f);
}",0.9386503067484664
26892,"/** 
 * returns the center of the chart taking offsets under consideration
 * @return
 */
public PointF getCenterOffsets(){
  return new PointF(mContentRect.left + mContentRect.width() / 2,mContentRect.top + mContentRect.height() / 2);
}","/** 
 * Returns the center of the chart taking offsets under consideration. (returns the center of the content rectangle)
 * @return
 */
public PointF getCenterOffsets(){
  return new PointF(mContentRect.centerX(),mContentRect.centerY());
}",0.7295597484276729
26893,"@Override protected void prepareContentRect(){
  super.prepareContentRect();
  if (mDataNotSet)   return;
  float width=mContentRect.width() + mOffsetLeft + mOffsetRight;
  float height=mContentRect.height() + mOffsetTop + mOffsetBottom;
  float diameter=getDiameter();
  float shift=((PieData)mCurrentData).getDataSet().getSelectionShift();
  mCircleBox.set(width / 2 - diameter / 2 + shift,height / 2 - diameter / 2 + shift,width / 2 + diameter / 2 - shift,height / 2 + diameter / 2 - shift);
}","@Override protected void prepareContentRect(){
  super.prepareContentRect();
  if (mDataNotSet)   return;
  float diameter=getDiameter();
  float boxSize=diameter / 2f;
  PointF c=getCenterOffsets();
  mCircleBox.set(c.x - boxSize,c.y - boxSize,c.x + boxSize,c.y + boxSize);
}",0.4533678756476684
26894,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  drawHighlights();
  drawData();
  drawAdditional();
  drawValues();
  drawLegend();
  drawDescription();
  drawCenterText();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
  PointF c1=getCenter();
  PointF c2=getCenterCircleBox();
  Log.i(LOG_TAG,""String_Node_Str"" + c1.x + ""String_Node_Str""+ c1.y);
  Log.i(LOG_TAG,""String_Node_Str"" + c2.x + ""String_Node_Str""+ c2.y);
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  if (mDataNotSet)   return;
  long starttime=System.currentTimeMillis();
  drawHighlights();
  drawData();
  drawAdditional();
  drawValues();
  drawLegend();
  drawDescription();
  drawCenterText();
  canvas.drawBitmap(mDrawBitmap,0,0,mDrawPaint);
  Log.i(LOG_TAG,""String_Node_Str"" + (System.currentTimeMillis() - starttime) + ""String_Node_Str"");
}",0.8107588856868396
26895,"/** 
 * returns the angle relative to the chart center for the given point on the chart in degrees. The angle is always between 0 and 360, 0 is NORTH, 90 is EAST, ...
 * @param x
 * @param y
 * @return
 */
public float getAngleForPoint(float x,float y){
  PointF c=getCenter();
  double tx=x - c.x, ty=y - c.y;
  double length=Math.sqrt(tx * tx + ty * ty);
  double r=Math.acos(ty / length);
  float angle=(float)Math.toDegrees(r);
  if (x > c.x)   angle=360f - angle;
  angle=angle + 90f;
  if (angle > 360f)   angle=angle - 360f;
  return angle;
}","/** 
 * returns the angle relative to the chart center for the given point on the chart in degrees. The angle is always between 0 and 360, 0 is NORTH, 90 is EAST, ...
 * @param x
 * @param y
 * @return
 */
public float getAngleForPoint(float x,float y){
  PointF c=getCenterOffsets();
  double tx=x - c.x, ty=y - c.y;
  double length=Math.sqrt(tx * tx + ty * ty);
  double r=Math.acos(ty / length);
  float angle=(float)Math.toDegrees(r);
  if (x > c.x)   angle=360f - angle;
  angle=angle + 90f;
  if (angle > 360f)   angle=angle - 360f;
  return angle;
}",0.9936993699369936
26896,"/** 
 * Returns the distance of a certain point on the chart to the center of the chart.
 * @param x
 * @param y
 * @return
 */
public float distanceToCenter(float x,float y){
  PointF c=getCenter();
  float dist=0f;
  float xDist=0f;
  float yDist=0f;
  if (x > c.x) {
    xDist=x - c.x;
  }
 else {
    xDist=c.x - x;
  }
  if (y > c.y) {
    yDist=y - c.y;
  }
 else {
    yDist=c.y - y;
  }
  dist=(float)Math.sqrt(Math.pow(xDist,2.0) + Math.pow(yDist,2.0));
  return dist;
}","/** 
 * Returns the distance of a certain point on the chart to the center of the chart.
 * @param x
 * @param y
 * @return
 */
public float distanceToCenter(float x,float y){
  PointF c=getCenterOffsets();
  float dist=0f;
  float xDist=0f;
  float yDist=0f;
  if (x > c.x) {
    xDist=x - c.x;
  }
 else {
    xDist=c.x - x;
  }
  if (y > c.y) {
    yDist=y - c.y;
  }
 else {
    yDist=c.y - y;
  }
  dist=(float)Math.sqrt(Math.pow(xDist,2.0) + Math.pow(yDist,2.0));
  return dist;
}",0.9927461139896372
26897,"@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 3.5f);
  }
  if (mDrawLegend) {
    mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
    mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight() / 3 * 2);
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}","@Override protected void calculateOffsets(){
  if (mLegend == null)   return;
  if (mLegend.getPosition() == LegendPosition.RIGHT_OF_CHART) {
    mLegend.setOffsetRight(mLegend.getMaximumEntryLength(mLegendLabelPaint));
    mLegendLabelPaint.setTextAlign(Align.LEFT);
  }
 else   if (mLegend.getPosition() == LegendPosition.BELOW_CHART_LEFT || mLegend.getPosition() == LegendPosition.BELOW_CHART_RIGHT || mLegend.getPosition() == LegendPosition.BELOW_CHART_CENTER) {
    if (this instanceof RadarChart)     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 5.5f);
 else     mLegend.setOffsetBottom(mLegendLabelPaint.getTextSize() * 4f);
  }
  if (mDrawLegend) {
    mOffsetBottom=Math.max(mOffsetBottom,mLegend.getOffsetBottom());
    mOffsetRight=Math.max(mOffsetRight,mLegend.getOffsetRight() / 3 * 2);
  }
  mLegend.setOffsetTop(mOffsetTop);
  mLegend.setOffsetLeft(mOffsetLeft);
  prepareContentRect();
  float scaleX=(float)((getWidth() - mOffsetLeft - mOffsetRight) / mDeltaX);
  float scaleY=(float)((getHeight() - mOffsetBottom - mOffsetTop) / mDeltaY);
  Matrix val=new Matrix();
  val.postTranslate(0,-mYChartMin);
  val.postScale(scaleX,-scaleY);
  mMatrixValueToPx.set(val);
  Matrix offset=new Matrix();
  offset.postTranslate(mOffsetLeft,getHeight() - mOffsetBottom);
  mMatrixOffset.set(offset);
}",0.9553536151718688
26898,"@Override protected void drawValues(){
  if (mDrawYValues) {
    float sliceangle=getSliceAngle();
    float factor=getFactor();
    PointF c=getCenter();
    float yoffset=Utils.convertDpToPixel(5f);
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      DataSet dataSet=mCurrentData.getDataSetByIndex(i);
      ArrayList<? extends Entry> entries=dataSet.getYVals();
      for (int j=0; j < entries.size(); j++) {
        Entry e=entries.get(j);
        PointF p=getPosition(c,e.getVal() * factor,sliceangle * j + mRotationAngle);
        mDrawCanvas.drawText(Utils.formatNumber(e.getVal(),mValueFormatDigits,mSeparateTousands),p.x,p.y - yoffset,mValuePaint);
      }
    }
  }
}","@Override protected void drawValues(){
  if (mDrawYValues) {
    float sliceangle=getSliceAngle();
    float factor=getFactor();
    PointF c=getCenterOffsets();
    float yoffset=Utils.convertDpToPixel(5f);
    for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
      DataSet dataSet=mCurrentData.getDataSetByIndex(i);
      ArrayList<? extends Entry> entries=dataSet.getYVals();
      for (int j=0; j < entries.size(); j++) {
        Entry e=entries.get(j);
        PointF p=getPosition(c,e.getVal() * factor,sliceangle * j + mRotationAngle);
        mDrawCanvas.drawText(Utils.formatNumber(e.getVal(),mValueFormatDigits,mSeparateTousands),p.x,p.y - yoffset,mValuePaint);
      }
    }
  }
}",0.9949676491732566
26899,"/** 
 * Draws the x-labels of the chart.
 */
private void drawXLabels(){
  if (!mDrawXLabels)   return;
  mXLabelPaint.setTypeface(mXLabels.getTypeface());
  mXLabelPaint.setTextSize(mXLabels.getTextSize());
  mXLabelPaint.setColor(mXLabels.getTextColor());
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenter();
  for (int i=0; i < mCurrentData.getXValCount(); i++) {
    String text=mCurrentData.getXVals().get(i);
    PointF p=getPosition(c,mYChartMax * factor,sliceangle * i + mRotationAngle);
    mDrawCanvas.drawText(text,p.x,p.y,mXLabelPaint);
  }
}","/** 
 * Draws the x-labels of the chart.
 */
private void drawXLabels(){
  if (!mDrawXLabels)   return;
  mXLabelPaint.setTypeface(mXLabels.getTypeface());
  mXLabelPaint.setTextSize(mXLabels.getTextSize());
  mXLabelPaint.setColor(mXLabels.getTextColor());
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenterOffsets();
  for (int i=0; i < mCurrentData.getXValCount(); i++) {
    String text=mCurrentData.getXVals().get(i);
    PointF p=getPosition(c,mYChartMax * factor,sliceangle * i + mRotationAngle);
    mDrawCanvas.drawText(text,p.x,p.y,mXLabelPaint);
  }
}",0.9940928270042194
26900,"/** 
 * Draws the y-labels of the RadarChart.
 */
private void drawYLabels(){
  if (!mDrawYLabels)   return;
  mYLabelPaint.setTypeface(mYLabels.getTypeface());
  mYLabelPaint.setTextSize(mYLabels.getTextSize());
  mYLabelPaint.setColor(mYLabels.getTextColor());
  PointF c=getCenter();
  float factor=getFactor();
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    float r=((mYChartMax / labelCount) * j) * factor;
    PointF p=getPosition(c,r,mRotationAngle);
    mDrawCanvas.drawText(Utils.formatNumber(r / factor,mYLabels.mDecimals,mSeparateTousands),p.x + 10,p.y - 5,mYLabelPaint);
  }
}","/** 
 * Draws the y-labels of the RadarChart.
 */
private void drawYLabels(){
  if (!mDrawYLabels)   return;
  mYLabelPaint.setTypeface(mYLabels.getTypeface());
  mYLabelPaint.setTextSize(mYLabels.getTextSize());
  mYLabelPaint.setColor(mYLabels.getTextColor());
  PointF c=getCenterOffsets();
  float factor=getFactor();
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    float r=((mYChartMax / labelCount) * j) * factor;
    PointF p=getPosition(c,r,mRotationAngle);
    mDrawCanvas.drawText(Utils.formatNumber(r / factor,mYLabels.mDecimals,mSeparateTousands),p.x + 10,p.y - 5,mYLabelPaint);
  }
}",0.994413407821229
26901,"/** 
 * setup the x-axis labels
 */
private void prepareXLabels(){
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(mCurrentData.getXValAverageLength() + mXLabels.getSpaceBetweenLabels());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXLabels.mLabelWidth=Utils.calcTextWidth(mXLabelPaint,a.toString());
  mXLabels.mLabelHeight=Utils.calcTextWidth(mXLabelPaint,""String_Node_Str"");
}","/** 
 * setup the x-axis labels
 */
private void prepareXLabels(){
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(mCurrentData.getXValAverageLength());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXLabels.mLabelWidth=Utils.calcTextWidth(mXLabelPaint,a.toString());
  mXLabels.mLabelHeight=Utils.calcTextWidth(mXLabelPaint,""String_Node_Str"");
  Log.i(LOG_TAG,""String_Node_Str"" + mXLabels.mLabelWidth);
}",0.8914549653579676
26902,"@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float sliceangle=getSliceAngle();
    float factor=getFactor();
    PointF c=getCenter();
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      RadarDataSet set=(RadarDataSet)mCurrentData.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
      mHighlightPaint.setColor(set.getHighLightColor());
      int xIndex=mIndicesToHightlight[i].getXIndex();
      Entry e=set.getEntryForXIndex(xIndex);
      int j=set.getEntryPosition(e);
      float y=e.getVal();
      PointF p=getPosition(c,y * factor,sliceangle * j + mRotationAngle);
      float[] pts=new float[]{p.x,0,p.x,getHeight(),0,p.y,getWidth(),p.y};
      mDrawCanvas.drawLines(pts,mHighlightPaint);
    }
  }
}","@Override protected void drawHighlights(){
  if (mHighlightEnabled && valuesToHighlight()) {
    float sliceangle=getSliceAngle();
    float factor=getFactor();
    PointF c=getCenterOffsets();
    for (int i=0; i < mIndicesToHightlight.length; i++) {
      RadarDataSet set=(RadarDataSet)mCurrentData.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
      mHighlightPaint.setColor(set.getHighLightColor());
      int xIndex=mIndicesToHightlight[i].getXIndex();
      Entry e=set.getEntryForXIndex(xIndex);
      int j=set.getEntryPosition(e);
      float y=e.getVal();
      PointF p=getPosition(c,y * factor,sliceangle * j + mRotationAngle);
      float[] pts=new float[]{p.x,0,p.x,getHeight(),0,p.y,getWidth(),p.y};
      mDrawCanvas.drawLines(pts,mHighlightPaint);
    }
  }
}",0.9955668144395188
26903,"@Override protected void drawData(){
  ArrayList<RadarDataSet> dataSets=(ArrayList<RadarDataSet>)mCurrentData.getDataSets();
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenter();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    RadarDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    Path surface=new Path();
    for (int j=0; j < entries.size(); j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      Entry e=entries.get(j);
      PointF p=getPosition(c,e.getVal() * factor,sliceangle * j + mRotationAngle);
      if (j == 0)       surface.moveTo(p.x,p.y);
 else       surface.lineTo(p.x,p.y);
    }
    surface.close();
    if (dataSet.isDrawFilledEnabled()) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(dataSet.getFillAlpha());
      mDrawCanvas.drawPath(surface,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setStyle(Paint.Style.STROKE);
    if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)     mDrawCanvas.drawPath(surface,mRenderPaint);
  }
}","@Override protected void drawData(){
  ArrayList<RadarDataSet> dataSets=(ArrayList<RadarDataSet>)mCurrentData.getDataSets();
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenterOffsets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    RadarDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    Path surface=new Path();
    for (int j=0; j < entries.size(); j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      Entry e=entries.get(j);
      PointF p=getPosition(c,e.getVal() * factor,sliceangle * j + mRotationAngle);
      if (j == 0)       surface.moveTo(p.x,p.y);
 else       surface.lineTo(p.x,p.y);
    }
    surface.close();
    if (dataSet.isDrawFilledEnabled()) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(dataSet.getFillAlpha());
      mDrawCanvas.drawPath(surface,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setStyle(Paint.Style.STROKE);
    if (!dataSet.isDrawFilledEnabled() || dataSet.getFillAlpha() < 255)     mDrawCanvas.drawPath(surface,mRenderPaint);
  }
}",0.9970501474926252
26904,"/** 
 * Draws the spider web.
 */
private void drawWeb(){
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenter();
  mWebPaint.setStrokeWidth(mWebLineWidth);
  mWebPaint.setColor(mWebColor);
  mWebPaint.setAlpha(mWebAlpha);
  for (int i=0; i < mCurrentData.getXValCount(); i++) {
    PointF p=getPosition(c,mYChartMax * factor,sliceangle * i + mRotationAngle);
    mDrawCanvas.drawLine(c.x,c.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mInnerWebLineWidth);
  mWebPaint.setColor(mWebColorInner);
  mWebPaint.setAlpha(mWebAlpha);
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mCurrentData.getXValCount(); i++) {
      float r=((mYChartMax / labelCount) * (j + 1)) * factor;
      PointF p1=getPosition(c,r,sliceangle * i + mRotationAngle);
      PointF p2=getPosition(c,r,sliceangle * (i + 1) + mRotationAngle);
      mDrawCanvas.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}","/** 
 * Draws the spider web.
 */
private void drawWeb(){
  float sliceangle=getSliceAngle();
  float factor=getFactor();
  PointF c=getCenterOffsets();
  mWebPaint.setStrokeWidth(mWebLineWidth);
  mWebPaint.setColor(mWebColor);
  mWebPaint.setAlpha(mWebAlpha);
  for (int i=0; i < mCurrentData.getXValCount(); i++) {
    PointF p=getPosition(c,mYChartMax * factor,sliceangle * i + mRotationAngle);
    mDrawCanvas.drawLine(c.x,c.y,p.x,p.y,mWebPaint);
  }
  mWebPaint.setStrokeWidth(mInnerWebLineWidth);
  mWebPaint.setColor(mWebColorInner);
  mWebPaint.setAlpha(mWebAlpha);
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    for (int i=0; i < mCurrentData.getXValCount(); i++) {
      float r=((mYChartMax / labelCount) * (j + 1)) * factor;
      PointF p1=getPosition(c,r,sliceangle * i + mRotationAngle);
      PointF p2=getPosition(c,r,sliceangle * (i + 1) + mRotationAngle);
      mDrawCanvas.drawLine(p1.x,p1.y,p2.x,p2.y,mWebPaint);
    }
  }
}",0.9964194373401536
26905,"/** 
 * Draws the y-labels of the RadarChart.
 */
private void drawYLabels(){
  if (!mDrawYLabels)   return;
  mYLabelPaint.setTypeface(mYLabels.getTypeface());
  mYLabelPaint.setTextSize(mYLabels.getTextSize());
  mYLabelPaint.setColor(mYLabels.getTextColor());
  PointF c=getCenterOffsets();
  float factor=getFactor();
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    float r=((mYChartMax / labelCount) * j) * factor;
    PointF p=getPosition(c,r,mRotationAngle);
    mDrawCanvas.drawText(Utils.formatNumber(r / factor,mYLabels.mDecimals,mYLabels.isSeparateThousandsEnabled()),p.x + 10,p.y - 5,mYLabelPaint);
  }
}","/** 
 * Draws the y-labels of the RadarChart.
 */
private void drawYLabels(){
  if (!mDrawYLabels)   return;
  mYLabelPaint.setTypeface(mYLabels.getTypeface());
  mYLabelPaint.setTextSize(mYLabels.getTextSize());
  mYLabelPaint.setColor(mYLabels.getTextColor());
  PointF c=getCenterOffsets();
  float factor=getFactor();
  int labelCount=mYLabels.mEntryCount;
  for (int j=0; j < labelCount; j++) {
    float r=((mYChartMax / labelCount) * j) * factor;
    PointF p=getPosition(c,r,mRotationAngle);
    float val=r / factor;
    String label=Utils.formatNumber(val,mYLabels.mDecimals,mYLabels.isSeparateThousandsEnabled());
    mDrawCanvas.drawText(label,p.x + 10,p.y - 5,mYLabelPaint);
  }
}",0.8384214445271779
26906,"/** 
 * Formats the given number to the given number of decimals, and returns the number as a string, maximum 35 characters.
 * @param number
 * @param digitCount
 * @param separateTousands set this to true to separate thousands values
 * @return
 */
public static String formatNumber(float number,int digitCount,boolean separateThousands){
  char[] out=new char[35];
  boolean neg=false;
  if (number == 0) {
    return ""String_Node_Str"";
  }
  boolean zero=false;
  if (number < 1 && number > -1) {
    zero=true;
  }
  if (number < 0) {
    neg=true;
    number=-number;
  }
  if (digitCount > POW_10.length) {
    digitCount=POW_10.length - 1;
  }
  number*=POW_10[digitCount];
  long lval=Math.round(number);
  int ind=out.length - 1;
  int charCount=0;
  boolean decimalPointAdded=false;
  while (lval != 0 || charCount < (digitCount + 1)) {
    int digit=(int)(lval % 10);
    lval=lval / 10;
    out[ind--]=(char)(digit + '0');
    charCount++;
    if (charCount == digitCount) {
      out[ind--]=',';
      charCount++;
      decimalPointAdded=true;
    }
 else     if (separateThousands && lval != 0 && charCount > digitCount) {
      if (decimalPointAdded) {
        if ((charCount - digitCount) % 4 == 0) {
          out[ind--]='.';
          charCount++;
        }
      }
 else {
        if ((charCount - digitCount) % 4 == 3) {
          out[ind--]='.';
          charCount++;
        }
      }
    }
  }
  if (zero)   out[ind--]='0';
  if (neg)   out[ind--]='-';
  return new String(out);
}","/** 
 * Formats the given number to the given number of decimals, and returns the number as a string, maximum 35 characters.
 * @param number
 * @param digitCount
 * @param separateTousands set this to true to separate thousands values
 * @return
 */
public static String formatNumber(float number,int digitCount,boolean separateThousands){
  char[] out=new char[35];
  boolean neg=false;
  if (number == 0) {
    return ""String_Node_Str"";
  }
  boolean zero=false;
  if (number < 1 && number > -1) {
    zero=true;
  }
  if (number < 0) {
    neg=true;
    number=-number;
  }
  if (digitCount > POW_10.length) {
    digitCount=POW_10.length - 1;
  }
  number*=POW_10[digitCount];
  long lval=Math.round(number);
  int ind=out.length - 1;
  int charCount=0;
  boolean decimalPointAdded=false;
  while (lval != 0 || charCount < (digitCount + 1)) {
    int digit=(int)(lval % 10);
    lval=lval / 10;
    out[ind--]=(char)(digit + '0');
    charCount++;
    if (charCount == digitCount) {
      out[ind--]=',';
      charCount++;
      decimalPointAdded=true;
    }
 else     if (separateThousands && lval != 0 && charCount > digitCount) {
      if (decimalPointAdded) {
        if ((charCount - digitCount) % 4 == 0) {
          out[ind--]='.';
          charCount++;
        }
      }
 else {
        if ((charCount - digitCount) % 4 == 3) {
          out[ind--]='.';
          charCount++;
        }
      }
    }
  }
  if (zero)   out[ind--]='0';
  if (neg)   out[ind--]='-';
  int start=out.length - charCount;
  return String.valueOf(out,start,out.length - start);
}",0.970425739356516
26907,"/** 
 * Formats the given number to the given number of decimals, and returns the number as a string, maximum 35 characters.
 * @param number
 * @param digitCount
 * @param separateTousands set this to true to separate thousands values
 * @return
 */
public static String formatNumber(float number,int digitCount,boolean separateThousands){
  char[] out=new char[35];
  boolean neg=false;
  if (number == 0) {
    return ""String_Node_Str"";
  }
  boolean zero=false;
  if (number < 1 && number > -1) {
    zero=true;
  }
  if (number < 0) {
    neg=true;
    number=-number;
  }
  if (digitCount > POW_10.length) {
    digitCount=POW_10.length - 1;
  }
  number*=POW_10[digitCount];
  long lval=Math.round(number);
  int ind=out.length - 1;
  int charCount=0;
  boolean decimalPointAdded=false;
  while (lval != 0 || charCount < (digitCount + 1)) {
    int digit=(int)(lval % 10);
    lval=lval / 10;
    out[ind--]=(char)(digit + '0');
    charCount++;
    if (charCount == digitCount) {
      out[ind--]=',';
      charCount++;
      decimalPointAdded=true;
    }
 else     if (separateThousands && lval != 0 && charCount > digitCount) {
      if (decimalPointAdded) {
        if ((charCount - digitCount) % 4 == 0) {
          out[ind--]='.';
          charCount++;
        }
      }
 else {
        if ((charCount - digitCount) % 4 == 3) {
          out[ind--]='.';
          charCount++;
        }
      }
    }
  }
  if (zero)   out[ind--]='0';
  if (neg)   out[ind--]='-';
  int start=out.length - charCount;
  return String.valueOf(out,start,out.length - start);
}","/** 
 * Formats the given number to the given number of decimals, and returns the number as a string, maximum 35 characters.
 * @param number
 * @param digitCount
 * @param separateTousands set this to true to separate thousands values
 * @return
 */
public static String formatNumber(float number,int digitCount,boolean separateThousands){
  char[] out=new char[35];
  boolean neg=false;
  if (number == 0) {
    return ""String_Node_Str"";
  }
  boolean zero=false;
  if (number < 1 && number > -1) {
    zero=true;
  }
  if (number < 0) {
    neg=true;
    number=-number;
  }
  if (digitCount > POW_10.length) {
    digitCount=POW_10.length - 1;
  }
  number*=POW_10[digitCount];
  long lval=Math.round(number);
  int ind=out.length - 1;
  int charCount=0;
  boolean decimalPointAdded=false;
  while (lval != 0 || charCount < (digitCount + 1)) {
    int digit=(int)(lval % 10);
    lval=lval / 10;
    out[ind--]=(char)(digit + '0');
    charCount++;
    if (charCount == digitCount) {
      out[ind--]=',';
      charCount++;
      decimalPointAdded=true;
    }
 else     if (separateThousands && lval != 0 && charCount > digitCount) {
      if (decimalPointAdded) {
        if ((charCount - digitCount) % 4 == 0) {
          out[ind--]='.';
          charCount++;
        }
      }
 else {
        if ((charCount - digitCount) % 4 == 3) {
          out[ind--]='.';
          charCount++;
        }
      }
    }
  }
  if (zero) {
    out[ind--]='0';
    charCount+=1;
  }
  if (neg) {
    out[ind--]='-';
    charCount+=1;
  }
  int start=out.length - charCount;
  return String.valueOf(out,start,out.length - start);
}",0.97871008140263
26908,"/** 
 * set if the user should be allowed to draw onto the chart
 * @param drawingEnabled
 */
public void setDrawingEnabled(boolean drawingEnabled){
  if (mListener instanceof BarLineChartTouchListener) {
    ((BarLineChartTouchListener)mListener).setDrawingEnabled(drawingEnabled);
  }
}","/** 
 * set if the user should be allowed to draw onto the chart
 * @param drawingEnabled
 */
public void setDrawingEnabled(boolean drawingEnabled){
  if (mListener instanceof BarLineChartTouchListener) {
    ((BarLineChartTouchListener<?>)mListener).setDrawingEnabled(drawingEnabled);
  }
}",0.9948186528497408
26909,"@Override public DataSet copy(){
  ArrayList<BarEntry> yVals=new ArrayList<BarEntry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(((BarEntry)mYVals.get(i)).copy());
  }
  BarDataSet copied=new BarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mStackSize=mStackSize;
  copied.mBarSpace=mBarSpace;
  copied.mBarShadowColor=mBarShadowColor;
  copied.mStackLabels=mStackLabels;
  copied.mHighLightColor=mHighLightColor;
  copied.mHighLightAlpha=mHighLightAlpha;
  return copied;
}","@Override public DataSet<BarEntry> copy(){
  ArrayList<BarEntry> yVals=new ArrayList<BarEntry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(((BarEntry)mYVals.get(i)).copy());
  }
  BarDataSet copied=new BarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mStackSize=mStackSize;
  copied.mBarSpace=mBarSpace;
  copied.mBarShadowColor=mBarShadowColor;
  copied.mStackLabels=mStackLabels;
  copied.mHighLightColor=mHighLightColor;
  copied.mHighLightAlpha=mHighLightAlpha;
  return copied;
}",0.9901960784313726
26910,"@Override public DataSet copy(){
  ArrayList<CandleEntry> yVals=new ArrayList<CandleEntry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(((CandleEntry)mYVals.get(i)).copy());
  }
  CandleDataSet copied=new CandleDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShadowWidth=mShadowWidth;
  copied.mBodySpace=mBodySpace;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","@Override public DataSet<CandleEntry> copy(){
  ArrayList<CandleEntry> yVals=new ArrayList<CandleEntry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(((CandleEntry)mYVals.get(i)).copy());
  }
  CandleDataSet copied=new CandleDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShadowWidth=mShadowWidth;
  copied.mBodySpace=mBodySpace;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}",0.9842424242424244
26911,"/** 
 * Provides an exact copy of the DataSet this method is used on.
 * @return
 */
public abstract DataSet copy();","/** 
 * Provides an exact copy of the DataSet this method is used on.
 * @return
 */
public abstract DataSet<T> copy();",0.9872340425531916
26912,"@Override public DataSet copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  LineDataSet copied=new LineDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mCircleSize=mCircleSize;
  copied.mCircleColors=mCircleColors;
  copied.mDashPathEffect=mDashPathEffect;
  copied.mDrawCircles=mDrawCircles;
  copied.mDrawCubic=mDrawCubic;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","@Override public DataSet<Entry> copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  LineDataSet copied=new LineDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mCircleSize=mCircleSize;
  copied.mCircleColors=mCircleColors;
  copied.mDashPathEffect=mDashPathEffect;
  copied.mDrawCircles=mDrawCircles;
  copied.mDrawCubic=mDrawCubic;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}",0.9928934010152284
26913,"@Override public DataSet copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  PieDataSet copied=new PieDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mSliceSpace=mSliceSpace;
  copied.mShift=mShift;
  return copied;
}","@Override public DataSet<Entry> copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  PieDataSet copied=new PieDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mSliceSpace=mSliceSpace;
  copied.mShift=mShift;
  return copied;
}",0.8998459167950693
26914,"@Override public DataSet copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  RadarDataSet copied=new RadarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","@Override public DataSet<Entry> copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  RadarDataSet copied=new RadarDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}",0.896
26915,"@Override public DataSet copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  ScatterDataSet copied=new ScatterDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShapeSize=mShapeSize;
  copied.mScatterShape=mScatterShape;
  copied.mCustomScatterPath=mCustomScatterPath;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}","@Override public DataSet<Entry> copy(){
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mYVals.size(); i++) {
    yVals.add(mYVals.get(i).copy());
  }
  ScatterDataSet copied=new ScatterDataSet(yVals,getLabel());
  copied.mColors=mColors;
  copied.mShapeSize=mShapeSize;
  copied.mScatterShape=mScatterShape;
  copied.mCustomScatterPath=mCustomScatterPath;
  copied.mHighLightColor=mHighLightColor;
  return copied;
}",0.9252013808975834
26916,"@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  BarLineScatterCandleData<? extends BarLineScatterCandleRadarDataSet<? extends Entry>> data=mChart.getDataCurrent();
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POSTZOOM;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
 else if (mTouchMode == LONGPRESS) {
mChart.disableScroll();
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}","@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  BarLineScatterCandleData<? extends BarLineScatterCandleRadarDataSet<? extends Entry>> data=mChart.getDataCurrent();
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}",0.9709206627894216
26917,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f);
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  LimitLine ll2=new LimitLine(-30f);
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  data.addLimitLine(ll1);
  data.addLimitLine(ll2);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setColor(Color.BLACK);
  set1.setCircleColor(Color.BLACK);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  set1.setFillAlpha(65);
  set1.setFillColor(Color.BLACK);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f);
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  LimitLine ll2=new LimitLine(-30f);
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  data.addLimitLine(ll1);
  data.addLimitLine(ll2);
  mChart.setData(data);
}",0.936515997968512
26918,"/** 
 * sets up the content rect that restricts the chart surface
 */
protected void prepareContentRect(){
  mContentRect.set((int)mOffsetLeft,(int)mOffsetTop,getMeasuredWidth() - (int)mOffsetRight,getMeasuredHeight() - (int)mOffsetBottom + 1);
}","/** 
 * sets up the content rect that restricts the chart surface
 */
protected void prepareContentRect(){
  mContentRect.set((int)mOffsetLeft - 1,(int)mOffsetTop,getMeasuredWidth() - (int)mOffsetRight + 1,getMeasuredHeight() - (int)mOffsetBottom + 1);
}",0.984
26919,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  YLabels yLabels=mChart.getYLabels();
  yLabels.setLabelCount(7);
  yLabels.setPosition(YLabelPosition.RIGHT_INSIDE);
  mChart.setDrawYLabels(true);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(15);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  YLabels yLabels=mChart.getYLabels();
  yLabels.setLabelCount(7);
  yLabels.setPosition(YLabelPosition.LEFT);
  mChart.setDrawYLabels(true);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(15);
  mSeekBarY.setProgress(100);
}",0.9940425531914894
26920,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart_noseekbar);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  String[] xVals=new String[30];
  for (int i=0; i < 30; i++)   xVals[i]=""String_Node_Str"" + i;
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < 10; i++)   yVals.add(new Entry((float)(Math.random() * 50) + 50f,i));
  LineDataSet set=new LineDataSet(yVals,""String_Node_Str"");
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  set.setColor(Color.rgb(240,99,99));
  set.setCircleColor(Color.rgb(240,99,99));
  set.setHighLightColor(Color.rgb(190,190,190));
  mData=new LineData(xVals,set);
  mChart.setData(mData);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart_noseekbar);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setDrawGridBackground(false);
  mChart.setDescription(""String_Node_Str"");
  String[] xVals=new String[30];
  for (int i=0; i < 30; i++)   xVals[i]=""String_Node_Str"" + i;
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < 10; i++)   yVals.add(new Entry((float)(Math.random() * 50) + 50f,i));
  LineDataSet set=new LineDataSet(yVals,""String_Node_Str"");
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  set.setColor(Color.rgb(240,99,99));
  set.setCircleColor(Color.rgb(240,99,99));
  set.setHighLightColor(Color.rgb(190,190,190));
  LineData data=new LineData(xVals,set);
  mChart.setData(data);
  mChart.invalidate();
}",0.9860911270983214
26921,"private void removeDataSet(){
  mData.removeDataSet(mData.getDataSetByIndex(mData.getDataSetCount() - 1));
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}","private void removeDataSet(){
  LineData data=mChart.getDataOriginal();
  data.removeDataSet(data.getDataSetByIndex(data.getDataSetCount() - 1));
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}",0.7629427792915532
26922,"private void addEntry(){
  LineDataSet set=mData.getDataSetByIndex(0);
  mData.addEntry(new Entry((float)(Math.random() * 50) + 50f,set.getEntryCount()),0);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}","private void addEntry(){
  LineData data=mChart.getDataOriginal();
  LineDataSet set=data.getDataSetByIndex(0);
  data.addEntry(new Entry((float)(Math.random() * 50) + 50f,set.getEntryCount()),0);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}",0.8974358974358975
26923,"private void removeLastEntry(){
  LineDataSet set=mData.getDataSetByIndex(0);
  Entry e=set.getEntryForXIndex(set.getEntryCount() - 1);
  mData.removeEntry(e,0);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}","private void removeLastEntry(){
  LineData data=mChart.getDataOriginal();
  LineDataSet set=data.getDataSetByIndex(0);
  Entry e=set.getEntryForXIndex(set.getEntryCount() - 1);
  data.removeEntry(e,0);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}",0.899581589958159
26924,"private void addDataSet(){
  int count=(mData.getDataSetCount() + 1);
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < mData.getXValCount(); i++)   yVals.add(new Entry((float)(Math.random() * 50f) + 50f * count,i));
  LineDataSet set=new LineDataSet(yVals,""String_Node_Str"" + count);
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  int color=getResources().getColor(mColors[count % mColors.length]);
  set.setColor(color);
  set.setCircleColor(color);
  set.setHighLightColor(color);
  mData.addDataSet(set);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}","private void addDataSet(){
  LineData data=mChart.getDataOriginal();
  int count=(data.getDataSetCount() + 1);
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < data.getXValCount(); i++)   yVals.add(new Entry((float)(Math.random() * 50f) + 50f * count,i));
  LineDataSet set=new LineDataSet(yVals,""String_Node_Str"" + count);
  set.setLineWidth(2.5f);
  set.setCircleSize(4.5f);
  int color=getResources().getColor(mColors[count % mColors.length]);
  set.setColor(color);
  set.setCircleColor(color);
  set.setHighLightColor(color);
  data.addDataSet(set);
  mChart.notifyDataSetChanged();
  mChart.invalidate();
}",0.876734693877551
26925,"@Override protected void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  BarData bd=(BarData)mCurrentData;
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace() + bd.getGroupSpace() / 2f;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}","@Override protected void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step + i * mOriginalData.getGroupSpace() + mOriginalData.getGroupSpace() / 2f;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}",0.9237918215613384
26926,"/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
 * @param x
 * @param y
 * @return
 */
@Override public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet || mCurrentData == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double base=xTouchVal;
  if (xTouchVal < 0 || xTouchVal > mDeltaX)   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int setCount=mOriginalData.getDataSetCount();
  int valCount=setCount * mOriginalData.getXValCount();
  BarData bd=(BarData)mCurrentData;
  float space=(float)(((float)valCount / (float)setCount) / (mDeltaX / base));
  float reduction=(float)space * bd.getGroupSpace();
  int xIndex=(int)((base - reduction) / setCount);
  int dataSetIndex=((int)(base - reduction)) % setCount;
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}","/** 
 * Returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
 * @param x
 * @param y
 * @return
 */
@Override public Highlight getHighlightByTouchPoint(float x,float y){
  if (mDataNotSet || mCurrentData == null) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double base=xTouchVal;
  if (xTouchVal < 0 || xTouchVal > mDeltaX)   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int setCount=mOriginalData.getDataSetCount();
  int valCount=setCount * mOriginalData.getXValCount();
  float space=(float)(((float)valCount / (float)setCount) / (mDeltaX / base));
  float reduction=(float)space * mOriginalData.getGroupSpace();
  int xIndex=(int)((base - reduction) / setCount);
  int dataSetIndex=((int)(base - reduction)) % setCount;
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.894973436861463
26927,"@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
  mDeltaX*=mOriginalData.getDataSetCount();
  int maxEntry=0;
  for (int i=0; i < mOriginalData.getDataSetCount(); i++) {
    DataSet<? extends Entry> set=mOriginalData.getDataSetByIndex(i);
    if (maxEntry < set.getEntryCount())     maxEntry=set.getEntryCount();
  }
  float groupSpace=((BarData)mOriginalData).getGroupSpace();
  mDeltaX+=maxEntry * groupSpace;
}","@Override protected void calcMinMax(boolean fixedValues){
  super.calcMinMax(fixedValues);
  mDeltaX++;
  mDeltaX*=mOriginalData.getDataSetCount();
  int maxEntry=0;
  for (int i=0; i < mOriginalData.getDataSetCount(); i++) {
    DataSet<? extends Entry> set=mOriginalData.getDataSetByIndex(i);
    if (maxEntry < set.getEntryCount())     maxEntry=set.getEntryCount();
  }
  float groupSpace=mOriginalData.getGroupSpace();
  mDeltaX+=maxEntry * groupSpace;
}",0.988133764832794
26928,"@Override protected void drawHighlights(){
  BarData bd=(BarData)mOriginalData;
  int setCount=mOriginalData.getDataSetCount();
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    Highlight h=mIndicesToHightlight[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
    mHighlightPaint.setColor(ds.getHighLightColor());
    mHighlightPaint.setAlpha(ds.getHighLightAlpha());
    if (index < mCurrentData.getYValCount() && index >= 0 && index < (mDeltaX * mPhaseX) / mOriginalData.getDataSetCount()) {
      Entry e=getEntryByDataSetIndex(index,dataSetIndex);
      if (e == null)       continue;
      float x=index * setCount + dataSetIndex + bd.getGroupSpace() / 2f + bd.getGroupSpace() * index;
      float y=e.getVal();
      prepareBar(x,y,ds.getBarSpace());
      mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      if (mDrawHighlightArrow) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mDeltaY * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        transformPath(arrow);
        mDrawCanvas.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override protected void drawHighlights(){
  int setCount=mOriginalData.getDataSetCount();
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    Highlight h=mIndicesToHightlight[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
    mHighlightPaint.setColor(ds.getHighLightColor());
    mHighlightPaint.setAlpha(ds.getHighLightAlpha());
    if (index < mCurrentData.getYValCount() && index >= 0 && index < (mDeltaX * mPhaseX) / mOriginalData.getDataSetCount()) {
      Entry e=getEntryByDataSetIndex(index,dataSetIndex);
      if (e == null)       continue;
      float x=index * setCount + dataSetIndex + mOriginalData.getGroupSpace() / 2f + mOriginalData.getGroupSpace() * index;
      float y=e.getVal();
      prepareBar(x,y,ds.getBarSpace());
      mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      if (mDrawHighlightArrow) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mDeltaY * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        transformPath(arrow);
        mDrawCanvas.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.974201001155179
26929,"@Override protected void drawData(){
  BarData bd=(BarData)mCurrentData;
  ArrayList<BarDataSet> dataSets=bd.getDataSets();
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int i=0; i < setCount; i++) {
    BarDataSet dataSet=dataSets.get(i);
    boolean noStacks=dataSet.getStackSize() == 1 ? true : false;
    ArrayList<BarEntry> entries=dataSet.getYVals();
    for (int j=0; j < dataSet.getEntryCount() * mPhaseX; j++) {
      BarEntry e=entries.get(j);
      float x=e.getXIndex() + j * (setCount - 1) + i + space * j + space / 2f;
      float y=e.getVal();
      if (noStacks) {
        prepareBar(x,y,dataSet.getBarSpace());
        if (isOffContentRight(mBarRect.left))         break;
        if (isOffContentLeft(mBarRect.right)) {
          continue;
        }
        if (mDrawBarShadow) {
          mRenderPaint.setColor(dataSet.getBarShadowColor());
          mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
        }
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      }
 else {
        float[] vals=e.getVals();
        if (vals == null) {
          prepareBar(x,y,dataSet.getBarSpace());
          if (mDrawBarShadow) {
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          mRenderPaint.setColor(dataSet.getColor(0));
          mDrawCanvas.drawRect(mBarRect,mRenderPaint);
        }
 else {
          float all=e.getVal();
          if (mDrawBarShadow) {
            prepareBar(x,y,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          for (int k=0; k < vals.length; k++) {
            all-=vals[k];
            prepareBar(x,vals[k] + all,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getColor(k));
            mDrawCanvas.drawRect(mBarRect,mRenderPaint);
          }
        }
        if (isOffContentRight(mBarRect.left))         break;
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<BarDataSet> dataSets=mOriginalData.getDataSets();
  int setCount=mOriginalData.getDataSetCount();
  float space=mOriginalData.getGroupSpace();
  for (int i=0; i < setCount; i++) {
    BarDataSet dataSet=dataSets.get(i);
    boolean noStacks=dataSet.getStackSize() == 1 ? true : false;
    ArrayList<BarEntry> entries=dataSet.getYVals();
    for (int j=0; j < dataSet.getEntryCount() * mPhaseX; j++) {
      BarEntry e=entries.get(j);
      float x=e.getXIndex() + j * (setCount - 1) + i + space * j + space / 2f;
      float y=e.getVal();
      if (noStacks) {
        prepareBar(x,y,dataSet.getBarSpace());
        if (isOffContentRight(mBarRect.left))         break;
        if (isOffContentLeft(mBarRect.right)) {
          continue;
        }
        if (mDrawBarShadow) {
          mRenderPaint.setColor(dataSet.getBarShadowColor());
          mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
        }
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      }
 else {
        float[] vals=e.getVals();
        if (vals == null) {
          prepareBar(x,y,dataSet.getBarSpace());
          if (mDrawBarShadow) {
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          mRenderPaint.setColor(dataSet.getColor(0));
          mDrawCanvas.drawRect(mBarRect,mRenderPaint);
        }
 else {
          float all=e.getVal();
          if (mDrawBarShadow) {
            prepareBar(x,y,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          for (int k=0; k < vals.length; k++) {
            all-=vals[k];
            prepareBar(x,vals[k] + all,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getColor(k));
            mDrawCanvas.drawRect(mBarRect,mRenderPaint);
          }
        }
        if (isOffContentRight(mBarRect.left))         break;
      }
    }
  }
}",0.976733029503478
26930,"@Override protected void drawVerticalGrid(){
  if (!mDrawVerticalGrid || mCurrentData == null)   return;
  float[] position=new float[]{0f,0f};
  BarData bd=(BarData)mCurrentData;
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step + i * bd.getGroupSpace();
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth()) {
      mDrawCanvas.drawLine(position[0],mOffsetTop,position[0],getHeight() - mOffsetBottom,mGridPaint);
    }
  }
}","@Override protected void drawVerticalGrid(){
  if (!mDrawVerticalGrid || mCurrentData == null)   return;
  float[] position=new float[]{0f,0f};
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step + i * mOriginalData.getGroupSpace();
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth()) {
      mDrawCanvas.drawLine(position[0],mOffsetTop,position[0],getHeight() - mOffsetBottom,mGridPaint);
    }
  }
}",0.9545049063336308
26931,"/** 
 * returns the filtered ChartData object depending on approximator settings, current scale level and x- and y-axis ratio
 * @return
 */
private ChartData<? extends DataSet<? extends Entry>> getFilteredData(){
  return null;
}","/** 
 * returns the filtered ChartData object depending on approximator settings, current scale level and x- and y-axis ratio
 * @return
 */
private T getFilteredData(){
  return null;
}",0.8894230769230769
26932,"/** 
 * Draws the limit lines if there are one.
 */
private void drawLimitLines(){
  ArrayList<LimitLine> limitLines=((BarLineScatterCandleRadarData<? extends DataSet<? extends Entry>>)mOriginalData).getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[]{0,0,0,0};
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[0]=0f;
    pts[1]=l.getLimit();
    pts[2]=mDeltaX;
    pts[3]=l.getLimit();
    transformPointArray(pts);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mDrawCanvas.drawLine(pts[0],pts[1],pts[2],pts[3],mLimitLinePaint);
  }
}","/** 
 * Draws the limit lines if there are one.
 */
private void drawLimitLines(){
  ArrayList<LimitLine> limitLines=mOriginalData.getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[]{0,0,0,0};
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[0]=0f;
    pts[1]=l.getLimit();
    pts[2]=mDeltaX;
    pts[3]=l.getLimit();
    transformPointArray(pts);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mDrawCanvas.drawLine(pts[0],pts[1],pts[2],pts[3],mLimitLinePaint);
  }
}",0.9366351056081572
26933,"@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=((CandleData)mCurrentData).getDataSets();
  float[] shadowPoints=new float[4];
  float[] bodyPoints=new float[4];
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<CandleEntry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      CandleEntry e=entries.get(j);
      transformShadow(shadowPoints,e);
      transformBody(bodyPoints,e,dataSet.getBodySpace());
      float xShadow=shadowPoints[0];
      float leftBody=bodyPoints[0];
      float rightBody=bodyPoints[2];
      float high=shadowPoints[1];
      float low=shadowPoints[3];
      float open=bodyPoints[1];
      float close=bodyPoints[3];
      if (isOffContentRight(leftBody))       break;
      if (isOffContentLeft(rightBody) && isOffContentTop(low) && isOffContentBottom(high))       continue;
      mDrawCanvas.drawLine(xShadow,low,xShadow,high,mRenderPaint);
      if (open > close) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mDrawCanvas.drawRect(leftBody,close,rightBody,open,mRenderPaint);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
        mDrawCanvas.drawRect(leftBody,open,rightBody,close,mRenderPaint);
      }
    }
  }
}","@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=mCurrentData.getDataSets();
  float[] shadowPoints=new float[4];
  float[] bodyPoints=new float[4];
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<CandleEntry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      CandleEntry e=entries.get(j);
      transformShadow(shadowPoints,e);
      transformBody(bodyPoints,e,dataSet.getBodySpace());
      float xShadow=shadowPoints[0];
      float leftBody=bodyPoints[0];
      float rightBody=bodyPoints[2];
      float high=shadowPoints[1];
      float low=shadowPoints[3];
      float open=bodyPoints[1];
      float close=bodyPoints[3];
      if (isOffContentRight(leftBody))       break;
      if (isOffContentLeft(rightBody) && isOffContentTop(low) && isOffContentBottom(high))       continue;
      mDrawCanvas.drawLine(xShadow,low,xShadow,high,mRenderPaint);
      if (open > close) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mDrawCanvas.drawRect(leftBody,close,rightBody,open,mRenderPaint);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
        mDrawCanvas.drawRect(leftBody,open,rightBody,close,mRenderPaint);
      }
    }
  }
}",0.9893692416725728
26934,"@Override protected void drawHighlights(){
  CandleData cd=(CandleData)mCurrentData;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    CandleDataSet set=cd.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mPhaseY;
    float high=e.getHigh() * mPhaseY;
    float[] vertPts=new float[]{xIndex,mYChartMax,xIndex,mYChartMin,xIndex + 1f,mYChartMax,xIndex + 1f,mYChartMin};
    float[] horPts=new float[]{0,low,mDeltaX,low,0,high,mDeltaX,high};
    transformPointArray(vertPts);
    transformPointArray(horPts);
    mDrawCanvas.drawLines(vertPts,mHighlightPaint);
    mDrawCanvas.drawLines(horPts,mHighlightPaint);
  }
}","@Override protected void drawHighlights(){
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    CandleDataSet set=mOriginalData.getDataSetByIndex(mIndicesToHightlight[i].getDataSetIndex());
    mHighlightPaint.setColor(set.getHighLightColor());
    CandleEntry e=set.getEntryForXIndex(xIndex);
    if (e == null)     continue;
    float low=e.getLow() * mPhaseY;
    float high=e.getHigh() * mPhaseY;
    float[] vertPts=new float[]{xIndex,mYChartMax,xIndex,mYChartMin,xIndex + 1f,mYChartMax,xIndex + 1f,mYChartMin};
    float[] horPts=new float[]{0,low,mDeltaX,low,0,high,mDeltaX,high};
    transformPointArray(vertPts);
    transformPointArray(horPts);
    mDrawCanvas.drawLines(vertPts,mHighlightPaint);
    mDrawCanvas.drawLines(horPts,mHighlightPaint);
  }
}",0.9659701492537314
26935,"@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  BarLineScatterCandleData<? extends BarLineScatterCandleRadarDataSet<? extends Entry>> data=mChart.getDataCurrent();
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}","@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  BarLineScatterCandleData<? extends BarLineScatterCandleRadarDataSet<? extends Entry>> data=mChart.getDataCurrent();
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=CANCEL;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}",0.993123336291038
26936,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  YLabels yLabels=mChart.getYLabels();
  yLabels.setPosition(YLabelPosition.BOTH_SIDED);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.TOP);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(true);
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.set3DEnabled(false);
  mChart.setPinchZoom(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(true);
  mChart.setDrawVerticalGrid(false);
  mChart.setValueTextSize(10f);
  mChart.setDrawBorder(false);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  XLabels xl=mChart.getXLabels();
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(8);
  yl.setPosition(YLabelPosition.BOTH_SIDED);
  mChart.setValueTypeface(tf);
  setData(12,50);
  mSeekBarY.setProgress(50);
  mSeekBarX.setProgress(12);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.BELOW_CHART_LEFT);
  l.setFormSize(8f);
  l.setXEntrySpace(4f);
}",0.9340256566890652
26937,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add(mMonths[i % 12]);
  }
  ArrayList<BarEntry> yVals1=new ArrayList<BarEntry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult);
    yVals1.add(new BarEntry(val,i));
  }
  BarDataSet set1=new BarDataSet(yVals1,""String_Node_Str"");
  set1.setBarSpacePercent(35f);
  ArrayList<BarDataSet> dataSets=new ArrayList<BarDataSet>();
  dataSets.add(set1);
  BarData data=new BarData(xVals,dataSets);
  mChart.setData(data);
}",0.9967585089141004
26938,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
}",0.9918985558295176
26939,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  XLabels xl=mChart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  mChart.setValueTypeface(tf);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(false);
  mChart.setPinchZoom(false);
  mChart.setDrawBarShadow(false);
  mChart.setDrawGridBackground(false);
  mChart.setDrawHorizontalGrid(false);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  XLabels xl=mChart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setTypeface(tf);
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  mChart.setValueTypeface(tf);
}",0.9375233819678264
26940,"@Override protected void drawData(){
  BarData bd=(BarData)mCurrentData;
  ArrayList<BarDataSet> dataSets=(ArrayList<BarDataSet>)bd.getDataSets();
  int setCount=bd.getDataSetCount();
  for (int i=0; i < setCount; i++) {
    BarDataSet dataSet=dataSets.get(i);
    boolean noStacks=dataSet.getStackSize() == 1 ? true : false;
    ArrayList<BarEntry> entries=(ArrayList<BarEntry>)dataSet.getYVals();
    float spaceSum=bd.getGroupSpace() / 2f;
    for (int j=0; j < dataSet.getEntryCount() * mPhaseX; j++) {
      BarEntry e=entries.get(j);
      float x=e.getXIndex() + j * (setCount - 1) + i + spaceSum;
      float y=e.getVal();
      spaceSum+=bd.getGroupSpace();
      if (noStacks) {
        prepareBar(x,y,dataSet.getBarSpace());
        if (isOffContentRight(mBarRect.left))         break;
        if (isOffContentLeft(mBarRect.right)) {
          continue;
        }
        if (mDrawBarShadow) {
          mRenderPaint.setColor(dataSet.getBarShadowColor());
          mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
        }
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      }
 else {
        float[] vals=e.getVals();
        if (vals == null) {
          prepareBar(x,y,dataSet.getBarSpace());
          if (mDrawBarShadow) {
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          mRenderPaint.setColor(dataSet.getColor(0));
          mDrawCanvas.drawRect(mBarRect,mRenderPaint);
        }
 else {
          float all=e.getVal();
          if (mDrawBarShadow) {
            prepareBar(x,y,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          for (int k=0; k < vals.length; k++) {
            all-=vals[k];
            prepareBar(x,vals[k] + all,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getColor(k));
            mDrawCanvas.drawRect(mBarRect,mRenderPaint);
          }
        }
        if (isOffContentRight(mBarRect.left))         break;
      }
    }
  }
}","@Override protected void drawData(){
  BarData bd=(BarData)mCurrentData;
  ArrayList<BarDataSet> dataSets=(ArrayList<BarDataSet>)bd.getDataSets();
  int setCount=bd.getDataSetCount();
  float space=bd.getGroupSpace();
  for (int i=0; i < setCount; i++) {
    BarDataSet dataSet=dataSets.get(i);
    boolean noStacks=dataSet.getStackSize() == 1 ? true : false;
    ArrayList<BarEntry> entries=(ArrayList<BarEntry>)dataSet.getYVals();
    for (int j=0; j < dataSet.getEntryCount() * mPhaseX; j++) {
      BarEntry e=entries.get(j);
      float x=e.getXIndex() + j * (setCount - 1) + i + space * j + space / 2f;
      float y=e.getVal();
      if (noStacks) {
        prepareBar(x,y,dataSet.getBarSpace());
        if (isOffContentRight(mBarRect.left))         break;
        if (isOffContentLeft(mBarRect.right)) {
          continue;
        }
        if (mDrawBarShadow) {
          mRenderPaint.setColor(dataSet.getBarShadowColor());
          mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
        }
        mRenderPaint.setColor(dataSet.getColor(j));
        mDrawCanvas.drawRect(mBarRect,mRenderPaint);
      }
 else {
        float[] vals=e.getVals();
        if (vals == null) {
          prepareBar(x,y,dataSet.getBarSpace());
          if (mDrawBarShadow) {
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          mRenderPaint.setColor(dataSet.getColor(0));
          mDrawCanvas.drawRect(mBarRect,mRenderPaint);
        }
 else {
          float all=e.getVal();
          if (mDrawBarShadow) {
            prepareBar(x,y,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getBarShadowColor());
            mDrawCanvas.drawRect(mBarShadow,mRenderPaint);
          }
          for (int k=0; k < vals.length; k++) {
            all-=vals[k];
            prepareBar(x,vals[k] + all,dataSet.getBarSpace());
            mRenderPaint.setColor(dataSet.getColor(k));
            mDrawCanvas.drawRect(mBarRect,mRenderPaint);
          }
        }
        if (isOffContentRight(mBarRect.left))         break;
      }
    }
  }
}",0.9687791239515378
26941,"/** 
 * Draws the view that is displayed when a value is highlighted.
 * @param xIndex the selected x-index
 * @param dataSetIndex the index of the selected DataSet
 */
private void drawMarkerView(int xIndex,int dataSetIndex){
  Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
  if (e == null) {
    return;
  }
  float xPos=(float)xIndex;
  if (this instanceof BarChart || this instanceof CandleStickChart)   xPos+=0.5f;
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  float posX=pts[0];
  float posY=pts[1];
  mMarkerView.refreshContent(e,dataSetIndex);
  mMarkerView.draw(mDrawCanvas,posX,posY);
}","/** 
 * Draws the view that is displayed when a value is highlighted.
 * @param xIndex the selected x-index
 * @param dataSetIndex the index of the selected DataSet
 */
private void drawMarkerView(int xIndex,int dataSetIndex){
  Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
  if (e == null) {
    return;
  }
  float xPos=(float)xIndex;
  if (this instanceof CandleStickChart)   xPos+=0.5f;
 else   if (this instanceof BarChart) {
    BarData bd=(BarData)mCurrentData;
    float space=bd.getGroupSpace();
    float j=mCurrentData.getDataSetByIndex(dataSetIndex).getEntryPosition(e);
    float x=(j * (mCurrentData.getDataSetCount() - 1)) + dataSetIndex + space * j + space / 2f + 0.5f;
    xPos+=x;
  }
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  float posX=pts[0];
  float posY=pts[1];
  mMarkerView.refreshContent(e,dataSetIndex);
  mMarkerView.draw(mDrawCanvas,posX,posY);
}",0.7828863346104725
26942,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor(i));
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        spline.lineTo((entries.size() - 1) * mPhaseX,mYChartMin);
        spline.lineTo(0,mYChartMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      float[] valuePoints=generateTransformedValues(entries,0f);
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        Path filled=generateFilledPath(entries);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (dataSet.isDrawCubicEnabled()) {
      mRenderPaint.setColor(dataSet.getColor(i));
      float intensity=dataSet.getCubicIntensity();
      Path spline=new Path();
      ArrayList<CPoint> points=new ArrayList<CPoint>();
      for (      Entry e : entries)       points.add(new CPoint(e.getXIndex(),e.getVal()));
      if (points.size() > 1) {
        for (int j=0; j < points.size() * mPhaseX; j++) {
          CPoint point=points.get(j);
          if (j == 0) {
            CPoint next=points.get(j + 1);
            point.dx=((next.x - point.x) * intensity);
            point.dy=((next.y - point.y) * intensity);
          }
 else           if (j == points.size() - 1) {
            CPoint prev=points.get(j - 1);
            point.dx=((point.x - prev.x) * intensity);
            point.dy=((point.y - prev.y) * intensity);
          }
 else {
            CPoint next=points.get(j + 1);
            CPoint prev=points.get(j - 1);
            point.dx=((next.x - prev.x) * intensity);
            point.dy=((next.y - prev.y) * intensity);
          }
          if (j == 0) {
            spline.moveTo(point.x,point.y * mPhaseY);
          }
 else {
            CPoint prev=points.get(j - 1);
            spline.cubicTo(prev.x + prev.dx,(prev.y + prev.dy) * mPhaseY,point.x - point.dx,(point.y - point.dy) * mPhaseY,point.x,point.y * mPhaseY);
          }
        }
      }
      if (dataSet.isDrawFilledEnabled()) {
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        spline.lineTo((entries.size() - 1) * mPhaseX,fillMin);
        spline.lineTo(0,fillMin);
        spline.close();
        mRenderPaint.setStyle(Paint.Style.FILL);
      }
 else {
        mRenderPaint.setStyle(Paint.Style.STROKE);
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      mRenderPaint.setStyle(Paint.Style.STROKE);
      float[] valuePoints=generateTransformedValues(entries,0f);
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
      mRenderPaint.setPathEffect(null);
      if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
        mRenderPaint.setStyle(Paint.Style.FILL);
        mRenderPaint.setColor(dataSet.getFillColor());
        mRenderPaint.setAlpha(dataSet.getFillAlpha());
        float fillMin=dataSet.getYMin() >= 0 ? mYChartMin : 0;
        Path filled=generateFilledPath(entries,fillMin);
        transformPath(filled);
        mDrawCanvas.drawPath(filled,mRenderPaint);
        mRenderPaint.setAlpha(255);
      }
    }
  }
}",0.9641133896260556
26943,"/** 
 * Generates the path that is used for filled drawing.
 * @param entries
 * @return
 */
private Path generateFilledPath(ArrayList<? extends Entry> entries){
  Path filled=new Path();
  filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal() * mPhaseY);
  for (int x=1; x < entries.size() * mPhaseX; x++) {
    Entry e=entries.get(x);
    filled.lineTo(e.getXIndex(),e.getVal() * mPhaseY);
  }
  filled.lineTo(entries.get((int)((entries.size() - 1) * mPhaseX)).getXIndex(),mYChartMin);
  filled.lineTo(entries.get(0).getXIndex(),mYChartMin);
  filled.close();
  return filled;
}","/** 
 * Generates the path that is used for filled drawing.
 * @param entries
 * @return
 */
private Path generateFilledPath(ArrayList<? extends Entry> entries,float fillMin){
  Path filled=new Path();
  filled.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal() * mPhaseY);
  for (int x=1; x < entries.size() * mPhaseX; x++) {
    Entry e=entries.get(x);
    filled.lineTo(e.getXIndex(),e.getVal() * mPhaseY);
  }
  filled.lineTo(entries.get((int)((entries.size() - 1) * mPhaseX)).getXIndex(),fillMin);
  filled.lineTo(entries.get(0).getXIndex(),fillMin);
  filled.close();
  return filled;
}",0.969747899159664
26944,"/** 
 * This method converts device specific pixels to density independent pixels. NEEDS UTILS TO BE INITIALIZED BEFORE USAGE.
 * @param px A value in px (pixels) unit. Which we need to convert into db
 * @return A float value to represent dp equivalent to px value
 */
public static float convertPixelsToDp(float px){
  if (mRes == null)   throw new IllegalStateException(""String_Node_Str"");
  DisplayMetrics metrics=mRes.getDisplayMetrics();
  float dp=px / (metrics.densityDpi / 160f);
  return dp;
}","/** 
 * This method converts device specific pixels to density independent pixels. NEEDS UTILS TO BE INITIALIZED BEFORE USAGE.
 * @param px A value in px (pixels) unit. Which we need to convert into db
 * @return A float value to represent dp equivalent to px value
 */
public static float convertPixelsToDp(float px){
  if (mRes == null) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return px;
  }
  DisplayMetrics metrics=mRes.getDisplayMetrics();
  float dp=px / (metrics.densityDpi / 160f);
  return dp;
}",0.9226248775710088
26945,"/** 
 * This method converts dp unit to equivalent pixels, depending on device density. NEEDS UTILS TO BE INITIALIZED BEFORE USAGE.
 * @param dp A value in dp (density independent pixels) unit. Which we needto convert into pixels
 * @return A float value to represent px equivalent to dp depending ondevice density
 */
public static float convertDpToPixel(float dp){
  if (mRes == null)   throw new IllegalStateException(""String_Node_Str"");
  DisplayMetrics metrics=mRes.getDisplayMetrics();
  float px=dp * (metrics.densityDpi / 160f);
  return px;
}","/** 
 * This method converts dp unit to equivalent pixels, depending on device density. NEEDS UTILS TO BE INITIALIZED BEFORE USAGE.
 * @param dp A value in dp (density independent pixels) unit. Which we needto convert into pixels
 * @return A float value to represent px equivalent to dp depending ondevice density
 */
public static float convertDpToPixel(float dp){
  if (mRes == null) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return dp;
  }
  DisplayMetrics metrics=mRes.getDisplayMetrics();
  float px=dp * (metrics.densityDpi / 160f);
  return px;
}",0.9292748433303492
26946,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(false);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9976019184652278
26947,"@Override protected void drawHighlights(){
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    Highlight h=mIndicesToHightlight[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
    mHighlightPaint.setColor(ds.getHighLightColor());
    mHighlightPaint.setAlpha(ds.getHighLightAlpha());
    if (index < mCurrentData.getYValCount() && index >= 0 && index < mDeltaX * mPhaseX) {
      Entry e=getEntryByDataSetIndex(index,dataSetIndex);
      float x=index * mOriginalData.getDataSetCount() + dataSetIndex;
      prepareBar(x,e.getVal(),ds.getBarSpace());
      mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      if (mDrawHighlightArrow) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mDeltaY * 0.07f;
        float y=e.getVal();
        Path arrow=new Path();
        arrow.moveTo(index + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(index + 0.2f,y + offsetY);
        arrow.lineTo(index + 0.8f,y + offsetY);
        transformPath(arrow);
        mDrawCanvas.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}","@Override protected void drawHighlights(){
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    Highlight h=mIndicesToHightlight[i];
    int index=h.getXIndex();
    int dataSetIndex=h.getDataSetIndex();
    BarDataSet ds=(BarDataSet)mCurrentData.getDataSetByIndex(dataSetIndex);
    mHighlightPaint.setColor(ds.getHighLightColor());
    mHighlightPaint.setAlpha(ds.getHighLightAlpha());
    if (index < mCurrentData.getYValCount() && index >= 0 && index < (mDeltaX * mPhaseX) / mOriginalData.getDataSetCount()) {
      Entry e=getEntryByDataSetIndex(index,dataSetIndex);
      float x=index * mOriginalData.getDataSetCount() + dataSetIndex;
      float y=e.getVal();
      prepareBar(x,y,ds.getBarSpace());
      mDrawCanvas.drawRect(mBarRect,mHighlightPaint);
      if (mDrawHighlightArrow) {
        mHighlightPaint.setAlpha(255);
        float offsetY=mDeltaY * 0.07f;
        Path arrow=new Path();
        arrow.moveTo(x + 0.5f,y + offsetY * 0.3f);
        arrow.lineTo(x + 0.2f,y + offsetY);
        arrow.lineTo(x + 0.8f,y + offsetY);
        transformPath(arrow);
        mDrawCanvas.drawPath(arrow,mHighlightPaint);
      }
    }
  }
}",0.9393278044522044
26948,"/** 
 * Prepares a bar for drawing on the specified x-index and y-position. Also prepares the shadow-bar if enabled.
 * @param x the x-position
 * @param y the y-position
 * @param space the space between bars
 */
private void prepareBar(float x,float y,float space){
  float spaceHalf=space / 2f;
  float left=x + spaceHalf;
  float right=x + 1f - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  mBarRect.set(left,top,right,bottom);
  transformRectWithPhase(mBarRect);
  if (mDrawBarShadow) {
    mBarShadow.set(mBarRect.left,mOffsetTop,mBarRect.right,getHeight() - mOffsetBottom);
  }
}","/** 
 * Prepares a bar for drawing on the specified x-index and y-position. Also prepares the shadow-bar if enabled.
 * @param x the x-position
 * @param y the y-position
 * @param barspace the space between bars
 */
private void prepareBar(float x,float y,float barspace){
  float spaceHalf=barspace / 2f;
  float left=x + spaceHalf;
  float right=x + 1f - spaceHalf;
  float top=y >= 0 ? y : 0;
  float bottom=y <= 0 ? y : 0;
  mBarRect.set(left,top,right,bottom);
  transformRectWithPhase(mBarRect);
  if (mDrawBarShadow) {
    mBarShadow.set(mBarRect.left,mOffsetTop,mBarRect.right,getHeight() - mOffsetBottom);
  }
}",0.9927007299270072
26949,"/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  if (this instanceof BarChart) {
    xIndex/=mOriginalData.getDataSetCount();
  }
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  if (mDataNotSet) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  if (this instanceof BarChart) {
    dataSetIndex=((int)base) % mOriginalData.getDataSetCount();
  }
 else {
    dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  }
  if (dataSetIndex == -1)   return null;
  Toast.makeText(getContext(),""String_Node_Str"" + xIndex + ""String_Node_Str""+ dataSetIndex,Toast.LENGTH_SHORT).show();
  return new Highlight(xIndex,dataSetIndex);
}","/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  if (this instanceof BarChart) {
    xIndex/=mOriginalData.getDataSetCount();
  }
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  if (mDataNotSet) {
    Log.e(LOG_TAG,""String_Node_Str"");
    return null;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  if (this instanceof BarChart) {
    dataSetIndex=((int)base) % mOriginalData.getDataSetCount();
  }
 else {
    dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  }
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.9431992631255756
26950,"/** 
 * draws the x-labels on the specified y-position
 * @param yPos
 */
private void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param yPos
 */
private void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  int step=1;
  if (this instanceof BarChart)   step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=(step / 2f);
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}",0.9805375347544022
26951,"/** 
 * draws the vertical grid
 */
protected void drawVerticalGrid(){
  if (!mDrawVerticalGrid || mCurrentData == null)   return;
  float[] position=new float[]{0f,0f};
  int step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step;
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth()) {
      mDrawCanvas.drawLine(position[0],mOffsetTop,position[0],getHeight() - mOffsetBottom,mGridPaint);
    }
  }
}","/** 
 * draws the vertical grid
 */
protected void drawVerticalGrid(){
  if (!mDrawVerticalGrid || mCurrentData == null)   return;
  float[] position=new float[]{0f,0f};
  int step=1;
  if (this instanceof BarChart)   step=mCurrentData.getDataSetCount();
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i * step;
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth()) {
      mDrawCanvas.drawLine(position[0],mOffsetTop,position[0],getHeight() - mOffsetBottom,mGridPaint);
    }
  }
}",0.962432915921288
26952,"/** 
 * Returns the first Entry object found at the given xIndex with binary search. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Entry getEntryForXIndex(int x){
  int low=0;
  int high=mYVals.size();
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      return mYVals.get(m);
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
  }
  return null;
}","/** 
 * Returns the first Entry object found at the given xIndex with binary search. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Entry getEntryForXIndex(int x){
  int low=0;
  int high=mYVals.size() - 1;
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      return mYVals.get(m);
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
  }
  return null;
}",0.9965217391304348
26953,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setRotationEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setRotationAngle(0);
  mChart.setDrawXValues(true);
  mChart.setRotationEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9886963074604372
26954,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setDescription(""String_Node_Str"");
  mChart.setWebLineWidth(2f);
  mChart.setWebLineWidthInner(0.75f);
  setData();
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_radarchart);
  mChart=(RadarChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setDescription(""String_Node_Str"");
  mChart.setWebLineWidth(2f);
  mChart.setWebLineWidthInner(0.75f);
  setData();
  YLabels yl=mChart.getYLabels();
  yl.setTypeface(tf);
  yl.setLabelCount(5);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setTypeface(tf);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9195876288659792
26955,"public void setData(){
  float mult=100;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < 6; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < 6; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 6; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(getResources().getColor(R.color.vordiplom_1));
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(getResources().getColor(R.color.vordiplom_5));
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  mChart.setData(data);
  mChart.highlightValues(null);
  mChart.invalidate();
}","public void setData(){
  float mult=150;
  ArrayList<Entry> yVals1=new ArrayList<Entry>();
  ArrayList<Entry> yVals2=new ArrayList<Entry>();
  for (int i=0; i < 6; i++) {
    yVals1.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  for (int i=0; i < 6; i++) {
    yVals2.add(new Entry((float)(Math.random() * mult) + mult / 2,i));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < 6; i++)   xVals.add(mParties[i % mParties.length]);
  RadarDataSet set1=new RadarDataSet(yVals1,""String_Node_Str"");
  set1.setColor(getResources().getColor(R.color.vordiplom_1));
  set1.setLineWidth(2f);
  RadarDataSet set2=new RadarDataSet(yVals2,""String_Node_Str"");
  set2.setColor(getResources().getColor(R.color.vordiplom_5));
  set2.setLineWidth(2f);
  ArrayList<RadarDataSet> sets=new ArrayList<RadarDataSet>();
  sets.add(set1);
  sets.add(set2);
  RadarData data=new RadarData(xVals,sets);
  mChart.setData(data);
  mChart.highlightValues(null);
  mChart.invalidate();
}",0.999
26956,"@Override protected void init(){
  super.init();
  mListener=new BarLineChartTouchListener(this,mMatrixTouch);
  mXLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mXLabelPaint.setColor(Color.BLACK);
  mXLabelPaint.setTextAlign(Align.CENTER);
  mXLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mYLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mYLabelPaint.setColor(Color.BLACK);
  mYLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mGridPaint=new Paint();
  mGridPaint.setColor(Color.GRAY);
  mGridPaint.setStrokeWidth(mGridWidth);
  mGridPaint.setStyle(Style.STROKE);
  mGridPaint.setAlpha(90);
  mBorderPaint=new Paint();
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(mGridWidth * 2f);
  mBorderPaint.setStyle(Style.STROKE);
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.STROKE);
}","@Override protected void init(){
  super.init();
  mListener=new BarLineChartTouchListener(this,mMatrixTouch);
  mXLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mXLabelPaint.setColor(Color.BLACK);
  mXLabelPaint.setTextAlign(Align.CENTER);
  mXLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mYLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mYLabelPaint.setColor(Color.BLACK);
  mYLabelPaint.setTextSize(Utils.convertDpToPixel(10f));
  mGridPaint=new Paint();
  mGridPaint.setColor(Color.GRAY);
  mGridPaint.setStrokeWidth(mGridWidth);
  mGridPaint.setStyle(Style.STROKE);
  mGridPaint.setAlpha(90);
  mBorderPaint=new Paint();
  mBorderPaint.setColor(Color.BLACK);
  mBorderPaint.setStrokeWidth(mGridWidth * 2f);
  mBorderPaint.setStyle(Style.STROKE);
  mGridBackgroundPaint=new Paint();
  mGridBackgroundPaint.setStyle(Style.FILL);
  mGridBackgroundPaint.setColor(Color.rgb(240,240,240));
  mLimitLinePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLimitLinePaint.setStyle(Paint.Style.STROKE);
}",0.8968036529680365
26957,"/** 
 * Draws the limit lines if there are one.
 */
private void drawLimitLines(){
  ArrayList<LimitLine> limitLines=((BarLineScatterCandleData)mOriginalData).getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[]{0,0,0,0};
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[0]=0f;
    pts[1]=l.getLimit();
    pts[2]=mDeltaX;
    pts[3]=l.getLimit();
    transformPointArray(pts);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mDrawCanvas.drawLine(pts[0],pts[1],pts[2],pts[3],mLimitLinePaint);
  }
}","/** 
 * Draws the limit lines if there are one.
 */
private void drawLimitLines(){
  ArrayList<LimitLine> limitLines=((BarLineScatterCandleRadarData)mOriginalData).getLimitLines();
  if (limitLines == null)   return;
  float[] pts=new float[]{0,0,0,0};
  for (int i=0; i < limitLines.size(); i++) {
    LimitLine l=limitLines.get(i);
    pts[0]=0f;
    pts[1]=l.getLimit();
    pts[2]=mDeltaX;
    pts[3]=l.getLimit();
    transformPointArray(pts);
    mLimitLinePaint.setColor(l.getLineColor());
    mLimitLinePaint.setPathEffect(l.getDashPathEffect());
    mLimitLinePaint.setStrokeWidth(l.getLineWidth());
    mDrawCanvas.drawLine(pts[0],pts[1],pts[2],pts[3],mLimitLinePaint);
  }
}",0.9963369963369964
26958,"/** 
 * initialize all paints and stuff
 */
protected void init(){
  Utils.init(getContext().getResources());
  mOffsetBottom=(int)Utils.convertDpToPixel(mOffsetBottom);
  mOffsetLeft=(int)Utils.convertDpToPixel(mOffsetLeft);
  mOffsetRight=(int)Utils.convertDpToPixel(mOffsetRight);
  mOffsetTop=(int)Utils.convertDpToPixel(mOffsetTop);
  mRenderPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mRenderPaint.setStyle(Style.FILL);
  mDrawPaint=new Paint();
  mDescPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mDescPaint.setColor(Color.BLACK);
  mDescPaint.setTextAlign(Align.RIGHT);
  mDescPaint.setTextSize(Utils.convertDpToPixel(9f));
  mInfoPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mInfoPaint.setColor(Color.rgb(247,189,51));
  mInfoPaint.setTextAlign(Align.CENTER);
  mInfoPaint.setTextSize(Utils.convertDpToPixel(12f));
  mValuePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mValuePaint.setColor(Color.rgb(63,63,63));
  mValuePaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(9f));
  mLegendFormPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLegendFormPaint.setStyle(Paint.Style.FILL);
  mLegendFormPaint.setStrokeWidth(3f);
  mLegendLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLegendLabelPaint.setTextSize(Utils.convertDpToPixel(9f));
}","/** 
 * initialize all paints and stuff
 */
protected void init(){
  Utils.init(getContext().getResources());
  mOffsetBottom=(int)Utils.convertDpToPixel(mOffsetBottom);
  mOffsetLeft=(int)Utils.convertDpToPixel(mOffsetLeft);
  mOffsetRight=(int)Utils.convertDpToPixel(mOffsetRight);
  mOffsetTop=(int)Utils.convertDpToPixel(mOffsetTop);
  mRenderPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mRenderPaint.setStyle(Style.FILL);
  mDrawPaint=new Paint();
  mDescPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mDescPaint.setColor(Color.BLACK);
  mDescPaint.setTextAlign(Align.RIGHT);
  mDescPaint.setTextSize(Utils.convertDpToPixel(9f));
  mInfoPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mInfoPaint.setColor(Color.rgb(247,189,51));
  mInfoPaint.setTextAlign(Align.CENTER);
  mInfoPaint.setTextSize(Utils.convertDpToPixel(12f));
  mValuePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mValuePaint.setColor(Color.rgb(63,63,63));
  mValuePaint.setTextAlign(Align.CENTER);
  mValuePaint.setTextSize(Utils.convertDpToPixel(9f));
  mLegendFormPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLegendFormPaint.setStyle(Paint.Style.FILL);
  mLegendFormPaint.setStrokeWidth(3f);
  mLegendLabelPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mLegendLabelPaint.setTextSize(Utils.convertDpToPixel(9f));
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}",0.9299410029498524
26959,"/** 
 * Returns the rectangle that defines the borders of the chart-value surface (into which the actual values are drawn).
 * @return
 */
public Rect getContentRect(){
  return mContentRect;
}","/** 
 * Returns the rectangle that defines the borders of the chart-value surface (into which the actual values are drawn).
 * @return
 */
public RectF getContentRect(){
  return mContentRect;
}",0.9974160206718348
26960,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX)     drawMarkerView(xIndex,mIndicesToHightlight[i].getDataSetIndex());
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    int dataSetIndex=mIndicesToHightlight[i].getDataSetIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX) {
      Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
      if (e == null)       continue;
      float[] pos=getMarkerPosition(e,dataSetIndex);
      mMarkerView.refreshContent(e,dataSetIndex);
      mMarkerView.draw(mDrawCanvas,pos[0],pos[1]);
    }
  }
}",0.6623616236162362
26961,"/** 
 * returns the center point of the chart in pixels
 * @return
 */
public PointF getCenter(){
  return new PointF(getWidth() / 2,getHeight() / 2);
}","/** 
 * returns the center point of the chart in pixels
 * @return
 */
public PointF getCenter(){
  return new PointF(getWidth() / 2f,getHeight() / 2f);
}",0.9934640522875816
26962,"@Override protected void prepareContentRect(){
  super.prepareContentRect();
  float width=mContentRect.width() + mOffsetLeft + mOffsetRight;
  float height=mContentRect.height() + mOffsetTop + mOffsetBottom;
  float diameter=getDiameter();
  float shift=((PieData)mCurrentData).getDataSet().getSelectionShift();
  mCircleBox.set(width / 2 - diameter / 2 + shift,height / 2 - diameter / 2 + shift,width / 2 + diameter / 2 - shift,height / 2 + diameter / 2 - shift);
}","@Override protected void prepareContentRect(){
  super.prepareContentRect();
  if (mDataNotSet)   return;
  float width=mContentRect.width() + mOffsetLeft + mOffsetRight;
  float height=mContentRect.height() + mOffsetTop + mOffsetBottom;
  float diameter=getDiameter();
  float shift=((PieData)mCurrentData).getDataSet().getSelectionShift();
  mCircleBox.set(width / 2 - diameter / 2 + shift,height / 2 - diameter / 2 + shift,width / 2 + diameter / 2 - shift,height / 2 + diameter / 2 - shift);
}",0.9698857736240912
26963,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_draw_chart);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setOnDrawListener(this);
  mChart.setDrawingEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setHighlightEnabled(true);
  mChart.setAutoFinish(false);
  mChart.setDrawLegend(false);
  initWithDummyData();
  mChart.setYRange(-40f,40f,true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_draw_chart);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setOnDrawListener(this);
  mChart.setDrawingEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setHighlightEnabled(true);
  mChart.setAutoFinish(false);
  mChart.setDrawLegend(false);
  initWithDummyData();
  mChart.setYRange(-40f,40f,true);
}",0.9961210240496507
26964,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(false);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9958819492107068
26965,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9982499124956248
26966,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(false);
  mSeekBarX.setProgress(20);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setDrawYValues(false);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragScaleEnabled(true);
  mChart.setPinchZoom(false);
  mSeekBarX.setProgress(20);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}",0.9973219068023568
26967,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setDragEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_scatterchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(ScatterChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDrawYValues(false);
  mChart.setDragScaleEnabled(true);
  mChart.setMaxVisibleValueCount(200);
  mChart.setPinchZoom(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
}",0.9974424552429668
26968,"/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  if (mDataNotSet) {
    Log.i(LOG_TAG,""String_Node_Str"");
    return null;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,(float)yTouchVal,dataSetIndex);
}","/** 
 * returns the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point.
 * @param x
 * @param y
 * @return
 */
public Highlight getHighlightByTouchPoint(float x,float y){
  float[] pts=new float[2];
  pts[0]=x;
  pts[1]=y;
  Matrix tmp=new Matrix();
  mMatrixOffset.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixTouch.invert(tmp);
  tmp.mapPoints(pts);
  mMatrixValueToPx.invert(tmp);
  tmp.mapPoints(pts);
  double xTouchVal=pts[0];
  double yTouchVal=pts[1];
  double base=Math.floor(xTouchVal);
  double touchOffset=mDeltaX * 0.025;
  if ((this instanceof LineChart || this instanceof ScatterChart) && (xTouchVal < -touchOffset || xTouchVal > mDeltaX + touchOffset))   return null;
  if (this instanceof BarChart && (xTouchVal < 0 || xTouchVal > mDeltaX))   return null;
  if (base < 0)   base=0;
  if (base >= mDeltaX)   base=mDeltaX - 1;
  int xIndex=(int)base;
  int dataSetIndex=0;
  if (this instanceof LineChart || this instanceof ScatterChart) {
    if (xTouchVal - base > 0.5) {
      xIndex=(int)base + 1;
    }
  }
  if (mDataNotSet) {
    Log.i(LOG_TAG,""String_Node_Str"");
    return null;
  }
  ArrayList<SelInfo> valsAtIndex=getYValsAtIndex(xIndex);
  dataSetIndex=getClosestDataSetIndex(valsAtIndex,(float)yTouchVal);
  if (dataSetIndex == -1)   return null;
  return new Highlight(xIndex,dataSetIndex);
}",0.9938338774029742
26969,"/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    if (xIndex < mCurrentData.getXVals().size() && xIndex < mDeltaX * mPhaseX)     drawMarkerView(xIndex,mIndicesToHightlight[i].getDataSetIndex());
  }
}","/** 
 * draws all MarkerViews on the highlighted positions
 */
protected void drawMarkers(){
  if (mMarkerView == null || !mDrawMarkerViews || !valuesToHighlight())   return;
  for (int i=0; i < mIndicesToHightlight.length; i++) {
    int xIndex=mIndicesToHightlight[i].getXIndex();
    if (xIndex <= mDeltaX && xIndex <= mDeltaX * mPhaseX)     drawMarkerView(xIndex,mIndicesToHightlight[i].getDataSetIndex());
  }
}",0.9566236811254396
26970,"/** 
 * Draws the view that is displayed when a value is highlighted.
 * @param xIndex the selected x-index
 * @param dataSetIndex the index of the selected DataSet
 */
private void drawMarkerView(int xIndex,int dataSetIndex){
  Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
  if (e == null)   return;
  float xPos=(float)xIndex;
  if (this instanceof BarChart || this instanceof CandleStickChart)   xPos+=0.5f;
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  float posX=pts[0];
  float posY=pts[1];
  mMarkerView.refreshContent(e,dataSetIndex);
  mMarkerView.draw(mDrawCanvas,posX,posY);
}","/** 
 * Draws the view that is displayed when a value is highlighted.
 * @param xIndex the selected x-index
 * @param dataSetIndex the index of the selected DataSet
 */
private void drawMarkerView(int xIndex,int dataSetIndex){
  Entry e=getEntryByDataSetIndex(xIndex,dataSetIndex);
  if (e == null) {
    return;
  }
  float xPos=(float)xIndex;
  if (this instanceof BarChart || this instanceof CandleStickChart)   xPos+=0.5f;
  float[] pts=new float[]{xPos,e.getVal() * mPhaseY};
  transformPointArray(pts);
  float posX=pts[0];
  float posY=pts[1];
  mMarkerView.refreshContent(e,dataSetIndex);
  mMarkerView.draw(mDrawCanvas,posX,posY);
}",0.9937205651491364
26971,"/** 
 * Returns the first Entry object found at the given xIndex. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Entry getEntryForXIndex(int xIndex){
  for (int i=0; i < mYVals.size(); i++) {
    if (xIndex == mYVals.get(i).getXIndex())     return mYVals.get(i);
  }
  return null;
}","/** 
 * Returns the first Entry object found at the given xIndex with binary search. Returns null if no Entry object at that index. INFORMATION: This method does calculations at runtime. Do not over-use in performance critical situations.
 * @param xIndex
 * @return
 */
public Entry getEntryForXIndex(int x){
  int low=0;
  int high=mYVals.size();
  while (low <= high) {
    int m=(high + low) / 2;
    if (x == mYVals.get(m).getXIndex()) {
      return mYVals.get(m);
    }
    if (x > mYVals.get(m).getXIndex())     low=m + 1;
 else     high=m - 1;
  }
  return null;
}",0.7584830339321357
26972,"@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  LineData data=null;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POSTZOOM;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
 else if (mTouchMode == LONGPRESS) {
mChart.disableScroll();
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}","@Override public boolean onTouch(View v,MotionEvent event){
  if (mTouchMode == NONE) {
    mGestureDetector.onTouchEvent(event);
  }
  if (!mChart.isDragScaleEnabled() && !mDrawingEnabled)   return true;
  mDrawingContext.init(mChart.getDrawListener(),mChart.isAutoFinishEnabled());
  LineData data=null;
switch (event.getAction() & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (event.getPointerCount() == 1 && mDrawingEnabled) {
      if (mLastHighlighted != null) {
        Entry highlightedEntry=mChart.getDataCurrent().getEntryForHighlight(mLastHighlighted);
        Entry currentHoveredEntry=mChart.getEntryByTouchPoint(event.getX(),event.getY());
        if (highlightedEntry != null && highlightedEntry == currentHoveredEntry) {
          mTouchMode=MOVE_POINT;
          mDrawingContext.setMovingEntry(currentHoveredEntry);
          break;
        }
      }
      mTouchMode=DRAWING;
      mStartTimestamp=System.currentTimeMillis();
      mDrawingContext.createNewDrawingDataSet(data);
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      mSavedMatrix.set(mMatrix);
    }
  mTouchStartPoint.set(event.getX(),event.getY());
break;
case MotionEvent.ACTION_POINTER_DOWN:
if (event.getPointerCount() == 2) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if ((mTouchMode == DRAWING && deltaT < 1000) || !mDrawingEnabled) {
  mDrawingContext.deleteLastDrawingEntry(data);
  mSavedXDist=getXDist(event);
  mSavedYDist=getYDist(event);
  mSavedDist=spacing(event);
  if (mSavedDist > 10f) {
    if (mChart.isPinchZoomEnabled()) {
      mTouchMode=PINCH_ZOOM;
    }
 else {
      if (mSavedXDist > mSavedYDist)       mTouchMode=X_ZOOM;
 else       mTouchMode=Y_ZOOM;
    }
    mSavedMatrix.set(mMatrix);
    midPoint(mTouchPointCenter,event);
    mChart.disableScroll();
  }
}
}
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (mTouchMode == DRAWING) {
long deltaT=System.currentTimeMillis() - mStartTimestamp;
if (deltaT < 1000 && Math.abs(event.getX() - mTouchStartPoint.x) < 25f) {
mDrawingContext.deleteLastDrawingEntry(data);
onSingleTapConfirmed(event);
Log.i(""String_Node_Str"",""String_Node_Str"");
}
 else {
mDrawingContext.finishNewDrawingEntry(data);
mChart.notifyDataSetChanged();
Log.i(""String_Node_Str"",""String_Node_Str"");
}
}
 else {
mChart.enableScroll();
}
mDrawingContext.setMovingEntry(null);
mTouchMode=NONE;
break;
case MotionEvent.ACTION_POINTER_UP:
mTouchMode=POSTZOOM;
break;
case MotionEvent.ACTION_MOVE:
if (mTouchMode == DRAWING || mTouchMode == MOVE_POINT) {
PointD p=mChart.getValuesByTouchPoint(event.getX(),event.getY());
int xIndex=(int)p.x;
float yVal=(float)p.y;
if (xIndex < 0) xIndex=0;
if (xIndex >= data.getXValCount()) {
xIndex=data.getXValCount() - 1;
}
boolean added=false;
if (mTouchMode == MOVE_POINT) {
mDrawingContext.getMovingEntry().setVal(yVal);
mDrawingContext.notifyEntryMoved(data);
added=true;
}
 else {
Entry entry=new Entry((float)yVal,xIndex);
added=mDrawingContext.addNewDrawingEntry(entry,data);
}
if (added) {
mChart.notifyDataSetChanged();
}
}
 else if (((mTouchMode == NONE && !mDrawingEnabled) || (mTouchMode != DRAG && event.getPointerCount() == 3)) && Math.abs(distance(event.getX(),mTouchStartPoint.x,event.getY(),mTouchStartPoint.y)) > 25f) {
mSavedMatrix.set(mMatrix);
mTouchStartPoint.set(event.getX(),event.getY());
mTouchMode=DRAG;
mChart.disableScroll();
}
 else if (mTouchMode == DRAG) {
mMatrix.set(mSavedMatrix);
PointF dragPoint=new PointF(event.getX(),event.getY());
if (!mChart.isInvertYAxisEnabled()) {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,dragPoint.y - mTouchStartPoint.y);
}
 else {
mMatrix.postTranslate(dragPoint.x - mTouchStartPoint.x,-(dragPoint.y - mTouchStartPoint.y));
}
}
 else if (mTouchMode == X_ZOOM || mTouchMode == Y_ZOOM || mTouchMode == PINCH_ZOOM) {
float totalDist=spacing(event);
if (totalDist > 10f) {
PointF t=getTrans(mTouchPointCenter.x,mTouchPointCenter.y);
if (mTouchMode == PINCH_ZOOM) {
float scale=totalDist / mSavedDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scale,scale,t.x,t.y);
}
 else if (mTouchMode == X_ZOOM) {
float xDist=getXDist(event);
float scaleX=xDist / mSavedXDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(scaleX,1f,t.x,t.y);
}
 else if (mTouchMode == Y_ZOOM) {
float yDist=getYDist(event);
float scaleY=yDist / mSavedYDist;
mMatrix.set(mSavedMatrix);
mMatrix.postScale(1f,scaleY,t.x,t.y);
}
}
}
 else if (mTouchMode == LONGPRESS) {
mChart.disableScroll();
}
break;
}
mMatrix=mChart.refreshTouch(mMatrix);
return true;
}",0.9994490358126722
26973,"@Override public boolean onSingleTapUp(MotionEvent e){
  float distance=mChart.distanceToCenter(e.getX(),e.getY());
  if (distance < mChart.getRadius() / 2 || distance > mChart.getRadius()) {
    mChart.highlightValues(null);
    mLastHighlight=null;
  }
 else {
    int index=mChart.getIndexForAngle(mChart.getAngleForPoint(e.getX(),e.getY()));
    int dataSetIndex=mChart.getDataSetIndexForIndex(index);
    Highlight h=new Highlight(index,0f,dataSetIndex);
    if (h.equalTo(mLastHighlight)) {
      mChart.highlightTouch(null);
      mLastHighlight=null;
    }
 else {
      mChart.highlightTouch(h);
      mLastHighlight=h;
    }
  }
  return true;
}","@Override public boolean onSingleTapUp(MotionEvent e){
  float distance=mChart.distanceToCenter(e.getX(),e.getY());
  if (distance < mChart.getRadius() / 2 || distance > mChart.getRadius()) {
    mChart.highlightValues(null);
    mLastHighlight=null;
  }
 else {
    int index=mChart.getIndexForAngle(mChart.getAngleForPoint(e.getX(),e.getY()));
    int dataSetIndex=mChart.getDataSetIndexForIndex(index);
    Highlight h=new Highlight(index,dataSetIndex);
    if (h.equalTo(mLastHighlight)) {
      mChart.highlightTouch(null);
      mLastHighlight=null;
    }
 else {
      mChart.highlightTouch(h);
      mLastHighlight=h;
    }
  }
  return true;
}",0.9671002295332825
26974,"/** 
 * constructor
 * @param x the index of the highlighted value on the x-axis
 * @param val the value at the position the user touched
 * @param dataSet the index of the DataSet the highlighted value belongs to
 */
public Highlight(int x,float val,int dataSet){
  this.mXIndex=x;
  this.mVal=val;
  this.mDataSetIndex=dataSet;
}","/** 
 * constructor
 * @param x the index of the highlighted value on the x-axis
 * @param val the value at the position the user touched
 * @param dataSet the index of the DataSet the highlighted value belongs to
 */
public Highlight(int x,int dataSet){
  this.mXIndex=x;
  this.mDataSetIndex=dataSet;
}",0.8976377952755905
26975,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawHorizontalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(0);
  mChart.setDrawYLabels(false);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(10);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_candlechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(CandleStickChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setUnit(""String_Node_Str"");
  mChart.setDescription(""String_Node_Str"");
  mChart.setMaxVisibleValueCount(60);
  mChart.setPinchZoom(false);
  mChart.setDrawVerticalGrid(false);
  mChart.setDrawGridBackground(false);
  XLabels xLabels=mChart.getXLabels();
  xLabels.setPosition(XLabelPosition.BOTTOM);
  xLabels.setCenterXLabelText(true);
  xLabels.setSpaceBetweenLabels(2);
  mChart.setDrawYLabels(true);
  mChart.setDrawLegend(false);
  mSeekBarX.setProgress(30);
  mSeekBarY.setProgress(100);
}",0.9547432550043516
26976,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<CandleEntry> yVals1=new ArrayList<CandleEntry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.sin(i) * mult) + 100f;
    yVals1.add(new CandleEntry(i,val + 7,val - 7,val + 4,val - 4));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add((int)yVals1.get(i).getVal() + ""String_Node_Str"" + mChart.getUnit());
  }
  CandleDataSet set1=new CandleDataSet(yVals1,""String_Node_Str"");
  set1.setColors(ColorTemplate.createColors(getApplicationContext(),ColorTemplate.VORDIPLOM_COLORS));
  CandleData data=new CandleData(xVals,set1);
  mChart.setData(data);
  mChart.invalidate();
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  tvX.setText(""String_Node_Str"" + (mSeekBarX.getProgress() + 1));
  tvY.setText(""String_Node_Str"" + (mSeekBarY.getProgress()));
  ArrayList<CandleEntry> yVals1=new ArrayList<CandleEntry>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    float mult=(mSeekBarY.getProgress() + 1);
    float val=(float)(Math.sin(i) * mult) + 400f;
    boolean even=i % 2 == 0;
    yVals1.add(new CandleEntry(i,even ? val + 10 : val - 10,even ? val - 10 : val + 10,even ? val + 5 : val - 5,even ? val - 5 : val + 5));
  }
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < mSeekBarX.getProgress() + 1; i++) {
    xVals.add(""String_Node_Str"" + (i + 1));
  }
  CandleDataSet set1=new CandleDataSet(yVals1,""String_Node_Str"");
  set1.setColors(ColorTemplate.createColors(getApplicationContext(),ColorTemplate.VORDIPLOM_COLORS));
  CandleData data=new CandleData(xVals,set1);
  mChart.setData(data);
  mChart.invalidate();
}",0.9059656218402428
26977,"/** 
 * setup the x-axis labels
 */
protected void prepareXLabels(){
  StringBuffer a=new StringBuffer();
  for (int i=0; i < mCurrentData.getXValAverageLength() + mXLabels.getSpaceBetweenLabels(); i++) {
    a.append(""String_Node_Str"");
  }
  mXLabels.mXLabelWidth=Utils.calcTextWidth(mXLabelPaint,a.toString());
  mXLabels.mXLabelHeight=Utils.calcTextWidth(mXLabelPaint,""String_Node_Str"");
}","/** 
 * setup the x-axis labels
 */
protected void prepareXLabels(){
  StringBuffer a=new StringBuffer();
  int max=(int)Math.round(mCurrentData.getXValAverageLength() + mXLabels.getSpaceBetweenLabels());
  for (int i=0; i < max; i++) {
    a.append(""String_Node_Str"");
  }
  mXLabels.mLabelWidth=Utils.calcTextWidth(mXLabelPaint,a.toString());
  mXLabels.mLabelHeight=Utils.calcTextWidth(mXLabelPaint,""String_Node_Str"");
}",0.7892156862745098
26978,"/** 
 * calculates the modulus for x-labels and grid
 */
protected void calcModulus(){
  float[] values=new float[9];
  mMatrixTouch.getValues(values);
  mXLabels.mXAxisLabelModulus=(int)Math.ceil((mCurrentData.getXValCount() * mXLabels.mXLabelWidth) / (mContentRect.width() * values[Matrix.MSCALE_X]));
}","/** 
 * calculates the modulus for x-labels and grid
 */
protected void calcModulus(){
  float[] values=new float[9];
  mMatrixTouch.getValues(values);
  mXLabels.mXAxisLabelModulus=(int)Math.ceil((mCurrentData.getXValCount() * mXLabels.mLabelWidth) / (mContentRect.width() * values[Matrix.MSCALE_X]));
}",0.9983579638752051
26979,"@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=(ArrayList<CandleDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.FILL);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<CandleEntry> entries=(ArrayList<CandleEntry>)dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
    float[] shadowPoints=new float[4];
    float[] bodyPoints=new float[4];
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      CandleEntry e=entries.get(j);
      transformShadow(shadowPoints,e);
      transformBody(bodyPoints,e,dataSet.getBodySpace());
      float xShadow=shadowPoints[0];
      float leftBody=bodyPoints[0];
      float rightBody=bodyPoints[2];
      float high=shadowPoints[1];
      float low=shadowPoints[3];
      float open=bodyPoints[1];
      float close=bodyPoints[3];
      if (isOffContentRight(leftBody))       break;
      if (isOffContentLeft(rightBody) && isOffContentTop(low) && isOffContentBottom(high))       continue;
      mDrawCanvas.drawLine(xShadow,low,xShadow,high,mRenderPaint);
      mDrawCanvas.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}","@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=(ArrayList<CandleDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<CandleEntry> entries=(ArrayList<CandleEntry>)dataSet.getYVals();
    mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());
    float[] shadowPoints=new float[4];
    float[] bodyPoints=new float[4];
    for (int j=0; j < entries.size() * mPhaseX; j++) {
      mRenderPaint.setColor(dataSet.getColor(j));
      CandleEntry e=entries.get(j);
      transformShadow(shadowPoints,e);
      transformBody(bodyPoints,e,dataSet.getBodySpace());
      float xShadow=shadowPoints[0];
      float leftBody=bodyPoints[0];
      float rightBody=bodyPoints[2];
      float high=shadowPoints[1];
      float low=shadowPoints[3];
      float open=bodyPoints[1];
      float close=bodyPoints[3];
      if (isOffContentRight(leftBody))       break;
      if (isOffContentLeft(rightBody) && isOffContentTop(low) && isOffContentBottom(high))       continue;
      mDrawCanvas.drawLine(xShadow,low,xShadow,high,mRenderPaint);
      if (open > close)       mRenderPaint.setStyle(Paint.Style.FILL);
 else       mRenderPaint.setStyle(Paint.Style.STROKE);
      mDrawCanvas.drawRect(leftBody,open,rightBody,close,mRenderPaint);
    }
  }
}",0.1891378655526016
26980,"/** 
 * calculates the average length (in characters) across all x-value strings
 */
private void calcXValAverageLength(){
  if (mXVals.size() == 0) {
    mXValAverageLength=1;
    return;
  }
  int sum=0;
  for (int i=0; i < mXVals.size(); i++) {
    sum+=mXVals.get(i).length();
  }
  mXValAverageLength=sum / mXVals.size();
}","/** 
 * calculates the average length (in characters) across all x-value strings
 */
private void calcXValAverageLength(){
  if (mXVals.size() == 0) {
    mXValAverageLength=1;
    return;
  }
  float sum=0f;
  for (int i=0; i < mXVals.size(); i++) {
    sum+=mXVals.get(i).length();
  }
  mXValAverageLength=sum / (float)mXVals.size();
}",0.978978978978979
26981,"/** 
 * returns the average length (in characters) across all values in the x-vals array
 * @return
 */
public int getXValAverageLength(){
  return mXValAverageLength;
}","/** 
 * returns the average length (in characters) across all values in the x-vals array
 * @return
 */
public float getXValAverageLength(){
  return mXValAverageLength;
}",0.9823529411764704
26982,"@Override protected void init(){
  super.init();
  mFilledPaint=new Paint();
  mFilledPaint.setStyle(Paint.Style.FILL);
  mFilledPaint.setColor(mColorDarkBlue);
  mFilledPaint.setAlpha(130);
  mCirclePaintInner=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCirclePaintInner.setStyle(Paint.Style.FILL);
  mCirclePaintInner.setColor(Color.WHITE);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}","@Override protected void init(){
  super.init();
  mCirclePaintInner=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCirclePaintInner.setStyle(Paint.Style.FILL);
  mCirclePaintInner.setColor(Color.WHITE);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}",0.8442982456140351
26983,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(85);
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setColor(dataSet.getFillColor());
      mRenderPaint.setAlpha(dataSet.getFillAlpha());
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}",0.9801801801801802
26984,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(true);
  mChart.setDrawYValues(true);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setInvertYAxisEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  XLabels xl=mChart.getXLabels();
  xl.setAvoidFirstLastClipping(true);
  setData(25,50);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.9746121297602256
26985,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setLineWidth(1.5f);
  set1.setCircleSize(4f);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i % 30) + ""String_Node_Str"" + (i % 12)+ ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.setLineWidth(1.5f);
  set1.setCircleSize(4f);
  LineData data=new LineData(xVals,set1);
  mChart.setData(data);
}",0.9657594381035997
26986,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setTouchEnabled(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_piechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(PieChart)findViewById(R.id.chart1);
  Typeface tf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  mChart.setValueTypeface(tf);
  mChart.setCenterTextTypeface(Typeface.createFromAsset(getAssets(),""String_Node_Str""));
  mChart.setHoleRadius(60f);
  mChart.setDescription(""String_Node_Str"");
  mChart.setDrawYValues(true);
  mChart.setDrawCenterText(true);
  mChart.setDrawHoleEnabled(true);
  mChart.setDrawXValues(true);
  mChart.setUsePercentValues(true);
  mChart.setOnChartValueSelectedListener(this);
  mSeekBarX.setProgress(3);
  mSeekBarY.setProgress(100);
  mChart.animateXY(1500,1500);
  Legend l=mChart.getLegend();
  l.setPosition(LegendPosition.RIGHT_OF_CHART);
  l.setXEntrySpace(7f);
  l.setYEntrySpace(5f);
}",0.9876256767208044
26987,"/** 
 * draws the x-labels on the specified y-position
 * @param yPos
 */
private void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=0.5f;
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      mDrawCanvas.drawText(mCurrentData.getXVals().get(i),position[0],yPos,mXLabelPaint);
    }
  }
}","/** 
 * draws the x-labels on the specified y-position
 * @param yPos
 */
private void drawXLabels(float yPos){
  float[] position=new float[]{0f,0f};
  for (int i=0; i < mCurrentData.getXValCount(); i+=mXLabels.mXAxisLabelModulus) {
    position[0]=i;
    if (mXLabels.isCenterXLabelsEnabled())     position[0]+=0.5f;
    transformPointArray(position);
    if (position[0] >= mOffsetLeft && position[0] <= getWidth() - mOffsetRight) {
      String label=mCurrentData.getXVals().get(i);
      if (mXLabels.isAvoidFirstLastClippingEnabled()) {
        if (i == mCurrentData.getXValCount() - 1) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          if (width > getOffsetRight() * 2 && position[0] + width > getWidth())           position[0]-=width / 2;
        }
 else         if (i == 0) {
          float width=Utils.calcTextWidth(mXLabelPaint,label);
          position[0]+=width / 2;
        }
      }
      mDrawCanvas.drawText(label,position[0],yPos,mXLabelPaint);
    }
  }
}",0.659297789336801
26988,"@Override protected void drawData(){
}","@Override protected void drawData(){
  ArrayList<CandleDataSet> dataSets=(ArrayList<CandleDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    CandleDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
      mRenderPaint.setColor(dataSet.getColor(j / 2));
      if (isOffContentRight(valuePoints[j]))       break;
      if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))       continue;
      mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
    }
  }
}",0.085201793721973
26989,"@Override public boolean onTouchEvent(MotionEvent event){
  return mListener.onTouch(this,event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (mTouchEnabled && mListener != null)   return mListener.onTouch(this,event);
 else   return super.onTouchEvent(event);
}",0.7021276595744681
26990,"@Override protected void init(){
  super.init();
  mFilledPaint=new Paint();
  mFilledPaint.setStyle(Paint.Style.FILL);
  mFilledPaint.setColor(mColorDarkBlue);
  mFilledPaint.setAlpha(130);
  mCirclePaintInner=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCirclePaintInner.setStyle(Paint.Style.FILL);
  mCirclePaintInner.setColor(Color.WHITE);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}","@Override protected void init(){
  super.init();
  mCirclePaintInner=new Paint(Paint.ANTI_ALIAS_FLAG);
  mCirclePaintInner.setStyle(Paint.Style.FILL);
  mCirclePaintInner.setColor(Color.WHITE);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setStyle(Paint.Style.STROKE);
  mHighlightPaint.setStrokeWidth(2f);
  mHighlightPaint.setColor(Color.rgb(255,187,115));
}",0.8442982456140351
26991,"/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setAlpha(85);
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}","/** 
 * draws the given y values to the screen
 */
@Override protected void drawData(){
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  mRenderPaint.setStyle(Paint.Style.STROKE);
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    ArrayList<? extends Entry> entries=dataSet.getYVals();
    float[] valuePoints=generateTransformedValues(entries,0f);
    mRenderPaint.setStrokeWidth(dataSet.getLineWidth());
    mRenderPaint.setPathEffect(dataSet.getDashPathEffect());
    if (mDrawCubic) {
      mRenderPaint.setColor(dataSet.getColor(i));
      Path spline=new Path();
      spline.moveTo(entries.get(0).getXIndex(),entries.get(0).getVal());
      for (int x=1; x < entries.size() - 3; x+=2) {
        spline.cubicTo(entries.get(x).getXIndex(),entries.get(x).getVal(),entries.get(x + 1).getXIndex(),entries.get(x + 1).getVal(),entries.get(x + 2).getXIndex(),entries.get(x + 2).getVal());
      }
      transformPath(spline);
      mDrawCanvas.drawPath(spline,mRenderPaint);
    }
 else {
      for (int j=0; j < (valuePoints.length - 2) * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getColor(j / 2));
        if (isOffContentRight(valuePoints[j]))         break;
        if (j != 0 && isOffContentLeft(valuePoints[j - 1]) && isOffContentTop(valuePoints[j + 1]) && isOffContentBottom(valuePoints[j + 1]))         continue;
        mDrawCanvas.drawLine(valuePoints[j],valuePoints[j + 1],valuePoints[j + 2],valuePoints[j + 3],mRenderPaint);
      }
    }
    mRenderPaint.setPathEffect(null);
    if (dataSet.isDrawFilledEnabled() && entries.size() > 0) {
      mRenderPaint.setStyle(Paint.Style.FILL);
      mRenderPaint.setColor(dataSet.getFillColor());
      mRenderPaint.setAlpha(dataSet.getFillAlpha());
      Path filled=generateFilledPath(entries);
      transformPath(filled);
      mDrawCanvas.drawPath(filled,mRenderPaint);
      mRenderPaint.setAlpha(255);
    }
  }
}",0.9801801801801802
26992,"/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  mRenderPaint.setStyle(Paint.Style.FILL);
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (dataSet.isDrawCirclesEnabled()) {
      ArrayList<? extends Entry> entries=dataSet.getYVals();
      float[] positions=generateTransformedValues(entries,0f);
      for (int j=0; j < positions.length * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getCircleColor(j));
        if (isOffContentRight(positions[j]))         break;
        if (isOffContentLeft(positions[j]) || isOffContentTop(positions[j + 1]) || isOffContentBottom(positions[j + 1]))         continue;
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],dataSet.getCircleSize(),mRenderPaint);
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],dataSet.getCircleSize() / 2,mCirclePaintInner);
      }
    }
  }
}","/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  mRenderPaint.setStyle(Paint.Style.FILL);
  ArrayList<LineDataSet> dataSets=(ArrayList<LineDataSet>)mCurrentData.getDataSets();
  for (int i=0; i < mCurrentData.getDataSetCount(); i++) {
    LineDataSet dataSet=dataSets.get(i);
    if (dataSet.isDrawCirclesEnabled()) {
      ArrayList<? extends Entry> entries=dataSet.getYVals();
      float[] positions=generateTransformedValues(entries,0f);
      for (int j=0; j < positions.length * mPhaseX; j+=2) {
        mRenderPaint.setColor(dataSet.getCircleColor(j / 2));
        if (isOffContentRight(positions[j]))         break;
        if (isOffContentLeft(positions[j]) || isOffContentTop(positions[j + 1]) || isOffContentBottom(positions[j + 1]))         continue;
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],dataSet.getCircleSize(),mRenderPaint);
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],dataSet.getCircleSize() / 2,mCirclePaintInner);
      }
    }
  }
}",0.9980601357904948
26993,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setOnChartValueSelectedListener(this);
  mChart.setStartAtZero(false);
  mChart.setDrawYValues(false);
  mChart.setDrawBorder(true);
  mChart.setBorderPositions(new BorderPosition[]{BorderPosition.BOTTOM});
  mChart.setDescription(""String_Node_Str"");
  mChart.setNoDataTextDescription(""String_Node_Str"");
  mChart.setHighlightEnabled(true);
  mChart.setTouchEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setPinchZoom(true);
  MyMarkerView mv=new MyMarkerView(this,R.layout.custom_marker_view);
  mv.setOffsets(-mv.getMeasuredWidth() / 2,-mv.getMeasuredHeight());
  mChart.setMarkerView(mv);
  mChart.setHighlightIndicatorEnabled(false);
  setData(45,100);
  mChart.animateX(2500);
  Legend l=mChart.getLegend();
  l.setForm(LegendForm.LINE);
  mChart.invalidate();
}",0.99115670321896
26994,"private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  mChart.setData(data);
}","private void setData(int count,float range){
  ArrayList<String> xVals=new ArrayList<String>();
  for (int i=0; i < count; i++) {
    xVals.add((i) + ""String_Node_Str"");
  }
  ArrayList<Entry> yVals=new ArrayList<Entry>();
  for (int i=0; i < count; i++) {
    float mult=(range + 1);
    float val=(float)(Math.random() * mult) + 3;
    yVals.add(new Entry(val,i));
  }
  LineDataSet set1=new LineDataSet(yVals,""String_Node_Str"");
  set1.enableDashedLine(10f,5f,0f);
  set1.setLineWidth(1f);
  set1.setCircleSize(4f);
  ArrayList<LineDataSet> dataSets=new ArrayList<LineDataSet>();
  dataSets.add(set1);
  LineData data=new LineData(xVals,dataSets);
  LimitLine ll1=new LimitLine(130f);
  ll1.setLineWidth(4f);
  ll1.enableDashedLine(10f,10f,0f);
  LimitLine ll2=new LimitLine(-30f);
  ll2.setLineWidth(4f);
  ll2.enableDashedLine(10f,10f,0f);
  data.addLimitLine(ll1);
  data.addLimitLine(ll2);
  mChart.setData(data);
}",0.8460575719649562
26995,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_listview_chart);
  ListView lv=(ListView)findViewById(R.id.listView1);
  ArrayList<ChartData> list=new ArrayList<ChartData>();
  for (int i=0; i < 20; i++) {
    list.add(generateData(i + 1));
  }
  ChartDataAdapter cda=new ChartDataAdapter(getApplicationContext(),list);
  lv.setAdapter(cda);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_listview_chart);
  ListView lv=(ListView)findViewById(R.id.listView1);
  ArrayList<BarData> list=new ArrayList<BarData>();
  for (int i=0; i < 20; i++) {
    list.add(generateData(i + 1));
  }
  ChartDataAdapter cda=new ChartDataAdapter(getApplicationContext(),list);
  lv.setAdapter(cda);
}",0.9851576994434136
26996,"public ChartDataAdapter(Context context,List<ChartData> objects){
  super(context,0,objects);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
}","public ChartDataAdapter(Context context,List<BarData> objects){
  super(context,0,objects);
  mTf=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
}",0.9872611464968152
26997,"@Override public View getView(int position,View convertView,ViewGroup parent){
  ChartData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  BarData c=getItem(position);
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setValueTextColor(Color.WHITE);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(c);
  holder.chart.animateY(700);
  return convertView;
}",0.995880535530381
26998,"protected ChartData generateBarData(int dataSets,float range,int count){
  ArrayList<BarDataSet> sets=new ArrayList<BarDataSet>();
  for (int i=0; i < dataSets; i++) {
    ArrayList<Entry> entries=new ArrayList<Entry>();
    for (int j=0; j < count; j++) {
      entries.add(new Entry((float)(Math.random() * range) + range / 4,j));
    }
    BarDataSet ds=new BarDataSet(entries,getLabel(i));
    ds.setColors(ColorTemplate.VORDIPLOM_COLORS,getActivity());
    sets.add(ds);
  }
  BarData d=new BarData(ChartData.generateXVals(0,count),sets);
  return d;
}","protected BarData generateBarData(int dataSets,float range,int count){
  ArrayList<BarDataSet> sets=new ArrayList<BarDataSet>();
  for (int i=0; i < dataSets; i++) {
    ArrayList<Entry> entries=new ArrayList<Entry>();
    for (int j=0; j < count; j++) {
      entries.add(new Entry((float)(Math.random() * range) + range / 4,j));
    }
    BarDataSet ds=new BarDataSet(entries,getLabel(i));
    ds.setColors(ColorTemplate.VORDIPLOM_COLORS,getActivity());
    sets.add(ds);
  }
  BarData d=new BarData(ChartData.generateXVals(0,count),sets);
  return d;
}",0.9928057553956836
26999,"protected ChartData generateScatterData(int dataSets,float range,int count){
  ArrayList<ScatterDataSet> sets=new ArrayList<ScatterDataSet>();
  ScatterShape[] shapes=ScatterChart.getAllPossibleShapes();
  for (int i=0; i < dataSets; i++) {
    ArrayList<Entry> entries=new ArrayList<Entry>();
    for (int j=0; j < count; j++) {
      entries.add(new Entry((float)(Math.random() * range) + range / 4,j));
    }
    ScatterDataSet ds=new ScatterDataSet(entries,getLabel(i));
    ds.setScatterShapeSize(12f);
    ds.setScatterShape(shapes[i % shapes.length]);
    ds.setColors(ColorTemplate.COLORFUL_COLORS,getActivity());
    ds.setScatterShapeSize(9f);
    sets.add(ds);
  }
  ScatterData d=new ScatterData(ChartData.generateXVals(0,count),sets);
  return d;
}","protected ScatterData generateScatterData(int dataSets,float range,int count){
  ArrayList<ScatterDataSet> sets=new ArrayList<ScatterDataSet>();
  ScatterShape[] shapes=ScatterChart.getAllPossibleShapes();
  for (int i=0; i < dataSets; i++) {
    ArrayList<Entry> entries=new ArrayList<Entry>();
    for (int j=0; j < count; j++) {
      entries.add(new Entry((float)(Math.random() * range) + range / 4,j));
    }
    ScatterDataSet ds=new ScatterDataSet(entries,getLabel(i));
    ds.setScatterShapeSize(12f);
    ds.setScatterShape(shapes[i % shapes.length]);
    ds.setColors(ColorTemplate.COLORFUL_COLORS,getActivity());
    ds.setScatterShapeSize(9f);
    sets.add(ds);
  }
  ScatterData d=new ScatterData(ChartData.generateXVals(0,count),sets);
  return d;
}",0.9921259842519684
27000,"@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData(mChartData);
  holder.chart.animateY(700);
  return convertView;
}","@Override public View getView(int position,View convertView,Context c){
  ViewHolder holder=null;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=LayoutInflater.from(c).inflate(R.layout.list_item_barchart,null);
    holder.chart=(BarChart)convertView.findViewById(R.id.chart);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.chart.setValueTypeface(mTf);
  holder.chart.setDescription(""String_Node_Str"");
  holder.chart.setDrawVerticalGrid(false);
  holder.chart.setDrawGridBackground(false);
  holder.chart.setDrawBarShadow(false);
  XLabels xl=holder.chart.getXLabels();
  xl.setCenterXLabelText(true);
  xl.setPosition(XLabelPosition.BOTTOM);
  xl.setTypeface(mTf);
  YLabels yl=holder.chart.getYLabels();
  yl.setTypeface(mTf);
  yl.setLabelCount(5);
  holder.chart.setData((BarData)mChartData);
  holder.chart.animateY(700);
  return convertView;
}",0.9951482479784368
