record_number,buggy_code,fixed_code,code_similarity
182001,"/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}",0.9427509293680296
182002,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9851570590265792
182003,"/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}","/** 
 * Request audio focus. Send a request to obtain the audio focus for a specific stream type
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus requestis temporary, and focus will be abandonned shortly. Examples of transient requests are for the playback of driving directions, or notifications sounds. Use  {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok forthe previous focus owner to keep playing if it ducks its audio output. Use  {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration suchas the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */
public int requestAudioFocus(OnAudioFocusChangeListener l,int streamType,int durationHint){
  int status=AUDIOFOCUS_REQUEST_FAILED;
  if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)) {
    Log.e(TAG,""String_Node_Str"");
    return status;
  }
  registerAudioFocusListener(l);
  IAudioService service=getService();
  try {
    status=service.requestAudioFocus(streamType,durationHint,mICallBack,mAudioFocusDispatcher,getIdForAudioFocusListener(l));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
  return status;
}",0.9427509293680296
182004,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    removeFocusStackEntry(clientId,false);
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9851570590265792
182005,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}",0.9959746981023576
182006,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}",0.9959746981023576
182007,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}",0.9959746981023576
182008,"private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}","private void handleHeaders(Headers headers){
  if (mCancelled)   return;
  mHeaders=headers;
  long contentLength=headers.getContentLength();
  if (contentLength != Headers.NO_CONTENT_LENGTH) {
    mContentLength=contentLength;
  }
 else {
    mContentLength=0;
  }
  String contentType=headers.getContentType();
  if (contentType != null) {
    parseContentTypeHeader(contentType);
    if (mMimeType.equals(""String_Node_Str"") || mMimeType.equals(""String_Node_Str"")) {
      String contentDisposition=headers.getContentDisposition();
      String url=null;
      if (contentDisposition != null) {
        url=URLUtil.parseContentDisposition(contentDisposition);
      }
      if (url == null) {
        url=mUrl;
      }
      String newMimeType=guessMimeTypeFromExtension(url);
      if (newMimeType != null) {
        mMimeType=newMimeType;
      }
    }
 else     if (mMimeType.equals(""String_Node_Str"")) {
      mMimeType=""String_Node_Str"";
    }
 else {
      if (mMimeType.equals(""String_Node_Str"")) {
        mMimeType=""String_Node_Str"";
      }
    }
  }
 else {
    guessMimeType();
  }
  if (mIsMainPageLoader && mIsMainResourceLoader && mUserGesture&& Pattern.matches(XML_MIME_TYPE,mMimeType)) {
    Intent i=new Intent(Intent.ACTION_VIEW);
    i.setDataAndType(Uri.parse(url()),mMimeType);
    ResolveInfo info=mContext.getPackageManager().resolveActivity(i,PackageManager.MATCH_DEFAULT_ONLY);
    if (info != null && !mContext.getPackageName().equals(info.activityInfo.packageName)) {
      try {
        mContext.startActivity(i);
        mBrowserFrame.stopLoading();
        return;
      }
 catch (      ActivityNotFoundException ex) {
      }
    }
  }
  boolean mustAuthenticate=(mStatusCode == HTTP_AUTH || mStatusCode == HTTP_PROXY_AUTH);
  boolean isProxyAuthRequest=(mStatusCode == HTTP_PROXY_AUTH);
  mAuthFailed=false;
  if (mAuthHeader != null) {
    mAuthFailed=(mustAuthenticate && isProxyAuthRequest == mAuthHeader.isProxy());
    if (!mAuthFailed && mAuthHeader.isProxy()) {
      Network network=Network.getInstance(mContext);
      if (network.isValidProxySet()) {
synchronized (network) {
          network.setProxyUsername(mAuthHeader.getUsername());
          network.setProxyPassword(mAuthHeader.getPassword());
        }
      }
    }
  }
  mAuthHeader=null;
  if (mustAuthenticate) {
    if (mStatusCode == HTTP_AUTH) {
      mAuthHeader=parseAuthHeader(headers.getWwwAuthenticate());
    }
 else {
      mAuthHeader=parseAuthHeader(headers.getProxyAuthenticate());
      if (mAuthHeader != null) {
        mAuthHeader.setProxy();
      }
    }
  }
  if ((mStatusCode == HTTP_OK || mStatusCode == HTTP_FOUND || mStatusCode == HTTP_MOVED_PERMANENTLY || mStatusCode == HTTP_TEMPORARY_REDIRECT) && mNativeLoader != 0) {
    if (!mFromCache && mRequestHandle != null && (!mRequestHandle.getMethod().equals(""String_Node_Str"") || mPostIdentifier != 0)) {
      WebViewWorker.CacheCreateData data=new WebViewWorker.CacheCreateData();
      data.mListener=this;
      data.mUrl=mUrl;
      data.mMimeType=mMimeType;
      data.mStatusCode=mStatusCode;
      data.mPostId=mPostIdentifier;
      data.mHeaders=headers;
      WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_CREATE_CACHE,data).sendToTarget();
    }
    WebViewWorker.CacheEncoding ce=new WebViewWorker.CacheEncoding();
    ce.mEncoding=mEncoding;
    WebViewWorker.getHandler().obtainMessage(WebViewWorker.MSG_UPDATE_CACHE_ENCODING,ce).sendToTarget();
  }
  commitHeadersCheckRedirect();
}",0.9959746981023576
182009,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.9757785467128028
182010,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.9757785467128028
182011,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
    surfaceView.mSurfaceLock.lock();
    try {
      if (reportDraw) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mReportDrawNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
 else       if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
    }
  finally {
      surfaceView.mSurfaceLock.unlock();
    }
  }
}",0.5706840390879478
182012,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
case UPDATE_WINDOW_MSG:
{
updateWindow(false);
}
break;
}
}",0.8724279835390947
182013,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      if (mTranslator == null) {
        mSurfaceFrame.right=mWinFrame.width();
        mSurfaceFrame.bottom=mWinFrame.height();
      }
 else {
        float appInvertedScale=mTranslator.applicationInvertedScale;
        mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
        mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
      }
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
        if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (localLOGV)         Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || reportDrawNeeded) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}",0.6274159976211716
182014,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.9757785467128028
182015,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.9757785467128028
182016,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
    surfaceView.mSurfaceLock.lock();
    try {
      if (reportDraw) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mReportDrawNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
 else       if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
    }
  finally {
      surfaceView.mSurfaceLock.unlock();
    }
  }
}",0.5706840390879478
182017,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
case UPDATE_WINDOW_MSG:
{
updateWindow(false);
}
break;
}
}",0.8724279835390947
182018,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      if (mTranslator == null) {
        mSurfaceFrame.right=mWinFrame.width();
        mSurfaceFrame.bottom=mWinFrame.height();
      }
 else {
        float appInvertedScale=mTranslator.applicationInvertedScale;
        mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
        mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
      }
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
        if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (localLOGV)         Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || reportDrawNeeded) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}",0.6274159976211716
182019,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mLastDimWidth=dw;
      mLastDimHeight=dh;
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
 else   if (mLastDimWidth != dw || mLastDimHeight != dh) {
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mDimSurface.setSize(dw,dh);
  }
}",0.8225352112676056
182020,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}",0.9982547993019196
182021,"private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      index=i;
      break;
    }
  }
  return index;
}",0.9070631970260224
182022,"private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}","private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
 else {
    HistoryRecord r=topRunningActivityLocked(null);
    if (r.app == app) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
      int index=indexOfTokenLocked(r);
      finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      index--;
      if (index >= 0) {
        r=(HistoryRecord)mHistory.get(index);
        if (r.state == ActivityState.RESUMED || r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
          if (!r.isHomeActivity) {
            Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
            finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
        }
      }
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}",0.7864406779661017
182023,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mLastDimWidth=dw;
      mLastDimHeight=dh;
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
 else   if (mLastDimWidth != dw || mLastDimHeight != dh) {
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mDimSurface.setSize(dw,dh);
  }
}",0.8225352112676056
182024,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}",0.9982547993019196
182025,"private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      index=i;
      break;
    }
  }
  return index;
}",0.9070631970260224
182026,"private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}","private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
 else {
    HistoryRecord r=topRunningActivityLocked(null);
    if (r.app == app) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
      int index=indexOfTokenLocked(r);
      finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      index--;
      if (index >= 0) {
        r=(HistoryRecord)mHistory.get(index);
        if (r.state == ActivityState.RESUMED || r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
          if (!r.isHomeActivity) {
            Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
            finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
        }
      }
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}",0.7864406779661017
182027,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mLastDimWidth=dw;
      mLastDimHeight=dh;
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
 else   if (mLastDimWidth != dw || mLastDimHeight != dh) {
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mDimSurface.setSize(dw,dh);
  }
}",0.8225352112676056
182028,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}",0.9982547993019196
182029,"private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      index=i;
      break;
    }
  }
  return index;
}",0.9070631970260224
182030,"private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}","private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
 else {
    HistoryRecord r=topRunningActivityLocked(null);
    if (r.app == app) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
      int index=indexOfTokenLocked(r);
      finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      index--;
      if (index >= 0) {
        r=(HistoryRecord)mHistory.get(index);
        if (r.state == ActivityState.RESUMED || r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
          if (!r.isHomeActivity) {
            Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
            finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
        }
      }
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}",0.7864406779661017
182031,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.9757785467128028
182032,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.9757785467128028
182033,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mLastDimWidth=dw;
      mLastDimHeight=dh;
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
 else   if (mLastDimWidth != dw || mLastDimHeight != dh) {
    mLastDimWidth=dw;
    mLastDimHeight=dh;
    mDimSurface.setSize(dw,dh);
  }
}",0.8225352112676056
182034,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,int launchFlags,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE && (launchFlags & Intent.FLAG_ACTIVITY_SINGLE_TOP) == 0) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}",0.9982547993019196
182035,"private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      index=i;
      break;
    }
  }
  return index;
}",0.9070631970260224
182036,"private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}","private boolean handleAppCrashLocked(ProcessRecord app){
  long now=SystemClock.uptimeMillis();
  Long crashTime=mProcessCrashTimes.get(app.info.processName,app.info.uid);
  if (crashTime != null && now < crashTime + MIN_CRASH_INTERVAL) {
    Slog.w(TAG,""String_Node_Str"" + app.info.processName + ""String_Node_Str"");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.info.processName,app.info.uid);
    killServicesLocked(app,false);
    for (int i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.app == app) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
        finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      }
    }
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.info.uid,app.info.processName);
      mBadProcesses.put(app.info.processName,app.info.uid,now);
      app.bad=true;
      mProcessCrashTimes.remove(app.info.processName,app.info.uid);
      app.removed=true;
      removeProcessLocked(app,false);
      return false;
    }
  }
 else {
    HistoryRecord r=topRunningActivityLocked(null);
    if (r.app == app) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
      int index=indexOfTokenLocked(r);
      finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      index--;
      if (index >= 0) {
        r=(HistoryRecord)mHistory.get(index);
        if (r.state == ActivityState.RESUMED || r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
          if (!r.isHomeActivity) {
            Slog.w(TAG,""String_Node_Str"" + r.intent.getComponent().flattenToShortString());
            finishActivityLocked(r,index,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
        }
      }
    }
  }
  if (app.services.size() != 0) {
    Iterator it=app.services.iterator();
    while (it.hasNext()) {
      ServiceRecord sr=(ServiceRecord)it.next();
      sr.crashCount++;
    }
  }
  mProcessCrashTimes.put(app.info.processName,app.info.uid,now);
  return true;
}",0.7864406779661017
182037,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.9757785467128028
182038,"@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    postInvalidate();
  }
}","@Override public void computeScroll(){
  if (mScroller.computeScrollOffset()) {
    int oldX=mScrollX;
    int oldY=mScrollY;
    int x=mScroller.getCurrX();
    int y=mScroller.getCurrY();
    if (getChildCount() > 0) {
      View child=getChildAt(0);
      x=clamp(x,getWidth() - mPaddingRight - mPaddingLeft,child.getWidth());
      y=clamp(y,getHeight() - mPaddingBottom - mPaddingTop,child.getHeight());
      if (x != oldX || y != oldY) {
        mScrollX=x;
        mScrollY=y;
        onScrollChanged(x,y,oldX,oldY);
      }
    }
    awakenScrollBars();
    postInvalidate();
  }
}",0.9757785467128028
182039,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
    surfaceView.mSurfaceLock.lock();
    try {
      if (reportDraw) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mReportDrawNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
 else       if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
    }
  finally {
      surfaceView.mSurfaceLock.unlock();
    }
  }
}",0.5706840390879478
182040,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
case UPDATE_WINDOW_MSG:
{
updateWindow(false);
}
break;
}
}",0.8724279835390947
182041,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      if (mTranslator == null) {
        mSurfaceFrame.right=mWinFrame.width();
        mSurfaceFrame.bottom=mWinFrame.height();
      }
 else {
        float appInvertedScale=mTranslator.applicationInvertedScale;
        mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
        mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
      }
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
        if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (localLOGV)         Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || reportDrawNeeded) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}",0.6274159976211716
182042,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw,Configuration newConfig){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
    surfaceView.mSurfaceLock.lock();
    try {
      if (reportDraw) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mReportDrawNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
 else       if (surfaceView.mWinFrame.width() != w || surfaceView.mWinFrame.height() != h) {
        surfaceView.mUpdateWindowNeeded=true;
        surfaceView.mHandler.sendEmptyMessage(UPDATE_WINDOW_MSG);
      }
    }
  finally {
      surfaceView.mSurfaceLock.unlock();
    }
  }
}",0.5706840390879478
182043,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case KEEP_SCREEN_ON_MSG:
{
      setKeepScreenOn(msg.arg1 != 0);
    }
  break;
case GET_NEW_SURFACE_MSG:
{
  handleGetNewSurface();
}
break;
case UPDATE_WINDOW_MSG:
{
updateWindow(false);
}
break;
}
}",0.8724279835390947
182044,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      if (mTranslator == null) {
        mSurfaceFrame.right=mWinFrame.width();
        mSurfaceFrame.bottom=mWinFrame.height();
      }
 else {
        float appInvertedScale=mTranslator.applicationInvertedScale;
        mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
        mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
      }
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  ViewRoot viewRoot=(ViewRoot)getRootView().getParent();
  if (viewRoot != null) {
    mTranslator=viewRoot.mTranslator;
  }
  Resources res=getContext().getResources();
  if (mTranslator != null || !res.getCompatibilityInfo().supportsScreen()) {
    mSurface.setCompatibleDisplayMetrics(res.getDisplayMetrics(),mTranslator);
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      if (mTranslator != null) {
        mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
      }
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS| WindowManager.LayoutParams.FLAG_SCALED| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
        mLayout.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      }
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      boolean realSizeChanged;
      boolean reportDrawNeeded;
      mSurfaceLock.lock();
      try {
        mUpdateWindowNeeded=false;
        reportDrawNeeded=mReportDrawNeeded;
        mReportDrawNeeded=false;
        mDrawingStopped=!visible;
        final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mConfiguration,mSurface);
        if ((relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mReportDrawNeeded=true;
        }
        if (localLOGV)         Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
        mSurfaceFrame.left=0;
        mSurfaceFrame.top=0;
        if (mTranslator == null) {
          mSurfaceFrame.right=mWinFrame.width();
          mSurfaceFrame.bottom=mWinFrame.height();
        }
 else {
          float appInvertedScale=mTranslator.applicationInvertedScale;
          mSurfaceFrame.right=(int)(mWinFrame.width() * appInvertedScale + 0.5f);
          mSurfaceFrame.bottom=(int)(mWinFrame.height() * appInvertedScale + 0.5f);
        }
        final int surfaceWidth=mSurfaceFrame.right;
        final int surfaceHeight=mSurfaceFrame.bottom;
        realSizeChanged=mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
        mLastSurfaceWidth=surfaceWidth;
        mLastSurfaceHeight=surfaceHeight;
      }
  finally {
        mSurfaceLock.unlock();
      }
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged|| realSizeChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,myWidth,myHeight);
            }
          }
        }
 else {
          mSurface.release();
        }
      }
  finally {
        mIsCreating=false;
        if (creating || reportDrawNeeded) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}",0.6274159976211716
182045,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags|=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags&=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}",0.999546485260771
182046,"private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}","private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mSettings.mRenamedPackages.containsKey(pkgName)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ mSettings.mRenamedPackages.get(pkgName));
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}",0.869983948635634
182047,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags|=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags&=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}",0.999546485260771
182048,"private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}","private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mSettings.mRenamedPackages.containsKey(pkgName)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ mSettings.mRenamedPackages.get(pkgName));
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}",0.869983948635634
182049,"private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags|=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}","private void replaceNonSystemPackageLI(PackageParser.Package deletedPackage,PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  PackageParser.Package newPackage=null;
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  String oldInstallerPackageName=null;
synchronized (mPackages) {
    oldInstallerPackageName=mSettings.getInstallerPackageName(pkgName);
  }
  parseFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  if (!deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo)) {
    res.returnCode=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
    deletedPkg=false;
  }
 else {
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
    newPackage=scanPackageLI(pkg,parseFlags,scanMode);
    if (newPackage == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
      if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
        res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      }
    }
 else {
      updateSettingsLI(newPackage,installerPackageName,res);
      updatedSettings=true;
    }
  }
  if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
synchronized (mPackages) {
      verifySignaturesLP(mSettings.mPackages.get(pkgName),pkg,parseFlags,true);
    }
  }
 else {
    if (updatedSettings) {
      deletePackageLI(pkgName,true,PackageManager.DONT_DELETE_DATA,res.removedInfo);
    }
    if (deletedPkg) {
      File restoreFile=new File(deletedPackage.mPath);
      if (restoreFile == null) {
        Slog.e(TAG,""String_Node_Str"" + pkgName);
        return;
      }
      PackageInstalledInfo restoreRes=new PackageInstalledInfo();
      restoreRes.removedInfo=new PackageRemovedInfo();
      parseFlags&=~PackageManager.INSTALL_REPLACE_EXISTING;
      scanPackageLI(restoreFile,parseFlags,scanMode);
synchronized (mPackages) {
        updatePermissionsLP(deletedPackage.packageName,deletedPackage,true,false);
        mSettings.writeLP();
      }
      if (restoreRes.returnCode != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      }
    }
  }
}",0.999546485260771
182050,"private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}","private void installNewPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode,String installerPackageName,PackageInstalledInfo res){
  String pkgName=pkg.packageName;
  boolean dataDirExists=getDataPathForPackage(pkg).exists();
  res.name=pkgName;
synchronized (mPackages) {
    if (mSettings.mRenamedPackages.containsKey(pkgName)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ mSettings.mRenamedPackages.get(pkgName));
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
    if (mPackages.containsKey(pkgName) || mAppDirs.containsKey(pkg.mPath)) {
      Slog.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      res.returnCode=PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
      return;
    }
  }
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  PackageParser.Package newPackage=scanPackageLI(pkg,parseFlags,scanMode);
  if (newPackage == null) {
    Slog.w(TAG,""String_Node_Str"" + pkg.mPath);
    if ((res.returnCode=mLastScanError) == PackageManager.INSTALL_SUCCEEDED) {
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
    }
  }
 else {
    updateSettingsLI(newPackage,installerPackageName,res);
    if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
      deletePackageLI(pkgName,false,dataDirExists ? PackageManager.DONT_DELETE_DATA : 0,res.removedInfo);
    }
  }
}",0.869983948635634
182051,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}",0.982763788968825
182052,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}",0.982763788968825
182053,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}",0.982763788968825
182054,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mActivePointerId=ev.getPointerId(0);
      final int x=(int)ev.getX();
      final int y=(int)ev.getY();
      int motionPosition=pointToPosition(x,y);
      if (!mDataChanged) {
        if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
          mTouchMode=TOUCH_MODE_DOWN;
          if (mPendingCheckForTap == null) {
            mPendingCheckForTap=new CheckForTap();
          }
          postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
        }
 else {
          if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
            return false;
          }
          if (mTouchMode == TOUCH_MODE_FLING) {
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
      }
      if (motionPosition >= 0) {
        v=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=v.getTop();
      }
      mMotionX=x;
      mMotionY=y;
      mMotionPosition=motionPosition;
      mLastY=Integer.MIN_VALUE;
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    final int pointerIndex=ev.findPointerIndex(mActivePointerId);
    final int y=(int)ev.getY(pointerIndex);
    deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
      startScrollIfNeeded(deltaY);
    break;
case TOUCH_MODE_SCROLL:
  if (PROFILE_SCROLLING) {
    if (!mScrollProfilingStarted) {
      Debug.startMethodTracing(""String_Node_Str"");
      mScrollProfilingStarted=true;
    }
  }
if (y != mLastY) {
  deltaY-=mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int motionViewPrevTop=0;
  View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    motionViewPrevTop=motionView.getTop();
  }
  boolean atEdge=false;
  if (incrementalDeltaY != 0) {
    atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
  }
  motionView=this.getChildAt(mMotionPosition - mFirstPosition);
  if (motionView != null) {
    final int motionViewRealTop=motionView.getTop();
    if (atEdge) {
      invalidate();
    }
  }
  mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
  post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}",0.982763788968825
182055,"final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mHoldingConfiguration=false;
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9922383050136354
182056,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (!mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}",0.9998261776464452
182057,"private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (config != null && mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}","private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}",0.9655998630840322
182058,"final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mHoldingConfiguration=false;
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9922383050136354
182059,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (!mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}",0.9998261776464452
182060,"private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (config != null && mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}","private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}",0.9655998630840322
182061,"/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}","/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}",0.988095238095238
182062,"/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label;
    }
  }
  return ci.loadLabel(pm);
}","/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label.toString().trim();
    }
  }
  CharSequence data=ci.loadLabel(pm);
  if (data != null)   data=data.toString().trim();
  return data;
}",0.9402914903620122
182063,"final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(int flags){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    if (oldAction != null && (flags & UiModeManager.DISABLE_CAR_MODE_GO_HOME) != 0) {
      try {
        Intent intent=new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mHoldingConfiguration=false;
        updateConfigurationLocked(false);
        ActivityManagerNative.getDefault().startActivityWithConfig(null,intent,null,null,0,null,null,0,false,false,mConfiguration);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,e.getCause());
      }
    }
 else {
      updateConfigurationLocked(true);
    }
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9922383050136354
182064,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (!mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
private final boolean ensureActivityConfigurationLocked(HistoryRecord r,int globalChanges){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG,""String_Node_Str"" + r);
  Configuration newConfig=mConfiguration;
  if (r.configuration == newConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  Configuration oldConfig=r.configuration;
  r.configuration=newConfig;
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  if (!r.persistent) {
    int changes=oldConfig.diff(newConfig);
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
      Slog.v(TAG,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.configChanges)+ ""String_Node_Str""+ newConfig);
    }
    if ((changes & (~r.info.configChanges)) != 0) {
      r.configChangeFlags|=changes;
      r.startFreezingScreenLocked(r.app,globalChanges);
      if (r.app == null || r.app.thread == null) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        destroyActivityLocked(r,true);
      }
 else       if (r.state == ActivityState.PAUSING) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        r.configDestroy=true;
        return true;
      }
 else       if (r.state == ActivityState.RESUMED) {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,true);
        r.configChangeFlags=0;
      }
 else {
        if (DEBUG_SWITCH || DEBUG_CONFIGURATION)         Slog.v(TAG,""String_Node_Str"" + r);
        relaunchActivityLocked(r,r.configChangeFlags,false);
        r.configChangeFlags=0;
      }
      return false;
    }
  }
  if (r.app != null && r.app.thread != null) {
    try {
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"" + r);
      r.app.thread.scheduleActivityConfigurationChanged(r);
    }
 catch (    RemoteException e) {
    }
  }
  r.stopFreezingScreenLocked(false);
  return true;
}",0.9998261776464452
182065,"private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (config != null && mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}","private final int startActivityMayWait(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug,WaitResult outResult,Configuration config){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    mConfigWillChange=config != null && mConfiguration.diff(config) != 0;
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,""String_Node_Str"" + mConfigWillChange);
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    if (mConfigWillChange) {
      enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,""String_Node_Str"");
      mConfigWillChange=false;
      if (DEBUG_CONFIGURATION)       Slog.v(TAG,""String_Node_Str"");
      updateConfigurationLocked(config,null);
    }
    Binder.restoreCallingIdentity(origId);
    if (outResult != null) {
      outResult.result=res;
      if (res == IActivityManager.START_SUCCESS) {
        mWaitingActivityLaunched.add(outResult);
        do {
          try {
            wait();
          }
 catch (          InterruptedException e) {
          }
        }
 while (!outResult.timeout && outResult.who == null);
      }
 else       if (res == IActivityManager.START_TASK_TO_FRONT) {
        HistoryRecord r=this.topRunningActivityLocked(null);
        if (r.nowVisible) {
          outResult.timeout=false;
          outResult.who=new ComponentName(r.info.packageName,r.info.name);
          outResult.totalTime=0;
          outResult.thisTime=0;
        }
 else {
          outResult.thisTime=SystemClock.uptimeMillis();
          mWaitingActivityVisible.add(outResult);
          do {
            try {
              wait();
            }
 catch (            InterruptedException e) {
            }
          }
 while (!outResult.timeout && outResult.who == null);
        }
      }
    }
    return res;
  }
}",0.9655998630840322
182066,"/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}","/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}",0.988095238095238
182067,"/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label;
    }
  }
  return ci.loadLabel(pm);
}","/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label.toString().trim();
    }
  }
  CharSequence data=ci.loadLabel(pm);
  if (data != null)   data=data.toString().trim();
  return data;
}",0.9402914903620122
182068,"/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}","/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}",0.988095238095238
182069,"/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label;
    }
  }
  return ci.loadLabel(pm);
}","/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label.toString().trim();
    }
  }
  CharSequence data=ci.loadLabel(pm);
  if (data != null)   data=data.toString().trim();
  return data;
}",0.9402914903620122
182070,"/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}","/** 
 * Retrieve the current textual label associated with this item.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the item's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  if (labelRes != 0) {
    CharSequence label=pm.getText(packageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  if (name != null) {
    return name;
  }
  return packageName;
}",0.988095238095238
182071,"/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label;
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label;
    }
  }
  return ci.loadLabel(pm);
}","/** 
 * Retrieve the current textual label associated with this resolution.  This will call back on the given PackageManager to load the label from the application.
 * @param pm A PackageManager from which the label can be loaded; usuallythe PackageManager from which you originally retrieved this item.
 * @return Returns a CharSequence containing the resolutions's label.  If theitem does not have a label, its name is returned.
 */
public CharSequence loadLabel(PackageManager pm){
  if (nonLocalizedLabel != null) {
    return nonLocalizedLabel;
  }
  CharSequence label;
  if (resolvePackageName != null && labelRes != 0) {
    label=pm.getText(resolvePackageName,labelRes,null);
    if (label != null) {
      return label.toString().trim();
    }
  }
  ComponentInfo ci=activityInfo != null ? activityInfo : serviceInfo;
  ApplicationInfo ai=ci.applicationInfo;
  if (labelRes != 0) {
    label=pm.getText(ci.packageName,labelRes,ai);
    if (label != null) {
      return label.toString().trim();
    }
  }
  CharSequence data=ci.loadLabel(pm);
  if (data != null)   data=data.toString().trim();
  return data;
}",0.9402914903620122
182072,"private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.845299777942265
182073,"private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}","private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}",0.7389037263131121
182074,"public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
 else     if (data != null && data.getScheme() != null) {
      filter.addDataScheme(data.getScheme());
      Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
      if (aIt != null) {
        while (aIt.hasNext()) {
          IntentFilter.AuthorityEntry a=aIt.next();
          if (a.match(data) >= 0) {
            int port=a.getPort();
            filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
            break;
          }
        }
      }
      Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
      if (pIt != null) {
        String path=data.getPath();
        while (path != null && pIt.hasNext()) {
          PatternMatcher p=pIt.next();
          if (p.match(path)) {
            filter.addDataPath(p.getPath(),p.getType());
            break;
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}","public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}",0.9581916383276656
182075,"private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.845299777942265
182076,"private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}","private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}",0.7389037263131121
182077,"public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
 else     if (data != null && data.getScheme() != null) {
      filter.addDataScheme(data.getScheme());
      Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
      if (aIt != null) {
        while (aIt.hasNext()) {
          IntentFilter.AuthorityEntry a=aIt.next();
          if (a.match(data) >= 0) {
            int port=a.getPort();
            filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
            break;
          }
        }
      }
      Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
      if (pIt != null) {
        String path=data.getPath();
        while (path != null && pIt.hasNext()) {
          PatternMatcher p=pIt.next();
          if (p.match(path)) {
            filter.addDataPath(p.getPath(),p.getType());
            break;
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}","public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}",0.9581916383276656
182078,"private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private static void showUsage(){
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.845299777942265
182079,"private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}","private Intent makeIntent() throws URISyntaxException {
  Intent intent=new Intent();
  boolean hasIntentInfo=false;
  mDebugOption=false;
  mWaitOption=false;
  Uri data=null;
  String type=null;
  String opt;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      intent.setAction(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      data=Uri.parse(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      type=nextArgRequired();
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addCategory(nextArgRequired());
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"") || opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,value);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      intent.putExtra(key,(String)null);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Integer.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String key=nextArgRequired();
      String value=nextArgRequired();
      intent.putExtra(key,Boolean.valueOf(value));
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      ComponentName cn=ComponentName.unflattenFromString(str);
      if (cn == null)       throw new IllegalArgumentException(""String_Node_Str"" + str);
      intent.setComponent(cn);
      hasIntentInfo=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      String str=nextArgRequired();
      intent.setFlags(Integer.decode(str).intValue());
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mDebugOption=true;
    }
 else     if (opt.equals(""String_Node_Str"")) {
      mWaitOption=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      showUsage();
      return null;
    }
  }
  intent.setDataAndType(data,type);
  String uri=nextArg();
  if (uri != null) {
    Intent oldIntent=intent;
    intent=Intent.getIntent(uri);
    if (oldIntent.getAction() != null) {
      intent.setAction(oldIntent.getAction());
    }
    if (oldIntent.getData() != null || oldIntent.getType() != null) {
      intent.setDataAndType(oldIntent.getData(),oldIntent.getType());
    }
    Set cats=oldIntent.getCategories();
    if (cats != null) {
      Iterator it=cats.iterator();
      while (it.hasNext()) {
        intent.addCategory((String)it.next());
      }
    }
    hasIntentInfo=true;
  }
  if (!hasIntentInfo)   throw new IllegalArgumentException(""String_Node_Str"");
  return intent;
}",0.7389037263131121
182080,"public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
 else     if (data != null && data.getScheme() != null) {
      filter.addDataScheme(data.getScheme());
      Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
      if (aIt != null) {
        while (aIt.hasNext()) {
          IntentFilter.AuthorityEntry a=aIt.next();
          if (a.match(data) >= 0) {
            int port=a.getPort();
            filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
            break;
          }
        }
      }
      Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
      if (pIt != null) {
        String path=data.getPath();
        while (path != null && pIt.hasNext()) {
          PatternMatcher p=pIt.next();
          if (p.match(path)) {
            filter.addDataPath(p.getPath(),p.getType());
            break;
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}","public void onClick(DialogInterface dialog,int which){
  ResolveInfo ri=mAdapter.resolveInfoForPosition(which);
  Intent intent=mAdapter.intentForPosition(which);
  if ((mAlwaysCheck != null) && mAlwaysCheck.isChecked()) {
    IntentFilter filter=new IntentFilter();
    if (intent.getAction() != null) {
      filter.addAction(intent.getAction());
    }
    Set<String> categories=intent.getCategories();
    if (categories != null) {
      for (      String cat : categories) {
        filter.addCategory(cat);
      }
    }
    filter.addCategory(Intent.CATEGORY_DEFAULT);
    int cat=ri.match & IntentFilter.MATCH_CATEGORY_MASK;
    Uri data=intent.getData();
    if (cat == IntentFilter.MATCH_CATEGORY_TYPE) {
      String mimeType=intent.resolveType(this);
      if (mimeType != null) {
        try {
          filter.addDataType(mimeType);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          Log.w(""String_Node_Str"",e);
          filter=null;
        }
      }
    }
    if (data != null && data.getScheme() != null) {
      if (cat != IntentFilter.MATCH_CATEGORY_TYPE || (!""String_Node_Str"".equals(data.getScheme()) && !""String_Node_Str"".equals(data.getScheme()))) {
        filter.addDataScheme(data.getScheme());
        Iterator<IntentFilter.AuthorityEntry> aIt=ri.filter.authoritiesIterator();
        if (aIt != null) {
          while (aIt.hasNext()) {
            IntentFilter.AuthorityEntry a=aIt.next();
            if (a.match(data) >= 0) {
              int port=a.getPort();
              filter.addDataAuthority(a.getHost(),port >= 0 ? Integer.toString(port) : null);
              break;
            }
          }
        }
        Iterator<PatternMatcher> pIt=ri.filter.pathsIterator();
        if (pIt != null) {
          String path=data.getPath();
          while (path != null && pIt.hasNext()) {
            PatternMatcher p=pIt.next();
            if (p.match(path)) {
              filter.addDataPath(p.getPath(),p.getType());
              break;
            }
          }
        }
      }
    }
    if (filter != null) {
      final int N=mAdapter.mList.size();
      ComponentName[] set=new ComponentName[N];
      int bestMatch=0;
      for (int i=0; i < N; i++) {
        ResolveInfo r=mAdapter.mList.get(i).ri;
        set[i]=new ComponentName(r.activityInfo.packageName,r.activityInfo.name);
        if (r.match > bestMatch)         bestMatch=r.match;
      }
      getPackageManager().addPreferredActivity(filter,bestMatch,set,intent.getComponent());
    }
  }
  if (intent != null) {
    startActivity(intent);
  }
  finish();
}",0.9581916383276656
182081,"void startSpringback(){
  if (mScroller.springback(0,mScrollY,0,0,0,0)) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    invalidate();
    post(this);
  }
}","void startSpringback(){
  if (mScroller.springback(0,mScrollY,0,0,0,0)) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    invalidate();
    post(this);
  }
 else {
    mTouchMode=TOUCH_MODE_REST;
  }
}",0.872093023255814
182082,"void startSpringback(){
  if (mScroller.springback(0,mScrollY,0,0,0,0)) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    invalidate();
    post(this);
  }
}","void startSpringback(){
  if (mScroller.springback(0,mScrollY,0,0,0,0)) {
    mTouchMode=TOUCH_MODE_OVERFLING;
    invalidate();
    post(this);
  }
 else {
    mTouchMode=TOUCH_MODE_REST;
  }
}",0.872093023255814
182083,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9833586423908448
182084,"/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}","/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurfaceShown=true;
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}",0.9815043156596794
182085,"void reclaimSomeSurfaceMemoryLocked(WindowState win,String operation){
  final Surface surface=win.mSurface;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    boolean leakedSurface=false;
    Slog.i(TAG,""String_Node_Str"");
    for (int i=0; i < N; i++) {
      WindowState ws=(WindowState)mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
          ws.mSurface.destroy();
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (win.mAppToken != null && win.mAppToken.clientHidden) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mAppToken);
          ws.mSurface.destroy();
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    boolean killedApps=false;
    if (!leakedSurface) {
      Slog.w(TAG,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=(WindowState)mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,""String_Node_Str"")) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,""String_Node_Str"");
      if (surface != null) {
        surface.destroy();
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
}","void reclaimSomeSurfaceMemoryLocked(WindowState win,String operation){
  final Surface surface=win.mSurface;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    boolean leakedSurface=false;
    Slog.i(TAG,""String_Node_Str"");
    for (int i=0; i < N; i++) {
      WindowState ws=(WindowState)mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (win.mAppToken != null && win.mAppToken.clientHidden) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mAppToken);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    boolean killedApps=false;
    if (!leakedSurface) {
      Slog.w(TAG,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=(WindowState)mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,""String_Node_Str"")) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,""String_Node_Str"");
      if (surface != null) {
        surface.destroy();
        win.mSurfaceShown=false;
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
}",0.9789889744123154
182086,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
  mDimShown=true;
  try {
    mDimSurface.setPosition(0,0);
    mDimSurface.setSize(dw,dh);
    mDimSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}",0.8963855421686747
182087,"void finishExit(){
  if (DEBUG_ANIM)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mExiting+ ""String_Node_Str""+ mRemoveOnExit+ ""String_Node_Str""+ isWindowAnimating());
  final int N=mChildWindows.size();
  for (int i=0; i < N; i++) {
    ((WindowState)mChildWindows.get(i)).finishExit();
  }
  if (!mExiting) {
    return;
  }
  if (isWindowAnimating()) {
    return;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mRemoveOnExit);
  if (mSurface != null) {
    mDestroySurface.add(this);
    mDestroying=true;
    if (SHOW_TRANSACTIONS)     logSurface(this,""String_Node_Str"",null);
    try {
      mSurface.hide();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this,e);
    }
    mLastHidden=true;
    mKeyWaiter.releasePendingPointerLocked(mSession);
  }
  mExiting=false;
  if (mRemoveOnExit) {
    mPendingRemove.add(this);
    mRemoveOnExit=false;
  }
}","void finishExit(){
  if (DEBUG_ANIM)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mExiting+ ""String_Node_Str""+ mRemoveOnExit+ ""String_Node_Str""+ isWindowAnimating());
  final int N=mChildWindows.size();
  for (int i=0; i < N; i++) {
    ((WindowState)mChildWindows.get(i)).finishExit();
  }
  if (!mExiting) {
    return;
  }
  if (isWindowAnimating()) {
    return;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mRemoveOnExit);
  if (mSurface != null) {
    mDestroySurface.add(this);
    mDestroying=true;
    if (SHOW_TRANSACTIONS)     logSurface(this,""String_Node_Str"",null);
    mSurfaceShown=false;
    try {
      mSurface.hide();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this,e);
    }
    mLastHidden=true;
    mKeyWaiter.releasePendingPointerLocked(mSession);
  }
  mExiting=false;
  if (mRemoveOnExit) {
    mPendingRemove.add(this);
    mRemoveOnExit=false;
  }
}",0.9867934495509773
182088,"void destroySurfaceLocked(){
  mKeyWaiter.finishedKey(mSession,mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(mSession);
  mKeyWaiter.releasePendingTrackballLocked(mSession);
  if (mAppToken != null && this == mAppToken.startingWindow) {
    mAppToken.startingDisplayed=false;
  }
  if (mSurface != null) {
    mDrawPending=false;
    mCommitDrawPending=false;
    mReadyToShow=false;
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    if (mReportDestroySurface) {
      mReportDestroySurface=false;
      mSurfacePendingDestroy=true;
      try {
        mClient.dispatchGetNewSurface();
        return;
      }
 catch (      RemoteException e) {
      }
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession,e);
      }
      if (SHOW_TRANSACTIONS) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        if (SHOW_TRANSACTIONS)         logSurface(this,""String_Node_Str"",e);
      }
      mSurface.destroy();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mSurface=null;
  }
}","void destroySurfaceLocked(){
  mKeyWaiter.finishedKey(mSession,mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(mSession);
  mKeyWaiter.releasePendingTrackballLocked(mSession);
  if (mAppToken != null && this == mAppToken.startingWindow) {
    mAppToken.startingDisplayed=false;
  }
  if (mSurface != null) {
    mDrawPending=false;
    mCommitDrawPending=false;
    mReadyToShow=false;
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    if (mReportDestroySurface) {
      mReportDestroySurface=false;
      mSurfacePendingDestroy=true;
      try {
        mClient.dispatchGetNewSurface();
        return;
      }
 catch (      RemoteException e) {
      }
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession,e);
      }
      if (SHOW_TRANSACTIONS) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        if (SHOW_TRANSACTIONS)         logSurface(this,""String_Node_Str"",e);
      }
      mSurface.destroy();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mSurfaceShown=false;
    mSurface=null;
  }
}",0.9922239502332816
182089,"Surface createSurfaceLocked(){
  if (mSurface == null) {
    mReportDestroySurface=false;
    mSurfacePendingDestroy=false;
    mDrawPending=true;
    mCommitDrawPending=false;
    mReadyToShow=false;
    if (mAppToken != null) {
      mAppToken.allDrawn=false;
    }
    int flags=0;
    if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
      flags|=Surface.PUSH_BUFFERS;
    }
    if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SECURE) != 0) {
      flags|=Surface.SECURE;
    }
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ flags);
    int w=mFrame.width();
    int h=mFrame.height();
    if ((mAttrs.flags & LayoutParams.FLAG_SCALED) != 0) {
      w=mRequestedWidth;
      h=mRequestedHeight;
    }
    if (w <= 0)     w=1;
    if (h <= 0)     h=1;
    try {
      mSurface=new Surface(mSession.mSurfaceSession,mSession.mPid,mAttrs.getTitle().toString(),0,w,h,mAttrs.format,flags);
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
    }
 catch (    Surface.OutOfResourcesException e) {
      Slog.w(TAG,""String_Node_Str"");
      reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      return null;
    }
catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
      return null;
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mFrame.left+ ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    if (SHOW_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      if (SHOW_TRANSACTIONS)       logSurface(this,""String_Node_Str"" + mFrame.left + ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    Surface.openTransaction();
    try {
      try {
        mSurface.setPosition(mFrame.left + mXOffset,mFrame.top + mYOffset);
        mSurface.setLayer(mAnimLayer);
        mSurface.hide();
        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_DITHER) != 0) {
          if (SHOW_TRANSACTIONS)           logSurface(this,""String_Node_Str"",null);
          mSurface.setFlags(Surface.SURFACE_DITHER,Surface.SURFACE_DITHER);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w,e);
        reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      }
      mLastHidden=true;
    }
  finally {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
      Surface.closeTransaction();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurface;
}","Surface createSurfaceLocked(){
  if (mSurface == null) {
    mReportDestroySurface=false;
    mSurfacePendingDestroy=false;
    mDrawPending=true;
    mCommitDrawPending=false;
    mReadyToShow=false;
    if (mAppToken != null) {
      mAppToken.allDrawn=false;
    }
    int flags=0;
    if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
      flags|=Surface.PUSH_BUFFERS;
    }
    if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SECURE) != 0) {
      flags|=Surface.SECURE;
    }
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ flags);
    int w=mFrame.width();
    int h=mFrame.height();
    if ((mAttrs.flags & LayoutParams.FLAG_SCALED) != 0) {
      w=mRequestedWidth;
      h=mRequestedHeight;
    }
    if (w <= 0)     w=1;
    if (h <= 0)     h=1;
    mSurfaceShown=false;
    mSurfaceLayer=0;
    mSurfaceAlpha=1;
    mSurfaceX=0;
    mSurfaceY=0;
    mSurfaceW=w;
    mSurfaceH=h;
    try {
      mSurface=new Surface(mSession.mSurfaceSession,mSession.mPid,mAttrs.getTitle().toString(),0,w,h,mAttrs.format,flags);
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
    }
 catch (    Surface.OutOfResourcesException e) {
      Slog.w(TAG,""String_Node_Str"");
      reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      return null;
    }
catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
      return null;
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mFrame.left+ ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    if (SHOW_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      if (SHOW_TRANSACTIONS)       logSurface(this,""String_Node_Str"" + mFrame.left + ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    Surface.openTransaction();
    try {
      try {
        mSurfaceX=mFrame.left + mXOffset;
        mSurfaceY=mFrame.top=mYOffset;
        mSurface.setPosition(mSurfaceX,mSurfaceY);
        mSurfaceLayer=mAnimLayer;
        mSurface.setLayer(mAnimLayer);
        mSurfaceShown=false;
        mSurface.hide();
        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_DITHER) != 0) {
          if (SHOW_TRANSACTIONS)           logSurface(this,""String_Node_Str"",null);
          mSurface.setFlags(Surface.SURFACE_DITHER,Surface.SURFACE_DITHER);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w,e);
        reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      }
      mLastHidden=true;
    }
  finally {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
      Surface.closeTransaction();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurface;
}",0.9446446118571896
182090,"private boolean chooseNewDefaultIMELocked(){
  List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
  if (enabled != null && enabled.size() > 0) {
    Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,enabled.get(0).getId());
    return true;
  }
  return false;
}","private boolean chooseNewDefaultIMELocked(){
  List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
  if (enabled != null && enabled.size() > 0) {
    int i=enabled.size();
    while (i > 0) {
      i--;
      if ((enabled.get(i).getServiceInfo().applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        break;
      }
    }
    Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,enabled.get(i).getId());
    return true;
  }
  return false;
}",0.7681159420289855
182091,"void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabled(p.getId(),true);
      }
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}","void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabledLocked(p.getId(),true);
      }
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}",0.9979577944179714
182092,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      mLastMotionX=x;
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(deltaX,0,mScrollX,0,getScrollRange(),0,getOverscrollMax(),0,true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(deltaX,0,mScrollX,0,getScrollRange(),0,getOverscrollMax(),0,true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.8696088264794383
182093,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.9665109034267912
182094,"private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}","private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final int scrollX=mScrollX;
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() - scrollX || x >= child.getRight() - scrollX);
  }
  return false;
}",0.8992248062015504
182095,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax(),true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax(),true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.8817843866171003
182096,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.9640768588137008
182097,"private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}","private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final int scrollY=mScrollY;
    final View child=getChildAt(0);
    return !(y < child.getTop() - scrollY || y >= child.getBottom() - scrollY || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}",0.8992248062015504
182098,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.947502116850127
182099,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.943327239488117
182100,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      PackageParser pp=new PackageParser(codePath);
      pp.setSeparateProcesses(mSeparateProcesses);
      final PackageParser.Package pkg=pp.parsePackage(new File(codePath),codePath,mMetrics,parseFlags);
      pp=null;
      doGc=true;
      if (pkg == null) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.cachePath);
        continue;
      }
      setApplicationInfoPaths(pkg,codePath,codePath);
synchronized (mInstallLock) {
        if (scanPackageLI(pkg,parseFlags,SCAN_MONITOR) != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      PackageParser pp=new PackageParser(codePath);
      pp.setSeparateProcesses(mSeparateProcesses);
      final PackageParser.Package pkg=pp.parsePackage(new File(codePath),codePath,mMetrics,parseFlags);
      pp=null;
      doGc=true;
      if (pkg == null) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.cachePath);
        continue;
      }
      setApplicationInfoPaths(pkg,codePath,codePath);
synchronized (mInstallLock) {
        if (scanPackageLI(pkg,parseFlags,SCAN_MONITOR) != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.989780387040661
182101,"WifiService(Context context,WifiStateTracker tracker){
  mContext=context;
  mWifiStateTracker=tracker;
  mWifiStateTracker.enableRssiPolling(true);
  mBatteryStats=BatteryStatsService.getService();
  IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  nwService=INetworkManagementService.Stub.asInterface(b);
  mScanResultCache=new LinkedHashMap<String,ScanResult>(SCAN_RESULT_CACHE_SIZE,0.75f,true){
    public boolean removeEldestEntry(    Map.Entry eldest){
      return SCAN_RESULT_CACHE_SIZE < this.size();
    }
  }
;
  HandlerThread wifiThread=new HandlerThread(""String_Node_Str"");
  wifiThread.start();
  mWifiHandler=new WifiHandler(wifiThread.getLooper());
  mWifiStateTracker.setWifiState(WIFI_STATE_DISABLED);
  mWifiApState=WIFI_AP_STATE_DISABLED;
  mAlarmManager=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent idleIntent=new Intent(ACTION_DEVICE_IDLE,null);
  mIdleIntent=PendingIntent.getBroadcast(mContext,IDLE_REQUEST,idleIntent,0);
  PowerManager powerManager=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  sWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  sDriverStopWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  mWifiStateTracker.setReleaseWakeLockCallback(new Runnable(){
    public void run(){
      mWifiHandler.removeMessages(MESSAGE_RELEASE_WAKELOCK);
synchronized (sDriverStopWakeLock) {
        if (sDriverStopWakeLock.isHeld()) {
          sDriverStopWakeLock.release();
        }
      }
    }
  }
);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      mAirplaneModeOverwridden=false;
      updateWifiState();
    }
  }
,new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      ArrayList<String> available=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER);
      ArrayList<String> active=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
      updateTetherState(available,active);
    }
  }
,new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
}","WifiService(Context context,WifiStateTracker tracker){
  mContext=context;
  mWifiStateTracker=tracker;
  mWifiStateTracker.enableRssiPolling(true);
  mBatteryStats=BatteryStatsService.getService();
  IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  nwService=INetworkManagementService.Stub.asInterface(b);
  mScanResultCache=new LinkedHashMap<String,ScanResult>(SCAN_RESULT_CACHE_SIZE,0.75f,true){
    public boolean removeEldestEntry(    Map.Entry eldest){
      return SCAN_RESULT_CACHE_SIZE < this.size();
    }
  }
;
  HandlerThread wifiThread=new HandlerThread(""String_Node_Str"");
  wifiThread.start();
  mWifiHandler=new WifiHandler(wifiThread.getLooper());
  mWifiStateTracker.setWifiState(WIFI_STATE_DISABLED);
  mWifiApState=WIFI_AP_STATE_DISABLED;
  mAlarmManager=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent idleIntent=new Intent(ACTION_DEVICE_IDLE,null);
  mIdleIntent=PendingIntent.getBroadcast(mContext,IDLE_REQUEST,idleIntent,0);
  PowerManager powerManager=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  sWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  sDriverStopWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      mAirplaneModeOverwridden=false;
      updateWifiState();
    }
  }
,new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      ArrayList<String> available=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER);
      ArrayList<String> active=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
      updateTetherState(available,active);
    }
  }
,new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
}",0.7026143790849673
182102,"private void doUpdateWifiState(){
  boolean wifiEnabled=getPersistedWifiEnabled();
  boolean airplaneMode=isAirplaneModeOn() && !mAirplaneModeOverwridden;
  boolean lockHeld=mLocks.hasLocks();
  int strongestLockMode;
  boolean wifiShouldBeEnabled=wifiEnabled && !airplaneMode;
  boolean wifiShouldBeStarted=!mDeviceIdle || lockHeld;
  if (mDeviceIdle && lockHeld) {
    strongestLockMode=mLocks.getStrongestLockMode();
  }
 else {
    strongestLockMode=WifiManager.WIFI_MODE_FULL;
  }
synchronized (mWifiHandler) {
    if ((mWifiStateTracker.getWifiState() == WIFI_STATE_ENABLING) && !airplaneMode) {
      return;
    }
    if (wifiShouldBeEnabled) {
      if (wifiShouldBeStarted) {
        sWakeLock.acquire();
        sendEnableMessage(true,false,mLastEnableUid);
        sWakeLock.acquire();
        sendStartMessage(strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
      }
 else {
        int wakeLockTimeout=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS,DEFAULT_WAKELOCK_TIMEOUT);
        sDriverStopWakeLock.acquire();
        mWifiHandler.sendEmptyMessage(MESSAGE_STOP_WIFI);
        mWifiHandler.sendEmptyMessageDelayed(MESSAGE_RELEASE_WAKELOCK,wakeLockTimeout);
      }
    }
 else {
      sWakeLock.acquire();
      sendEnableMessage(false,false,mLastEnableUid);
    }
  }
}","private void doUpdateWifiState(){
  boolean wifiEnabled=getPersistedWifiEnabled();
  boolean airplaneMode=isAirplaneModeOn() && !mAirplaneModeOverwridden;
  boolean lockHeld=mLocks.hasLocks();
  int strongestLockMode;
  boolean wifiShouldBeEnabled=wifiEnabled && !airplaneMode;
  boolean wifiShouldBeStarted=!mDeviceIdle || lockHeld;
  if (mDeviceIdle && lockHeld) {
    strongestLockMode=mLocks.getStrongestLockMode();
  }
 else {
    strongestLockMode=WifiManager.WIFI_MODE_FULL;
  }
synchronized (mWifiHandler) {
    if ((mWifiStateTracker.getWifiState() == WIFI_STATE_ENABLING) && !airplaneMode) {
      return;
    }
    if (wifiShouldBeEnabled) {
      if (wifiShouldBeStarted) {
        sWakeLock.acquire();
        sendEnableMessage(true,false,mLastEnableUid);
        sWakeLock.acquire();
        sendStartMessage(strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
      }
 else       if (!mWifiStateTracker.isDriverStopped()) {
        int wakeLockTimeout=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS,DEFAULT_WAKELOCK_TIMEOUT);
        sDriverStopWakeLock.acquire();
        mWifiHandler.sendEmptyMessage(MESSAGE_STOP_WIFI);
        mWifiHandler.sendEmptyMessageDelayed(MESSAGE_RELEASE_WAKELOCK,wakeLockTimeout);
      }
    }
 else {
      sWakeLock.acquire();
      sendEnableMessage(false,false,mLastEnableUid);
    }
  }
}",0.9827089337175792
182103,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MESSAGE_ENABLE_WIFI:
    if (mWifiWatchdogService == null) {
      mWifiWatchdogService=new WifiWatchdogService(mContext,mWifiStateTracker);
    }
  setWifiEnabledBlocking(true,msg.arg1 == 1,msg.arg2);
sWakeLock.release();
break;
case MESSAGE_START_WIFI:
mWifiStateTracker.setScanOnlyMode(msg.arg1 != 0);
mWifiStateTracker.restart();
sWakeLock.release();
break;
case MESSAGE_UPDATE_STATE:
doUpdateWifiState();
break;
case MESSAGE_DISABLE_WIFI:
setWifiEnabledBlocking(false,msg.arg1 == 1,msg.arg2);
if (mWifiWatchdogService != null) {
mWifiWatchdogService.quit();
mWifiWatchdogService=null;
}
sWakeLock.release();
break;
case MESSAGE_STOP_WIFI:
mWifiStateTracker.disconnectAndStop();
break;
case MESSAGE_RELEASE_WAKELOCK:
synchronized (sDriverStopWakeLock) {
if (sDriverStopWakeLock.isHeld()) {
sDriverStopWakeLock.release();
}
}
break;
case MESSAGE_START_ACCESS_POINT:
setWifiApEnabledBlocking(true,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
case MESSAGE_STOP_ACCESS_POINT:
setWifiApEnabledBlocking(false,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MESSAGE_ENABLE_WIFI:
    if (mWifiWatchdogService == null) {
      mWifiWatchdogService=new WifiWatchdogService(mContext,mWifiStateTracker);
    }
  setWifiEnabledBlocking(true,msg.arg1 == 1,msg.arg2);
sWakeLock.release();
break;
case MESSAGE_START_WIFI:
mWifiStateTracker.setScanOnlyMode(msg.arg1 != 0);
mWifiStateTracker.restart();
sWakeLock.release();
break;
case MESSAGE_UPDATE_STATE:
doUpdateWifiState();
break;
case MESSAGE_DISABLE_WIFI:
setWifiEnabledBlocking(false,msg.arg1 == 1,msg.arg2);
if (mWifiWatchdogService != null) {
mWifiWatchdogService.quit();
mWifiWatchdogService=null;
}
sWakeLock.release();
break;
case MESSAGE_STOP_WIFI:
mWifiStateTracker.disconnectAndStop();
break;
case MESSAGE_RELEASE_WAKELOCK:
sDriverStopWakeLock.release();
break;
case MESSAGE_START_ACCESS_POINT:
setWifiApEnabledBlocking(true,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
case MESSAGE_STOP_ACCESS_POINT:
setWifiApEnabledBlocking(false,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
}
}",0.9563299514777238
182104,"/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return stopDriver();
    }
 else {
      return disconnect();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return stopDriver();
    }
 else {
      return disconnect();
    }
  }
  return true;
}",0.9575844716031632
182105,"private synchronized boolean isDriverStopped(){
  return mRunState == RUN_STATE_STOPPED || mRunState == RUN_STATE_STOPPING;
}","/** 
 * TODO: mRunState is not synchronized in some places address this as part of re-architect. TODO: We are exposing an additional public synchronized call for a wakelock optimization in WifiService. Remove it when we handle the wakelock in ConnectivityService.
 */
public synchronized boolean isDriverStopped(){
  return mRunState == RUN_STATE_STOPPED || mRunState == RUN_STATE_STOPPING;
}",0.4564796905222437
182106,"@Override public void releaseWakeLock(){
  if (mReleaseWakeLockCallback != null) {
    mReleaseWakeLockCallback.run();
  }
}","/** 
 * We release the wakelock in WifiService using a timer. TODO: Releasing wakelock using both timer and a call from ConnectivityService requires a rethink. We had problems where WifiService could keep a wakelock forever if we delete messages in the asynchronous call from ConnectivityService
 */
@Override public void releaseWakeLock(){
}",0.1802575107296137
182107,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
int adjResult=0;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
adjResult|=ADJUST_WALLPAPER_LAYERS_CHANGED;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult|=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult|=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurfaceX=w.mShownFrame.left;
    w.mSurfaceY=w.mShownFrame.top;
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurfaceW=width;
      w.mSurfaceH=height;
      w.mSurface.setSize(width,height);
      w.mSurfaceX=w.mShownFrame.left;
      w.mSurfaceY=w.mShownFrame.top;
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (DEBUG_CONFIGURATION && configChanged) {
    Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mCurConfiguration);
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      w.mSurfaceShown=false;
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurfaceAlpha=w.mShownAlpha;
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurfaceLayer=w.mAnimLayer;
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
      mDimAnimator.updateParameters(w,currentTime);
    }
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (mBlurSurface != null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        mBlurSurface.setLayer(w.mAnimLayer - 2);
        if (!mBlurShown) {
          try {
            if (SHOW_TRANSACTIONS)             Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
            mBlurSurface.show();
          }
 catch (          RuntimeException e) {
            Slog.w(TAG,""String_Node_Str"",e);
          }
          mBlurShown=true;
        }
      }
    }
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
int diff=0;
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ mCurConfiguration+ ""String_Node_Str""+ Integer.toHexString(diff));
}
win.mConfiguration=mCurConfiguration;
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
assignLayersLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9833586423908448
182108,"/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}","/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurfaceShown=true;
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}",0.9815043156596794
182109,"void reclaimSomeSurfaceMemoryLocked(WindowState win,String operation){
  final Surface surface=win.mSurface;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    boolean leakedSurface=false;
    Slog.i(TAG,""String_Node_Str"");
    for (int i=0; i < N; i++) {
      WindowState ws=(WindowState)mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
          ws.mSurface.destroy();
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (win.mAppToken != null && win.mAppToken.clientHidden) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mAppToken);
          ws.mSurface.destroy();
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    boolean killedApps=false;
    if (!leakedSurface) {
      Slog.w(TAG,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=(WindowState)mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,""String_Node_Str"")) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,""String_Node_Str"");
      if (surface != null) {
        surface.destroy();
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
}","void reclaimSomeSurfaceMemoryLocked(WindowState win,String operation){
  final Surface surface=win.mSurface;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    boolean leakedSurface=false;
    Slog.i(TAG,""String_Node_Str"");
    for (int i=0; i < N; i++) {
      WindowState ws=(WindowState)mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (win.mAppToken != null && win.mAppToken.clientHidden) {
          Slog.w(TAG,""String_Node_Str"" + ws + ""String_Node_Str""+ ws.mSurface+ ""String_Node_Str""+ win.mAppToken);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    boolean killedApps=false;
    if (!leakedSurface) {
      Slog.w(TAG,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=(WindowState)mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,""String_Node_Str"")) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,""String_Node_Str"");
      if (surface != null) {
        surface.destroy();
        win.mSurfaceShown=false;
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
}",0.9789889744123154
182110,"/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
  mDimShown=true;
  try {
    mDimSurface.setPosition(0,0);
    mDimSurface.setSize(dw,dh);
    mDimSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Show the dim surface.
 */
void show(int dw,int dh){
  if (!mDimShown) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + mDimSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str"");
    mDimShown=true;
    try {
      mDimSurface.setPosition(0,0);
      mDimSurface.setSize(dw,dh);
      mDimSurface.show();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"",e);
    }
  }
}",0.8963855421686747
182111,"void finishExit(){
  if (DEBUG_ANIM)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mExiting+ ""String_Node_Str""+ mRemoveOnExit+ ""String_Node_Str""+ isWindowAnimating());
  final int N=mChildWindows.size();
  for (int i=0; i < N; i++) {
    ((WindowState)mChildWindows.get(i)).finishExit();
  }
  if (!mExiting) {
    return;
  }
  if (isWindowAnimating()) {
    return;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mRemoveOnExit);
  if (mSurface != null) {
    mDestroySurface.add(this);
    mDestroying=true;
    if (SHOW_TRANSACTIONS)     logSurface(this,""String_Node_Str"",null);
    try {
      mSurface.hide();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this,e);
    }
    mLastHidden=true;
    mKeyWaiter.releasePendingPointerLocked(mSession);
  }
  mExiting=false;
  if (mRemoveOnExit) {
    mPendingRemove.add(this);
    mRemoveOnExit=false;
  }
}","void finishExit(){
  if (DEBUG_ANIM)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mExiting+ ""String_Node_Str""+ mRemoveOnExit+ ""String_Node_Str""+ isWindowAnimating());
  final int N=mChildWindows.size();
  for (int i=0; i < N; i++) {
    ((WindowState)mChildWindows.get(i)).finishExit();
  }
  if (!mExiting) {
    return;
  }
  if (isWindowAnimating()) {
    return;
  }
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mRemoveOnExit);
  if (mSurface != null) {
    mDestroySurface.add(this);
    mDestroying=true;
    if (SHOW_TRANSACTIONS)     logSurface(this,""String_Node_Str"",null);
    mSurfaceShown=false;
    try {
      mSurface.hide();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this,e);
    }
    mLastHidden=true;
    mKeyWaiter.releasePendingPointerLocked(mSession);
  }
  mExiting=false;
  if (mRemoveOnExit) {
    mPendingRemove.add(this);
    mRemoveOnExit=false;
  }
}",0.9867934495509773
182112,"void destroySurfaceLocked(){
  mKeyWaiter.finishedKey(mSession,mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(mSession);
  mKeyWaiter.releasePendingTrackballLocked(mSession);
  if (mAppToken != null && this == mAppToken.startingWindow) {
    mAppToken.startingDisplayed=false;
  }
  if (mSurface != null) {
    mDrawPending=false;
    mCommitDrawPending=false;
    mReadyToShow=false;
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    if (mReportDestroySurface) {
      mReportDestroySurface=false;
      mSurfacePendingDestroy=true;
      try {
        mClient.dispatchGetNewSurface();
        return;
      }
 catch (      RemoteException e) {
      }
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession,e);
      }
      if (SHOW_TRANSACTIONS) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        if (SHOW_TRANSACTIONS)         logSurface(this,""String_Node_Str"",e);
      }
      mSurface.destroy();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mSurface=null;
  }
}","void destroySurfaceLocked(){
  mKeyWaiter.finishedKey(mSession,mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(mSession);
  mKeyWaiter.releasePendingTrackballLocked(mSession);
  if (mAppToken != null && this == mAppToken.startingWindow) {
    mAppToken.startingDisplayed=false;
  }
  if (mSurface != null) {
    mDrawPending=false;
    mCommitDrawPending=false;
    mReadyToShow=false;
    int i=mChildWindows.size();
    while (i > 0) {
      i--;
      WindowState c=(WindowState)mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    if (mReportDestroySurface) {
      mReportDestroySurface=false;
      mSurfacePendingDestroy=true;
      try {
        mClient.dispatchGetNewSurface();
        return;
      }
 catch (      RemoteException e) {
      }
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession,e);
      }
      if (SHOW_TRANSACTIONS) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        if (SHOW_TRANSACTIONS)         logSurface(this,""String_Node_Str"",e);
      }
      mSurface.destroy();
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mSurfaceShown=false;
    mSurface=null;
  }
}",0.9922239502332816
182113,"Surface createSurfaceLocked(){
  if (mSurface == null) {
    mReportDestroySurface=false;
    mSurfacePendingDestroy=false;
    mDrawPending=true;
    mCommitDrawPending=false;
    mReadyToShow=false;
    if (mAppToken != null) {
      mAppToken.allDrawn=false;
    }
    int flags=0;
    if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
      flags|=Surface.PUSH_BUFFERS;
    }
    if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SECURE) != 0) {
      flags|=Surface.SECURE;
    }
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ flags);
    int w=mFrame.width();
    int h=mFrame.height();
    if ((mAttrs.flags & LayoutParams.FLAG_SCALED) != 0) {
      w=mRequestedWidth;
      h=mRequestedHeight;
    }
    if (w <= 0)     w=1;
    if (h <= 0)     h=1;
    try {
      mSurface=new Surface(mSession.mSurfaceSession,mSession.mPid,mAttrs.getTitle().toString(),0,w,h,mAttrs.format,flags);
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
    }
 catch (    Surface.OutOfResourcesException e) {
      Slog.w(TAG,""String_Node_Str"");
      reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      return null;
    }
catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
      return null;
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mFrame.left+ ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    if (SHOW_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      if (SHOW_TRANSACTIONS)       logSurface(this,""String_Node_Str"" + mFrame.left + ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    Surface.openTransaction();
    try {
      try {
        mSurface.setPosition(mFrame.left + mXOffset,mFrame.top + mYOffset);
        mSurface.setLayer(mAnimLayer);
        mSurface.hide();
        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_DITHER) != 0) {
          if (SHOW_TRANSACTIONS)           logSurface(this,""String_Node_Str"",null);
          mSurface.setFlags(Surface.SURFACE_DITHER,Surface.SURFACE_DITHER);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w,e);
        reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      }
      mLastHidden=true;
    }
  finally {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
      Surface.closeTransaction();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurface;
}","Surface createSurfaceLocked(){
  if (mSurface == null) {
    mReportDestroySurface=false;
    mSurfacePendingDestroy=false;
    mDrawPending=true;
    mCommitDrawPending=false;
    mReadyToShow=false;
    if (mAppToken != null) {
      mAppToken.allDrawn=false;
    }
    int flags=0;
    if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
      flags|=Surface.PUSH_BUFFERS;
    }
    if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_SECURE) != 0) {
      flags|=Surface.SECURE;
    }
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ flags);
    int w=mFrame.width();
    int h=mFrame.height();
    if ((mAttrs.flags & LayoutParams.FLAG_SCALED) != 0) {
      w=mRequestedWidth;
      h=mRequestedHeight;
    }
    if (w <= 0)     w=1;
    if (h <= 0)     h=1;
    mSurfaceShown=false;
    mSurfaceLayer=0;
    mSurfaceAlpha=1;
    mSurfaceX=0;
    mSurfaceY=0;
    mSurfaceW=w;
    mSurfaceH=h;
    try {
      mSurface=new Surface(mSession.mSurfaceSession,mSession.mPid,mAttrs.getTitle().toString(),0,w,h,mAttrs.format,flags);
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ mAttrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
    }
 catch (    Surface.OutOfResourcesException e) {
      Slog.w(TAG,""String_Node_Str"");
      reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      return null;
    }
catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
      return null;
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ mFrame.left+ ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    if (SHOW_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      if (SHOW_TRANSACTIONS)       logSurface(this,""String_Node_Str"" + mFrame.left + ""String_Node_Str""+ mFrame.top+ ""String_Node_Str""+ mFrame.width()+ ""String_Node_Str""+ mFrame.height()+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    Surface.openTransaction();
    try {
      try {
        mSurfaceX=mFrame.left + mXOffset;
        mSurfaceY=mFrame.top=mYOffset;
        mSurface.setPosition(mSurfaceX,mSurfaceY);
        mSurfaceLayer=mAnimLayer;
        mSurface.setLayer(mAnimLayer);
        mSurfaceShown=false;
        mSurface.hide();
        if ((mAttrs.flags & WindowManager.LayoutParams.FLAG_DITHER) != 0) {
          if (SHOW_TRANSACTIONS)           logSurface(this,""String_Node_Str"",null);
          mSurface.setFlags(Surface.SURFACE_DITHER,Surface.SURFACE_DITHER);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w,e);
        reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"");
      }
      mLastHidden=true;
    }
  finally {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
      Surface.closeTransaction();
    }
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurface;
}",0.9446446118571896
182114,"WifiService(Context context,WifiStateTracker tracker){
  mContext=context;
  mWifiStateTracker=tracker;
  mWifiStateTracker.enableRssiPolling(true);
  mBatteryStats=BatteryStatsService.getService();
  IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  nwService=INetworkManagementService.Stub.asInterface(b);
  mScanResultCache=new LinkedHashMap<String,ScanResult>(SCAN_RESULT_CACHE_SIZE,0.75f,true){
    public boolean removeEldestEntry(    Map.Entry eldest){
      return SCAN_RESULT_CACHE_SIZE < this.size();
    }
  }
;
  HandlerThread wifiThread=new HandlerThread(""String_Node_Str"");
  wifiThread.start();
  mWifiHandler=new WifiHandler(wifiThread.getLooper());
  mWifiStateTracker.setWifiState(WIFI_STATE_DISABLED);
  mWifiApState=WIFI_AP_STATE_DISABLED;
  mAlarmManager=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent idleIntent=new Intent(ACTION_DEVICE_IDLE,null);
  mIdleIntent=PendingIntent.getBroadcast(mContext,IDLE_REQUEST,idleIntent,0);
  PowerManager powerManager=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  sWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  sDriverStopWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  mWifiStateTracker.setReleaseWakeLockCallback(new Runnable(){
    public void run(){
      mWifiHandler.removeMessages(MESSAGE_RELEASE_WAKELOCK);
synchronized (sDriverStopWakeLock) {
        if (sDriverStopWakeLock.isHeld()) {
          sDriverStopWakeLock.release();
        }
      }
    }
  }
);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      mAirplaneModeOverwridden=false;
      updateWifiState();
    }
  }
,new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      ArrayList<String> available=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER);
      ArrayList<String> active=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
      updateTetherState(available,active);
    }
  }
,new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
}","WifiService(Context context,WifiStateTracker tracker){
  mContext=context;
  mWifiStateTracker=tracker;
  mWifiStateTracker.enableRssiPolling(true);
  mBatteryStats=BatteryStatsService.getService();
  IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  nwService=INetworkManagementService.Stub.asInterface(b);
  mScanResultCache=new LinkedHashMap<String,ScanResult>(SCAN_RESULT_CACHE_SIZE,0.75f,true){
    public boolean removeEldestEntry(    Map.Entry eldest){
      return SCAN_RESULT_CACHE_SIZE < this.size();
    }
  }
;
  HandlerThread wifiThread=new HandlerThread(""String_Node_Str"");
  wifiThread.start();
  mWifiHandler=new WifiHandler(wifiThread.getLooper());
  mWifiStateTracker.setWifiState(WIFI_STATE_DISABLED);
  mWifiApState=WIFI_AP_STATE_DISABLED;
  mAlarmManager=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent idleIntent=new Intent(ACTION_DEVICE_IDLE,null);
  mIdleIntent=PendingIntent.getBroadcast(mContext,IDLE_REQUEST,idleIntent,0);
  PowerManager powerManager=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  sWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  sDriverStopWakeLock=powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,WAKELOCK_TAG);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      mAirplaneModeOverwridden=false;
      updateWifiState();
    }
  }
,new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      ArrayList<String> available=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER);
      ArrayList<String> active=intent.getStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER);
      updateTetherState(available,active);
    }
  }
,new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
}",0.7026143790849673
182115,"private void doUpdateWifiState(){
  boolean wifiEnabled=getPersistedWifiEnabled();
  boolean airplaneMode=isAirplaneModeOn() && !mAirplaneModeOverwridden;
  boolean lockHeld=mLocks.hasLocks();
  int strongestLockMode;
  boolean wifiShouldBeEnabled=wifiEnabled && !airplaneMode;
  boolean wifiShouldBeStarted=!mDeviceIdle || lockHeld;
  if (mDeviceIdle && lockHeld) {
    strongestLockMode=mLocks.getStrongestLockMode();
  }
 else {
    strongestLockMode=WifiManager.WIFI_MODE_FULL;
  }
synchronized (mWifiHandler) {
    if ((mWifiStateTracker.getWifiState() == WIFI_STATE_ENABLING) && !airplaneMode) {
      return;
    }
    if (wifiShouldBeEnabled) {
      if (wifiShouldBeStarted) {
        sWakeLock.acquire();
        sendEnableMessage(true,false,mLastEnableUid);
        sWakeLock.acquire();
        sendStartMessage(strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
      }
 else {
        int wakeLockTimeout=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS,DEFAULT_WAKELOCK_TIMEOUT);
        sDriverStopWakeLock.acquire();
        mWifiHandler.sendEmptyMessage(MESSAGE_STOP_WIFI);
        mWifiHandler.sendEmptyMessageDelayed(MESSAGE_RELEASE_WAKELOCK,wakeLockTimeout);
      }
    }
 else {
      sWakeLock.acquire();
      sendEnableMessage(false,false,mLastEnableUid);
    }
  }
}","private void doUpdateWifiState(){
  boolean wifiEnabled=getPersistedWifiEnabled();
  boolean airplaneMode=isAirplaneModeOn() && !mAirplaneModeOverwridden;
  boolean lockHeld=mLocks.hasLocks();
  int strongestLockMode;
  boolean wifiShouldBeEnabled=wifiEnabled && !airplaneMode;
  boolean wifiShouldBeStarted=!mDeviceIdle || lockHeld;
  if (mDeviceIdle && lockHeld) {
    strongestLockMode=mLocks.getStrongestLockMode();
  }
 else {
    strongestLockMode=WifiManager.WIFI_MODE_FULL;
  }
synchronized (mWifiHandler) {
    if ((mWifiStateTracker.getWifiState() == WIFI_STATE_ENABLING) && !airplaneMode) {
      return;
    }
    if (wifiShouldBeEnabled) {
      if (wifiShouldBeStarted) {
        sWakeLock.acquire();
        sendEnableMessage(true,false,mLastEnableUid);
        sWakeLock.acquire();
        sendStartMessage(strongestLockMode == WifiManager.WIFI_MODE_SCAN_ONLY);
      }
 else       if (!mWifiStateTracker.isDriverStopped()) {
        int wakeLockTimeout=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.WIFI_MOBILE_DATA_TRANSITION_WAKELOCK_TIMEOUT_MS,DEFAULT_WAKELOCK_TIMEOUT);
        sDriverStopWakeLock.acquire();
        mWifiHandler.sendEmptyMessage(MESSAGE_STOP_WIFI);
        mWifiHandler.sendEmptyMessageDelayed(MESSAGE_RELEASE_WAKELOCK,wakeLockTimeout);
      }
    }
 else {
      sWakeLock.acquire();
      sendEnableMessage(false,false,mLastEnableUid);
    }
  }
}",0.9827089337175792
182116,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MESSAGE_ENABLE_WIFI:
    if (mWifiWatchdogService == null) {
      mWifiWatchdogService=new WifiWatchdogService(mContext,mWifiStateTracker);
    }
  setWifiEnabledBlocking(true,msg.arg1 == 1,msg.arg2);
sWakeLock.release();
break;
case MESSAGE_START_WIFI:
mWifiStateTracker.setScanOnlyMode(msg.arg1 != 0);
mWifiStateTracker.restart();
sWakeLock.release();
break;
case MESSAGE_UPDATE_STATE:
doUpdateWifiState();
break;
case MESSAGE_DISABLE_WIFI:
setWifiEnabledBlocking(false,msg.arg1 == 1,msg.arg2);
if (mWifiWatchdogService != null) {
mWifiWatchdogService.quit();
mWifiWatchdogService=null;
}
sWakeLock.release();
break;
case MESSAGE_STOP_WIFI:
mWifiStateTracker.disconnectAndStop();
break;
case MESSAGE_RELEASE_WAKELOCK:
synchronized (sDriverStopWakeLock) {
if (sDriverStopWakeLock.isHeld()) {
sDriverStopWakeLock.release();
}
}
break;
case MESSAGE_START_ACCESS_POINT:
setWifiApEnabledBlocking(true,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
case MESSAGE_STOP_ACCESS_POINT:
setWifiApEnabledBlocking(false,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MESSAGE_ENABLE_WIFI:
    if (mWifiWatchdogService == null) {
      mWifiWatchdogService=new WifiWatchdogService(mContext,mWifiStateTracker);
    }
  setWifiEnabledBlocking(true,msg.arg1 == 1,msg.arg2);
sWakeLock.release();
break;
case MESSAGE_START_WIFI:
mWifiStateTracker.setScanOnlyMode(msg.arg1 != 0);
mWifiStateTracker.restart();
sWakeLock.release();
break;
case MESSAGE_UPDATE_STATE:
doUpdateWifiState();
break;
case MESSAGE_DISABLE_WIFI:
setWifiEnabledBlocking(false,msg.arg1 == 1,msg.arg2);
if (mWifiWatchdogService != null) {
mWifiWatchdogService.quit();
mWifiWatchdogService=null;
}
sWakeLock.release();
break;
case MESSAGE_STOP_WIFI:
mWifiStateTracker.disconnectAndStop();
break;
case MESSAGE_RELEASE_WAKELOCK:
sDriverStopWakeLock.release();
break;
case MESSAGE_START_ACCESS_POINT:
setWifiApEnabledBlocking(true,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
case MESSAGE_STOP_ACCESS_POINT:
setWifiApEnabledBlocking(false,msg.arg1,(WifiConfiguration)msg.obj);
sWakeLock.release();
break;
}
}",0.9563299514777238
182117,"/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return stopDriver();
    }
 else {
      return disconnect();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return stopDriver();
    }
 else {
      return disconnect();
    }
  }
  return true;
}",0.9575844716031632
182118,"private synchronized boolean isDriverStopped(){
  return mRunState == RUN_STATE_STOPPED || mRunState == RUN_STATE_STOPPING;
}","/** 
 * TODO: mRunState is not synchronized in some places address this as part of re-architect. TODO: We are exposing an additional public synchronized call for a wakelock optimization in WifiService. Remove it when we handle the wakelock in ConnectivityService.
 */
public synchronized boolean isDriverStopped(){
  return mRunState == RUN_STATE_STOPPED || mRunState == RUN_STATE_STOPPING;
}",0.4564796905222437
182119,"@Override public void releaseWakeLock(){
  if (mReleaseWakeLockCallback != null) {
    mReleaseWakeLockCallback.run();
  }
}","/** 
 * We release the wakelock in WifiService using a timer. TODO: Releasing wakelock using both timer and a call from ConnectivityService requires a rethink. We had problems where WifiService could keep a wakelock forever if we delete messages in the asynchronous call from ConnectivityService
 */
@Override public void releaseWakeLock(){
}",0.1802575107296137
182120,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      mLastMotionX=x;
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(deltaX,0,mScrollX,0,getScrollRange(),0,getOverscrollMax(),0,true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      if (!(mIsBeingDragged=inChild((int)x,(int)ev.getY()))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionX=x;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float x=ev.getX(activePointerIndex);
    final int deltaX=(int)(mLastMotionX - x);
    mLastMotionX=x;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(deltaX,0,mScrollX,0,getScrollRange(),0,getOverscrollMax(),0,true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getXVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int right=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,right,0,0)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.8696088264794383
182121,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
if (mScroller.springback(mScrollX,mScrollY,0,getScrollRange(),0,0)) {
invalidate();
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.9665109034267912
182122,"private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}","private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final int scrollX=mScrollX;
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() - scrollX || x >= child.getRight() - scrollX);
  }
  return false;
}",0.8992248062015504
182123,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax(),true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    final int oldX=mScrollX;
    final int oldY=mScrollY;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax(),true);
    onScrollChanged(mScrollX,mScrollY,oldX,oldY);
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.8817843866171003
182124,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
if (mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange())) {
invalidate();
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.9640768588137008
182125,"private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final View child=getChildAt(0);
    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}","private boolean inChild(int x,int y){
  if (getChildCount() > 0) {
    final int scrollY=mScrollY;
    final View child=getChildAt(0);
    return !(y < child.getTop() - scrollY || y >= child.getBottom() - scrollY || x < child.getLeft() || x >= child.getRight());
  }
  return false;
}",0.8992248062015504
182126,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float x=ev.getX(pointerIndex);
      final int xDiff=(int)Math.abs(x - mLastMotionX);
      if (xDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionX=x;
        if (mParent != null)         mParent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float x=ev.getX();
    if (!inChild((int)x,(int)ev.getY())) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionX=x;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.947502116850127
182127,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int activePointerId=mActivePointerId;
      if (activePointerId == INVALID_POINTER) {
        break;
      }
      final int pointerIndex=ev.findPointerIndex(activePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.943327239488117
182128,"public void onBootCompleted(){
  mBootCompleted=true;
  if (mReadyToRunLatch != null) {
    mReadyToRunLatch.countDown();
  }
}","public void onBootCompleted(){
  mBootCompleted=true;
  mSyncStorageEngine.doDatabaseCleanup(AccountManager.get(mContext).getAccounts());
  if (mReadyToRunLatch != null) {
    mReadyToRunLatch.countDown();
  }
}",0.7514792899408284
182129,"public void onAccountsUpdated(Account[] accounts){
  final boolean justBootedUp=mAccounts == INITIAL_ACCOUNTS_ARRAY;
  mAccounts=accounts;
  ActiveSyncContext activeSyncContext=mActiveSyncContext;
  if (activeSyncContext != null) {
    if (!ArrayUtils.contains(accounts,activeSyncContext.mSyncOperation.account)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(activeSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
  mSyncStorageEngine.doDatabaseCleanup(accounts);
  if (accounts.length > 0) {
    boolean onlyThoseWithUnkownSyncableState=justBootedUp;
    scheduleSync(null,null,null,0,onlyThoseWithUnkownSyncableState);
  }
}","public void onAccountsUpdated(Account[] accounts){
  final boolean justBootedUp=mAccounts == INITIAL_ACCOUNTS_ARRAY;
  mAccounts=accounts;
  ActiveSyncContext activeSyncContext=mActiveSyncContext;
  if (activeSyncContext != null) {
    if (!ArrayUtils.contains(accounts,activeSyncContext.mSyncOperation.account)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(activeSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
  if (mBootCompleted) {
    mSyncStorageEngine.doDatabaseCleanup(accounts);
  }
  if (accounts.length > 0) {
    boolean onlyThoseWithUnkownSyncableState=justBootedUp;
    scheduleSync(null,null,null,0,onlyThoseWithUnkownSyncableState);
  }
}",0.9779735682819384
182130,"/** 
 * Read all account information back in to the initial engine state.
 */
private void readAccountInfoLocked(){
  boolean writeNeeded=false;
  FileInputStream fis=null;
  try {
    fis=mAccountInfoFile.openRead();
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(fis,null);
    int eventType=parser.getEventType();
    while (eventType != XmlPullParser.START_TAG) {
      eventType=parser.next();
    }
    String tagName=parser.getName();
    if (""String_Node_Str"".equals(tagName)) {
      String listen=parser.getAttributeValue(null,""String_Node_Str"");
      String versionString=parser.getAttributeValue(null,""String_Node_Str"");
      int version;
      try {
        version=(versionString == null) ? 0 : Integer.parseInt(versionString);
      }
 catch (      NumberFormatException e) {
        version=0;
      }
      if (version < ACCOUNTS_VERSION) {
        writeNeeded=true;
      }
      mMasterSyncAutomatically=listen == null || Boolean.parseBoolean(listen);
      eventType=parser.next();
      AuthorityInfo authority=null;
      Pair<Bundle,Long> periodicSync=null;
      do {
        if (eventType == XmlPullParser.START_TAG) {
          tagName=parser.getName();
          if (parser.getDepth() == 2) {
            if (""String_Node_Str"".equals(tagName)) {
              authority=parseAuthority(parser,version);
              periodicSync=null;
            }
          }
 else           if (parser.getDepth() == 3) {
            if (""String_Node_Str"".equals(tagName) && authority != null) {
              periodicSync=parsePeriodicSync(parser,authority);
            }
          }
 else           if (parser.getDepth() == 4 && periodicSync != null) {
            if (""String_Node_Str"".equals(tagName)) {
              parseExtra(parser,periodicSync);
            }
          }
        }
        eventType=parser.next();
      }
 while (eventType != XmlPullParser.END_DOCUMENT);
    }
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
    return;
  }
catch (  java.io.IOException e) {
    if (fis == null)     Log.i(TAG,""String_Node_Str"");
 else     Log.w(TAG,""String_Node_Str"",e);
    return;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      java.io.IOException e1) {
      }
    }
  }
  if (writeNeeded) {
    writeAccountInfoLocked();
  }
}","/** 
 * Read all account information back in to the initial engine state.
 */
private void readAccountInfoLocked(){
  boolean writeNeeded=false;
  FileInputStream fis=null;
  try {
    fis=mAccountInfoFile.openRead();
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(fis,null);
    int eventType=parser.getEventType();
    while (eventType != XmlPullParser.START_TAG) {
      eventType=parser.next();
    }
    String tagName=parser.getName();
    if (""String_Node_Str"".equals(tagName)) {
      String listen=parser.getAttributeValue(null,""String_Node_Str"");
      String versionString=parser.getAttributeValue(null,""String_Node_Str"");
      int version;
      try {
        version=(versionString == null) ? 0 : Integer.parseInt(versionString);
      }
 catch (      NumberFormatException e) {
        version=0;
      }
      if (version < ACCOUNTS_VERSION) {
        writeNeeded=true;
      }
      mMasterSyncAutomatically=listen == null || Boolean.parseBoolean(listen);
      eventType=parser.next();
      AuthorityInfo authority=null;
      Pair<Bundle,Long> periodicSync=null;
      do {
        if (eventType == XmlPullParser.START_TAG) {
          tagName=parser.getName();
          if (parser.getDepth() == 2) {
            if (""String_Node_Str"".equals(tagName)) {
              authority=parseAuthority(parser,version);
              periodicSync=null;
            }
          }
 else           if (parser.getDepth() == 3) {
            if (""String_Node_Str"".equals(tagName) && authority != null) {
              periodicSync=parsePeriodicSync(parser,authority);
            }
          }
 else           if (parser.getDepth() == 4 && periodicSync != null) {
            if (""String_Node_Str"".equals(tagName)) {
              parseExtra(parser,periodicSync);
            }
          }
        }
        eventType=parser.next();
      }
 while (eventType != XmlPullParser.END_DOCUMENT);
    }
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
    return;
  }
catch (  java.io.IOException e) {
    if (fis == null)     Log.i(TAG,""String_Node_Str"");
 else     Log.w(TAG,""String_Node_Str"",e);
    return;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      java.io.IOException e1) {
      }
    }
  }
  if (maybeMigrateSettingsForRenamedAuthorities()) {
    writeNeeded=true;
  }
  if (writeNeeded) {
    writeAccountInfoLocked();
  }
}",0.9840629412951382
182131,"private AuthorityInfo parseAuthority(XmlPullParser parser,int version){
  AuthorityInfo authority=null;
  int id=-1;
  try {
    id=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (id >= 0) {
    String accountName=parser.getAttributeValue(null,""String_Node_Str"");
    String accountType=parser.getAttributeValue(null,""String_Node_Str"");
    if (accountType == null) {
      accountType=""String_Node_Str"";
    }
    String authorityName=parser.getAttributeValue(null,""String_Node_Str"");
    String enabled=parser.getAttributeValue(null,""String_Node_Str"");
    String syncable=parser.getAttributeValue(null,""String_Node_Str"");
    authority=mAuthorities.get(id);
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    if (authority == null) {
      if (DEBUG_FILE)       Log.v(TAG,""String_Node_Str"");
      authority=getOrCreateAuthorityLocked(new Account(accountName,accountType),authorityName,id,false);
      if (version > 0) {
        authority.periodicSyncs.clear();
      }
    }
    if (authority != null) {
      authority.enabled=enabled == null || Boolean.parseBoolean(enabled);
      if (""String_Node_Str"".equals(syncable)) {
        authority.syncable=-1;
      }
 else {
        authority.syncable=(syncable == null || Boolean.parseBoolean(enabled)) ? 1 : 0;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    }
  }
  return authority;
}","private AuthorityInfo parseAuthority(XmlPullParser parser,int version){
  AuthorityInfo authority=null;
  int id=-1;
  try {
    id=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (id >= 0) {
    String authorityName=parser.getAttributeValue(null,""String_Node_Str"");
    String enabled=parser.getAttributeValue(null,""String_Node_Str"");
    String syncable=parser.getAttributeValue(null,""String_Node_Str"");
    String accountName=parser.getAttributeValue(null,""String_Node_Str"");
    String accountType=parser.getAttributeValue(null,""String_Node_Str"");
    if (accountType == null) {
      accountType=""String_Node_Str"";
      syncable=""String_Node_Str"";
    }
    authority=mAuthorities.get(id);
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    if (authority == null) {
      if (DEBUG_FILE)       Log.v(TAG,""String_Node_Str"");
      authority=getOrCreateAuthorityLocked(new Account(accountName,accountType),authorityName,id,false);
      if (version > 0) {
        authority.periodicSyncs.clear();
      }
    }
    if (authority != null) {
      authority.enabled=enabled == null || Boolean.parseBoolean(enabled);
      if (""String_Node_Str"".equals(syncable)) {
        authority.syncable=-1;
      }
 else {
        authority.syncable=(syncable == null || Boolean.parseBoolean(syncable)) ? 1 : 0;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    }
  }
  return authority;
}",0.8621370171976318
182132,"/** 
 * Write all account information to the account file.
 */
private void writeAccountInfoLocked(){
  if (DEBUG_FILE)   Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,""String_Node_Str"");
    out.startDocument(null,true);
    out.setFeature(""String_Node_Str"",true);
    out.startTag(null,""String_Node_Str"");
    out.attribute(null,""String_Node_Str"",Integer.toString(ACCOUNTS_VERSION));
    if (!mMasterSyncAutomatically) {
      out.attribute(null,""String_Node_Str"",""String_Node_Str"");
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,""String_Node_Str"");
      out.attribute(null,""String_Node_Str"",Integer.toString(authority.ident));
      out.attribute(null,""String_Node_Str"",authority.account.name);
      out.attribute(null,""String_Node_Str"",authority.account.type);
      out.attribute(null,""String_Node_Str"",authority.authority);
      if (!authority.enabled) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
      if (authority.syncable < 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
 else       if (authority.syncable == 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,""String_Node_Str"");
        out.attribute(null,""String_Node_Str"",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,""String_Node_Str"");
          out.attribute(null,""String_Node_Str"",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",((Account)value).name);
            out.attribute(null,""String_Node_Str"",((Account)value).type);
          }
          out.endTag(null,""String_Node_Str"");
        }
        out.endTag(null,""String_Node_Str"");
      }
      out.endTag(null,""String_Node_Str"");
    }
    out.endTag(null,""String_Node_Str"");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,""String_Node_Str"",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}","/** 
 * Write all account information to the account file.
 */
private void writeAccountInfoLocked(){
  if (DEBUG_FILE)   Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,""String_Node_Str"");
    out.startDocument(null,true);
    out.setFeature(""String_Node_Str"",true);
    out.startTag(null,""String_Node_Str"");
    out.attribute(null,""String_Node_Str"",Integer.toString(ACCOUNTS_VERSION));
    if (!mMasterSyncAutomatically) {
      out.attribute(null,""String_Node_Str"",""String_Node_Str"");
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,""String_Node_Str"");
      out.attribute(null,""String_Node_Str"",Integer.toString(authority.ident));
      out.attribute(null,""String_Node_Str"",authority.account.name);
      out.attribute(null,""String_Node_Str"",authority.account.type);
      out.attribute(null,""String_Node_Str"",authority.authority);
      out.attribute(null,""String_Node_Str"",Boolean.toString(authority.enabled));
      if (authority.syncable < 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
 else {
        out.attribute(null,""String_Node_Str"",Boolean.toString(authority.syncable != 0));
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,""String_Node_Str"");
        out.attribute(null,""String_Node_Str"",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,""String_Node_Str"");
          out.attribute(null,""String_Node_Str"",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",((Account)value).name);
            out.attribute(null,""String_Node_Str"",((Account)value).type);
          }
          out.endTag(null,""String_Node_Str"");
        }
        out.endTag(null,""String_Node_Str"");
      }
      out.endTag(null,""String_Node_Str"");
    }
    out.endTag(null,""String_Node_Str"");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,""String_Node_Str"",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}",0.9216292512434467
182133,"private void removeAuthorityLocked(Account account,String authorityName){
  AccountInfo accountInfo=mAccounts.get(account);
  if (accountInfo != null) {
    if (accountInfo.authorities.remove(authorityName) != null) {
      writeAccountInfoLocked();
    }
  }
}","private void removeAuthorityLocked(Account account,String authorityName){
  AccountInfo accountInfo=mAccounts.get(account);
  if (accountInfo != null) {
    final AuthorityInfo authorityInfo=accountInfo.authorities.remove(authorityName);
    if (authorityInfo != null) {
      mAuthorities.remove(authorityInfo.ident);
      writeAccountInfoLocked();
    }
  }
}",0.8250401284109149
182134,"@SmallTest public void testAuthorityParsing() throws Exception {
  final Account account=new Account(""String_Node_Str"",""String_Node_Str"");
  final String authority1=""String_Node_Str"";
  final String authority2=""String_Node_Str"";
  final String authority3=""String_Node_Str"";
  final Bundle extras=new Bundle();
  PeriodicSync sync1=new PeriodicSync(account,authority1,extras,(long)(60 * 60 * 24));
  PeriodicSync sync2=new PeriodicSync(account,authority2,extras,(long)(60 * 60 * 24));
  PeriodicSync sync3=new PeriodicSync(account,authority3,extras,(long)(60 * 60 * 24));
  PeriodicSync sync1s=new PeriodicSync(account,authority1,extras,1000);
  PeriodicSync sync2s=new PeriodicSync(account,authority2,extras,1000);
  PeriodicSync sync3s=new PeriodicSync(account,authority3,extras,1000);
  MockContentResolver mockResolver=new MockContentResolver();
  final TestContext testContext=new TestContext(mockResolver,getContext());
  SyncStorageEngine engine=SyncStorageEngine.newTestInstance(testContext);
  byte[] accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  File syncDir=new File(new File(testContext.getFilesDir(),""String_Node_Str""),""String_Node_Str"");
  syncDir.mkdirs();
  AtomicFile accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  FileOutputStream fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  List<PeriodicSync> syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3,syncs.get(0));
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(0,syncs.size());
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3s,syncs.get(0));
}","@SmallTest public void testAuthorityParsing() throws Exception {
  final Account account=new Account(""String_Node_Str"",""String_Node_Str"");
  final String authority1=""String_Node_Str"";
  final String authority2=""String_Node_Str"";
  final String authority3=""String_Node_Str"";
  final Bundle extras=new Bundle();
  PeriodicSync sync1=new PeriodicSync(account,authority1,extras,(long)(60 * 60 * 24));
  PeriodicSync sync2=new PeriodicSync(account,authority2,extras,(long)(60 * 60 * 24));
  PeriodicSync sync3=new PeriodicSync(account,authority3,extras,(long)(60 * 60 * 24));
  PeriodicSync sync1s=new PeriodicSync(account,authority1,extras,1000);
  PeriodicSync sync2s=new PeriodicSync(account,authority2,extras,1000);
  PeriodicSync sync3s=new PeriodicSync(account,authority3,extras,1000);
  MockContentResolver mockResolver=new MockContentResolver();
  final TestContext testContext=new TestContext(mockResolver,getContext());
  byte[] accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  File syncDir=new File(new File(testContext.getFilesDir(),""String_Node_Str""),""String_Node_Str"");
  syncDir.mkdirs();
  AtomicFile accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  FileOutputStream fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  SyncStorageEngine engine=SyncStorageEngine.newTestInstance(testContext);
  List<PeriodicSync> syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3,syncs.get(0));
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(0,syncs.size());
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3s,syncs.get(0));
}",0.4978864734299517
182135,"private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      PackageParser pp=new PackageParser(codePath);
      pp.setSeparateProcesses(mSeparateProcesses);
      final PackageParser.Package pkg=pp.parsePackage(new File(codePath),codePath,mMetrics,parseFlags);
      pp=null;
      doGc=true;
      if (pkg == null) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.cachePath);
        continue;
      }
      setApplicationInfoPaths(pkg,codePath,codePath);
synchronized (mInstallLock) {
        if (scanPackageLI(pkg,parseFlags,SCAN_MONITOR) != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}","private void loadMediaPackages(HashMap<SdInstallArgs,String> processCids,int uidArr[],HashSet<String> removeCids){
  ArrayList<String> pkgList=new ArrayList<String>();
  Set<SdInstallArgs> keys=processCids.keySet();
  boolean doGc=false;
  for (  SdInstallArgs args : keys) {
    String codePath=processCids.get(args);
    if (DEBUG_SD_INSTALL)     Log.i(TAG,""String_Node_Str"" + args.cid);
    int retCode=PackageManager.INSTALL_FAILED_CONTAINER_ERROR;
    try {
      if (args.doPreInstall(PackageManager.INSTALL_SUCCEEDED) != PackageManager.INSTALL_SUCCEEDED) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str"");
        continue;
      }
      if (codePath == null || !codePath.equals(args.getCodePath())) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.getCodePath()+ ""String_Node_Str""+ codePath);
        continue;
      }
      int parseFlags=PackageParser.PARSE_CHATTY | PackageParser.PARSE_ON_SDCARD | mDefParseFlags;
      PackageParser pp=new PackageParser(codePath);
      pp.setSeparateProcesses(mSeparateProcesses);
      final PackageParser.Package pkg=pp.parsePackage(new File(codePath),codePath,mMetrics,parseFlags);
      pp=null;
      doGc=true;
      if (pkg == null) {
        Slog.e(TAG,""String_Node_Str"" + args.cid + ""String_Node_Str""+ args.cachePath);
        continue;
      }
      setApplicationInfoPaths(pkg,codePath,codePath);
synchronized (mInstallLock) {
        if (scanPackageLI(pkg,parseFlags,SCAN_MONITOR) != null) {
synchronized (mPackages) {
            retCode=PackageManager.INSTALL_SUCCEEDED;
            pkgList.add(pkg.packageName);
            args.doPostInstall(PackageManager.INSTALL_SUCCEEDED);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        }
      }
    }
  finally {
      if (retCode != PackageManager.INSTALL_SUCCEEDED) {
        removeCids.add(args.cid);
      }
    }
  }
synchronized (mPackages) {
    updatePermissionsLP(null,null,true,false);
    mSettings.writeLP();
  }
  if (pkgList.size() > 0) {
    sendResourcesChangedBroadcast(true,pkgList,uidArr);
  }
  if (doGc) {
    Runtime.getRuntime().gc();
  }
  if (removeCids != null) {
    for (    String cid : removeCids) {
      Log.w(TAG,""String_Node_Str"" + cid + ""String_Node_Str"");
    }
  }
}",0.989780387040661
182136,"private boolean chooseNewDefaultIMELocked(){
  List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
  if (enabled != null && enabled.size() > 0) {
    Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,enabled.get(0).getId());
    return true;
  }
  return false;
}","private boolean chooseNewDefaultIMELocked(){
  List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
  if (enabled != null && enabled.size() > 0) {
    int i=enabled.size();
    while (i > 0) {
      i--;
      if ((enabled.get(i).getServiceInfo().applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        break;
      }
    }
    Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,enabled.get(i).getId());
    return true;
  }
  return false;
}",0.7681159420289855
182137,"void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabled(p.getId(),true);
      }
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}","void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabledLocked(p.getId(),true);
      }
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}",0.9979577944179714
182138,"private void installDecor(){
  if (mDecor == null) {
    mDecor=generateDecor();
    mDecor.setIsRootNamespace(true);
  }
  if (mContentParent == null) {
    mContentParent=generateLayout(mDecor);
    mTitleView=(TextView)findViewById(com.android.internal.R.id.title);
    if (mTitleView != null) {
      if ((getLocalFeatures() & (1 << FEATURE_NO_TITLE)) != 0) {
        View titleContainer=findViewById(com.android.internal.R.id.title_container);
        if (titleContainer != null) {
          titleContainer.setVisibility(View.GONE);
        }
 else {
          mTitleView.setVisibility(View.GONE);
        }
        if (mContentParent instanceof FrameLayout) {
          ((FrameLayout)mContentParent).setForeground(null);
        }
      }
 else {
        mTitleView.setText(mTitle);
      }
    }
  }
}","private void installDecor(){
  if (mDecor == null) {
    mDecor=generateDecor();
    mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
    mDecor.setIsRootNamespace(true);
  }
  if (mContentParent == null) {
    mContentParent=generateLayout(mDecor);
    mTitleView=(TextView)findViewById(com.android.internal.R.id.title);
    if (mTitleView != null) {
      if ((getLocalFeatures() & (1 << FEATURE_NO_TITLE)) != 0) {
        View titleContainer=findViewById(com.android.internal.R.id.title_container);
        if (titleContainer != null) {
          titleContainer.setVisibility(View.GONE);
        }
 else {
          mTitleView.setVisibility(View.GONE);
        }
        if (mContentParent instanceof FrameLayout) {
          ((FrameLayout)mContentParent).setForeground(null);
        }
      }
 else {
        mTitleView.setText(mTitle);
      }
    }
  }
}",0.9567791592658378
182139,"public void onBootCompleted(){
  mBootCompleted=true;
  if (mReadyToRunLatch != null) {
    mReadyToRunLatch.countDown();
  }
}","public void onBootCompleted(){
  mBootCompleted=true;
  mSyncStorageEngine.doDatabaseCleanup(AccountManager.get(mContext).getAccounts());
  if (mReadyToRunLatch != null) {
    mReadyToRunLatch.countDown();
  }
}",0.7514792899408284
182140,"public void onAccountsUpdated(Account[] accounts){
  final boolean justBootedUp=mAccounts == INITIAL_ACCOUNTS_ARRAY;
  mAccounts=accounts;
  ActiveSyncContext activeSyncContext=mActiveSyncContext;
  if (activeSyncContext != null) {
    if (!ArrayUtils.contains(accounts,activeSyncContext.mSyncOperation.account)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(activeSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
  mSyncStorageEngine.doDatabaseCleanup(accounts);
  if (accounts.length > 0) {
    boolean onlyThoseWithUnkownSyncableState=justBootedUp;
    scheduleSync(null,null,null,0,onlyThoseWithUnkownSyncableState);
  }
}","public void onAccountsUpdated(Account[] accounts){
  final boolean justBootedUp=mAccounts == INITIAL_ACCOUNTS_ARRAY;
  mAccounts=accounts;
  ActiveSyncContext activeSyncContext=mActiveSyncContext;
  if (activeSyncContext != null) {
    if (!ArrayUtils.contains(accounts,activeSyncContext.mSyncOperation.account)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(activeSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
  if (mBootCompleted) {
    mSyncStorageEngine.doDatabaseCleanup(accounts);
  }
  if (accounts.length > 0) {
    boolean onlyThoseWithUnkownSyncableState=justBootedUp;
    scheduleSync(null,null,null,0,onlyThoseWithUnkownSyncableState);
  }
}",0.9779735682819384
182141,"/** 
 * Read all account information back in to the initial engine state.
 */
private void readAccountInfoLocked(){
  boolean writeNeeded=false;
  FileInputStream fis=null;
  try {
    fis=mAccountInfoFile.openRead();
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(fis,null);
    int eventType=parser.getEventType();
    while (eventType != XmlPullParser.START_TAG) {
      eventType=parser.next();
    }
    String tagName=parser.getName();
    if (""String_Node_Str"".equals(tagName)) {
      String listen=parser.getAttributeValue(null,""String_Node_Str"");
      String versionString=parser.getAttributeValue(null,""String_Node_Str"");
      int version;
      try {
        version=(versionString == null) ? 0 : Integer.parseInt(versionString);
      }
 catch (      NumberFormatException e) {
        version=0;
      }
      if (version < ACCOUNTS_VERSION) {
        writeNeeded=true;
      }
      mMasterSyncAutomatically=listen == null || Boolean.parseBoolean(listen);
      eventType=parser.next();
      AuthorityInfo authority=null;
      Pair<Bundle,Long> periodicSync=null;
      do {
        if (eventType == XmlPullParser.START_TAG) {
          tagName=parser.getName();
          if (parser.getDepth() == 2) {
            if (""String_Node_Str"".equals(tagName)) {
              authority=parseAuthority(parser,version);
              periodicSync=null;
            }
          }
 else           if (parser.getDepth() == 3) {
            if (""String_Node_Str"".equals(tagName) && authority != null) {
              periodicSync=parsePeriodicSync(parser,authority);
            }
          }
 else           if (parser.getDepth() == 4 && periodicSync != null) {
            if (""String_Node_Str"".equals(tagName)) {
              parseExtra(parser,periodicSync);
            }
          }
        }
        eventType=parser.next();
      }
 while (eventType != XmlPullParser.END_DOCUMENT);
    }
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
    return;
  }
catch (  java.io.IOException e) {
    if (fis == null)     Log.i(TAG,""String_Node_Str"");
 else     Log.w(TAG,""String_Node_Str"",e);
    return;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      java.io.IOException e1) {
      }
    }
  }
  if (writeNeeded) {
    writeAccountInfoLocked();
  }
}","/** 
 * Read all account information back in to the initial engine state.
 */
private void readAccountInfoLocked(){
  boolean writeNeeded=false;
  FileInputStream fis=null;
  try {
    fis=mAccountInfoFile.openRead();
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(fis,null);
    int eventType=parser.getEventType();
    while (eventType != XmlPullParser.START_TAG) {
      eventType=parser.next();
    }
    String tagName=parser.getName();
    if (""String_Node_Str"".equals(tagName)) {
      String listen=parser.getAttributeValue(null,""String_Node_Str"");
      String versionString=parser.getAttributeValue(null,""String_Node_Str"");
      int version;
      try {
        version=(versionString == null) ? 0 : Integer.parseInt(versionString);
      }
 catch (      NumberFormatException e) {
        version=0;
      }
      if (version < ACCOUNTS_VERSION) {
        writeNeeded=true;
      }
      mMasterSyncAutomatically=listen == null || Boolean.parseBoolean(listen);
      eventType=parser.next();
      AuthorityInfo authority=null;
      Pair<Bundle,Long> periodicSync=null;
      do {
        if (eventType == XmlPullParser.START_TAG) {
          tagName=parser.getName();
          if (parser.getDepth() == 2) {
            if (""String_Node_Str"".equals(tagName)) {
              authority=parseAuthority(parser,version);
              periodicSync=null;
            }
          }
 else           if (parser.getDepth() == 3) {
            if (""String_Node_Str"".equals(tagName) && authority != null) {
              periodicSync=parsePeriodicSync(parser,authority);
            }
          }
 else           if (parser.getDepth() == 4 && periodicSync != null) {
            if (""String_Node_Str"".equals(tagName)) {
              parseExtra(parser,periodicSync);
            }
          }
        }
        eventType=parser.next();
      }
 while (eventType != XmlPullParser.END_DOCUMENT);
    }
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
    return;
  }
catch (  java.io.IOException e) {
    if (fis == null)     Log.i(TAG,""String_Node_Str"");
 else     Log.w(TAG,""String_Node_Str"",e);
    return;
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      java.io.IOException e1) {
      }
    }
  }
  if (maybeMigrateSettingsForRenamedAuthorities()) {
    writeNeeded=true;
  }
  if (writeNeeded) {
    writeAccountInfoLocked();
  }
}",0.9840629412951382
182142,"private AuthorityInfo parseAuthority(XmlPullParser parser,int version){
  AuthorityInfo authority=null;
  int id=-1;
  try {
    id=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (id >= 0) {
    String accountName=parser.getAttributeValue(null,""String_Node_Str"");
    String accountType=parser.getAttributeValue(null,""String_Node_Str"");
    if (accountType == null) {
      accountType=""String_Node_Str"";
    }
    String authorityName=parser.getAttributeValue(null,""String_Node_Str"");
    String enabled=parser.getAttributeValue(null,""String_Node_Str"");
    String syncable=parser.getAttributeValue(null,""String_Node_Str"");
    authority=mAuthorities.get(id);
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    if (authority == null) {
      if (DEBUG_FILE)       Log.v(TAG,""String_Node_Str"");
      authority=getOrCreateAuthorityLocked(new Account(accountName,accountType),authorityName,id,false);
      if (version > 0) {
        authority.periodicSyncs.clear();
      }
    }
    if (authority != null) {
      authority.enabled=enabled == null || Boolean.parseBoolean(enabled);
      if (""String_Node_Str"".equals(syncable)) {
        authority.syncable=-1;
      }
 else {
        authority.syncable=(syncable == null || Boolean.parseBoolean(enabled)) ? 1 : 0;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    }
  }
  return authority;
}","private AuthorityInfo parseAuthority(XmlPullParser parser,int version){
  AuthorityInfo authority=null;
  int id=-1;
  try {
    id=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  if (id >= 0) {
    String authorityName=parser.getAttributeValue(null,""String_Node_Str"");
    String enabled=parser.getAttributeValue(null,""String_Node_Str"");
    String syncable=parser.getAttributeValue(null,""String_Node_Str"");
    String accountName=parser.getAttributeValue(null,""String_Node_Str"");
    String accountType=parser.getAttributeValue(null,""String_Node_Str"");
    if (accountType == null) {
      accountType=""String_Node_Str"";
      syncable=""String_Node_Str"";
    }
    authority=mAuthorities.get(id);
    if (DEBUG_FILE)     Log.v(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    if (authority == null) {
      if (DEBUG_FILE)       Log.v(TAG,""String_Node_Str"");
      authority=getOrCreateAuthorityLocked(new Account(accountName,accountType),authorityName,id,false);
      if (version > 0) {
        authority.periodicSyncs.clear();
      }
    }
    if (authority != null) {
      authority.enabled=enabled == null || Boolean.parseBoolean(enabled);
      if (""String_Node_Str"".equals(syncable)) {
        authority.syncable=-1;
      }
 else {
        authority.syncable=(syncable == null || Boolean.parseBoolean(syncable)) ? 1 : 0;
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ authorityName+ ""String_Node_Str""+ enabled+ ""String_Node_Str""+ syncable);
    }
  }
  return authority;
}",0.8621370171976318
182143,"/** 
 * Write all account information to the account file.
 */
private void writeAccountInfoLocked(){
  if (DEBUG_FILE)   Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,""String_Node_Str"");
    out.startDocument(null,true);
    out.setFeature(""String_Node_Str"",true);
    out.startTag(null,""String_Node_Str"");
    out.attribute(null,""String_Node_Str"",Integer.toString(ACCOUNTS_VERSION));
    if (!mMasterSyncAutomatically) {
      out.attribute(null,""String_Node_Str"",""String_Node_Str"");
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,""String_Node_Str"");
      out.attribute(null,""String_Node_Str"",Integer.toString(authority.ident));
      out.attribute(null,""String_Node_Str"",authority.account.name);
      out.attribute(null,""String_Node_Str"",authority.account.type);
      out.attribute(null,""String_Node_Str"",authority.authority);
      if (!authority.enabled) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
      if (authority.syncable < 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
 else       if (authority.syncable == 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,""String_Node_Str"");
        out.attribute(null,""String_Node_Str"",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,""String_Node_Str"");
          out.attribute(null,""String_Node_Str"",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",((Account)value).name);
            out.attribute(null,""String_Node_Str"",((Account)value).type);
          }
          out.endTag(null,""String_Node_Str"");
        }
        out.endTag(null,""String_Node_Str"");
      }
      out.endTag(null,""String_Node_Str"");
    }
    out.endTag(null,""String_Node_Str"");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,""String_Node_Str"",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}","/** 
 * Write all account information to the account file.
 */
private void writeAccountInfoLocked(){
  if (DEBUG_FILE)   Log.v(TAG,""String_Node_Str"" + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,""String_Node_Str"");
    out.startDocument(null,true);
    out.setFeature(""String_Node_Str"",true);
    out.startTag(null,""String_Node_Str"");
    out.attribute(null,""String_Node_Str"",Integer.toString(ACCOUNTS_VERSION));
    if (!mMasterSyncAutomatically) {
      out.attribute(null,""String_Node_Str"",""String_Node_Str"");
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,""String_Node_Str"");
      out.attribute(null,""String_Node_Str"",Integer.toString(authority.ident));
      out.attribute(null,""String_Node_Str"",authority.account.name);
      out.attribute(null,""String_Node_Str"",authority.account.type);
      out.attribute(null,""String_Node_Str"",authority.authority);
      out.attribute(null,""String_Node_Str"",Boolean.toString(authority.enabled));
      if (authority.syncable < 0) {
        out.attribute(null,""String_Node_Str"",""String_Node_Str"");
      }
 else {
        out.attribute(null,""String_Node_Str"",Boolean.toString(authority.syncable != 0));
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,""String_Node_Str"");
        out.attribute(null,""String_Node_Str"",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,""String_Node_Str"");
          out.attribute(null,""String_Node_Str"",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,""String_Node_Str"",""String_Node_Str"");
            out.attribute(null,""String_Node_Str"",((Account)value).name);
            out.attribute(null,""String_Node_Str"",((Account)value).type);
          }
          out.endTag(null,""String_Node_Str"");
        }
        out.endTag(null,""String_Node_Str"");
      }
      out.endTag(null,""String_Node_Str"");
    }
    out.endTag(null,""String_Node_Str"");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,""String_Node_Str"",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}",0.9216292512434467
182144,"private void removeAuthorityLocked(Account account,String authorityName){
  AccountInfo accountInfo=mAccounts.get(account);
  if (accountInfo != null) {
    if (accountInfo.authorities.remove(authorityName) != null) {
      writeAccountInfoLocked();
    }
  }
}","private void removeAuthorityLocked(Account account,String authorityName){
  AccountInfo accountInfo=mAccounts.get(account);
  if (accountInfo != null) {
    final AuthorityInfo authorityInfo=accountInfo.authorities.remove(authorityName);
    if (authorityInfo != null) {
      mAuthorities.remove(authorityInfo.ident);
      writeAccountInfoLocked();
    }
  }
}",0.8250401284109149
182145,"@SmallTest public void testAuthorityParsing() throws Exception {
  final Account account=new Account(""String_Node_Str"",""String_Node_Str"");
  final String authority1=""String_Node_Str"";
  final String authority2=""String_Node_Str"";
  final String authority3=""String_Node_Str"";
  final Bundle extras=new Bundle();
  PeriodicSync sync1=new PeriodicSync(account,authority1,extras,(long)(60 * 60 * 24));
  PeriodicSync sync2=new PeriodicSync(account,authority2,extras,(long)(60 * 60 * 24));
  PeriodicSync sync3=new PeriodicSync(account,authority3,extras,(long)(60 * 60 * 24));
  PeriodicSync sync1s=new PeriodicSync(account,authority1,extras,1000);
  PeriodicSync sync2s=new PeriodicSync(account,authority2,extras,1000);
  PeriodicSync sync3s=new PeriodicSync(account,authority3,extras,1000);
  MockContentResolver mockResolver=new MockContentResolver();
  final TestContext testContext=new TestContext(mockResolver,getContext());
  SyncStorageEngine engine=SyncStorageEngine.newTestInstance(testContext);
  byte[] accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  File syncDir=new File(new File(testContext.getFilesDir(),""String_Node_Str""),""String_Node_Str"");
  syncDir.mkdirs();
  AtomicFile accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  FileOutputStream fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  List<PeriodicSync> syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3,syncs.get(0));
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(0,syncs.size());
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3s,syncs.get(0));
}","@SmallTest public void testAuthorityParsing() throws Exception {
  final Account account=new Account(""String_Node_Str"",""String_Node_Str"");
  final String authority1=""String_Node_Str"";
  final String authority2=""String_Node_Str"";
  final String authority3=""String_Node_Str"";
  final Bundle extras=new Bundle();
  PeriodicSync sync1=new PeriodicSync(account,authority1,extras,(long)(60 * 60 * 24));
  PeriodicSync sync2=new PeriodicSync(account,authority2,extras,(long)(60 * 60 * 24));
  PeriodicSync sync3=new PeriodicSync(account,authority3,extras,(long)(60 * 60 * 24));
  PeriodicSync sync1s=new PeriodicSync(account,authority1,extras,1000);
  PeriodicSync sync2s=new PeriodicSync(account,authority2,extras,1000);
  PeriodicSync sync3s=new PeriodicSync(account,authority3,extras,1000);
  MockContentResolver mockResolver=new MockContentResolver();
  final TestContext testContext=new TestContext(mockResolver,getContext());
  byte[] accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  File syncDir=new File(new File(testContext.getFilesDir(),""String_Node_Str""),""String_Node_Str"");
  syncDir.mkdirs();
  AtomicFile accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  FileOutputStream fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  SyncStorageEngine engine=SyncStorageEngine.newTestInstance(testContext);
  List<PeriodicSync> syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3,syncs.get(0));
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(0,syncs.size());
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(0,syncs.size());
  accountsFileData=(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").getBytes();
  accountInfoFile=new AtomicFile(new File(syncDir,""String_Node_Str""));
  fos=accountInfoFile.startWrite();
  fos.write(accountsFileData);
  accountInfoFile.finishWrite(fos);
  engine.clearAndReadState();
  syncs=engine.getPeriodicSyncs(account,authority1);
  assertEquals(1,syncs.size());
  assertEquals(sync1s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority2);
  assertEquals(1,syncs.size());
  assertEquals(sync2s,syncs.get(0));
  syncs=engine.getPeriodicSyncs(account,authority3);
  assertEquals(1,syncs.size());
  assertEquals(sync3s,syncs.get(0));
}",0.4978864734299517
182146,"/** 
 * <p>Builds the popup window's content and returns the height the popup should have. Returns -1 when the content already exists.</p>
 * @return the content's height or -1 if content already exists
 */
private int buildDropDown(){
  ViewGroup dropDownView;
  int otherHeights=0;
  final ListAdapter adapter=mAdapter;
  if (adapter != null) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null) {
      final int count=Math.min(adapter.getCount(),20);
      CompletionInfo[] completions=new CompletionInfo[count];
      int realCount=0;
      for (int i=0; i < count; i++) {
        if (adapter.isEnabled(i)) {
          realCount++;
          Object item=adapter.getItem(i);
          long id=adapter.getItemId(i);
          completions[i]=new CompletionInfo(id,i,convertSelectionToString(item));
        }
      }
      if (realCount != count) {
        CompletionInfo[] tmp=new CompletionInfo[realCount];
        System.arraycopy(completions,0,tmp,0,realCount);
        completions=tmp;
      }
      imm.displayCompletions(this,completions);
    }
  }
  if (mDropDownList == null) {
    Context context=getContext();
    mHideSelector=new ListSelectorHider();
    mShowDropDownRunnable=new Runnable(){
      public void run(){
        View view=getDropDownAnchorView();
        if (view != null && view.getWindowToken() != null) {
          showDropDown();
        }
      }
    }
;
    mDropDownList=new DropDownListView(context);
    mDropDownList.setSelector(mDropDownListHighlight);
    mDropDownList.setAdapter(adapter);
    mDropDownList.setVerticalFadingEdgeEnabled(true);
    mDropDownList.setOnItemClickListener(mDropDownItemClickListener);
    mDropDownList.setFocusable(true);
    mDropDownList.setFocusableInTouchMode(true);
    mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
      public void onItemSelected(      AdapterView<?> parent,      View view,      int position,      long id){
        if (position != -1) {
          DropDownListView dropDownList=mDropDownList;
          if (dropDownList != null) {
            dropDownList.mListSelectionHidden=false;
          }
        }
      }
      public void onNothingSelected(      AdapterView<?> parent){
      }
    }
);
    if (mItemSelectedListener != null) {
      mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
    }
    dropDownView=mDropDownList;
    View hintView=getHintView(context);
    if (hintView != null) {
      LinearLayout hintContainer=new LinearLayout(context);
      hintContainer.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams hintParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1.0f);
      hintContainer.addView(dropDownView,hintParams);
      hintContainer.addView(hintView);
      int widthSpec=MeasureSpec.makeMeasureSpec(getWidth(),MeasureSpec.AT_MOST);
      int heightSpec=MeasureSpec.UNSPECIFIED;
      hintView.measure(widthSpec,heightSpec);
      hintParams=(LinearLayout.LayoutParams)hintView.getLayoutParams();
      otherHeights=hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
      dropDownView=hintContainer;
    }
    mPopup.setContentView(dropDownView);
  }
 else {
    dropDownView=(ViewGroup)mPopup.getContentView();
    final View view=dropDownView.findViewById(HINT_VIEW_ID);
    if (view != null) {
      LinearLayout.LayoutParams hintParams=(LinearLayout.LayoutParams)view.getLayoutParams();
      otherHeights=view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
    }
  }
  boolean ignoreBottomDecorations=mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
  final int maxHeight=mPopup.getMaxAvailableHeight(getDropDownAnchorView(),mDropDownVerticalOffset,ignoreBottomDecorations);
  int padding=0;
  Drawable background=mPopup.getBackground();
  if (background != null) {
    background.getPadding(mTempRect);
    padding=mTempRect.top + mTempRect.bottom;
  }
  if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
    return maxHeight + padding;
  }
  final int listContent=mDropDownList.measureHeightOfChildren(MeasureSpec.UNSPECIFIED,0,ListView.NO_POSITION,maxHeight - otherHeights,2);
  if (listContent > 0)   otherHeights+=padding;
  return listContent + otherHeights;
}","/** 
 * <p>Builds the popup window's content and returns the height the popup should have. Returns -1 when the content already exists.</p>
 * @return the content's height or -1 if content already exists
 */
private int buildDropDown(){
  ViewGroup dropDownView;
  int otherHeights=0;
  final ListAdapter adapter=mAdapter;
  if (adapter != null) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null) {
      final int count=Math.min(adapter.getCount(),20);
      CompletionInfo[] completions=new CompletionInfo[count];
      int realCount=0;
      for (int i=0; i < count; i++) {
        if (adapter.isEnabled(i)) {
          realCount++;
          Object item=adapter.getItem(i);
          long id=adapter.getItemId(i);
          completions[i]=new CompletionInfo(id,i,convertSelectionToString(item));
        }
      }
      if (realCount != count) {
        CompletionInfo[] tmp=new CompletionInfo[realCount];
        System.arraycopy(completions,0,tmp,0,realCount);
        completions=tmp;
      }
      imm.displayCompletions(this,completions);
    }
  }
  if (mDropDownList == null) {
    Context context=getContext();
    mHideSelector=new ListSelectorHider();
    mShowDropDownRunnable=new Runnable(){
      public void run(){
        View view=getDropDownAnchorView();
        if (view != null && view.getWindowToken() != null) {
          showDropDown();
        }
      }
    }
;
    mDropDownList=new DropDownListView(context);
    mDropDownList.setSelector(mDropDownListHighlight);
    mDropDownList.setAdapter(adapter);
    mDropDownList.setVerticalFadingEdgeEnabled(true);
    mDropDownList.setOnItemClickListener(mDropDownItemClickListener);
    mDropDownList.setFocusable(true);
    mDropDownList.setFocusableInTouchMode(true);
    mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
      public void onItemSelected(      AdapterView<?> parent,      View view,      int position,      long id){
        if (position != -1) {
          DropDownListView dropDownList=mDropDownList;
          if (dropDownList != null) {
            dropDownList.mListSelectionHidden=false;
          }
        }
      }
      public void onNothingSelected(      AdapterView<?> parent){
      }
    }
);
    mDropDownList.setOnScrollListener(new PopupScrollListener());
    if (mItemSelectedListener != null) {
      mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
    }
    dropDownView=mDropDownList;
    View hintView=getHintView(context);
    if (hintView != null) {
      LinearLayout hintContainer=new LinearLayout(context);
      hintContainer.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams hintParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1.0f);
      hintContainer.addView(dropDownView,hintParams);
      hintContainer.addView(hintView);
      int widthSpec=MeasureSpec.makeMeasureSpec(getWidth(),MeasureSpec.AT_MOST);
      int heightSpec=MeasureSpec.UNSPECIFIED;
      hintView.measure(widthSpec,heightSpec);
      hintParams=(LinearLayout.LayoutParams)hintView.getLayoutParams();
      otherHeights=hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
      dropDownView=hintContainer;
    }
    mPopup.setContentView(dropDownView);
  }
 else {
    dropDownView=(ViewGroup)mPopup.getContentView();
    final View view=dropDownView.findViewById(HINT_VIEW_ID);
    if (view != null) {
      LinearLayout.LayoutParams hintParams=(LinearLayout.LayoutParams)view.getLayoutParams();
      otherHeights=view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
    }
  }
  boolean ignoreBottomDecorations=mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
  final int maxHeight=mPopup.getMaxAvailableHeight(getDropDownAnchorView(),mDropDownVerticalOffset,ignoreBottomDecorations);
  int padding=0;
  Drawable background=mPopup.getBackground();
  if (background != null) {
    background.getPadding(mTempRect);
    padding=mTempRect.top + mTempRect.bottom;
  }
  if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
    return maxHeight + padding;
  }
  final int listContent=mDropDownList.measureHeightOfChildren(MeasureSpec.UNSPECIFIED,0,ListView.NO_POSITION,maxHeight - otherHeights,2);
  if (listContent > 0)   otherHeights+=padding;
  return listContent + otherHeights;
}",0.9924502402196294
182147,"public boolean onTouch(View v,MotionEvent event){
  if (event.getAction() == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
    mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
    showDropDown();
  }
  return false;
}","public boolean onTouch(View v,MotionEvent event){
  final int action=event.getAction();
  if (action == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
    postDelayed(mResizePopupRunnable,EXPAND_LIST_TIMEOUT);
  }
 else   if (action == MotionEvent.ACTION_UP) {
    removeCallbacks(mResizePopupRunnable);
  }
  return false;
}",0.5351170568561873
182148,"private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}","private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    try {
      return new SimpleDateFormat(format);
    }
 catch (    IllegalArgumentException e) {
      return DateFormat.getDateInstance(DateFormat.SHORT);
    }
  }
}",0.8353096179183136
182149,"void scaleAll(){
  for (  ChildView v : mChildren) {
    v.mView.setLayoutParams(computeLayout(v));
  }
}","void scaleAll(){
  for (  ChildView v : mChildren) {
    requestLayout(v);
  }
}",0.8216216216216217
182150,"void attachView(int x,int y,int width,int height){
  if (mView == null) {
    return;
  }
  setBounds(x,y,width,height);
  mWebView.mPrivateHandler.post(new Runnable(){
    public void run(){
      AbsoluteLayout.LayoutParams lp=computeLayout(ChildView.this);
      if (mView.getParent() != null) {
        mView.setLayoutParams(lp);
      }
 else {
        attachViewOnUIThread(lp);
      }
    }
  }
);
}","void attachView(int x,int y,int width,int height){
  if (mView == null) {
    return;
  }
  setBounds(x,y,width,height);
  mWebView.mPrivateHandler.post(new Runnable(){
    public void run(){
      requestLayout(ChildView.this);
      if (mView.getParent() == null) {
        attachViewOnUIThread();
      }
    }
  }
);
}",0.7774725274725275
182151,"private void attachViewOnUIThread(AbsoluteLayout.LayoutParams lp){
  mWebView.addView(mView,lp);
  mChildren.add(this);
  if (!mReadyToDraw) {
    mView.setVisibility(View.GONE);
  }
}","private void attachViewOnUIThread(){
  mWebView.addView(mView);
  mChildren.add(this);
  if (!mReadyToDraw) {
    mView.setVisibility(View.GONE);
  }
}",0.9014925373134328
182152,"public boolean onScaleBegin(ScaleGestureDetector detector){
  cancelTouch();
  dismissZoomControl();
  mInZoomOverview=false;
  if (inEditingMode() && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(false);
  }
  return true;
}","public boolean onScaleBegin(ScaleGestureDetector detector){
  cancelTouch();
  dismissZoomControl();
  mInZoomOverview=false;
  if (inEditingMode() && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(false);
  }
  mViewManager.startZoom();
  return true;
}",0.946153846153846
182153,"public void onScaleEnd(ScaleGestureDetector detector){
  if (mPreviewZoomOnly) {
    mPreviewZoomOnly=false;
    mAnchorX=viewToContentX((int)mZoomCenterX + mScrollX);
    mAnchorY=viewToContentY((int)mZoomCenterY + mScrollY);
    boolean reflowNow=(mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT) || ((mActualScale <= 0.8 * mTextWrapScale));
    setNewZoomScale(mActualScale,reflowNow,true);
    invalidate();
  }
  if (inEditingMode() && didUpdateTextViewBounds(false) && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(true);
  }
  mTouchMode=TOUCH_PINCH_DRAG;
  mConfirmMove=true;
  startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
}","public void onScaleEnd(ScaleGestureDetector detector){
  if (mPreviewZoomOnly) {
    mPreviewZoomOnly=false;
    mAnchorX=viewToContentX((int)mZoomCenterX + mScrollX);
    mAnchorY=viewToContentY((int)mZoomCenterY + mScrollY);
    boolean reflowNow=(mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT) || ((mActualScale <= 0.8 * mTextWrapScale));
    setNewZoomScale(mActualScale,reflowNow,true);
    invalidate();
  }
  if (inEditingMode() && didUpdateTextViewBounds(false) && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(true);
  }
  mTouchMode=TOUCH_PINCH_DRAG;
  mConfirmMove=true;
  startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
  mViewManager.endZoom();
}",0.9814020028612304
182154,"/** 
 * <p>Builds the popup window's content and returns the height the popup should have. Returns -1 when the content already exists.</p>
 * @return the content's height or -1 if content already exists
 */
private int buildDropDown(){
  ViewGroup dropDownView;
  int otherHeights=0;
  final ListAdapter adapter=mAdapter;
  if (adapter != null) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null) {
      final int count=Math.min(adapter.getCount(),20);
      CompletionInfo[] completions=new CompletionInfo[count];
      int realCount=0;
      for (int i=0; i < count; i++) {
        if (adapter.isEnabled(i)) {
          realCount++;
          Object item=adapter.getItem(i);
          long id=adapter.getItemId(i);
          completions[i]=new CompletionInfo(id,i,convertSelectionToString(item));
        }
      }
      if (realCount != count) {
        CompletionInfo[] tmp=new CompletionInfo[realCount];
        System.arraycopy(completions,0,tmp,0,realCount);
        completions=tmp;
      }
      imm.displayCompletions(this,completions);
    }
  }
  if (mDropDownList == null) {
    Context context=getContext();
    mHideSelector=new ListSelectorHider();
    mShowDropDownRunnable=new Runnable(){
      public void run(){
        View view=getDropDownAnchorView();
        if (view != null && view.getWindowToken() != null) {
          showDropDown();
        }
      }
    }
;
    mDropDownList=new DropDownListView(context);
    mDropDownList.setSelector(mDropDownListHighlight);
    mDropDownList.setAdapter(adapter);
    mDropDownList.setVerticalFadingEdgeEnabled(true);
    mDropDownList.setOnItemClickListener(mDropDownItemClickListener);
    mDropDownList.setFocusable(true);
    mDropDownList.setFocusableInTouchMode(true);
    mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
      public void onItemSelected(      AdapterView<?> parent,      View view,      int position,      long id){
        if (position != -1) {
          DropDownListView dropDownList=mDropDownList;
          if (dropDownList != null) {
            dropDownList.mListSelectionHidden=false;
          }
        }
      }
      public void onNothingSelected(      AdapterView<?> parent){
      }
    }
);
    if (mItemSelectedListener != null) {
      mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
    }
    dropDownView=mDropDownList;
    View hintView=getHintView(context);
    if (hintView != null) {
      LinearLayout hintContainer=new LinearLayout(context);
      hintContainer.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams hintParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1.0f);
      hintContainer.addView(dropDownView,hintParams);
      hintContainer.addView(hintView);
      int widthSpec=MeasureSpec.makeMeasureSpec(getWidth(),MeasureSpec.AT_MOST);
      int heightSpec=MeasureSpec.UNSPECIFIED;
      hintView.measure(widthSpec,heightSpec);
      hintParams=(LinearLayout.LayoutParams)hintView.getLayoutParams();
      otherHeights=hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
      dropDownView=hintContainer;
    }
    mPopup.setContentView(dropDownView);
  }
 else {
    dropDownView=(ViewGroup)mPopup.getContentView();
    final View view=dropDownView.findViewById(HINT_VIEW_ID);
    if (view != null) {
      LinearLayout.LayoutParams hintParams=(LinearLayout.LayoutParams)view.getLayoutParams();
      otherHeights=view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
    }
  }
  boolean ignoreBottomDecorations=mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
  final int maxHeight=mPopup.getMaxAvailableHeight(getDropDownAnchorView(),mDropDownVerticalOffset,ignoreBottomDecorations);
  int padding=0;
  Drawable background=mPopup.getBackground();
  if (background != null) {
    background.getPadding(mTempRect);
    padding=mTempRect.top + mTempRect.bottom;
  }
  if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
    return maxHeight + padding;
  }
  final int listContent=mDropDownList.measureHeightOfChildren(MeasureSpec.UNSPECIFIED,0,ListView.NO_POSITION,maxHeight - otherHeights,2);
  if (listContent > 0)   otherHeights+=padding;
  return listContent + otherHeights;
}","/** 
 * <p>Builds the popup window's content and returns the height the popup should have. Returns -1 when the content already exists.</p>
 * @return the content's height or -1 if content already exists
 */
private int buildDropDown(){
  ViewGroup dropDownView;
  int otherHeights=0;
  final ListAdapter adapter=mAdapter;
  if (adapter != null) {
    InputMethodManager imm=InputMethodManager.peekInstance();
    if (imm != null) {
      final int count=Math.min(adapter.getCount(),20);
      CompletionInfo[] completions=new CompletionInfo[count];
      int realCount=0;
      for (int i=0; i < count; i++) {
        if (adapter.isEnabled(i)) {
          realCount++;
          Object item=adapter.getItem(i);
          long id=adapter.getItemId(i);
          completions[i]=new CompletionInfo(id,i,convertSelectionToString(item));
        }
      }
      if (realCount != count) {
        CompletionInfo[] tmp=new CompletionInfo[realCount];
        System.arraycopy(completions,0,tmp,0,realCount);
        completions=tmp;
      }
      imm.displayCompletions(this,completions);
    }
  }
  if (mDropDownList == null) {
    Context context=getContext();
    mHideSelector=new ListSelectorHider();
    mShowDropDownRunnable=new Runnable(){
      public void run(){
        View view=getDropDownAnchorView();
        if (view != null && view.getWindowToken() != null) {
          showDropDown();
        }
      }
    }
;
    mDropDownList=new DropDownListView(context);
    mDropDownList.setSelector(mDropDownListHighlight);
    mDropDownList.setAdapter(adapter);
    mDropDownList.setVerticalFadingEdgeEnabled(true);
    mDropDownList.setOnItemClickListener(mDropDownItemClickListener);
    mDropDownList.setFocusable(true);
    mDropDownList.setFocusableInTouchMode(true);
    mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
      public void onItemSelected(      AdapterView<?> parent,      View view,      int position,      long id){
        if (position != -1) {
          DropDownListView dropDownList=mDropDownList;
          if (dropDownList != null) {
            dropDownList.mListSelectionHidden=false;
          }
        }
      }
      public void onNothingSelected(      AdapterView<?> parent){
      }
    }
);
    mDropDownList.setOnScrollListener(new PopupScrollListener());
    if (mItemSelectedListener != null) {
      mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
    }
    dropDownView=mDropDownList;
    View hintView=getHintView(context);
    if (hintView != null) {
      LinearLayout hintContainer=new LinearLayout(context);
      hintContainer.setOrientation(LinearLayout.VERTICAL);
      LinearLayout.LayoutParams hintParams=new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1.0f);
      hintContainer.addView(dropDownView,hintParams);
      hintContainer.addView(hintView);
      int widthSpec=MeasureSpec.makeMeasureSpec(getWidth(),MeasureSpec.AT_MOST);
      int heightSpec=MeasureSpec.UNSPECIFIED;
      hintView.measure(widthSpec,heightSpec);
      hintParams=(LinearLayout.LayoutParams)hintView.getLayoutParams();
      otherHeights=hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
      dropDownView=hintContainer;
    }
    mPopup.setContentView(dropDownView);
  }
 else {
    dropDownView=(ViewGroup)mPopup.getContentView();
    final View view=dropDownView.findViewById(HINT_VIEW_ID);
    if (view != null) {
      LinearLayout.LayoutParams hintParams=(LinearLayout.LayoutParams)view.getLayoutParams();
      otherHeights=view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
    }
  }
  boolean ignoreBottomDecorations=mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
  final int maxHeight=mPopup.getMaxAvailableHeight(getDropDownAnchorView(),mDropDownVerticalOffset,ignoreBottomDecorations);
  int padding=0;
  Drawable background=mPopup.getBackground();
  if (background != null) {
    background.getPadding(mTempRect);
    padding=mTempRect.top + mTempRect.bottom;
  }
  if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
    return maxHeight + padding;
  }
  final int listContent=mDropDownList.measureHeightOfChildren(MeasureSpec.UNSPECIFIED,0,ListView.NO_POSITION,maxHeight - otherHeights,2);
  if (listContent > 0)   otherHeights+=padding;
  return listContent + otherHeights;
}",0.9924502402196294
182155,"public boolean onTouch(View v,MotionEvent event){
  if (event.getAction() == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
    mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
    showDropDown();
  }
  return false;
}","public boolean onTouch(View v,MotionEvent event){
  final int action=event.getAction();
  if (action == MotionEvent.ACTION_DOWN && mPopup != null && mPopup.isShowing()) {
    postDelayed(mResizePopupRunnable,EXPAND_LIST_TIMEOUT);
  }
 else   if (action == MotionEvent.ACTION_UP) {
    removeCallbacks(mResizePopupRunnable);
  }
  return false;
}",0.5351170568561873
182156,"boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}","boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          if (mView instanceof ViewGroup) {
            ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          }
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}",0.991238670694864
182157,"private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(""String_Node_Str"",""String_Node_Str"");
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
}
}","private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(""String_Node_Str"",""String_Node_Str"");
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
}
}",0.98870765370138
182158,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
public void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=getHeight() - mPaddingBottom - mPaddingTop;
    int bottom=getChildAt(0).getHeight();
    mScroller.fling(mScrollX,mScrollY,0,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    final boolean movingDown=velocityY > 0;
    View newFocused=findFocusableViewInMyBounds(movingDown,mScroller.getFinalY(),findFocus());
    if (newFocused == null) {
      newFocused=this;
    }
    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {
      mScrollViewMovedFocus=true;
      mScrollViewMovedFocus=false;
    }
    awakenScrollBars(mScroller.getDuration());
    invalidate();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
public void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=getHeight() - mPaddingBottom - mPaddingTop;
    int bottom=getChildAt(0).getHeight();
    mScroller.fling(mScrollX,mScrollY,0,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    final boolean movingDown=velocityY > 0;
    View newFocused=findFocusableViewInMyBounds(movingDown,mScroller.getFinalY(),findFocus());
    if (newFocused == null) {
      newFocused=this;
    }
    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {
      mScrollViewMovedFocus=true;
      mScrollViewMovedFocus=false;
    }
    invalidate();
  }
}",0.961899503036996
182159,"@Override protected void onOverscrolled(int scrollX,int scrollY,boolean clampedX,boolean clampedY){
  if (!mScroller.isFinished()) {
    mScrollX=scrollX;
    mScrollY=scrollY;
    if (clampedY) {
      mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange());
    }
  }
 else {
    super.scrollTo(scrollX,scrollY);
  }
}","@Override protected void onOverscrolled(int scrollX,int scrollY,boolean clampedX,boolean clampedY){
  if (!mScroller.isFinished()) {
    mScrollX=scrollX;
    mScrollY=scrollY;
    if (clampedY) {
      mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange());
    }
  }
 else {
    super.scrollTo(scrollX,scrollY);
  }
  awakenScrollBars();
}",0.9674556213017752
182160,"private void grantPermissionsLP(PackageParser.Package pkg,boolean replace){
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    String name=pkg.requestedPermissions.get(i);
    BasePermission bp=mSettings.mPermissions.get(name);
    if (false) {
      if (gp != ps) {
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ name+ ""String_Node_Str""+ bp);
      }
    }
    if (bp != null && bp.packageSetting != null) {
      final String perm=bp.name;
      boolean allowed;
      boolean allowedSig=false;
      if (bp.protectionLevel == PermissionInfo.PROTECTION_NORMAL || bp.protectionLevel == PermissionInfo.PROTECTION_DANGEROUS) {
        allowed=true;
      }
 else       if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE || bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
        allowed=(checkSignaturesLP(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (checkSignaturesLP(mPlatformPackage.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
        if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
          if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
              PackageSetting sysPs=mSettings.getDisabledSystemPkg(pkg.packageName);
              if (sysPs.grantedPermissions.contains(perm)) {
                allowed=true;
              }
 else {
                allowed=false;
              }
            }
 else {
              allowed=true;
            }
          }
        }
        if (allowed) {
          allowedSig=true;
        }
      }
 else {
        allowed=false;
      }
      if (false) {
        if (gp != ps) {
          Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ perm);
        }
      }
      if (allowed) {
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
          if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
            allowed=false;
            final int NP=PackageParser.NEW_PERMISSIONS.length;
            for (int ip=0; ip < NP; ip++) {
              final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
              if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
                allowed=true;
                Log.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName);
                break;
              }
            }
          }
        }
        if (allowed) {
          if (!gp.grantedPermissions.contains(perm)) {
            changedPermission=true;
            gp.grantedPermissions.add(perm);
            gp.gids=appendInts(gp.gids,bp.gids);
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str"");
        }
      }
 else {
        if (gp.grantedPermissions.remove(perm)) {
          changedPermission=true;
          gp.gids=removeInts(gp.gids,bp.gids);
          Slog.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ pkg.packageName);
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
}","private void grantPermissionsLP(PackageParser.Package pkg,boolean replace){
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    String name=pkg.requestedPermissions.get(i);
    BasePermission bp=mSettings.mPermissions.get(name);
    if (false) {
      if (gp != ps) {
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ name+ ""String_Node_Str""+ bp);
      }
    }
    if (bp != null && bp.packageSetting != null) {
      final String perm=bp.name;
      boolean allowed;
      boolean allowedSig=false;
      if (bp.protectionLevel == PermissionInfo.PROTECTION_NORMAL || bp.protectionLevel == PermissionInfo.PROTECTION_DANGEROUS) {
        allowed=true;
      }
 else       if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE || bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
        allowed=(checkSignaturesLP(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (checkSignaturesLP(mPlatformPackage.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
        if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
          if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
              PackageSetting sysPs=mSettings.getDisabledSystemPkg(pkg.packageName);
              if (sysPs.grantedPermissions.contains(perm)) {
                allowed=true;
              }
 else {
                allowed=false;
              }
            }
 else {
              allowed=true;
            }
          }
        }
        if (allowed) {
          allowedSig=true;
        }
      }
 else {
        allowed=false;
      }
      if (false) {
        if (gp != ps) {
          Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ perm);
        }
      }
      if (allowed) {
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
          if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
            allowed=false;
            final int NP=PackageParser.NEW_PERMISSIONS.length;
            for (int ip=0; ip < NP; ip++) {
              final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
              if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
                allowed=true;
                Log.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName);
                break;
              }
            }
          }
        }
        if (allowed) {
          if (!gp.grantedPermissions.contains(perm)) {
            changedPermission=true;
            gp.grantedPermissions.add(perm);
            gp.gids=appendInts(gp.gids,bp.gids);
          }
 else           if (!ps.haveGids) {
            gp.gids=appendInts(gp.gids,bp.gids);
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str"");
        }
      }
 else {
        if (gp.grantedPermissions.remove(perm)) {
          changedPermission=true;
          gp.gids=removeInts(gp.gids,bp.gids);
          Slog.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ pkg.packageName);
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
  ps.haveGids=true;
}",0.9866025420817588
182161,"public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  timeStamp=base.timeStamp;
  timeStampString=base.timeStampString;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  disabledComponents=base.disabledComponents;
  enabledComponents=base.enabledComponents;
  enabled=base.enabled;
  installStatus=base.installStatus;
}","public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  timeStamp=base.timeStamp;
  timeStampString=base.timeStampString;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  disabledComponents=base.disabledComponents;
  enabledComponents=base.enabledComponents;
  enabled=base.enabled;
  installStatus=base.installStatus;
}",0.9686746987951808
182162,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
    }
 else     if (""String_Node_Str"".equals(opt)) {
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || cmd.contains(""String_Node_Str"")) {
      packageName=cmd;
    }
  }
  boolean printedTitle=false;
synchronized (mPackages) {
    if (mActivities.dump(pw,""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mReceivers.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mServices.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mSettings.mPreferredActivities.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    boolean printedSomething=false;
{
      for (      BasePermission p : mSettings.mPermissions.values()) {
        if (packageName != null && !packageName.equals(p.sourcePackage)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(p.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(p)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(p.sourcePackage);
        pw.print(""String_Node_Str"");
        pw.print(p.uid);
        pw.print(""String_Node_Str"");
        pw.print(arrayToString(p.gids));
        pw.print(""String_Node_Str"");
        pw.print(p.type);
        pw.print(""String_Node_Str"");
        pw.println(p.protectionLevel);
        if (p.packageSetting != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.packageSetting);
        }
        if (p.perm != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.perm);
        }
      }
    }
    printedSomething=false;
    SharedUserSetting packageSharedUser=null;
{
      for (      PackageSetting ps : mSettings.mPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        packageSharedUser=ps.sharedUser;
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(ps.gids));
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
        if (ps.pkg != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.dataDir);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.targetSdkVersion);
          pw.print(""String_Node_Str"");
          boolean first=true;
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
        }
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(ps.getTimeStampStr());
        pw.print(""String_Node_Str"");
        pw.println(ps.signatures);
        pw.print(""String_Node_Str"");
        pw.print(ps.permissionsFixed);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(ps.pkgFlags));
        pw.print(""String_Node_Str"");
        pw.print(ps.installStatus);
        pw.print(""String_Node_Str"");
        pw.println(ps.enabled);
        if (ps.disabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.disabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.enabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.enabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.grantedPermissions.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.grantedPermissions) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
      }
    }
    printedSomething=false;
    if (mSettings.mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mSettings.mRenamedPackages.entrySet()) {
        if (packageName != null && !packageName.equals(e.getKey()) && !packageName.equals(e.getValue())) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(e.getKey());
        pw.print(""String_Node_Str"");
        pw.println(e.getValue());
      }
    }
    printedSomething=false;
    if (mSettings.mDisabledSysPackages.size() > 0) {
      for (      PackageSetting ps : mSettings.mDisabledSysPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.println(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
      }
    }
    printedSomething=false;
{
      for (      SharedUserSetting su : mSettings.mSharedUsers.values()) {
        if (packageName != null && su != packageSharedUser) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(su.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(su)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(su.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(su.gids));
        pw.println(""String_Node_Str"");
        for (        String s : su.grantedPermissions) {
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
    if (packageName == null) {
      if (printedTitle)       pw.println(""String_Node_Str"");
      printedTitle=true;
      pw.println(""String_Node_Str"");
      pw.println(mSettings.mReadMessages.toString());
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      File fname=getSettingsProblemFile();
      FileInputStream in;
      try {
        in=new FileInputStream(fname);
        int avail=in.available();
        byte[] data=new byte[avail];
        in.read(data);
        pw.println(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
    }
  }
synchronized (mProviders) {
    boolean printedSomething=false;
    for (    PackageParser.Provider p : mProviders.values()) {
      if (packageName != null && !packageName.equals(p.info.packageName)) {
        continue;
      }
      if (!printedSomething) {
        if (printedTitle)         pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        printedSomething=true;
        printedTitle=true;
      }
      pw.print(""String_Node_Str"");
      pw.print(p.info.authority);
      pw.print(""String_Node_Str"");
      pw.println(p.toString());
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
    }
 else     if (""String_Node_Str"".equals(opt)) {
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || cmd.contains(""String_Node_Str"")) {
      packageName=cmd;
    }
  }
  boolean printedTitle=false;
synchronized (mPackages) {
    if (mActivities.dump(pw,""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mReceivers.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mServices.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mSettings.mPreferredActivities.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    boolean printedSomething=false;
{
      for (      BasePermission p : mSettings.mPermissions.values()) {
        if (packageName != null && !packageName.equals(p.sourcePackage)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(p.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(p)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(p.sourcePackage);
        pw.print(""String_Node_Str"");
        pw.print(p.uid);
        pw.print(""String_Node_Str"");
        pw.print(arrayToString(p.gids));
        pw.print(""String_Node_Str"");
        pw.print(p.type);
        pw.print(""String_Node_Str"");
        pw.println(p.protectionLevel);
        if (p.packageSetting != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.packageSetting);
        }
        if (p.perm != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.perm);
        }
      }
    }
    printedSomething=false;
    SharedUserSetting packageSharedUser=null;
{
      for (      PackageSetting ps : mSettings.mPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        packageSharedUser=ps.sharedUser;
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(ps.gids));
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
        if (ps.pkg != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.dataDir);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.targetSdkVersion);
          pw.print(""String_Node_Str"");
          boolean first=true;
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
        }
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(ps.getTimeStampStr());
        pw.print(""String_Node_Str"");
        pw.println(ps.signatures);
        pw.print(""String_Node_Str"");
        pw.print(ps.permissionsFixed);
        pw.print(""String_Node_Str"");
        pw.println(ps.haveGids);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(ps.pkgFlags));
        pw.print(""String_Node_Str"");
        pw.print(ps.installStatus);
        pw.print(""String_Node_Str"");
        pw.println(ps.enabled);
        if (ps.disabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.disabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.enabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.enabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.grantedPermissions.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.grantedPermissions) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
      }
    }
    printedSomething=false;
    if (mSettings.mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mSettings.mRenamedPackages.entrySet()) {
        if (packageName != null && !packageName.equals(e.getKey()) && !packageName.equals(e.getValue())) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(e.getKey());
        pw.print(""String_Node_Str"");
        pw.println(e.getValue());
      }
    }
    printedSomething=false;
    if (mSettings.mDisabledSysPackages.size() > 0) {
      for (      PackageSetting ps : mSettings.mDisabledSysPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.println(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
      }
    }
    printedSomething=false;
{
      for (      SharedUserSetting su : mSettings.mSharedUsers.values()) {
        if (packageName != null && su != packageSharedUser) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(su.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(su)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(su.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(su.gids));
        pw.println(""String_Node_Str"");
        for (        String s : su.grantedPermissions) {
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
    if (packageName == null) {
      if (printedTitle)       pw.println(""String_Node_Str"");
      printedTitle=true;
      pw.println(""String_Node_Str"");
      pw.println(mSettings.mReadMessages.toString());
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      File fname=getSettingsProblemFile();
      FileInputStream in;
      try {
        in=new FileInputStream(fname);
        int avail=in.available();
        byte[] data=new byte[avail];
        in.read(data);
        pw.println(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
    }
  }
synchronized (mProviders) {
    boolean printedSomething=false;
    for (    PackageParser.Provider p : mProviders.values()) {
      if (packageName != null && !packageName.equals(p.info.packageName)) {
        continue;
      }
      if (!printedSomething) {
        if (printedTitle)         pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        printedSomething=true;
        printedTitle=true;
      }
      pw.print(""String_Node_Str"");
      pw.print(p.info.authority);
      pw.print(""String_Node_Str"");
      pw.println(p.toString());
    }
  }
}",0.9968414403032216
182163,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
public void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=getHeight() - mPaddingBottom - mPaddingTop;
    int bottom=getChildAt(0).getHeight();
    mScroller.fling(mScrollX,mScrollY,0,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    final boolean movingDown=velocityY > 0;
    View newFocused=findFocusableViewInMyBounds(movingDown,mScroller.getFinalY(),findFocus());
    if (newFocused == null) {
      newFocused=this;
    }
    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {
      mScrollViewMovedFocus=true;
      mScrollViewMovedFocus=false;
    }
    awakenScrollBars(mScroller.getDuration());
    invalidate();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
public void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=getHeight() - mPaddingBottom - mPaddingTop;
    int bottom=getChildAt(0).getHeight();
    mScroller.fling(mScrollX,mScrollY,0,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    final boolean movingDown=velocityY > 0;
    View newFocused=findFocusableViewInMyBounds(movingDown,mScroller.getFinalY(),findFocus());
    if (newFocused == null) {
      newFocused=this;
    }
    if (newFocused != findFocus() && newFocused.requestFocus(movingDown ? View.FOCUS_DOWN : View.FOCUS_UP)) {
      mScrollViewMovedFocus=true;
      mScrollViewMovedFocus=false;
    }
    invalidate();
  }
}",0.961899503036996
182164,"@Override protected void onOverscrolled(int scrollX,int scrollY,boolean clampedX,boolean clampedY){
  if (!mScroller.isFinished()) {
    mScrollX=scrollX;
    mScrollY=scrollY;
    if (clampedY) {
      mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange());
    }
  }
 else {
    super.scrollTo(scrollX,scrollY);
  }
}","@Override protected void onOverscrolled(int scrollX,int scrollY,boolean clampedX,boolean clampedY){
  if (!mScroller.isFinished()) {
    mScrollX=scrollX;
    mScrollY=scrollY;
    if (clampedY) {
      mScroller.springback(mScrollX,mScrollY,0,0,0,getScrollRange());
    }
  }
 else {
    super.scrollTo(scrollX,scrollY);
  }
  awakenScrollBars();
}",0.9674556213017752
182165,"void scaleAll(){
  for (  ChildView v : mChildren) {
    v.mView.setLayoutParams(computeLayout(v));
  }
}","void scaleAll(){
  for (  ChildView v : mChildren) {
    requestLayout(v);
  }
}",0.8216216216216217
182166,"void attachView(int x,int y,int width,int height){
  if (mView == null) {
    return;
  }
  setBounds(x,y,width,height);
  mWebView.mPrivateHandler.post(new Runnable(){
    public void run(){
      AbsoluteLayout.LayoutParams lp=computeLayout(ChildView.this);
      if (mView.getParent() != null) {
        mView.setLayoutParams(lp);
      }
 else {
        attachViewOnUIThread(lp);
      }
    }
  }
);
}","void attachView(int x,int y,int width,int height){
  if (mView == null) {
    return;
  }
  setBounds(x,y,width,height);
  mWebView.mPrivateHandler.post(new Runnable(){
    public void run(){
      requestLayout(ChildView.this);
      if (mView.getParent() == null) {
        attachViewOnUIThread();
      }
    }
  }
);
}",0.7774725274725275
182167,"private void attachViewOnUIThread(AbsoluteLayout.LayoutParams lp){
  mWebView.addView(mView,lp);
  mChildren.add(this);
  if (!mReadyToDraw) {
    mView.setVisibility(View.GONE);
  }
}","private void attachViewOnUIThread(){
  mWebView.addView(mView);
  mChildren.add(this);
  if (!mReadyToDraw) {
    mView.setVisibility(View.GONE);
  }
}",0.9014925373134328
182168,"public boolean onScaleBegin(ScaleGestureDetector detector){
  cancelTouch();
  dismissZoomControl();
  mInZoomOverview=false;
  if (inEditingMode() && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(false);
  }
  return true;
}","public boolean onScaleBegin(ScaleGestureDetector detector){
  cancelTouch();
  dismissZoomControl();
  mInZoomOverview=false;
  if (inEditingMode() && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(false);
  }
  mViewManager.startZoom();
  return true;
}",0.946153846153846
182169,"public void onScaleEnd(ScaleGestureDetector detector){
  if (mPreviewZoomOnly) {
    mPreviewZoomOnly=false;
    mAnchorX=viewToContentX((int)mZoomCenterX + mScrollX);
    mAnchorY=viewToContentY((int)mZoomCenterY + mScrollY);
    boolean reflowNow=(mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT) || ((mActualScale <= 0.8 * mTextWrapScale));
    setNewZoomScale(mActualScale,reflowNow,true);
    invalidate();
  }
  if (inEditingMode() && didUpdateTextViewBounds(false) && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(true);
  }
  mTouchMode=TOUCH_PINCH_DRAG;
  mConfirmMove=true;
  startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
}","public void onScaleEnd(ScaleGestureDetector detector){
  if (mPreviewZoomOnly) {
    mPreviewZoomOnly=false;
    mAnchorX=viewToContentX((int)mZoomCenterX + mScrollX);
    mAnchorY=viewToContentY((int)mZoomCenterY + mScrollY);
    boolean reflowNow=(mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT) || ((mActualScale <= 0.8 * mTextWrapScale));
    setNewZoomScale(mActualScale,reflowNow,true);
    invalidate();
  }
  if (inEditingMode() && didUpdateTextViewBounds(false) && nativeFocusCandidateIsPassword()) {
    mWebTextView.setInPassword(true);
  }
  mTouchMode=TOUCH_PINCH_DRAG;
  mConfirmMove=true;
  startTouch(detector.getFocusX(),detector.getFocusY(),mLastTouchTime);
  mViewManager.endZoom();
}",0.9814020028612304
182170,"boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}","boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          if (mView instanceof ViewGroup) {
            ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          }
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}",0.991238670694864
182171,"private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(""String_Node_Str"",""String_Node_Str"");
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
}
}","private void deliverKeyEventToViewHierarchy(KeyEvent event,boolean sendDone){
  try {
    if (mView != null && mAdded) {
      final int action=event.getAction();
      boolean isDown=(action == KeyEvent.ACTION_DOWN);
      if (checkForLeavingTouchModeAndConsume(event)) {
        return;
      }
      if (Config.LOGV) {
        captureKeyLog(""String_Node_Str"",event);
      }
      boolean keyHandled=mView.dispatchKeyEvent(event);
      if (!keyHandled && isDown) {
        int direction=0;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_DPAD_LEFT:
          direction=View.FOCUS_LEFT;
        break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
      direction=View.FOCUS_RIGHT;
    break;
case KeyEvent.KEYCODE_DPAD_UP:
  direction=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
direction=View.FOCUS_DOWN;
break;
}
if (direction != 0) {
View focused=mView != null ? mView.findFocus() : null;
if (focused != null) {
View v=focused.focusSearch(direction);
boolean focusPassed=false;
if (v != null && v != focused) {
focused.getFocusedRect(mTempRect);
if (mView instanceof ViewGroup) {
((ViewGroup)mView).offsetDescendantRectToMyCoords(focused,mTempRect);
((ViewGroup)mView).offsetRectIntoDescendantCoords(v,mTempRect);
}
focusPassed=v.requestFocus(direction,mTempRect);
}
if (!focusPassed) {
mView.dispatchUnhandledMove(focused,direction);
}
 else {
playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
}
}
}
}
}
}
  finally {
if (sendDone) {
if (LOCAL_LOGV) Log.v(""String_Node_Str"",""String_Node_Str"");
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
}
}",0.98870765370138
182172,"private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}","private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    try {
      return new SimpleDateFormat(format);
    }
 catch (    IllegalArgumentException e) {
      return DateFormat.getDateInstance(DateFormat.SHORT);
    }
  }
}",0.8353096179183136
182173,"private boolean trackSignalStrength(){
  return getPreferences().getBoolean(SIGNAL_PREF,true);
}","private boolean trackSignalStrength(){
  return getPreferences().getBoolean(SIGNAL_PREF,false);
}",0.9637305699481864
182174,"private boolean doDebugLogging(){
  return getPreferences().getBoolean(DEBUG_PREF,true);
}","private boolean doDebugLogging(){
  return getPreferences().getBoolean(DEBUG_PREF,false);
}",0.9613259668508288
182175,"private void grantPermissionsLP(PackageParser.Package pkg,boolean replace){
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    String name=pkg.requestedPermissions.get(i);
    BasePermission bp=mSettings.mPermissions.get(name);
    if (false) {
      if (gp != ps) {
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ name+ ""String_Node_Str""+ bp);
      }
    }
    if (bp != null && bp.packageSetting != null) {
      final String perm=bp.name;
      boolean allowed;
      boolean allowedSig=false;
      if (bp.protectionLevel == PermissionInfo.PROTECTION_NORMAL || bp.protectionLevel == PermissionInfo.PROTECTION_DANGEROUS) {
        allowed=true;
      }
 else       if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE || bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
        allowed=(checkSignaturesLP(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (checkSignaturesLP(mPlatformPackage.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
        if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
          if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
              PackageSetting sysPs=mSettings.getDisabledSystemPkg(pkg.packageName);
              if (sysPs.grantedPermissions.contains(perm)) {
                allowed=true;
              }
 else {
                allowed=false;
              }
            }
 else {
              allowed=true;
            }
          }
        }
        if (allowed) {
          allowedSig=true;
        }
      }
 else {
        allowed=false;
      }
      if (false) {
        if (gp != ps) {
          Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ perm);
        }
      }
      if (allowed) {
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
          if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
            allowed=false;
            final int NP=PackageParser.NEW_PERMISSIONS.length;
            for (int ip=0; ip < NP; ip++) {
              final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
              if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
                allowed=true;
                Log.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName);
                break;
              }
            }
          }
        }
        if (allowed) {
          if (!gp.grantedPermissions.contains(perm)) {
            changedPermission=true;
            gp.grantedPermissions.add(perm);
            gp.gids=appendInts(gp.gids,bp.gids);
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str"");
        }
      }
 else {
        if (gp.grantedPermissions.remove(perm)) {
          changedPermission=true;
          gp.gids=removeInts(gp.gids,bp.gids);
          Slog.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ pkg.packageName);
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
}","private void grantPermissionsLP(PackageParser.Package pkg,boolean replace){
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    String name=pkg.requestedPermissions.get(i);
    BasePermission bp=mSettings.mPermissions.get(name);
    if (false) {
      if (gp != ps) {
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ name+ ""String_Node_Str""+ bp);
      }
    }
    if (bp != null && bp.packageSetting != null) {
      final String perm=bp.name;
      boolean allowed;
      boolean allowedSig=false;
      if (bp.protectionLevel == PermissionInfo.PROTECTION_NORMAL || bp.protectionLevel == PermissionInfo.PROTECTION_DANGEROUS) {
        allowed=true;
      }
 else       if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE || bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
        allowed=(checkSignaturesLP(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (checkSignaturesLP(mPlatformPackage.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH);
        if (bp.protectionLevel == PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM) {
          if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
              PackageSetting sysPs=mSettings.getDisabledSystemPkg(pkg.packageName);
              if (sysPs.grantedPermissions.contains(perm)) {
                allowed=true;
              }
 else {
                allowed=false;
              }
            }
 else {
              allowed=true;
            }
          }
        }
        if (allowed) {
          allowedSig=true;
        }
      }
 else {
        allowed=false;
      }
      if (false) {
        if (gp != ps) {
          Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ perm);
        }
      }
      if (allowed) {
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
          if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
            allowed=false;
            final int NP=PackageParser.NEW_PERMISSIONS.length;
            for (int ip=0; ip < NP; ip++) {
              final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
              if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
                allowed=true;
                Log.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName);
                break;
              }
            }
          }
        }
        if (allowed) {
          if (!gp.grantedPermissions.contains(perm)) {
            changedPermission=true;
            gp.grantedPermissions.add(perm);
            gp.gids=appendInts(gp.gids,bp.gids);
          }
 else           if (!ps.haveGids) {
            gp.gids=appendInts(gp.gids,bp.gids);
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str"");
        }
      }
 else {
        if (gp.grantedPermissions.remove(perm)) {
          changedPermission=true;
          gp.gids=removeInts(gp.gids,bp.gids);
          Slog.i(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + perm + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ bp.protectionLevel+ ""String_Node_Str""+ Integer.toHexString(pkg.applicationInfo.flags)+ ""String_Node_Str"");
        }
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ pkg.packageName);
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
  ps.haveGids=true;
}",0.9866025420817588
182176,"public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  timeStamp=base.timeStamp;
  timeStampString=base.timeStampString;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  disabledComponents=base.disabledComponents;
  enabledComponents=base.enabledComponents;
  enabled=base.enabled;
  installStatus=base.installStatus;
}","public void copyFrom(PackageSettingBase base){
  grantedPermissions=base.grantedPermissions;
  gids=base.gids;
  timeStamp=base.timeStamp;
  timeStampString=base.timeStampString;
  signatures=base.signatures;
  permissionsFixed=base.permissionsFixed;
  haveGids=base.haveGids;
  disabledComponents=base.disabledComponents;
  enabledComponents=base.enabledComponents;
  enabled=base.enabled;
  installStatus=base.installStatus;
}",0.9686746987951808
182177,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
    }
 else     if (""String_Node_Str"".equals(opt)) {
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || cmd.contains(""String_Node_Str"")) {
      packageName=cmd;
    }
  }
  boolean printedTitle=false;
synchronized (mPackages) {
    if (mActivities.dump(pw,""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mReceivers.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mServices.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mSettings.mPreferredActivities.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    boolean printedSomething=false;
{
      for (      BasePermission p : mSettings.mPermissions.values()) {
        if (packageName != null && !packageName.equals(p.sourcePackage)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(p.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(p)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(p.sourcePackage);
        pw.print(""String_Node_Str"");
        pw.print(p.uid);
        pw.print(""String_Node_Str"");
        pw.print(arrayToString(p.gids));
        pw.print(""String_Node_Str"");
        pw.print(p.type);
        pw.print(""String_Node_Str"");
        pw.println(p.protectionLevel);
        if (p.packageSetting != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.packageSetting);
        }
        if (p.perm != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.perm);
        }
      }
    }
    printedSomething=false;
    SharedUserSetting packageSharedUser=null;
{
      for (      PackageSetting ps : mSettings.mPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        packageSharedUser=ps.sharedUser;
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(ps.gids));
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
        if (ps.pkg != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.dataDir);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.targetSdkVersion);
          pw.print(""String_Node_Str"");
          boolean first=true;
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
        }
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(ps.getTimeStampStr());
        pw.print(""String_Node_Str"");
        pw.println(ps.signatures);
        pw.print(""String_Node_Str"");
        pw.print(ps.permissionsFixed);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(ps.pkgFlags));
        pw.print(""String_Node_Str"");
        pw.print(ps.installStatus);
        pw.print(""String_Node_Str"");
        pw.println(ps.enabled);
        if (ps.disabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.disabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.enabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.enabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.grantedPermissions.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.grantedPermissions) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
      }
    }
    printedSomething=false;
    if (mSettings.mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mSettings.mRenamedPackages.entrySet()) {
        if (packageName != null && !packageName.equals(e.getKey()) && !packageName.equals(e.getValue())) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(e.getKey());
        pw.print(""String_Node_Str"");
        pw.println(e.getValue());
      }
    }
    printedSomething=false;
    if (mSettings.mDisabledSysPackages.size() > 0) {
      for (      PackageSetting ps : mSettings.mDisabledSysPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.println(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
      }
    }
    printedSomething=false;
{
      for (      SharedUserSetting su : mSettings.mSharedUsers.values()) {
        if (packageName != null && su != packageSharedUser) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(su.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(su)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(su.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(su.gids));
        pw.println(""String_Node_Str"");
        for (        String s : su.grantedPermissions) {
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
    if (packageName == null) {
      if (printedTitle)       pw.println(""String_Node_Str"");
      printedTitle=true;
      pw.println(""String_Node_Str"");
      pw.println(mSettings.mReadMessages.toString());
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      File fname=getSettingsProblemFile();
      FileInputStream in;
      try {
        in=new FileInputStream(fname);
        int avail=in.available();
        byte[] data=new byte[avail];
        in.read(data);
        pw.println(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
    }
  }
synchronized (mProviders) {
    boolean printedSomething=false;
    for (    PackageParser.Provider p : mProviders.values()) {
      if (packageName != null && !packageName.equals(p.info.packageName)) {
        continue;
      }
      if (!printedSomething) {
        if (printedTitle)         pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        printedSomething=true;
        printedTitle=true;
      }
      pw.print(""String_Node_Str"");
      pw.print(p.info.authority);
      pw.print(""String_Node_Str"");
      pw.println(p.toString());
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if (""String_Node_Str"".equals(opt)) {
    }
 else     if (""String_Node_Str"".equals(opt)) {
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      return;
    }
 else {
      pw.println(""String_Node_Str"" + opt + ""String_Node_Str"");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if (""String_Node_Str"".equals(cmd) || cmd.contains(""String_Node_Str"")) {
      packageName=cmd;
    }
  }
  boolean printedTitle=false;
synchronized (mPackages) {
    if (mActivities.dump(pw,""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mReceivers.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mServices.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    if (mSettings.mPreferredActivities.dump(pw,printedTitle ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",packageName)) {
      printedTitle=true;
    }
    boolean printedSomething=false;
{
      for (      BasePermission p : mSettings.mPermissions.values()) {
        if (packageName != null && !packageName.equals(p.sourcePackage)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(p.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(p)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(p.sourcePackage);
        pw.print(""String_Node_Str"");
        pw.print(p.uid);
        pw.print(""String_Node_Str"");
        pw.print(arrayToString(p.gids));
        pw.print(""String_Node_Str"");
        pw.print(p.type);
        pw.print(""String_Node_Str"");
        pw.println(p.protectionLevel);
        if (p.packageSetting != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.packageSetting);
        }
        if (p.perm != null) {
          pw.print(""String_Node_Str"");
          pw.println(p.perm);
        }
      }
    }
    printedSomething=false;
    SharedUserSetting packageSharedUser=null;
{
      for (      PackageSetting ps : mSettings.mPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        packageSharedUser=ps.sharedUser;
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(ps.gids));
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
        if (ps.pkg != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.dataDir);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.applicationInfo.targetSdkVersion);
          pw.print(""String_Node_Str"");
          boolean first=true;
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
          if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
            if (!first)             pw.print(""String_Node_Str"");
            first=false;
            pw.print(""String_Node_Str"");
          }
        }
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.println(ps.getTimeStampStr());
        pw.print(""String_Node_Str"");
        pw.println(ps.signatures);
        pw.print(""String_Node_Str"");
        pw.print(ps.permissionsFixed);
        pw.print(""String_Node_Str"");
        pw.println(ps.haveGids);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(ps.pkgFlags));
        pw.print(""String_Node_Str"");
        pw.print(ps.installStatus);
        pw.print(""String_Node_Str"");
        pw.println(ps.enabled);
        if (ps.disabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.disabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.enabledComponents.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.enabledComponents) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
        if (ps.grantedPermissions.size() > 0) {
          pw.println(""String_Node_Str"");
          for (          String s : ps.grantedPermissions) {
            pw.print(""String_Node_Str"");
            pw.println(s);
          }
        }
      }
    }
    printedSomething=false;
    if (mSettings.mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mSettings.mRenamedPackages.entrySet()) {
        if (packageName != null && !packageName.equals(e.getKey()) && !packageName.equals(e.getValue())) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(e.getKey());
        pw.print(""String_Node_Str"");
        pw.println(e.getValue());
      }
    }
    printedSomething=false;
    if (mSettings.mDisabledSysPackages.size() > 0) {
      for (      PackageSetting ps : mSettings.mDisabledSysPackages.values()) {
        if (packageName != null && !packageName.equals(ps.realName) && !packageName.equals(ps.name)) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(ps.realName != null ? ps.realName : ps.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(ps)));
        pw.println(""String_Node_Str"");
        if (ps.realName != null) {
          pw.print(""String_Node_Str"");
          pw.println(ps.name);
        }
        pw.print(""String_Node_Str"");
        pw.println(ps.userId);
        pw.print(""String_Node_Str"");
        pw.println(ps.sharedUser);
        pw.print(""String_Node_Str"");
        pw.println(ps.codePathString);
        pw.print(""String_Node_Str"");
        pw.println(ps.resourcePathString);
      }
    }
    printedSomething=false;
{
      for (      SharedUserSetting su : mSettings.mSharedUsers.values()) {
        if (packageName != null && su != packageSharedUser) {
          continue;
        }
        if (!printedSomething) {
          if (printedTitle)           pw.println(""String_Node_Str"");
          pw.println(""String_Node_Str"");
          printedSomething=true;
          printedTitle=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(su.name);
        pw.print(""String_Node_Str"");
        pw.print(Integer.toHexString(System.identityHashCode(su)));
        pw.println(""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(su.userId);
        pw.print(""String_Node_Str"");
        pw.println(arrayToString(su.gids));
        pw.println(""String_Node_Str"");
        for (        String s : su.grantedPermissions) {
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
    if (packageName == null) {
      if (printedTitle)       pw.println(""String_Node_Str"");
      printedTitle=true;
      pw.println(""String_Node_Str"");
      pw.println(mSettings.mReadMessages.toString());
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"");
      File fname=getSettingsProblemFile();
      FileInputStream in;
      try {
        in=new FileInputStream(fname);
        int avail=in.available();
        byte[] data=new byte[avail];
        in.read(data);
        pw.println(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
    }
  }
synchronized (mProviders) {
    boolean printedSomething=false;
    for (    PackageParser.Provider p : mProviders.values()) {
      if (packageName != null && !packageName.equals(p.info.packageName)) {
        continue;
      }
      if (!printedSomething) {
        if (printedTitle)         pw.println(""String_Node_Str"");
        pw.println(""String_Node_Str"");
        printedSomething=true;
        printedTitle=true;
      }
      pw.print(""String_Node_Str"");
      pw.print(p.info.authority);
      pw.print(""String_Node_Str"");
      pw.println(p.toString());
    }
  }
}",0.9968414403032216
182178,"private boolean trackSignalStrength(){
  return getPreferences().getBoolean(SIGNAL_PREF,true);
}","private boolean trackSignalStrength(){
  return getPreferences().getBoolean(SIGNAL_PREF,false);
}",0.9637305699481864
182179,"private boolean doDebugLogging(){
  return getPreferences().getBoolean(DEBUG_PREF,true);
}","private boolean doDebugLogging(){
  return getPreferences().getBoolean(DEBUG_PREF,false);
}",0.9613259668508288
182180,"/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}","/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomRightStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}",0.9893778452200304
182181,"/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}","/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomRightStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}",0.9893778452200304
182182,"/** 
 * Sets the drawable to use as the left part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theleft strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}","/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}",0.6371951219512195
182183,"/** 
 * Sets the drawable to use as the left part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theleft strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}","/** 
 * Sets the drawable to use as the right part of the strip below the tab indicators.
 * @param resId the resource identifier of the drawable to use as theright strip drawable
 */
public void setRightStripDrawable(int resId){
  mBottomLeftStrip=mContext.getResources().getDrawable(resId);
  requestLayout();
  invalidate();
}",0.6371951219512195
182184,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0 && (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
 else {
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}",0.879740980573543
182185,"public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          mICallback.linkToDeath(this,0);
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          mICallback.unlinkToDeath(this,0);
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}","public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          if (mICallback != null) {
            mICallback.linkToDeath(this,0);
          }
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          if (mICallback != null) {
            mICallback.unlinkToDeath(this,0);
          }
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}",0.9624624624624624
182186,"/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,streamState.mIndex);
}","/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  int index;
  if (streamState.muteCount() != 0) {
    if (adjustVolume) {
      streamState.adjustLastAudibleIndex(direction);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
    index=streamState.mLastAudibleIndex;
  }
 else {
    if (adjustVolume && streamState.adjustIndex(direction)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
    index=streamState.mIndex;
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}",0.784503631961259
182187,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,false);
  }
}",0.9978909310033144
182188,"private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (isStreamMutedByRingerMode(streamType)) {
      if (!isStreamAffectedByRingerMode(streamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
        mStreamStates[streamType].mute(null,false);
        mRingerModeMutedStreams&=~(1 << streamType);
      }
    }
 else {
      if (isStreamAffectedByRingerMode(streamType) && mRingerMode != AudioManager.RINGER_MODE_NORMAL) {
        mStreamStates[streamType].mute(null,true);
        mRingerModeMutedStreams|=(1 << streamType);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}",0.3765786452353616
182189,"private VolumeDeathHandler getDeathHandler(IBinder cb,boolean state){
synchronized (mDeathHandlers) {
    VolumeDeathHandler handler;
    int size=mDeathHandlers.size();
    for (int i=0; i < size; i++) {
      handler=mDeathHandlers.get(i);
      if (cb.equals(handler.mICallback)) {
        return handler;
      }
    }
    if (state) {
      handler=new VolumeDeathHandler(cb);
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      handler=null;
    }
    return handler;
  }
}","private VolumeDeathHandler getDeathHandler(IBinder cb,boolean state){
synchronized (mDeathHandlers) {
    VolumeDeathHandler handler;
    int size=mDeathHandlers.size();
    for (int i=0; i < size; i++) {
      handler=mDeathHandlers.get(i);
      if (cb == handler.mICallback) {
        return handler;
      }
    }
    if (state) {
      handler=new VolumeDeathHandler(cb);
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      handler=null;
    }
    return handler;
  }
}",0.9864724245577524
182190,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  final int oldIndex=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  index=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}",0.7969413763806287
182191,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0 && (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
 else {
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.muteCount() != 0) {
    streamState.setLastAudibleIndex(index);
    sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
  }
 else {
    if (streamState.setIndex(index,lastAudible) || force) {
      if (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0) {
        sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
      }
 else {
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
      }
    }
  }
}",0.879740980573543
182192,"public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          mICallback.linkToDeath(this,0);
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          mICallback.unlinkToDeath(this,0);
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}","public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          if (mICallback != null) {
            mICallback.linkToDeath(this,0);
          }
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          if (mICallback != null) {
            mICallback.unlinkToDeath(this,0);
          }
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}",0.9624624624624624
182193,"/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,streamState.mIndex);
}","/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  int index;
  if (streamState.muteCount() != 0) {
    if (adjustVolume) {
      streamState.adjustLastAudibleIndex(direction);
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
    index=streamState.mLastAudibleIndex;
  }
 else {
    if (adjustVolume && streamState.adjustIndex(direction)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
    index=streamState.mIndex;
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}",0.784503631961259
182194,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,false);
  }
}",0.9978909310033144
182195,"private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (isStreamMutedByRingerMode(streamType)) {
      if (!isStreamAffectedByRingerMode(streamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
        mStreamStates[streamType].mute(null,false);
        mRingerModeMutedStreams&=~(1 << streamType);
      }
    }
 else {
      if (isStreamAffectedByRingerMode(streamType) && mRingerMode != AudioManager.RINGER_MODE_NORMAL) {
        mStreamStates[streamType].mute(null,true);
        mRingerModeMutedStreams|=(1 << streamType);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}",0.3765786452353616
182196,"private VolumeDeathHandler getDeathHandler(IBinder cb,boolean state){
synchronized (mDeathHandlers) {
    VolumeDeathHandler handler;
    int size=mDeathHandlers.size();
    for (int i=0; i < size; i++) {
      handler=mDeathHandlers.get(i);
      if (cb.equals(handler.mICallback)) {
        return handler;
      }
    }
    if (state) {
      handler=new VolumeDeathHandler(cb);
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      handler=null;
    }
    return handler;
  }
}","private VolumeDeathHandler getDeathHandler(IBinder cb,boolean state){
synchronized (mDeathHandlers) {
    VolumeDeathHandler handler;
    int size=mDeathHandlers.size();
    for (int i=0; i < size; i++) {
      handler=mDeathHandlers.get(i);
      if (cb == handler.mICallback) {
        return handler;
      }
    }
    if (state) {
      handler=new VolumeDeathHandler(cb);
    }
 else {
      Log.w(TAG,""String_Node_Str"");
      handler=null;
    }
    return handler;
  }
}",0.9864724245577524
182197,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  final int oldIndex=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  index=(streamState.muteCount() != 0) ? streamState.mLastAudibleIndex : streamState.mIndex;
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}",0.7969413763806287
182198,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}",0.9822085889570552
182199,"/** 
 * Helper function: Remove focus listeners from the focus stack for a particular client.
 */
private void removeFocusStackEntryForClient(IBinder cb){
  Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
  while (stackIterator.hasNext()) {
    FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
    if (fse.mSourceRef.equals(cb)) {
      Log.i(TAG,""String_Node_Str"" + fse.mClientId);
      mFocusStack.remove(fse);
    }
  }
}","/** 
 * Helper function: Remove focus listeners from the focus stack for a particular client.
 */
private void removeFocusStackEntryForClient(IBinder cb){
  boolean isTopOfStackForClientToRemove=!mFocusStack.isEmpty() && mFocusStack.peek().mSourceRef.equals(cb);
  Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
  while (stackIterator.hasNext()) {
    FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
    if (fse.mSourceRef.equals(cb)) {
      Log.i(TAG,""String_Node_Str"" + fse.mClientId);
      mFocusStack.remove(fse);
    }
  }
  if (isTopOfStackForClientToRemove) {
    notifyTopOfAudioFocusStack();
  }
}",0.8298068077276909
182200,"/** 
 * Helper function: Remove a focus listener from the focus stack.
 * @param focusListenerToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holdingfocus, notify the next item in the stack it gained focus.
 */
private void removeFocusStackEntry(String clientToRemove,boolean signal){
  if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
    mFocusStack.pop();
    if (signal) {
      if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null) && canReassignAudioFocus()) {
        try {
          mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN,mFocusStack.peek().mClientId);
        }
 catch (        RemoteException e) {
          Log.e(TAG,""String_Node_Str"" + e);
          e.printStackTrace();
        }
      }
    }
  }
 else {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
      if (fse.mClientId.equals(clientToRemove)) {
        Log.i(TAG,""String_Node_Str"" + fse.mClientId);
        mFocusStack.remove(fse);
      }
    }
  }
}","/** 
 * Helper function: Remove a focus listener from the focus stack.
 * @param focusListenerToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holdingfocus, notify the next item in the stack it gained focus.
 */
private void removeFocusStackEntry(String clientToRemove,boolean signal){
  if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
    mFocusStack.pop();
    if (signal) {
      notifyTopOfAudioFocusStack();
    }
  }
 else {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
      if (fse.mClientId.equals(clientToRemove)) {
        Log.i(TAG,""String_Node_Str"" + fse.mClientId);
        mFocusStack.remove(fse);
      }
    }
  }
}",0.5766458433445459
182201,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      mFocusStack.peek().mFocusChangeType=focusChangeHint;
      return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9829181494661922
182202,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        checkForUndispatchedAudioFocusChange(mMode,mode);
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
        if (mode != AudioSystem.MODE_NORMAL) {
          clearAllScoClients();
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}",0.9822085889570552
182203,"/** 
 * Helper function: Remove focus listeners from the focus stack for a particular client.
 */
private void removeFocusStackEntryForClient(IBinder cb){
  Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
  while (stackIterator.hasNext()) {
    FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
    if (fse.mSourceRef.equals(cb)) {
      Log.i(TAG,""String_Node_Str"" + fse.mClientId);
      mFocusStack.remove(fse);
    }
  }
}","/** 
 * Helper function: Remove focus listeners from the focus stack for a particular client.
 */
private void removeFocusStackEntryForClient(IBinder cb){
  boolean isTopOfStackForClientToRemove=!mFocusStack.isEmpty() && mFocusStack.peek().mSourceRef.equals(cb);
  Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
  while (stackIterator.hasNext()) {
    FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
    if (fse.mSourceRef.equals(cb)) {
      Log.i(TAG,""String_Node_Str"" + fse.mClientId);
      mFocusStack.remove(fse);
    }
  }
  if (isTopOfStackForClientToRemove) {
    notifyTopOfAudioFocusStack();
  }
}",0.8298068077276909
182204,"/** 
 * Helper function: Remove a focus listener from the focus stack.
 * @param focusListenerToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holdingfocus, notify the next item in the stack it gained focus.
 */
private void removeFocusStackEntry(String clientToRemove,boolean signal){
  if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
    mFocusStack.pop();
    if (signal) {
      if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null) && canReassignAudioFocus()) {
        try {
          mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(AudioManager.AUDIOFOCUS_GAIN,mFocusStack.peek().mClientId);
        }
 catch (        RemoteException e) {
          Log.e(TAG,""String_Node_Str"" + e);
          e.printStackTrace();
        }
      }
    }
  }
 else {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
      if (fse.mClientId.equals(clientToRemove)) {
        Log.i(TAG,""String_Node_Str"" + fse.mClientId);
        mFocusStack.remove(fse);
      }
    }
  }
}","/** 
 * Helper function: Remove a focus listener from the focus stack.
 * @param focusListenerToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holdingfocus, notify the next item in the stack it gained focus.
 */
private void removeFocusStackEntry(String clientToRemove,boolean signal){
  if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientToRemove)) {
    mFocusStack.pop();
    if (signal) {
      notifyTopOfAudioFocusStack();
    }
  }
 else {
    Iterator<FocusStackEntry> stackIterator=mFocusStack.iterator();
    while (stackIterator.hasNext()) {
      FocusStackEntry fse=(FocusStackEntry)stackIterator.next();
      if (fse.mClientId.equals(clientToRemove)) {
        Log.i(TAG,""String_Node_Str"" + fse.mClientId);
        mFocusStack.remove(fse);
      }
    }
  }
}",0.5766458433445459
182205,"/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      mFocusStack.peek().mFocusChangeType=focusChangeHint;
      return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}","/** 
 * @see AudioManager#requestAudioFocus(IAudioFocusDispatcher,int,int) 
 */
public int requestAudioFocus(int mainStreamType,int focusChangeHint,IBinder cb,IAudioFocusDispatcher fd,String clientId){
  Log.i(TAG,""String_Node_Str"" + clientId);
  if ((cb == null) || !cb.pingBinder()) {
    Log.i(TAG,""String_Node_Str"");
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
  if (!canReassignAudioFocus()) {
    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
  }
synchronized (mFocusStack) {
    if (!mFocusStack.empty() && mFocusStack.peek().mClientId.equals(clientId)) {
      if (mFocusStack.peek().mFocusChangeType == focusChangeHint) {
        return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
      }
      mFocusStack.pop();
    }
    if (!mFocusStack.empty() && (mFocusStack.peek().mFocusDispatcher != null)) {
      try {
        mFocusStack.peek().mFocusDispatcher.dispatchAudioFocusChange(-1 * focusChangeHint,mFocusStack.peek().mClientId);
      }
 catch (      RemoteException e) {
        Log.e(TAG,""String_Node_Str"" + e);
        e.printStackTrace();
      }
    }
    mFocusStack.push(new FocusStackEntry(mainStreamType,focusChangeHint,false,fd,cb,clientId));
  }
  AudioFocusDeathHandler afdh=new AudioFocusDeathHandler(cb);
  try {
    cb.linkToDeath(afdh,0);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
  }
  return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}",0.9829181494661922
182206,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9956709956709956
182207,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}",0.9908443540183112
182208,"private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  boolean removeExisting=false;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      removeExisting=true;
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (removeExisting) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    if (mInstaller != null) {
      int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
      if (ret != 0) {
        String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
        reportSettingsProblem(Log.WARN,msg);
        mLastScanError=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
        return null;
      }
    }
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  }
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}","private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
      reportSettingsProblem(Log.WARN,msg);
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}",0.8171160094844999
182209,"public PointerLocationView(Context c){
  super(c);
  mVC=ViewConfiguration.get(c);
  mTextPaint=new Paint();
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTextSize(10 * getResources().getDisplayMetrics().density);
  mTextPaint.setARGB(255,0,0,0);
  mTextBackgroundPaint=new Paint();
  mTextBackgroundPaint.setAntiAlias(false);
  mTextBackgroundPaint.setARGB(128,255,255,255);
  mTextLevelPaint=new Paint();
  mTextLevelPaint.setAntiAlias(false);
  mTextLevelPaint.setARGB(192,255,0,0);
  mPaint=new Paint();
  mPaint.setAntiAlias(true);
  mPaint.setARGB(255,255,255,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(2);
  mTargetPaint=new Paint();
  mTargetPaint.setAntiAlias(false);
  mTargetPaint.setARGB(255,0,0,192);
  mPathPaint=new Paint();
  mPathPaint.setAntiAlias(false);
  mPathPaint.setARGB(255,0,96,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(1);
  PointerState ps=new PointerState();
  ps.mVelocity=VelocityTracker.obtain();
  mPointers.add(ps);
}","public PointerLocationView(Context c){
  super(c);
  setFocusable(true);
  mVC=ViewConfiguration.get(c);
  mTextPaint=new Paint();
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTextSize(10 * getResources().getDisplayMetrics().density);
  mTextPaint.setARGB(255,0,0,0);
  mTextBackgroundPaint=new Paint();
  mTextBackgroundPaint.setAntiAlias(false);
  mTextBackgroundPaint.setARGB(128,255,255,255);
  mTextLevelPaint=new Paint();
  mTextLevelPaint.setAntiAlias(false);
  mTextLevelPaint.setARGB(192,255,0,0);
  mPaint=new Paint();
  mPaint.setAntiAlias(true);
  mPaint.setARGB(255,255,255,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(2);
  mTargetPaint=new Paint();
  mTargetPaint.setAntiAlias(false);
  mTargetPaint.setARGB(255,0,0,192);
  mPathPaint=new Paint();
  mPathPaint.setAntiAlias(false);
  mPathPaint.setARGB(255,0,96,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(1);
  PointerState ps=new PointerState();
  ps.mVelocity=VelocityTracker.obtain();
  mPointers.add(ps);
}",0.9891944990176816
182210,"public void run(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              if (JUMPY_TOUCH_HACK) {
                ms.dropJumpyPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Slog.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Slog.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Slog.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Slog.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              if (JUMPY_TOUCH_HACK) {
                ms.dropJumpyPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Slog.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Slog.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Slog.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Slog.e(TAG,""String_Node_Str"",exc);
    }
  }
}",0.9987062149599883
182211,"private boolean writeFileLocked(){
  if (mFile.exists()) {
    if (!mFile.renameTo(mBackupFile)) {
      Log.e(TAG,""String_Node_Str"" + mFile + ""String_Node_Str""+ mBackupFile);
      return false;
    }
  }
  try {
    FileOutputStream str=createFileOutputStream(mFile);
    if (str == null) {
      return false;
    }
    XmlUtils.writeMapXml(mMap,str);
    str.close();
    setFilePermissionsFromMode(mFile.getPath(),mMode,0);
    if (FileUtils.getFileStatus(mFile.getPath(),mFileStatus)) {
      mTimestamp=mFileStatus.mtime;
    }
    mBackupFile.delete();
    return true;
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  if (mFile.exists()) {
    if (!mFile.delete()) {
      Log.e(TAG,""String_Node_Str"" + mFile);
    }
  }
  return false;
}","private boolean writeFileLocked(){
  if (mFile.exists()) {
    if (!mBackupFile.exists()) {
      if (!mFile.renameTo(mBackupFile)) {
        Log.e(TAG,""String_Node_Str"" + mFile + ""String_Node_Str""+ mBackupFile);
        return false;
      }
    }
 else {
      mFile.delete();
    }
  }
  try {
    FileOutputStream str=createFileOutputStream(mFile);
    if (str == null) {
      return false;
    }
    XmlUtils.writeMapXml(mMap,str);
    str.close();
    setFilePermissionsFromMode(mFile.getPath(),mMode,0);
    if (FileUtils.getFileStatus(mFile.getPath(),mFileStatus)) {
      mTimestamp=mFileStatus.mtime;
    }
    mBackupFile.delete();
    return true;
  }
 catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"",e);
  }
  if (mFile.exists()) {
    if (!mFile.delete()) {
      Log.e(TAG,""String_Node_Str"" + mFile);
    }
  }
  return false;
}",0.953344575604272
182212,"/** 
 * Copy data from a source stream to destFile. Return true if succeed, return false if failed.
 */
public static boolean copyToFile(InputStream inputStream,File destFile){
  try {
    OutputStream out=new FileOutputStream(destFile);
    try {
      byte[] buffer=new byte[4096];
      int bytesRead;
      while ((bytesRead=inputStream.read(buffer)) >= 0) {
        out.write(buffer,0,bytesRead);
      }
    }
  finally {
      out.close();
    }
    return true;
  }
 catch (  IOException e) {
    return false;
  }
}","/** 
 * Copy data from a source stream to destFile. Return true if succeed, return false if failed.
 */
public static boolean copyToFile(InputStream inputStream,File destFile){
  try {
    if (destFile.exists()) {
      destFile.delete();
    }
    OutputStream out=new FileOutputStream(destFile);
    try {
      byte[] buffer=new byte[4096];
      int bytesRead;
      while ((bytesRead=inputStream.read(buffer)) >= 0) {
        out.write(buffer,0,bytesRead);
      }
    }
  finally {
      out.close();
    }
    return true;
  }
 catch (  IOException e) {
    return false;
  }
}",0.9458483754512635
182213,"/** 
 * Stops the current view recycer tracing. Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.traces</code> containing all the traces (or method calls) relative to the specified view's recycler. Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.recycler</code> containing all of the views used by the recycler of the view supplied to  {@link #startRecyclerTracing(String,View)}. This method will return immediately if TRACE_RECYCLER is false.
 * @see #startRecyclerTracing(String,View)
 * @see #trace(View,android.view.ViewDebug.RecyclerTraceType,int[])
 */
public static void stopRecyclerTracing(){
  if (!TRACE_RECYCLER) {
    return;
  }
  if (sRecyclerOwnerView == null || sRecyclerViews == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  File recyclerDump=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  recyclerDump.mkdirs();
  recyclerDump=new File(recyclerDump,sRecyclerTracePrefix + ""String_Node_Str"");
  try {
    final BufferedWriter out=new BufferedWriter(new FileWriter(recyclerDump),8 * 1024);
    for (    View view : sRecyclerViews) {
      final String name=view.getClass().getName();
      out.write(name);
      out.newLine();
    }
    out.close();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  recyclerDump=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  recyclerDump=new File(recyclerDump,sRecyclerTracePrefix + ""String_Node_Str"");
  try {
    final FileOutputStream file=new FileOutputStream(recyclerDump);
    final DataOutputStream out=new DataOutputStream(file);
    for (    RecyclerTrace trace : sRecyclerTraces) {
      out.writeInt(trace.view);
      out.writeInt(trace.type.ordinal());
      out.writeInt(trace.position);
      out.writeInt(trace.indexOnScreen);
      out.flush();
    }
    out.close();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  sRecyclerViews.clear();
  sRecyclerViews=null;
  sRecyclerTraces.clear();
  sRecyclerTraces=null;
  sRecyclerOwnerView=null;
}","/** 
 * Stops the current view recycer tracing. Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.traces</code> containing all the traces (or method calls) relative to the specified view's recycler. Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.recycler</code> containing all of the views used by the recycler of the view supplied to  {@link #startRecyclerTracing(String,View)}. This method will return immediately if TRACE_RECYCLER is false.
 * @see #startRecyclerTracing(String,View)
 * @see #trace(View,android.view.ViewDebug.RecyclerTraceType,int[])
 */
public static void stopRecyclerTracing(){
  if (!TRACE_RECYCLER) {
    return;
  }
  if (sRecyclerOwnerView == null || sRecyclerViews == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  File recyclerDump=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  recyclerDump.mkdirs();
  recyclerDump=new File(recyclerDump,sRecyclerTracePrefix + ""String_Node_Str"");
  try {
    final BufferedWriter out=new BufferedWriter(new FileWriter(recyclerDump),8 * 1024);
    for (    View view : sRecyclerViews) {
      final String name=view.getClass().getName();
      out.write(name);
      out.newLine();
    }
    out.close();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  recyclerDump=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  recyclerDump=new File(recyclerDump,sRecyclerTracePrefix + ""String_Node_Str"");
  try {
    if (recyclerDump.exists()) {
      recyclerDump.delete();
    }
    final FileOutputStream file=new FileOutputStream(recyclerDump);
    final DataOutputStream out=new DataOutputStream(file);
    for (    RecyclerTrace trace : sRecyclerTraces) {
      out.writeInt(trace.view);
      out.writeInt(trace.type.ordinal());
      out.writeInt(trace.position);
      out.writeInt(trace.indexOnScreen);
      out.flush();
    }
    out.close();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  sRecyclerViews.clear();
  sRecyclerViews=null;
  sRecyclerTraces.clear();
  sRecyclerTraces=null;
  sRecyclerOwnerView=null;
}",0.9844606946983546
182214,"public int performBackup(PackageInfo packageInfo,ParcelFileDescriptor data){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + packageInfo.packageName);
  File packageDir=new File(mDataDir,packageInfo.packageName);
  packageDir.mkdirs();
  BackupDataInput changeSet=new BackupDataInput(data.getFileDescriptor());
  try {
    int bufSize=512;
    byte[] buf=new byte[bufSize];
    while (changeSet.readNextHeader()) {
      String key=changeSet.getKey();
      String base64Key=new String(Base64.encode(key.getBytes()));
      File entityFile=new File(packageDir,base64Key);
      int dataSize=changeSet.getDataSize();
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ dataSize+ ""String_Node_Str""+ base64Key);
      if (dataSize >= 0) {
        FileOutputStream entity=new FileOutputStream(entityFile);
        if (dataSize > bufSize) {
          bufSize=dataSize;
          buf=new byte[bufSize];
        }
        changeSet.readEntityData(buf,0,dataSize);
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + dataSize);
        try {
          entity.write(buf,0,dataSize);
        }
 catch (        IOException e) {
          Log.e(TAG,""String_Node_Str"" + entityFile.getAbsolutePath());
          return BackupConstants.TRANSPORT_ERROR;
        }
 finally {
          entity.close();
        }
      }
 else {
        entityFile.delete();
      }
    }
    return BackupConstants.TRANSPORT_OK;
  }
 catch (  IOException e) {
    Log.v(TAG,""String_Node_Str"",e);
    return BackupConstants.TRANSPORT_ERROR;
  }
}","public int performBackup(PackageInfo packageInfo,ParcelFileDescriptor data){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + packageInfo.packageName);
  File packageDir=new File(mDataDir,packageInfo.packageName);
  packageDir.mkdirs();
  BackupDataInput changeSet=new BackupDataInput(data.getFileDescriptor());
  try {
    int bufSize=512;
    byte[] buf=new byte[bufSize];
    while (changeSet.readNextHeader()) {
      String key=changeSet.getKey();
      String base64Key=new String(Base64.encode(key.getBytes()));
      File entityFile=new File(packageDir,base64Key);
      int dataSize=changeSet.getDataSize();
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ dataSize+ ""String_Node_Str""+ base64Key);
      if (dataSize >= 0) {
        if (entityFile.exists()) {
          entityFile.delete();
        }
        FileOutputStream entity=new FileOutputStream(entityFile);
        if (dataSize > bufSize) {
          bufSize=dataSize;
          buf=new byte[bufSize];
        }
        changeSet.readEntityData(buf,0,dataSize);
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + dataSize);
        try {
          entity.write(buf,0,dataSize);
        }
 catch (        IOException e) {
          Log.e(TAG,""String_Node_Str"" + entityFile.getAbsolutePath());
          return BackupConstants.TRANSPORT_ERROR;
        }
 finally {
          entity.close();
        }
      }
 else {
        entityFile.delete();
      }
    }
    return BackupConstants.TRANSPORT_OK;
  }
 catch (  IOException e) {
    Log.v(TAG,""String_Node_Str"",e);
    return BackupConstants.TRANSPORT_ERROR;
  }
}",0.9759036144578314
182215,"public FileOutputStream startWrite() throws IOException {
  if (mBaseName.exists()) {
    if (!mBaseName.renameTo(mBackupName)) {
      mBackupName.delete();
      if (!mBaseName.renameTo(mBackupName)) {
        Log.w(""String_Node_Str"",""String_Node_Str"" + mBaseName + ""String_Node_Str""+ mBackupName);
      }
    }
  }
  FileOutputStream str=null;
  try {
    str=new FileOutputStream(mBaseName);
  }
 catch (  FileNotFoundException e) {
    File parent=mBaseName.getParentFile();
    if (!parent.mkdir()) {
      throw new IOException(""String_Node_Str"" + mBaseName);
    }
    FileUtils.setPermissions(parent.getPath(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,-1,-1);
    try {
      str=new FileOutputStream(mBaseName);
    }
 catch (    FileNotFoundException e2) {
      throw new IOException(""String_Node_Str"" + mBaseName);
    }
  }
  return str;
}","public FileOutputStream startWrite() throws IOException {
  if (mBaseName.exists()) {
    if (!mBackupName.exists()) {
      if (!mBaseName.renameTo(mBackupName)) {
        Log.w(""String_Node_Str"",""String_Node_Str"" + mBaseName + ""String_Node_Str""+ mBackupName);
      }
    }
 else {
      mBaseName.delete();
    }
  }
  FileOutputStream str=null;
  try {
    str=new FileOutputStream(mBaseName);
  }
 catch (  FileNotFoundException e) {
    File parent=mBaseName.getParentFile();
    if (!parent.mkdir()) {
      throw new IOException(""String_Node_Str"" + mBaseName);
    }
    FileUtils.setPermissions(parent.getPath(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,-1,-1);
    try {
      str=new FileOutputStream(mBaseName);
    }
 catch (    FileNotFoundException e2) {
      throw new IOException(""String_Node_Str"" + mBaseName);
    }
  }
  return str;
}",0.8259620907524411
182216,"public void writeLocked(){
  if ((mFile == null) || (mBackupFile == null)) {
    Log.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  if (mFile.exists()) {
    if (mBackupFile.exists()) {
      mBackupFile.delete();
    }
    if (!mFile.renameTo(mBackupFile)) {
      Log.w(""String_Node_Str"",""String_Node_Str"");
      return;
    }
  }
  try {
    FileOutputStream stream=new FileOutputStream(mFile);
    Parcel out=Parcel.obtain();
    writeSummaryToParcel(out);
    stream.write(out.marshall());
    out.recycle();
    stream.flush();
    stream.close();
    mBackupFile.delete();
    mLastWriteTime=SystemClock.elapsedRealtime();
    return;
  }
 catch (  IOException e) {
    Log.w(""String_Node_Str"",""String_Node_Str"",e);
  }
  if (mFile.exists()) {
    if (!mFile.delete()) {
      Log.w(TAG,""String_Node_Str"" + mFile);
    }
  }
}","public void writeLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  try {
    FileOutputStream stream=new FileOutputStream(mFile.chooseForWrite());
    Parcel out=Parcel.obtain();
    writeSummaryToParcel(out);
    stream.write(out.marshall());
    out.recycle();
    stream.flush();
    stream.close();
    mFile.commit();
    mLastWriteTime=SystemClock.elapsedRealtime();
    return;
  }
 catch (  IOException e) {
    Slog.w(""String_Node_Str"",""String_Node_Str"",e);
  }
  mFile.rollback();
}",0.5320836337418889
182217,"public void updateKernelWakelocksLocked(){
  Map<String,KernelWakelockStats> m=readKernelWakelockStats();
  if (m == null) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  for (  Map.Entry<String,KernelWakelockStats> ent : m.entrySet()) {
    String name=ent.getKey();
    KernelWakelockStats kws=ent.getValue();
    SamplingTimer kwlt=mKernelWakelockStats.get(name);
    if (kwlt == null) {
      kwlt=new SamplingTimer(mUnpluggables,mOnBatteryInternal,true);
      mKernelWakelockStats.put(name,kwlt);
    }
    kwlt.updateCurrentReportedCount(kws.mCount);
    kwlt.updateCurrentReportedTotalTime(kws.mTotalTime);
    kwlt.setUpdateVersion(sKernelWakelockUpdateVersion);
  }
  if (m.size() != mKernelWakelockStats.size()) {
    for (    Map.Entry<String,SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
      SamplingTimer st=ent.getValue();
      if (st.getUpdateVersion() != sKernelWakelockUpdateVersion) {
        st.setStale();
      }
    }
  }
}","public void updateKernelWakelocksLocked(){
  Map<String,KernelWakelockStats> m=readKernelWakelockStats();
  if (m == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  for (  Map.Entry<String,KernelWakelockStats> ent : m.entrySet()) {
    String name=ent.getKey();
    KernelWakelockStats kws=ent.getValue();
    SamplingTimer kwlt=mKernelWakelockStats.get(name);
    if (kwlt == null) {
      kwlt=new SamplingTimer(mUnpluggables,mOnBatteryInternal,true);
      mKernelWakelockStats.put(name,kwlt);
    }
    kwlt.updateCurrentReportedCount(kws.mCount);
    kwlt.updateCurrentReportedTotalTime(kws.mTotalTime);
    kwlt.setUpdateVersion(sKernelWakelockUpdateVersion);
  }
  if (m.size() != mKernelWakelockStats.size()) {
    for (    Map.Entry<String,SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
      SamplingTimer st=ent.getValue();
      if (st.getUpdateVersion() != sKernelWakelockUpdateVersion) {
        st.setStale();
      }
    }
  }
}",0.9984464008285864
182218,"private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryLastUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mBatteryLastRealtime=in.readLong();
  mUptime=in.readLong();
  mLastUptime=in.readLong();
  mRealtime=in.readLong();
  mLastRealtime=in.readLong();
  mDischargeStartLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mWifiRunning=false;
  mWifiRunningTimer.readSummaryFromParcelLocked(in);
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  int NKW=in.readInt();
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  final int NU=in.readInt();
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiTurnedOn=false;
    u.mWifiTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mFullWifiLockOut=false;
    u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    u.mAudioTurnedOn=false;
    u.mAudioTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mVideoTurnedOn=false;
    u.mVideoTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mScanWifiLockOut=false;
    u.mScanWifiLockTimer.readSummaryFromParcelLocked(in);
    u.mWifiMulticastEnabled=false;
    u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mLastUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mLastSystemTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      p.mLastStarts=in.readInt();
    }
    NP=in.readInt();
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      p.mLastWakeups=in.readInt();
      final int NS=in.readInt();
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mLastStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLastStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
        s.mLastLaunches=in.readInt();
      }
    }
    u.mLoadedTcpBytesReceived=in.readLong();
    u.mLoadedTcpBytesSent=in.readLong();
  }
}","private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryLastUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mBatteryLastRealtime=in.readLong();
  mUptime=in.readLong();
  mLastUptime=in.readLong();
  mRealtime=in.readLong();
  mLastRealtime=in.readLong();
  mDischargeStartLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mWifiRunning=false;
  mWifiRunningTimer.readSummaryFromParcelLocked(in);
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiTurnedOn=false;
    u.mWifiTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mFullWifiLockOut=false;
    u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    u.mAudioTurnedOn=false;
    u.mAudioTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mVideoTurnedOn=false;
    u.mVideoTurnedOnTimer.readSummaryFromParcelLocked(in);
    u.mScanWifiLockOut=false;
    u.mScanWifiLockTimer.readSummaryFromParcelLocked(in);
    u.mWifiMulticastEnabled=false;
    u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mLastUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mLastSystemTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      p.mLastStarts=in.readInt();
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      p.mLastWakeups=in.readInt();
      final int NS=in.readInt();
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mLastStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLastStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
        s.mLastLaunches=in.readInt();
      }
    }
    u.mLoadedTcpBytesReceived=in.readLong();
    u.mLoadedTcpBytesSent=in.readLong();
  }
}",0.9481979615425028
182219,"public void readLocked(){
  if ((mFile == null) || (mBackupFile == null)) {
    Log.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  FileInputStream stream=null;
  if (mBackupFile.exists()) {
    try {
      stream=new FileInputStream(mBackupFile);
    }
 catch (    java.io.IOException e) {
    }
  }
  try {
    if (stream == null) {
      if (!mFile.exists()) {
        return;
      }
      stream=new FileInputStream(mFile);
    }
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  java.io.IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}","public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  java.io.IOException e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}",0.1544401544401544
182220,"public BatteryStatsImpl(Parcel p){
  mFile=mBackupFile=null;
  readFromParcel(p);
}","public BatteryStatsImpl(Parcel p){
  mFile=null;
  readFromParcel(p);
}",0.922077922077922
182221,"void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}","void writeLP(){
  if (mSettingsFilename.exists()) {
    if (!mBackupSettingsFilename.exists()) {
      if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
 else {
      mSettingsFilename.delete();
      Slog.w(TAG,""String_Node_Str"");
    }
  }
  mPastSignatures.clear();
  try {
    FileOutputStream str=new FileOutputStream(mSettingsFilename);
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(str,""String_Node_Str"");
    serializer.startDocument(null,true);
    serializer.setFeature(""String_Node_Str"",true);
    serializer.startTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissionTrees.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.startTag(null,""String_Node_Str"");
    for (    BasePermission bp : mPermissions.values()) {
      writePermission(serializer,bp);
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    PackageSetting pkg : mPackages.values()) {
      writePackage(serializer,pkg);
    }
    for (    PackageSetting pkg : mDisabledSysPackages.values()) {
      writeDisabledSysPackage(serializer,pkg);
    }
    serializer.startTag(null,""String_Node_Str"");
    for (    PreferredActivity pa : mPreferredActivities.filterSet()) {
      serializer.startTag(null,""String_Node_Str"");
      pa.writeToXml(serializer);
      serializer.endTag(null,""String_Node_Str"");
    }
    serializer.endTag(null,""String_Node_Str"");
    for (    SharedUserSetting usr : mSharedUsers.values()) {
      serializer.startTag(null,""String_Node_Str"");
      serializer.attribute(null,""String_Node_Str"",usr.name);
      serializer.attribute(null,""String_Node_Str"",Integer.toString(usr.userId));
      usr.signatures.writeXml(serializer,""String_Node_Str"",mPastSignatures);
      serializer.startTag(null,""String_Node_Str"");
      for (      String name : usr.grantedPermissions) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",name);
        serializer.endTag(null,""String_Node_Str"");
      }
      serializer.endTag(null,""String_Node_Str"");
      serializer.endTag(null,""String_Node_Str"");
    }
    if (mPackagesToBeCleaned.size() > 0) {
      for (int i=0; i < mPackagesToBeCleaned.size(); i++) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",mPackagesToBeCleaned.get(i));
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    if (mRenamedPackages.size() > 0) {
      for (      HashMap.Entry<String,String> e : mRenamedPackages.entrySet()) {
        serializer.startTag(null,""String_Node_Str"");
        serializer.attribute(null,""String_Node_Str"",e.getKey());
        serializer.attribute(null,""String_Node_Str"",e.getValue());
        serializer.endTag(null,""String_Node_Str"");
      }
    }
    serializer.endTag(null,""String_Node_Str"");
    serializer.endDocument();
    str.flush();
    str.close();
    mBackupSettingsFilename.delete();
    FileUtils.setPermissions(mSettingsFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    File tempFile=new File(mPackageListFilename.toString() + ""String_Node_Str"");
    JournaledFile journal=new JournaledFile(mPackageListFilename,tempFile);
    str=new FileOutputStream(journal.chooseForWrite());
    try {
      StringBuilder sb=new StringBuilder();
      for (      PackageSetting pkg : mPackages.values()) {
        ApplicationInfo ai=pkg.pkg.applicationInfo;
        String dataPath=ai.dataDir;
        boolean isDebug=(ai.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
        if (dataPath.indexOf(""String_Node_Str"") >= 0 || ai.uid <= Process.FIRST_APPLICATION_UID)         continue;
        sb.setLength(0);
        sb.append(ai.packageName);
        sb.append(""String_Node_Str"");
        sb.append((int)ai.uid);
        sb.append(isDebug ? ""String_Node_Str"" : ""String_Node_Str"");
        sb.append(dataPath);
        sb.append(""String_Node_Str"");
        str.write(sb.toString().getBytes());
      }
      str.flush();
      str.close();
      journal.commit();
    }
 catch (    Exception e) {
      journal.rollback();
    }
    FileUtils.setPermissions(mPackageListFilename.toString(),FileUtils.S_IRUSR | FileUtils.S_IWUSR | FileUtils.S_IRGRP| FileUtils.S_IWGRP| FileUtils.S_IROTH,-1,-1);
    return;
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  java.io.IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
  if (mSettingsFilename.exists()) {
    if (!mSettingsFilename.delete()) {
      Log.i(TAG,""String_Node_Str"" + mSettingsFilename);
    }
  }
}",0.9964583333333332
182222,"boolean restoreNamedResourceLocked(){
  if (mName.length() > 4 && ""String_Node_Str"".equals(mName.substring(0,4))) {
    String resName=mName.substring(4);
    String pkg=null;
    int colon=resName.indexOf(':');
    if (colon > 0) {
      pkg=resName.substring(0,colon);
    }
    String ident=null;
    int slash=resName.lastIndexOf('/');
    if (slash > 0) {
      ident=resName.substring(slash + 1);
    }
    String type=null;
    if (colon > 0 && slash > 0 && (slash - colon) > 1) {
      type=resName.substring(colon + 1,slash);
    }
    if (pkg != null && ident != null && type != null) {
      int resId=-1;
      InputStream res=null;
      FileOutputStream fos=null;
      try {
        Context c=mContext.createPackageContext(pkg,Context.CONTEXT_RESTRICTED);
        Resources r=c.getResources();
        resId=r.getIdentifier(resName,null,null);
        if (resId == 0) {
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ type+ ""String_Node_Str""+ ident);
          return false;
        }
        res=r.openRawResource(resId);
        fos=new FileOutputStream(WALLPAPER_FILE);
        byte[] buffer=new byte[32768];
        int amt;
        while ((amt=res.read(buffer)) > 0) {
          fos.write(buffer,0,amt);
        }
        Slog.v(TAG,""String_Node_Str"" + resName);
        return true;
      }
 catch (      NameNotFoundException e) {
        Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
      }
catch (      Resources.NotFoundException e) {
        Slog.e(TAG,""String_Node_Str"" + resId);
      }
catch (      IOException e) {
        Slog.e(TAG,""String_Node_Str"",e);
      }
 finally {
        if (res != null) {
          try {
            res.close();
          }
 catch (          IOException ex) {
          }
        }
        if (fos != null) {
          try {
            fos.close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
  return false;
}","boolean restoreNamedResourceLocked(){
  if (mName.length() > 4 && ""String_Node_Str"".equals(mName.substring(0,4))) {
    String resName=mName.substring(4);
    String pkg=null;
    int colon=resName.indexOf(':');
    if (colon > 0) {
      pkg=resName.substring(0,colon);
    }
    String ident=null;
    int slash=resName.lastIndexOf('/');
    if (slash > 0) {
      ident=resName.substring(slash + 1);
    }
    String type=null;
    if (colon > 0 && slash > 0 && (slash - colon) > 1) {
      type=resName.substring(colon + 1,slash);
    }
    if (pkg != null && ident != null && type != null) {
      int resId=-1;
      InputStream res=null;
      FileOutputStream fos=null;
      try {
        Context c=mContext.createPackageContext(pkg,Context.CONTEXT_RESTRICTED);
        Resources r=c.getResources();
        resId=r.getIdentifier(resName,null,null);
        if (resId == 0) {
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ type+ ""String_Node_Str""+ ident);
          return false;
        }
        res=r.openRawResource(resId);
        if (WALLPAPER_FILE.exists()) {
          WALLPAPER_FILE.delete();
        }
        fos=new FileOutputStream(WALLPAPER_FILE);
        byte[] buffer=new byte[32768];
        int amt;
        while ((amt=res.read(buffer)) > 0) {
          fos.write(buffer,0,amt);
        }
        Slog.v(TAG,""String_Node_Str"" + resName);
        return true;
      }
 catch (      NameNotFoundException e) {
        Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
      }
catch (      Resources.NotFoundException e) {
        Slog.e(TAG,""String_Node_Str"" + resId);
      }
catch (      IOException e) {
        Slog.e(TAG,""String_Node_Str"",e);
      }
 finally {
        if (res != null) {
          try {
            res.close();
          }
 catch (          IOException ex) {
          }
        }
        if (fos != null) {
          try {
            fos.close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
  return false;
}",0.9668008048289738
182223,"private void writeStatsToFile(boolean force){
synchronized (mFileLock) {
    mCal.setTimeInMillis(System.currentTimeMillis());
    final int curDay=mCal.get(Calendar.DAY_OF_YEAR);
    final boolean dayChanged=curDay != mLastWriteDay;
    long currElapsedTime=SystemClock.elapsedRealtime();
    if (!force) {
      if (((currElapsedTime - mLastWriteElapsedTime) < FILE_WRITE_INTERVAL) && (!dayChanged)) {
        return;
      }
    }
    mFileLeaf=getCurrentDateStr(FILE_PREFIX);
    File backupFile=null;
    if (mFile != null && mFile.exists()) {
      backupFile=new File(mFile.getPath() + ""String_Node_Str"");
      if (!mFile.renameTo(backupFile)) {
        Slog.w(TAG,""String_Node_Str"");
        return;
      }
    }
    try {
      writeStatsFLOCK();
      mLastWriteElapsedTime=currElapsedTime;
      if (dayChanged) {
        mLastWriteDay=curDay;
synchronized (mStats) {
          mStats.clear();
        }
        mFile=new File(mDir,mFileLeaf);
        checkFileLimitFLOCK();
      }
      if (backupFile != null) {
        backupFile.delete();
      }
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + mFile);
      if (backupFile != null) {
        mFile.delete();
        backupFile.renameTo(mFile);
      }
    }
  }
}","private void writeStatsToFile(boolean force){
synchronized (mFileLock) {
    mCal.setTimeInMillis(System.currentTimeMillis());
    final int curDay=mCal.get(Calendar.DAY_OF_YEAR);
    final boolean dayChanged=curDay != mLastWriteDay;
    long currElapsedTime=SystemClock.elapsedRealtime();
    if (!force) {
      if (((currElapsedTime - mLastWriteElapsedTime) < FILE_WRITE_INTERVAL) && (!dayChanged)) {
        return;
      }
    }
    mFileLeaf=getCurrentDateStr(FILE_PREFIX);
    File backupFile=null;
    if (mFile != null && mFile.exists()) {
      backupFile=new File(mFile.getPath() + ""String_Node_Str"");
      if (!backupFile.exists()) {
        if (!mFile.renameTo(backupFile)) {
          Slog.w(TAG,""String_Node_Str"");
          return;
        }
      }
 else {
        mFile.delete();
      }
    }
    try {
      writeStatsFLOCK();
      mLastWriteElapsedTime=currElapsedTime;
      if (dayChanged) {
        mLastWriteDay=curDay;
synchronized (mStats) {
          mStats.clear();
        }
        mFile=new File(mDir,mFileLeaf);
        checkFileLimitFLOCK();
      }
      if (backupFile != null) {
        backupFile.delete();
      }
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + mFile);
      if (backupFile != null) {
        mFile.delete();
        backupFile.renameTo(mFile);
      }
    }
  }
}",0.9607993850883936
182224,"public PointerLocationView(Context c){
  super(c);
  mVC=ViewConfiguration.get(c);
  mTextPaint=new Paint();
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTextSize(10 * getResources().getDisplayMetrics().density);
  mTextPaint.setARGB(255,0,0,0);
  mTextBackgroundPaint=new Paint();
  mTextBackgroundPaint.setAntiAlias(false);
  mTextBackgroundPaint.setARGB(128,255,255,255);
  mTextLevelPaint=new Paint();
  mTextLevelPaint.setAntiAlias(false);
  mTextLevelPaint.setARGB(192,255,0,0);
  mPaint=new Paint();
  mPaint.setAntiAlias(true);
  mPaint.setARGB(255,255,255,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(2);
  mTargetPaint=new Paint();
  mTargetPaint.setAntiAlias(false);
  mTargetPaint.setARGB(255,0,0,192);
  mPathPaint=new Paint();
  mPathPaint.setAntiAlias(false);
  mPathPaint.setARGB(255,0,96,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(1);
  PointerState ps=new PointerState();
  ps.mVelocity=VelocityTracker.obtain();
  mPointers.add(ps);
}","public PointerLocationView(Context c){
  super(c);
  setFocusable(true);
  mVC=ViewConfiguration.get(c);
  mTextPaint=new Paint();
  mTextPaint.setAntiAlias(true);
  mTextPaint.setTextSize(10 * getResources().getDisplayMetrics().density);
  mTextPaint.setARGB(255,0,0,0);
  mTextBackgroundPaint=new Paint();
  mTextBackgroundPaint.setAntiAlias(false);
  mTextBackgroundPaint.setARGB(128,255,255,255);
  mTextLevelPaint=new Paint();
  mTextLevelPaint.setAntiAlias(false);
  mTextLevelPaint.setARGB(192,255,0,0);
  mPaint=new Paint();
  mPaint.setAntiAlias(true);
  mPaint.setARGB(255,255,255,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(2);
  mTargetPaint=new Paint();
  mTargetPaint.setAntiAlias(false);
  mTargetPaint.setARGB(255,0,0,192);
  mPathPaint=new Paint();
  mPathPaint.setAntiAlias(false);
  mPathPaint.setARGB(255,0,96,255);
  mPaint.setStyle(Paint.Style.STROKE);
  mPaint.setStrokeWidth(1);
  PointerState ps=new PointerState();
  ps.mVelocity=VelocityTracker.obtain();
  mPointers.add(ps);
}",0.9891944990176816
182225,"public void run(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              if (JUMPY_TOUCH_HACK) {
                ms.dropJumpyPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Slog.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Slog.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Slog.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Slog.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Slog.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Slog.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Slog.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              if (JUMPY_TOUCH_HACK) {
                ms.dropJumpyPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Slog.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Slog.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.everChanged=true;
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Slog.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Slog.e(TAG,""String_Node_Str"",exc);
    }
  }
}",0.9987062149599883
182226,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9956709956709956
182227,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}",0.9908443540183112
182228,"private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  boolean removeExisting=false;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      removeExisting=true;
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (removeExisting) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    if (mInstaller != null) {
      int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
      if (ret != 0) {
        String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
        reportSettingsProblem(Log.WARN,msg);
        mLastScanError=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
        return null;
      }
    }
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  }
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}","private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
      reportSettingsProblem(Log.WARN,msg);
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}",0.8171160094844999
182229,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Slog.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mSecureAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Slog.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Slog.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,""String_Node_Str"");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg=""String_Node_Str"" + ps.name + ""String_Node_Str"";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP(null,null,true,false);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9956709956709956
182230,"public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}","public void onEvent(int event,String path){
  String removedPackage=null;
  int removedUid=-1;
  String addedPackage=null;
  int addedUid=-1;
synchronized (mInstallLock) {
    String fullPathStr=null;
    File fullPath=null;
    if (path != null) {
      fullPath=new File(mRootDir,path);
      fullPathStr=fullPath.getPath();
    }
    if (Config.LOGV)     Log.v(TAG,""String_Node_Str"" + fullPathStr + ""String_Node_Str""+ Integer.toHexString(event));
    if (!isPackageFilename(path)) {
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + fullPathStr);
      return;
    }
    if (ignoreCodePath(fullPathStr)) {
      return;
    }
    PackageParser.Package p=null;
synchronized (mPackages) {
      p=mAppDirs.get(fullPathStr);
    }
    if ((event & REMOVE_EVENTS) != 0) {
      if (p != null) {
        removePackageLI(p,true);
        removedPackage=p.applicationInfo.packageName;
        removedUid=p.applicationInfo.uid;
      }
    }
    if ((event & ADD_EVENTS) != 0) {
      if (p == null) {
        p=scanPackageLI(fullPath,(mIsRom ? PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR : 0) | PackageParser.PARSE_CHATTY | PackageParser.PARSE_MUST_BE_APK,SCAN_MONITOR | SCAN_NO_PATHS);
        if (p != null) {
synchronized (mPackages) {
            updatePermissionsLP(p.packageName,p,p.permissions.size() > 0,false);
          }
          addedPackage=p.applicationInfo.packageName;
          addedUid=p.applicationInfo.uid;
        }
      }
    }
synchronized (mPackages) {
      mSettings.writeLP();
    }
  }
  if (removedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,removedUid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED,false);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED,removedPackage,extras);
  }
  if (addedPackage != null) {
    Bundle extras=new Bundle(1);
    extras.putInt(Intent.EXTRA_UID,addedUid);
    sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,addedPackage,extras);
  }
}",0.9908443540183112
182231,"private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  boolean removeExisting=false;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      removeExisting=true;
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (removeExisting) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    if (mInstaller != null) {
      int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
      if (ret != 0) {
        String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
        reportSettingsProblem(Log.WARN,msg);
        mLastScanError=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
        return null;
      }
    }
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  }
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}","private PackageParser.Package scanPackageLI(PackageParser.Package pkg,int parseFlags,int scanMode){
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkg.packageName.equals(""String_Node_Str"")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"");
        Slog.w(TAG,""String_Node_Str"" + mScanningPath);
        Slog.w(TAG,""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,""String_Node_Str"" + pkg.packageName);
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    Slog.w(TAG,""String_Node_Str"");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesLibraries.get(i)+ ""String_Node_Str"");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.usesOptionalLibraries.get(i)+ ""String_Node_Str"");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Slog.e(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ fi.name+ ""String_Node_Str"");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + pkg.mSharedUserId + ""String_Node_Str""+ suid.userId+ ""String_Node_Str""+ suid.packages);
      }
    }
    if (false) {
      if (pkg.mOriginalPackages != null) {
        Log.w(TAG,""String_Node_Str"");
        Debug.waitForDebugger();
        Log.i(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ pkg.mOriginalPackages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLP(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdate(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,""String_Node_Str"" + origPackage.name + ""String_Node_Str""+ pkg.packageName+ ""String_Node_Str""+ origPackage.sharedUser.name+ ""String_Node_Str""+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Slog.w(TAG,""String_Node_Str"" + pkg.packageName + ""String_Node_Str"");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg=""String_Node_Str"" + pkgSetting.realName + ""String_Node_Str""+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
      reportSettingsProblem(Log.WARN,msg);
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(""String_Node_Str"");
          for (int j=0; j < names.length; j++) {
            if (mProviders.containsKey(names[j])) {
              PackageParser.Provider other=mProviders.get(names[j]);
              Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  if (pkg.mAdoptPermissions != null) {
    for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
      String origName=pkg.mAdoptPermissions.get(i);
      PackageSetting orig=mSettings.peekPackageLP(origName);
      if (orig != null) {
        if (verifyPackageUpdate(orig,pkg)) {
          Slog.i(TAG,""String_Node_Str"" + origName + ""String_Node_Str""+ pkg.packageName);
          mSettings.transferPermissions(origName,pkg.packageName);
        }
      }
    }
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),""String_Node_Str"");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    dataPath=getDataPathForPackage(pkg);
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str"";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir=""String_Node_Str"" + pkg.applicationInfo.uid + ""String_Node_Str""+ mOutPermissions[1];
          String msg=""String_Node_Str"" + pkg.packageName + ""String_Node_Str""+ mOutPermissions[1]+ ""String_Node_Str""+ pkg.applicationInfo.uid+ ""String_Node_Str"";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,""String_Node_Str"" + dataPath);
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + ""String_Node_Str"");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(""String_Node_Str"");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProviders.containsKey(names[j])) {
            mProviders.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ""String_Node_Str"" + names[j];
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)             Log.d(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ p.info.name+ ""String_Node_Str""+ p.info.isSyncable);
          }
 else {
            PackageParser.Provider other=mProviders.get(names[j]);
            Slog.w(TAG,""String_Node_Str"" + names[j] + ""String_Node_Str""+ pkg.applicationInfo.packageName+ ""String_Node_Str""+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : ""String_Node_Str""));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,""String_Node_Str"");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pg.info.name + ""String_Node_Str""+ pg.info.packageName+ ""String_Node_Str""+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ tree.name+ ""String_Node_Str""+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(""String_Node_Str"");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + p.info.name + ""String_Node_Str""+ p.info.packageName+ ""String_Node_Str""+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}",0.8171160094844999
182232,"@Override protected void onRestoreInstanceState(Bundle state){
  super.onRestoreInstanceState(state);
  Bundle container=state.getBundle(PREFERENCES_TAG);
  if (container != null) {
    final PreferenceScreen preferenceScreen=getPreferenceScreen();
    if (preferenceScreen != null) {
      preferenceScreen.restoreHierarchyState(container);
    }
  }
}","@Override protected void onRestoreInstanceState(Bundle state){
  Bundle container=state.getBundle(PREFERENCES_TAG);
  if (container != null) {
    final PreferenceScreen preferenceScreen=getPreferenceScreen();
    if (preferenceScreen != null) {
      preferenceScreen.restoreHierarchyState(container);
      mSavedInstanceState=state;
      return;
    }
  }
  super.onRestoreInstanceState(state);
}",0.8339973439575034
182233,"private void bindPreferences(){
  final PreferenceScreen preferenceScreen=getPreferenceScreen();
  if (preferenceScreen != null) {
    preferenceScreen.bind(getListView());
  }
}","private void bindPreferences(){
  final PreferenceScreen preferenceScreen=getPreferenceScreen();
  if (preferenceScreen != null) {
    preferenceScreen.bind(getListView());
    if (mSavedInstanceState != null) {
      super.onRestoreInstanceState(mSavedInstanceState);
      mSavedInstanceState=null;
    }
  }
}",0.726530612244898
182234,"@Override protected void onRestoreInstanceState(Bundle state){
  super.onRestoreInstanceState(state);
  Bundle container=state.getBundle(PREFERENCES_TAG);
  if (container != null) {
    final PreferenceScreen preferenceScreen=getPreferenceScreen();
    if (preferenceScreen != null) {
      preferenceScreen.restoreHierarchyState(container);
    }
  }
}","@Override protected void onRestoreInstanceState(Bundle state){
  Bundle container=state.getBundle(PREFERENCES_TAG);
  if (container != null) {
    final PreferenceScreen preferenceScreen=getPreferenceScreen();
    if (preferenceScreen != null) {
      preferenceScreen.restoreHierarchyState(container);
      mSavedInstanceState=state;
      return;
    }
  }
  super.onRestoreInstanceState(state);
}",0.8339973439575034
182235,"private void bindPreferences(){
  final PreferenceScreen preferenceScreen=getPreferenceScreen();
  if (preferenceScreen != null) {
    preferenceScreen.bind(getListView());
  }
}","private void bindPreferences(){
  final PreferenceScreen preferenceScreen=getPreferenceScreen();
  if (preferenceScreen != null) {
    preferenceScreen.bind(getListView());
    if (mSavedInstanceState != null) {
      super.onRestoreInstanceState(mSavedInstanceState);
      mSavedInstanceState=null;
    }
  }
}",0.726530612244898
182236,"/** 
 * Updates the engine configuration.
 */
public int setConfig(String engineConfig){
  return native_setConfig(engineConfig);
}","/** 
 * Updates the engine configuration.
 */
public int setConfig(String engineConfig){
  return native_setConfig(mJniData,engineConfig);
}",0.966789667896679
182237,private native final int native_setConfig(String engineConfig);,"private native final int native_setConfig(int jniData,String engineConfig);",0.9130434782608696
182238,"private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
          mPendingConfiguration=newConfig;
          applyConfigurationToResourcesLocked(newConfig);
        }
      }
      queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
    }
    public void onLowMemory(){
    }
  }
);
}","private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (applyConfigurationToResourcesLocked(newConfig)) {
          if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
            mPendingConfiguration=newConfig;
            queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
          }
        }
      }
    }
    public void onLowMemory(){
    }
  }
);
}",0.945538057742782
182239,"public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
      mPendingConfiguration=newConfig;
      applyConfigurationToResourcesLocked(newConfig);
    }
  }
  queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
}","public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (applyConfigurationToResourcesLocked(newConfig)) {
      if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
        mPendingConfiguration=newConfig;
        queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
      }
    }
  }
}",0.5835694050991501
182240,"final void applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return;
  }
  mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
}","final boolean applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return false;
  }
  int changes=mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
  return changes != 0;
}",0.9743336623889436
182241,"private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
          mPendingConfiguration=newConfig;
          applyConfigurationToResourcesLocked(newConfig);
        }
      }
      queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
    }
    public void onLowMemory(){
    }
  }
);
}","private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (applyConfigurationToResourcesLocked(newConfig)) {
          if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
            mPendingConfiguration=newConfig;
            queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
          }
        }
      }
    }
    public void onLowMemory(){
    }
  }
);
}",0.945538057742782
182242,"public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
      mPendingConfiguration=newConfig;
      applyConfigurationToResourcesLocked(newConfig);
    }
  }
  queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
}","public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (applyConfigurationToResourcesLocked(newConfig)) {
      if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
        mPendingConfiguration=newConfig;
        queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
      }
    }
  }
}",0.5835694050991501
182243,"final void applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return;
  }
  mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
}","final boolean applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return false;
  }
  int changes=mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
  return changes != 0;
}",0.9743336623889436
182244,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnTypeToWatchFor);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
mEnabled=true;
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnTypeToWatchFor);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
mEnabled=true;
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
if (mApnType != Phone.APN_TYPE_DEFAULT) {
mEnabled=false;
}
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}",0.981981981981982
182245,"private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
          mPendingConfiguration=newConfig;
          applyConfigurationToResourcesLocked(newConfig);
        }
      }
      queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
    }
    public void onLowMemory(){
    }
  }
);
}","private final void attach(boolean system){
  sThreadLocal.set(this);
  mSystemThread=system;
  if (!system) {
    ViewRoot.addFirstDrawHandler(new Runnable(){
      public void run(){
        ensureJitEnabled();
      }
    }
);
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    RuntimeInit.setApplicationObject(mAppThread.asBinder());
    IActivityManager mgr=ActivityManagerNative.getDefault();
    try {
      mgr.attachApplication(mAppThread);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    android.ddm.DdmHandleAppName.setAppName(""String_Node_Str"");
    try {
      mInstrumentation=new Instrumentation();
      ContextImpl context=new ContextImpl();
      context.init(getSystemContext().mPackageInfo,null,this);
      Application app=Instrumentation.newApplication(Application.class,context);
      mAllApplications.add(app);
      mInitialApplication=app;
      app.onCreate();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.toString(),e);
    }
  }
  ViewRoot.addConfigCallback(new ComponentCallbacks(){
    public void onConfigurationChanged(    Configuration newConfig){
synchronized (mPackages) {
        if (applyConfigurationToResourcesLocked(newConfig)) {
          if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
            mPendingConfiguration=newConfig;
            queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
          }
        }
      }
    }
    public void onLowMemory(){
    }
  }
);
}",0.945538057742782
182246,"public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
      mPendingConfiguration=newConfig;
      applyConfigurationToResourcesLocked(newConfig);
    }
  }
  queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
}","public void onConfigurationChanged(Configuration newConfig){
synchronized (mPackages) {
    if (applyConfigurationToResourcesLocked(newConfig)) {
      if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) {
        mPendingConfiguration=newConfig;
        queueOrSendMessage(H.CONFIGURATION_CHANGED,newConfig);
      }
    }
  }
}",0.5835694050991501
182247,"final void applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return;
  }
  mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
}","final boolean applyConfigurationToResourcesLocked(Configuration config){
  if (mResConfiguration == null) {
    mResConfiguration=new Configuration();
  }
  if (!mResConfiguration.isOtherSeqNewer(config)) {
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + mResConfiguration.seq + ""String_Node_Str""+ config.seq);
    return false;
  }
  int changes=mResConfiguration.updateFrom(config);
  DisplayMetrics dm=getDisplayMetricsLocked(true);
  if (config.locale != null) {
    Locale.setDefault(config.locale);
  }
  Resources.updateSystemConfiguration(config,dm);
  ContextImpl.ApplicationPackageManager.configurationChanged();
  Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
  while (it.hasNext()) {
    WeakReference<Resources> v=it.next();
    Resources r=v.get();
    if (r != null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ config);
      r.updateConfiguration(config,dm);
    }
 else {
      it.remove();
    }
  }
  return changes != 0;
}",0.9743336623889436
182248,"/** 
 * Updates the engine configuration.
 */
public int setConfig(String engineConfig){
  return native_setConfig(engineConfig);
}","/** 
 * Updates the engine configuration.
 */
public int setConfig(String engineConfig){
  return native_setConfig(mJniData,engineConfig);
}",0.966789667896679
182249,private native final int native_setConfig(String engineConfig);,"private native final int native_setConfig(int jniData,String engineConfig);",0.9130434782608696
182250,"private void recreateLockScreen(){
  if (mLockScreen.getVisibility() == View.VISIBLE) {
    ((KeyguardScreen)mLockScreen).onPause();
  }
  ((KeyguardScreen)mLockScreen).cleanUp();
  removeViewInLayout(mLockScreen);
  mLockScreen=createLockScreen();
  mLockScreen.setVisibility(View.INVISIBLE);
  addView(mLockScreen);
}","private void recreateLockScreen(){
  if (mLockScreen.getVisibility() == View.VISIBLE) {
    ((KeyguardScreen)mLockScreen).onPause();
  }
  ((KeyguardScreen)mLockScreen).cleanUp();
  removeView(mLockScreen);
  mLockScreen=createLockScreen();
  mLockScreen.setVisibility(View.INVISIBLE);
  addView(mLockScreen);
}",0.7492063492063492
182251,"private void updateScreen(final Mode mode){
  mMode=mode;
  if (mode == Mode.UnlockScreen && mCurrentUnlockMode != getUnlockMode()) {
    recreateUnlockScreen();
  }
  final View goneScreen=(mode == Mode.LockScreen) ? mUnlockScreen : mLockScreen;
  final View visibleScreen=(mode == Mode.LockScreen) ? mLockScreen : mUnlockScreen;
  mWindowController.setNeedsInput(((KeyguardScreen)visibleScreen).needsInput());
  if (mScreenOn) {
    if (goneScreen.getVisibility() == View.VISIBLE) {
      ((KeyguardScreen)goneScreen).onPause();
    }
    if (visibleScreen.getVisibility() != View.VISIBLE) {
      ((KeyguardScreen)visibleScreen).onResume();
    }
  }
  goneScreen.setVisibility(View.GONE);
  visibleScreen.setVisibility(View.VISIBLE);
  if (!visibleScreen.requestFocus()) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + visibleScreen.getClass().getCanonicalName());
  }
}","private void updateScreen(final Mode mode){
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + mode + ""String_Node_Str""+ mMode,new RuntimeException());
  mMode=mode;
  if (mode == Mode.UnlockScreen && mCurrentUnlockMode != getUnlockMode()) {
    recreateUnlockScreen();
  }
  final View goneScreen=(mode == Mode.LockScreen) ? mUnlockScreen : mLockScreen;
  final View visibleScreen=(mode == Mode.LockScreen) ? mLockScreen : mUnlockScreen;
  mWindowController.setNeedsInput(((KeyguardScreen)visibleScreen).needsInput());
  if (DEBUG_CONFIGURATION) {
    Log.v(TAG,""String_Node_Str"" + goneScreen);
    Log.v(TAG,""String_Node_Str"" + visibleScreen);
  }
  if (mScreenOn) {
    if (goneScreen.getVisibility() == View.VISIBLE) {
      ((KeyguardScreen)goneScreen).onPause();
    }
    if (visibleScreen.getVisibility() != View.VISIBLE) {
      ((KeyguardScreen)visibleScreen).onResume();
    }
  }
  goneScreen.setVisibility(View.GONE);
  visibleScreen.setVisibility(View.VISIBLE);
  requestLayout();
  if (!visibleScreen.requestFocus()) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + visibleScreen.getClass().getCanonicalName());
  }
}",0.8721659430776653
182252,"private void recreateUnlockScreen(){
  if (mUnlockScreen.getVisibility() == View.VISIBLE) {
    ((KeyguardScreen)mUnlockScreen).onPause();
  }
  ((KeyguardScreen)mUnlockScreen).cleanUp();
  removeViewInLayout(mUnlockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreen.setVisibility(View.INVISIBLE);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
}","private void recreateUnlockScreen(){
  if (mUnlockScreen.getVisibility() == View.VISIBLE) {
    ((KeyguardScreen)mUnlockScreen).onPause();
  }
  ((KeyguardScreen)mUnlockScreen).cleanUp();
  removeView(mUnlockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreen.setVisibility(View.INVISIBLE);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
}",0.9905882352941175
182253,"/** 
 * @param context Used to setup the view.
 * @param configuration The current configuration. Used to use when selecting layout, etc.
 * @param lockPatternUtils Used to know the state of the lock pattern settings.
 * @param updateMonitor Used to register for updates on various keyguard relatedstate, and query the initial state at setup.
 * @param callback Used to communicate back to the host keyguard view.
 */
LockScreen(Context context,Configuration configuration,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mEnableMenuKeyInLockScreen=shouldEnableMenuKey();
  mCreationOrientation=configuration.orientation;
  mKeyboardHidden=configuration.hardKeyboardHidden;
  final LayoutInflater inflater=LayoutInflater.from(context);
  if (DBG)   Log.v(TAG,""String_Node_Str"" + mCreationOrientation);
  if (mCreationOrientation != Configuration.ORIENTATION_LANDSCAPE) {
    inflater.inflate(R.layout.keyguard_screen_tab_unlock,this,true);
  }
 else {
    inflater.inflate(R.layout.keyguard_screen_tab_unlock_land,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCarrier.setSelected(true);
  mCarrier.setTextColor(0xffffffff);
  mDate=(TextView)findViewById(R.id.date);
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatus2=(TextView)findViewById(R.id.status2);
  mEmergencyCallButton=(Button)findViewById(R.id.emergencyCallButton);
  mEmergencyCallButton.setText(R.string.lockscreen_emergency_call);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCallButton);
  mScreenLocked=(TextView)findViewById(R.id.screenLocked);
  mSelector=(SlidingTab)findViewById(R.id.tab_selector);
  mSelector.setHoldAfterTrigger(true,false);
  mSelector.setLeftHintText(R.string.lockscreen_unlock_label);
  mEmergencyCallButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  mSilentMode=isSilentMode();
  mSelector.setLeftTabResources(R.drawable.ic_jog_dial_unlock,R.drawable.jog_tab_target_green,R.drawable.jog_tab_bar_left_unlock,R.drawable.jog_tab_left_unlock);
  updateRightTabResources();
  mSelector.setOnTriggerListener(this);
  resetStatusInfo(updateMonitor);
}","/** 
 * @param context Used to setup the view.
 * @param configuration The current configuration. Used to use when selecting layout, etc.
 * @param lockPatternUtils Used to know the state of the lock pattern settings.
 * @param updateMonitor Used to register for updates on various keyguard relatedstate, and query the initial state at setup.
 * @param callback Used to communicate back to the host keyguard view.
 */
LockScreen(Context context,Configuration configuration,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mEnableMenuKeyInLockScreen=shouldEnableMenuKey();
  mCreationOrientation=configuration.orientation;
  mKeyboardHidden=configuration.hardKeyboardHidden;
  if (LockPatternKeyguardView.DEBUG_CONFIGURATION) {
    Log.v(TAG,""String_Node_Str"",new RuntimeException());
    Log.v(TAG,""String_Node_Str"" + mCreationOrientation + ""String_Node_Str""+ context.getResources().getConfiguration().orientation);
  }
  final LayoutInflater inflater=LayoutInflater.from(context);
  if (DBG)   Log.v(TAG,""String_Node_Str"" + mCreationOrientation);
  if (mCreationOrientation != Configuration.ORIENTATION_LANDSCAPE) {
    inflater.inflate(R.layout.keyguard_screen_tab_unlock,this,true);
  }
 else {
    inflater.inflate(R.layout.keyguard_screen_tab_unlock_land,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCarrier.setSelected(true);
  mCarrier.setTextColor(0xffffffff);
  mDate=(TextView)findViewById(R.id.date);
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatus2=(TextView)findViewById(R.id.status2);
  mEmergencyCallButton=(Button)findViewById(R.id.emergencyCallButton);
  mEmergencyCallButton.setText(R.string.lockscreen_emergency_call);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCallButton);
  mScreenLocked=(TextView)findViewById(R.id.screenLocked);
  mSelector=(SlidingTab)findViewById(R.id.tab_selector);
  mSelector.setHoldAfterTrigger(true,false);
  mSelector.setLeftHintText(R.string.lockscreen_unlock_label);
  mEmergencyCallButton.setOnClickListener(new View.OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  mSilentMode=isSilentMode();
  mSelector.setLeftTabResources(R.drawable.ic_jog_dial_unlock,R.drawable.jog_tab_target_green,R.drawable.jog_tab_bar_left_unlock,R.drawable.jog_tab_left_unlock);
  updateRightTabResources();
  mSelector.setOnTriggerListener(this);
  resetStatusInfo(updateMonitor);
}",0.9555635838150288
182254,"/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (DBG) {
    Log.v(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    if (getResources().getConfiguration().orientation != newConfig.orientation) {
      Log.e(TAG,""String_Node_Str"",new Exception(""String_Node_Str""));
    }
  }
  if (newConfig.orientation != mCreationOrientation) {
    mCallback.recreateMe(newConfig);
  }
 else   if (newConfig.hardKeyboardHidden != mKeyboardHidden) {
    mKeyboardHidden=newConfig.hardKeyboardHidden;
    final boolean isKeyboardOpen=mKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO;
    if (mUpdateMonitor.isKeyguardBypassEnabled() && isKeyboardOpen) {
      mCallback.goToUnlockScreen();
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (LockPatternKeyguardView.DEBUG_CONFIGURATION) {
    Log.w(TAG,""String_Node_Str"",new RuntimeException());
    Log.v(TAG,""String_Node_Str"" + mCreationOrientation + ""String_Node_Str""+ newConfig);
  }
  updateConfiguration();
}",0.3706233988044407
182255,"/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (newConfig.orientation != mCreationOrientation) {
    mCallback.recreateMe(newConfig);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (LockPatternKeyguardView.DEBUG_CONFIGURATION) {
    Log.v(TAG,""String_Node_Str"");
    Log.v(TAG,""String_Node_Str"" + mCreationOrientation + ""String_Node_Str""+ getResources().getConfiguration());
  }
  if (newConfig.orientation != mCreationOrientation) {
    mCallback.recreateMe(newConfig);
  }
}",0.7036496350364964
182256,"/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (newConfig.orientation != mCreationOrientation) {
    mCallback.recreateMe(newConfig);
  }
 else   if (newConfig.hardKeyboardHidden != mKeyboardHidden) {
    mKeyboardHidden=newConfig.hardKeyboardHidden;
    final boolean isKeyboardOpen=mKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO;
    if (mUpdateMonitor.isKeyguardBypassEnabled() && isKeyboardOpen) {
      mCallback.goToUnlockScreen();
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override protected void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  updateConfiguration();
}",0.4581618655692729
182257,"/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
}","/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
  if (mSearchManager != null) {
    mSearchManager.stopSearch();
  }
}",0.9819419000261712
182258,"/** 
 * Constructor - fires it up and makes it look like the search UI.
 * @param context Application Context we can use for system acess
 */
public SearchDialog(Context context,SearchManager searchManager){
  super(context,com.android.internal.R.style.Theme_SearchBar);
  mVoiceWebSearchIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
  mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
  mVoiceAppSearchIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
  mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mSearchManager=searchManager;
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
  context.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        onConfigurationChanged();
      }
    }
  }
,filter);
}","/** 
 * Constructor - fires it up and makes it look like the search UI.
 * @param context Application Context we can use for system acess
 */
public SearchDialog(Context context,SearchManager searchManager){
  super(context,com.android.internal.R.style.Theme_SearchBar);
  mVoiceWebSearchIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
  mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
  mVoiceAppSearchIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
  mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mSearchManager=searchManager;
}",0.7932011331444759
182259,"/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}","/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  getContext().unregisterReceiver(mConfChangeListener);
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}",0.9399141630901288
182260,"/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
}","/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
  if (mSearchManager != null) {
    mSearchManager.stopSearch();
  }
}",0.9819419000261712
182261,"/** 
 * Constructor - fires it up and makes it look like the search UI.
 * @param context Application Context we can use for system acess
 */
public SearchDialog(Context context,SearchManager searchManager){
  super(context,com.android.internal.R.style.Theme_SearchBar);
  mVoiceWebSearchIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
  mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
  mVoiceAppSearchIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
  mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mSearchManager=searchManager;
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
  context.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        onConfigurationChanged();
      }
    }
  }
,filter);
}","/** 
 * Constructor - fires it up and makes it look like the search UI.
 * @param context Application Context we can use for system acess
 */
public SearchDialog(Context context,SearchManager searchManager){
  super(context,com.android.internal.R.style.Theme_SearchBar);
  mVoiceWebSearchIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
  mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
  mVoiceAppSearchIntent=new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
  mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
  mSearchManager=searchManager;
}",0.7932011331444759
182262,"/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}","/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  getContext().unregisterReceiver(mConfChangeListener);
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}",0.9399141630901288
182263,"void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  hideInputMethodMenu();
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
  int N=immis.size();
  mItems=new CharSequence[N];
  mIms=new InputMethodInfo[N];
  for (int i=0; i < N; ++i) {
    InputMethodInfo property=immis.get(i);
    if (property == null) {
      i--;
      N--;
      continue;
    }
    mItems[i]=property.loadLabel(pm);
    mIms[i]=property;
  }
  int checkedItem=0;
  for (int i=0; i < N; ++i) {
    if (mIms[i].getId().equals(lastInputMethodId)) {
      checkedItem=i;
      break;
    }
  }
  AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      hideInputMethodMenu();
    }
  }
;
  TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
  mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      hideInputMethodMenu();
    }
  }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
  a.recycle();
  mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
synchronized (mMethodMap) {
        if (mIms == null || mIms.length <= which) {
          return;
        }
        InputMethodInfo im=mIms[which];
        hideInputMethodMenu();
        if (im != null) {
          setInputMethodLocked(im.getId());
        }
      }
    }
  }
);
synchronized (mMethodMap) {
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}","void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
synchronized (mMethodMap) {
    hideInputMethodMenuLocked();
    int N=immis.size();
    mItems=new CharSequence[N];
    mIms=new InputMethodInfo[N];
    int j=0;
    for (int i=0; i < N; ++i) {
      InputMethodInfo property=immis.get(i);
      if (property == null) {
        continue;
      }
      mItems[j]=property.loadLabel(pm);
      mIms[j]=property;
      j++;
    }
    int checkedItem=0;
    for (int i=0; i < N; ++i) {
      if (mIms[i].getId().equals(lastInputMethodId)) {
        checkedItem=i;
        break;
      }
    }
    AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        hideInputMethodMenu();
      }
    }
;
    TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
    mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
      public void onCancel(      DialogInterface dialog){
        hideInputMethodMenu();
      }
    }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
    a.recycle();
    mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
synchronized (mMethodMap) {
          if (mIms == null || mIms.length <= which) {
            return;
          }
          InputMethodInfo im=mIms[which];
          hideInputMethodMenu();
          if (im != null) {
            setInputMethodLocked(im.getId());
          }
        }
      }
    }
);
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}",0.8853530950305144
182264,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnTypeToWatchFor);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
mEnabled=true;
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnTypeToWatchFor);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
mEnabled=true;
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
if (mApnType != Phone.APN_TYPE_DEFAULT) {
mEnabled=false;
}
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}",0.981981981981982
182265,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return;
  }
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}",0.6116642958748222
182266,"private String getIdForAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return new String();
  }
 else {
    return new String(this.toString() + l.toString());
  }
}","private String getIdForAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return new String(this.toString());
  }
 else {
    return new String(this.toString() + l.toString());
  }
}",0.9618320610687024
182267,"void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  hideInputMethodMenu();
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
  int N=immis.size();
  mItems=new CharSequence[N];
  mIms=new InputMethodInfo[N];
  for (int i=0; i < N; ++i) {
    InputMethodInfo property=immis.get(i);
    if (property == null) {
      i--;
      N--;
      continue;
    }
    mItems[i]=property.loadLabel(pm);
    mIms[i]=property;
  }
  int checkedItem=0;
  for (int i=0; i < N; ++i) {
    if (mIms[i].getId().equals(lastInputMethodId)) {
      checkedItem=i;
      break;
    }
  }
  AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      hideInputMethodMenu();
    }
  }
;
  TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
  mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      hideInputMethodMenu();
    }
  }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
  a.recycle();
  mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
synchronized (mMethodMap) {
        if (mIms == null || mIms.length <= which) {
          return;
        }
        InputMethodInfo im=mIms[which];
        hideInputMethodMenu();
        if (im != null) {
          setInputMethodLocked(im.getId());
        }
      }
    }
  }
);
synchronized (mMethodMap) {
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}","void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
synchronized (mMethodMap) {
    hideInputMethodMenuLocked();
    int N=immis.size();
    mItems=new CharSequence[N];
    mIms=new InputMethodInfo[N];
    int j=0;
    for (int i=0; i < N; ++i) {
      InputMethodInfo property=immis.get(i);
      if (property == null) {
        continue;
      }
      mItems[j]=property.loadLabel(pm);
      mIms[j]=property;
      j++;
    }
    int checkedItem=0;
    for (int i=0; i < N; ++i) {
      if (mIms[i].getId().equals(lastInputMethodId)) {
        checkedItem=i;
        break;
      }
    }
    AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        hideInputMethodMenu();
      }
    }
;
    TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
    mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
      public void onCancel(      DialogInterface dialog){
        hideInputMethodMenu();
      }
    }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
    a.recycle();
    mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
synchronized (mMethodMap) {
          if (mIms == null || mIms.length <= which) {
            return;
          }
          InputMethodInfo im=mIms[which];
          hideInputMethodMenu();
          if (im != null) {
            setInputMethodLocked(im.getId());
          }
        }
      }
    }
);
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}",0.8853530950305144
182268,"/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return;
  }
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}","/** 
 * Register a listener for audio focus updates.
 */
public void registerAudioFocusListener(OnAudioFocusChangeListener l){
synchronized (mFocusListenerLock) {
    if (mAudioFocusIdListenerMap.containsKey(getIdForAudioFocusListener(l))) {
      return;
    }
    mAudioFocusIdListenerMap.put(getIdForAudioFocusListener(l),l);
  }
}",0.6116642958748222
182269,"private String getIdForAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return new String();
  }
 else {
    return new String(this.toString() + l.toString());
  }
}","private String getIdForAudioFocusListener(OnAudioFocusChangeListener l){
  if (l == null) {
    return new String(this.toString());
  }
 else {
    return new String(this.toString() + l.toString());
  }
}",0.9618320610687024
182270,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (isPopupShowing()) {
    if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || (keyCode != KeyEvent.KEYCODE_ENTER && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
      int curIndex=mDropDownList.getSelectedItemPosition();
      boolean consumed;
      final boolean below=!mPopup.isAboveAnchor();
      final ListAdapter adapter=mDropDownList.getAdapter();
      final boolean allEnabled=adapter.areAllItemsEnabled();
      final int firstItem=allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0,true);
      final int lastItem=allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1,false);
      if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
        clearListSelection();
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
        showDropDown();
        return true;
      }
 else {
        mDropDownList.mListSelectionHidden=false;
      }
      consumed=mDropDownList.onKeyDown(keyCode,event);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ consumed);
      if (consumed) {
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
        mDropDownList.requestFocusFromTouch();
        showDropDown();
switch (keyCode) {
case KeyEvent.KEYCODE_ENTER:
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_DPAD_DOWN:
case KeyEvent.KEYCODE_DPAD_UP:
          return true;
      }
    }
 else {
      if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
        if (curIndex == lastItem) {
          return true;
        }
      }
 else       if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
        return true;
      }
    }
  }
}
 else {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_DOWN:
    performValidation();
}
}
mLastKeyCode=keyCode;
boolean handled=super.onKeyDown(keyCode,event);
mLastKeyCode=KeyEvent.KEYCODE_UNKNOWN;
if (handled && isPopupShowing() && mDropDownList != null) {
clearListSelection();
}
return handled;
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (isPopupShowing()) {
    if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || (keyCode != KeyEvent.KEYCODE_ENTER && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
      int curIndex=mDropDownList.getSelectedItemPosition();
      boolean consumed;
      final boolean below=!mPopup.isAboveAnchor();
      final ListAdapter adapter=mAdapter;
      boolean allEnabled;
      int firstItem=Integer.MAX_VALUE;
      int lastItem=Integer.MIN_VALUE;
      if (adapter != null) {
        allEnabled=adapter.areAllItemsEnabled();
        firstItem=allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0,true);
        lastItem=allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1,false);
      }
      if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
        clearListSelection();
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
        showDropDown();
        return true;
      }
 else {
        mDropDownList.mListSelectionHidden=false;
      }
      consumed=mDropDownList.onKeyDown(keyCode,event);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ consumed);
      if (consumed) {
        mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
        mDropDownList.requestFocusFromTouch();
        showDropDown();
switch (keyCode) {
case KeyEvent.KEYCODE_ENTER:
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_DPAD_DOWN:
case KeyEvent.KEYCODE_DPAD_UP:
          return true;
      }
    }
 else {
      if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
        if (curIndex == lastItem) {
          return true;
        }
      }
 else       if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
        return true;
      }
    }
  }
}
 else {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_DOWN:
    performValidation();
}
}
mLastKeyCode=keyCode;
boolean handled=super.onKeyDown(keyCode,event);
mLastKeyCode=KeyEvent.KEYCODE_UNKNOWN;
if (handled && isPopupShowing() && mDropDownList != null) {
clearListSelection();
}
return handled;
}",0.9350244770805518
182271,"public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}","public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
}",0.9333333333333332
182272,"public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}","public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
}",0.9333333333333332
182273,"/** 
 * Figures out the layout for the menu items.
 * @param width The available width for the icon menu.
 */
private void layoutItems(int width){
  int numItems=getChildCount();
  int curNumRows=Math.min((int)Math.ceil(numItems / (float)mMaxItemsPerRow),mMaxRows);
  for (; curNumRows <= mMaxRows; curNumRows++) {
    layoutItemsUsingGravity(curNumRows,numItems);
    if (curNumRows >= numItems) {
      break;
    }
    if (doItemsFit()) {
      break;
    }
  }
}","/** 
 * Figures out the layout for the menu items.
 * @param width The available width for the icon menu.
 */
private void layoutItems(int width){
  int numItems=getChildCount();
  if (numItems == 0) {
    mLayoutNumRows=0;
    return;
  }
  int curNumRows=Math.min((int)Math.ceil(numItems / (float)mMaxItemsPerRow),mMaxRows);
  for (; curNumRows <= mMaxRows; curNumRows++) {
    layoutItemsUsingGravity(curNumRows,numItems);
    if (curNumRows >= numItems) {
      break;
    }
    if (doItemsFit()) {
      break;
    }
  }
}",0.9385699899295066
182274,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mHasStaleChildren) {
    mHasStaleChildren=false;
    updateChildren(false);
  }
  int measuredWidth=resolveSize(Integer.MAX_VALUE,widthMeasureSpec);
  calculateItemFittingMetadata(measuredWidth);
  layoutItems(measuredWidth);
  final int desiredHeight=(mRowHeight + mHorizontalDividerHeight) * mLayoutNumRows - mHorizontalDividerHeight;
  setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec));
  positionChildren(mMeasuredWidth,mMeasuredHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mHasStaleChildren) {
    mHasStaleChildren=false;
    updateChildren(false);
  }
  int measuredWidth=resolveSize(Integer.MAX_VALUE,widthMeasureSpec);
  calculateItemFittingMetadata(measuredWidth);
  layoutItems(measuredWidth);
  final int layoutNumRows=mLayoutNumRows;
  final int desiredHeight=(mRowHeight + mHorizontalDividerHeight) * layoutNumRows - mHorizontalDividerHeight;
  setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec));
  if (layoutNumRows > 0) {
    positionChildren(mMeasuredWidth,mMeasuredHeight);
  }
}",0.911371237458194
182275,"/** 
 * Figures out the layout for the menu items.
 * @param width The available width for the icon menu.
 */
private void layoutItems(int width){
  int numItems=getChildCount();
  int curNumRows=Math.min((int)Math.ceil(numItems / (float)mMaxItemsPerRow),mMaxRows);
  for (; curNumRows <= mMaxRows; curNumRows++) {
    layoutItemsUsingGravity(curNumRows,numItems);
    if (curNumRows >= numItems) {
      break;
    }
    if (doItemsFit()) {
      break;
    }
  }
}","/** 
 * Figures out the layout for the menu items.
 * @param width The available width for the icon menu.
 */
private void layoutItems(int width){
  int numItems=getChildCount();
  if (numItems == 0) {
    mLayoutNumRows=0;
    return;
  }
  int curNumRows=Math.min((int)Math.ceil(numItems / (float)mMaxItemsPerRow),mMaxRows);
  for (; curNumRows <= mMaxRows; curNumRows++) {
    layoutItemsUsingGravity(curNumRows,numItems);
    if (curNumRows >= numItems) {
      break;
    }
    if (doItemsFit()) {
      break;
    }
  }
}",0.9385699899295066
182276,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mHasStaleChildren) {
    mHasStaleChildren=false;
    updateChildren(false);
  }
  int measuredWidth=resolveSize(Integer.MAX_VALUE,widthMeasureSpec);
  calculateItemFittingMetadata(measuredWidth);
  layoutItems(measuredWidth);
  final int desiredHeight=(mRowHeight + mHorizontalDividerHeight) * mLayoutNumRows - mHorizontalDividerHeight;
  setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec));
  positionChildren(mMeasuredWidth,mMeasuredHeight);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  if (mHasStaleChildren) {
    mHasStaleChildren=false;
    updateChildren(false);
  }
  int measuredWidth=resolveSize(Integer.MAX_VALUE,widthMeasureSpec);
  calculateItemFittingMetadata(measuredWidth);
  layoutItems(measuredWidth);
  final int layoutNumRows=mLayoutNumRows;
  final int desiredHeight=(mRowHeight + mHorizontalDividerHeight) * layoutNumRows - mHorizontalDividerHeight;
  setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec));
  if (layoutNumRows > 0) {
    positionChildren(mMeasuredWidth,mMeasuredHeight);
  }
}",0.911371237458194
182277,"/** 
 * See if the key event means we should leave touch mode (and leave touch mode if so).
 * @param event The key event.
 * @return Whether this key event should be consumed (meaning the act ofleaving touch mode alone is considered the event).
 */
private boolean checkForLeavingTouchModeAndConsume(KeyEvent event){
  if (event.getAction() != KeyEvent.ACTION_DOWN) {
    return false;
  }
  if ((event.getFlags() & KeyEvent.FLAG_KEEP_TOUCH_MODE) != 0) {
    return false;
  }
  if (!mAttachInfo.mInTouchMode) {
    return false;
  }
  if (isKeyboardKey(event) && mView != null && mView.hasFocus()) {
    mFocusedView=mView.findFocus();
    if ((mFocusedView instanceof ViewGroup) && ((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) {
      return false;
    }
    if (ensureTouchMode(false)) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    return false;
  }
  if (isDirectional(event.getKeyCode())) {
    return ensureTouchMode(false);
  }
  return false;
}","/** 
 * See if the key event means we should leave touch mode (and leave touch mode if so).
 * @param event The key event.
 * @return Whether this key event should be consumed (meaning the act ofleaving touch mode alone is considered the event).
 */
private boolean checkForLeavingTouchModeAndConsume(KeyEvent event){
  final int action=event.getAction();
  if (action != KeyEvent.ACTION_DOWN && action != KeyEvent.ACTION_MULTIPLE) {
    return false;
  }
  if ((event.getFlags() & KeyEvent.FLAG_KEEP_TOUCH_MODE) != 0) {
    return false;
  }
  if (!mAttachInfo.mInTouchMode) {
    return false;
  }
  if (isKeyboardKey(event) && mView != null && mView.hasFocus()) {
    mFocusedView=mView.findFocus();
    if ((mFocusedView instanceof ViewGroup) && ((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) {
      return false;
    }
    if (ensureTouchMode(false)) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    return false;
  }
  if (isDirectional(event.getKeyCode())) {
    return ensureTouchMode(false);
  }
  return false;
}",0.9660938225731538
182278,"public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
        if (mScrollY != 0) {
          mScrollY=0;
          invalidate();
        }
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}","public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}",0.9814471243042672
182279,"final void updateLocked(){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
      }
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    updateConfigurationLocked();
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    updateConfigurationLocked();
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9594594594594594
182280,"/** 
 * AccountUnlockScreen constructor.
 */
public AccountUnlockScreen(Context context,KeyguardScreenCallback callback,LockPatternUtils lockPatternUtils){
  super(context);
  mCallback=callback;
  mLockPatternUtils=lockPatternUtils;
  LayoutInflater.from(context).inflate(R.layout.keyguard_screen_glogin_unlock,this,true);
  mTopHeader=(TextView)findViewById(R.id.topHeader);
  mTopHeader.setText(mLockPatternUtils.isPermanentlyLocked() ? R.string.lockscreen_glogin_too_many_attempts : R.string.lockscreen_glogin_forgot_pattern);
  mInstructions=(TextView)findViewById(R.id.instructions);
  mLogin=(EditText)findViewById(R.id.login);
  mLogin.setFilters(new InputFilter[]{new LoginFilter.UsernameFilterGeneric()});
  mLogin.addTextChangedListener(this);
  mPassword=(EditText)findViewById(R.id.password);
  mPassword.addTextChangedListener(this);
  mOk=(Button)findViewById(R.id.ok);
  mOk.setOnClickListener(this);
  mEmergencyCall=(Button)findViewById(R.id.emergencyCall);
  mEmergencyCall.setOnClickListener(this);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCall);
}","/** 
 * AccountUnlockScreen constructor.
 * @param configuration
 */
public AccountUnlockScreen(Context context,Configuration configuration,KeyguardScreenCallback callback,LockPatternUtils lockPatternUtils){
  super(context);
  mCallback=callback;
  mLockPatternUtils=lockPatternUtils;
  LayoutInflater.from(context).inflate(R.layout.keyguard_screen_glogin_unlock,this,true);
  mTopHeader=(TextView)findViewById(R.id.topHeader);
  mTopHeader.setText(mLockPatternUtils.isPermanentlyLocked() ? R.string.lockscreen_glogin_too_many_attempts : R.string.lockscreen_glogin_forgot_pattern);
  mInstructions=(TextView)findViewById(R.id.instructions);
  mLogin=(EditText)findViewById(R.id.login);
  mLogin.setFilters(new InputFilter[]{new LoginFilter.UsernameFilterGeneric()});
  mLogin.addTextChangedListener(this);
  mPassword=(EditText)findViewById(R.id.password);
  mPassword.addTextChangedListener(this);
  mOk=(Button)findViewById(R.id.ok);
  mOk.setOnClickListener(this);
  mEmergencyCall=(Button)findViewById(R.id.emergencyCall);
  mEmergencyCall.setOnClickListener(this);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCall);
}",0.9766606822262118
182281,"/** 
 * Stay on me, but recreate me (so I can use a different layout).
 */
void recreateMe();","/** 
 * Stay on me, but recreate me (so I can use a different layout).
 */
void recreateMe(Configuration config);",0.9029126213592232
182282,"/** 
 * Remove the given observer from being registered from any of the kinds of callbacks.
 * @param observer The observer to remove (an instance of {@link ConfigurationChangeCallback},  {@link InfoCallback} or {@link SimStateCallback}
 */
public void removeCallback(Object observer){
  mConfigurationChangeCallbacks.remove(observer);
  mInfoCallbacks.remove(observer);
  mSimStateCallbacks.remove(observer);
}","/** 
 * Remove the given observer from being registered from any of the kinds of callbacks.
 * @param observer The observer to remove (an instance of {@link ConfigurationChangeCallback},  {@link InfoCallback} or {@link SimStateCallback}
 */
public void removeCallback(Object observer){
  mInfoCallbacks.remove(observer);
  mSimStateCallbacks.remove(observer);
}",0.9041450777202072
182283,"public KeyguardUpdateMonitor(Context context){
  mContext=context;
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CONFIGURATION_CHANGED:
        handleConfigurationChange();
      break;
case MSG_TIME_UPDATE:
    handleTimeUpdate();
  break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}
}
;
mKeyguardBypassEnabled=context.getResources().getBoolean(com.android.internal.R.bool.config_bypass_keyguard_if_slider_open);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (!mDeviceProvisioned) {
mContentObserver=new ContentObserver(mHandler){
@Override public void onChange(boolean selfChange){
super.onChange(selfChange);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (mDeviceProvisioned && mContentObserver != null) {
mContext.getContentResolver().unregisterContentObserver(mContentObserver);
mContentObserver=null;
}
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mDeviceProvisioned);
}
}
;
mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEVICE_PROVISIONED),false,mContentObserver);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
}
mInPortrait=queryInPortrait();
mKeyboardOpen=queryKeyboardOpen();
mSimState=IccCard.State.READY;
mDevicePluggedIn=true;
mBatteryLevel=100;
mTelephonyPlmn=getDefaultPlmn();
final IntentFilter filter=new IntentFilter();
filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
filter.addAction(Intent.ACTION_TIME_TICK);
filter.addAction(Intent.ACTION_TIME_CHANGED);
filter.addAction(Intent.ACTION_BATTERY_CHANGED);
filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
filter.addAction(SPN_STRINGS_UPDATED_ACTION);
filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
context.registerReceiver(new BroadcastReceiver(){
public void onReceive(Context context,Intent intent){
final String action=intent.getAction();
if (DEBUG) Log.d(TAG,""String_Node_Str"" + action);
if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_CONFIGURATION_CHANGED));
}
 else if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
}
 else if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
mTelephonyPlmn=getTelephonyPlmnFrom(intent);
mTelephonySpn=getTelephonySpnFrom(intent);
mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
}
 else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
mHandler.sendMessage(msg);
}
 else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
}
 else if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
}
 else if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
}
}
}
,filter);
}","public KeyguardUpdateMonitor(Context context){
  mContext=context;
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_TIME_UPDATE:
        handleTimeUpdate();
      break;
case MSG_BATTERY_UPDATE:
    handleBatteryUpdate(msg.arg1,msg.arg2);
  break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}
}
;
mKeyguardBypassEnabled=context.getResources().getBoolean(com.android.internal.R.bool.config_bypass_keyguard_if_slider_open);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (!mDeviceProvisioned) {
mContentObserver=new ContentObserver(mHandler){
@Override public void onChange(boolean selfChange){
super.onChange(selfChange);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (mDeviceProvisioned && mContentObserver != null) {
mContext.getContentResolver().unregisterContentObserver(mContentObserver);
mContentObserver=null;
}
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mDeviceProvisioned);
}
}
;
mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEVICE_PROVISIONED),false,mContentObserver);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
}
mSimState=IccCard.State.READY;
mDevicePluggedIn=true;
mBatteryLevel=100;
mTelephonyPlmn=getDefaultPlmn();
final IntentFilter filter=new IntentFilter();
filter.addAction(Intent.ACTION_TIME_TICK);
filter.addAction(Intent.ACTION_TIME_CHANGED);
filter.addAction(Intent.ACTION_BATTERY_CHANGED);
filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
filter.addAction(SPN_STRINGS_UPDATED_ACTION);
filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
context.registerReceiver(new BroadcastReceiver(){
public void onReceive(Context context,Intent intent){
final String action=intent.getAction();
if (DEBUG) Log.d(TAG,""String_Node_Str"" + action);
if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
}
 else if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
mTelephonyPlmn=getTelephonyPlmnFrom(intent);
mTelephonySpn=getTelephonySpnFrom(intent);
mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
}
 else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
mHandler.sendMessage(msg);
}
 else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
}
 else if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
}
 else if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
}
}
}
,filter);
}",0.953909891248058
182284,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_CONFIGURATION_CHANGED:
    handleConfigurationChange();
  break;
case MSG_TIME_UPDATE:
handleTimeUpdate();
break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_TIME_UPDATE:
    handleTimeUpdate();
  break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}",0.9233716475095786
182285,"public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + action);
  if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CONFIGURATION_CHANGED));
  }
 else   if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
  }
 else   if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
    mTelephonyPlmn=getTelephonyPlmnFrom(intent);
    mTelephonySpn=getTelephonySpnFrom(intent);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
  }
 else   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
    final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
    int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
    final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
    mHandler.sendMessage(msg);
  }
 else   if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
  }
 else   if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
  }
 else   if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
    String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
  }
}","public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + action);
  if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
  }
 else   if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
    mTelephonyPlmn=getTelephonyPlmnFrom(intent);
    mTelephonySpn=getTelephonySpnFrom(intent);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
  }
 else   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
    final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
    int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
    final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
    mHandler.sendMessage(msg);
  }
 else   if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
  }
 else   if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
  }
 else   if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
    String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
  }
}",0.9545032497678736
182286,"View createLockScreen(){
  return new LockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
}","View createLockScreen(){
  return new LockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
}",0.9402390438247012
182287,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mConfiguration=context.getResources().getConfiguration();
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(    Configuration config){
      mConfiguration=config;
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.9861908835390444
182288,"View createUnlockScreenFor(UnlockMode unlockMode){
  mIsPortrait=getResources().getBoolean(R.bool.lockscreen_isPortrait);
  View unlockView=null;
  if (unlockMode == UnlockMode.Pattern) {
    PatternUnlockScreen view=new PatternUnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + unlockMode + ""String_Node_Str""+ mEnableFallback);
    view.setEnableFallback(mEnableFallback);
    unlockView=view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    unlockView=new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback,mLockPatternUtils);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      unlockView=new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      unlockView=createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else   if (unlockMode == UnlockMode.Password) {
    unlockView=new PasswordUnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
  mCurrentUnlockMode=unlockMode;
  return unlockView;
}","View createUnlockScreenFor(UnlockMode unlockMode){
  View unlockView=null;
  if (unlockMode == UnlockMode.Pattern) {
    PatternUnlockScreen view=new PatternUnlockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + unlockMode + ""String_Node_Str""+ mEnableFallback);
    view.setEnableFallback(mEnableFallback);
    unlockView=view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    unlockView=new SimUnlockScreen(mContext,mConfiguration,mUpdateMonitor,mKeyguardScreenCallback,mLockPatternUtils);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      unlockView=new AccountUnlockScreen(mContext,mConfiguration,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      unlockView=createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else   if (unlockMode == UnlockMode.Password) {
    unlockView=new PasswordUnlockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
  mCurrentUnlockMode=unlockMode;
  return unlockView;
}",0.9490073958738808
182289,"@Override protected void dispatchDraw(Canvas canvas){
  final int orientation=getResources().getConfiguration().orientation;
  if (mIsPortrait && Configuration.ORIENTATION_PORTRAIT != orientation || getResources().getBoolean(R.bool.lockscreen_isPortrait) != mIsPortrait) {
    postInvalidate();
    ViewGroup view=(ViewGroup)(mMode == Mode.LockScreen ? mLockScreen : mUnlockScreen);
    if (view != null && view.getChildAt(0) != null) {
      Drawable background=view.getChildAt(0).getBackground();
      if (background != null) {
        background.draw(canvas);
      }
    }
    return;
  }
  super.dispatchDraw(canvas);
}","@Override protected void dispatchDraw(Canvas canvas){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
  super.dispatchDraw(canvas);
}",0.2922490470139771
182290,"public void recreateMe(){
  recreateScreens();
}","public void recreateMe(Configuration config){
  mConfiguration=config;
  recreateScreens();
}",0.6808510638297872
182291,"final void updateLocked(){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
      }
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    updateConfigurationLocked();
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","final void updateLocked(){
  long ident=Binder.clearCallingIdentity();
  try {
    String action=null;
    String oldAction=null;
    if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_CAR) {
      adjustStatusBarCarModeLocked();
      oldAction=UiModeManager.ACTION_EXIT_CAR_MODE;
    }
 else     if (mLastBroadcastState == Intent.EXTRA_DOCK_STATE_DESK) {
      oldAction=UiModeManager.ACTION_EXIT_DESK_MODE;
    }
    if (mCarModeEnabled) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_CAR) {
        adjustStatusBarCarModeLocked();
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_CAR;
        action=UiModeManager.ACTION_ENTER_CAR_MODE;
      }
    }
 else     if (mDockState == Intent.EXTRA_DOCK_STATE_DESK) {
      if (mLastBroadcastState != Intent.EXTRA_DOCK_STATE_DESK) {
        if (oldAction != null) {
          mContext.sendBroadcast(new Intent(oldAction));
        }
        mLastBroadcastState=Intent.EXTRA_DOCK_STATE_DESK;
        action=UiModeManager.ACTION_ENTER_DESK_MODE;
      }
    }
 else {
      mLastBroadcastState=Intent.EXTRA_DOCK_STATE_UNDOCKED;
      action=oldAction;
    }
    if (action != null) {
      mContext.sendOrderedBroadcast(new Intent(action),null,mResultReceiver,null,Activity.RESULT_OK,null,null);
      mHoldingConfiguration=true;
    }
    updateConfigurationLocked();
    boolean keepScreenOn=mCharging && ((mCarModeEnabled && mCarModeKeepsScreenOn) || (mCurUiMode == Configuration.UI_MODE_TYPE_DESK && mDeskModeKeepsScreenOn));
    if (keepScreenOn != mWakeLock.isHeld()) {
      if (keepScreenOn) {
        mWakeLock.acquire();
      }
 else {
        mWakeLock.release();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9594594594594594
182292,"/** 
 * See if the key event means we should leave touch mode (and leave touch mode if so).
 * @param event The key event.
 * @return Whether this key event should be consumed (meaning the act ofleaving touch mode alone is considered the event).
 */
private boolean checkForLeavingTouchModeAndConsume(KeyEvent event){
  if (event.getAction() != KeyEvent.ACTION_DOWN) {
    return false;
  }
  if ((event.getFlags() & KeyEvent.FLAG_KEEP_TOUCH_MODE) != 0) {
    return false;
  }
  if (!mAttachInfo.mInTouchMode) {
    return false;
  }
  if (isKeyboardKey(event) && mView != null && mView.hasFocus()) {
    mFocusedView=mView.findFocus();
    if ((mFocusedView instanceof ViewGroup) && ((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) {
      return false;
    }
    if (ensureTouchMode(false)) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    return false;
  }
  if (isDirectional(event.getKeyCode())) {
    return ensureTouchMode(false);
  }
  return false;
}","/** 
 * See if the key event means we should leave touch mode (and leave touch mode if so).
 * @param event The key event.
 * @return Whether this key event should be consumed (meaning the act ofleaving touch mode alone is considered the event).
 */
private boolean checkForLeavingTouchModeAndConsume(KeyEvent event){
  final int action=event.getAction();
  if (action != KeyEvent.ACTION_DOWN && action != KeyEvent.ACTION_MULTIPLE) {
    return false;
  }
  if ((event.getFlags() & KeyEvent.FLAG_KEEP_TOUCH_MODE) != 0) {
    return false;
  }
  if (!mAttachInfo.mInTouchMode) {
    return false;
  }
  if (isKeyboardKey(event) && mView != null && mView.hasFocus()) {
    mFocusedView=mView.findFocus();
    if ((mFocusedView instanceof ViewGroup) && ((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS) {
      return false;
    }
    if (ensureTouchMode(false)) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    }
    return false;
  }
  if (isDirectional(event.getKeyCode())) {
    return ensureTouchMode(false);
  }
  return false;
}",0.9660938225731538
182293,"public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
        if (mScrollY != 0) {
          mScrollY=0;
          invalidate();
        }
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}","public void onTouchModeChanged(boolean isInTouchMode){
  if (isInTouchMode) {
    hideSelector();
    if (getHeight() > 0 && getChildCount() > 0) {
      layoutChildren();
    }
  }
 else {
    int touchMode=mTouchMode;
    if (touchMode == TOUCH_MODE_OVERSCROLL || touchMode == TOUCH_MODE_OVERFLING) {
      if (mFlingRunnable != null) {
        mFlingRunnable.endFling();
      }
      if (mScrollY != 0) {
        mScrollY=0;
        invalidate();
      }
    }
  }
  mLastTouchMode=isInTouchMode ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
}",0.9814471243042672
182294,"/** 
 * @param contentResolver Used to look up and save settings.
 */
public LockPatternUtils(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mDevicePolicyManager=getDevicePolicyManager();
  if (sLockPatternFilename == null) {
    sLockPatternFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PATTERN_FILE;
    sLockPasswordFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PASSWORD_FILE;
  }
}","/** 
 * @param contentResolver Used to look up and save settings.
 */
public LockPatternUtils(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  if (sLockPatternFilename == null) {
    sLockPatternFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PATTERN_FILE;
    sLockPasswordFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PASSWORD_FILE;
  }
}",0.947027027027027
182295,"public void testScreenRequestsRecreation(){
  mLPKV.wakeWhenReadyTq(0);
  mLPKV.onScreenTurnedOn();
  assertEquals(1,mLPKV.getInjectedLockScreens().size());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().size());
  MockKeyguardScreen lockScreen=mLPKV.getInjectedLockScreens().get(0);
  assertEquals(0,lockScreen.getOnPauseCount());
  assertEquals(1,lockScreen.getOnResumeCount());
  mLPKV.mKeyguardScreenCallback.recreateMe();
  assertEquals(2,mLPKV.getInjectedLockScreens().size());
  assertEquals(2,mLPKV.getInjectedUnlockScreens().size());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getOnPauseCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(0).getOnPauseCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(1).getOnResumeCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(1).getOnResumeCount());
}","public void testScreenRequestsRecreation(){
  mLPKV.wakeWhenReadyTq(0);
  mLPKV.onScreenTurnedOn();
  assertEquals(1,mLPKV.getInjectedLockScreens().size());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().size());
  MockKeyguardScreen lockScreen=mLPKV.getInjectedLockScreens().get(0);
  assertEquals(0,lockScreen.getOnPauseCount());
  assertEquals(1,lockScreen.getOnResumeCount());
  mLPKV.mKeyguardScreenCallback.recreateMe(new Configuration());
  assertEquals(2,mLPKV.getInjectedLockScreens().size());
  assertEquals(2,mLPKV.getInjectedUnlockScreens().size());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getOnPauseCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(0).getOnPauseCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(1).getOnResumeCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(1).getOnResumeCount());
}",0.9906357811729916
182296,"/** 
 * Send ar.userObj if its a message, which is should be back to originator.
 * @param dp is the DisconnectParams.
 */
private void notifyDisconnectCompleted(DisconnectParams dp){
  if (DBG)   log(""String_Node_Str"");
  Message msg=dp.onCompletedMsg;
  log(String.format(""String_Node_Str"",msg.what,((msg.obj instanceof String) ? (String)msg.obj : ""String_Node_Str"")));
  AsyncResult.forMessage(msg);
  msg.sendToTarget();
  clearSettings();
}","/** 
 * Send ar.userObj if its a message, which is should be back to originator.
 * @param dp is the DisconnectParams.
 */
private void notifyDisconnectCompleted(DisconnectParams dp){
  if (DBG)   log(""String_Node_Str"");
  if (dp.onCompletedMsg != null) {
    Message msg=dp.onCompletedMsg;
    log(String.format(""String_Node_Str"",msg.what,((msg.obj instanceof String) ? (String)msg.obj : ""String_Node_Str"")));
    AsyncResult.forMessage(msg);
    msg.sendToTarget();
  }
  if (dp.lockObj != null) {
synchronized (dp.lockObj) {
      dp.lockObj.notify();
    }
  }
  clearSettings();
}",0.8116504854368932
182297,"public DisconnectParams(Message onCompletedMsg){
  this.onCompletedMsg=onCompletedMsg;
}","public DisconnectParams(ResetSynchronouslyLock lockObj){
  this.lockObj=lockObj;
}",0.5411764705882353
182298,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : dataConnectionList) {
    if (conn != null) {
      if (tearDown) {
        if (DBG)         log(""String_Node_Str"");
        conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
      }
 else {
        if (DBG)         log(""String_Node_Str"");
        conn.reset(obtainMessage(EVENT_RESET_DONE,reason));
      }
      notificationDeferred=true;
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : dataConnectionList) {
    if (conn != null) {
      if (tearDown) {
        if (DBG)         log(""String_Node_Str"");
        conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
        notificationDeferred=true;
      }
 else {
        if (DBG)         log(""String_Node_Str"");
        conn.resetSynchronously();
        notificationDeferred=false;
      }
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}",0.9395667046750285
182299,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying GsmDataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : pdpList) {
    if (tearDown) {
      if (DBG)       log(""String_Node_Str"");
      conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
    }
 else {
      if (DBG)       log(""String_Node_Str"");
      conn.reset(obtainMessage(EVENT_RESET_DONE,reason));
    }
    notificationDeferred=true;
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying GsmDataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : pdpList) {
    if (tearDown) {
      if (DBG)       log(""String_Node_Str"");
      conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
      notificationDeferred=true;
    }
 else {
      if (DBG)       log(""String_Node_Str"");
      conn.resetSynchronously();
      notificationDeferred=false;
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}",0.939116593712694
182300,"/** 
 * Send ar.userObj if its a message, which is should be back to originator.
 * @param dp is the DisconnectParams.
 */
private void notifyDisconnectCompleted(DisconnectParams dp){
  if (DBG)   log(""String_Node_Str"");
  Message msg=dp.onCompletedMsg;
  log(String.format(""String_Node_Str"",msg.what,((msg.obj instanceof String) ? (String)msg.obj : ""String_Node_Str"")));
  AsyncResult.forMessage(msg);
  msg.sendToTarget();
  clearSettings();
}","/** 
 * Send ar.userObj if its a message, which is should be back to originator.
 * @param dp is the DisconnectParams.
 */
private void notifyDisconnectCompleted(DisconnectParams dp){
  if (DBG)   log(""String_Node_Str"");
  if (dp.onCompletedMsg != null) {
    Message msg=dp.onCompletedMsg;
    log(String.format(""String_Node_Str"",msg.what,((msg.obj instanceof String) ? (String)msg.obj : ""String_Node_Str"")));
    AsyncResult.forMessage(msg);
    msg.sendToTarget();
  }
  if (dp.lockObj != null) {
synchronized (dp.lockObj) {
      dp.lockObj.notify();
    }
  }
  clearSettings();
}",0.8116504854368932
182301,"public DisconnectParams(Message onCompletedMsg){
  this.onCompletedMsg=onCompletedMsg;
}","public DisconnectParams(ResetSynchronouslyLock lockObj){
  this.lockObj=lockObj;
}",0.5411764705882353
182302,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : dataConnectionList) {
    if (conn != null) {
      if (tearDown) {
        if (DBG)         log(""String_Node_Str"");
        conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
      }
 else {
        if (DBG)         log(""String_Node_Str"");
        conn.reset(obtainMessage(EVENT_RESET_DONE,reason));
      }
      notificationDeferred=true;
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : dataConnectionList) {
    if (conn != null) {
      if (tearDown) {
        if (DBG)         log(""String_Node_Str"");
        conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
        notificationDeferred=true;
      }
 else {
        if (DBG)         log(""String_Node_Str"");
        conn.resetSynchronously();
        notificationDeferred=false;
      }
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}",0.9395667046750285
182303,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying GsmDataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : pdpList) {
    if (tearDown) {
      if (DBG)       log(""String_Node_Str"");
      conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
    }
 else {
      if (DBG)       log(""String_Node_Str"");
      conn.reset(obtainMessage(EVENT_RESET_DONE,reason));
    }
    notificationDeferred=true;
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying GsmDataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  boolean notificationDeferred=false;
  for (  DataConnection conn : pdpList) {
    if (tearDown) {
      if (DBG)       log(""String_Node_Str"");
      conn.disconnect(obtainMessage(EVENT_DISCONNECT_DONE,reason));
      notificationDeferred=true;
    }
 else {
      if (DBG)       log(""String_Node_Str"");
      conn.resetSynchronously();
      notificationDeferred=false;
    }
  }
  stopNetStatPoll();
  if (!notificationDeferred) {
    if (DBG)     log(""String_Node_Str"");
    gotoIdleAndNotifyDataConnection(reason);
  }
}",0.939116593712694
182304,"/** 
 * AccountUnlockScreen constructor.
 */
public AccountUnlockScreen(Context context,KeyguardScreenCallback callback,LockPatternUtils lockPatternUtils){
  super(context);
  mCallback=callback;
  mLockPatternUtils=lockPatternUtils;
  LayoutInflater.from(context).inflate(R.layout.keyguard_screen_glogin_unlock,this,true);
  mTopHeader=(TextView)findViewById(R.id.topHeader);
  mTopHeader.setText(mLockPatternUtils.isPermanentlyLocked() ? R.string.lockscreen_glogin_too_many_attempts : R.string.lockscreen_glogin_forgot_pattern);
  mInstructions=(TextView)findViewById(R.id.instructions);
  mLogin=(EditText)findViewById(R.id.login);
  mLogin.setFilters(new InputFilter[]{new LoginFilter.UsernameFilterGeneric()});
  mLogin.addTextChangedListener(this);
  mPassword=(EditText)findViewById(R.id.password);
  mPassword.addTextChangedListener(this);
  mOk=(Button)findViewById(R.id.ok);
  mOk.setOnClickListener(this);
  mEmergencyCall=(Button)findViewById(R.id.emergencyCall);
  mEmergencyCall.setOnClickListener(this);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCall);
}","/** 
 * AccountUnlockScreen constructor.
 * @param configuration
 */
public AccountUnlockScreen(Context context,Configuration configuration,KeyguardScreenCallback callback,LockPatternUtils lockPatternUtils){
  super(context);
  mCallback=callback;
  mLockPatternUtils=lockPatternUtils;
  LayoutInflater.from(context).inflate(R.layout.keyguard_screen_glogin_unlock,this,true);
  mTopHeader=(TextView)findViewById(R.id.topHeader);
  mTopHeader.setText(mLockPatternUtils.isPermanentlyLocked() ? R.string.lockscreen_glogin_too_many_attempts : R.string.lockscreen_glogin_forgot_pattern);
  mInstructions=(TextView)findViewById(R.id.instructions);
  mLogin=(EditText)findViewById(R.id.login);
  mLogin.setFilters(new InputFilter[]{new LoginFilter.UsernameFilterGeneric()});
  mLogin.addTextChangedListener(this);
  mPassword=(EditText)findViewById(R.id.password);
  mPassword.addTextChangedListener(this);
  mOk=(Button)findViewById(R.id.ok);
  mOk.setOnClickListener(this);
  mEmergencyCall=(Button)findViewById(R.id.emergencyCall);
  mEmergencyCall.setOnClickListener(this);
  mLockPatternUtils.updateEmergencyCallButtonState(mEmergencyCall);
}",0.9766606822262118
182305,"/** 
 * Stay on me, but recreate me (so I can use a different layout).
 */
void recreateMe();","/** 
 * Stay on me, but recreate me (so I can use a different layout).
 */
void recreateMe(Configuration config);",0.9029126213592232
182306,"/** 
 * Remove the given observer from being registered from any of the kinds of callbacks.
 * @param observer The observer to remove (an instance of {@link ConfigurationChangeCallback},  {@link InfoCallback} or {@link SimStateCallback}
 */
public void removeCallback(Object observer){
  mConfigurationChangeCallbacks.remove(observer);
  mInfoCallbacks.remove(observer);
  mSimStateCallbacks.remove(observer);
}","/** 
 * Remove the given observer from being registered from any of the kinds of callbacks.
 * @param observer The observer to remove (an instance of {@link ConfigurationChangeCallback},  {@link InfoCallback} or {@link SimStateCallback}
 */
public void removeCallback(Object observer){
  mInfoCallbacks.remove(observer);
  mSimStateCallbacks.remove(observer);
}",0.9041450777202072
182307,"public KeyguardUpdateMonitor(Context context){
  mContext=context;
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CONFIGURATION_CHANGED:
        handleConfigurationChange();
      break;
case MSG_TIME_UPDATE:
    handleTimeUpdate();
  break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}
}
;
mKeyguardBypassEnabled=context.getResources().getBoolean(com.android.internal.R.bool.config_bypass_keyguard_if_slider_open);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (!mDeviceProvisioned) {
mContentObserver=new ContentObserver(mHandler){
@Override public void onChange(boolean selfChange){
super.onChange(selfChange);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (mDeviceProvisioned && mContentObserver != null) {
mContext.getContentResolver().unregisterContentObserver(mContentObserver);
mContentObserver=null;
}
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mDeviceProvisioned);
}
}
;
mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEVICE_PROVISIONED),false,mContentObserver);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
}
mInPortrait=queryInPortrait();
mKeyboardOpen=queryKeyboardOpen();
mSimState=IccCard.State.READY;
mDevicePluggedIn=true;
mBatteryLevel=100;
mTelephonyPlmn=getDefaultPlmn();
final IntentFilter filter=new IntentFilter();
filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
filter.addAction(Intent.ACTION_TIME_TICK);
filter.addAction(Intent.ACTION_TIME_CHANGED);
filter.addAction(Intent.ACTION_BATTERY_CHANGED);
filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
filter.addAction(SPN_STRINGS_UPDATED_ACTION);
filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
context.registerReceiver(new BroadcastReceiver(){
public void onReceive(Context context,Intent intent){
final String action=intent.getAction();
if (DEBUG) Log.d(TAG,""String_Node_Str"" + action);
if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_CONFIGURATION_CHANGED));
}
 else if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
}
 else if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
mTelephonyPlmn=getTelephonyPlmnFrom(intent);
mTelephonySpn=getTelephonySpnFrom(intent);
mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
}
 else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
mHandler.sendMessage(msg);
}
 else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
}
 else if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
}
 else if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
}
}
}
,filter);
}","public KeyguardUpdateMonitor(Context context){
  mContext=context;
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_TIME_UPDATE:
        handleTimeUpdate();
      break;
case MSG_BATTERY_UPDATE:
    handleBatteryUpdate(msg.arg1,msg.arg2);
  break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}
}
;
mKeyguardBypassEnabled=context.getResources().getBoolean(com.android.internal.R.bool.config_bypass_keyguard_if_slider_open);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (!mDeviceProvisioned) {
mContentObserver=new ContentObserver(mHandler){
@Override public void onChange(boolean selfChange){
super.onChange(selfChange);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
if (mDeviceProvisioned && mContentObserver != null) {
mContext.getContentResolver().unregisterContentObserver(mContentObserver);
mContentObserver=null;
}
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mDeviceProvisioned);
}
}
;
mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEVICE_PROVISIONED),false,mContentObserver);
mDeviceProvisioned=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) != 0;
}
mSimState=IccCard.State.READY;
mDevicePluggedIn=true;
mBatteryLevel=100;
mTelephonyPlmn=getDefaultPlmn();
final IntentFilter filter=new IntentFilter();
filter.addAction(Intent.ACTION_TIME_TICK);
filter.addAction(Intent.ACTION_TIME_CHANGED);
filter.addAction(Intent.ACTION_BATTERY_CHANGED);
filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
filter.addAction(SPN_STRINGS_UPDATED_ACTION);
filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
context.registerReceiver(new BroadcastReceiver(){
public void onReceive(Context context,Intent intent){
final String action=intent.getAction();
if (DEBUG) Log.d(TAG,""String_Node_Str"" + action);
if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
}
 else if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
mTelephonyPlmn=getTelephonyPlmnFrom(intent);
mTelephonySpn=getTelephonySpnFrom(intent);
mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
}
 else if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
mHandler.sendMessage(msg);
}
 else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
}
 else if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
}
 else if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
}
}
}
,filter);
}",0.953909891248058
182308,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_CONFIGURATION_CHANGED:
    handleConfigurationChange();
  break;
case MSG_TIME_UPDATE:
handleTimeUpdate();
break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_TIME_UPDATE:
    handleTimeUpdate();
  break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1,msg.arg2);
break;
case MSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs)msg.obj);
break;
case MSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
case MSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
}
}",0.9233716475095786
182309,"public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + action);
  if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CONFIGURATION_CHANGED));
  }
 else   if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
  }
 else   if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
    mTelephonyPlmn=getTelephonyPlmnFrom(intent);
    mTelephonySpn=getTelephonySpnFrom(intent);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
  }
 else   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
    final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
    int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
    final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
    mHandler.sendMessage(msg);
  }
 else   if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
  }
 else   if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
  }
 else   if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
    String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
  }
}","public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + action);
  if (Intent.ACTION_TIME_TICK.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_TIME_UPDATE));
  }
 else   if (SPN_STRINGS_UPDATED_ACTION.equals(action)) {
    mTelephonyPlmn=getTelephonyPlmnFrom(intent);
    mTelephonySpn=getTelephonySpnFrom(intent);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_CARRIER_INFO_UPDATE));
  }
 else   if (Intent.ACTION_BATTERY_CHANGED.equals(action)) {
    final int pluggedInStatus=intent.getIntExtra(""String_Node_Str"",BATTERY_STATUS_UNKNOWN);
    int batteryLevel=intent.getIntExtra(""String_Node_Str"",0);
    final Message msg=mHandler.obtainMessage(MSG_BATTERY_UPDATE,pluggedInStatus,batteryLevel);
    mHandler.sendMessage(msg);
  }
 else   if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SIM_STATE_CHANGE,new SimArgs(intent)));
  }
 else   if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
    mHandler.sendMessage(mHandler.obtainMessage(MSG_RINGER_MODE_CHANGED,intent.getIntExtra(AudioManager.EXTRA_RINGER_MODE,-1),0));
  }
 else   if (TelephonyManager.ACTION_PHONE_STATE_CHANGED.equals(action)) {
    String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_PHONE_STATE_CHANGED,state));
  }
}",0.9545032497678736
182310,"View createLockScreen(){
  return new LockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
}","View createLockScreen(){
  return new LockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
}",0.9402390438247012
182311,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mConfiguration=context.getResources().getConfiguration();
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(    Configuration config){
      mConfiguration=config;
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.9861908835390444
182312,"View createUnlockScreenFor(UnlockMode unlockMode){
  mIsPortrait=getResources().getBoolean(R.bool.lockscreen_isPortrait);
  View unlockView=null;
  if (unlockMode == UnlockMode.Pattern) {
    PatternUnlockScreen view=new PatternUnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + unlockMode + ""String_Node_Str""+ mEnableFallback);
    view.setEnableFallback(mEnableFallback);
    unlockView=view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    unlockView=new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback,mLockPatternUtils);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      unlockView=new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      unlockView=createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else   if (unlockMode == UnlockMode.Password) {
    unlockView=new PasswordUnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
  mCurrentUnlockMode=unlockMode;
  return unlockView;
}","View createUnlockScreenFor(UnlockMode unlockMode){
  View unlockView=null;
  if (unlockMode == UnlockMode.Pattern) {
    PatternUnlockScreen view=new PatternUnlockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + unlockMode + ""String_Node_Str""+ mEnableFallback);
    view.setEnableFallback(mEnableFallback);
    unlockView=view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    unlockView=new SimUnlockScreen(mContext,mConfiguration,mUpdateMonitor,mKeyguardScreenCallback,mLockPatternUtils);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      unlockView=new AccountUnlockScreen(mContext,mConfiguration,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      unlockView=createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else   if (unlockMode == UnlockMode.Password) {
    unlockView=new PasswordUnlockScreen(mContext,mConfiguration,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
  mCurrentUnlockMode=unlockMode;
  return unlockView;
}",0.9490073958738808
182313,"@Override protected void dispatchDraw(Canvas canvas){
  final int orientation=getResources().getConfiguration().orientation;
  if (mIsPortrait && Configuration.ORIENTATION_PORTRAIT != orientation || getResources().getBoolean(R.bool.lockscreen_isPortrait) != mIsPortrait) {
    postInvalidate();
    ViewGroup view=(ViewGroup)(mMode == Mode.LockScreen ? mLockScreen : mUnlockScreen);
    if (view != null && view.getChildAt(0) != null) {
      Drawable background=view.getChildAt(0).getBackground();
      if (background != null) {
        background.draw(canvas);
      }
    }
    return;
  }
  super.dispatchDraw(canvas);
}","@Override protected void dispatchDraw(Canvas canvas){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
  super.dispatchDraw(canvas);
}",0.2922490470139771
182314,"public void recreateMe(){
  recreateScreens();
}","public void recreateMe(Configuration config){
  mConfiguration=config;
  recreateScreens();
}",0.6808510638297872
182315,"/** 
 * @param contentResolver Used to look up and save settings.
 */
public LockPatternUtils(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mDevicePolicyManager=getDevicePolicyManager();
  if (sLockPatternFilename == null) {
    sLockPatternFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PATTERN_FILE;
    sLockPasswordFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PASSWORD_FILE;
  }
}","/** 
 * @param contentResolver Used to look up and save settings.
 */
public LockPatternUtils(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  if (sLockPatternFilename == null) {
    sLockPatternFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PATTERN_FILE;
    sLockPasswordFilename=android.os.Environment.getDataDirectory().getAbsolutePath() + LOCK_PASSWORD_FILE;
  }
}",0.947027027027027
182316,"public void testScreenRequestsRecreation(){
  mLPKV.wakeWhenReadyTq(0);
  mLPKV.onScreenTurnedOn();
  assertEquals(1,mLPKV.getInjectedLockScreens().size());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().size());
  MockKeyguardScreen lockScreen=mLPKV.getInjectedLockScreens().get(0);
  assertEquals(0,lockScreen.getOnPauseCount());
  assertEquals(1,lockScreen.getOnResumeCount());
  mLPKV.mKeyguardScreenCallback.recreateMe();
  assertEquals(2,mLPKV.getInjectedLockScreens().size());
  assertEquals(2,mLPKV.getInjectedUnlockScreens().size());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getOnPauseCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(0).getOnPauseCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(1).getOnResumeCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(1).getOnResumeCount());
}","public void testScreenRequestsRecreation(){
  mLPKV.wakeWhenReadyTq(0);
  mLPKV.onScreenTurnedOn();
  assertEquals(1,mLPKV.getInjectedLockScreens().size());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().size());
  MockKeyguardScreen lockScreen=mLPKV.getInjectedLockScreens().get(0);
  assertEquals(0,lockScreen.getOnPauseCount());
  assertEquals(1,lockScreen.getOnResumeCount());
  mLPKV.mKeyguardScreenCallback.recreateMe(new Configuration());
  assertEquals(2,mLPKV.getInjectedLockScreens().size());
  assertEquals(2,mLPKV.getInjectedUnlockScreens().size());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedUnlockScreens().get(0).getCleanupCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(0).getOnPauseCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(0).getOnPauseCount());
  assertEquals(1,mLPKV.getInjectedLockScreens().get(1).getOnResumeCount());
  assertEquals(0,mLPKV.getInjectedUnlockScreens().get(1).getOnResumeCount());
}",0.9906357811729916
182317,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
    int grantedMode=data.readInt();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    boolean onlyIfNeeded=data.readInt() != 0;
    boolean debug=data.readInt() != 0;
    WaitResult result=startActivityAndWait(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
    reply.writeNoException();
    result.writeToParcel(reply,0);
    return true;
  }
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
  Intent fillInIntent=null;
  if (data.readInt() != 0) {
    fillInIntent=Intent.CREATOR.createFromParcel(data);
  }
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int flagsMask=data.readInt();
  int flagsValues=data.readInt();
  int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean result=startNextMatchingActivity(callingActivity,intent);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=finishActivity(token,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
if (token != null) {
activityIdle(token,config);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
killBackgroundProcesses(packageName);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
forceStopPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeInt(isUserAMonkey() ? 1 : 0);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
    int grantedMode=data.readInt();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    boolean onlyIfNeeded=data.readInt() != 0;
    boolean debug=data.readInt() != 0;
    WaitResult result=startActivityAndWait(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
    reply.writeNoException();
    result.writeToParcel(reply,0);
    return true;
  }
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
  Intent fillInIntent=null;
  if (data.readInt() != 0) {
    fillInIntent=Intent.CREATOR.createFromParcel(data);
  }
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int flagsMask=data.readInt();
  int flagsValues=data.readInt();
  int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean result=startNextMatchingActivity(callingActivity,intent);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=finishActivity(token,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
if (token != null) {
activityIdle(token,config);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
killBackgroundProcesses(packageName);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
forceStopPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeInt(isUserAMonkey() ? 1 : 0);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9960764460194912
182318,"final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    if (r.window == null && !a.mFinished && !a.mStartedActivity) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (a.mStartedActivity) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && !a.mStartedActivity && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.newConfig);
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    boolean willBeVisible=!a.mStartedActivity;
    if (!willBeVisible) {
      try {
        willBeVisible=ActivityManagerNative.getDefault().willActivityBeVisible(a.getActivityToken());
      }
 catch (      RemoteException e) {
      }
    }
    if (r.window == null && !a.mFinished && willBeVisible) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (!willBeVisible) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ r.newConfig);
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.936779471922648
182319,"public final ActivityRecord performResumeActivity(IBinder token,boolean clearHide){
  ActivityRecord r=mActivities.get(token);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.activity.mFinished);
  if (r != null && !r.activity.mFinished) {
    if (clearHide) {
      r.hideForNow=false;
      r.activity.mStartedActivity=false;
    }
    try {
      if (r.pendingIntents != null) {
        deliverNewIntents(r,r.pendingIntents);
        r.pendingIntents=null;
      }
      if (r.pendingResults != null) {
        deliverResults(r,r.pendingResults);
        r.pendingResults=null;
      }
      r.activity.performResume();
      EventLog.writeEvent(LOG_ON_RESUME_CALLED,r.activity.getComponentName().getClassName());
      r.paused=false;
      r.stopped=false;
      if (r.activity.mStartedActivity) {
        r.hideForNow=true;
      }
      r.state=null;
    }
 catch (    Exception e) {
      if (!mInstrumentation.onException(r.activity,e)) {
        throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
      }
    }
  }
  return r;
}","public final ActivityRecord performResumeActivity(IBinder token,boolean clearHide){
  ActivityRecord r=mActivities.get(token);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.activity.mFinished);
  if (r != null && !r.activity.mFinished) {
    if (clearHide) {
      r.hideForNow=false;
      r.activity.mStartedActivity=false;
    }
    try {
      if (r.pendingIntents != null) {
        deliverNewIntents(r,r.pendingIntents);
        r.pendingIntents=null;
      }
      if (r.pendingResults != null) {
        deliverResults(r,r.pendingResults);
        r.pendingResults=null;
      }
      r.activity.performResume();
      EventLog.writeEvent(LOG_ON_RESUME_CALLED,r.activity.getComponentName().getClassName());
      r.paused=false;
      r.stopped=false;
      r.state=null;
    }
 catch (    Exception e) {
      if (!mInstrumentation.onException(r.activity,e)) {
        throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
      }
    }
  }
  return r;
}",0.9654545454545456
182320,"public int compareTo(Configuration that){
  int n;
  float a=this.fontScale;
  float b=that.fontScale;
  if (a < b)   return -1;
  if (a > b)   return 1;
  n=this.mcc - that.mcc;
  if (n != 0)   return n;
  n=this.mnc - that.mnc;
  if (n != 0)   return n;
  n=this.locale.getLanguage().compareTo(that.locale.getLanguage());
  if (n != 0)   return n;
  n=this.locale.getCountry().compareTo(that.locale.getCountry());
  if (n != 0)   return n;
  n=this.locale.getVariant().compareTo(that.locale.getVariant());
  if (n != 0)   return n;
  n=this.touchscreen - that.touchscreen;
  if (n != 0)   return n;
  n=this.keyboard - that.keyboard;
  if (n != 0)   return n;
  n=this.keyboardHidden - that.keyboardHidden;
  if (n != 0)   return n;
  n=this.hardKeyboardHidden - that.hardKeyboardHidden;
  if (n != 0)   return n;
  n=this.navigation - that.navigation;
  if (n != 0)   return n;
  n=this.navigationHidden - that.navigationHidden;
  if (n != 0)   return n;
  n=this.orientation - that.orientation;
  if (n != 0)   return n;
  n=this.screenLayout - that.screenLayout;
  if (n != 0)   return n;
  n=this.uiMode - that.uiMode;
  return n;
}","public int compareTo(Configuration that){
  int n;
  float a=this.fontScale;
  float b=that.fontScale;
  if (a < b)   return -1;
  if (a > b)   return 1;
  n=this.mcc - that.mcc;
  if (n != 0)   return n;
  n=this.mnc - that.mnc;
  if (n != 0)   return n;
  if (this.locale == null) {
    if (that.locale != null)     return 1;
  }
 else   if (that.locale == null) {
    return -1;
  }
 else {
    n=this.locale.getLanguage().compareTo(that.locale.getLanguage());
    if (n != 0)     return n;
    n=this.locale.getCountry().compareTo(that.locale.getCountry());
    if (n != 0)     return n;
    n=this.locale.getVariant().compareTo(that.locale.getVariant());
    if (n != 0)     return n;
  }
  n=this.touchscreen - that.touchscreen;
  if (n != 0)   return n;
  n=this.keyboard - that.keyboard;
  if (n != 0)   return n;
  n=this.keyboardHidden - that.keyboardHidden;
  if (n != 0)   return n;
  n=this.hardKeyboardHidden - that.hardKeyboardHidden;
  if (n != 0)   return n;
  n=this.navigation - that.navigation;
  if (n != 0)   return n;
  n=this.navigationHidden - that.navigationHidden;
  if (n != 0)   return n;
  n=this.orientation - that.orientation;
  if (n != 0)   return n;
  n=this.screenLayout - that.screenLayout;
  if (n != 0)   return n;
  n=this.uiMode - that.uiMode;
  return n;
}",0.9105090311986864
182321,"public int hashCode(){
  return ((int)this.fontScale) + this.mcc + this.mnc+ this.locale.hashCode()+ this.touchscreen+ this.keyboard+ this.keyboardHidden+ this.hardKeyboardHidden+ this.navigation+ this.navigationHidden+ this.orientation+ this.screenLayout+ this.uiMode;
}","public int hashCode(){
  return ((int)this.fontScale) + this.mcc + this.mnc+ (this.locale != null ? this.locale.hashCode() : 0)+ this.touchscreen+ this.keyboard+ this.keyboardHidden+ this.hardKeyboardHidden+ this.navigation+ this.navigationHidden+ this.orientation+ this.screenLayout+ this.uiMode;
}",0.950877192982456
182322,"public boolean validateMemoryResult(int startPid,int startMemory,Writer output,int limit) throws Exception {
  Thread.sleep(10000);
  mEndPid=getMediaserverPid();
  int memDiff=mEndMemory - startMemory;
  if (memDiff < 0)   memDiff=0;
 else   output.write(""String_Node_Str"" + memDiff);
  output.write(""String_Node_Str"");
  if (startPid != mEndPid) {
    output.write(""String_Node_Str"");
    return false;
  }
  if (memDiff > limit)   return false;
  return true;
}","public boolean validateMemoryResult(int startPid,int startMemory,Writer output,int limit) throws Exception {
  Thread.sleep(10000);
  mEndPid=getMediaserverPid();
  int memDiff=mEndMemory - startMemory;
  if (memDiff < 0) {
    memDiff=0;
  }
  output.write(""String_Node_Str"" + memDiff);
  output.write(""String_Node_Str"");
  if (startPid != mEndPid) {
    output.write(""String_Node_Str"");
    return false;
  }
  if (memDiff > limit)   return false;
  return true;
}",0.9870967741935484
182323,"public boolean validateMemoryResult(int startPid,int startMemory,Writer output,int limit) throws Exception {
  Thread.sleep(10000);
  mEndPid=getMediaserverPid();
  int memDiff=mEndMemory - startMemory;
  if (memDiff < 0)   memDiff=0;
 else   output.write(""String_Node_Str"" + memDiff);
  output.write(""String_Node_Str"");
  if (startPid != mEndPid) {
    output.write(""String_Node_Str"");
    return false;
  }
  if (memDiff > limit)   return false;
  return true;
}","public boolean validateMemoryResult(int startPid,int startMemory,Writer output,int limit) throws Exception {
  Thread.sleep(10000);
  mEndPid=getMediaserverPid();
  int memDiff=mEndMemory - startMemory;
  if (memDiff < 0) {
    memDiff=0;
  }
  output.write(""String_Node_Str"" + memDiff);
  output.write(""String_Node_Str"");
  if (startPid != mEndPid) {
    output.write(""String_Node_Str"");
    return false;
  }
  if (memDiff > limit)   return false;
  return true;
}",0.9870967741935484
182324,"/** 
 * Reboot the device immediately, passing 'reason' (may be null) to the underlying __reboot system call.  Should not return.
 */
public void reboot(String reason){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT,null);
  if (mHandler == null || !ActivityManagerNative.isSystemReady()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final String finalReason=reason;
  Runnable runnable=new Runnable(){
    public void run(){
synchronized (this) {
        ShutdownThread.reboot(mContext,finalReason,false);
        notify();
      }
    }
  }
;
  mHandler.post(runnable);
synchronized (runnable) {
    try {
      runnable.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Reboot the device immediately, passing 'reason' (may be null) to the underlying __reboot system call.  Should not return.
 */
public void reboot(String reason){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT,null);
  if (mHandler == null || !ActivityManagerNative.isSystemReady()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final String finalReason=reason;
  Runnable runnable=new Runnable(){
    public void run(){
synchronized (this) {
        ShutdownThread.reboot(mContext,finalReason,false);
      }
    }
  }
;
  mHandler.post(runnable);
synchronized (runnable) {
    while (true) {
      try {
        runnable.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
}",0.7852044127190136
182325,"final void appNotRespondingLocked(ProcessRecord app,HistoryRecord activity,HistoryRecord parent,final String annotation){
  if (app.notResponding || app.crashing) {
    return;
  }
  EventLog.writeEvent(EventLogTags.AM_ANR,app.pid,app.processName,app.info.flags,annotation);
  ArrayList<Integer> pids=new ArrayList<Integer>(20);
  pids.add(app.pid);
  int parentPid=app.pid;
  if (parent != null && parent.app != null && parent.app.pid > 0)   parentPid=parent.app.pid;
  if (parentPid != app.pid)   pids.add(parentPid);
  if (MY_PID != app.pid && MY_PID != parentPid)   pids.add(MY_PID);
  for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
    ProcessRecord r=mLruProcesses.get(i);
    if (r != null && r.thread != null) {
      int pid=r.pid;
      if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID)       pids.add(pid);
    }
  }
  File tracesFile=dumpStackTraces(pids);
  StringBuilder info=mStringBuilder;
  info.setLength(0);
  info.append(""String_Node_Str"").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(""String_Node_Str"").append(activity.shortComponentName).append(""String_Node_Str"");
  }
  info.append(""String_Node_Str"");
  if (annotation != null) {
    info.append(""String_Node_Str"").append(annotation).append(""String_Node_Str"");
  }
  if (parent != null && parent != activity) {
    info.append(""String_Node_Str"").append(parent.shortComponentName).append(""String_Node_Str"");
  }
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState();
    }
    info.append(cpuInfo);
  }
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox(""String_Node_Str"",app,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
  if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
    Process.killProcess(app.pid);
    return;
  }
  makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? ""String_Node_Str"" + annotation : ""String_Node_Str"",info.toString());
  Message msg=Message.obtain();
  HashMap map=new HashMap();
  msg.what=SHOW_NOT_RESPONDING_MSG;
  msg.obj=map;
  map.put(""String_Node_Str"",app);
  if (activity != null) {
    map.put(""String_Node_Str"",activity);
  }
  mHandler.sendMessage(msg);
  return;
}","final void appNotRespondingLocked(ProcessRecord app,HistoryRecord activity,HistoryRecord parent,final String annotation){
  if (mShuttingDown || app.notResponding || app.crashing) {
    return;
  }
  EventLog.writeEvent(EventLogTags.AM_ANR,app.pid,app.processName,app.info.flags,annotation);
  ArrayList<Integer> pids=new ArrayList<Integer>(20);
  pids.add(app.pid);
  int parentPid=app.pid;
  if (parent != null && parent.app != null && parent.app.pid > 0)   parentPid=parent.app.pid;
  if (parentPid != app.pid)   pids.add(parentPid);
  if (MY_PID != app.pid && MY_PID != parentPid)   pids.add(MY_PID);
  for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
    ProcessRecord r=mLruProcesses.get(i);
    if (r != null && r.thread != null) {
      int pid=r.pid;
      if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID)       pids.add(pid);
    }
  }
  File tracesFile=dumpStackTraces(pids);
  StringBuilder info=mStringBuilder;
  info.setLength(0);
  info.append(""String_Node_Str"").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(""String_Node_Str"").append(activity.shortComponentName).append(""String_Node_Str"");
  }
  info.append(""String_Node_Str"");
  if (annotation != null) {
    info.append(""String_Node_Str"").append(annotation).append(""String_Node_Str"");
  }
  if (parent != null && parent != activity) {
    info.append(""String_Node_Str"").append(parent.shortComponentName).append(""String_Node_Str"");
  }
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState();
    }
    info.append(cpuInfo);
  }
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox(""String_Node_Str"",app,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
  if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
    Process.killProcess(app.pid);
    return;
  }
  makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? ""String_Node_Str"" + annotation : ""String_Node_Str"",info.toString());
  Message msg=Message.obtain();
  HashMap map=new HashMap();
  msg.what=SHOW_NOT_RESPONDING_MSG;
  msg.obj=map;
  map.put(""String_Node_Str"",app);
  if (activity != null) {
    map.put(""String_Node_Str"",activity);
  }
  mHandler.sendMessage(msg);
  return;
}",0.9970654237873297
182326,"/** 
 * Reboot the device immediately, passing 'reason' (may be null) to the underlying __reboot system call.  Should not return.
 */
public void reboot(String reason){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT,null);
  if (mHandler == null || !ActivityManagerNative.isSystemReady()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final String finalReason=reason;
  Runnable runnable=new Runnable(){
    public void run(){
synchronized (this) {
        ShutdownThread.reboot(mContext,finalReason,false);
        notify();
      }
    }
  }
;
  mHandler.post(runnable);
synchronized (runnable) {
    try {
      runnable.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Reboot the device immediately, passing 'reason' (may be null) to the underlying __reboot system call.  Should not return.
 */
public void reboot(String reason){
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT,null);
  if (mHandler == null || !ActivityManagerNative.isSystemReady()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final String finalReason=reason;
  Runnable runnable=new Runnable(){
    public void run(){
synchronized (this) {
        ShutdownThread.reboot(mContext,finalReason,false);
      }
    }
  }
;
  mHandler.post(runnable);
synchronized (runnable) {
    while (true) {
      try {
        runnable.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
}",0.7852044127190136
182327,"final void appNotRespondingLocked(ProcessRecord app,HistoryRecord activity,HistoryRecord parent,final String annotation){
  if (app.notResponding || app.crashing) {
    return;
  }
  EventLog.writeEvent(EventLogTags.AM_ANR,app.pid,app.processName,app.info.flags,annotation);
  ArrayList<Integer> pids=new ArrayList<Integer>(20);
  pids.add(app.pid);
  int parentPid=app.pid;
  if (parent != null && parent.app != null && parent.app.pid > 0)   parentPid=parent.app.pid;
  if (parentPid != app.pid)   pids.add(parentPid);
  if (MY_PID != app.pid && MY_PID != parentPid)   pids.add(MY_PID);
  for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
    ProcessRecord r=mLruProcesses.get(i);
    if (r != null && r.thread != null) {
      int pid=r.pid;
      if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID)       pids.add(pid);
    }
  }
  File tracesFile=dumpStackTraces(pids);
  StringBuilder info=mStringBuilder;
  info.setLength(0);
  info.append(""String_Node_Str"").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(""String_Node_Str"").append(activity.shortComponentName).append(""String_Node_Str"");
  }
  info.append(""String_Node_Str"");
  if (annotation != null) {
    info.append(""String_Node_Str"").append(annotation).append(""String_Node_Str"");
  }
  if (parent != null && parent != activity) {
    info.append(""String_Node_Str"").append(parent.shortComponentName).append(""String_Node_Str"");
  }
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState();
    }
    info.append(cpuInfo);
  }
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox(""String_Node_Str"",app,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
  if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
    Process.killProcess(app.pid);
    return;
  }
  makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? ""String_Node_Str"" + annotation : ""String_Node_Str"",info.toString());
  Message msg=Message.obtain();
  HashMap map=new HashMap();
  msg.what=SHOW_NOT_RESPONDING_MSG;
  msg.obj=map;
  map.put(""String_Node_Str"",app);
  if (activity != null) {
    map.put(""String_Node_Str"",activity);
  }
  mHandler.sendMessage(msg);
  return;
}","final void appNotRespondingLocked(ProcessRecord app,HistoryRecord activity,HistoryRecord parent,final String annotation){
  if (mShuttingDown || app.notResponding || app.crashing) {
    return;
  }
  EventLog.writeEvent(EventLogTags.AM_ANR,app.pid,app.processName,app.info.flags,annotation);
  ArrayList<Integer> pids=new ArrayList<Integer>(20);
  pids.add(app.pid);
  int parentPid=app.pid;
  if (parent != null && parent.app != null && parent.app.pid > 0)   parentPid=parent.app.pid;
  if (parentPid != app.pid)   pids.add(parentPid);
  if (MY_PID != app.pid && MY_PID != parentPid)   pids.add(MY_PID);
  for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
    ProcessRecord r=mLruProcesses.get(i);
    if (r != null && r.thread != null) {
      int pid=r.pid;
      if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID)       pids.add(pid);
    }
  }
  File tracesFile=dumpStackTraces(pids);
  StringBuilder info=mStringBuilder;
  info.setLength(0);
  info.append(""String_Node_Str"").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(""String_Node_Str"").append(activity.shortComponentName).append(""String_Node_Str"");
  }
  info.append(""String_Node_Str"");
  if (annotation != null) {
    info.append(""String_Node_Str"").append(annotation).append(""String_Node_Str"");
  }
  if (parent != null && parent != activity) {
    info.append(""String_Node_Str"").append(parent.shortComponentName).append(""String_Node_Str"");
  }
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState();
    }
    info.append(cpuInfo);
  }
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox(""String_Node_Str"",app,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
  if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
    Process.killProcess(app.pid);
    return;
  }
  makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? ""String_Node_Str"" + annotation : ""String_Node_Str"",info.toString());
  Message msg=Message.obtain();
  HashMap map=new HashMap();
  msg.what=SHOW_NOT_RESPONDING_MSG;
  msg.obj=map;
  map.put(""String_Node_Str"",app);
  if (activity != null) {
    map.put(""String_Node_Str"",activity);
  }
  mHandler.sendMessage(msg);
  return;
}",0.9970654237873297
182328,"final void handleProfilerControl(boolean start,ProfilerControlData pcd){
  if (start) {
    try {
      Debug.startMethodTracing(pcd.path,pcd.fd.getFileDescriptor(),8 * 1024 * 1024,0);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + pcd.path + ""String_Node_Str"");
    }
 finally {
      try {
        pcd.fd.close();
      }
 catch (      IOException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}","final void handleProfilerControl(boolean start,ProfilerControlData pcd){
  if (start) {
    try {
      Debug.startMethodTracing(pcd.path,pcd.fd.getFileDescriptor(),8 * 1024 * 1024,0);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + pcd.path + ""String_Node_Str"");
    }
 finally {
      try {
        pcd.fd.close();
      }
 catch (      IOException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}",0.9938398357289528
182329,"public void setSchedulingGroup(int group){
  try {
    Process.setProcessGroup(Process.myPid(),group);
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + group,e);
  }
}","public void setSchedulingGroup(int group){
  try {
    Process.setProcessGroup(Process.myPid(),group);
  }
 catch (  Exception e) {
    Slog.w(TAG,""String_Node_Str"" + group,e);
  }
}",0.9917355371900828
182330,"public void removeContextRegistrations(Context context,String who,String what){
  HashMap<BroadcastReceiver,ReceiverDispatcher> rmap=mReceivers.remove(context);
  if (rmap != null) {
    Iterator<ReceiverDispatcher> it=rmap.values().iterator();
    while (it.hasNext()) {
      ReceiverDispatcher rd=it.next();
      IntentReceiverLeaked leak=new IntentReceiverLeaked(what + ""String_Node_Str"" + who+ ""String_Node_Str""+ rd.getIntentReceiver()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      leak.setStackTrace(rd.getLocation().getStackTrace());
      Log.e(TAG,leak.getMessage(),leak);
      try {
        ActivityManagerNative.getDefault().unregisterReceiver(rd.getIIntentReceiver());
      }
 catch (      RemoteException e) {
      }
    }
  }
  mUnregisteredReceivers.remove(context);
  HashMap<ServiceConnection,ServiceDispatcher> smap=mServices.remove(context);
  if (smap != null) {
    Iterator<ServiceDispatcher> it=smap.values().iterator();
    while (it.hasNext()) {
      ServiceDispatcher sd=it.next();
      ServiceConnectionLeaked leak=new ServiceConnectionLeaked(what + ""String_Node_Str"" + who+ ""String_Node_Str""+ sd.getServiceConnection()+ ""String_Node_Str"");
      leak.setStackTrace(sd.getLocation().getStackTrace());
      Log.e(TAG,leak.getMessage(),leak);
      try {
        ActivityManagerNative.getDefault().unbindService(sd.getIServiceConnection());
      }
 catch (      RemoteException e) {
      }
      sd.doForget();
    }
  }
  mUnboundServices.remove(context);
}","public void removeContextRegistrations(Context context,String who,String what){
  HashMap<BroadcastReceiver,ReceiverDispatcher> rmap=mReceivers.remove(context);
  if (rmap != null) {
    Iterator<ReceiverDispatcher> it=rmap.values().iterator();
    while (it.hasNext()) {
      ReceiverDispatcher rd=it.next();
      IntentReceiverLeaked leak=new IntentReceiverLeaked(what + ""String_Node_Str"" + who+ ""String_Node_Str""+ rd.getIntentReceiver()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      leak.setStackTrace(rd.getLocation().getStackTrace());
      Slog.e(TAG,leak.getMessage(),leak);
      try {
        ActivityManagerNative.getDefault().unregisterReceiver(rd.getIIntentReceiver());
      }
 catch (      RemoteException e) {
      }
    }
  }
  mUnregisteredReceivers.remove(context);
  HashMap<ServiceConnection,ServiceDispatcher> smap=mServices.remove(context);
  if (smap != null) {
    Iterator<ServiceDispatcher> it=smap.values().iterator();
    while (it.hasNext()) {
      ServiceDispatcher sd=it.next();
      ServiceConnectionLeaked leak=new ServiceConnectionLeaked(what + ""String_Node_Str"" + who+ ""String_Node_Str""+ sd.getServiceConnection()+ ""String_Node_Str"");
      leak.setStackTrace(sd.getLocation().getStackTrace());
      Slog.e(TAG,leak.getMessage(),leak);
      try {
        ActivityManagerNative.getDefault().unbindService(sd.getIServiceConnection());
      }
 catch (      RemoteException e) {
      }
      sd.doForget();
    }
  }
  mUnboundServices.remove(context);
}",0.998015873015873
182331,"private final void handleCreateBackupAgent(CreateBackupAgentData data){
  if (DEBUG_BACKUP)   Log.v(TAG,""String_Node_Str"" + data);
  unscheduleGcIdler();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.appInfo);
  String packageName=packageInfo.mPackageName;
  if (mBackupAgents.get(packageName) != null) {
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + packageName + ""String_Node_Str"");
    return;
  }
  BackupAgent agent=null;
  String classname=data.appInfo.backupAgentName;
  if (classname == null) {
    if (data.backupMode == IApplicationThread.BACKUP_MODE_INCREMENTAL) {
      Log.e(TAG,""String_Node_Str"" + packageName);
      return;
    }
    classname=""String_Node_Str"";
  }
  try {
    IBinder binder=null;
    try {
      java.lang.ClassLoader cl=packageInfo.getClassLoader();
      agent=(BackupAgent)cl.loadClass(data.appInfo.backupAgentName).newInstance();
      if (DEBUG_BACKUP)       Log.v(TAG,""String_Node_Str"" + data.appInfo.backupAgentName);
      ContextImpl context=new ContextImpl();
      context.init(packageInfo,null,this);
      context.setOuterContext(agent);
      agent.attach(context);
      agent.onCreate();
      binder=agent.onBind();
      mBackupAgents.put(packageName,agent);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"" + e);
      if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE) {
        throw e;
      }
    }
    try {
      ActivityManagerNative.getDefault().backupAgentCreated(packageName,binder);
    }
 catch (    RemoteException e) {
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + data.appInfo.backupAgentName + ""String_Node_Str""+ e.toString(),e);
  }
}","private final void handleCreateBackupAgent(CreateBackupAgentData data){
  if (DEBUG_BACKUP)   Log.v(TAG,""String_Node_Str"" + data);
  unscheduleGcIdler();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.appInfo);
  String packageName=packageInfo.mPackageName;
  if (mBackupAgents.get(packageName) != null) {
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + packageName + ""String_Node_Str"");
    return;
  }
  BackupAgent agent=null;
  String classname=data.appInfo.backupAgentName;
  if (classname == null) {
    if (data.backupMode == IApplicationThread.BACKUP_MODE_INCREMENTAL) {
      Slog.e(TAG,""String_Node_Str"" + packageName);
      return;
    }
    classname=""String_Node_Str"";
  }
  try {
    IBinder binder=null;
    try {
      java.lang.ClassLoader cl=packageInfo.getClassLoader();
      agent=(BackupAgent)cl.loadClass(data.appInfo.backupAgentName).newInstance();
      if (DEBUG_BACKUP)       Log.v(TAG,""String_Node_Str"" + data.appInfo.backupAgentName);
      ContextImpl context=new ContextImpl();
      context.init(packageInfo,null,this);
      context.setOuterContext(agent);
      agent.attach(context);
      agent.onCreate();
      binder=agent.onBind();
      mBackupAgents.put(packageName,agent);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"" + e);
      if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE) {
        throw e;
      }
    }
    try {
      ActivityManagerNative.getDefault().backupAgentCreated(packageName,binder);
    }
 catch (    RemoteException e) {
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + data.appInfo.backupAgentName + ""String_Node_Str""+ e.toString(),e);
  }
}",0.99822695035461
182332,"private final IContentProvider installProvider(Context context,IContentProvider provider,ProviderInfo info,boolean noisy){
  ContentProvider localProvider=null;
  if (provider == null) {
    if (noisy) {
      Log.d(TAG,""String_Node_Str"" + info.authority + ""String_Node_Str""+ info.name);
    }
    Context c=null;
    ApplicationInfo ai=info.applicationInfo;
    if (context.getPackageName().equals(ai.packageName)) {
      c=context;
    }
 else     if (mInitialApplication != null && mInitialApplication.getPackageName().equals(ai.packageName)) {
      c=mInitialApplication;
    }
 else {
      try {
        c=context.createPackageContext(ai.packageName,Context.CONTEXT_INCLUDE_CODE);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    if (c == null) {
      Log.w(TAG,""String_Node_Str"" + ai.packageName + ""String_Node_Str""+ info.name);
      return null;
    }
    try {
      final java.lang.ClassLoader cl=c.getClassLoader();
      localProvider=(ContentProvider)cl.loadClass(info.name).newInstance();
      provider=localProvider.getIContentProvider();
      if (provider == null) {
        Log.e(TAG,""String_Node_Str"" + info.name + ""String_Node_Str""+ info.applicationInfo.sourceDir);
        return null;
      }
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + info.name);
      localProvider.attachInfo(c,info);
    }
 catch (    java.lang.Exception e) {
      if (!mInstrumentation.onException(null,e)) {
        throw new RuntimeException(""String_Node_Str"" + info.name + ""String_Node_Str""+ e.toString(),e);
      }
      return null;
    }
  }
 else   if (localLOGV) {
    Log.v(TAG,""String_Node_Str"" + info.authority + ""String_Node_Str""+ info.name);
  }
synchronized (mProviderMap) {
    String names[]=PATTERN_SEMICOLON.split(info.authority);
    for (int i=0; i < names.length; i++) {
      ProviderRecord pr=new ProviderRecord(names[i],provider,localProvider);
      try {
        provider.asBinder().linkToDeath(pr,0);
        mProviderMap.put(names[i],pr);
      }
 catch (      RemoteException e) {
        return null;
      }
    }
    if (localProvider != null) {
      mLocalProviders.put(provider.asBinder(),new ProviderRecord(null,provider,localProvider));
    }
  }
  return provider;
}","private final IContentProvider installProvider(Context context,IContentProvider provider,ProviderInfo info,boolean noisy){
  ContentProvider localProvider=null;
  if (provider == null) {
    if (noisy) {
      Log.d(TAG,""String_Node_Str"" + info.authority + ""String_Node_Str""+ info.name);
    }
    Context c=null;
    ApplicationInfo ai=info.applicationInfo;
    if (context.getPackageName().equals(ai.packageName)) {
      c=context;
    }
 else     if (mInitialApplication != null && mInitialApplication.getPackageName().equals(ai.packageName)) {
      c=mInitialApplication;
    }
 else {
      try {
        c=context.createPackageContext(ai.packageName,Context.CONTEXT_INCLUDE_CODE);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    if (c == null) {
      Slog.w(TAG,""String_Node_Str"" + ai.packageName + ""String_Node_Str""+ info.name);
      return null;
    }
    try {
      final java.lang.ClassLoader cl=c.getClassLoader();
      localProvider=(ContentProvider)cl.loadClass(info.name).newInstance();
      provider=localProvider.getIContentProvider();
      if (provider == null) {
        Slog.e(TAG,""String_Node_Str"" + info.name + ""String_Node_Str""+ info.applicationInfo.sourceDir);
        return null;
      }
      if (Config.LOGV)       Log.v(TAG,""String_Node_Str"" + info.name);
      localProvider.attachInfo(c,info);
    }
 catch (    java.lang.Exception e) {
      if (!mInstrumentation.onException(null,e)) {
        throw new RuntimeException(""String_Node_Str"" + info.name + ""String_Node_Str""+ e.toString(),e);
      }
      return null;
    }
  }
 else   if (localLOGV) {
    Log.v(TAG,""String_Node_Str"" + info.authority + ""String_Node_Str""+ info.name);
  }
synchronized (mProviderMap) {
    String names[]=PATTERN_SEMICOLON.split(info.authority);
    for (int i=0; i < names.length; i++) {
      ProviderRecord pr=new ProviderRecord(names[i],provider,localProvider);
      try {
        provider.asBinder().linkToDeath(pr,0);
        mProviderMap.put(names[i],pr);
      }
 catch (      RemoteException e) {
        return null;
      }
    }
    if (localProvider != null) {
      mLocalProviders.put(provider.asBinder(),new ProviderRecord(null,provider,localProvider));
    }
  }
  return provider;
}",0.998669623059867
182333,"private final void handleDestroyBackupAgent(CreateBackupAgentData data){
  if (DEBUG_BACKUP)   Log.v(TAG,""String_Node_Str"" + data);
  PackageInfo packageInfo=getPackageInfoNoCheck(data.appInfo);
  String packageName=packageInfo.mPackageName;
  BackupAgent agent=mBackupAgents.get(packageName);
  if (agent != null) {
    try {
      agent.onDestroy();
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + data.appInfo);
      e.printStackTrace();
    }
    mBackupAgents.remove(packageName);
  }
 else {
    Log.w(TAG,""String_Node_Str"" + data);
  }
}","private final void handleDestroyBackupAgent(CreateBackupAgentData data){
  if (DEBUG_BACKUP)   Log.v(TAG,""String_Node_Str"" + data);
  PackageInfo packageInfo=getPackageInfoNoCheck(data.appInfo);
  String packageName=packageInfo.mPackageName;
  BackupAgent agent=mBackupAgents.get(packageName);
  if (agent != null) {
    try {
      agent.onDestroy();
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"" + data.appInfo);
      e.printStackTrace();
    }
    mBackupAgents.remove(packageName);
  }
 else {
    Slog.w(TAG,""String_Node_Str"" + data);
  }
}",0.9947089947089948
182334,"private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Log.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  if (holder.permissionFailure != null) {
    throw new SecurityException(""String_Node_Str"" + holder.permissionFailure + ""String_Node_Str""+ name);
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}","private final IContentProvider getProvider(Context context,String name){
synchronized (mProviderMap) {
    final ProviderRecord pr=mProviderMap.get(name);
    if (pr != null) {
      return pr.mProvider;
    }
  }
  IActivityManager.ContentProviderHolder holder=null;
  try {
    holder=ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(),name);
  }
 catch (  RemoteException ex) {
  }
  if (holder == null) {
    Slog.e(TAG,""String_Node_Str"" + name);
    return null;
  }
  if (holder.permissionFailure != null) {
    throw new SecurityException(""String_Node_Str"" + holder.permissionFailure + ""String_Node_Str""+ name);
  }
  IContentProvider prov=installProvider(context,holder.provider,holder.info,true);
  if (holder.noReleaseNeeded || holder.provider == null) {
synchronized (mProviderMap) {
      mProviderRefCountMap.put(prov.asBinder(),new ProviderRefCount(10000));
    }
  }
  return prov;
}",0.9983757444504602
182335,"private final void performStopActivityInner(ActivityRecord r,StopInfo info,boolean keepShown){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  if (r != null) {
    if (!keepShown && r.stopped) {
      if (r.activity.mFinished) {
        return;
      }
      RuntimeException e=new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString());
      Log.e(TAG,e.getMessage(),e);
    }
    if (info != null) {
      try {
        info.description=r.activity.onCreateDescription();
      }
 catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
    }
    if (!keepShown) {
      try {
        r.activity.performStop();
      }
 catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.stopped=true;
    }
    r.paused=true;
  }
}","private final void performStopActivityInner(ActivityRecord r,StopInfo info,boolean keepShown){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  if (r != null) {
    if (!keepShown && r.stopped) {
      if (r.activity.mFinished) {
        return;
      }
      RuntimeException e=new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString());
      Slog.e(TAG,e.getMessage(),e);
    }
    if (info != null) {
      try {
        info.description=r.activity.onCreateDescription();
      }
 catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
    }
    if (!keepShown) {
      try {
        r.activity.performStop();
      }
 catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.stopped=true;
    }
    r.paused=true;
  }
}",0.9986708019494904
182336,"private void warn(String methodName){
  if (warned) {
    return;
  }
  warned=true;
  Thread.currentThread().setContextClassLoader(getParent());
  Log.w(TAG,""String_Node_Str"" + methodName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private void warn(String methodName){
  if (warned) {
    return;
  }
  warned=true;
  Thread.currentThread().setContextClassLoader(getParent());
  Slog.w(TAG,""String_Node_Str"" + methodName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9951219512195122
182337,"final Bundle performPauseActivity(ActivityRecord r,boolean finished,boolean saveState){
  if (r.paused) {
    if (r.activity.mFinished) {
      return null;
    }
    RuntimeException e=new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString());
    Log.e(TAG,e.getMessage(),e);
  }
  Bundle state=null;
  if (finished) {
    r.activity.mFinished=true;
  }
  try {
    if (!r.activity.mFinished && saveState) {
      state=new Bundle();
      mInstrumentation.callActivityOnSaveInstanceState(r.activity,state);
      r.state=state;
    }
    r.activity.mCalled=false;
    mInstrumentation.callActivityOnPause(r.activity);
    EventLog.writeEvent(LOG_ON_PAUSE_CALLED,r.activity.getComponentName().getClassName());
    if (!r.activity.mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
    }
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(r.activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
    }
  }
  r.paused=true;
  return state;
}","final Bundle performPauseActivity(ActivityRecord r,boolean finished,boolean saveState){
  if (r.paused) {
    if (r.activity.mFinished) {
      return null;
    }
    RuntimeException e=new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString());
    Slog.e(TAG,e.getMessage(),e);
  }
  Bundle state=null;
  if (finished) {
    r.activity.mFinished=true;
  }
  try {
    if (!r.activity.mFinished && saveState) {
      state=new Bundle();
      mInstrumentation.callActivityOnSaveInstanceState(r.activity,state);
      r.state=state;
    }
    r.activity.mCalled=false;
    mInstrumentation.callActivityOnPause(r.activity);
    EventLog.writeEvent(LOG_ON_PAUSE_CALLED,r.activity.getComponentName().getClassName());
    if (!r.activity.mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
    }
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(r.activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
    }
  }
  r.paused=true;
  return state;
}",0.9987598181066556
182338,"/** 
 * The main function called when started through the zygote process. This could be unified with main(), if the native code in finishInit() were rationalized with Zygote startup.<p> Current recognized args: <ul> <li> --nice-name=<i>nice name to appear in ps</i> <li> <code> [--] &lt;start class name&gt;  &lt;args&gt; </ul>
 * @param argv arg strings
 */
public static final void zygoteInit(String[] argv) throws ZygoteInit.MethodAndArgsCaller {
  System.setOut(new AndroidPrintStream(Log.INFO,""String_Node_Str""));
  System.setErr(new AndroidPrintStream(Log.WARN,""String_Node_Str""));
  commonInit();
  zygoteInitNative();
  int curArg=0;
  for (; curArg < argv.length; curArg++) {
    String arg=argv[curArg];
    if (arg.equals(""String_Node_Str"")) {
      curArg++;
      break;
    }
 else     if (!arg.startsWith(""String_Node_Str"")) {
      break;
    }
 else     if (arg.startsWith(""String_Node_Str"")) {
      String niceName=arg.substring(arg.indexOf('=') + 1);
      Process.setArgV0(niceName);
    }
  }
  if (curArg == argv.length) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  String startClass=argv[curArg++];
  String[] startArgs=new String[argv.length - curArg];
  System.arraycopy(argv,curArg,startArgs,0,startArgs.length);
  invokeStaticMain(startClass,startArgs);
}","/** 
 * The main function called when started through the zygote process. This could be unified with main(), if the native code in finishInit() were rationalized with Zygote startup.<p> Current recognized args: <ul> <li> --nice-name=<i>nice name to appear in ps</i> <li> <code> [--] &lt;start class name&gt;  &lt;args&gt; </ul>
 * @param argv arg strings
 */
public static final void zygoteInit(String[] argv) throws ZygoteInit.MethodAndArgsCaller {
  System.setOut(new AndroidPrintStream(Log.INFO,""String_Node_Str""));
  System.setErr(new AndroidPrintStream(Log.WARN,""String_Node_Str""));
  commonInit();
  zygoteInitNative();
  int curArg=0;
  for (; curArg < argv.length; curArg++) {
    String arg=argv[curArg];
    if (arg.equals(""String_Node_Str"")) {
      curArg++;
      break;
    }
 else     if (!arg.startsWith(""String_Node_Str"")) {
      break;
    }
 else     if (arg.startsWith(""String_Node_Str"")) {
      String niceName=arg.substring(arg.indexOf('=') + 1);
      Process.setArgV0(niceName);
    }
  }
  if (curArg == argv.length) {
    Slog.e(TAG,""String_Node_Str"");
    return;
  }
  String startClass=argv[curArg++];
  String[] startArgs=new String[argv.length - curArg];
  System.arraycopy(argv,curArg,startArgs,0,startArgs.length);
  invokeStaticMain(startClass,startArgs);
}",0.9988394584139264
182339,"/** 
 * Report a serious error in the current process.  May or may not cause the process to terminate (depends on system settings).
 * @param tag to record with the error
 * @param t exception describing the error site and conditions
 */
public static void wtf(String tag,Throwable t){
  try {
    if (ActivityManagerNative.getDefault().handleApplicationWtf(mApplicationObject,tag,new ApplicationErrorReport.CrashInfo(t))) {
      Process.killProcess(Process.myPid());
      System.exit(10);
    }
  }
 catch (  Throwable t2) {
    Log.e(TAG,""String_Node_Str"",t2);
  }
}","/** 
 * Report a serious error in the current process.  May or may not cause the process to terminate (depends on system settings).
 * @param tag to record with the error
 * @param t exception describing the error site and conditions
 */
public static void wtf(String tag,Throwable t){
  try {
    if (ActivityManagerNative.getDefault().handleApplicationWtf(mApplicationObject,tag,new ApplicationErrorReport.CrashInfo(t))) {
      Process.killProcess(Process.myPid());
      System.exit(10);
    }
  }
 catch (  Throwable t2) {
    Slog.e(TAG,""String_Node_Str"",t2);
  }
}",0.9973707274320772
182340,"public static final void main(String[] argv){
  commonInit();
  finishInit();
  if (Config.LOGV)   Log.d(TAG,""String_Node_Str"");
}","public static final void main(String[] argv){
  commonInit();
  finishInit();
  if (Config.LOGV)   Slog.d(TAG,""String_Node_Str"");
}",0.9885057471264368
182341,"private static final void commonInit(){
  if (Config.LOGV)   Log.d(TAG,""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());
  int hasQwerty=getQwertyKeyboard();
  if (Config.LOGV)   Log.d(TAG,""String_Node_Str"" + hasQwerty);
  if (hasQwerty == 1) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  TimezoneGetter.setInstance(new TimezoneGetter(){
    @Override public String getId(){
      return SystemProperties.get(""String_Node_Str"");
    }
  }
);
  TimeZone.setDefault(null);
  LogManager.getLogManager().reset();
  new AndroidConfig();
  String userAgent=getDefaultUserAgent();
  System.setProperty(""String_Node_Str"",userAgent);
  String trace=SystemProperties.get(""String_Node_Str"");
  if (trace.equals(""String_Node_Str"")) {
    Log.i(TAG,""String_Node_Str"");
    Debug.enableEmulatorTraceOutput();
  }
  initialized=true;
}","private static final void commonInit(){
  if (Config.LOGV)   Slog.d(TAG,""String_Node_Str"");
  Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());
  int hasQwerty=getQwertyKeyboard();
  if (Config.LOGV)   Slog.d(TAG,""String_Node_Str"" + hasQwerty);
  if (hasQwerty == 1) {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  TimezoneGetter.setInstance(new TimezoneGetter(){
    @Override public String getId(){
      return SystemProperties.get(""String_Node_Str"");
    }
  }
);
  TimeZone.setDefault(null);
  LogManager.getLogManager().reset();
  new AndroidConfig();
  String userAgent=getDefaultUserAgent();
  System.setProperty(""String_Node_Str"",userAgent);
  String trace=SystemProperties.get(""String_Node_Str"");
  if (trace.equals(""String_Node_Str"")) {
    Slog.i(TAG,""String_Node_Str"");
    Debug.enableEmulatorTraceOutput();
  }
  initialized=true;
}",0.9949008498583568
182342,"public void uncaughtException(Thread t,Throwable e){
  try {
    if (mCrashing)     return;
    mCrashing=true;
    if (mApplicationObject == null) {
      Log.e(TAG,""String_Node_Str"" + t.getName(),e);
    }
 else {
      Log.e(TAG,""String_Node_Str"" + t.getName(),e);
    }
    ActivityManagerNative.getDefault().handleApplicationCrash(mApplicationObject,new ApplicationErrorReport.CrashInfo(e));
  }
 catch (  Throwable t2) {
    try {
      Log.e(TAG,""String_Node_Str"",t2);
    }
 catch (    Throwable t3) {
    }
  }
 finally {
    Process.killProcess(Process.myPid());
    System.exit(10);
  }
}","public void uncaughtException(Thread t,Throwable e){
  try {
    if (mCrashing)     return;
    mCrashing=true;
    if (mApplicationObject == null) {
      Slog.e(TAG,""String_Node_Str"" + t.getName(),e);
    }
 else {
      Slog.e(TAG,""String_Node_Str"" + t.getName(),e);
    }
    ActivityManagerNative.getDefault().handleApplicationCrash(mApplicationObject,new ApplicationErrorReport.CrashInfo(e));
  }
 catch (  Throwable t2) {
    try {
      Slog.e(TAG,""String_Node_Str"",t2);
    }
 catch (    Throwable t3) {
    }
  }
 finally {
    Process.killProcess(Process.myPid());
    System.exit(10);
  }
}",0.9925062447960034
182343,"public void clearWallpaperLocked(){
  File f=WALLPAPER_FILE;
  if (f.exists()) {
    f.delete();
  }
  final long ident=Binder.clearCallingIdentity();
  try {
    bindWallpaperComponentLocked(null);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void clearWallpaperLocked(){
  File f=WALLPAPER_FILE;
  if (f.exists()) {
    f.delete();
  }
  final long ident=Binder.clearCallingIdentity();
  try {
    bindWallpaperComponentLocked(null);
  }
 catch (  IllegalArgumentException e) {
    Slog.e(TAG,""String_Node_Str"",e);
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.8675496688741722
182344,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if ((DEBUG_RESIZE || DEBUG_ORIENTATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9882918903420044
182345,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean wallpaperForceHidingChanged=false;
    int repeats=0;
    int changes=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,""String_Node_Str"");
        mLayoutNeeded=false;
        break;
      }
      if ((changes & (WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG | WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT)) != 0) {
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
          if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
            assignLayersLocked();
            mLayoutNeeded=true;
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,""String_Node_Str"");
          if (updateOrientationFromAppTokensLocked()) {
            mLayoutNeeded=true;
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
          }
        }
        if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          mLayoutNeeded=true;
        }
      }
      if (repeats < 4) {
        changes=performLayoutLockedInner();
        if (changes != 0) {
          continue;
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"");
        changes=0;
      }
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean forceHiding=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
            }
 else {
              changed=w.showLw(false,false);
              if (DEBUG_VISIBILITY && changed)               Slog.v(TAG,""String_Node_Str"" + w);
              if (changed) {
                if (wallpaperForceHidingChanged && w.isVisibleNow()) {
                  Animation a=mPolicy.createForceHideEnterAnimation();
                  if (a != null) {
                    w.setAnimation(a);
                  }
                }
                if (mCurrentFocus == null || mCurrentFocus.mLayer < w.mLayer) {
                  mFocusMayChange=true;
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      changes|=mPolicy.finishAnimationLw();
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && changes == 0 && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
  adjResult=0;
}
}
if (mLayoutNeeded) {
changes|=PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(changes));
}
 while (changes != 0);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top,null);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       logSurface(w,""String_Node_Str"" + w.mShownFrame.left + ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height(),null);
      w.mSurfaceResized=true;
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| w.mSurfaceResized|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_RESIZE || DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   logSurface(w,""String_Node_Str"" + w.mShownAlpha + ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"",null);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     logSurface(w,""String_Node_Str"",null);
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (canBeSeen && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if ((DEBUG_RESIZE || DEBUG_ORIENTATION) && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
win.mSurfaceResized=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9882918903420044
182346,"/** 
 * Searches for an entry in the CalendarAlerts table that matches the given event id, begin time and alarm time.  If one is found then this alarm already exists and this method returns true.
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given eventwith the same start time and alarm time.
 */
public static final boolean alarmExists(ContentResolver cr,long eventId,long begin,long alarmTime){
  String selection=CalendarAlerts.EVENT_ID + ""String_Node_Str"" + eventId+ ""String_Node_Str""+ CalendarAlerts.BEGIN+ ""String_Node_Str""+ begin+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ alarmTime;
  String[] projection=new String[]{CalendarAlerts.ALARM_TIME};
  Cursor cursor=query(cr,projection,selection,null,null);
  boolean found=false;
  try {
    if (cursor != null && cursor.getCount() > 0) {
      found=true;
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return found;
}","/** 
 * Searches for an entry in the CalendarAlerts table that matches the given event id, begin time and alarm time.  If one is found then this alarm already exists and this method returns true.
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given eventwith the same start time and alarm time.
 */
public static final boolean alarmExists(ContentResolver cr,long eventId,long begin,long alarmTime){
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,WHERE_ALARM_EXISTS,new String[]{Long.toString(eventId),Long.toString(begin),Long.toString(alarmTime)},null);
  boolean found=false;
  try {
    if (cursor != null && cursor.getCount() > 0) {
      found=true;
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return found;
}",0.8382838283828383
182347,"@Override public Entity getEntityAndIncrementCursor(Cursor cursor) throws RemoteException {
  final long eventId=cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
  ContentValues cv=new ContentValues();
  cv.put(Events._ID,eventId);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,CALENDAR_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HTML_URI);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,TITLE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DESCRIPTION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_LOCATION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,STATUS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,SELF_ATTENDEE_STATUS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,COMMENTS_URI);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTSTART);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTEND);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DURATION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_TIMEZONE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ALL_DAY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,VISIBILITY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,TRANSPARENCY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_ALARM);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_EXTENDED_PROPERTIES);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORIGINAL_EVENT);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,ORIGINAL_INSTANCE_TIME);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,ORIGINAL_ALL_DAY);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,LAST_DATE);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,HAS_ATTENDEE_DATA);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_INVITE_OTHERS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_MODIFY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_SEE_GUESTS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORGANIZER);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_DATA);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,_SYNC_DIRTY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_VERSION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,DELETED);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,Calendars.URL);
  Entity entity=new Entity(cv);
  Cursor subCursor;
  if (mResolver != null) {
    subCursor=mResolver.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues reminderValues=new ContentValues();
      reminderValues.put(Reminders.MINUTES,subCursor.getInt(COLUMN_MINUTES));
      reminderValues.put(Reminders.METHOD,subCursor.getInt(COLUMN_METHOD));
      entity.addSubValue(Reminders.CONTENT_URI,reminderValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues attendeeValues=new ContentValues();
      attendeeValues.put(Attendees.ATTENDEE_NAME,subCursor.getString(COLUMN_ATTENDEE_NAME));
      attendeeValues.put(Attendees.ATTENDEE_EMAIL,subCursor.getString(COLUMN_ATTENDEE_EMAIL));
      attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP,subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
      attendeeValues.put(Attendees.ATTENDEE_TYPE,subCursor.getInt(COLUMN_ATTENDEE_TYPE));
      attendeeValues.put(Attendees.ATTENDEE_STATUS,subCursor.getInt(COLUMN_ATTENDEE_STATUS));
      entity.addSubValue(Attendees.CONTENT_URI,attendeeValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues extendedValues=new ContentValues();
      extendedValues.put(ExtendedProperties.NAME,subCursor.getString(COLUMN_NAME));
      extendedValues.put(ExtendedProperties.VALUE,subCursor.getString(COLUMN_VALUE));
      entity.addSubValue(ExtendedProperties.CONTENT_URI,extendedValues);
    }
  }
  finally {
    subCursor.close();
  }
  cursor.moveToNext();
  return entity;
}","@Override public Entity getEntityAndIncrementCursor(Cursor cursor) throws RemoteException {
  final long eventId=cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
  ContentValues cv=new ContentValues();
  cv.put(Events._ID,eventId);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,CALENDAR_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HTML_URI);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,TITLE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DESCRIPTION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_LOCATION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,STATUS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,SELF_ATTENDEE_STATUS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,COMMENTS_URI);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTSTART);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTEND);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DURATION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_TIMEZONE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ALL_DAY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,VISIBILITY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,TRANSPARENCY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_ALARM);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_EXTENDED_PROPERTIES);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORIGINAL_EVENT);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,ORIGINAL_INSTANCE_TIME);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,ORIGINAL_ALL_DAY);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,LAST_DATE);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,HAS_ATTENDEE_DATA);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_INVITE_OTHERS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_MODIFY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_SEE_GUESTS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORGANIZER);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_DATA);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,_SYNC_DIRTY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_VERSION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,DELETED);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,Calendars.URL);
  Entity entity=new Entity(cv);
  Cursor subCursor;
  if (mResolver != null) {
    subCursor=mResolver.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues reminderValues=new ContentValues();
      reminderValues.put(Reminders.MINUTES,subCursor.getInt(COLUMN_MINUTES));
      reminderValues.put(Reminders.METHOD,subCursor.getInt(COLUMN_METHOD));
      entity.addSubValue(Reminders.CONTENT_URI,reminderValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues attendeeValues=new ContentValues();
      attendeeValues.put(Attendees.ATTENDEE_NAME,subCursor.getString(COLUMN_ATTENDEE_NAME));
      attendeeValues.put(Attendees.ATTENDEE_EMAIL,subCursor.getString(COLUMN_ATTENDEE_EMAIL));
      attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP,subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
      attendeeValues.put(Attendees.ATTENDEE_TYPE,subCursor.getInt(COLUMN_ATTENDEE_TYPE));
      attendeeValues.put(Attendees.ATTENDEE_STATUS,subCursor.getInt(COLUMN_ATTENDEE_STATUS));
      entity.addSubValue(Attendees.CONTENT_URI,attendeeValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues extendedValues=new ContentValues();
      extendedValues.put(ExtendedProperties.NAME,subCursor.getString(COLUMN_NAME));
      extendedValues.put(ExtendedProperties.VALUE,subCursor.getString(COLUMN_VALUE));
      entity.addSubValue(ExtendedProperties.CONTENT_URI,extendedValues);
    }
  }
  finally {
    subCursor.close();
  }
  cursor.moveToNext();
  return entity;
}",0.9540166204986148
182348,"/** 
 * Finds the next alarm after (or equal to) the given time and returns the time of that alarm or -1 if no such alarm exists.
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1if no such alarm exists.
 */
public static final long findNextAlarmTime(ContentResolver cr,long millis){
  String selection=ALARM_TIME + ""String_Node_Str"" + millis;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,selection,null,ALARM_TIME + ""String_Node_Str"");
  long alarmTime=-1;
  try {
    if (cursor != null && cursor.moveToFirst()) {
      alarmTime=cursor.getLong(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return alarmTime;
}","/** 
 * Finds the next alarm after (or equal to) the given time and returns the time of that alarm or -1 if no such alarm exists.
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1if no such alarm exists.
 */
public static final long findNextAlarmTime(ContentResolver cr,long millis){
  String selection=ALARM_TIME + ""String_Node_Str"" + millis;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,WHERE_FINDNEXTALARMTIME,new String[]{Long.toString(millis)},SORT_ORDER_ALARMTIME_ASC);
  long alarmTime=-1;
  try {
    if (cursor != null && cursor.moveToFirst()) {
      alarmTime=cursor.getLong(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return alarmTime;
}",0.9426987060998152
182349,"public static void scheduleAlarm(Context context,AlarmManager manager,long alarmTime){
  if (DEBUG) {
    Time time=new Time();
    time.set(alarmTime);
    String schedTime=time.format(""String_Node_Str"");
    Log.d(TAG,""String_Node_Str"" + alarmTime + ""String_Node_Str""+ schedTime);
  }
  if (manager == null) {
    manager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  }
  Intent intent=new Intent(android.provider.Calendar.EVENT_REMINDER_ACTION);
  intent.putExtra(android.provider.Calendar.CalendarAlerts.ALARM_TIME,alarmTime);
  PendingIntent pi=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  manager.set(AlarmManager.RTC_WAKEUP,alarmTime,pi);
}","public static void scheduleAlarm(Context context,AlarmManager manager,long alarmTime){
  if (DEBUG) {
    Time time=new Time();
    time.set(alarmTime);
    String schedTime=time.format(""String_Node_Str"");
    Log.d(TAG,""String_Node_Str"" + alarmTime + ""String_Node_Str""+ schedTime);
  }
  if (manager == null) {
    manager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  }
  Intent intent=new Intent(EVENT_REMINDER_ACTION);
  intent.putExtra(ALARM_TIME,alarmTime);
  PendingIntent pi=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  manager.set(AlarmManager.RTC_WAKEUP,alarmTime,pi);
}",0.9499626587005228
182350,"/** 
 * Convenience method to delete all calendars that match the account.
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
public static int deleteCalendarsForAccount(ContentResolver cr,Account account){
  return Calendar.Calendars.delete(cr,Calendar.Calendars._SYNC_ACCOUNT + ""String_Node_Str"" + Calendar.Calendars._SYNC_ACCOUNT_TYPE+ ""String_Node_Str"",new String[]{account.name,account.type});
}","/** 
 * Convenience method to delete all calendars that match the account.
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
public static int deleteCalendarsForAccount(ContentResolver cr,Account account){
  return Calendar.Calendars.delete(cr,WHERE_DELETE_FOR_ACCOUNT,new String[]{account.name,account.type});
}",0.8695652173913043
182351,"/** 
 * Searches the CalendarAlerts table for alarms that should have fired but have not and then reschedules them.  This method can be called at boot time to restore alarms that may have been lost due to a phone reboot.
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
public static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManager manager){
  long now=System.currentTimeMillis();
  long ancient=now - DateUtils.DAY_IN_MILLIS;
  String selection=CalendarAlerts.STATE + ""String_Node_Str"" + CalendarAlerts.SCHEDULED+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ now+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ ancient+ ""String_Node_Str""+ CalendarAlerts.END+ ""String_Node_Str""+ now;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=CalendarAlerts.query(cr,projection,selection,null,""String_Node_Str"");
  if (cursor == null) {
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + cursor.getCount());
  }
  try {
    long alarmTime=-1;
    while (cursor.moveToNext()) {
      long newAlarmTime=cursor.getLong(0);
      if (alarmTime != newAlarmTime) {
        if (DEBUG) {
          Log.w(TAG,""String_Node_Str"" + newAlarmTime);
        }
        scheduleAlarm(context,manager,newAlarmTime);
        alarmTime=newAlarmTime;
      }
    }
  }
  finally {
    cursor.close();
  }
}","/** 
 * Searches the CalendarAlerts table for alarms that should have fired but have not and then reschedules them.  This method can be called at boot time to restore alarms that may have been lost due to a phone reboot.
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
public static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManager manager){
  long now=System.currentTimeMillis();
  long ancient=now - DateUtils.DAY_IN_MILLIS;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=CalendarAlerts.query(cr,projection,WHERE_RESCHEDULE_MISSED_ALARMS,new String[]{Long.toString(now),Long.toString(ancient),Long.toString(now)},SORT_ORDER_ALARMTIME_ASC);
  if (cursor == null) {
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + cursor.getCount());
  }
  try {
    long alarmTime=-1;
    while (cursor.moveToNext()) {
      long newAlarmTime=cursor.getLong(0);
      if (alarmTime != newAlarmTime) {
        if (DEBUG) {
          Log.w(TAG,""String_Node_Str"" + newAlarmTime);
        }
        scheduleAlarm(context,manager,newAlarmTime);
        alarmTime=newAlarmTime;
      }
    }
  }
  finally {
    cursor.close();
  }
}",0.7899285982713266
182352,"/** 
 * Searches for an entry in the CalendarAlerts table that matches the given event id, begin time and alarm time.  If one is found then this alarm already exists and this method returns true.
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given eventwith the same start time and alarm time.
 */
public static final boolean alarmExists(ContentResolver cr,long eventId,long begin,long alarmTime){
  String selection=CalendarAlerts.EVENT_ID + ""String_Node_Str"" + eventId+ ""String_Node_Str""+ CalendarAlerts.BEGIN+ ""String_Node_Str""+ begin+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ alarmTime;
  String[] projection=new String[]{CalendarAlerts.ALARM_TIME};
  Cursor cursor=query(cr,projection,selection,null,null);
  boolean found=false;
  try {
    if (cursor != null && cursor.getCount() > 0) {
      found=true;
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return found;
}","/** 
 * Searches for an entry in the CalendarAlerts table that matches the given event id, begin time and alarm time.  If one is found then this alarm already exists and this method returns true.
 * @param cr the ContentResolver
 * @param eventId the event id to match
 * @param begin the start time of the event in UTC millis
 * @param alarmTime the alarm time of the event in UTC millis
 * @return true if there is already an alarm for the given eventwith the same start time and alarm time.
 */
public static final boolean alarmExists(ContentResolver cr,long eventId,long begin,long alarmTime){
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,WHERE_ALARM_EXISTS,new String[]{Long.toString(eventId),Long.toString(begin),Long.toString(alarmTime)},null);
  boolean found=false;
  try {
    if (cursor != null && cursor.getCount() > 0) {
      found=true;
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return found;
}",0.8382838283828383
182353,"@Override public Entity getEntityAndIncrementCursor(Cursor cursor) throws RemoteException {
  final long eventId=cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
  ContentValues cv=new ContentValues();
  cv.put(Events._ID,eventId);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,CALENDAR_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HTML_URI);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,TITLE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DESCRIPTION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_LOCATION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,STATUS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,SELF_ATTENDEE_STATUS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,COMMENTS_URI);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTSTART);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTEND);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DURATION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_TIMEZONE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ALL_DAY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,VISIBILITY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,TRANSPARENCY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_ALARM);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_EXTENDED_PROPERTIES);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORIGINAL_EVENT);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,ORIGINAL_INSTANCE_TIME);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,ORIGINAL_ALL_DAY);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,LAST_DATE);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,HAS_ATTENDEE_DATA);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_INVITE_OTHERS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_MODIFY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_SEE_GUESTS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORGANIZER);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_DATA);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,_SYNC_DIRTY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_VERSION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,DELETED);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,Calendars.URL);
  Entity entity=new Entity(cv);
  Cursor subCursor;
  if (mResolver != null) {
    subCursor=mResolver.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues reminderValues=new ContentValues();
      reminderValues.put(Reminders.MINUTES,subCursor.getInt(COLUMN_MINUTES));
      reminderValues.put(Reminders.METHOD,subCursor.getInt(COLUMN_METHOD));
      entity.addSubValue(Reminders.CONTENT_URI,reminderValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues attendeeValues=new ContentValues();
      attendeeValues.put(Attendees.ATTENDEE_NAME,subCursor.getString(COLUMN_ATTENDEE_NAME));
      attendeeValues.put(Attendees.ATTENDEE_EMAIL,subCursor.getString(COLUMN_ATTENDEE_EMAIL));
      attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP,subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
      attendeeValues.put(Attendees.ATTENDEE_TYPE,subCursor.getInt(COLUMN_ATTENDEE_TYPE));
      attendeeValues.put(Attendees.ATTENDEE_STATUS,subCursor.getInt(COLUMN_ATTENDEE_STATUS));
      entity.addSubValue(Attendees.CONTENT_URI,attendeeValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
 else {
    subCursor=mProvider.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,""String_Node_Str"" + eventId,null,null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues extendedValues=new ContentValues();
      extendedValues.put(ExtendedProperties.NAME,subCursor.getString(COLUMN_NAME));
      extendedValues.put(ExtendedProperties.VALUE,subCursor.getString(COLUMN_VALUE));
      entity.addSubValue(ExtendedProperties.CONTENT_URI,extendedValues);
    }
  }
  finally {
    subCursor.close();
  }
  cursor.moveToNext();
  return entity;
}","@Override public Entity getEntityAndIncrementCursor(Cursor cursor) throws RemoteException {
  final long eventId=cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
  ContentValues cv=new ContentValues();
  cv.put(Events._ID,eventId);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,CALENDAR_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HTML_URI);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,TITLE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DESCRIPTION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_LOCATION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,STATUS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,SELF_ATTENDEE_STATUS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,COMMENTS_URI);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTSTART);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,DTEND);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,DURATION);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EVENT_TIMEZONE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ALL_DAY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,VISIBILITY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,TRANSPARENCY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_ALARM);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,HAS_EXTENDED_PROPERTIES);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,RDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXRULE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,EXDATE);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORIGINAL_EVENT);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,ORIGINAL_INSTANCE_TIME);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,ORIGINAL_ALL_DAY);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,LAST_DATE);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,HAS_ATTENDEE_DATA);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_INVITE_OTHERS);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_MODIFY);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,GUESTS_CAN_SEE_GUESTS);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,ORGANIZER);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_ID);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_DATA);
  DatabaseUtils.cursorLongToContentValuesIfPresent(cursor,cv,_SYNC_DIRTY);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,_SYNC_VERSION);
  DatabaseUtils.cursorIntToContentValuesIfPresent(cursor,cv,DELETED);
  DatabaseUtils.cursorStringToContentValuesIfPresent(cursor,cv,Calendars.URL);
  Entity entity=new Entity(cv);
  Cursor subCursor;
  if (mResolver != null) {
    subCursor=mResolver.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(Reminders.CONTENT_URI,REMINDERS_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues reminderValues=new ContentValues();
      reminderValues.put(Reminders.MINUTES,subCursor.getInt(COLUMN_MINUTES));
      reminderValues.put(Reminders.METHOD,subCursor.getInt(COLUMN_METHOD));
      entity.addSubValue(Reminders.CONTENT_URI,reminderValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(Attendees.CONTENT_URI,ATTENDEES_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues attendeeValues=new ContentValues();
      attendeeValues.put(Attendees.ATTENDEE_NAME,subCursor.getString(COLUMN_ATTENDEE_NAME));
      attendeeValues.put(Attendees.ATTENDEE_EMAIL,subCursor.getString(COLUMN_ATTENDEE_EMAIL));
      attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP,subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
      attendeeValues.put(Attendees.ATTENDEE_TYPE,subCursor.getInt(COLUMN_ATTENDEE_TYPE));
      attendeeValues.put(Attendees.ATTENDEE_STATUS,subCursor.getInt(COLUMN_ATTENDEE_STATUS));
      entity.addSubValue(Attendees.CONTENT_URI,attendeeValues);
    }
  }
  finally {
    subCursor.close();
  }
  if (mResolver != null) {
    subCursor=mResolver.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
 else {
    subCursor=mProvider.query(ExtendedProperties.CONTENT_URI,EXTENDED_PROJECTION,WHERE_EVENT_ID,new String[]{Long.toString(eventId)},null);
  }
  try {
    while (subCursor.moveToNext()) {
      ContentValues extendedValues=new ContentValues();
      extendedValues.put(ExtendedProperties.NAME,subCursor.getString(COLUMN_NAME));
      extendedValues.put(ExtendedProperties.VALUE,subCursor.getString(COLUMN_VALUE));
      entity.addSubValue(ExtendedProperties.CONTENT_URI,extendedValues);
    }
  }
  finally {
    subCursor.close();
  }
  cursor.moveToNext();
  return entity;
}",0.9540166204986148
182354,"/** 
 * Finds the next alarm after (or equal to) the given time and returns the time of that alarm or -1 if no such alarm exists.
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1if no such alarm exists.
 */
public static final long findNextAlarmTime(ContentResolver cr,long millis){
  String selection=ALARM_TIME + ""String_Node_Str"" + millis;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,selection,null,ALARM_TIME + ""String_Node_Str"");
  long alarmTime=-1;
  try {
    if (cursor != null && cursor.moveToFirst()) {
      alarmTime=cursor.getLong(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return alarmTime;
}","/** 
 * Finds the next alarm after (or equal to) the given time and returns the time of that alarm or -1 if no such alarm exists.
 * @param cr the ContentResolver
 * @param millis the time in UTC milliseconds
 * @return the next alarm time greater than or equal to ""millis"", or -1if no such alarm exists.
 */
public static final long findNextAlarmTime(ContentResolver cr,long millis){
  String selection=ALARM_TIME + ""String_Node_Str"" + millis;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=query(cr,projection,WHERE_FINDNEXTALARMTIME,new String[]{Long.toString(millis)},SORT_ORDER_ALARMTIME_ASC);
  long alarmTime=-1;
  try {
    if (cursor != null && cursor.moveToFirst()) {
      alarmTime=cursor.getLong(0);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return alarmTime;
}",0.9426987060998152
182355,"public static void scheduleAlarm(Context context,AlarmManager manager,long alarmTime){
  if (DEBUG) {
    Time time=new Time();
    time.set(alarmTime);
    String schedTime=time.format(""String_Node_Str"");
    Log.d(TAG,""String_Node_Str"" + alarmTime + ""String_Node_Str""+ schedTime);
  }
  if (manager == null) {
    manager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  }
  Intent intent=new Intent(android.provider.Calendar.EVENT_REMINDER_ACTION);
  intent.putExtra(android.provider.Calendar.CalendarAlerts.ALARM_TIME,alarmTime);
  PendingIntent pi=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  manager.set(AlarmManager.RTC_WAKEUP,alarmTime,pi);
}","public static void scheduleAlarm(Context context,AlarmManager manager,long alarmTime){
  if (DEBUG) {
    Time time=new Time();
    time.set(alarmTime);
    String schedTime=time.format(""String_Node_Str"");
    Log.d(TAG,""String_Node_Str"" + alarmTime + ""String_Node_Str""+ schedTime);
  }
  if (manager == null) {
    manager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  }
  Intent intent=new Intent(EVENT_REMINDER_ACTION);
  intent.putExtra(ALARM_TIME,alarmTime);
  PendingIntent pi=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  manager.set(AlarmManager.RTC_WAKEUP,alarmTime,pi);
}",0.9499626587005228
182356,"/** 
 * Convenience method to delete all calendars that match the account.
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
public static int deleteCalendarsForAccount(ContentResolver cr,Account account){
  return Calendar.Calendars.delete(cr,Calendar.Calendars._SYNC_ACCOUNT + ""String_Node_Str"" + Calendar.Calendars._SYNC_ACCOUNT_TYPE+ ""String_Node_Str"",new String[]{account.name,account.type});
}","/** 
 * Convenience method to delete all calendars that match the account.
 * @param cr the ContentResolver
 * @param account the account whose rows should be deleted
 * @return the count of rows that were deleted
 */
public static int deleteCalendarsForAccount(ContentResolver cr,Account account){
  return Calendar.Calendars.delete(cr,WHERE_DELETE_FOR_ACCOUNT,new String[]{account.name,account.type});
}",0.8695652173913043
182357,"/** 
 * Searches the CalendarAlerts table for alarms that should have fired but have not and then reschedules them.  This method can be called at boot time to restore alarms that may have been lost due to a phone reboot.
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
public static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManager manager){
  long now=System.currentTimeMillis();
  long ancient=now - DateUtils.DAY_IN_MILLIS;
  String selection=CalendarAlerts.STATE + ""String_Node_Str"" + CalendarAlerts.SCHEDULED+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ now+ ""String_Node_Str""+ CalendarAlerts.ALARM_TIME+ ""String_Node_Str""+ ancient+ ""String_Node_Str""+ CalendarAlerts.END+ ""String_Node_Str""+ now;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=CalendarAlerts.query(cr,projection,selection,null,""String_Node_Str"");
  if (cursor == null) {
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + cursor.getCount());
  }
  try {
    long alarmTime=-1;
    while (cursor.moveToNext()) {
      long newAlarmTime=cursor.getLong(0);
      if (alarmTime != newAlarmTime) {
        if (DEBUG) {
          Log.w(TAG,""String_Node_Str"" + newAlarmTime);
        }
        scheduleAlarm(context,manager,newAlarmTime);
        alarmTime=newAlarmTime;
      }
    }
  }
  finally {
    cursor.close();
  }
}","/** 
 * Searches the CalendarAlerts table for alarms that should have fired but have not and then reschedules them.  This method can be called at boot time to restore alarms that may have been lost due to a phone reboot.
 * @param cr the ContentResolver
 * @param context the Context
 * @param manager the AlarmManager
 */
public static final void rescheduleMissedAlarms(ContentResolver cr,Context context,AlarmManager manager){
  long now=System.currentTimeMillis();
  long ancient=now - DateUtils.DAY_IN_MILLIS;
  String[] projection=new String[]{ALARM_TIME};
  Cursor cursor=CalendarAlerts.query(cr,projection,WHERE_RESCHEDULE_MISSED_ALARMS,new String[]{Long.toString(now),Long.toString(ancient),Long.toString(now)},SORT_ORDER_ALARMTIME_ASC);
  if (cursor == null) {
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + cursor.getCount());
  }
  try {
    long alarmTime=-1;
    while (cursor.moveToNext()) {
      long newAlarmTime=cursor.getLong(0);
      if (alarmTime != newAlarmTime) {
        if (DEBUG) {
          Log.w(TAG,""String_Node_Str"" + newAlarmTime);
        }
        scheduleAlarm(context,manager,newAlarmTime);
        alarmTime=newAlarmTime;
      }
    }
  }
  finally {
    cursor.close();
  }
}",0.7899285982713266
182358,"@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){
  final boolean isPassword=isPasswordInputType(mInputType);
  if (!isPassword) {
    CharSequence text=getText();
    if (TextUtils.isEmpty(text)) {
      text=getHint();
    }
    if (!TextUtils.isEmpty(text)) {
      if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
        text=text.subSequence(0,AccessibilityEvent.MAX_TEXT_LENGTH + 1);
      }
      event.getText().add(text);
    }
  }
 else {
    event.setPassword(isPassword);
  }
  return false;
}","@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){
  if (!isShown()) {
    return false;
  }
  final boolean isPassword=isPasswordInputType(mInputType);
  if (!isPassword) {
    CharSequence text=getText();
    if (TextUtils.isEmpty(text)) {
      text=getHint();
    }
    if (!TextUtils.isEmpty(text)) {
      if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
        text=text.subSequence(0,AccessibilityEvent.MAX_TEXT_LENGTH + 1);
      }
      event.getText().add(text);
    }
  }
 else {
    event.setPassword(isPassword);
  }
  return false;
}",0.9633507853403142
182359,"@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){
  final boolean isPassword=isPasswordInputType(mInputType);
  if (!isPassword) {
    CharSequence text=getText();
    if (TextUtils.isEmpty(text)) {
      text=getHint();
    }
    if (!TextUtils.isEmpty(text)) {
      if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
        text=text.subSequence(0,AccessibilityEvent.MAX_TEXT_LENGTH + 1);
      }
      event.getText().add(text);
    }
  }
 else {
    event.setPassword(isPassword);
  }
  return false;
}","@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){
  if (!isShown()) {
    return false;
  }
  final boolean isPassword=isPasswordInputType(mInputType);
  if (!isPassword) {
    CharSequence text=getText();
    if (TextUtils.isEmpty(text)) {
      text=getHint();
    }
    if (!TextUtils.isEmpty(text)) {
      if (text.length() > AccessibilityEvent.MAX_TEXT_LENGTH) {
        text=text.subSequence(0,AccessibilityEvent.MAX_TEXT_LENGTH + 1);
      }
      event.getText().add(text);
    }
  }
 else {
    event.setPassword(isPassword);
  }
  return false;
}",0.9633507853403142
182360,"/** 
 * Synthesizes the given text to a file using the specified parameters.
 * @param text The String of text that should be synthesized
 * @param params The list of parameters to be used. Can be null if no parameters are given. They are specified using a (key, value) pair, where the key can be {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename The string that gives the full output filename; it should be something like ""/sdcard/myappsounds/mysound.wav"".
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
public int synthesizeToFile(String text,HashMap<String,String> params,String filename){
synchronized (mStartLock) {
    int result=ERROR;
    if (!mStarted) {
      return result;
    }
    try {
      if ((params != null) && (!params.isEmpty())) {
        String extra=params.get(Engine.KEY_PARAM_UTTERANCE_ID);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=extra;
        }
        extra=params.get(Engine.KEY_PARAM_ENGINE);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=extra;
        }
      }
      if (mITts.synthesizeToFile(mPackageName,text,mCachedParams,filename)) {
        result=SUCCESS;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
 finally {
      resetCachedParams();
      return result;
    }
  }
}","/** 
 * Synthesizes the given text to a file using the specified parameters.
 * @param text The String of text that should be synthesized
 * @param params The list of parameters to be used. Can be null if no parameters are given. They are specified using a (key, value) pair, where the key can be {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename The string that gives the full output filename; it should be something like ""/sdcard/myappsounds/mysound.wav"".
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
public int synthesizeToFile(String text,HashMap<String,String> params,String filename){
synchronized (mStartLock) {
    int result=ERROR;
    if (!mStarted) {
      return result;
    }
    try {
      if ((params != null) && (!params.isEmpty())) {
        String extra=params.get(Engine.KEY_PARAM_UTTERANCE_ID);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=extra;
        }
        extra=params.get(Engine.KEY_PARAM_ENGINE);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=extra;
        }
      }
      result=mITts.synthesizeToFile(mPackageName,text,mCachedParams,filename) ? SUCCESS : ERROR;
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
 finally {
      resetCachedParams();
      return result;
    }
  }
}",0.9858136300417246
182361,"void start(int position,int boundPosition){
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + getChildCount() - 1;
  int viewTravelCount=0;
  if (position < firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - position + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (position > lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=position - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=position;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  post(this);
}","void start(int position,int boundPosition){
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + getChildCount() - 1;
  int viewTravelCount=0;
  if (position <= firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - position + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (position >= lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=position - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=position;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  post(this);
}",0.999251497005988
182362,"void start(int position,int boundPosition){
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + getChildCount() - 1;
  int viewTravelCount=0;
  if (position < firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - position + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (position > lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=position - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=position;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  post(this);
}","void start(int position,int boundPosition){
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + getChildCount() - 1;
  int viewTravelCount=0;
  if (position <= firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - position + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (position >= lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=position - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=position;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  post(this);
}",0.999251497005988
182363,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  hideSelector();
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    positionSelector(getChildAt(mSelectedPosition - mFirstPosition));
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}",0.9694220921726407
182364,"/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  hideSelector();
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}","/** 
 * Track a motion scroll
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motionbegan. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY,int incrementalDeltaY){
  final int childCount=getChildCount();
  if (childCount == 0) {
    return true;
  }
  final int firstTop=getChildAt(0).getTop();
  final int lastBottom=getChildAt(childCount - 1).getBottom();
  final Rect listPadding=mListPadding;
  final int spaceAbove=listPadding.top - firstTop;
  final int end=getHeight() - listPadding.bottom;
  final int spaceBelow=lastBottom - end;
  final int height=getHeight() - mPaddingBottom - mPaddingTop;
  if (deltaY < 0) {
    deltaY=Math.max(-(height - 1),deltaY);
  }
 else {
    deltaY=Math.min(height - 1,deltaY);
  }
  if (incrementalDeltaY < 0) {
    incrementalDeltaY=Math.max(-(height - 1),incrementalDeltaY);
  }
 else {
    incrementalDeltaY=Math.min(height - 1,incrementalDeltaY);
  }
  final int firstPosition=mFirstPosition;
  if (firstPosition == 0 && firstTop >= listPadding.top && deltaY > 0) {
    return true;
  }
  if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY < 0) {
    return true;
  }
  final boolean down=incrementalDeltaY < 0;
  final boolean inTouchMode=isInTouchMode();
  if (inTouchMode) {
    hideSelector();
  }
  final int headerViewsCount=getHeaderViewsCount();
  final int footerViewsStart=mItemCount - getFooterViewsCount();
  int start=0;
  int count=0;
  if (down) {
    final int top=listPadding.top - incrementalDeltaY;
    for (int i=0; i < childCount; i++) {
      final View child=getChildAt(i);
      if (child.getBottom() >= top) {
        break;
      }
 else {
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
 else {
    final int bottom=getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i=childCount - 1; i >= 0; i--) {
      final View child=getChildAt(i);
      if (child.getTop() <= bottom) {
        break;
      }
 else {
        start=i;
        count++;
        int position=firstPosition + i;
        if (position >= headerViewsCount && position < footerViewsStart) {
          mRecycler.addScrapView(child);
          if (ViewDebug.TRACE_RECYCLER) {
            ViewDebug.trace(child,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,firstPosition + i,-1);
          }
        }
      }
    }
  }
  mMotionViewNewTop=mMotionViewOriginalTop + deltaY;
  mBlockLayoutRequests=true;
  if (count > 0) {
    detachViewsFromParent(start,count);
  }
  offsetChildrenTopAndBottom(incrementalDeltaY);
  if (down) {
    mFirstPosition+=count;
  }
  invalidate();
  final int absIncrementalDeltaY=Math.abs(incrementalDeltaY);
  if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
    fillGap(down);
  }
  if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
    positionSelector(getChildAt(mSelectedPosition - mFirstPosition));
  }
  mBlockLayoutRequests=false;
  invokeOnItemScrollListener();
  awakenScrollBars();
  return false;
}",0.9694220921726407
182365,"/** 
 * Synthesizes the given text to a file using the specified parameters.
 * @param text The String of text that should be synthesized
 * @param params The list of parameters to be used. Can be null if no parameters are given. They are specified using a (key, value) pair, where the key can be {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename The string that gives the full output filename; it should be something like ""/sdcard/myappsounds/mysound.wav"".
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
public int synthesizeToFile(String text,HashMap<String,String> params,String filename){
synchronized (mStartLock) {
    int result=ERROR;
    if (!mStarted) {
      return result;
    }
    try {
      if ((params != null) && (!params.isEmpty())) {
        String extra=params.get(Engine.KEY_PARAM_UTTERANCE_ID);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=extra;
        }
        extra=params.get(Engine.KEY_PARAM_ENGINE);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=extra;
        }
      }
      if (mITts.synthesizeToFile(mPackageName,text,mCachedParams,filename)) {
        result=SUCCESS;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
 finally {
      resetCachedParams();
      return result;
    }
  }
}","/** 
 * Synthesizes the given text to a file using the specified parameters.
 * @param text The String of text that should be synthesized
 * @param params The list of parameters to be used. Can be null if no parameters are given. They are specified using a (key, value) pair, where the key can be {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename The string that gives the full output filename; it should be something like ""/sdcard/myappsounds/mysound.wav"".
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
public int synthesizeToFile(String text,HashMap<String,String> params,String filename){
synchronized (mStartLock) {
    int result=ERROR;
    if (!mStarted) {
      return result;
    }
    try {
      if ((params != null) && (!params.isEmpty())) {
        String extra=params.get(Engine.KEY_PARAM_UTTERANCE_ID);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=extra;
        }
        extra=params.get(Engine.KEY_PARAM_ENGINE);
        if (extra != null) {
          mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=extra;
        }
      }
      result=mITts.synthesizeToFile(mPackageName,text,mCachedParams,filename) ? SUCCESS : ERROR;
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
 finally {
      resetCachedParams();
      return result;
    }
  }
}",0.9858136300417246
182366,"@Override protected boolean setFrame(int l,int t,int r,int b){
  boolean result=super.setFrame(l,t,r,b);
  if (mPopup.isShowing()) {
    mPopup.update(this,r - l,-1);
  }
  return result;
}","@Override protected boolean setFrame(final int l,int t,final int r,int b){
  boolean result=super.setFrame(l,t,r,b);
  if (mPopup.isShowing()) {
    showDropDown();
  }
  return result;
}",0.8776595744680851
182367,"/** 
 * <p>Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view.</p> <p>If the view later scrolls to move <code>anchor</code> to a different location, the popup will be moved correspondingly.</p>
 * @param anchor the view on which to pin the popup window
 * @see #dismiss()
 */
public void showAsDropDown(View anchor,int xoff,int yoff){
  if (isShowing() || mContentView == null) {
    return;
  }
  registerForScrollChanged(anchor,xoff,yoff);
  mIsShowing=true;
  mIsDropdown=true;
  WindowManager.LayoutParams p=createPopupLayout(anchor.getWindowToken());
  preparePopup(p);
  mAboveAnchor=findDropDownPosition(anchor,p,xoff,yoff);
  if (mBackground != null) {
    if (mAboveAnchorBackgroundDrawable != null) {
      if (mAboveAnchor) {
        mPopupView.setBackgroundDrawable(mAboveAnchorBackgroundDrawable);
      }
 else {
        mPopupView.setBackgroundDrawable(mBelowAnchorBackgroundDrawable);
      }
    }
 else {
      mPopupView.refreshDrawableState();
    }
  }
  if (mHeightMode < 0)   p.height=mLastHeight=mHeightMode;
  if (mWidthMode < 0)   p.width=mLastWidth=mWidthMode;
  p.windowAnimations=computeAnimationResource();
  invokePopup(p);
}","/** 
 * <p>Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view.</p> <p>If the view later scrolls to move <code>anchor</code> to a different location, the popup will be moved correspondingly.</p>
 * @param anchor the view on which to pin the popup window
 * @see #dismiss()
 */
public void showAsDropDown(View anchor,int xoff,int yoff){
  if (isShowing() || mContentView == null) {
    return;
  }
  registerForScrollChanged(anchor,xoff,yoff);
  mIsShowing=true;
  mIsDropdown=true;
  WindowManager.LayoutParams p=createPopupLayout(anchor.getWindowToken());
  preparePopup(p);
  updateAboveAnchor(findDropDownPosition(anchor,p,xoff,yoff));
  if (mHeightMode < 0)   p.height=mLastHeight=mHeightMode;
  if (mWidthMode < 0)   p.width=mLastWidth=mWidthMode;
  p.windowAnimations=computeAnimationResource();
  invokePopup(p);
}",0.7455223880597015
182368,"private void update(View anchor,boolean updateLocation,int xoff,int yoff,boolean updateDimension,int width,int height){
  if (!isShowing() || mContentView == null) {
    return;
  }
  WeakReference<View> oldAnchor=mAnchor;
  if (oldAnchor == null || oldAnchor.get() != anchor || (updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff))) {
    registerForScrollChanged(anchor,xoff,yoff);
  }
  WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
  if (updateDimension) {
    if (width == -1) {
      width=mPopupWidth;
    }
 else {
      mPopupWidth=width;
    }
    if (height == -1) {
      height=mPopupHeight;
    }
 else {
      mPopupHeight=height;
    }
  }
  if (updateLocation) {
    mAboveAnchor=findDropDownPosition(anchor,p,xoff,yoff);
  }
 else {
    mAboveAnchor=findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff);
  }
  update(p.x,p.y,width,height);
}","private void update(View anchor,boolean updateLocation,int xoff,int yoff,boolean updateDimension,int width,int height){
  if (!isShowing() || mContentView == null) {
    return;
  }
  WeakReference<View> oldAnchor=mAnchor;
  if (oldAnchor == null || oldAnchor.get() != anchor || (updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff))) {
    registerForScrollChanged(anchor,xoff,yoff);
  }
  WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
  if (updateDimension) {
    if (width == -1) {
      width=mPopupWidth;
    }
 else {
      mPopupWidth=width;
    }
    if (height == -1) {
      height=mPopupHeight;
    }
 else {
      mPopupHeight=height;
    }
  }
  int x=p.x;
  int y=p.y;
  if (updateLocation) {
    updateAboveAnchor(findDropDownPosition(anchor,p,xoff,yoff));
  }
 else {
    updateAboveAnchor(findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff));
  }
  update(p.x,p.y,width,height,x != p.x || y != p.y);
}",0.7628647214854112
182369,"public void onScrollChanged(){
  View anchor=mAnchor.get();
  if (anchor != null && mPopupView != null) {
    WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
    mAboveAnchor=findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff);
    update(p.x,p.y,-1,-1,true);
  }
}","public void onScrollChanged(){
  View anchor=mAnchor.get();
  if (anchor != null && mPopupView != null) {
    WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
    updateAboveAnchor(findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff));
    update(p.x,p.y,-1,-1,true);
  }
}",0.9838709677419356
182370,"/** 
 * <p>Positions the popup window on screen. When the popup window is too tall to fit under the anchor, a parent scroll view is seeked and scrolled up to reclaim space. If scrolling is not possible or not enough, the popup window gets moved on top of the anchor.</p> <p>The height must have been set on the layout parameters prior to calling this method.</p>
 * @param anchor the view on which the popup window must be anchored
 * @param p the layout parameters used to display the drop down
 * @return true if the popup is translated upwards to fit on screen
 */
private boolean findDropDownPosition(View anchor,WindowManager.LayoutParams p,int xoff,int yoff){
  anchor.getLocationInWindow(mDrawingLocation);
  p.x=mDrawingLocation[0] + xoff;
  p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
  boolean onTop=false;
  p.gravity=Gravity.LEFT | Gravity.TOP;
  anchor.getLocationOnScreen(mScreenLocation);
  final Rect displayFrame=new Rect();
  anchor.getWindowVisibleDisplayFrame(displayFrame);
  final View root=anchor.getRootView();
  if (p.y + mPopupHeight > displayFrame.bottom || p.x + mPopupWidth - root.getWidth() > 0) {
    int scrollX=anchor.getScrollX();
    int scrollY=anchor.getScrollY();
    Rect r=new Rect(scrollX,scrollY,scrollX + mPopupWidth,scrollY + mPopupHeight + anchor.getMeasuredHeight());
    anchor.requestRectangleOnScreen(r,true);
    anchor.getLocationInWindow(mDrawingLocation);
    p.x=mDrawingLocation[0] + xoff;
    p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
    anchor.getLocationOnScreen(mScreenLocation);
    onTop=(displayFrame.bottom - mScreenLocation[1] - anchor.getMeasuredHeight()- yoff) < (mScreenLocation[1] - yoff - displayFrame.top);
    if (onTop) {
      p.gravity=Gravity.LEFT | Gravity.BOTTOM;
      p.y=root.getHeight() - mDrawingLocation[1] + yoff;
    }
 else {
      p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
    }
  }
  p.gravity|=Gravity.DISPLAY_CLIP_VERTICAL;
  return onTop;
}","/** 
 * <p>Positions the popup window on screen. When the popup window is too tall to fit under the anchor, a parent scroll view is seeked and scrolled up to reclaim space. If scrolling is not possible or not enough, the popup window gets moved on top of the anchor.</p> <p>The height must have been set on the layout parameters prior to calling this method.</p>
 * @param anchor the view on which the popup window must be anchored
 * @param p the layout parameters used to display the drop down
 * @return true if the popup is translated upwards to fit on screen
 */
private boolean findDropDownPosition(View anchor,WindowManager.LayoutParams p,int xoff,int yoff){
  anchor.getLocationInWindow(mDrawingLocation);
  p.x=mDrawingLocation[0] + xoff;
  p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
  boolean onTop=false;
  p.gravity=Gravity.LEFT | Gravity.TOP;
  anchor.getLocationOnScreen(mScreenLocation);
  final Rect displayFrame=new Rect();
  anchor.getWindowVisibleDisplayFrame(displayFrame);
  final View root=anchor.getRootView();
  if (p.y + mPopupHeight > displayFrame.bottom || p.x + mPopupWidth - root.getWidth() > 0) {
    int scrollX=anchor.getScrollX();
    int scrollY=anchor.getScrollY();
    Rect r=new Rect(scrollX,scrollY,scrollX + mPopupWidth + xoff,scrollY + mPopupHeight + anchor.getHeight()+ yoff);
    anchor.requestRectangleOnScreen(r,true);
    anchor.getLocationInWindow(mDrawingLocation);
    p.x=mDrawingLocation[0] + xoff;
    p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
    anchor.getLocationOnScreen(mScreenLocation);
    onTop=(displayFrame.bottom - mScreenLocation[1] - anchor.getHeight()- yoff) < (mScreenLocation[1] - yoff - displayFrame.top);
    if (onTop) {
      p.gravity=Gravity.LEFT | Gravity.BOTTOM;
      p.y=root.getHeight() - mDrawingLocation[1] + yoff;
    }
 else {
      p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
    }
  }
  p.gravity|=Gravity.DISPLAY_CLIP_VERTICAL;
  return onTop;
}",0.9865720800608055
182371,"@Override protected boolean setFrame(int l,int t,int r,int b){
  boolean result=super.setFrame(l,t,r,b);
  if (mPopup.isShowing()) {
    mPopup.update(this,r - l,-1);
  }
  return result;
}","@Override protected boolean setFrame(final int l,int t,final int r,int b){
  boolean result=super.setFrame(l,t,r,b);
  if (mPopup.isShowing()) {
    showDropDown();
  }
  return result;
}",0.8776595744680851
182372,"/** 
 * <p>Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view.</p> <p>If the view later scrolls to move <code>anchor</code> to a different location, the popup will be moved correspondingly.</p>
 * @param anchor the view on which to pin the popup window
 * @see #dismiss()
 */
public void showAsDropDown(View anchor,int xoff,int yoff){
  if (isShowing() || mContentView == null) {
    return;
  }
  registerForScrollChanged(anchor,xoff,yoff);
  mIsShowing=true;
  mIsDropdown=true;
  WindowManager.LayoutParams p=createPopupLayout(anchor.getWindowToken());
  preparePopup(p);
  mAboveAnchor=findDropDownPosition(anchor,p,xoff,yoff);
  if (mBackground != null) {
    if (mAboveAnchorBackgroundDrawable != null) {
      if (mAboveAnchor) {
        mPopupView.setBackgroundDrawable(mAboveAnchorBackgroundDrawable);
      }
 else {
        mPopupView.setBackgroundDrawable(mBelowAnchorBackgroundDrawable);
      }
    }
 else {
      mPopupView.refreshDrawableState();
    }
  }
  if (mHeightMode < 0)   p.height=mLastHeight=mHeightMode;
  if (mWidthMode < 0)   p.width=mLastWidth=mWidthMode;
  p.windowAnimations=computeAnimationResource();
  invokePopup(p);
}","/** 
 * <p>Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view.</p> <p>If the view later scrolls to move <code>anchor</code> to a different location, the popup will be moved correspondingly.</p>
 * @param anchor the view on which to pin the popup window
 * @see #dismiss()
 */
public void showAsDropDown(View anchor,int xoff,int yoff){
  if (isShowing() || mContentView == null) {
    return;
  }
  registerForScrollChanged(anchor,xoff,yoff);
  mIsShowing=true;
  mIsDropdown=true;
  WindowManager.LayoutParams p=createPopupLayout(anchor.getWindowToken());
  preparePopup(p);
  updateAboveAnchor(findDropDownPosition(anchor,p,xoff,yoff));
  if (mHeightMode < 0)   p.height=mLastHeight=mHeightMode;
  if (mWidthMode < 0)   p.width=mLastWidth=mWidthMode;
  p.windowAnimations=computeAnimationResource();
  invokePopup(p);
}",0.7455223880597015
182373,"private void update(View anchor,boolean updateLocation,int xoff,int yoff,boolean updateDimension,int width,int height){
  if (!isShowing() || mContentView == null) {
    return;
  }
  WeakReference<View> oldAnchor=mAnchor;
  if (oldAnchor == null || oldAnchor.get() != anchor || (updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff))) {
    registerForScrollChanged(anchor,xoff,yoff);
  }
  WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
  if (updateDimension) {
    if (width == -1) {
      width=mPopupWidth;
    }
 else {
      mPopupWidth=width;
    }
    if (height == -1) {
      height=mPopupHeight;
    }
 else {
      mPopupHeight=height;
    }
  }
  if (updateLocation) {
    mAboveAnchor=findDropDownPosition(anchor,p,xoff,yoff);
  }
 else {
    mAboveAnchor=findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff);
  }
  update(p.x,p.y,width,height);
}","private void update(View anchor,boolean updateLocation,int xoff,int yoff,boolean updateDimension,int width,int height){
  if (!isShowing() || mContentView == null) {
    return;
  }
  WeakReference<View> oldAnchor=mAnchor;
  if (oldAnchor == null || oldAnchor.get() != anchor || (updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff))) {
    registerForScrollChanged(anchor,xoff,yoff);
  }
  WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
  if (updateDimension) {
    if (width == -1) {
      width=mPopupWidth;
    }
 else {
      mPopupWidth=width;
    }
    if (height == -1) {
      height=mPopupHeight;
    }
 else {
      mPopupHeight=height;
    }
  }
  int x=p.x;
  int y=p.y;
  if (updateLocation) {
    updateAboveAnchor(findDropDownPosition(anchor,p,xoff,yoff));
  }
 else {
    updateAboveAnchor(findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff));
  }
  update(p.x,p.y,width,height,x != p.x || y != p.y);
}",0.7628647214854112
182374,"public void onScrollChanged(){
  View anchor=mAnchor.get();
  if (anchor != null && mPopupView != null) {
    WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
    mAboveAnchor=findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff);
    update(p.x,p.y,-1,-1,true);
  }
}","public void onScrollChanged(){
  View anchor=mAnchor.get();
  if (anchor != null && mPopupView != null) {
    WindowManager.LayoutParams p=(WindowManager.LayoutParams)mPopupView.getLayoutParams();
    updateAboveAnchor(findDropDownPosition(anchor,p,mAnchorXoff,mAnchorYoff));
    update(p.x,p.y,-1,-1,true);
  }
}",0.9838709677419356
182375,"/** 
 * <p>Positions the popup window on screen. When the popup window is too tall to fit under the anchor, a parent scroll view is seeked and scrolled up to reclaim space. If scrolling is not possible or not enough, the popup window gets moved on top of the anchor.</p> <p>The height must have been set on the layout parameters prior to calling this method.</p>
 * @param anchor the view on which the popup window must be anchored
 * @param p the layout parameters used to display the drop down
 * @return true if the popup is translated upwards to fit on screen
 */
private boolean findDropDownPosition(View anchor,WindowManager.LayoutParams p,int xoff,int yoff){
  anchor.getLocationInWindow(mDrawingLocation);
  p.x=mDrawingLocation[0] + xoff;
  p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
  boolean onTop=false;
  p.gravity=Gravity.LEFT | Gravity.TOP;
  anchor.getLocationOnScreen(mScreenLocation);
  final Rect displayFrame=new Rect();
  anchor.getWindowVisibleDisplayFrame(displayFrame);
  final View root=anchor.getRootView();
  if (p.y + mPopupHeight > displayFrame.bottom || p.x + mPopupWidth - root.getWidth() > 0) {
    int scrollX=anchor.getScrollX();
    int scrollY=anchor.getScrollY();
    Rect r=new Rect(scrollX,scrollY,scrollX + mPopupWidth,scrollY + mPopupHeight + anchor.getMeasuredHeight());
    anchor.requestRectangleOnScreen(r,true);
    anchor.getLocationInWindow(mDrawingLocation);
    p.x=mDrawingLocation[0] + xoff;
    p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
    anchor.getLocationOnScreen(mScreenLocation);
    onTop=(displayFrame.bottom - mScreenLocation[1] - anchor.getMeasuredHeight()- yoff) < (mScreenLocation[1] - yoff - displayFrame.top);
    if (onTop) {
      p.gravity=Gravity.LEFT | Gravity.BOTTOM;
      p.y=root.getHeight() - mDrawingLocation[1] + yoff;
    }
 else {
      p.y=mDrawingLocation[1] + anchor.getMeasuredHeight() + yoff;
    }
  }
  p.gravity|=Gravity.DISPLAY_CLIP_VERTICAL;
  return onTop;
}","/** 
 * <p>Positions the popup window on screen. When the popup window is too tall to fit under the anchor, a parent scroll view is seeked and scrolled up to reclaim space. If scrolling is not possible or not enough, the popup window gets moved on top of the anchor.</p> <p>The height must have been set on the layout parameters prior to calling this method.</p>
 * @param anchor the view on which the popup window must be anchored
 * @param p the layout parameters used to display the drop down
 * @return true if the popup is translated upwards to fit on screen
 */
private boolean findDropDownPosition(View anchor,WindowManager.LayoutParams p,int xoff,int yoff){
  anchor.getLocationInWindow(mDrawingLocation);
  p.x=mDrawingLocation[0] + xoff;
  p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
  boolean onTop=false;
  p.gravity=Gravity.LEFT | Gravity.TOP;
  anchor.getLocationOnScreen(mScreenLocation);
  final Rect displayFrame=new Rect();
  anchor.getWindowVisibleDisplayFrame(displayFrame);
  final View root=anchor.getRootView();
  if (p.y + mPopupHeight > displayFrame.bottom || p.x + mPopupWidth - root.getWidth() > 0) {
    int scrollX=anchor.getScrollX();
    int scrollY=anchor.getScrollY();
    Rect r=new Rect(scrollX,scrollY,scrollX + mPopupWidth + xoff,scrollY + mPopupHeight + anchor.getHeight()+ yoff);
    anchor.requestRectangleOnScreen(r,true);
    anchor.getLocationInWindow(mDrawingLocation);
    p.x=mDrawingLocation[0] + xoff;
    p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
    anchor.getLocationOnScreen(mScreenLocation);
    onTop=(displayFrame.bottom - mScreenLocation[1] - anchor.getHeight()- yoff) < (mScreenLocation[1] - yoff - displayFrame.top);
    if (onTop) {
      p.gravity=Gravity.LEFT | Gravity.BOTTOM;
      p.y=root.getHeight() - mDrawingLocation[1] + yoff;
    }
 else {
      p.y=mDrawingLocation[1] + anchor.getHeight() + yoff;
    }
  }
  p.gravity|=Gravity.DISPLAY_CLIP_VERTICAL;
  return onTop;
}",0.9865720800608055
182376,"public AuthenticatorDescription parseServiceAttributes(String packageName,AttributeSet attrs){
  TypedArray sa=mContext.getResources().obtainAttributes(attrs,com.android.internal.R.styleable.AccountAuthenticator);
  try {
    final String accountType=sa.getString(com.android.internal.R.styleable.AccountAuthenticator_accountType);
    final int labelId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_label,0);
    final int iconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_icon,0);
    final int smallIconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_smallIcon,0);
    final int prefId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_accountPreferences,0);
    if (TextUtils.isEmpty(accountType)) {
      return null;
    }
    return new AuthenticatorDescription(accountType,packageName,labelId,iconId,smallIconId,prefId);
  }
  finally {
    sa.recycle();
  }
}","public AuthenticatorDescription parseServiceAttributes(Resources res,String packageName,AttributeSet attrs){
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AccountAuthenticator);
  try {
    final String accountType=sa.getString(com.android.internal.R.styleable.AccountAuthenticator_accountType);
    final int labelId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_label,0);
    final int iconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_icon,0);
    final int smallIconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_smallIcon,0);
    final int prefId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_accountPreferences,0);
    if (TextUtils.isEmpty(accountType)) {
      return null;
    }
    return new AuthenticatorDescription(accountType,packageName,labelId,iconId,smallIconId,prefId);
  }
  finally {
    sa.recycle();
  }
}",0.1419689119170984
182377,"public SyncAdapterType parseServiceAttributes(String packageName,AttributeSet attrs){
  TypedArray sa=mContext.getResources().obtainAttributes(attrs,com.android.internal.R.styleable.SyncAdapter);
  try {
    final String authority=sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
    final String accountType=sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
    if (authority == null || accountType == null) {
      return null;
    }
    final boolean userVisible=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible,true);
    final boolean supportsUploading=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading,true);
    return new SyncAdapterType(authority,accountType,userVisible,supportsUploading);
  }
  finally {
    sa.recycle();
  }
}","public SyncAdapterType parseServiceAttributes(Resources res,String packageName,AttributeSet attrs){
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.SyncAdapter);
  try {
    final String authority=sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
    final String accountType=sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
    if (authority == null || accountType == null) {
      return null;
    }
    final boolean userVisible=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible,true);
    final boolean supportsUploading=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading,true);
    return new SyncAdapterType(authority,accountType,userVisible,supportsUploading);
  }
  finally {
    sa.recycle();
  }
}",0.9760479041916168
182378,"public abstract V parseServiceAttributes(String packageName,AttributeSet attrs);","public abstract V parseServiceAttributes(Resources res,String packageName,AttributeSet attrs);",0.9195402298850576
182379,"private ServiceInfo<V> parseServiceInfo(ResolveInfo service) throws XmlPullParserException, IOException {
  android.content.pm.ServiceInfo si=service.serviceInfo;
  ComponentName componentName=new ComponentName(si.packageName,si.name);
  PackageManager pm=mContext.getPackageManager();
  XmlResourceParser parser=null;
  try {
    parser=si.loadXmlMetaData(pm,mMetaDataName);
    if (parser == null) {
      throw new XmlPullParserException(""String_Node_Str"" + mMetaDataName + ""String_Node_Str"");
    }
    AttributeSet attrs=Xml.asAttributeSet(parser);
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
    }
    String nodeName=parser.getName();
    if (!mAttributesName.equals(nodeName)) {
      throw new XmlPullParserException(""String_Node_Str"" + mAttributesName + ""String_Node_Str"");
    }
    V v=parseServiceAttributes(si.packageName,attrs);
    if (v == null) {
      return null;
    }
    final android.content.pm.ServiceInfo serviceInfo=service.serviceInfo;
    final ApplicationInfo applicationInfo=serviceInfo.applicationInfo;
    final int uid=applicationInfo.uid;
    return new ServiceInfo<V>(v,componentName,uid);
  }
  finally {
    if (parser != null)     parser.close();
  }
}","private ServiceInfo<V> parseServiceInfo(ResolveInfo service) throws XmlPullParserException, IOException {
  android.content.pm.ServiceInfo si=service.serviceInfo;
  ComponentName componentName=new ComponentName(si.packageName,si.name);
  PackageManager pm=mContext.getPackageManager();
  XmlResourceParser parser=null;
  try {
    parser=si.loadXmlMetaData(pm,mMetaDataName);
    if (parser == null) {
      throw new XmlPullParserException(""String_Node_Str"" + mMetaDataName + ""String_Node_Str"");
    }
    AttributeSet attrs=Xml.asAttributeSet(parser);
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
    }
    String nodeName=parser.getName();
    if (!mAttributesName.equals(nodeName)) {
      throw new XmlPullParserException(""String_Node_Str"" + mAttributesName + ""String_Node_Str"");
    }
    V v=parseServiceAttributes(pm.getResourcesForApplication(si.applicationInfo),si.packageName,attrs);
    if (v == null) {
      return null;
    }
    final android.content.pm.ServiceInfo serviceInfo=service.serviceInfo;
    final ApplicationInfo applicationInfo=serviceInfo.applicationInfo;
    final int uid=applicationInfo.uid;
    return new ServiceInfo<V>(v,componentName,uid);
  }
 catch (  NameNotFoundException e) {
    throw new XmlPullParserException(""String_Node_Str"" + si.packageName);
  }
 finally {
    if (parser != null)     parser.close();
  }
}",0.9389426656738644
182380,"public AuthenticatorDescription parseServiceAttributes(String packageName,AttributeSet attrs){
  TypedArray sa=mContext.getResources().obtainAttributes(attrs,com.android.internal.R.styleable.AccountAuthenticator);
  try {
    final String accountType=sa.getString(com.android.internal.R.styleable.AccountAuthenticator_accountType);
    final int labelId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_label,0);
    final int iconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_icon,0);
    final int smallIconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_smallIcon,0);
    final int prefId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_accountPreferences,0);
    if (TextUtils.isEmpty(accountType)) {
      return null;
    }
    return new AuthenticatorDescription(accountType,packageName,labelId,iconId,smallIconId,prefId);
  }
  finally {
    sa.recycle();
  }
}","public AuthenticatorDescription parseServiceAttributes(Resources res,String packageName,AttributeSet attrs){
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AccountAuthenticator);
  try {
    final String accountType=sa.getString(com.android.internal.R.styleable.AccountAuthenticator_accountType);
    final int labelId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_label,0);
    final int iconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_icon,0);
    final int smallIconId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_smallIcon,0);
    final int prefId=sa.getResourceId(com.android.internal.R.styleable.AccountAuthenticator_accountPreferences,0);
    if (TextUtils.isEmpty(accountType)) {
      return null;
    }
    return new AuthenticatorDescription(accountType,packageName,labelId,iconId,smallIconId,prefId);
  }
  finally {
    sa.recycle();
  }
}",0.1419689119170984
182381,"public SyncAdapterType parseServiceAttributes(String packageName,AttributeSet attrs){
  TypedArray sa=mContext.getResources().obtainAttributes(attrs,com.android.internal.R.styleable.SyncAdapter);
  try {
    final String authority=sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
    final String accountType=sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
    if (authority == null || accountType == null) {
      return null;
    }
    final boolean userVisible=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible,true);
    final boolean supportsUploading=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading,true);
    return new SyncAdapterType(authority,accountType,userVisible,supportsUploading);
  }
  finally {
    sa.recycle();
  }
}","public SyncAdapterType parseServiceAttributes(Resources res,String packageName,AttributeSet attrs){
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.SyncAdapter);
  try {
    final String authority=sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
    final String accountType=sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
    if (authority == null || accountType == null) {
      return null;
    }
    final boolean userVisible=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible,true);
    final boolean supportsUploading=sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading,true);
    return new SyncAdapterType(authority,accountType,userVisible,supportsUploading);
  }
  finally {
    sa.recycle();
  }
}",0.9760479041916168
182382,"public abstract V parseServiceAttributes(String packageName,AttributeSet attrs);","public abstract V parseServiceAttributes(Resources res,String packageName,AttributeSet attrs);",0.9195402298850576
182383,"private ServiceInfo<V> parseServiceInfo(ResolveInfo service) throws XmlPullParserException, IOException {
  android.content.pm.ServiceInfo si=service.serviceInfo;
  ComponentName componentName=new ComponentName(si.packageName,si.name);
  PackageManager pm=mContext.getPackageManager();
  XmlResourceParser parser=null;
  try {
    parser=si.loadXmlMetaData(pm,mMetaDataName);
    if (parser == null) {
      throw new XmlPullParserException(""String_Node_Str"" + mMetaDataName + ""String_Node_Str"");
    }
    AttributeSet attrs=Xml.asAttributeSet(parser);
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
    }
    String nodeName=parser.getName();
    if (!mAttributesName.equals(nodeName)) {
      throw new XmlPullParserException(""String_Node_Str"" + mAttributesName + ""String_Node_Str"");
    }
    V v=parseServiceAttributes(si.packageName,attrs);
    if (v == null) {
      return null;
    }
    final android.content.pm.ServiceInfo serviceInfo=service.serviceInfo;
    final ApplicationInfo applicationInfo=serviceInfo.applicationInfo;
    final int uid=applicationInfo.uid;
    return new ServiceInfo<V>(v,componentName,uid);
  }
  finally {
    if (parser != null)     parser.close();
  }
}","private ServiceInfo<V> parseServiceInfo(ResolveInfo service) throws XmlPullParserException, IOException {
  android.content.pm.ServiceInfo si=service.serviceInfo;
  ComponentName componentName=new ComponentName(si.packageName,si.name);
  PackageManager pm=mContext.getPackageManager();
  XmlResourceParser parser=null;
  try {
    parser=si.loadXmlMetaData(pm,mMetaDataName);
    if (parser == null) {
      throw new XmlPullParserException(""String_Node_Str"" + mMetaDataName + ""String_Node_Str"");
    }
    AttributeSet attrs=Xml.asAttributeSet(parser);
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
    }
    String nodeName=parser.getName();
    if (!mAttributesName.equals(nodeName)) {
      throw new XmlPullParserException(""String_Node_Str"" + mAttributesName + ""String_Node_Str"");
    }
    V v=parseServiceAttributes(pm.getResourcesForApplication(si.applicationInfo),si.packageName,attrs);
    if (v == null) {
      return null;
    }
    final android.content.pm.ServiceInfo serviceInfo=service.serviceInfo;
    final ApplicationInfo applicationInfo=serviceInfo.applicationInfo;
    final int uid=applicationInfo.uid;
    return new ServiceInfo<V>(v,componentName,uid);
  }
 catch (  NameNotFoundException e) {
    throw new XmlPullParserException(""String_Node_Str"" + si.packageName);
  }
 finally {
    if (parser != null)     parser.close();
  }
}",0.9389426656738644
182384,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportFailedUnlockAttempt(){
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.958976833976834
182385,"public void reportFailedUnlockAttempt(){
  mLockPatternUtils.reportFailedPasswordAttempt();
}","public void reportFailedUnlockAttempt(){
  mUpdateMonitor.reportFailedAttempt();
  final int failedAttempts=mUpdateMonitor.getFailedAttempts();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
  if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    showAlmostAtAccountLoginDialog();
  }
 else   if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
    mLockPatternUtils.setPermanentlyLocked(true);
    updateScreen(mMode);
  }
 else   if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
    showTimeoutDialog();
  }
  mLockPatternUtils.reportFailedPasswordAttempt();
}",0.1128668171557562
182386,"/** 
 * Given the current state of things, what should the unlock screen be?
 */
private UnlockMode getUnlockMode(){
  final IccCard.State simState=mUpdateMonitor.getSimState();
  UnlockMode currentMode;
  if (simState == IccCard.State.PIN_REQUIRED || simState == IccCard.State.PUK_REQUIRED) {
    currentMode=UnlockMode.SimPin;
  }
 else {
    final int mode=mLockPatternUtils.getPasswordMode();
switch (mode) {
case LockPatternUtils.MODE_PIN:
case LockPatternUtils.MODE_PASSWORD:
      currentMode=UnlockMode.Password;
    break;
case LockPatternUtils.MODE_PATTERN:
  if (mForgotPattern && mLockPatternUtils.isPermanentlyLocked()) {
    currentMode=UnlockMode.Account;
  }
 else {
    currentMode=UnlockMode.Pattern;
  }
break;
default :
throw new IllegalStateException(""String_Node_Str"" + mode);
}
}
return currentMode;
}","/** 
 * Given the current state of things, what should the unlock screen be?
 */
private UnlockMode getUnlockMode(){
  final IccCard.State simState=mUpdateMonitor.getSimState();
  UnlockMode currentMode;
  if (simState == IccCard.State.PIN_REQUIRED || simState == IccCard.State.PUK_REQUIRED) {
    currentMode=UnlockMode.SimPin;
  }
 else {
    final int mode=mLockPatternUtils.getPasswordMode();
switch (mode) {
case LockPatternUtils.MODE_PIN:
case LockPatternUtils.MODE_PASSWORD:
      currentMode=UnlockMode.Password;
    break;
case LockPatternUtils.MODE_PATTERN:
  if (mForgotPattern || mLockPatternUtils.isPermanentlyLocked()) {
    currentMode=UnlockMode.Account;
  }
 else {
    currentMode=UnlockMode.Pattern;
  }
break;
default :
throw new IllegalStateException(""String_Node_Str"" + mode);
}
}
return currentMode;
}",0.9975728155339806
182387,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mInstructions=""String_Node_Str"";
    updateStatusLines();
    mCallback.keyguardDone(true);
    mCallback.reportSuccessfulUnlockAttempt();
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.pokeWakelock(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mInstructions=getContext().getString(R.string.lockscreen_pattern_wrong);
      updateStatusLines();
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
    if (pattern.size() > MIN_PATTERN_BEFORE_REPORT) {
      mCallback.reportFailedUnlockAttempt();
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mInstructions=""String_Node_Str"";
    updateStatusLines();
    mCallback.keyguardDone(true);
    mCallback.reportSuccessfulUnlockAttempt();
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.pokeWakelock(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportFailedUnlockAttempt();
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mInstructions=getContext().getString(R.string.lockscreen_pattern_wrong);
      updateStatusLines();
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.9378624689312344
182388,"private void setSystemVolume(VolumeStreamState streamState){
  setStreamVolumeIndex(streamState.mStreamType,streamState.mIndex);
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (streamType != streamState.mStreamType && STREAM_VOLUME_ALIAS[streamType] == streamState.mStreamType) {
      setStreamVolumeIndex(streamType,mStreamStates[streamType].mIndex);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamState.mStreamType,SENDMSG_REPLACE,0,0,streamState,PERSIST_DELAY);
}","private void setSystemVolume(VolumeStreamState streamState){
  setStreamVolumeIndex(streamState.mStreamType,streamState.mIndex);
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (streamType != streamState.mStreamType && STREAM_VOLUME_ALIAS[streamType] == streamState.mStreamType) {
      setStreamVolumeIndex(streamType,mStreamStates[streamType].mIndex);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamState.mStreamType,SENDMSG_REPLACE,1,1,streamState,PERSIST_DELAY);
}",0.9947183098591548
182389,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,0,0,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,1,1,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}",0.9985239852398524
182390,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0 && (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
 else {
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
}",0.8679245283018868
182391,"private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}",0.9921787709497206
182392,"private void persistVolume(VolumeStreamState streamState){
  System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,(streamState.mIndex + 5) / 10);
  System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,(streamState.mLastAudibleIndex + 5) / 10);
}","private void persistVolume(VolumeStreamState streamState,boolean current,boolean lastAudible){
  if (current) {
    System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,(streamState.mIndex + 5) / 10);
  }
  if (lastAudible) {
    System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,(streamState.mLastAudibleIndex + 5) / 10);
  }
}",0.8685015290519877
182393,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}",0.9903556359252562
182394,"public boolean isUsbRNDISStarted() throws IllegalStateException {
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE,""String_Node_Str"");
  ArrayList<String> rsp=mConnector.doCommand(""String_Node_Str"");
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == NetdResponseCode.UsbRNDISStatusResult) {
      if (tok[2].equals(""String_Node_Str""))       return true;
      return false;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","public boolean isUsbRNDISStarted() throws IllegalStateException {
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE,""String_Node_Str"");
  ArrayList<String> rsp=mConnector.doCommand(""String_Node_Str"");
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == NetdResponseCode.UsbRNDISStatusResult) {
      if (tok[3].equals(""String_Node_Str""))       return true;
      return false;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}",0.9984756097560976
182395,"public boolean isUsbRNDISStarted() throws IllegalStateException {
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE,""String_Node_Str"");
  ArrayList<String> rsp=mConnector.doCommand(""String_Node_Str"");
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == NetdResponseCode.UsbRNDISStatusResult) {
      if (tok[2].equals(""String_Node_Str""))       return true;
      return false;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","public boolean isUsbRNDISStarted() throws IllegalStateException {
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_NETWORK_STATE,""String_Node_Str"");
  ArrayList<String> rsp=mConnector.doCommand(""String_Node_Str"");
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == NetdResponseCode.UsbRNDISStatusResult) {
      if (tok[3].equals(""String_Node_Str""))       return true;
      return false;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}",0.9984756097560976
182396,"void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  hideInputMethodMenu();
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  int N=(immis == null ? 0 : immis.size());
  mItems=new CharSequence[N];
  mIms=new InputMethodInfo[N];
  for (int i=0; i < N; ++i) {
    InputMethodInfo property=immis.get(i);
    mItems[i]=property.loadLabel(pm);
    mIms[i]=property;
  }
  int checkedItem=0;
  for (int i=0; i < N; ++i) {
    if (mIms[i].getId().equals(lastInputMethodId)) {
      checkedItem=i;
      break;
    }
  }
  AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      hideInputMethodMenu();
    }
  }
;
  TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
  mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      hideInputMethodMenu();
    }
  }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
  a.recycle();
  mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
synchronized (mMethodMap) {
        InputMethodInfo im=mIms[which];
        hideInputMethodMenu();
        setInputMethodLocked(im.getId());
      }
    }
  }
);
synchronized (mMethodMap) {
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}","void showInputMethodMenu(){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"");
  hideInputMethodMenu();
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + lastInputMethodId);
  final List<InputMethodInfo> immis=getEnabledInputMethodList();
  if (immis == null) {
    return;
  }
  int N=immis.size();
  mItems=new CharSequence[N];
  mIms=new InputMethodInfo[N];
  for (int i=0; i < N; ++i) {
    InputMethodInfo property=immis.get(i);
    if (property == null) {
      i--;
      N--;
      continue;
    }
    mItems[i]=property.loadLabel(pm);
    mIms[i]=property;
  }
  int checkedItem=0;
  for (int i=0; i < N; ++i) {
    if (mIms[i].getId().equals(lastInputMethodId)) {
      checkedItem=i;
      break;
    }
  }
  AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      hideInputMethodMenu();
    }
  }
;
  TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
  mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      hideInputMethodMenu();
    }
  }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
  a.recycle();
  mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
synchronized (mMethodMap) {
        InputMethodInfo im=mIms[which];
        hideInputMethodMenu();
        setInputMethodLocked(im.getId());
      }
    }
  }
);
synchronized (mMethodMap) {
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}",0.9680057733942748
182397,"/** 
 * Sets the final position (Y) for this scroller.
 * @param newY The new Y offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalX(int)
 */
public void setFinalY(int newY){
  if (mScrollMode == MODE_DEFAULT) {
    mDefaultScroller.setFinalY(newY);
  }
}","/** 
 * Sets the final position (Y) for this scroller.
 * @param newY The new Y offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalX(int)
 */
public void setFinalY(int newY){
  if (mScrollMode == MODE_DEFAULT) {
    if (newY < mMinimumY) {
      mMinimumY=newY;
    }
    if (newY > mMaximumY) {
      mMaximumY=newY;
    }
    mDefaultScroller.setFinalY(newY);
  }
}",0.8418079096045198
182398,"/** 
 * Sets the final position (X) for this scroller.
 * @param newX The new X offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalY(int)
 */
public void setFinalX(int newX){
  if (mScrollMode == MODE_DEFAULT) {
    mDefaultScroller.setFinalX(newX);
  }
}","/** 
 * Sets the final position (X) for this scroller.
 * @param newX The new X offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalY(int)
 */
public void setFinalX(int newX){
  if (mScrollMode == MODE_DEFAULT) {
    if (newX < mMinimumX) {
      mMinimumX=newX;
    }
    if (newX > mMaximumX) {
      mMaximumX=newX;
    }
    mDefaultScroller.setFinalX(newX);
  }
}",0.8418079096045198
182399,"/** 
 * A key was pressed down and not handled by anything else in the window.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
protected boolean onKeyDown(int featureId,int keyCode,KeyEvent event){
  final KeyEvent.DispatcherState dispatcher=mDecor != null ? mDecor.getKeyDispatcherState() : null;
switch (keyCode) {
case KeyEvent.KEYCODE_VOLUME_UP:
case KeyEvent.KEYCODE_VOLUME_DOWN:
{
      AudioManager audioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
      if (audioManager != null) {
        audioManager.adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,mVolumeControlStreamType,AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_VIBRATE);
      }
      return true;
    }
case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
  if (mTelephonyManager == null) {
    mTelephonyManager=(TelephonyManager)getContext().getSystemService(Context.TELEPHONY_SERVICE);
  }
if (mTelephonyManager != null && mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
  return true;
}
case KeyEvent.KEYCODE_MUTE:
case KeyEvent.KEYCODE_HEADSETHOOK:
case KeyEvent.KEYCODE_MEDIA_STOP:
case KeyEvent.KEYCODE_MEDIA_NEXT:
case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
case KeyEvent.KEYCODE_MEDIA_REWIND:
case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
{
Intent intent=new Intent(Intent.ACTION_MEDIA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,event);
getContext().sendOrderedBroadcast(intent,null);
return true;
}
case KeyEvent.KEYCODE_CAMERA:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
dispatcher.performedLongPress(event);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,event);
getContext().sendOrderedBroadcast(intent,null);
}
return true;
}
case KeyEvent.KEYCODE_MENU:
{
onKeyDownPanel((featureId < 0) ? FEATURE_OPTIONS_PANEL : featureId,event);
return true;
}
case KeyEvent.KEYCODE_BACK:
{
if (event.getRepeatCount() > 0) break;
if (featureId < 0) break;
dispatcher.startTracking(event,this);
return true;
}
case KeyEvent.KEYCODE_CALL:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
dispatcher.performedLongPress(event);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
return true;
}
case KeyEvent.KEYCODE_SEARCH:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
Configuration config=getContext().getResources().getConfiguration();
if (config.keyboard == Configuration.KEYBOARD_NOKEYS || config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
dispatcher.performedLongPress(event);
}
 catch (ActivityNotFoundException e) {
}
}
}
break;
}
}
return false;
}","/** 
 * A key was pressed down and not handled by anything else in the window.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */
protected boolean onKeyDown(int featureId,int keyCode,KeyEvent event){
  final KeyEvent.DispatcherState dispatcher=mDecor != null ? mDecor.getKeyDispatcherState() : null;
switch (keyCode) {
case KeyEvent.KEYCODE_VOLUME_UP:
case KeyEvent.KEYCODE_VOLUME_DOWN:
{
      AudioManager audioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
      if (audioManager != null) {
        audioManager.adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER,mVolumeControlStreamType,AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_VIBRATE);
      }
      return true;
    }
case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
  if (mTelephonyManager == null) {
    mTelephonyManager=(TelephonyManager)getContext().getSystemService(Context.TELEPHONY_SERVICE);
  }
if (mTelephonyManager != null && mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
  return true;
}
case KeyEvent.KEYCODE_MUTE:
case KeyEvent.KEYCODE_HEADSETHOOK:
case KeyEvent.KEYCODE_MEDIA_STOP:
case KeyEvent.KEYCODE_MEDIA_NEXT:
case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
case KeyEvent.KEYCODE_MEDIA_REWIND:
case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
{
Intent intent=new Intent(Intent.ACTION_MEDIA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,event);
getContext().sendOrderedBroadcast(intent,null);
return true;
}
case KeyEvent.KEYCODE_CAMERA:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
dispatcher.performedLongPress(event);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,event);
getContext().sendOrderedBroadcast(intent,null);
}
return true;
}
case KeyEvent.KEYCODE_MENU:
{
onKeyDownPanel((featureId < 0) ? FEATURE_OPTIONS_PANEL : featureId,event);
return true;
}
case KeyEvent.KEYCODE_BACK:
{
if (event.getRepeatCount() > 0) break;
if (featureId < 0) break;
dispatcher.startTracking(event,this);
return true;
}
case KeyEvent.KEYCODE_CALL:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
dispatcher.performedLongPress(event);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
return true;
}
case KeyEvent.KEYCODE_SEARCH:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || dispatcher == null) {
break;
}
if (event.getRepeatCount() == 0) {
dispatcher.startTracking(event,this);
}
 else if (event.isLongPress() && dispatcher.isTracking(event)) {
Configuration config=getContext().getResources().getConfiguration();
if (config.keyboard == Configuration.KEYBOARD_NOKEYS || config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
dispatcher.performedLongPress(event);
return true;
}
 catch (ActivityNotFoundException e) {
}
}
}
break;
}
}
return false;
}",0.998272884283247
182400,"private void setSystemVolume(VolumeStreamState streamState){
  setStreamVolumeIndex(streamState.mStreamType,streamState.mIndex);
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (streamType != streamState.mStreamType && STREAM_VOLUME_ALIAS[streamType] == streamState.mStreamType) {
      setStreamVolumeIndex(streamType,mStreamStates[streamType].mIndex);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamState.mStreamType,SENDMSG_REPLACE,0,0,streamState,PERSIST_DELAY);
}","private void setSystemVolume(VolumeStreamState streamState){
  setStreamVolumeIndex(streamState.mStreamType,streamState.mIndex);
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
    if (streamType != streamState.mStreamType && STREAM_VOLUME_ALIAS[streamType] == streamState.mStreamType) {
      setStreamVolumeIndex(streamType,mStreamStates[streamType].mIndex);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamState.mStreamType,SENDMSG_REPLACE,1,1,streamState,PERSIST_DELAY);
}",0.9947183098591548
182401,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,0,0,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,1,1,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}",0.9985239852398524
182402,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0 && (mRingerMode == AudioManager.RINGER_MODE_NORMAL || !isStreamAffectedByRingerMode(streamType) || index == 0)) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
 else {
      sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,streamType,SENDMSG_REPLACE,0,1,streamState,PERSIST_DELAY);
    }
  }
}",0.8679245283018868
182403,"private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,true,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}",0.9921787709497206
182404,"private void persistVolume(VolumeStreamState streamState){
  System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,(streamState.mIndex + 5) / 10);
  System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,(streamState.mLastAudibleIndex + 5) / 10);
}","private void persistVolume(VolumeStreamState streamState,boolean current,boolean lastAudible){
  if (current) {
    System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,(streamState.mIndex + 5) / 10);
  }
  if (lastAudible) {
    System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,(streamState.mLastAudibleIndex + 5) / 10);
  }
}",0.8685015290519877
182405,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj,(msg.arg1 != 0),(msg.arg2 != 0));
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC);
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}",0.9903556359252562
182406,"/** 
 * Sets the final position (Y) for this scroller.
 * @param newY The new Y offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalX(int)
 */
public void setFinalY(int newY){
  if (mScrollMode == MODE_DEFAULT) {
    mDefaultScroller.setFinalY(newY);
  }
}","/** 
 * Sets the final position (Y) for this scroller.
 * @param newY The new Y offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalX(int)
 */
public void setFinalY(int newY){
  if (mScrollMode == MODE_DEFAULT) {
    if (newY < mMinimumY) {
      mMinimumY=newY;
    }
    if (newY > mMaximumY) {
      mMaximumY=newY;
    }
    mDefaultScroller.setFinalY(newY);
  }
}",0.8418079096045198
182407,"/** 
 * Sets the final position (X) for this scroller.
 * @param newX The new X offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalY(int)
 */
public void setFinalX(int newX){
  if (mScrollMode == MODE_DEFAULT) {
    mDefaultScroller.setFinalX(newX);
  }
}","/** 
 * Sets the final position (X) for this scroller.
 * @param newX The new X offset as an absolute distance from the origin.
 * @see #extendDuration(int)
 * @see #setFinalY(int)
 */
public void setFinalX(int newX){
  if (mScrollMode == MODE_DEFAULT) {
    if (newX < mMinimumX) {
      mMinimumX=newX;
    }
    if (newX > mMaximumX) {
      mMaximumX=newX;
    }
    mDefaultScroller.setFinalX(newX);
  }
}",0.8418079096045198
182408,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  boolean configChanged;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client,false);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (DEBUG_LAYOUT)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mAttrs);
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
 else {
      win.mHScale=win.mVScale=1;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen && mPolicy.isScreenOn()) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Slog.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
      if (win.mAttrs.type == TYPE_BASE_APPLICATION && win.mAppToken != null && win.mAppToken.startingWindow != null) {
        final int mask=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
        WindowManager.LayoutParams sa=win.mAppToken.startingWindow.mAttrs;
        sa.flags=(sa.flags & ~mask) | (win.mAttrs.flags & mask);
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    configChanged=updateOrientationFromAppTokensLocked();
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (configChanged) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  boolean configChanged;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client,false);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (DEBUG_LAYOUT)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mAttrs);
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
 else {
      win.mHScale=win.mVScale=1;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen && mPolicy.isScreenOn()) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Slog.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
      if (win.mAttrs.type == TYPE_BASE_APPLICATION && win.mAppToken != null && win.mAppToken.startingWindow != null) {
        final int mask=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
        WindowManager.LayoutParams sa=win.mAppToken.startingWindow.mAttrs;
        sa.flags=(sa.flags & ~mask) | (win.mAttrs.flags & mask);
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    configChanged=updateOrientationFromAppTokensLocked();
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (configChanged) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}",0.9949809275245934
182409,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    boolean wallpaperForceHidingChanged=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
focusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && !restart && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    restart=true;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + restart);
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    boolean wallpaperForceHidingChanged=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
                mFocusMayChange=true;
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && !restart && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    restart=true;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + restart);
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9952067207533748
182410,"/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}","/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}",0.7804878048780488
182411,"public void prepareAppTransition(int transit){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit + ""String_Node_Str""+ mNextAppTransition);
    if (!mDisplayFrozen) {
      if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
        mNextAppTransition=transit;
      }
      mAppTransitionReady=false;
      mAppTransitionTimeout=false;
      mStartingIconInTransition=false;
      mSkipAppTransitionAnimation=false;
      mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
      mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),5000);
    }
  }
}","public void prepareAppTransition(int transit){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit + ""String_Node_Str""+ mNextAppTransition);
    if (!mDisplayFrozen && mPolicy.isScreenOn()) {
      if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
        mNextAppTransition=transit;
      }
      mAppTransitionReady=false;
      mAppTransitionTimeout=false;
      mStartingIconInTransition=false;
      mSkipAppTransitionAnimation=false;
      mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
      mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),5000);
    }
  }
}",0.9900249376558604
182412,"public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mPolicy.isScreenOn() && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}",0.9940298507462688
182413,"boolean hideLw(boolean doAnimation,boolean requestAnim){
  boolean current=doAnimation ? mPolicyVisibilityAfterAnim : mPolicyVisibility;
  if (!current) {
    return false;
  }
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_EXIT,false);
    if (mAnimation == null) {
      doAnimation=false;
    }
  }
  if (doAnimation) {
    mPolicyVisibilityAfterAnim=false;
  }
 else {
    mPolicyVisibilityAfterAnim=false;
    mPolicyVisibility=false;
    enableScreenIfNeededLocked();
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}","boolean hideLw(boolean doAnimation,boolean requestAnim){
  boolean current=doAnimation ? mPolicyVisibilityAfterAnim : mPolicyVisibility;
  if (!current) {
    return false;
  }
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_EXIT,false);
    if (mAnimation == null) {
      doAnimation=false;
    }
  }
  if (doAnimation) {
    mPolicyVisibilityAfterAnim=false;
  }
 else {
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this);
    mPolicyVisibilityAfterAnim=false;
    mPolicyVisibility=false;
    enableScreenIfNeededLocked();
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}",0.9448051948051948
182414,"boolean showLw(boolean doAnimation,boolean requestAnim){
  if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
    return false;
  }
  mPolicyVisibility=true;
  mPolicyVisibilityAfterAnim=true;
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_ENTER,true);
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}","boolean showLw(boolean doAnimation,boolean requestAnim){
  if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
    return false;
  }
  if (DEBUG_VISIBILITY)   Slog.v(TAG,""String_Node_Str"" + this);
  mPolicyVisibility=true;
  mPolicyVisibilityAfterAnim=true;
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_ENTER,true);
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}",0.9193954659949622
182415,"public void startAppFreezingScreen(IBinder token,int configChanges){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (configChanges == 0 && !mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + token);
      return;
    }
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null || wtoken.appToken == null) {
      Slog.w(TAG,""String_Node_Str"" + wtoken);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    startAppFreezingScreenLocked(wtoken,configChanges);
    Binder.restoreCallingIdentity(origId);
  }
}","public void startAppFreezingScreen(IBinder token,int configChanges){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (configChanges == 0 && !mDisplayFrozen && mPolicy.isScreenOn()) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + token);
      return;
    }
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null || wtoken.appToken == null) {
      Slog.w(TAG,""String_Node_Str"" + wtoken);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    startAppFreezingScreenLocked(wtoken,configChanges);
    Binder.restoreCallingIdentity(origId);
  }
}",0.9836734693877552
182416,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  boolean configChanged;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client,false);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (DEBUG_LAYOUT)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mAttrs);
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
 else {
      win.mHScale=win.mVScale=1;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen && mPolicy.isScreenOn()) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Slog.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
      if (win.mAttrs.type == TYPE_BASE_APPLICATION && win.mAppToken != null && win.mAppToken.startingWindow != null) {
        final int mask=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
        WindowManager.LayoutParams sa=win.mAppToken.startingWindow.mAttrs;
        sa.flags=(sa.flags & ~mask) | (win.mAttrs.flags & mask);
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    configChanged=updateOrientationFromAppTokensLocked();
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (configChanged) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  boolean configChanged;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client,false);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (DEBUG_LAYOUT)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mAttrs);
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
 else {
      win.mHScale=win.mVScale=1;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen && mPolicy.isScreenOn()) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Slog.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
      if (win.mAttrs.type == TYPE_BASE_APPLICATION && win.mAppToken != null && win.mAppToken.startingWindow != null) {
        final int mask=WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
        WindowManager.LayoutParams sa=win.mAppToken.startingWindow.mAttrs;
        sa.flags=(sa.flags & ~mask) | (win.mAttrs.flags & mask);
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Slog.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    configChanged=updateOrientationFromAppTokensLocked();
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (configChanged) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}",0.9949809275245934
182417,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    boolean wallpaperForceHidingChanged=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
focusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && !restart && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    restart=true;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + restart);
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  if (mFocusMayChange) {
    mFocusMayChange=false;
    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
  }
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  float buttonBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    boolean wallpaperForceHidingChanged=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + transactionSequence + ""String_Node_Str""+ tokensAnimating);
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Slog.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              mFocusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
                mFocusMayChange=true;
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Slog.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Slog.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  if (!mPolicy.allowAppAnimationsLw()) {
    animLp=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  mFocusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
mFocusMayChange=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged && !restart && !mAppTransitionReady) {
WindowState oldWallpaper=mWallpaperTarget;
if (mLowerWallpaperTarget != null && mLowerWallpaperTarget.mAppToken != null) {
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget);
  if (DEBUG_WALLPAPER)   Slog.v(TAG,""String_Node_Str"" + mLowerWallpaperTarget.mAppToken.hidden + ""String_Node_Str""+ mLowerWallpaperTarget.mAppToken.hiddenRequested);
  if (mLowerWallpaperTarget.mAppToken.hidden) {
    mLowerWallpaperTarget=mUpperWallpaperTarget=null;
    restart=true;
  }
}
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
wallpaperForceHidingChanged=false;
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget+ ""String_Node_Str""+ mLowerWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs) && w.isVisibleLw()) {
        if (DEBUG_FOCUS)         Slog.i(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Slog.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (mFocusMayChange) {
mFocusMayChange=false;
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,""String_Node_Str"" + restart);
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Slog.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  boolean configChanged=w.mConfiguration != mCurConfiguration && (w.mConfiguration == null || mCurConfiguration.diff(w.mConfiguration) != 0);
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ configChanged+ ""String_Node_Str""+ w.mLastFrame+ ""String_Node_Str""+ w.mFrame);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged|| configChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (!mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Slog.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Slog.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.MATCH_PARENT && attrs.height == LayoutParams.MATCH_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (!syswin && w.mAttrs.buttonBrightness >= 0 && buttonBrightness < 0) {
    buttonBrightness=w.mAttrs.buttonBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Slog.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,""String_Node_Str"",0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Slog.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Slog.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,""String_Node_Str"",-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Slog.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Slog.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Slog.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen || !mPolicy.isScreenOn());
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Slog.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Slog.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Slog.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
stopFreezingDisplayLocked();
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Slog.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
boolean configChanged=win.mConfiguration != mCurConfiguration && (win.mConfiguration == null || mCurConfiguration.diff(win.mConfiguration) != 0);
win.mConfiguration=mCurConfiguration;
if (DEBUG_ORIENTATION && configChanged) {
  Slog.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame.width()+ ""String_Node_Str""+ win.mFrame.height()+ ""String_Node_Str""+ win.mConfiguration);
}
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending,configChanged ? win.mConfiguration : null);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (buttonBrightness < 0 || buttonBrightness > 1.0f) {
mPowerManager.setButtonBrightnessOverride(-1);
}
 else {
mPowerManager.setButtonBrightnessOverride((int)(buttonBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
if (DEBUG_VISIBILITY) Slog.v(TAG,""String_Node_Str"");
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
enableScreenIfNeededLocked();
}",0.9952067207533748
182418,"/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}","/** 
 * Have the surface flinger show a surface, robustly dealing with error conditions.  In particular, if there is not enough memory to show the surface, then we will try to get rid of other surfaces in order to succeed.
 * @return Returns true if the surface was successfully shown.
 */
boolean showSurfaceRobustlyLocked(WindowState win){
  try {
    if (win.mSurface != null) {
      win.mSurface.show();
      if (win.mTurnOnScreen) {
        if (DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + win);
        win.mTurnOnScreen=false;
        mTurnOnScreen=true;
      }
    }
    return true;
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win);
  }
  reclaimSomeSurfaceMemoryLocked(win,""String_Node_Str"");
  return false;
}",0.7804878048780488
182419,"public void prepareAppTransition(int transit){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit + ""String_Node_Str""+ mNextAppTransition);
    if (!mDisplayFrozen) {
      if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
        mNextAppTransition=transit;
      }
      mAppTransitionReady=false;
      mAppTransitionTimeout=false;
      mStartingIconInTransition=false;
      mSkipAppTransitionAnimation=false;
      mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
      mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),5000);
    }
  }
}","public void prepareAppTransition(int transit){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + transit + ""String_Node_Str""+ mNextAppTransition);
    if (!mDisplayFrozen && mPolicy.isScreenOn()) {
      if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
        mNextAppTransition=transit;
      }
 else       if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
        mNextAppTransition=transit;
      }
      mAppTransitionReady=false;
      mAppTransitionTimeout=false;
      mStartingIconInTransition=false;
      mSkipAppTransitionAnimation=false;
      mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
      mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),5000);
    }
  }
}",0.9900249376558604
182420,"public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mPolicy.isScreenOn() && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}",0.9940298507462688
182421,"boolean hideLw(boolean doAnimation,boolean requestAnim){
  boolean current=doAnimation ? mPolicyVisibilityAfterAnim : mPolicyVisibility;
  if (!current) {
    return false;
  }
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_EXIT,false);
    if (mAnimation == null) {
      doAnimation=false;
    }
  }
  if (doAnimation) {
    mPolicyVisibilityAfterAnim=false;
  }
 else {
    mPolicyVisibilityAfterAnim=false;
    mPolicyVisibility=false;
    enableScreenIfNeededLocked();
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}","boolean hideLw(boolean doAnimation,boolean requestAnim){
  boolean current=doAnimation ? mPolicyVisibilityAfterAnim : mPolicyVisibility;
  if (!current) {
    return false;
  }
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_EXIT,false);
    if (mAnimation == null) {
      doAnimation=false;
    }
  }
  if (doAnimation) {
    mPolicyVisibilityAfterAnim=false;
  }
 else {
    if (DEBUG_VISIBILITY)     Slog.v(TAG,""String_Node_Str"" + this);
    mPolicyVisibilityAfterAnim=false;
    mPolicyVisibility=false;
    enableScreenIfNeededLocked();
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}",0.9448051948051948
182422,"boolean showLw(boolean doAnimation,boolean requestAnim){
  if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
    return false;
  }
  mPolicyVisibility=true;
  mPolicyVisibilityAfterAnim=true;
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_ENTER,true);
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}","boolean showLw(boolean doAnimation,boolean requestAnim){
  if (mPolicyVisibility && mPolicyVisibilityAfterAnim) {
    return false;
  }
  if (DEBUG_VISIBILITY)   Slog.v(TAG,""String_Node_Str"" + this);
  mPolicyVisibility=true;
  mPolicyVisibilityAfterAnim=true;
  if (doAnimation) {
    applyAnimationLocked(this,WindowManagerPolicy.TRANSIT_ENTER,true);
  }
  if (requestAnim) {
    requestAnimationLocked(0);
  }
  return true;
}",0.9193954659949622
182423,"public void startAppFreezingScreen(IBinder token,int configChanges){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (configChanges == 0 && !mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + token);
      return;
    }
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null || wtoken.appToken == null) {
      Slog.w(TAG,""String_Node_Str"" + wtoken);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    startAppFreezingScreenLocked(wtoken,configChanges);
    Binder.restoreCallingIdentity(origId);
  }
}","public void startAppFreezingScreen(IBinder token,int configChanges){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (configChanges == 0 && !mDisplayFrozen && mPolicy.isScreenOn()) {
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + token);
      return;
    }
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null || wtoken.appToken == null) {
      Slog.w(TAG,""String_Node_Str"" + wtoken);
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    startAppFreezingScreenLocked(wtoken,configChanges);
    Binder.restoreCallingIdentity(origId);
  }
}",0.9836734693877552
182424,"private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}","private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  if (mAuthHeader != null)   return;
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}",0.8425720620842572
182425,"private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}","private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  if (mAuthHeader != null)   return;
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}",0.8425720620842572
182426,"private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}","private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  if (mAuthHeader != null)   return;
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}",0.8425720620842572
182427,"private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}","private void commitHeaders(){
  if (mIsMainPageLoader && sCertificateTypeMap.containsKey(mMimeType)) {
    return;
  }
  if (mAuthHeader != null)   return;
  int nativeResponse=createNativeResponse();
  nativeReceivedResponse(nativeResponse);
}",0.8425720620842572
182428,"/** 
 * The constructor for the TextToSpeech class. This will also initialize the associated TextToSpeech engine if it isn't already running.
 * @param context The context this instance is running in.
 * @param listener The  {@link TextToSpeech.OnInitListener} that will be called when theTextToSpeech engine has initialized.
 */
public TextToSpeech(Context context,OnInitListener listener){
  mContext=context;
  mPackageName=mContext.getPackageName();
  mInitListener=listener;
  mCachedParams=new String[2 * Engine.NB_CACHED_PARAMS];
  mCachedParams[Engine.PARAM_POSITION_RATE]=Engine.KEY_PARAM_RATE;
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE]=Engine.KEY_PARAM_LANGUAGE;
  mCachedParams[Engine.PARAM_POSITION_COUNTRY]=Engine.KEY_PARAM_COUNTRY;
  mCachedParams[Engine.PARAM_POSITION_VARIANT]=Engine.KEY_PARAM_VARIANT;
  mCachedParams[Engine.PARAM_POSITION_STREAM]=Engine.KEY_PARAM_STREAM;
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID]=Engine.KEY_PARAM_UTTERANCE_ID;
  mCachedParams[Engine.PARAM_POSITION_ENGINE]=Engine.KEY_PARAM_ENGINE;
  mCachedParams[Engine.PARAM_POSITION_RATE + 1]=String.valueOf(Engine.DEFAULT_RATE);
  Locale defaultLoc=Locale.getDefault();
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1]=defaultLoc.getISO3Language();
  mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1]=defaultLoc.getISO3Country();
  mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]=defaultLoc.getVariant();
  mCachedParams[Engine.PARAM_POSITION_STREAM + 1]=String.valueOf(Engine.DEFAULT_STREAM);
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=Engine.DEFAULT_SYNTH;
  initTts();
}","/** 
 * The constructor for the TextToSpeech class. This will also initialize the associated TextToSpeech engine if it isn't already running.
 * @param context The context this instance is running in.
 * @param listener The  {@link TextToSpeech.OnInitListener} that will be called when theTextToSpeech engine has initialized.
 */
public TextToSpeech(Context context,OnInitListener listener){
  mContext=context;
  mPackageName=mContext.getPackageName();
  mInitListener=listener;
  mCachedParams=new String[2 * Engine.NB_CACHED_PARAMS];
  mCachedParams[Engine.PARAM_POSITION_RATE]=Engine.KEY_PARAM_RATE;
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE]=Engine.KEY_PARAM_LANGUAGE;
  mCachedParams[Engine.PARAM_POSITION_COUNTRY]=Engine.KEY_PARAM_COUNTRY;
  mCachedParams[Engine.PARAM_POSITION_VARIANT]=Engine.KEY_PARAM_VARIANT;
  mCachedParams[Engine.PARAM_POSITION_STREAM]=Engine.KEY_PARAM_STREAM;
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID]=Engine.KEY_PARAM_UTTERANCE_ID;
  mCachedParams[Engine.PARAM_POSITION_ENGINE]=Engine.KEY_PARAM_ENGINE;
  mCachedParams[Engine.PARAM_POSITION_RATE + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_STREAM + 1]=String.valueOf(Engine.DEFAULT_STREAM);
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=""String_Node_Str"";
  initTts();
}",0.7033034887310898
182429,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
synchronized (this) {
        mSynthBusy=true;
      }
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
synchronized (this) {
        mSynthBusy=false;
      }
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
synchronized (this) {
        mSynthBusy=true;
      }
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
synchronized (this) {
        mSynthBusy=false;
      }
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
 else {
        setEngine(getDefaultEngine());
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
 else {
        setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
 else {
        setSpeechRate(""String_Node_Str"",getDefaultRate());
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}",0.9535661218424965
182430,"private int setEngine(String enginePackageName){
  String soFilename=""String_Node_Str"";
  if (enginePackageName.equals(""String_Node_Str"")) {
    soFilename=""String_Node_Str"";
  }
 else {
    Intent intent=new Intent(""String_Node_Str"");
    intent.setPackage(enginePackageName);
    ResolveInfo[] enginesArray=new ResolveInfo[0];
    PackageManager pm=getPackageManager();
    List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
    if ((resolveInfos == null) || resolveInfos.isEmpty()) {
      Log.e(SERVICE_TAG,""String_Node_Str"" + enginePackageName);
      return TextToSpeech.ERROR;
    }
    enginesArray=resolveInfos.toArray(enginesArray);
    ActivityInfo aInfo=enginesArray[0].activityInfo;
    soFilename=aInfo.name.replace(aInfo.packageName + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    soFilename=soFilename.toLowerCase();
    soFilename=""String_Node_Str"" + aInfo.packageName + ""String_Node_Str""+ soFilename;
  }
  if (currentSpeechEngineSOFile.equals(soFilename)) {
    return TextToSpeech.SUCCESS;
  }
  File f=new File(soFilename);
  if (!f.exists()) {
    Log.e(SERVICE_TAG,""String_Node_Str"" + soFilename);
    return TextToSpeech.ERROR;
  }
  if (sNativeSynth != null) {
    sNativeSynth.stopSync();
    sNativeSynth.shutdown();
    sNativeSynth=null;
  }
  sNativeSynth=new SynthProxy(soFilename);
  currentSpeechEngineSOFile=soFilename;
  return TextToSpeech.SUCCESS;
}","private int setEngine(String enginePackageName){
  String soFilename=""String_Node_Str"";
  if (isDefaultEnforced()) {
    enginePackageName=getDefaultEngine();
  }
  if (enginePackageName.equals(""String_Node_Str"")) {
    soFilename=""String_Node_Str"";
  }
 else {
    Intent intent=new Intent(""String_Node_Str"");
    intent.setPackage(enginePackageName);
    ResolveInfo[] enginesArray=new ResolveInfo[0];
    PackageManager pm=getPackageManager();
    List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
    if ((resolveInfos == null) || resolveInfos.isEmpty()) {
      Log.e(SERVICE_TAG,""String_Node_Str"" + enginePackageName);
      return TextToSpeech.ERROR;
    }
    enginesArray=resolveInfos.toArray(enginesArray);
    ActivityInfo aInfo=enginesArray[0].activityInfo;
    soFilename=aInfo.name.replace(aInfo.packageName + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    soFilename=soFilename.toLowerCase();
    soFilename=""String_Node_Str"" + aInfo.packageName + ""String_Node_Str""+ soFilename;
  }
  if (currentSpeechEngineSOFile.equals(soFilename)) {
    return TextToSpeech.SUCCESS;
  }
  File f=new File(soFilename);
  if (!f.exists()) {
    Log.e(SERVICE_TAG,""String_Node_Str"" + soFilename);
    return TextToSpeech.ERROR;
  }
  if (sNativeSynth != null) {
    sNativeSynth.stopSync();
    sNativeSynth.shutdown();
    sNativeSynth=null;
  }
  sNativeSynth=new SynthProxy(soFilename);
  currentSpeechEngineSOFile=soFilename;
  return TextToSpeech.SUCCESS;
}",0.9742356578495364
182431,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
synchronized (this) {
            mSynthBusy=true;
          }
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
synchronized (this) {
            mSynthBusy=false;
          }
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
synchronized (this) {
            mSynthBusy=true;
          }
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
synchronized (this) {
            mSynthBusy=false;
          }
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
 else {
            setEngine(getDefaultEngine());
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
 else {
            setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
 else {
            setSpeechRate(""String_Node_Str"",getDefaultRate());
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}",0.957611386138614
182432,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          mSynthBusy=true;
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          mSynthBusy=false;
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          mSynthBusy=true;
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          mSynthBusy=false;
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
 else {
            setEngine(getDefaultEngine());
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
 else {
            setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
 else {
            setSpeechRate(""String_Node_Str"",getDefaultRate());
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}",0.960185992444057
182433,"/** 
 * The constructor for the TextToSpeech class. This will also initialize the associated TextToSpeech engine if it isn't already running.
 * @param context The context this instance is running in.
 * @param listener The  {@link TextToSpeech.OnInitListener} that will be called when theTextToSpeech engine has initialized.
 */
public TextToSpeech(Context context,OnInitListener listener){
  mContext=context;
  mPackageName=mContext.getPackageName();
  mInitListener=listener;
  mCachedParams=new String[2 * Engine.NB_CACHED_PARAMS];
  mCachedParams[Engine.PARAM_POSITION_RATE]=Engine.KEY_PARAM_RATE;
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE]=Engine.KEY_PARAM_LANGUAGE;
  mCachedParams[Engine.PARAM_POSITION_COUNTRY]=Engine.KEY_PARAM_COUNTRY;
  mCachedParams[Engine.PARAM_POSITION_VARIANT]=Engine.KEY_PARAM_VARIANT;
  mCachedParams[Engine.PARAM_POSITION_STREAM]=Engine.KEY_PARAM_STREAM;
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID]=Engine.KEY_PARAM_UTTERANCE_ID;
  mCachedParams[Engine.PARAM_POSITION_ENGINE]=Engine.KEY_PARAM_ENGINE;
  mCachedParams[Engine.PARAM_POSITION_RATE + 1]=String.valueOf(Engine.DEFAULT_RATE);
  Locale defaultLoc=Locale.getDefault();
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1]=defaultLoc.getISO3Language();
  mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1]=defaultLoc.getISO3Country();
  mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]=defaultLoc.getVariant();
  mCachedParams[Engine.PARAM_POSITION_STREAM + 1]=String.valueOf(Engine.DEFAULT_STREAM);
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=Engine.DEFAULT_SYNTH;
  initTts();
}","/** 
 * The constructor for the TextToSpeech class. This will also initialize the associated TextToSpeech engine if it isn't already running.
 * @param context The context this instance is running in.
 * @param listener The  {@link TextToSpeech.OnInitListener} that will be called when theTextToSpeech engine has initialized.
 */
public TextToSpeech(Context context,OnInitListener listener){
  mContext=context;
  mPackageName=mContext.getPackageName();
  mInitListener=listener;
  mCachedParams=new String[2 * Engine.NB_CACHED_PARAMS];
  mCachedParams[Engine.PARAM_POSITION_RATE]=Engine.KEY_PARAM_RATE;
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE]=Engine.KEY_PARAM_LANGUAGE;
  mCachedParams[Engine.PARAM_POSITION_COUNTRY]=Engine.KEY_PARAM_COUNTRY;
  mCachedParams[Engine.PARAM_POSITION_VARIANT]=Engine.KEY_PARAM_VARIANT;
  mCachedParams[Engine.PARAM_POSITION_STREAM]=Engine.KEY_PARAM_STREAM;
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID]=Engine.KEY_PARAM_UTTERANCE_ID;
  mCachedParams[Engine.PARAM_POSITION_ENGINE]=Engine.KEY_PARAM_ENGINE;
  mCachedParams[Engine.PARAM_POSITION_RATE + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_STREAM + 1]=String.valueOf(Engine.DEFAULT_STREAM);
  mCachedParams[Engine.PARAM_POSITION_UTTERANCE_ID + 1]=""String_Node_Str"";
  mCachedParams[Engine.PARAM_POSITION_ENGINE + 1]=""String_Node_Str"";
  initTts();
}",0.7033034887310898
182434,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
synchronized (this) {
        mSynthBusy=true;
      }
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
synchronized (this) {
        mSynthBusy=false;
      }
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
synchronized (this) {
        mSynthBusy=true;
      }
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
synchronized (this) {
        mSynthBusy=false;
      }
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
 else {
        setEngine(getDefaultEngine());
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
 else {
        setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
 else {
        setSpeechRate(""String_Node_Str"",getDefaultRate());
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}",0.9535661218424965
182435,"private int setEngine(String enginePackageName){
  String soFilename=""String_Node_Str"";
  if (enginePackageName.equals(""String_Node_Str"")) {
    soFilename=""String_Node_Str"";
  }
 else {
    Intent intent=new Intent(""String_Node_Str"");
    intent.setPackage(enginePackageName);
    ResolveInfo[] enginesArray=new ResolveInfo[0];
    PackageManager pm=getPackageManager();
    List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
    if ((resolveInfos == null) || resolveInfos.isEmpty()) {
      Log.e(SERVICE_TAG,""String_Node_Str"" + enginePackageName);
      return TextToSpeech.ERROR;
    }
    enginesArray=resolveInfos.toArray(enginesArray);
    ActivityInfo aInfo=enginesArray[0].activityInfo;
    soFilename=aInfo.name.replace(aInfo.packageName + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    soFilename=soFilename.toLowerCase();
    soFilename=""String_Node_Str"" + aInfo.packageName + ""String_Node_Str""+ soFilename;
  }
  if (currentSpeechEngineSOFile.equals(soFilename)) {
    return TextToSpeech.SUCCESS;
  }
  File f=new File(soFilename);
  if (!f.exists()) {
    Log.e(SERVICE_TAG,""String_Node_Str"" + soFilename);
    return TextToSpeech.ERROR;
  }
  if (sNativeSynth != null) {
    sNativeSynth.stopSync();
    sNativeSynth.shutdown();
    sNativeSynth=null;
  }
  sNativeSynth=new SynthProxy(soFilename);
  currentSpeechEngineSOFile=soFilename;
  return TextToSpeech.SUCCESS;
}","private int setEngine(String enginePackageName){
  String soFilename=""String_Node_Str"";
  if (isDefaultEnforced()) {
    enginePackageName=getDefaultEngine();
  }
  if (enginePackageName.equals(""String_Node_Str"")) {
    soFilename=""String_Node_Str"";
  }
 else {
    Intent intent=new Intent(""String_Node_Str"");
    intent.setPackage(enginePackageName);
    ResolveInfo[] enginesArray=new ResolveInfo[0];
    PackageManager pm=getPackageManager();
    List<ResolveInfo> resolveInfos=pm.queryIntentActivities(intent,0);
    if ((resolveInfos == null) || resolveInfos.isEmpty()) {
      Log.e(SERVICE_TAG,""String_Node_Str"" + enginePackageName);
      return TextToSpeech.ERROR;
    }
    enginesArray=resolveInfos.toArray(enginesArray);
    ActivityInfo aInfo=enginesArray[0].activityInfo;
    soFilename=aInfo.name.replace(aInfo.packageName + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
    soFilename=soFilename.toLowerCase();
    soFilename=""String_Node_Str"" + aInfo.packageName + ""String_Node_Str""+ soFilename;
  }
  if (currentSpeechEngineSOFile.equals(soFilename)) {
    return TextToSpeech.SUCCESS;
  }
  File f=new File(soFilename);
  if (!f.exists()) {
    Log.e(SERVICE_TAG,""String_Node_Str"" + soFilename);
    return TextToSpeech.ERROR;
  }
  if (sNativeSynth != null) {
    sNativeSynth.stopSync();
    sNativeSynth.shutdown();
    sNativeSynth=null;
  }
  sNativeSynth=new SynthProxy(soFilename);
  currentSpeechEngineSOFile=soFilename;
  return TextToSpeech.SUCCESS;
}",0.9742356578495364
182436,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
synchronized (this) {
            mSynthBusy=true;
          }
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
synchronized (this) {
            mSynthBusy=false;
          }
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
synchronized (this) {
            mSynthBusy=true;
          }
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
synchronized (this) {
            mSynthBusy=false;
          }
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
 else {
            setEngine(getDefaultEngine());
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
 else {
            setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
 else {
            setSpeechRate(""String_Node_Str"",getDefaultRate());
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}",0.957611386138614
182437,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          mSynthBusy=true;
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          mSynthBusy=false;
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          mSynthBusy=true;
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          mSynthBusy=false;
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
 else {
            setEngine(getDefaultEngine());
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
 else {
            setLanguage(""String_Node_Str"",getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
 else {
            setSpeechRate(""String_Node_Str"",getDefaultRate());
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}",0.960185992444057
182438,"Listener(IBinder token){
  mToken=token;
}","Listener(IBinder token,int uid){
  mToken=token;
  mUid=uid;
}",0.8076923076923077
182439,"public boolean enableSensor(IBinder binder,String name,int sensor,int enable) throws RemoteException {
  if (localLOGV)   Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ sensor+ ""String_Node_Str""+ enable);
  int uid=Binder.getCallingUid();
  long identity=Binder.clearCallingIdentity();
  if (enable == SENSOR_DISABLE) {
    mBatteryStats.noteStopSensor(uid,sensor);
  }
 else {
    mBatteryStats.noteStartSensor(uid,sensor);
  }
  Binder.restoreCallingIdentity(identity);
  if (binder == null) {
    Slog.w(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ sensor+ ""String_Node_Str"");
    return false;
  }
synchronized (mListeners) {
    if (enable != SENSOR_DISABLE && !_sensors_control_activate(sensor,true)) {
      Slog.w(TAG,""String_Node_Str"" + sensor);
      return false;
    }
    Listener l=null;
    int minDelay=enable;
    for (    Listener listener : mListeners) {
      if (binder == listener.mToken) {
        l=listener;
      }
      if (minDelay > listener.mDelay)       minDelay=listener.mDelay;
    }
    if (l == null && enable != SENSOR_DISABLE) {
      l=new Listener(binder);
      binder.linkToDeath(l,0);
      mListeners.add(l);
      mListeners.notify();
    }
    if (l == null) {
      Slog.w(TAG,""String_Node_Str"" + binder + ""String_Node_Str""+ name+ ""String_Node_Str""+ sensor+ ""String_Node_Str"");
      return false;
    }
    if (minDelay >= 0) {
      _sensors_control_set_delay(minDelay);
    }
    if (enable != SENSOR_DISABLE) {
      l.addSensor(sensor,enable);
    }
 else {
      l.removeSensor(sensor);
      deactivateIfUnusedLocked(sensor);
      if (l.mSensors == 0) {
        mListeners.remove(l);
        binder.unlinkToDeath(l,0);
        mListeners.notify();
      }
    }
    if (mListeners.size() == 0) {
      _sensors_control_wake();
      _sensors_control_close();
    }
  }
  return true;
}","public boolean enableSensor(IBinder binder,String name,int sensor,int enable) throws RemoteException {
  if (localLOGV)   Slog.d(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ sensor+ ""String_Node_Str""+ enable);
  if (binder == null) {
    Slog.e(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ sensor+ ""String_Node_Str"");
    return false;
  }
  if (enable < 0 && (enable != SENSOR_DISABLE)) {
    Slog.e(TAG,""String_Node_Str"" + enable + ""String_Node_Str""+ name+ ""String_Node_Str""+ sensor+ ""String_Node_Str"");
    return false;
  }
  boolean res;
  int uid=Binder.getCallingUid();
synchronized (mListeners) {
    res=enableSensorInternalLocked(binder,uid,name,sensor,enable);
    if (res == true) {
      long identity=Binder.clearCallingIdentity();
      if (enable == SENSOR_DISABLE) {
        mBatteryStats.noteStopSensor(uid,sensor);
      }
 else {
        mBatteryStats.noteStartSensor(uid,sensor);
      }
      Binder.restoreCallingIdentity(identity);
    }
  }
  return res;
}",0.2966608084358523
182440,"void addSensor(int sensor,int delay){
  mSensors|=(1 << sensor);
  if (mDelay > delay)   mDelay=delay;
}","void addSensor(int sensor,int delay){
  mSensors|=(1 << sensor);
  if (delay < mDelay)   mDelay=delay;
}",0.9615384615384616
182441,"private void deactivateIfUnusedLocked(int sensor) throws RemoteException {
  int size=mListeners.size();
  for (int i=0; i < size; i++) {
    if (mListeners.get(i).hasSensor(sensor))     return;
  }
  _sensors_control_activate(sensor,false);
}","private void deactivateIfUnusedLocked(int sensor){
  int size=mListeners.size();
  for (int i=0; i < size; i++) {
    if (mListeners.get(i).hasSensor(sensor)) {
      return;
    }
  }
  if (_sensors_control_activate(sensor,false) == false) {
    Slog.w(TAG,""String_Node_Str"" + sensor);
  }
}",0.7925233644859813
182442,"public void binderDied(){
  if (localLOGV)   Slog.d(TAG,""String_Node_Str"");
synchronized (mListeners) {
    mListeners.remove(this);
    mToken.unlinkToDeath(this,0);
    for (int sensor=0; sensor < 32 && mSensors != 0; sensor++) {
      if (hasSensor(sensor)) {
        removeSensor(sensor);
        try {
          deactivateIfUnusedLocked(sensor);
        }
 catch (        RemoteException e) {
          Slog.w(TAG,""String_Node_Str"");
        }
      }
    }
    if (mListeners.size() == 0) {
      _sensors_control_wake();
      _sensors_control_close();
    }
    mListeners.notify();
  }
}","public void binderDied(){
  if (localLOGV)   Slog.d(TAG,""String_Node_Str"");
synchronized (mListeners) {
    mListeners.remove(this);
    mToken.unlinkToDeath(this,0);
    for (int sensor=0; sensor < 32 && mSensors != 0; sensor++) {
      if (hasSensor(sensor)) {
        removeSensor(sensor);
        deactivateIfUnusedLocked(sensor);
        try {
          mBatteryStats.noteStopSensor(mUid,sensor);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (mListeners.size() == 0) {
      _sensors_control_wake();
      _sensors_control_close();
    }
 else {
    }
    mListeners.notify();
  }
}",0.8865131578947368
182443,"void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  operation=new SyncOperation(operation);
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.tooManyRetries) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(new SyncOperation(operation.account,operation.syncSource,operation.authority,operation.extras,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS));
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}","void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  operation=new SyncOperation(operation);
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.tooManyRetries) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(new SyncOperation(operation.account,operation.syncSource,operation.authority,operation.extras,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000));
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}",0.9978401727861772
182444,"void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  operation=new SyncOperation(operation);
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.tooManyRetries) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(new SyncOperation(operation.account,operation.syncSource,operation.authority,operation.extras,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS));
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}","void maybeRescheduleSync(SyncResult syncResult,SyncOperation operation){
  boolean isLoggable=Log.isLoggable(TAG,Log.DEBUG);
  if (isLoggable) {
    Log.d(TAG,""String_Node_Str"" + syncResult + ""String_Node_Str""+ operation);
  }
  operation=new SyncOperation(operation);
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF);
  }
  if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY,false)) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (operation.extras.getBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD,false)) {
    operation.extras.remove(ContentResolver.SYNC_EXTRAS_UPLOAD);
    Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.tooManyRetries) {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
 else   if (syncResult.madeSomeProgress()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"");
    }
    scheduleSyncOperation(operation);
  }
 else   if (syncResult.syncAlreadyInProgress) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(new SyncOperation(operation.account,operation.syncSource,operation.authority,operation.extras,DELAY_RETRY_SYNC_IN_PROGRESS_IN_SECONDS * 1000));
  }
 else   if (syncResult.hasSoftError()) {
    if (isLoggable) {
      Log.d(TAG,""String_Node_Str"" + operation);
    }
    scheduleSyncOperation(operation);
  }
 else {
    Log.d(TAG,""String_Node_Str"" + operation);
  }
}",0.9978401727861772
182445,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=app.setSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  boolean normalMode=mSystemReady || isAllowedWhileBooting(app.info);
  List providers=normalMode ? generateApplicationProvidersLocked(app) : null;
  if (!normalMode) {
    Log.i(TAG,""String_Node_Str"" + app);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + processName + ""String_Node_Str""+ mConfiguration);
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode || !normalMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=app.lastLowMemory=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Log.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=app.setSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  boolean normalMode=mSystemReady || isAllowedWhileBooting(app.info);
  List providers=normalMode ? generateApplicationProvidersLocked(app) : null;
  if (!normalMode) {
    Log.i(TAG,""String_Node_Str"" + app);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    if (DEBUG_CONFIGURATION)     Log.v(TAG,""String_Node_Str"" + processName + ""String_Node_Str""+ mConfiguration);
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode || !normalMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=app.lastLowMemory=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
      br.state=BroadcastRecord.IDLE;
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Log.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}",0.99671607348895
182446,"private final void appDiedLocked(ProcessRecord app,int pid,IApplicationThread thread){
  mProcDeaths[0]++;
  if (app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ pid+ ""String_Node_Str""+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        long now=SystemClock.uptimeMillis();
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec != app && rec.thread != null && (rec.lastLowMemory + GC_MIN_INTERVAL) <= now) {
            if (rec.setAdj <= VISIBLE_APP_ADJ) {
              rec.lastRequestedGc=0;
            }
 else {
              rec.lastRequestedGc=rec.lastLowMemory;
            }
            rec.reportLowMemory=true;
            rec.lastLowMemory=now;
            mProcessesToGc.remove(rec);
            addProcessToGcListLocked(rec);
          }
        }
        scheduleAppGcsLocked();
      }
    }
  }
 else   if (Config.LOGD) {
    Log.d(TAG,""String_Node_Str"" + thread.asBinder());
  }
}","private final void appDiedLocked(ProcessRecord app,int pid,IApplicationThread thread){
  mProcDeaths[0]++;
  if (app.pid == pid && app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ pid+ ""String_Node_Str""+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        long now=SystemClock.uptimeMillis();
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec != app && rec.thread != null && (rec.lastLowMemory + GC_MIN_INTERVAL) <= now) {
            if (rec.setAdj <= VISIBLE_APP_ADJ) {
              rec.lastRequestedGc=0;
            }
 else {
              rec.lastRequestedGc=rec.lastLowMemory;
            }
            rec.reportLowMemory=true;
            rec.lastLowMemory=now;
            mProcessesToGc.remove(rec);
            addProcessToGcListLocked(rec);
          }
        }
        scheduleAppGcsLocked();
      }
    }
  }
 else   if (app.pid != pid) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str""+ app.pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,pid,app.processName);
  }
 else   if (Config.LOGD) {
    Log.d(TAG,""String_Node_Str"" + thread.asBinder());
  }
}",0.9275599128540304
182447,"public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  cancel();
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent,searchable);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}","public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent,searchable);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
  dismiss();
}",0.9772520473157416
182448,"/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mActivityContext=null;
  mUserQuery=null;
}","/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}",0.9522752497225304
182449,"/** 
 * Update the UI according to the info in the current value of   {@link #mSearchable}.
 */
private void updateUI(){
  if (mSearchable != null) {
    mDecor.setVisibility(View.VISIBLE);
    updateSearchAutoComplete();
    updateSearchButton();
    updateSearchAppIcon();
    updateSearchBadge();
    updateQueryHint();
    updateVoiceButton();
    int inputType=mSearchable.getInputType();
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
      inputType&=~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      if (mSearchable.getSuggestAuthority() != null) {
        inputType|=InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      }
    }
    mSearchAutoComplete.setInputType(inputType);
    mSearchAutoCompleteImeOptions=mSearchable.getImeOptions();
    mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
    if (mSearchable.getVoiceSearchEnabled()) {
      mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
 else {
      mSearchAutoComplete.setPrivateImeOptions(null);
    }
  }
}","/** 
 * Update the UI according to the info in the current value of   {@link #mSearchable}.
 */
private void updateUI(){
  if (mSearchable != null) {
    mDecor.setVisibility(View.VISIBLE);
    updateSearchAutoComplete();
    updateSearchButton();
    updateSearchAppIcon();
    updateSearchBadge();
    updateQueryHint();
    updateVoiceButton(TextUtils.isEmpty(mUserQuery));
    int inputType=mSearchable.getInputType();
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
      inputType&=~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      if (mSearchable.getSuggestAuthority() != null) {
        inputType|=InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      }
    }
    mSearchAutoComplete.setInputType(inputType);
    mSearchAutoCompleteImeOptions=mSearchable.getImeOptions();
    mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
    if (mSearchable.getVoiceSearchEnabled()) {
      mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
 else {
      mSearchAutoComplete.setPrivateImeOptions(null);
    }
  }
}",0.9862754377662092
182450,"public void onTextChanged(CharSequence s,int start,int before,int after){
  if (DBG_LOG_TIMING) {
    dbgLogTiming(""String_Node_Str"");
  }
  if (mSearchable == null) {
    return;
  }
  updateWidgetState();
  if (!mSearchAutoComplete.isPerformingCompletion()) {
    mUserQuery=s == null ? ""String_Node_Str"" : s.toString();
  }
}","public void onTextChanged(CharSequence s,int start,int before,int after){
  if (DBG_LOG_TIMING) {
    dbgLogTiming(""String_Node_Str"");
  }
  if (mSearchable == null) {
    return;
  }
  updateWidgetState();
  if (!mSearchAutoComplete.isPerformingCompletion()) {
    mUserQuery=s == null ? ""String_Node_Str"" : s.toString();
  }
  updateVoiceButton(TextUtils.isEmpty(s));
}",0.938483547925608
182451,"/** 
 * Update the visibility of the voice button.  There are actually two voice search modes,  either of which will activate the button.
 */
private void updateVoiceButton(){
  int visibility=View.GONE;
  if (mSearchable.getVoiceSearchEnabled()) {
    Intent testIntent=null;
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      testIntent=mVoiceWebSearchIntent;
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      testIntent=mVoiceAppSearchIntent;
    }
    if (testIntent != null) {
      ResolveInfo ri=getContext().getPackageManager().resolveActivity(testIntent,PackageManager.MATCH_DEFAULT_ONLY);
      if (ri != null) {
        visibility=View.VISIBLE;
      }
    }
  }
  mVoiceButton.setVisibility(visibility);
}","/** 
 * Update the visibility of the voice button.  There are actually two voice search modes,  either of which will activate the button.
 * @param empty whether the search query text field is empty. If it is, then the othercriteria apply to make the voice button visible. Otherwise the voice button will not be visible - i.e., if the user has typed a query, remove the voice button.
 */
private void updateVoiceButton(boolean empty){
  int visibility=View.GONE;
  if (mSearchable.getVoiceSearchEnabled() && empty) {
    Intent testIntent=null;
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      testIntent=mVoiceWebSearchIntent;
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      testIntent=mVoiceAppSearchIntent;
    }
    if (testIntent != null) {
      ResolveInfo ri=getContext().getPackageManager().resolveActivity(testIntent,PackageManager.MATCH_DEFAULT_ONLY);
      if (ri != null) {
        visibility=View.VISIBLE;
      }
    }
  }
  mVoiceButton.setVisibility(visibility);
}",0.848587570621469
182452,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float y=ev.getY();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  if (!inChild((int)ev.getX(),(int)y)) {
    mIsBeingDragged=false;
    return false;
  }
mLastMotionY=y;
break;
case MotionEvent.ACTION_MOVE:
if (mIsBeingDragged) {
final int deltaY=(int)(mLastMotionY - y);
mLastMotionY=y;
overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax());
break;
}
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity();
if (getChildCount() > 0) {
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
fling(-initialVelocity);
}
 else {
final int bottom=getScrollRange();
if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
  invalidate();
}
}
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax());
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.8089668615984406
182453,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
  final float y=ev.getY();
switch (action) {
case MotionEvent.ACTION_MOVE:
    final int yDiff=(int)Math.abs(y - mLastMotionY);
  if (yDiff > mTouchSlop) {
    mIsBeingDragged=true;
    mLastMotionY=y;
  }
break;
case MotionEvent.ACTION_DOWN:
if (!inChild((int)ev.getX(),(int)y)) {
mIsBeingDragged=false;
break;
}
mLastMotionY=y;
mIsBeingDragged=!mScroller.isFinished();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.7533527696793003
182454,"public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  cancel();
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent,searchable);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}","public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent,searchable);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
  dismiss();
}",0.9772520473157416
182455,"/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mActivityContext=null;
  mUserQuery=null;
}","/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}",0.9522752497225304
182456,"/** 
 * Update the UI according to the info in the current value of   {@link #mSearchable}.
 */
private void updateUI(){
  if (mSearchable != null) {
    mDecor.setVisibility(View.VISIBLE);
    updateSearchAutoComplete();
    updateSearchButton();
    updateSearchAppIcon();
    updateSearchBadge();
    updateQueryHint();
    updateVoiceButton();
    int inputType=mSearchable.getInputType();
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
      inputType&=~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      if (mSearchable.getSuggestAuthority() != null) {
        inputType|=InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      }
    }
    mSearchAutoComplete.setInputType(inputType);
    mSearchAutoCompleteImeOptions=mSearchable.getImeOptions();
    mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
    if (mSearchable.getVoiceSearchEnabled()) {
      mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
 else {
      mSearchAutoComplete.setPrivateImeOptions(null);
    }
  }
}","/** 
 * Update the UI according to the info in the current value of   {@link #mSearchable}.
 */
private void updateUI(){
  if (mSearchable != null) {
    mDecor.setVisibility(View.VISIBLE);
    updateSearchAutoComplete();
    updateSearchButton();
    updateSearchAppIcon();
    updateSearchBadge();
    updateQueryHint();
    updateVoiceButton(TextUtils.isEmpty(mUserQuery));
    int inputType=mSearchable.getInputType();
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
      inputType&=~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      if (mSearchable.getSuggestAuthority() != null) {
        inputType|=InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      }
    }
    mSearchAutoComplete.setInputType(inputType);
    mSearchAutoCompleteImeOptions=mSearchable.getImeOptions();
    mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
    if (mSearchable.getVoiceSearchEnabled()) {
      mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
 else {
      mSearchAutoComplete.setPrivateImeOptions(null);
    }
  }
}",0.9862754377662092
182457,"public void onTextChanged(CharSequence s,int start,int before,int after){
  if (DBG_LOG_TIMING) {
    dbgLogTiming(""String_Node_Str"");
  }
  if (mSearchable == null) {
    return;
  }
  updateWidgetState();
  if (!mSearchAutoComplete.isPerformingCompletion()) {
    mUserQuery=s == null ? ""String_Node_Str"" : s.toString();
  }
}","public void onTextChanged(CharSequence s,int start,int before,int after){
  if (DBG_LOG_TIMING) {
    dbgLogTiming(""String_Node_Str"");
  }
  if (mSearchable == null) {
    return;
  }
  updateWidgetState();
  if (!mSearchAutoComplete.isPerformingCompletion()) {
    mUserQuery=s == null ? ""String_Node_Str"" : s.toString();
  }
  updateVoiceButton(TextUtils.isEmpty(s));
}",0.938483547925608
182458,"/** 
 * Update the visibility of the voice button.  There are actually two voice search modes,  either of which will activate the button.
 */
private void updateVoiceButton(){
  int visibility=View.GONE;
  if (mSearchable.getVoiceSearchEnabled()) {
    Intent testIntent=null;
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      testIntent=mVoiceWebSearchIntent;
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      testIntent=mVoiceAppSearchIntent;
    }
    if (testIntent != null) {
      ResolveInfo ri=getContext().getPackageManager().resolveActivity(testIntent,PackageManager.MATCH_DEFAULT_ONLY);
      if (ri != null) {
        visibility=View.VISIBLE;
      }
    }
  }
  mVoiceButton.setVisibility(visibility);
}","/** 
 * Update the visibility of the voice button.  There are actually two voice search modes,  either of which will activate the button.
 * @param empty whether the search query text field is empty. If it is, then the othercriteria apply to make the voice button visible. Otherwise the voice button will not be visible - i.e., if the user has typed a query, remove the voice button.
 */
private void updateVoiceButton(boolean empty){
  int visibility=View.GONE;
  if (mSearchable.getVoiceSearchEnabled() && empty) {
    Intent testIntent=null;
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      testIntent=mVoiceWebSearchIntent;
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      testIntent=mVoiceAppSearchIntent;
    }
    if (testIntent != null) {
      ResolveInfo ri=getContext().getPackageManager().resolveActivity(testIntent,PackageManager.MATCH_DEFAULT_ONLY);
      if (ri != null) {
        visibility=View.VISIBLE;
      }
    }
  }
  mVoiceButton.setVisibility(visibility);
}",0.848587570621469
182459,"SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    db.addToCompiledQueries(sql,mCompiledSql);
    mCompiledSql.acquire();
  }
 else {
    if (!mCompiledSql.acquire()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
  }
  nStatement=mCompiledSql.nStatement;
}","SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    mCompiledSql.acquire();
    db.addToCompiledQueries(sql,mCompiledSql);
  }
 else {
    if (!mCompiledSql.acquire()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
  }
  nStatement=mCompiledSql.nStatement;
}",0.9452054794520548
182460,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float y=ev.getY();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  if (!inChild((int)ev.getX(),(int)y)) {
    mIsBeingDragged=false;
    return false;
  }
mLastMotionY=y;
break;
case MotionEvent.ACTION_MOVE:
if (mIsBeingDragged) {
final int deltaY=(int)(mLastMotionY - y);
mLastMotionY=y;
overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax());
break;
}
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity();
if (getChildCount() > 0) {
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
fling(-initialVelocity);
}
 else {
final int bottom=getScrollRange();
if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
  invalidate();
}
}
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax());
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.8089668615984406
182461,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
  final float y=ev.getY();
switch (action) {
case MotionEvent.ACTION_MOVE:
    final int yDiff=(int)Math.abs(y - mLastMotionY);
  if (yDiff > mTouchSlop) {
    mIsBeingDragged=true;
    mLastMotionY=y;
  }
break;
case MotionEvent.ACTION_DOWN:
if (!inChild((int)ev.getX(),(int)y)) {
mIsBeingDragged=false;
break;
}
mLastMotionY=y;
mIsBeingDragged=!mScroller.isFinished();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}",0.7533527696793003
182462,"final void releaseTheme(int theme){
synchronized (this) {
    deleteTheme(theme);
    decRefsLocked();
  }
}","final void releaseTheme(int theme){
synchronized (this) {
    deleteTheme(theme);
    decRefsLocked(theme);
  }
}",0.9773755656108596
182463,"private final void decRefsLocked(){
  mNumRefs--;
  if (mNumRefs == 0) {
    destroy();
  }
}","private final void decRefsLocked(int id){
  if (DEBUG_REFS && mRefStacks != null) {
    mRefStacks.remove(id);
  }
  mNumRefs--;
  if (mNumRefs == 0) {
    destroy();
  }
}",0.7018867924528301
182464,"final int createTheme(){
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    mNumRefs++;
    return newTheme();
  }
}","final int createTheme(){
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int res=newTheme();
    incRefsLocked(res);
    return res;
  }
}",0.8199445983379502
182465,"public final void close() throws IOException {
synchronized (AssetManager.this) {
    if (mAsset != 0) {
      destroyAsset(mAsset);
      mAsset=0;
      decRefsLocked();
    }
  }
}","public final void close() throws IOException {
synchronized (AssetManager.this) {
    if (mAsset != 0) {
      destroyAsset(mAsset);
      mAsset=0;
      decRefsLocked(hashCode());
    }
  }
}",0.973404255319149
182466,"private AssetManager(boolean isSystem){
  init();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + this);
}","private AssetManager(boolean isSystem){
  if (DEBUG_REFS) {
synchronized (this) {
      mNumRefs=0;
      incRefsLocked(this.hashCode());
    }
  }
  init();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + this);
}",0.6645962732919255
182467,"/** 
 * {@hide}Retrieve a non-asset as a compiled XML file.  Not for use by applications.
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 */
final XmlBlock openXmlBlockAsset(int cookie,String fileName) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int xmlBlock=openXmlAssetNative(cookie,fileName);
    if (xmlBlock != 0) {
      mNumRefs++;
      return new XmlBlock(this,xmlBlock);
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}","/** 
 * {@hide}Retrieve a non-asset as a compiled XML file.  Not for use by applications.
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 */
final XmlBlock openXmlBlockAsset(int cookie,String fileName) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int xmlBlock=openXmlAssetNative(cookie,fileName);
    if (xmlBlock != 0) {
      XmlBlock res=new XmlBlock(this,xmlBlock);
      incRefsLocked(res.hashCode());
      return res;
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}",0.9248181083265966
182468,"/** 
 * {@hide}Open a non-asset in a specified package.  Not for use by applications.
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 * @param accessMode Desired access mode for retrieving the data.
 */
public final InputStream openNonAsset(int cookie,String fileName,int accessMode) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int asset=openNonAssetNative(cookie,fileName,accessMode);
    if (asset != 0) {
      mNumRefs++;
      return new AssetInputStream(asset);
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}","/** 
 * {@hide}Open a non-asset in a specified package.  Not for use by applications.
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 * @param accessMode Desired access mode for retrieving the data.
 */
public final InputStream openNonAsset(int cookie,String fileName,int accessMode) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int asset=openNonAssetNative(cookie,fileName,accessMode);
    if (asset != 0) {
      AssetInputStream res=new AssetInputStream(asset);
      incRefsLocked(res.hashCode());
      return res;
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}",0.9189570119802678
182469,"void xmlBlockGone(){
synchronized (this) {
    decRefsLocked();
  }
}","void xmlBlockGone(int id){
synchronized (this) {
    decRefsLocked(id);
  }
}",0.9452054794520548
182470,"/** 
 * Open an asset using an explicit access mode, returning an InputStream to read its contents.  This provides access to files that have been bundled with an application as assets -- that is, files placed in to the ""assets"" directory.
 * @param fileName The name of the asset to open.  This name can behierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
public final InputStream open(String fileName,int accessMode) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int asset=openAsset(fileName,accessMode);
    if (asset != 0) {
      mNumRefs++;
      return new AssetInputStream(asset);
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}","/** 
 * Open an asset using an explicit access mode, returning an InputStream to read its contents.  This provides access to files that have been bundled with an application as assets -- that is, files placed in to the ""assets"" directory.
 * @param fileName The name of the asset to open.  This name can behierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
public final InputStream open(String fileName,int accessMode) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int asset=openAsset(fileName,accessMode);
    if (asset != 0) {
      AssetInputStream res=new AssetInputStream(asset);
      incRefsLocked(res.hashCode());
      return res;
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}",0.9373326191751472
182471,"private void decOpenCountLocked(){
  mOpenCount--;
  if (mOpenCount == 0) {
    nativeDestroy(mNative);
    if (mAssets != null) {
      mAssets.xmlBlockGone();
    }
  }
}","private void decOpenCountLocked(){
  mOpenCount--;
  if (mOpenCount == 0) {
    nativeDestroy(mNative);
    if (mAssets != null) {
      mAssets.xmlBlockGone(hashCode());
    }
  }
}",0.9717514124293786
182472,"public static final void installSystemProviders(){
  ProcessRecord app=mSelf.mProcessNames.get(""String_Node_Str"",Process.SYSTEM_UID);
  List providers=mSelf.generateApplicationProvidersLocked(app);
  mSystemThread.installSystemProviders(providers);
}","public static final void installSystemProviders(){
  ProcessRecord app=mSelf.mProcessNames.get(""String_Node_Str"",Process.SYSTEM_UID);
  List providers=mSelf.generateApplicationProvidersLocked(app);
  if (providers != null) {
    for (int i=providers.size() - 1; i >= 0; i--) {
      ProviderInfo pi=(ProviderInfo)providers.get(i);
      if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
        Log.w(TAG,""String_Node_Str"" + pi.name + ""String_Node_Str"");
        providers.remove(i);
      }
    }
  }
  mSystemThread.installSystemProviders(providers);
}",0.6075334143377886
182473,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9813034752297456
182474,"void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(uid);
  pw.print(""String_Node_Str"");
  pw.print(key.packageName);
  pw.print(""String_Node_Str"");
  pw.print(key.typeName());
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(key.flags));
  if (key.activity != null || key.who != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(key.activity);
    pw.print(""String_Node_Str"");
    pw.println(key.who);
  }
  if (key.requestCode != 0 || key.requestResolvedType != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(key.requestCode);
    pw.print(""String_Node_Str"");
    pw.println(key.requestResolvedType);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(key.requestIntent.toShortString(true,true));
  if (sent || canceled) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(sent);
    pw.print(""String_Node_Str"");
    pw.println(canceled);
  }
}","void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(uid);
  pw.print(""String_Node_Str"");
  pw.print(key.packageName);
  pw.print(""String_Node_Str"");
  pw.print(key.typeName());
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(key.flags));
  if (key.activity != null || key.who != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(key.activity);
    pw.print(""String_Node_Str"");
    pw.println(key.who);
  }
  if (key.requestCode != 0 || key.requestResolvedType != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(key.requestCode);
    pw.print(""String_Node_Str"");
    pw.println(key.requestResolvedType);
  }
  if (key.requestIntent != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(key.requestIntent.toShortString(true,true));
  }
  if (sent || canceled) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(sent);
    pw.print(""String_Node_Str"");
    pw.println(canceled);
  }
}",0.9380185456320156
182475,"SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    db.addToCompiledQueries(sql,mCompiledSql);
    mCompiledSql.acquire();
  }
 else {
    if (!mCompiledSql.acquire()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
  }
  nStatement=mCompiledSql.nStatement;
}","SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    mCompiledSql.acquire();
    db.addToCompiledQueries(sql,mCompiledSql);
  }
 else {
    if (!mCompiledSql.acquire()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
  }
  nStatement=mCompiledSql.nStatement;
}",0.9452054794520548
182476,"public int renameSecureContainer(String oldId,String newId){
  validatePermission(android.Manifest.permission.ASEC_RENAME);
  waitForReady();
  warnOnNotMounted();
synchronized (mAsecMountSet) {
    if (mAsecMountSet.contains(oldId)) {
      return StorageResultCode.OperationFailedStorageMounted;
    }
  }
  int rc=StorageResultCode.OperationSucceeded;
  String cmd=String.format(""String_Node_Str"",oldId,newId);
  try {
    mConnector.doCommand(cmd);
  }
 catch (  NativeDaemonConnectorException e) {
    rc=StorageResultCode.OperationFailedInternalError;
  }
  return rc;
}","public int renameSecureContainer(String oldId,String newId){
  validatePermission(android.Manifest.permission.ASEC_RENAME);
  waitForReady();
  warnOnNotMounted();
synchronized (mAsecMountSet) {
    if (mAsecMountSet.contains(oldId) || mAsecMountSet.contains(newId)) {
      return StorageResultCode.OperationFailedStorageMounted;
    }
  }
  int rc=StorageResultCode.OperationSucceeded;
  String cmd=String.format(""String_Node_Str"",oldId,newId);
  try {
    mConnector.doCommand(cmd);
  }
 catch (  NativeDaemonConnectorException e) {
    rc=StorageResultCode.OperationFailedInternalError;
  }
  return rc;
}",0.9721518987341772
182477,"private static void addPropertiesForRuleStr(ICalendar.Component component,String propertyName,String ruleStr){
  if (TextUtils.isEmpty(ruleStr)) {
    return;
  }
  String[] rrules=ruleStr.split(RULE_SEPARATOR);
  for (  String rrule : rrules) {
    ICalendar.Property prop=new ICalendar.Property(propertyName);
    prop.setValue(rrule);
    component.addProperty(prop);
  }
}","private static void addPropertiesForRuleStr(ICalendar.Component component,String propertyName,String ruleStr){
  if (TextUtils.isEmpty(ruleStr)) {
    return;
  }
  String[] rrules=getRuleStrings(ruleStr);
  for (  String rrule : rrules) {
    ICalendar.Property prop=new ICalendar.Property(propertyName);
    prop.setValue(rrule);
    component.addProperty(prop);
  }
}",0.935656836461126
182478,"public static boolean populateComponent(ContentValues values,ICalendar.Component component){
  long dtstart=-1;
  if (values.containsKey(Calendar.Events.DTSTART)) {
    dtstart=values.getAsLong(Calendar.Events.DTSTART);
  }
  String duration=values.getAsString(Calendar.Events.DURATION);
  String tzid=values.getAsString(Calendar.Events.EVENT_TIMEZONE);
  String rruleStr=values.getAsString(Calendar.Events.RRULE);
  String rdateStr=values.getAsString(Calendar.Events.RDATE);
  String exruleStr=values.getAsString(Calendar.Events.EXRULE);
  String exdateStr=values.getAsString(Calendar.Events.EXDATE);
  boolean allDay=values.getAsInteger(Calendar.Events.ALL_DAY) == 1;
  if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
    return false;
  }
  ICalendar.Property dtstartProp=new ICalendar.Property(""String_Node_Str"");
  Time dtstartTime=null;
  if (!TextUtils.isEmpty(tzid)) {
    if (!allDay) {
      dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",tzid));
    }
    dtstartTime=new Time(tzid);
  }
 else {
    dtstartTime=new Time(Time.TIMEZONE_UTC);
  }
  dtstartTime.set(dtstart);
  if (allDay) {
    dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",""String_Node_Str""));
    dtstartTime.allDay=true;
    dtstartTime.hour=0;
    dtstartTime.minute=0;
    dtstartTime.second=0;
  }
  dtstartProp.setValue(dtstartTime.format2445());
  component.addProperty(dtstartProp);
  ICalendar.Property durationProp=new ICalendar.Property(""String_Node_Str"");
  durationProp.setValue(duration);
  component.addProperty(durationProp);
  addPropertiesForRuleStr(component,""String_Node_Str"",rruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",rdateStr);
  addPropertiesForRuleStr(component,""String_Node_Str"",exruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",exdateStr);
  return true;
}","public static boolean populateComponent(ContentValues values,ICalendar.Component component){
  long dtstart=-1;
  if (values.containsKey(Calendar.Events.DTSTART)) {
    dtstart=values.getAsLong(Calendar.Events.DTSTART);
  }
  String duration=values.getAsString(Calendar.Events.DURATION);
  String tzid=values.getAsString(Calendar.Events.EVENT_TIMEZONE);
  String rruleStr=values.getAsString(Calendar.Events.RRULE);
  String rdateStr=values.getAsString(Calendar.Events.RDATE);
  String exruleStr=values.getAsString(Calendar.Events.EXRULE);
  String exdateStr=values.getAsString(Calendar.Events.EXDATE);
  Integer allDayInteger=values.getAsInteger(Calendar.Events.ALL_DAY);
  boolean allDay=(null != allDayInteger) ? (allDayInteger == 1) : false;
  if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
    return false;
  }
  ICalendar.Property dtstartProp=new ICalendar.Property(""String_Node_Str"");
  Time dtstartTime=null;
  if (!TextUtils.isEmpty(tzid)) {
    if (!allDay) {
      dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",tzid));
    }
    dtstartTime=new Time(tzid);
  }
 else {
    dtstartTime=new Time(Time.TIMEZONE_UTC);
  }
  dtstartTime.set(dtstart);
  if (allDay) {
    dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",""String_Node_Str""));
    dtstartTime.allDay=true;
    dtstartTime.hour=0;
    dtstartTime.minute=0;
    dtstartTime.second=0;
  }
  dtstartProp.setValue(dtstartTime.format2445());
  component.addProperty(dtstartProp);
  ICalendar.Property durationProp=new ICalendar.Property(""String_Node_Str"");
  durationProp.setValue(duration);
  component.addProperty(durationProp);
  addPropertiesForRuleStr(component,""String_Node_Str"",rruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",rdateStr);
  addPropertiesForRuleStr(component,""String_Node_Str"",exruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",exdateStr);
  return true;
}",0.9771501925545572
182479,"private static void addPropertiesForRuleStr(ICalendar.Component component,String propertyName,String ruleStr){
  if (TextUtils.isEmpty(ruleStr)) {
    return;
  }
  String[] rrules=ruleStr.split(RULE_SEPARATOR);
  for (  String rrule : rrules) {
    ICalendar.Property prop=new ICalendar.Property(propertyName);
    prop.setValue(rrule);
    component.addProperty(prop);
  }
}","private static void addPropertiesForRuleStr(ICalendar.Component component,String propertyName,String ruleStr){
  if (TextUtils.isEmpty(ruleStr)) {
    return;
  }
  String[] rrules=getRuleStrings(ruleStr);
  for (  String rrule : rrules) {
    ICalendar.Property prop=new ICalendar.Property(propertyName);
    prop.setValue(rrule);
    component.addProperty(prop);
  }
}",0.935656836461126
182480,"public static boolean populateComponent(ContentValues values,ICalendar.Component component){
  long dtstart=-1;
  if (values.containsKey(Calendar.Events.DTSTART)) {
    dtstart=values.getAsLong(Calendar.Events.DTSTART);
  }
  String duration=values.getAsString(Calendar.Events.DURATION);
  String tzid=values.getAsString(Calendar.Events.EVENT_TIMEZONE);
  String rruleStr=values.getAsString(Calendar.Events.RRULE);
  String rdateStr=values.getAsString(Calendar.Events.RDATE);
  String exruleStr=values.getAsString(Calendar.Events.EXRULE);
  String exdateStr=values.getAsString(Calendar.Events.EXDATE);
  boolean allDay=values.getAsInteger(Calendar.Events.ALL_DAY) == 1;
  if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
    return false;
  }
  ICalendar.Property dtstartProp=new ICalendar.Property(""String_Node_Str"");
  Time dtstartTime=null;
  if (!TextUtils.isEmpty(tzid)) {
    if (!allDay) {
      dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",tzid));
    }
    dtstartTime=new Time(tzid);
  }
 else {
    dtstartTime=new Time(Time.TIMEZONE_UTC);
  }
  dtstartTime.set(dtstart);
  if (allDay) {
    dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",""String_Node_Str""));
    dtstartTime.allDay=true;
    dtstartTime.hour=0;
    dtstartTime.minute=0;
    dtstartTime.second=0;
  }
  dtstartProp.setValue(dtstartTime.format2445());
  component.addProperty(dtstartProp);
  ICalendar.Property durationProp=new ICalendar.Property(""String_Node_Str"");
  durationProp.setValue(duration);
  component.addProperty(durationProp);
  addPropertiesForRuleStr(component,""String_Node_Str"",rruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",rdateStr);
  addPropertiesForRuleStr(component,""String_Node_Str"",exruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",exdateStr);
  return true;
}","public static boolean populateComponent(ContentValues values,ICalendar.Component component){
  long dtstart=-1;
  if (values.containsKey(Calendar.Events.DTSTART)) {
    dtstart=values.getAsLong(Calendar.Events.DTSTART);
  }
  String duration=values.getAsString(Calendar.Events.DURATION);
  String tzid=values.getAsString(Calendar.Events.EVENT_TIMEZONE);
  String rruleStr=values.getAsString(Calendar.Events.RRULE);
  String rdateStr=values.getAsString(Calendar.Events.RDATE);
  String exruleStr=values.getAsString(Calendar.Events.EXRULE);
  String exdateStr=values.getAsString(Calendar.Events.EXDATE);
  Integer allDayInteger=values.getAsInteger(Calendar.Events.ALL_DAY);
  boolean allDay=(null != allDayInteger) ? (allDayInteger == 1) : false;
  if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
    return false;
  }
  ICalendar.Property dtstartProp=new ICalendar.Property(""String_Node_Str"");
  Time dtstartTime=null;
  if (!TextUtils.isEmpty(tzid)) {
    if (!allDay) {
      dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",tzid));
    }
    dtstartTime=new Time(tzid);
  }
 else {
    dtstartTime=new Time(Time.TIMEZONE_UTC);
  }
  dtstartTime.set(dtstart);
  if (allDay) {
    dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",""String_Node_Str""));
    dtstartTime.allDay=true;
    dtstartTime.hour=0;
    dtstartTime.minute=0;
    dtstartTime.second=0;
  }
  dtstartProp.setValue(dtstartTime.format2445());
  component.addProperty(dtstartProp);
  ICalendar.Property durationProp=new ICalendar.Property(""String_Node_Str"");
  durationProp.setValue(duration);
  component.addProperty(durationProp);
  addPropertiesForRuleStr(component,""String_Node_Str"",rruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",rdateStr);
  addPropertiesForRuleStr(component,""String_Node_Str"",exruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",exdateStr);
  return true;
}",0.9771501925545572
182481,"public int renameSecureContainer(String oldId,String newId){
  validatePermission(android.Manifest.permission.ASEC_RENAME);
  waitForReady();
  warnOnNotMounted();
synchronized (mAsecMountSet) {
    if (mAsecMountSet.contains(oldId)) {
      return StorageResultCode.OperationFailedStorageMounted;
    }
  }
  int rc=StorageResultCode.OperationSucceeded;
  String cmd=String.format(""String_Node_Str"",oldId,newId);
  try {
    mConnector.doCommand(cmd);
  }
 catch (  NativeDaemonConnectorException e) {
    rc=StorageResultCode.OperationFailedInternalError;
  }
  return rc;
}","public int renameSecureContainer(String oldId,String newId){
  validatePermission(android.Manifest.permission.ASEC_RENAME);
  waitForReady();
  warnOnNotMounted();
synchronized (mAsecMountSet) {
    if (mAsecMountSet.contains(oldId) || mAsecMountSet.contains(newId)) {
      return StorageResultCode.OperationFailedStorageMounted;
    }
  }
  int rc=StorageResultCode.OperationSucceeded;
  String cmd=String.format(""String_Node_Str"",oldId,newId);
  try {
    mConnector.doCommand(cmd);
  }
 catch (  NativeDaemonConnectorException e) {
    rc=StorageResultCode.OperationFailedInternalError;
  }
  return rc;
}",0.9721518987341772
182482,"private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    Bundle oldState=r.state;
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        r.state=oldState;
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.977149979227254
182483,"private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ContextImpl appContext=new ContextImpl();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
      r.state=null;
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}","private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ContextImpl appContext=new ContextImpl();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}",0.9972602739726028
182484,"public StopwatchTimer getWakeTimerLocked(String name,int type){
  Wakelock wl=mWakelockStats.get(name);
  if (wl == null) {
    wl=new Wakelock();
    mWakelockStats.put(name,wl);
  }
  StopwatchTimer t=null;
switch (type) {
case WAKE_TYPE_PARTIAL:
    t=wl.mTimerPartial;
  if (t == null) {
    t=new StopwatchTimer(WAKE_TYPE_PARTIAL,mPartialTimers,mUnpluggables);
    wl.mTimerPartial=t;
  }
return t;
case WAKE_TYPE_FULL:
t=wl.mTimerFull;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_FULL,mFullTimers,mUnpluggables);
wl.mTimerFull=t;
}
return t;
case WAKE_TYPE_WINDOW:
t=wl.mTimerWindow;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_WINDOW,mWindowTimers,mUnpluggables);
wl.mTimerWindow=t;
}
return t;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}","public StopwatchTimer getWakeTimerLocked(String name,int type){
  Wakelock wl=mWakelockStats.get(name);
  if (wl == null) {
    if (mWakelockStats.size() > MAX_WAKELOCKS_PER_UID) {
      name=BATCHED_WAKELOCK_NAME;
      wl=mWakelockStats.get(name);
    }
    if (wl == null) {
      wl=new Wakelock();
      mWakelockStats.put(name,wl);
    }
  }
  StopwatchTimer t=null;
switch (type) {
case WAKE_TYPE_PARTIAL:
    t=wl.mTimerPartial;
  if (t == null) {
    t=new StopwatchTimer(WAKE_TYPE_PARTIAL,mPartialTimers,mUnpluggables);
    wl.mTimerPartial=t;
  }
return t;
case WAKE_TYPE_FULL:
t=wl.mTimerFull;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_FULL,mFullTimers,mUnpluggables);
wl.mTimerFull=t;
}
return t;
case WAKE_TYPE_WINDOW:
t=wl.mTimerWindow;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_WINDOW,mWindowTimers,mUnpluggables);
wl.mTimerWindow=t;
}
return t;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}",0.8788927335640139
182485,"private PackageSetting getPackageLP(String name,PackageSetting origPackage,String realName,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      if ((p != null) && ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        Log.w(TAG,""String_Node_Str"" + p.codePathString + ""String_Node_Str""+ codePath.toString());
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
    }
    if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
 else {
      if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        p.pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    if (origPackage != null) {
      p=new PackageSetting(origPackage.name,name,codePath,resourcePath,vc,pkgFlags);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ origPackage.name);
      p.copyFrom(origPackage);
      p.sharedUser=origPackage.sharedUser;
      p.userId=origPackage.userId;
      p.origPackage=origPackage;
      mRenamedPackages.put(name,origPackage.name);
      name=origPackage.name;
      p.setTimeStamp(codePath.lastModified());
    }
 else {
      p=new PackageSetting(name,realName,codePath,resourcePath,vc,pkgFlags);
      p.setTimeStamp(codePath.lastModified());
      p.sharedUser=sharedUser;
      if (sharedUser != null) {
        p.userId=sharedUser.userId;
      }
 else       if (MULTIPLE_APPLICATION_UIDS) {
        PackageSetting dis=mDisabledSysPackages.get(name);
        if (dis != null) {
          if (dis.signatures.mSignatures != null) {
            p.signatures.mSignatures=dis.signatures.mSignatures.clone();
          }
          p.userId=dis.userId;
          p.grantedPermissions=new HashSet<String>(dis.grantedPermissions);
          p.loadedPermissions=new HashSet<String>(dis.loadedPermissions);
          p.disabledComponents=new HashSet<String>(dis.disabledComponents);
          p.enabledComponents=new HashSet<String>(dis.enabledComponents);
          addUserIdLP(p.userId,p,name);
        }
 else {
          p.userId=newUserIdLP(p);
        }
      }
 else {
        p.userId=FIRST_APPLICATION_UID;
      }
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      addPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,PackageSetting origPackage,String realName,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      if ((p != null) && ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        Log.w(TAG,""String_Node_Str"" + p.codePathString + ""String_Node_Str""+ codePath.toString());
      }
 else {
        Log.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
    }
    if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
 else {
      if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        p.pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    if (origPackage != null) {
      p=new PackageSetting(origPackage.name,name,codePath,resourcePath,vc,pkgFlags);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ origPackage.name);
      p.copyFrom(origPackage);
      p.sharedUser=origPackage.sharedUser;
      p.userId=origPackage.userId;
      p.origPackage=origPackage;
      mRenamedPackages.put(name,origPackage.name);
      name=origPackage.name;
      p.setTimeStamp(codePath.lastModified());
    }
 else {
      p=new PackageSetting(name,realName,codePath,resourcePath,vc,pkgFlags);
      p.setTimeStamp(codePath.lastModified());
      p.sharedUser=sharedUser;
      if (sharedUser != null) {
        p.userId=sharedUser.userId;
      }
 else       if (MULTIPLE_APPLICATION_UIDS) {
        PackageSetting dis=mDisabledSysPackages.get(name);
        if (dis != null) {
          if (dis.signatures.mSignatures != null) {
            p.signatures.mSignatures=dis.signatures.mSignatures.clone();
          }
          p.userId=dis.userId;
          p.grantedPermissions=new HashSet<String>(dis.grantedPermissions);
          p.loadedPermissions=new HashSet<String>(dis.loadedPermissions);
          p.disabledComponents=new HashSet<String>(dis.disabledComponents);
          p.enabledComponents=new HashSet<String>(dis.enabledComponents);
          addUserIdLP(p.userId,p,name);
        }
 else {
          p.userId=newUserIdLP(p);
        }
      }
 else {
        p.userId=FIRST_APPLICATION_UID;
      }
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      addPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.9949433304272014
182486,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    if (deletedPs != null) {
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.8495264819361628
182487,"private void revokeUriPermissionLocked(int callingUid,Uri uri,int modeFlags){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  final IPackageManager pm=ActivityThread.getPackageManager();
  final String authority=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(authority);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(authority,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + authority);
    return;
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
  }
  final List<String> SEGMENTS=uri.getPathSegments();
  if (SEGMENTS != null) {
    final int NS=SEGMENTS.size();
    int N=mGrantedUriPermissions.size();
    for (int i=0; i < N; i++) {
      HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.valueAt(i);
      Iterator<UriPermission> it=perms.values().iterator();
      toploop:       while (it.hasNext()) {
        UriPermission perm=it.next();
        Uri targetUri=perm.uri;
        if (!authority.equals(targetUri.getAuthority())) {
          continue;
        }
        List<String> targetSegments=targetUri.getPathSegments();
        if (targetSegments == null) {
          continue;
        }
        if (targetSegments.size() < NS) {
          continue;
        }
        for (int j=0; j < NS; j++) {
          if (!SEGMENTS.get(j).equals(targetSegments.get(j))) {
            continue toploop;
          }
        }
        perm.clearModes(modeFlags);
        if (perm.modeFlags == 0) {
          it.remove();
        }
      }
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(mGrantedUriPermissions.keyAt(i));
        N--;
        i--;
      }
    }
  }
}","private void revokeUriPermissionLocked(int callingUid,Uri uri,int modeFlags){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + uri);
  final IPackageManager pm=ActivityThread.getPackageManager();
  final String authority=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(authority);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(authority,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + authority);
    return;
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
  }
  final List<String> SEGMENTS=uri.getPathSegments();
  if (SEGMENTS != null) {
    final int NS=SEGMENTS.size();
    int N=mGrantedUriPermissions.size();
    for (int i=0; i < N; i++) {
      HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.valueAt(i);
      Iterator<UriPermission> it=perms.values().iterator();
      toploop:       while (it.hasNext()) {
        UriPermission perm=it.next();
        Uri targetUri=perm.uri;
        if (!authority.equals(targetUri.getAuthority())) {
          continue;
        }
        List<String> targetSegments=targetUri.getPathSegments();
        if (targetSegments == null) {
          continue;
        }
        if (targetSegments.size() < NS) {
          continue;
        }
        for (int j=0; j < NS; j++) {
          if (!SEGMENTS.get(j).equals(targetSegments.get(j))) {
            continue toploop;
          }
        }
        if (DEBUG_URI_PERMISSION)         Log.v(TAG,""String_Node_Str"" + perm.uid + ""String_Node_Str""+ perm.uri);
        perm.clearModes(modeFlags);
        if (perm.modeFlags == 0) {
          it.remove();
        }
      }
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(mGrantedUriPermissions.keyAt(i));
        N--;
        i--;
      }
    }
  }
}",0.9574518659377228
182488,"private void removeUriPermissionIfNeededLocked(UriPermission perm){
  if ((perm.modeFlags & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) == 0) {
    HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(perm.uid);
    if (perms != null) {
      perms.remove(perm.uri);
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(perm.uid);
      }
    }
  }
}","private void removeUriPermissionIfNeededLocked(UriPermission perm){
  if ((perm.modeFlags & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) == 0) {
    HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(perm.uid);
    if (perms != null) {
      if (DEBUG_URI_PERMISSION)       Log.v(TAG,""String_Node_Str"" + perm.uid + ""String_Node_Str""+ perm.uri);
      perms.remove(perm.uri);
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(perm.uid);
      }
    }
  }
}",0.882921589688507
182489,"private void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,HistoryRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  final IPackageManager pm=ActivityThread.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    return;
  }
  if (checkUriPermissionLocked(uri,targetUid,modeFlags)) {
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}","private void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,HistoryRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  final IPackageManager pm=ActivityThread.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    if (DEBUG_URI_PERMISSION)     Log.v(TAG,""String_Node_Str"" + uri);
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      if (DEBUG_URI_PERMISSION)       Log.v(TAG,""String_Node_Str"" + targetPkg);
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    if (DEBUG_URI_PERMISSION)     Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}",0.921531701192718
182490,"public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.918763479511143
182491,"protected void finalize() throws Throwable {
  if (!canceled) {
synchronized (owner) {
      WeakReference<PendingIntentRecord> current=owner.mIntentSenderRecords.get(key);
      if (current == ref) {
        owner.mIntentSenderRecords.remove(key);
      }
    }
  }
}","protected void finalize() throws Throwable {
  try {
    if (!canceled) {
      owner.mHandler.sendMessage(owner.mHandler.obtainMessage(ActivityManagerService.FINALIZE_PENDING_INTENT_MSG,this));
    }
  }
  finally {
    super.finalize();
  }
}",0.2890625
182492,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,localForegroundId,null,true);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.9445482866043614
182493,"public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.9839743589743588
182494,"public void run(){
  INotificationManager inm=NotificationManager.getService();
  if (inm == null) {
    return;
  }
  try {
    inm.cancelNotification(localPackageName,localForegroundId);
  }
 catch (  RuntimeException e) {
    Log.w(ActivityManagerService.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
  }
catch (  RemoteException e) {
  }
}","public void run(){
  INotificationManager inm=NotificationManager.getService();
  if (inm == null) {
    return;
  }
  try {
    inm.cancelNotification(localPackageName,localForegroundId);
  }
 catch (  RuntimeException e) {
    Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
  }
catch (  RemoteException e) {
  }
}",0.96996996996997
182495,"/** 
 * Gets an auth token of the specified type for a particular account, optionally raising a notification if the user must enter credentials. This method is intended for background tasks and services where the user should not be immediately interrupted with a password prompt. <p>If a previously generated auth token is cached for this account and type, then it will be returned.  Otherwise, if we have saved credentials the server accepts, it will be used to generate a new auth token. Otherwise, an Intent will be returned which, when started, will prompt the user for a password.  If the notifyAuthFailure parameter is set, the same Intent will be associated with a status bar notification, alerting the user that they need to enter a password at some point. <p>If the intent is left in a notification, you will need to wait until the user gets around to entering a password before trying again, which could be hours or days or never.  When it does happen, the account manager will broadcast the   {@link #LOGIN_ACCOUNTS_CHANGED_ACTION}{@link Intent}, which applications can use to trigger another attempt to fetch an auth token. <p>If notifications are not enabled, it is the application's responsibility to launch the returned intent at some point to let the user enter credentials.  In either case, the result from this call will not wait for user action. <p>The value of the auth token type depends on the authenticator. Some services use different tokens to access different functionality -- for example, Google uses different auth tokens to access Gmail and Google Calendar for the same account. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#USE_CREDENTIALS}.
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependentstring token, must not be null
 * @param options Authenticator-specific options for the request,may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt theuser for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withat least the following fields on success: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account<li>  {@link #KEY_AUTHTOKEN} - the auth token you wanted</ul> (Other authenticator-specific values may be returned.)  If the user must enter credentials, the returned Bundle contains only {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.<p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if the authenticator failed to respond<li>  {@link OperationCanceledException} if the operation is canceled forany reason, incluidng the user canceling a credential request <li>  {@link IOException} if the authenticator experienced an I/O problemcreating a new auth token, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> getAuthToken(final Account account,final String authTokenType,final boolean notifyAuthFailure,AccountManagerCallback<Bundle> callback,Handler handler){
  if (account == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (authTokenType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  return new AmsTask(null,handler,callback){
    public void doWork() throws RemoteException {
      mService.getAuthToken(mResponse,account,authTokenType,notifyAuthFailure,false,null);
    }
  }
.start();
}","/** 
 * Gets an auth token of the specified type for a particular account, optionally raising a notification if the user must enter credentials. This method is intended for background tasks and services where the user should not be immediately interrupted with a password prompt. <p>If a previously generated auth token is cached for this account and type, then it will be returned.  Otherwise, if we have saved credentials the server accepts, it will be used to generate a new auth token. Otherwise, an Intent will be returned which, when started, will prompt the user for a password.  If the notifyAuthFailure parameter is set, the same Intent will be associated with a status bar notification, alerting the user that they need to enter a password at some point. <p>If the intent is left in a notification, you will need to wait until the user gets around to entering a password before trying again, which could be hours or days or never.  When it does happen, the account manager will broadcast the   {@link #LOGIN_ACCOUNTS_CHANGED_ACTION}{@link Intent}, which applications can use to trigger another attempt to fetch an auth token. <p>If notifications are not enabled, it is the application's responsibility to launch the returned intent at some point to let the user enter credentials.  In either case, the result from this call will not wait for user action. <p>The value of the auth token type depends on the authenticator. Some services use different tokens to access different functionality -- for example, Google uses different auth tokens to access Gmail and Google Calendar for the same account. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#USE_CREDENTIALS}.
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependentstring token, must not be null
 * @param notifyAuthFailure True to add a notification to prompt theuser for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withat least the following fields on success: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account<li>  {@link #KEY_AUTHTOKEN} - the auth token you wanted</ul> (Other authenticator-specific values may be returned.)  If the user must enter credentials, the returned Bundle contains only {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.<p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if the authenticator failed to respond<li>  {@link OperationCanceledException} if the operation is canceled forany reason, incluidng the user canceling a credential request <li>  {@link IOException} if the authenticator experienced an I/O problemcreating a new auth token, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> getAuthToken(final Account account,final String authTokenType,final boolean notifyAuthFailure,AccountManagerCallback<Bundle> callback,Handler handler){
  if (account == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (authTokenType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  return new AmsTask(null,handler,callback){
    public void doWork() throws RemoteException {
      mService.getAuthToken(mResponse,account,authTokenType,notifyAuthFailure,false,null);
    }
  }
.start();
}",0.988871635610766
182496,"/** 
 * Asks the user to add an account of a specified type.  The authenticator for this account type processes this request with the appropriate user interface.  If the user does elect to create a new account, the account name is returned. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken}) this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,may be null or empty
 * @param activity The {@link Activity} context to use for launching a newauthenticator-defined sub-Activity to prompt the user to create an account; used only to call startActivity(); if null, the prompt will not be launched directly, but the necessary  {@link Intent}will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFeature} which resolves to a Bundle withthese fields if activity was specified and an account was created: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account created<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account</ul> If no activity was specified, the returned Bundle contains only {@link #KEY_INTENT} with the {@link Intent} needed to launch theactual account creation process. <p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if no authenticator was registered forthis account type or the authenticator failed to respond <li>  {@link OperationCanceledException} if the operation was canceled forany reason, including the user canceling the creation process <li>  {@link IOException} if the authenticator experienced an I/O problemcreating a new account, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> addAccount(final String accountType,final String authTokenType,final String[] requiredFeatures,final Bundle addAccountOptions,final Activity activity,AccountManagerCallback<Bundle> callback,Handler handler){
  return new AmsTask(activity,handler,callback){
    public void doWork() throws RemoteException {
      if (accountType == null) {
        Log.e(TAG,""String_Node_Str"");
        set(new Bundle());
        return;
      }
      mService.addAcount(mResponse,accountType,authTokenType,requiredFeatures,activity != null,addAccountOptions);
    }
  }
.start();
}","/** 
 * Asks the user to add an account of a specified type.  The authenticator for this account type processes this request with the appropriate user interface.  If the user does elect to create a new account, the account name is returned. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken}) this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,may be null or empty
 * @param activity The {@link Activity} context to use for launching a newauthenticator-defined sub-Activity to prompt the user to create an account; used only to call startActivity(); if null, the prompt will not be launched directly, but the necessary  {@link Intent}will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withthese fields if activity was specified and an account was created: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account created<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account</ul> If no activity was specified, the returned Bundle contains only {@link #KEY_INTENT} with the {@link Intent} needed to launch theactual account creation process. <p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if no authenticator was registered forthis account type or the authenticator failed to respond <li>  {@link OperationCanceledException} if the operation was canceled forany reason, including the user canceling the creation process <li>  {@link IOException} if the authenticator experienced an I/O problemcreating a new account, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> addAccount(final String accountType,final String authTokenType,final String[] requiredFeatures,final Bundle addAccountOptions,final Activity activity,AccountManagerCallback<Bundle> callback,Handler handler){
  return new AmsTask(activity,handler,callback){
    public void doWork() throws RemoteException {
      if (accountType == null) {
        Log.e(TAG,""String_Node_Str"");
        set(new Bundle());
        return;
      }
      mService.addAcount(mResponse,accountType,authTokenType,requiredFeatures,activity != null,addAccountOptions);
    }
  }
.start();
}",0.999481954757382
182497,"/** 
 * This convenience helper combines the functionality of  {@link #getAccountsByTypeAndFeatures},   {@link #getAuthToken}, and  {@link #addAccount}. <p>This method gets a list of the accounts matching the specified type and feature set; if there is exactly one, it is used; if there are more than one, the user is prompted to pick one; if there are none, the user is prompted to add one.  Finally, an auth token is acquired for the chosen account. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType The account type required(see  {@link getAccountsByType}), must not be null
 * @param authTokenType The desired auth token type(see  {@link #getAuthToken}), must not be null
 * @param features Required features for the account(see  {@link #getAccountsByTypeAndFeatures}), may be null or empty
 * @param activity The {@link Activity} context to use for launching newsub-Activities to prompt to add an account, select an account, and/or enter a password, as necessary; used only to call startActivity(); should not be null
 * @param addAccountOptions Authenticator-specific options to use foradding new accounts; may be null or empty
 * @param getAuthTokenOptions Authenticator-specific options to use forgetting auth tokens; may be null or empty
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withat least the following fields: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account<li>  {@link #KEY_AUTHTOKEN} - the auth token you wanted</ul> <p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if no authenticator was registered forthis account type or the authenticator failed to respond <li>  {@link OperationCanceledException} if the operation was canceled forany reason, including the user canceling any operation <li>  {@link IOException} if the authenticator experienced an I/O problemupdating settings, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> getAuthTokenByFeatures(final String accountType,final String authTokenType,final String[] features,final Activity activity,final Bundle addAccountOptions,final Bundle getAuthTokenOptions,final AccountManagerCallback<Bundle> callback,final Handler handler){
  if (accountType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (authTokenType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  final GetAuthTokenByTypeAndFeaturesTask task=new GetAuthTokenByTypeAndFeaturesTask(accountType,authTokenType,features,activity,addAccountOptions,getAuthTokenOptions,callback,handler);
  task.start();
  return task;
}","/** 
 * This convenience helper combines the functionality of  {@link #getAccountsByTypeAndFeatures},   {@link #getAuthToken}, and  {@link #addAccount}. <p>This method gets a list of the accounts matching the specified type and feature set; if there is exactly one, it is used; if there are more than one, the user is prompted to pick one; if there are none, the user is prompted to add one.  Finally, an auth token is acquired for the chosen account. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType The account type required(see  {@link #getAccountsByType}), must not be null
 * @param authTokenType The desired auth token type(see  {@link #getAuthToken}), must not be null
 * @param features Required features for the account(see  {@link #getAccountsByTypeAndFeatures}), may be null or empty
 * @param activity The {@link Activity} context to use for launching newsub-Activities to prompt to add an account, select an account, and/or enter a password, as necessary; used only to call startActivity(); should not be null
 * @param addAccountOptions Authenticator-specific options to use foradding new accounts; may be null or empty
 * @param getAuthTokenOptions Authenticator-specific options to use forgetting auth tokens; may be null or empty
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withat least the following fields: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account<li>  {@link #KEY_AUTHTOKEN} - the auth token you wanted</ul> <p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if no authenticator was registered forthis account type or the authenticator failed to respond <li>  {@link OperationCanceledException} if the operation was canceled forany reason, including the user canceling any operation <li>  {@link IOException} if the authenticator experienced an I/O problemupdating settings, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> getAuthTokenByFeatures(final String accountType,final String authTokenType,final String[] features,final Activity activity,final Bundle addAccountOptions,final Bundle getAuthTokenOptions,final AccountManagerCallback<Bundle> callback,final Handler handler){
  if (accountType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (authTokenType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  final GetAuthTokenByTypeAndFeaturesTask task=new GetAuthTokenByTypeAndFeaturesTask(accountType,authTokenType,features,activity,addAccountOptions,getAuthTokenOptions,callback,handler);
  task.start();
  return task;
}",0.9998376886869016
182498,"private String getTestPath(){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  String test_path=LAYOUT_TESTS_ROOT;
  if (runner.mTestPath != null) {
    test_path+=runner.mTestPath;
  }
  try {
    test_path=new File(test_path).getCanonicalPath();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
  }
  Log.v(""String_Node_Str"",""String_Node_Str"" + test_path);
  return test_path;
}","private String getTestPath(){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  String test_path=LAYOUT_TESTS_ROOT;
  if (runner.mTestPath != null) {
    test_path+=runner.mTestPath;
  }
  test_path=new File(test_path).getAbsolutePath();
  Log.v(""String_Node_Str"",""String_Node_Str"" + test_path);
  return test_path;
}",0.7615480649188514
182499,"public void executeLayoutTests(boolean resume){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  if (runner.mTestPath == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  this.mTestList=new Vector<String>();
  try {
    this.mTestPathPrefix=(new File(LAYOUT_TESTS_ROOT + runner.mTestPath)).getCanonicalPath();
  }
 catch (  IOException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
    return;
  }
  this.mRebaselineResults=runner.mRebaseline;
  int timeout=runner.mTimeoutInMillis;
  if (timeout <= 0) {
    timeout=DEFAULT_TIMEOUT_IN_MILLIS;
  }
  this.mResultRecorder=new MyTestRecorder(resume);
  if (!resume)   clearTestStatus();
  getTestList();
  if (resume)   resumeTestList();
  TestShellActivity activity=getActivity();
  activity.setDefaultDumpDataType(DumpDataType.DUMP_AS_TEXT);
  int addr=-1;
  try {
    addr=AdbUtils.resolve(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    Log.w(LOGTAG,""String_Node_Str"",ioe);
  }
  if (addr == -1) {
    Log.w(LOGTAG,""String_Node_Str"");
  }
  for (int i=0; i < mTestList.size(); i++) {
    String s=mTestList.elementAt(i);
    FsUtils.updateTestStatus(TEST_STATUS_FILE,s);
    runTestAndWaitUntilDone(activity,s,runner.mTimeoutInMillis);
  }
  FsUtils.updateTestStatus(TEST_STATUS_FILE,""String_Node_Str"");
  ForwardService.getForwardService().stopForwardService();
  activity.finish();
}","public void executeLayoutTests(boolean resume){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  if (runner.mTestPath == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  this.mTestList=new Vector<String>();
  this.mTestPathPrefix=(new File(LAYOUT_TESTS_ROOT + runner.mTestPath)).getAbsolutePath();
  this.mRebaselineResults=runner.mRebaseline;
  int timeout=runner.mTimeoutInMillis;
  if (timeout <= 0) {
    timeout=DEFAULT_TIMEOUT_IN_MILLIS;
  }
  this.mResultRecorder=new MyTestRecorder(resume);
  if (!resume)   clearTestStatus();
  getTestList();
  if (resume)   resumeTestList();
  TestShellActivity activity=getActivity();
  activity.setDefaultDumpDataType(DumpDataType.DUMP_AS_TEXT);
  int addr=-1;
  try {
    addr=AdbUtils.resolve(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    Log.w(LOGTAG,""String_Node_Str"",ioe);
  }
  if (addr == -1) {
    Log.w(LOGTAG,""String_Node_Str"");
  }
  for (int i=0; i < mTestList.size(); i++) {
    String s=mTestList.elementAt(i);
    FsUtils.updateTestStatus(TEST_STATUS_FILE,s);
    runTestAndWaitUntilDone(activity,s,runner.mTimeoutInMillis);
  }
  FsUtils.updateTestStatus(TEST_STATUS_FILE,""String_Node_Str"");
  ForwardService.getForwardService().stopForwardService();
  activity.finish();
}",0.9524163568773234
182500,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion == 39) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.def_screen_brightness_automatic_mode) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.System.SCREEN_BRIGHTNESS_MODE + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=40;
  }
  if (upgradeVersion == 40) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=41;
  }
  if (upgradeVersion == 41) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.HAPTIC_FEEDBACK_ENABLED + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultHapticSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=42;
  }
  if (upgradeVersion == 42) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.NOTIFICATION_LIGHT_PULSE,R.bool.def_notification_pulse);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=43;
  }
  if (upgradeVersion == 43) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=44;
  }
  if (upgradeVersion == 44) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    upgradeVersion=45;
  }
  if (upgradeVersion == 45) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_AUTOSTART + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_PROMPT + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=46;
  }
  if (upgradeVersion == 46) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=47;
  }
  if (upgradeVersion == 47) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=48;
  }
  if (upgradeVersion == 48) {
    upgradeVersion=49;
  }
  if (upgradeVersion == 49) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadUISoundEffectsSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=50;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
    String wipeReason=oldVersion + ""String_Node_Str"" + upgradeVersion+ ""String_Node_Str""+ currentVersion;
    db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + wipeReason + ""String_Node_Str"");
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion == 39) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.def_screen_brightness_automatic_mode) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.System.SCREEN_BRIGHTNESS_MODE + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=40;
  }
  if (upgradeVersion == 40) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=41;
  }
  if (upgradeVersion == 41) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.HAPTIC_FEEDBACK_ENABLED + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultHapticSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=42;
  }
  if (upgradeVersion == 42) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.NOTIFICATION_LIGHT_PULSE,R.bool.def_notification_pulse);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=43;
  }
  if (upgradeVersion == 43) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=44;
  }
  if (upgradeVersion == 44) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    upgradeVersion=45;
  }
  if (upgradeVersion == 45) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_AUTOSTART + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_PROMPT + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=46;
  }
  if (upgradeVersion == 46) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=47;
  }
  if (upgradeVersion == 47) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=48;
  }
  if (upgradeVersion == 48) {
    upgradeVersion=49;
  }
  if (upgradeVersion == 49) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadUISoundEffectsSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=50;
  }
  if (upgradeVersion == 50) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.SET_INSTALL_LOCATION,R.bool.set_install_location);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=51;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
    String wipeReason=oldVersion + ""String_Node_Str"" + upgradeVersion+ ""String_Node_Str""+ currentVersion;
    db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + wipeReason + ""String_Node_Str"");
  }
}",0.984257748776509
182501,"public boolean onKeyDown(int keyCode,KeyEvent event){
  if (mScrollView != null && mScrollView.executeKeyEvent(event))   return true;
  return false;
}","@SuppressWarnings({""String_Node_Str""}) public boolean onKeyDown(int keyCode,KeyEvent event){
  return mScrollView != null && mScrollView.executeKeyEvent(event);
}",0.7476038338658147
182502,"private void setBackground(LinearLayout topPanel,LinearLayout contentPanel,View customPanel,boolean hasButtons,TypedArray a,boolean hasTitle,View buttonPanel){
  int fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,R.drawable.popup_full_dark);
  int topDark=a.getResourceId(R.styleable.AlertDialog_topDark,R.drawable.popup_top_dark);
  int centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,R.drawable.popup_center_dark);
  int bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,R.drawable.popup_bottom_dark);
  int fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,R.drawable.popup_full_bright);
  int topBright=a.getResourceId(R.styleable.AlertDialog_topBright,R.drawable.popup_top_bright);
  int centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,R.drawable.popup_center_bright);
  int bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,R.drawable.popup_bottom_bright);
  int bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,R.drawable.popup_bottom_medium);
  int centerMedium=a.getResourceId(R.styleable.AlertDialog_centerMedium,R.drawable.popup_center_medium);
  View[] views=new View[4];
  boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=(contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
  light[pos]=mListView == null ? false : true;
  pos++;
  if (customPanel != null) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  if ((mListView != null) && (mAdapter != null)) {
    mListView.setAdapter(mAdapter);
    if (mCheckedItem > -1) {
      mListView.setItemChecked(mCheckedItem,true);
      mListView.setSelection(mCheckedItem);
    }
  }
}","private void setBackground(LinearLayout topPanel,LinearLayout contentPanel,View customPanel,boolean hasButtons,TypedArray a,boolean hasTitle,View buttonPanel){
  int fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,R.drawable.popup_full_dark);
  int topDark=a.getResourceId(R.styleable.AlertDialog_topDark,R.drawable.popup_top_dark);
  int centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,R.drawable.popup_center_dark);
  int bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,R.drawable.popup_bottom_dark);
  int fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,R.drawable.popup_full_bright);
  int topBright=a.getResourceId(R.styleable.AlertDialog_topBright,R.drawable.popup_top_bright);
  int centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,R.drawable.popup_center_bright);
  int bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,R.drawable.popup_bottom_bright);
  int bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,R.drawable.popup_bottom_medium);
  View[] views=new View[4];
  boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=(contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
  light[pos]=mListView != null;
  pos++;
  if (customPanel != null) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  if ((mListView != null) && (mAdapter != null)) {
    mListView.setAdapter(mAdapter);
    if (mCheckedItem > -1) {
      mListView.setItemChecked(mCheckedItem,true);
      mListView.setSelection(mCheckedItem);
    }
  }
}",0.9734548335974644
182503,"public Button getButton(int whichButton){
switch (whichButton) {
case DialogInterface.BUTTON_POSITIVE:
    return mButtonPositiveMessage != null ? mButtonPositive : null;
case DialogInterface.BUTTON_NEGATIVE:
  return mButtonNegativeMessage != null ? mButtonNegative : null;
case DialogInterface.BUTTON_NEUTRAL:
return mButtonNeutralMessage != null ? mButtonNeutral : null;
default :
return null;
}
}","public Button getButton(int whichButton){
switch (whichButton) {
case DialogInterface.BUTTON_POSITIVE:
    return mButtonPositive;
case DialogInterface.BUTTON_NEGATIVE:
  return mButtonNegative;
case DialogInterface.BUTTON_NEUTRAL:
return mButtonNeutral;
default :
return null;
}
}",0.8252569750367107
182504,"public boolean onKeyUp(int keyCode,KeyEvent event){
  if (mScrollView != null && mScrollView.executeKeyEvent(event))   return true;
  return false;
}","@SuppressWarnings({""String_Node_Str""}) public boolean onKeyUp(int keyCode,KeyEvent event){
  return mScrollView != null && mScrollView.executeKeyEvent(event);
}",0.7443365695792881
182505,"private boolean setupButtons(){
  View defaultButton=null;
  int BIT_BUTTON_POSITIVE=1;
  int BIT_BUTTON_NEGATIVE=2;
  int BIT_BUTTON_NEUTRAL=4;
  int whichButtons=0;
  mButtonPositive=(Button)mWindow.findViewById(R.id.button1);
  mButtonPositive.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonPositiveText)) {
    mButtonPositive.setVisibility(View.GONE);
  }
 else {
    mButtonPositive.setText(mButtonPositiveText);
    mButtonPositive.setVisibility(View.VISIBLE);
    defaultButton=mButtonPositive;
    whichButtons=whichButtons | BIT_BUTTON_POSITIVE;
  }
  mButtonNegative=(Button)mWindow.findViewById(R.id.button2);
  mButtonNegative.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNegativeText)) {
    mButtonNegative.setVisibility(View.GONE);
  }
 else {
    mButtonNegative.setText(mButtonNegativeText);
    mButtonNegative.setVisibility(View.VISIBLE);
    if (defaultButton == null) {
      defaultButton=mButtonNegative;
    }
    whichButtons=whichButtons | BIT_BUTTON_NEGATIVE;
  }
  mButtonNeutral=(Button)mWindow.findViewById(R.id.button3);
  mButtonNeutral.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNeutralText)) {
    mButtonNeutral.setVisibility(View.GONE);
  }
 else {
    mButtonNeutral.setText(mButtonNeutralText);
    mButtonNeutral.setVisibility(View.VISIBLE);
    if (defaultButton == null) {
      defaultButton=mButtonNeutral;
    }
    whichButtons=whichButtons | BIT_BUTTON_NEUTRAL;
  }
  if (whichButtons == BIT_BUTTON_POSITIVE) {
    centerButton(mButtonPositive);
  }
 else   if (whichButtons == BIT_BUTTON_NEGATIVE) {
    centerButton(mButtonNeutral);
  }
 else   if (whichButtons == BIT_BUTTON_NEUTRAL) {
    centerButton(mButtonNeutral);
  }
  return whichButtons != 0;
}","private boolean setupButtons(){
  int BIT_BUTTON_POSITIVE=1;
  int BIT_BUTTON_NEGATIVE=2;
  int BIT_BUTTON_NEUTRAL=4;
  int whichButtons=0;
  mButtonPositive=(Button)mWindow.findViewById(R.id.button1);
  mButtonPositive.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonPositiveText)) {
    mButtonPositive.setVisibility(View.GONE);
  }
 else {
    mButtonPositive.setText(mButtonPositiveText);
    mButtonPositive.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_POSITIVE;
  }
  mButtonNegative=(Button)mWindow.findViewById(R.id.button2);
  mButtonNegative.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNegativeText)) {
    mButtonNegative.setVisibility(View.GONE);
  }
 else {
    mButtonNegative.setText(mButtonNegativeText);
    mButtonNegative.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_NEGATIVE;
  }
  mButtonNeutral=(Button)mWindow.findViewById(R.id.button3);
  mButtonNeutral.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNeutralText)) {
    mButtonNeutral.setVisibility(View.GONE);
  }
 else {
    mButtonNeutral.setText(mButtonNeutralText);
    mButtonNeutral.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_NEUTRAL;
  }
  if (whichButtons == BIT_BUTTON_POSITIVE) {
    centerButton(mButtonPositive);
  }
 else   if (whichButtons == BIT_BUTTON_NEGATIVE) {
    centerButton(mButtonNeutral);
  }
 else   if (whichButtons == BIT_BUTTON_NEUTRAL) {
    centerButton(mButtonNeutral);
  }
  return whichButtons != 0;
}",0.9359398496240602
182506,"private String getTestPath(){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  String test_path=LAYOUT_TESTS_ROOT;
  if (runner.mTestPath != null) {
    test_path+=runner.mTestPath;
  }
  try {
    test_path=new File(test_path).getCanonicalPath();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
  }
  Log.v(""String_Node_Str"",""String_Node_Str"" + test_path);
  return test_path;
}","private String getTestPath(){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  String test_path=LAYOUT_TESTS_ROOT;
  if (runner.mTestPath != null) {
    test_path+=runner.mTestPath;
  }
  test_path=new File(test_path).getAbsolutePath();
  Log.v(""String_Node_Str"",""String_Node_Str"" + test_path);
  return test_path;
}",0.7615480649188514
182507,"public void executeLayoutTests(boolean resume){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  if (runner.mTestPath == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  this.mTestList=new Vector<String>();
  try {
    this.mTestPathPrefix=(new File(LAYOUT_TESTS_ROOT + runner.mTestPath)).getCanonicalPath();
  }
 catch (  IOException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
    return;
  }
  this.mRebaselineResults=runner.mRebaseline;
  int timeout=runner.mTimeoutInMillis;
  if (timeout <= 0) {
    timeout=DEFAULT_TIMEOUT_IN_MILLIS;
  }
  this.mResultRecorder=new MyTestRecorder(resume);
  if (!resume)   clearTestStatus();
  getTestList();
  if (resume)   resumeTestList();
  TestShellActivity activity=getActivity();
  activity.setDefaultDumpDataType(DumpDataType.DUMP_AS_TEXT);
  int addr=-1;
  try {
    addr=AdbUtils.resolve(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    Log.w(LOGTAG,""String_Node_Str"",ioe);
  }
  if (addr == -1) {
    Log.w(LOGTAG,""String_Node_Str"");
  }
  for (int i=0; i < mTestList.size(); i++) {
    String s=mTestList.elementAt(i);
    FsUtils.updateTestStatus(TEST_STATUS_FILE,s);
    runTestAndWaitUntilDone(activity,s,runner.mTimeoutInMillis);
  }
  FsUtils.updateTestStatus(TEST_STATUS_FILE,""String_Node_Str"");
  ForwardService.getForwardService().stopForwardService();
  activity.finish();
}","public void executeLayoutTests(boolean resume){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  if (runner.mTestPath == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  this.mTestList=new Vector<String>();
  this.mTestPathPrefix=(new File(LAYOUT_TESTS_ROOT + runner.mTestPath)).getAbsolutePath();
  this.mRebaselineResults=runner.mRebaseline;
  int timeout=runner.mTimeoutInMillis;
  if (timeout <= 0) {
    timeout=DEFAULT_TIMEOUT_IN_MILLIS;
  }
  this.mResultRecorder=new MyTestRecorder(resume);
  if (!resume)   clearTestStatus();
  getTestList();
  if (resume)   resumeTestList();
  TestShellActivity activity=getActivity();
  activity.setDefaultDumpDataType(DumpDataType.DUMP_AS_TEXT);
  int addr=-1;
  try {
    addr=AdbUtils.resolve(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    Log.w(LOGTAG,""String_Node_Str"",ioe);
  }
  if (addr == -1) {
    Log.w(LOGTAG,""String_Node_Str"");
  }
  for (int i=0; i < mTestList.size(); i++) {
    String s=mTestList.elementAt(i);
    FsUtils.updateTestStatus(TEST_STATUS_FILE,s);
    runTestAndWaitUntilDone(activity,s,runner.mTimeoutInMillis);
  }
  FsUtils.updateTestStatus(TEST_STATUS_FILE,""String_Node_Str"");
  ForwardService.getForwardService().stopForwardService();
  activity.finish();
}",0.9524163568773234
182508,"private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    Bundle oldState=r.state;
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        r.state=oldState;
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.977149979227254
182509,"private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ContextImpl appContext=new ContextImpl();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
      r.state=null;
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}","private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ContextImpl appContext=new ContextImpl();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}",0.9972602739726028
182510,"public StopwatchTimer getWakeTimerLocked(String name,int type){
  Wakelock wl=mWakelockStats.get(name);
  if (wl == null) {
    wl=new Wakelock();
    mWakelockStats.put(name,wl);
  }
  StopwatchTimer t=null;
switch (type) {
case WAKE_TYPE_PARTIAL:
    t=wl.mTimerPartial;
  if (t == null) {
    t=new StopwatchTimer(WAKE_TYPE_PARTIAL,mPartialTimers,mUnpluggables);
    wl.mTimerPartial=t;
  }
return t;
case WAKE_TYPE_FULL:
t=wl.mTimerFull;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_FULL,mFullTimers,mUnpluggables);
wl.mTimerFull=t;
}
return t;
case WAKE_TYPE_WINDOW:
t=wl.mTimerWindow;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_WINDOW,mWindowTimers,mUnpluggables);
wl.mTimerWindow=t;
}
return t;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}","public StopwatchTimer getWakeTimerLocked(String name,int type){
  Wakelock wl=mWakelockStats.get(name);
  if (wl == null) {
    if (mWakelockStats.size() > MAX_WAKELOCKS_PER_UID) {
      name=BATCHED_WAKELOCK_NAME;
      wl=mWakelockStats.get(name);
    }
    if (wl == null) {
      wl=new Wakelock();
      mWakelockStats.put(name,wl);
    }
  }
  StopwatchTimer t=null;
switch (type) {
case WAKE_TYPE_PARTIAL:
    t=wl.mTimerPartial;
  if (t == null) {
    t=new StopwatchTimer(WAKE_TYPE_PARTIAL,mPartialTimers,mUnpluggables);
    wl.mTimerPartial=t;
  }
return t;
case WAKE_TYPE_FULL:
t=wl.mTimerFull;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_FULL,mFullTimers,mUnpluggables);
wl.mTimerFull=t;
}
return t;
case WAKE_TYPE_WINDOW:
t=wl.mTimerWindow;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_WINDOW,mWindowTimers,mUnpluggables);
wl.mTimerWindow=t;
}
return t;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}",0.8788927335640139
182511,"private PackageSetting getPackageLP(String name,PackageSetting origPackage,String realName,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      if ((p != null) && ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        Log.w(TAG,""String_Node_Str"" + p.codePathString + ""String_Node_Str""+ codePath.toString());
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
    }
    if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
 else {
      if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        p.pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    if (origPackage != null) {
      p=new PackageSetting(origPackage.name,name,codePath,resourcePath,vc,pkgFlags);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ origPackage.name);
      p.copyFrom(origPackage);
      p.sharedUser=origPackage.sharedUser;
      p.userId=origPackage.userId;
      p.origPackage=origPackage;
      mRenamedPackages.put(name,origPackage.name);
      name=origPackage.name;
      p.setTimeStamp(codePath.lastModified());
    }
 else {
      p=new PackageSetting(name,realName,codePath,resourcePath,vc,pkgFlags);
      p.setTimeStamp(codePath.lastModified());
      p.sharedUser=sharedUser;
      if (sharedUser != null) {
        p.userId=sharedUser.userId;
      }
 else       if (MULTIPLE_APPLICATION_UIDS) {
        PackageSetting dis=mDisabledSysPackages.get(name);
        if (dis != null) {
          if (dis.signatures.mSignatures != null) {
            p.signatures.mSignatures=dis.signatures.mSignatures.clone();
          }
          p.userId=dis.userId;
          p.grantedPermissions=new HashSet<String>(dis.grantedPermissions);
          p.loadedPermissions=new HashSet<String>(dis.loadedPermissions);
          p.disabledComponents=new HashSet<String>(dis.disabledComponents);
          p.enabledComponents=new HashSet<String>(dis.enabledComponents);
          addUserIdLP(p.userId,p,name);
        }
 else {
          p.userId=newUserIdLP(p);
        }
      }
 else {
        p.userId=FIRST_APPLICATION_UID;
      }
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      addPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,PackageSetting origPackage,String realName,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      if ((p != null) && ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        Log.w(TAG,""String_Node_Str"" + p.codePathString + ""String_Node_Str""+ codePath.toString());
      }
 else {
        Log.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
    }
    if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
 else {
      if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        p.pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    if (origPackage != null) {
      p=new PackageSetting(origPackage.name,name,codePath,resourcePath,vc,pkgFlags);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ origPackage.name);
      p.copyFrom(origPackage);
      p.sharedUser=origPackage.sharedUser;
      p.userId=origPackage.userId;
      p.origPackage=origPackage;
      mRenamedPackages.put(name,origPackage.name);
      name=origPackage.name;
      p.setTimeStamp(codePath.lastModified());
    }
 else {
      p=new PackageSetting(name,realName,codePath,resourcePath,vc,pkgFlags);
      p.setTimeStamp(codePath.lastModified());
      p.sharedUser=sharedUser;
      if (sharedUser != null) {
        p.userId=sharedUser.userId;
      }
 else       if (MULTIPLE_APPLICATION_UIDS) {
        PackageSetting dis=mDisabledSysPackages.get(name);
        if (dis != null) {
          if (dis.signatures.mSignatures != null) {
            p.signatures.mSignatures=dis.signatures.mSignatures.clone();
          }
          p.userId=dis.userId;
          p.grantedPermissions=new HashSet<String>(dis.grantedPermissions);
          p.loadedPermissions=new HashSet<String>(dis.loadedPermissions);
          p.disabledComponents=new HashSet<String>(dis.disabledComponents);
          p.enabledComponents=new HashSet<String>(dis.enabledComponents);
          addUserIdLP(p.userId,p,name);
        }
 else {
          p.userId=newUserIdLP(p);
        }
      }
 else {
        p.userId=FIRST_APPLICATION_UID;
      }
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      addPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.9949433304272014
182512,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    if (deletedPs != null) {
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}",0.8495264819361628
182513,"private void revokeUriPermissionLocked(int callingUid,Uri uri,int modeFlags){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  final IPackageManager pm=ActivityThread.getPackageManager();
  final String authority=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(authority);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(authority,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + authority);
    return;
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
  }
  final List<String> SEGMENTS=uri.getPathSegments();
  if (SEGMENTS != null) {
    final int NS=SEGMENTS.size();
    int N=mGrantedUriPermissions.size();
    for (int i=0; i < N; i++) {
      HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.valueAt(i);
      Iterator<UriPermission> it=perms.values().iterator();
      toploop:       while (it.hasNext()) {
        UriPermission perm=it.next();
        Uri targetUri=perm.uri;
        if (!authority.equals(targetUri.getAuthority())) {
          continue;
        }
        List<String> targetSegments=targetUri.getPathSegments();
        if (targetSegments == null) {
          continue;
        }
        if (targetSegments.size() < NS) {
          continue;
        }
        for (int j=0; j < NS; j++) {
          if (!SEGMENTS.get(j).equals(targetSegments.get(j))) {
            continue toploop;
          }
        }
        perm.clearModes(modeFlags);
        if (perm.modeFlags == 0) {
          it.remove();
        }
      }
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(mGrantedUriPermissions.keyAt(i));
        N--;
        i--;
      }
    }
  }
}","private void revokeUriPermissionLocked(int callingUid,Uri uri,int modeFlags){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + uri);
  final IPackageManager pm=ActivityThread.getPackageManager();
  final String authority=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(authority);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(authority,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + authority);
    return;
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
  }
  final List<String> SEGMENTS=uri.getPathSegments();
  if (SEGMENTS != null) {
    final int NS=SEGMENTS.size();
    int N=mGrantedUriPermissions.size();
    for (int i=0; i < N; i++) {
      HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.valueAt(i);
      Iterator<UriPermission> it=perms.values().iterator();
      toploop:       while (it.hasNext()) {
        UriPermission perm=it.next();
        Uri targetUri=perm.uri;
        if (!authority.equals(targetUri.getAuthority())) {
          continue;
        }
        List<String> targetSegments=targetUri.getPathSegments();
        if (targetSegments == null) {
          continue;
        }
        if (targetSegments.size() < NS) {
          continue;
        }
        for (int j=0; j < NS; j++) {
          if (!SEGMENTS.get(j).equals(targetSegments.get(j))) {
            continue toploop;
          }
        }
        if (DEBUG_URI_PERMISSION)         Log.v(TAG,""String_Node_Str"" + perm.uid + ""String_Node_Str""+ perm.uri);
        perm.clearModes(modeFlags);
        if (perm.modeFlags == 0) {
          it.remove();
        }
      }
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(mGrantedUriPermissions.keyAt(i));
        N--;
        i--;
      }
    }
  }
}",0.9574518659377228
182514,"private void removeUriPermissionIfNeededLocked(UriPermission perm){
  if ((perm.modeFlags & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) == 0) {
    HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(perm.uid);
    if (perms != null) {
      perms.remove(perm.uri);
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(perm.uid);
      }
    }
  }
}","private void removeUriPermissionIfNeededLocked(UriPermission perm){
  if ((perm.modeFlags & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) == 0) {
    HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(perm.uid);
    if (perms != null) {
      if (DEBUG_URI_PERMISSION)       Log.v(TAG,""String_Node_Str"" + perm.uid + ""String_Node_Str""+ perm.uri);
      perms.remove(perm.uri);
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(perm.uid);
      }
    }
  }
}",0.882921589688507
182515,"private void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,HistoryRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  final IPackageManager pm=ActivityThread.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    return;
  }
  if (checkUriPermissionLocked(uri,targetUid,modeFlags)) {
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}","private void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,HistoryRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  final IPackageManager pm=ActivityThread.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    if (DEBUG_URI_PERMISSION)     Log.v(TAG,""String_Node_Str"" + uri);
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      if (DEBUG_URI_PERMISSION)       Log.v(TAG,""String_Node_Str"" + targetPkg);
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    if (DEBUG_URI_PERMISSION)     Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}",0.921531701192718
182516,"public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.918763479511143
182517,"protected void finalize() throws Throwable {
  if (!canceled) {
synchronized (owner) {
      WeakReference<PendingIntentRecord> current=owner.mIntentSenderRecords.get(key);
      if (current == ref) {
        owner.mIntentSenderRecords.remove(key);
      }
    }
  }
}","protected void finalize() throws Throwable {
  try {
    if (!canceled) {
      owner.mHandler.sendMessage(owner.mHandler.obtainMessage(ActivityManagerService.FINALIZE_PENDING_INTENT_MSG,this));
    }
  }
  finally {
    super.finalize();
  }
}",0.2890625
182518,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,localForegroundId,null,true);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.9445482866043614
182519,"public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.9839743589743588
182520,"public void run(){
  INotificationManager inm=NotificationManager.getService();
  if (inm == null) {
    return;
  }
  try {
    inm.cancelNotification(localPackageName,localForegroundId);
  }
 catch (  RuntimeException e) {
    Log.w(ActivityManagerService.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
  }
catch (  RemoteException e) {
  }
}","public void run(){
  INotificationManager inm=NotificationManager.getService();
  if (inm == null) {
    return;
  }
  try {
    inm.cancelNotification(localPackageName,localForegroundId);
  }
 catch (  RuntimeException e) {
    Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
  }
catch (  RemoteException e) {
  }
}",0.96996996996997
182521,"/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
  int numCursors=mManagedCursors.size();
  for (int i=0; i < numCursors; i++) {
    ManagedCursor c=mManagedCursors.get(i);
    if (c != null) {
      c.mCursor.close();
    }
  }
  mManagedCursors.clear();
}","/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
}",0.9856718031900512
182522,"final void performRestart(){
  final int N=mManagedCursors.size();
  for (int i=0; i < N; i++) {
    ManagedCursor mc=mManagedCursors.get(i);
    if (mc.mReleased || mc.mUpdated) {
      mc.mCursor.requery();
      mc.mReleased=false;
      mc.mUpdated=false;
    }
  }
  if (mStopped) {
    mStopped=false;
    mCalled=false;
    mInstrumentation.callActivityOnRestart(this);
    if (!mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
    }
    performStart();
  }
}","final void performRestart(){
synchronized (mManagedCursors) {
    final int N=mManagedCursors.size();
    for (int i=0; i < N; i++) {
      ManagedCursor mc=mManagedCursors.get(i);
      if (mc.mReleased || mc.mUpdated) {
        mc.mCursor.requery();
        mc.mReleased=false;
        mc.mUpdated=false;
      }
    }
  }
  if (mStopped) {
    mStopped=false;
    mCalled=false;
    mInstrumentation.callActivityOnRestart(this);
    if (!mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
    }
    performStart();
  }
}",0.9512843224092116
182523,"final void performStop(){
  if (!mStopped) {
    if (mWindow != null) {
      mWindow.closeAllPanels();
    }
    mCalled=false;
    mInstrumentation.callActivityOnStop(this);
    if (!mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
    }
    final int N=mManagedCursors.size();
    for (int i=0; i < N; i++) {
      ManagedCursor mc=mManagedCursors.get(i);
      if (!mc.mReleased) {
        mc.mCursor.deactivate();
        mc.mReleased=true;
      }
    }
    mStopped=true;
  }
  mResumed=false;
}","final void performStop(){
  if (!mStopped) {
    if (mWindow != null) {
      mWindow.closeAllPanels();
    }
    mCalled=false;
    mInstrumentation.callActivityOnStop(this);
    if (!mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
    }
synchronized (mManagedCursors) {
      final int N=mManagedCursors.size();
      for (int i=0; i < N; i++) {
        ManagedCursor mc=mManagedCursors.get(i);
        if (!mc.mReleased) {
          mc.mCursor.deactivate();
          mc.mReleased=true;
        }
      }
    }
    mStopped=true;
  }
  mResumed=false;
}",0.925895087427144
182524,"public boolean onKeyDown(int keyCode,KeyEvent event){
  if (mScrollView != null && mScrollView.executeKeyEvent(event))   return true;
  return false;
}","@SuppressWarnings({""String_Node_Str""}) public boolean onKeyDown(int keyCode,KeyEvent event){
  return mScrollView != null && mScrollView.executeKeyEvent(event);
}",0.7476038338658147
182525,"private void setBackground(LinearLayout topPanel,LinearLayout contentPanel,View customPanel,boolean hasButtons,TypedArray a,boolean hasTitle,View buttonPanel){
  int fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,R.drawable.popup_full_dark);
  int topDark=a.getResourceId(R.styleable.AlertDialog_topDark,R.drawable.popup_top_dark);
  int centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,R.drawable.popup_center_dark);
  int bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,R.drawable.popup_bottom_dark);
  int fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,R.drawable.popup_full_bright);
  int topBright=a.getResourceId(R.styleable.AlertDialog_topBright,R.drawable.popup_top_bright);
  int centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,R.drawable.popup_center_bright);
  int bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,R.drawable.popup_bottom_bright);
  int bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,R.drawable.popup_bottom_medium);
  int centerMedium=a.getResourceId(R.styleable.AlertDialog_centerMedium,R.drawable.popup_center_medium);
  View[] views=new View[4];
  boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=(contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
  light[pos]=mListView == null ? false : true;
  pos++;
  if (customPanel != null) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  if ((mListView != null) && (mAdapter != null)) {
    mListView.setAdapter(mAdapter);
    if (mCheckedItem > -1) {
      mListView.setItemChecked(mCheckedItem,true);
      mListView.setSelection(mCheckedItem);
    }
  }
}","private void setBackground(LinearLayout topPanel,LinearLayout contentPanel,View customPanel,boolean hasButtons,TypedArray a,boolean hasTitle,View buttonPanel){
  int fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,R.drawable.popup_full_dark);
  int topDark=a.getResourceId(R.styleable.AlertDialog_topDark,R.drawable.popup_top_dark);
  int centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,R.drawable.popup_center_dark);
  int bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,R.drawable.popup_bottom_dark);
  int fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,R.drawable.popup_full_bright);
  int topBright=a.getResourceId(R.styleable.AlertDialog_topBright,R.drawable.popup_top_bright);
  int centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,R.drawable.popup_center_bright);
  int bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,R.drawable.popup_bottom_bright);
  int bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,R.drawable.popup_bottom_medium);
  View[] views=new View[4];
  boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=(contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
  light[pos]=mListView != null;
  pos++;
  if (customPanel != null) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  if ((mListView != null) && (mAdapter != null)) {
    mListView.setAdapter(mAdapter);
    if (mCheckedItem > -1) {
      mListView.setItemChecked(mCheckedItem,true);
      mListView.setSelection(mCheckedItem);
    }
  }
}",0.9734548335974644
182526,"public Button getButton(int whichButton){
switch (whichButton) {
case DialogInterface.BUTTON_POSITIVE:
    return mButtonPositiveMessage != null ? mButtonPositive : null;
case DialogInterface.BUTTON_NEGATIVE:
  return mButtonNegativeMessage != null ? mButtonNegative : null;
case DialogInterface.BUTTON_NEUTRAL:
return mButtonNeutralMessage != null ? mButtonNeutral : null;
default :
return null;
}
}","public Button getButton(int whichButton){
switch (whichButton) {
case DialogInterface.BUTTON_POSITIVE:
    return mButtonPositive;
case DialogInterface.BUTTON_NEGATIVE:
  return mButtonNegative;
case DialogInterface.BUTTON_NEUTRAL:
return mButtonNeutral;
default :
return null;
}
}",0.8252569750367107
182527,"public boolean onKeyUp(int keyCode,KeyEvent event){
  if (mScrollView != null && mScrollView.executeKeyEvent(event))   return true;
  return false;
}","@SuppressWarnings({""String_Node_Str""}) public boolean onKeyUp(int keyCode,KeyEvent event){
  return mScrollView != null && mScrollView.executeKeyEvent(event);
}",0.7443365695792881
182528,"private boolean setupButtons(){
  View defaultButton=null;
  int BIT_BUTTON_POSITIVE=1;
  int BIT_BUTTON_NEGATIVE=2;
  int BIT_BUTTON_NEUTRAL=4;
  int whichButtons=0;
  mButtonPositive=(Button)mWindow.findViewById(R.id.button1);
  mButtonPositive.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonPositiveText)) {
    mButtonPositive.setVisibility(View.GONE);
  }
 else {
    mButtonPositive.setText(mButtonPositiveText);
    mButtonPositive.setVisibility(View.VISIBLE);
    defaultButton=mButtonPositive;
    whichButtons=whichButtons | BIT_BUTTON_POSITIVE;
  }
  mButtonNegative=(Button)mWindow.findViewById(R.id.button2);
  mButtonNegative.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNegativeText)) {
    mButtonNegative.setVisibility(View.GONE);
  }
 else {
    mButtonNegative.setText(mButtonNegativeText);
    mButtonNegative.setVisibility(View.VISIBLE);
    if (defaultButton == null) {
      defaultButton=mButtonNegative;
    }
    whichButtons=whichButtons | BIT_BUTTON_NEGATIVE;
  }
  mButtonNeutral=(Button)mWindow.findViewById(R.id.button3);
  mButtonNeutral.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNeutralText)) {
    mButtonNeutral.setVisibility(View.GONE);
  }
 else {
    mButtonNeutral.setText(mButtonNeutralText);
    mButtonNeutral.setVisibility(View.VISIBLE);
    if (defaultButton == null) {
      defaultButton=mButtonNeutral;
    }
    whichButtons=whichButtons | BIT_BUTTON_NEUTRAL;
  }
  if (whichButtons == BIT_BUTTON_POSITIVE) {
    centerButton(mButtonPositive);
  }
 else   if (whichButtons == BIT_BUTTON_NEGATIVE) {
    centerButton(mButtonNeutral);
  }
 else   if (whichButtons == BIT_BUTTON_NEUTRAL) {
    centerButton(mButtonNeutral);
  }
  return whichButtons != 0;
}","private boolean setupButtons(){
  int BIT_BUTTON_POSITIVE=1;
  int BIT_BUTTON_NEGATIVE=2;
  int BIT_BUTTON_NEUTRAL=4;
  int whichButtons=0;
  mButtonPositive=(Button)mWindow.findViewById(R.id.button1);
  mButtonPositive.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonPositiveText)) {
    mButtonPositive.setVisibility(View.GONE);
  }
 else {
    mButtonPositive.setText(mButtonPositiveText);
    mButtonPositive.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_POSITIVE;
  }
  mButtonNegative=(Button)mWindow.findViewById(R.id.button2);
  mButtonNegative.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNegativeText)) {
    mButtonNegative.setVisibility(View.GONE);
  }
 else {
    mButtonNegative.setText(mButtonNegativeText);
    mButtonNegative.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_NEGATIVE;
  }
  mButtonNeutral=(Button)mWindow.findViewById(R.id.button3);
  mButtonNeutral.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNeutralText)) {
    mButtonNeutral.setVisibility(View.GONE);
  }
 else {
    mButtonNeutral.setText(mButtonNeutralText);
    mButtonNeutral.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_NEUTRAL;
  }
  if (whichButtons == BIT_BUTTON_POSITIVE) {
    centerButton(mButtonPositive);
  }
 else   if (whichButtons == BIT_BUTTON_NEGATIVE) {
    centerButton(mButtonNeutral);
  }
 else   if (whichButtons == BIT_BUTTON_NEUTRAL) {
    centerButton(mButtonNeutral);
  }
  return whichButtons != 0;
}",0.9359398496240602
182529,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion == 39) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.def_screen_brightness_automatic_mode) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.System.SCREEN_BRIGHTNESS_MODE + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=40;
  }
  if (upgradeVersion == 40) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=41;
  }
  if (upgradeVersion == 41) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.HAPTIC_FEEDBACK_ENABLED + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultHapticSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=42;
  }
  if (upgradeVersion == 42) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.NOTIFICATION_LIGHT_PULSE,R.bool.def_notification_pulse);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=43;
  }
  if (upgradeVersion == 43) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=44;
  }
  if (upgradeVersion == 44) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    upgradeVersion=45;
  }
  if (upgradeVersion == 45) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_AUTOSTART + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_PROMPT + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=46;
  }
  if (upgradeVersion == 46) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=47;
  }
  if (upgradeVersion == 47) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=48;
  }
  if (upgradeVersion == 48) {
    upgradeVersion=49;
  }
  if (upgradeVersion == 49) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadUISoundEffectsSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=50;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
    String wipeReason=oldVersion + ""String_Node_Str"" + upgradeVersion+ ""String_Node_Str""+ currentVersion;
    db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + wipeReason + ""String_Node_Str"");
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion == 39) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.def_screen_brightness_automatic_mode) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.System.SCREEN_BRIGHTNESS_MODE + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=40;
  }
  if (upgradeVersion == 40) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=41;
  }
  if (upgradeVersion == 41) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.HAPTIC_FEEDBACK_ENABLED + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultHapticSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=42;
  }
  if (upgradeVersion == 42) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.NOTIFICATION_LIGHT_PULSE,R.bool.def_notification_pulse);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=43;
  }
  if (upgradeVersion == 43) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=44;
  }
  if (upgradeVersion == 44) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    upgradeVersion=45;
  }
  if (upgradeVersion == 45) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_AUTOSTART + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_PROMPT + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=46;
  }
  if (upgradeVersion == 46) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=47;
  }
  if (upgradeVersion == 47) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=48;
  }
  if (upgradeVersion == 48) {
    upgradeVersion=49;
  }
  if (upgradeVersion == 49) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadUISoundEffectsSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=50;
  }
  if (upgradeVersion == 50) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.SET_INSTALL_LOCATION,R.bool.set_install_location);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=51;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
    String wipeReason=oldVersion + ""String_Node_Str"" + upgradeVersion+ ""String_Node_Str""+ currentVersion;
    db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + wipeReason + ""String_Node_Str"");
  }
}",0.984257748776509
182530,"/** 
 * Gets a value and converts it to a Float.
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
public Float getAsFloat(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).floatValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Float.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Float.
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
public Float getAsFloat(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).floatValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Float.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.9936485532815807
182531,"/** 
 * Gets a value and converts it to a Byte.
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
public Byte getAsByte(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).byteValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Byte.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Byte.
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
public Byte getAsByte(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).byteValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Byte.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.993594306049822
182532,"/** 
 * Gets a value and converts it to an Integer.
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
public Integer getAsInteger(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).intValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Integer.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to an Integer.
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
public Integer getAsInteger(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).intValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Integer.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.9937282229965156
182533,"/** 
 * Gets a value and converts it to a Long.
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
public Long getAsLong(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).longValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Long.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Long.
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
public Long getAsLong(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).longValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Long.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.993594306049822
182534,"/** 
 * Returns true if this object has the named value.
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise 
 */
public boolean containsKey(String key){
  return mValues.containsKey(key);
}","/** 
 * Returns true if this object has the named value.
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise
 */
public boolean containsKey(String key){
  return mValues.containsKey(key);
}",0.997979797979798
182535,"/** 
 * Gets a value and converts it to a Double.
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
public Double getAsDouble(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).doubleValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Double.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Double.
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
public Double getAsDouble(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).doubleValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Double.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.99370188943317
182536,"/** 
 * Gets a value and converts it to a Boolean.
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
public Boolean getAsBoolean(String key){
  Object value=mValues.get(key);
  try {
    return (Boolean)value;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      return Boolean.valueOf(value.toString());
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Boolean.
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
public Boolean getAsBoolean(String key){
  Object value=mValues.get(key);
  try {
    return (Boolean)value;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      return Boolean.valueOf(value.toString());
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.991304347826087
182537,"/** 
 * Gets a value and converts it to a Short.
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
public Short getAsShort(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).shortValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Short.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Short.
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
public Short getAsShort(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).shortValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Short.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.9936485532815807
182538,"/** 
 * Gets a value and converts it to a Float.
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
public Float getAsFloat(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).floatValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Float.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Float.
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
public Float getAsFloat(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).floatValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Float.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.9936485532815807
182539,"/** 
 * Gets a value and converts it to a Byte.
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
public Byte getAsByte(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).byteValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Byte.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Byte.
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
public Byte getAsByte(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).byteValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Byte.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.993594306049822
182540,"/** 
 * Gets a value and converts it to an Integer.
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
public Integer getAsInteger(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).intValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Integer.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to an Integer.
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
public Integer getAsInteger(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).intValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Integer.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.9937282229965156
182541,"/** 
 * Gets a value and converts it to a Long.
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
public Long getAsLong(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).longValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Long.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Long.
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
public Long getAsLong(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).longValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Long.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.993594306049822
182542,"/** 
 * Returns true if this object has the named value.
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise 
 */
public boolean containsKey(String key){
  return mValues.containsKey(key);
}","/** 
 * Returns true if this object has the named value.
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise
 */
public boolean containsKey(String key){
  return mValues.containsKey(key);
}",0.997979797979798
182543,"/** 
 * Gets a value and converts it to a Double.
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
public Double getAsDouble(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).doubleValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Double.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Double.
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
public Double getAsDouble(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).doubleValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Double.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.99370188943317
182544,"/** 
 * Gets a value and converts it to a Boolean.
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
public Boolean getAsBoolean(String key){
  Object value=mValues.get(key);
  try {
    return (Boolean)value;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      return Boolean.valueOf(value.toString());
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Boolean.
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
public Boolean getAsBoolean(String key){
  Object value=mValues.get(key);
  try {
    return (Boolean)value;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      return Boolean.valueOf(value.toString());
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.991304347826087
182545,"/** 
 * Gets a value and converts it to a Short.
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
public Short getAsShort(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).shortValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Short.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Short.
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
public Short getAsShort(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).shortValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Short.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}",0.9936485532815807
182546,"public void onPress(int primaryCode){
}","public void onPress(int primaryCode){
  if (mVibratePattern != null) {
    mVibrator.vibrate(mVibratePattern,-1);
  }
}",0.4936708860759494
182547,"public PasswordEntryKeyboardHelper(Context context,KeyboardView keyboardView,View targetView){
  mContext=context;
  mTargetView=targetView;
  mKeyboardView=keyboardView;
  createKeyboards();
  mKeyboardView.setOnKeyboardActionListener(this);
}","public PasswordEntryKeyboardHelper(Context context,KeyboardView keyboardView,View targetView){
  mContext=context;
  mTargetView=targetView;
  mKeyboardView=keyboardView;
  createKeyboards();
  mKeyboardView.setOnKeyboardActionListener(this);
  mVibrator=new Vibrator();
}",0.9457364341085271
182548,"public PasswordUnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mCreatedWithKeyboardOpen=mUpdateMonitor.isKeyboardOpen();
  LayoutInflater layoutInflater=LayoutInflater.from(context);
  if (mUpdateMonitor.isInPortrait()) {
    layoutInflater.inflate(R.layout.keyguard_screen_password_portrait,this,true);
  }
 else {
    layoutInflater.inflate(R.layout.keyguard_screen_password_landscape,this,true);
  }
  boolean isAlpha=lockPatternUtils.getPasswordMode() == LockPatternUtils.MODE_PASSWORD;
  mKeyboardView=(PasswordEntryKeyboardView)findViewById(R.id.keyboard);
  mPasswordEntry=(EditText)findViewById(R.id.passwordEntry);
  mPasswordEntry.setOnEditorActionListener(this);
  mEmergencyCallButton=(TextView)findViewById(R.id.emergencyCall);
  mEmergencyCallButton.setOnClickListener(this);
  mUpdateMonitor.registerConfigurationChangeCallback(this);
  mLockPatternUtils=lockPatternUtils;
  mKeyboardHelper=new PasswordEntryKeyboardHelper(context,mKeyboardView,this);
  mKeyboardHelper.setKeyboardMode(isAlpha ? PasswordEntryKeyboardHelper.KEYBOARD_MODE_ALPHA : PasswordEntryKeyboardHelper.KEYBOARD_MODE_NUMERIC);
  mKeyboardView.setVisibility(mCreatedWithKeyboardOpen ? View.INVISIBLE : View.VISIBLE);
  mPasswordEntry.requestFocus();
}","public PasswordUnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mCreatedWithKeyboardOpen=mUpdateMonitor.isKeyboardOpen();
  LayoutInflater layoutInflater=LayoutInflater.from(context);
  if (mUpdateMonitor.isInPortrait()) {
    layoutInflater.inflate(R.layout.keyguard_screen_password_portrait,this,true);
  }
 else {
    layoutInflater.inflate(R.layout.keyguard_screen_password_landscape,this,true);
  }
  boolean isAlpha=lockPatternUtils.getPasswordMode() == LockPatternUtils.MODE_PASSWORD;
  mKeyboardView=(PasswordEntryKeyboardView)findViewById(R.id.keyboard);
  mPasswordEntry=(EditText)findViewById(R.id.passwordEntry);
  mPasswordEntry.setOnEditorActionListener(this);
  mEmergencyCallButton=(TextView)findViewById(R.id.emergencyCall);
  mEmergencyCallButton.setOnClickListener(this);
  mUpdateMonitor.registerConfigurationChangeCallback(this);
  mLockPatternUtils=lockPatternUtils;
  mKeyboardHelper=new PasswordEntryKeyboardHelper(context,mKeyboardView,this);
  mKeyboardHelper.setKeyboardMode(isAlpha ? PasswordEntryKeyboardHelper.KEYBOARD_MODE_ALPHA : PasswordEntryKeyboardHelper.KEYBOARD_MODE_NUMERIC);
  mKeyboardView.setVisibility(mCreatedWithKeyboardOpen ? View.INVISIBLE : View.VISIBLE);
  mPasswordEntry.requestFocus();
  mKeyboardHelper.setVibratePattern(mLockPatternUtils.isTactileFeedbackEnabled() ? com.android.internal.R.array.config_virtualKeyVibePattern : 0);
}",0.9499489274770172
182549,"public PasswordUnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mCreatedWithKeyboardOpen=mUpdateMonitor.isKeyboardOpen();
  LayoutInflater layoutInflater=LayoutInflater.from(context);
  if (mUpdateMonitor.isInPortrait()) {
    layoutInflater.inflate(R.layout.keyguard_screen_password_portrait,this,true);
  }
 else {
    layoutInflater.inflate(R.layout.keyguard_screen_password_landscape,this,true);
  }
  boolean isAlpha=lockPatternUtils.getPasswordMode() == LockPatternUtils.MODE_PASSWORD;
  mKeyboardView=(PasswordEntryKeyboardView)findViewById(R.id.keyboard);
  mPasswordEntry=(EditText)findViewById(R.id.passwordEntry);
  mPasswordEntry.setOnEditorActionListener(this);
  mEmergencyCallButton=(TextView)findViewById(R.id.emergencyCall);
  mEmergencyCallButton.setOnClickListener(this);
  mUpdateMonitor.registerConfigurationChangeCallback(this);
  mLockPatternUtils=lockPatternUtils;
  mKeyboardHelper=new PasswordEntryKeyboardHelper(context,mKeyboardView,this);
  mKeyboardHelper.setKeyboardMode(isAlpha ? PasswordEntryKeyboardHelper.KEYBOARD_MODE_ALPHA : PasswordEntryKeyboardHelper.KEYBOARD_MODE_NUMERIC);
  mKeyboardView.setVisibility(mCreatedWithKeyboardOpen ? View.INVISIBLE : View.VISIBLE);
  mPasswordEntry.requestFocus();
}","public PasswordUnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mCreatedWithKeyboardOpen=mUpdateMonitor.isKeyboardOpen();
  LayoutInflater layoutInflater=LayoutInflater.from(context);
  if (mUpdateMonitor.isInPortrait()) {
    layoutInflater.inflate(R.layout.keyguard_screen_password_portrait,this,true);
  }
 else {
    layoutInflater.inflate(R.layout.keyguard_screen_password_landscape,this,true);
  }
  boolean isAlpha=lockPatternUtils.getPasswordMode() == LockPatternUtils.MODE_PASSWORD;
  mKeyboardView=(PasswordEntryKeyboardView)findViewById(R.id.keyboard);
  mPasswordEntry=(EditText)findViewById(R.id.passwordEntry);
  mPasswordEntry.setOnEditorActionListener(this);
  mEmergencyCallButton=(TextView)findViewById(R.id.emergencyCall);
  mEmergencyCallButton.setOnClickListener(this);
  mUpdateMonitor.registerConfigurationChangeCallback(this);
  mLockPatternUtils=lockPatternUtils;
  mKeyboardHelper=new PasswordEntryKeyboardHelper(context,mKeyboardView,this);
  mKeyboardHelper.setKeyboardMode(isAlpha ? PasswordEntryKeyboardHelper.KEYBOARD_MODE_ALPHA : PasswordEntryKeyboardHelper.KEYBOARD_MODE_NUMERIC);
  mKeyboardView.setVisibility(mCreatedWithKeyboardOpen ? View.INVISIBLE : View.VISIBLE);
  mPasswordEntry.requestFocus();
  mKeyboardHelper.setVibratePattern(mLockPatternUtils.isTactileFeedbackEnabled() ? com.android.internal.R.array.config_virtualKeyVibePattern : 0);
}",0.9499489274770172
182550,"public void onPress(int primaryCode){
}","public void onPress(int primaryCode){
  if (mVibratePattern != null) {
    mVibrator.vibrate(mVibratePattern,-1);
  }
}",0.4936708860759494
182551,"public PasswordEntryKeyboardHelper(Context context,KeyboardView keyboardView,View targetView){
  mContext=context;
  mTargetView=targetView;
  mKeyboardView=keyboardView;
  createKeyboards();
  mKeyboardView.setOnKeyboardActionListener(this);
}","public PasswordEntryKeyboardHelper(Context context,KeyboardView keyboardView,View targetView){
  mContext=context;
  mTargetView=targetView;
  mKeyboardView=keyboardView;
  createKeyboards();
  mKeyboardView.setOnKeyboardActionListener(this);
  mVibrator=new Vibrator();
}",0.9457364341085271
182552,"/** 
 * Updates the state of   {@link android.view.accessibility.AccessibilityManager} clients.
 */
private void updateClientsLocked(){
  for (int i=0, count=mClients.size(); i < count; i++) {
    try {
      mClients.get(i).setEnabled(mIsEnabled);
    }
 catch (    RemoteException re) {
      mClients.remove(i);
      count--;
    }
  }
}","/** 
 * Updates the state of   {@link android.view.accessibility.AccessibilityManager} clients.
 */
private void updateClientsLocked(){
  for (int i=0, count=mClients.size(); i < count; i++) {
    try {
      mClients.get(i).setEnabled(mIsEnabled);
    }
 catch (    RemoteException re) {
      mClients.remove(i);
      count--;
      i--;
    }
  }
}",0.963924963924964
182553,"/** 
 * Updates the state of   {@link android.view.accessibility.AccessibilityManager} clients.
 */
private void updateClientsLocked(){
  for (int i=0, count=mClients.size(); i < count; i++) {
    try {
      mClients.get(i).setEnabled(mIsEnabled);
    }
 catch (    RemoteException re) {
      mClients.remove(i);
      count--;
    }
  }
}","/** 
 * Updates the state of   {@link android.view.accessibility.AccessibilityManager} clients.
 */
private void updateClientsLocked(){
  for (int i=0, count=mClients.size(); i < count; i++) {
    try {
      mClients.get(i).setEnabled(mIsEnabled);
    }
 catch (    RemoteException re) {
      mClients.remove(i);
      count--;
      i--;
    }
  }
}",0.963924963924964
182554,"SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    db.addToCompiledQueries(sql,mCompiledSql);
  }
  nStatement=mCompiledSql.nStatement;
}","SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    db.addToCompiledQueries(sql,mCompiledSql);
    mCompiledSql.acquire();
  }
 else {
    if (mCompiledSql.isInUse()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
 else {
      mCompiledSql.acquire();
    }
  }
  nStatement=mCompiledSql.nStatement;
}",0.734475374732334
182555,"@Override protected void onAllReferencesReleasedFromContainer(){
  releaseCompiledSqlIfInCache();
  mDatabase.releaseReference();
}","@Override protected void onAllReferencesReleasedFromContainer(){
  releaseCompiledSqlIfNotInCache();
  mDatabase.releaseReference();
}",0.9886792452830188
182556,"@Override protected void onAllReferencesReleased(){
  releaseCompiledSqlIfInCache();
  mDatabase.releaseReference();
  mDatabase.removeSQLiteClosable(this);
}","@Override protected void onAllReferencesReleased(){
  releaseCompiledSqlIfNotInCache();
  mDatabase.releaseReference();
  mDatabase.removeSQLiteClosable(this);
}",0.9905956112852664
182557,"@MediumTest public void testInsertHelper() throws Exception {
  Cursor cur;
  ContentValues cv;
  long row;
  mDatabase.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  DatabaseUtils.InsertHelper ih=new DatabaseUtils.InsertHelper(mDatabase,""String_Node_Str"");
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertNull(cur.getString(3));
  Assert.assertEquals(1234,cur.getLong(4));
  Assert.assertNull(cur.getString(5));
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertNull(cur.getString(3));
  Assert.assertEquals(1234,cur.getLong(4));
  Assert.assertNull(cur.getString(5));
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  Assert.assertEquals(-1,row);
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",2345);
  cv.put(""String_Node_Str"",3456);
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertEquals(2345,cur.getLong(3));
  Assert.assertEquals(3456,cur.getLong(4));
  Assert.assertEquals(""String_Node_Str"",cur.getString(5));
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",6789);
  row=ih.insert(cv);
  Assert.assertEquals(-1,row);
  row=ih.replace(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertEquals(6789,cur.getLong(3));
  ih.close();
}","@MediumTest public void testInsertHelper() throws Exception {
  Cursor cur;
  ContentValues cv;
  long row;
  mDatabase.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  DatabaseUtils.InsertHelper ih=new DatabaseUtils.InsertHelper(mDatabase,""String_Node_Str"");
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertNull(cur.getString(3));
  Assert.assertEquals(1234,cur.getLong(4));
  Assert.assertNull(cur.getString(5));
  cur.close();
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertNull(cur.getString(3));
  Assert.assertEquals(1234,cur.getLong(4));
  Assert.assertNull(cur.getString(5));
  cur.close();
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  Assert.assertEquals(-1,row);
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",2345);
  cv.put(""String_Node_Str"",3456);
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertEquals(2345,cur.getLong(3));
  Assert.assertEquals(3456,cur.getLong(4));
  Assert.assertEquals(""String_Node_Str"",cur.getString(5));
  cur.close();
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",6789);
  row=ih.insert(cv);
  Assert.assertEquals(-1,row);
  row=ih.replace(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertEquals(6789,cur.getLong(3));
  cur.close();
  ih.close();
}",0.9877200163733116
182558,"public void writeToParcel(Parcel parcel,int flags){
  parcel.writeInt(eventTypes);
  parcel.writeStringArray(packageNames);
  parcel.writeInt(feedbackType);
  parcel.writeLong(notificationTimeout);
  parcel.writeInt(flags);
}","public void writeToParcel(Parcel parcel,int flagz){
  parcel.writeInt(eventTypes);
  parcel.writeStringArray(packageNames);
  parcel.writeInt(feedbackType);
  parcel.writeLong(notificationTimeout);
  parcel.writeInt(flags);
}",0.9955555555555556
182559,"/** 
 * Removes a dead service.
 * @param service The service.
 * @return True if the service was removed, false otherwise.
 */
private boolean removeDeadServiceLocked(Service service){
  mServices.remove(service);
  mHandler.removeMessages(service.mId);
  if (LOGV) {
    Log.i(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
  }
  if (mServices.isEmpty()) {
    mIsEnabled=false;
    updateClientsLocked();
  }
  return true;
}","/** 
 * Removes a dead service.
 * @param service The service.
 * @return True if the service was removed, false otherwise.
 */
private boolean removeDeadServiceLocked(Service service){
  mServices.remove(service);
  mHandler.removeMessages(service.mId);
  if (Config.DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
  }
  if (mServices.isEmpty()) {
    mIsEnabled=false;
    updateClientsLocked();
  }
  return true;
}",0.9845132743362832
182560,"/** 
 * Creates a new instance.
 * @param context A {@link Context} instance.
 */
AccessibilityManagerService(Context context){
  mContext=context;
  mPackageManager=mContext.getPackageManager();
  mCaller=new HandlerCaller(context,this);
  registerPackageChangeAndBootCompletedBroadcastReceiver();
  registerSettingsContentObservers();
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
  }
}","/** 
 * Creates a new instance.
 * @param context A {@link Context} instance.
 */
AccessibilityManagerService(Context context){
  mContext=context;
  mPackageManager=mContext.getPackageManager();
  mCaller=new HandlerCaller(context,this);
  registerPackageChangeAndBootCompletedBroadcastReceiver();
  registerSettingsContentObservers();
}",0.9025367156208278
182561,"/** 
 * Registers a   {@link BroadcastReceiver} for the events ofadding/changing/removing/restarting a package and boot completion.
 */
private void registerPackageChangeAndBootCompletedBroadcastReceiver(){
  Context context=mContext;
  BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mLock) {
        populateAccessibilityServiceListLocked();
        manageServicesLocked();
        if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
          mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
          updateClientsLocked();
        }
      }
    }
  }
;
  IntentFilter packageFilter=new IntentFilter();
  packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  packageFilter.addDataScheme(""String_Node_Str"");
  context.registerReceiver(broadcastReceiver,packageFilter);
  IntentFilter sdFilter=new IntentFilter();
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  mContext.registerReceiver(broadcastReceiver,sdFilter);
  IntentFilter bootFiler=new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
  mContext.registerReceiver(broadcastReceiver,bootFiler);
}","/** 
 * Registers a   {@link BroadcastReceiver} for the events ofadding/changing/removing/restarting a package and boot completion.
 */
private void registerPackageChangeAndBootCompletedBroadcastReceiver(){
  Context context=mContext;
  BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mLock) {
        populateAccessibilityServiceListLocked();
        if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
          mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
          if (mIsEnabled) {
            updateClientsLocked();
          }
        }
        manageServicesLocked();
      }
    }
  }
;
  IntentFilter packageFilter=new IntentFilter();
  packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  packageFilter.addDataScheme(""String_Node_Str"");
  context.registerReceiver(broadcastReceiver,packageFilter);
  IntentFilter sdFilter=new IntentFilter();
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  mContext.registerReceiver(broadcastReceiver,sdFilter);
  IntentFilter bootFiler=new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
  mContext.registerReceiver(broadcastReceiver,bootFiler);
}",0.9448183041722744
182562,"@Override public void onReceive(Context context,Intent intent){
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
    manageServicesLocked();
    if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
      mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
      updateClientsLocked();
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
    if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
      mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
      if (mIsEnabled) {
        updateClientsLocked();
      }
    }
    manageServicesLocked();
  }
}",0.8866498740554156
182563,"/** 
 * Updates the state of each service by starting (or keeping running) enabled ones and stopping the rest.
 * @param installedServices All installed {@link AccessibilityService}s.
 * @param enabledServices The {@link ComponentName}s of the enabled services.
 */
private void updateServicesStateLocked(List<ServiceInfo> installedServices,Set<ComponentName> enabledServices){
  Map<ComponentName,Service> componentNameToServiceMap=mComponentNameToServiceMap;
  List<Service> services=mServices;
  for (int i=0, count=installedServices.size(); i < count; i++) {
    ServiceInfo intalledService=installedServices.get(i);
    ComponentName componentName=new ComponentName(intalledService.packageName,intalledService.name);
    Service service=componentNameToServiceMap.get(componentName);
    if (enabledServices.contains(componentName)) {
      if (service == null) {
        new Service(componentName).bind();
      }
    }
 else {
      if (service != null) {
        service.unbind();
        componentNameToServiceMap.remove(componentName);
        services.remove(service);
      }
    }
  }
}","/** 
 * Updates the state of each service by starting (or keeping running) enabled ones and stopping the rest.
 * @param installedServices All installed {@link AccessibilityService}s.
 * @param enabledServices The {@link ComponentName}s of the enabled services.
 */
private void updateServicesStateLocked(List<ServiceInfo> installedServices,Set<ComponentName> enabledServices){
  Map<ComponentName,Service> componentNameToServiceMap=mComponentNameToServiceMap;
  List<Service> services=mServices;
  boolean isEnabled=mIsEnabled;
  for (int i=0, count=installedServices.size(); i < count; i++) {
    ServiceInfo intalledService=installedServices.get(i);
    ComponentName componentName=new ComponentName(intalledService.packageName,intalledService.name);
    Service service=componentNameToServiceMap.get(componentName);
    if (isEnabled && enabledServices.contains(componentName)) {
      if (service == null) {
        new Service(componentName).bind();
      }
    }
 else {
      if (service != null) {
        service.unbind();
        componentNameToServiceMap.remove(componentName);
        services.remove(service);
      }
    }
  }
}",0.9799196787148594
182564,"/** 
 * Notifies a service for a scheduled event given the event type.
 * @param service The service.
 * @param eventType The type of the event to dispatch.
 */
private void notifyEventListenerLocked(Service service,int eventType){
  IEventListener listener=service.mServiceInterface;
  AccessibilityEvent event=service.mPendingEvents.get(eventType);
  try {
    listener.onAccessibilityEvent(event);
    if (LOGV) {
      Log.i(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ listener);
    }
  }
 catch (  RemoteException re) {
    if (re instanceof DeadObjectException) {
      Log.w(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
synchronized (mLock) {
        removeDeadServiceLocked(service);
      }
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ service.mService,re);
    }
  }
}","/** 
 * Notifies a service for a scheduled event given the event type.
 * @param service The service.
 * @param eventType The type of the event to dispatch.
 */
private void notifyEventListenerLocked(Service service,int eventType){
  IEventListener listener=service.mServiceInterface;
  AccessibilityEvent event=service.mPendingEvents.get(eventType);
  try {
    listener.onAccessibilityEvent(event);
    if (Config.DEBUG) {
      Log.i(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ listener);
    }
  }
 catch (  RemoteException re) {
    if (re instanceof DeadObjectException) {
      Log.w(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
synchronized (mLock) {
        removeDeadServiceLocked(service);
      }
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ service.mService,re);
    }
  }
}",0.9917840375586856
182565,"private void init(String rruleStr,String rdateStr,String exruleStr,String exdateStr){
  if (!TextUtils.isEmpty(rruleStr) || !TextUtils.isEmpty(rdateStr)) {
    if (!TextUtils.isEmpty(rruleStr)) {
      String[] rruleStrs=rruleStr.split(RULE_SEPARATOR);
      rrules=new EventRecurrence[rruleStrs.length];
      for (int i=0; i < rruleStrs.length; ++i) {
        EventRecurrence rrule=new EventRecurrence();
        rrule.parse(rruleStrs[i]);
        rrules[i]=rrule;
      }
    }
    if (!TextUtils.isEmpty(rdateStr)) {
      rdates=parseRecurrenceDates(rdateStr);
    }
    if (!TextUtils.isEmpty(exruleStr)) {
      String[] exruleStrs=exruleStr.split(RULE_SEPARATOR);
      exrules=new EventRecurrence[exruleStrs.length];
      for (int i=0; i < exruleStrs.length; ++i) {
        EventRecurrence exrule=new EventRecurrence();
        exrule.parse(exruleStr);
        exrules[i]=exrule;
      }
    }
    if (!TextUtils.isEmpty(exdateStr)) {
      exdates=parseRecurrenceDates(exdateStr);
    }
  }
}","private void init(String rruleStr,String rdateStr,String exruleStr,String exdateStr) throws EventRecurrence.InvalidFormatException {
  if (!TextUtils.isEmpty(rruleStr) || !TextUtils.isEmpty(rdateStr)) {
    if (!TextUtils.isEmpty(rruleStr)) {
      String[] rruleStrs=rruleStr.split(RULE_SEPARATOR);
      rrules=new EventRecurrence[rruleStrs.length];
      for (int i=0; i < rruleStrs.length; ++i) {
        EventRecurrence rrule=new EventRecurrence();
        rrule.parse(rruleStrs[i]);
        rrules[i]=rrule;
      }
    }
    if (!TextUtils.isEmpty(rdateStr)) {
      rdates=parseRecurrenceDates(rdateStr);
    }
    if (!TextUtils.isEmpty(exruleStr)) {
      String[] exruleStrs=exruleStr.split(RULE_SEPARATOR);
      exrules=new EventRecurrence[exruleStrs.length];
      for (int i=0; i < exruleStrs.length; ++i) {
        EventRecurrence exrule=new EventRecurrence();
        exrule.parse(exruleStr);
        exrules[i]=exrule;
      }
    }
    if (!TextUtils.isEmpty(exdateStr)) {
      exdates=parseRecurrenceDates(exdateStr);
    }
  }
}",0.9771066731612276
182566,"public RecurrenceSet(String rruleStr,String rdateStr,String exruleStr,String exdateStr){
  init(rruleStr,rdateStr,exruleStr,exdateStr);
}","public RecurrenceSet(String rruleStr,String rdateStr,String exruleStr,String exdateStr) throws EventRecurrence.InvalidFormatException {
  init(rruleStr,rdateStr,exruleStr,exdateStr);
}",0.8535825545171339
182567,"private void init(String rruleStr,String rdateStr,String exruleStr,String exdateStr){
  if (!TextUtils.isEmpty(rruleStr) || !TextUtils.isEmpty(rdateStr)) {
    if (!TextUtils.isEmpty(rruleStr)) {
      String[] rruleStrs=rruleStr.split(RULE_SEPARATOR);
      rrules=new EventRecurrence[rruleStrs.length];
      for (int i=0; i < rruleStrs.length; ++i) {
        EventRecurrence rrule=new EventRecurrence();
        rrule.parse(rruleStrs[i]);
        rrules[i]=rrule;
      }
    }
    if (!TextUtils.isEmpty(rdateStr)) {
      rdates=parseRecurrenceDates(rdateStr);
    }
    if (!TextUtils.isEmpty(exruleStr)) {
      String[] exruleStrs=exruleStr.split(RULE_SEPARATOR);
      exrules=new EventRecurrence[exruleStrs.length];
      for (int i=0; i < exruleStrs.length; ++i) {
        EventRecurrence exrule=new EventRecurrence();
        exrule.parse(exruleStr);
        exrules[i]=exrule;
      }
    }
    if (!TextUtils.isEmpty(exdateStr)) {
      exdates=parseRecurrenceDates(exdateStr);
    }
  }
}","private void init(String rruleStr,String rdateStr,String exruleStr,String exdateStr) throws EventRecurrence.InvalidFormatException {
  if (!TextUtils.isEmpty(rruleStr) || !TextUtils.isEmpty(rdateStr)) {
    if (!TextUtils.isEmpty(rruleStr)) {
      String[] rruleStrs=rruleStr.split(RULE_SEPARATOR);
      rrules=new EventRecurrence[rruleStrs.length];
      for (int i=0; i < rruleStrs.length; ++i) {
        EventRecurrence rrule=new EventRecurrence();
        rrule.parse(rruleStrs[i]);
        rrules[i]=rrule;
      }
    }
    if (!TextUtils.isEmpty(rdateStr)) {
      rdates=parseRecurrenceDates(rdateStr);
    }
    if (!TextUtils.isEmpty(exruleStr)) {
      String[] exruleStrs=exruleStr.split(RULE_SEPARATOR);
      exrules=new EventRecurrence[exruleStrs.length];
      for (int i=0; i < exruleStrs.length; ++i) {
        EventRecurrence exrule=new EventRecurrence();
        exrule.parse(exruleStr);
        exrules[i]=exrule;
      }
    }
    if (!TextUtils.isEmpty(exdateStr)) {
      exdates=parseRecurrenceDates(exdateStr);
    }
  }
}",0.9771066731612276
182568,"public RecurrenceSet(String rruleStr,String rdateStr,String exruleStr,String exdateStr){
  init(rruleStr,rdateStr,exruleStr,exdateStr);
}","public RecurrenceSet(String rruleStr,String rdateStr,String exruleStr,String exdateStr) throws EventRecurrence.InvalidFormatException {
  init(rruleStr,rdateStr,exruleStr,exdateStr);
}",0.8535825545171339
182569,"public void writeToParcel(Parcel parcel,int flags){
  parcel.writeInt(eventTypes);
  parcel.writeStringArray(packageNames);
  parcel.writeInt(feedbackType);
  parcel.writeLong(notificationTimeout);
  parcel.writeInt(flags);
}","public void writeToParcel(Parcel parcel,int flagz){
  parcel.writeInt(eventTypes);
  parcel.writeStringArray(packageNames);
  parcel.writeInt(feedbackType);
  parcel.writeLong(notificationTimeout);
  parcel.writeInt(flags);
}",0.9955555555555556
182570,"/** 
 * Removes a dead service.
 * @param service The service.
 * @return True if the service was removed, false otherwise.
 */
private boolean removeDeadServiceLocked(Service service){
  mServices.remove(service);
  mHandler.removeMessages(service.mId);
  if (LOGV) {
    Log.i(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
  }
  if (mServices.isEmpty()) {
    mIsEnabled=false;
    updateClientsLocked();
  }
  return true;
}","/** 
 * Removes a dead service.
 * @param service The service.
 * @return True if the service was removed, false otherwise.
 */
private boolean removeDeadServiceLocked(Service service){
  mServices.remove(service);
  mHandler.removeMessages(service.mId);
  if (Config.DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
  }
  if (mServices.isEmpty()) {
    mIsEnabled=false;
    updateClientsLocked();
  }
  return true;
}",0.9845132743362832
182571,"/** 
 * Creates a new instance.
 * @param context A {@link Context} instance.
 */
AccessibilityManagerService(Context context){
  mContext=context;
  mPackageManager=mContext.getPackageManager();
  mCaller=new HandlerCaller(context,this);
  registerPackageChangeAndBootCompletedBroadcastReceiver();
  registerSettingsContentObservers();
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
  }
}","/** 
 * Creates a new instance.
 * @param context A {@link Context} instance.
 */
AccessibilityManagerService(Context context){
  mContext=context;
  mPackageManager=mContext.getPackageManager();
  mCaller=new HandlerCaller(context,this);
  registerPackageChangeAndBootCompletedBroadcastReceiver();
  registerSettingsContentObservers();
}",0.9025367156208278
182572,"/** 
 * Registers a   {@link BroadcastReceiver} for the events ofadding/changing/removing/restarting a package and boot completion.
 */
private void registerPackageChangeAndBootCompletedBroadcastReceiver(){
  Context context=mContext;
  BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mLock) {
        populateAccessibilityServiceListLocked();
        manageServicesLocked();
        if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
          mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
          updateClientsLocked();
        }
      }
    }
  }
;
  IntentFilter packageFilter=new IntentFilter();
  packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  packageFilter.addDataScheme(""String_Node_Str"");
  context.registerReceiver(broadcastReceiver,packageFilter);
  IntentFilter sdFilter=new IntentFilter();
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  mContext.registerReceiver(broadcastReceiver,sdFilter);
  IntentFilter bootFiler=new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
  mContext.registerReceiver(broadcastReceiver,bootFiler);
}","/** 
 * Registers a   {@link BroadcastReceiver} for the events ofadding/changing/removing/restarting a package and boot completion.
 */
private void registerPackageChangeAndBootCompletedBroadcastReceiver(){
  Context context=mContext;
  BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mLock) {
        populateAccessibilityServiceListLocked();
        if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
          mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
          if (mIsEnabled) {
            updateClientsLocked();
          }
        }
        manageServicesLocked();
      }
    }
  }
;
  IntentFilter packageFilter=new IntentFilter();
  packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  packageFilter.addDataScheme(""String_Node_Str"");
  context.registerReceiver(broadcastReceiver,packageFilter);
  IntentFilter sdFilter=new IntentFilter();
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  mContext.registerReceiver(broadcastReceiver,sdFilter);
  IntentFilter bootFiler=new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
  mContext.registerReceiver(broadcastReceiver,bootFiler);
}",0.9448183041722744
182573,"@Override public void onReceive(Context context,Intent intent){
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
    manageServicesLocked();
    if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
      mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
      updateClientsLocked();
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
    if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
      mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
      if (mIsEnabled) {
        updateClientsLocked();
      }
    }
    manageServicesLocked();
  }
}",0.8866498740554156
182574,"/** 
 * Updates the state of each service by starting (or keeping running) enabled ones and stopping the rest.
 * @param installedServices All installed {@link AccessibilityService}s.
 * @param enabledServices The {@link ComponentName}s of the enabled services.
 */
private void updateServicesStateLocked(List<ServiceInfo> installedServices,Set<ComponentName> enabledServices){
  Map<ComponentName,Service> componentNameToServiceMap=mComponentNameToServiceMap;
  List<Service> services=mServices;
  for (int i=0, count=installedServices.size(); i < count; i++) {
    ServiceInfo intalledService=installedServices.get(i);
    ComponentName componentName=new ComponentName(intalledService.packageName,intalledService.name);
    Service service=componentNameToServiceMap.get(componentName);
    if (enabledServices.contains(componentName)) {
      if (service == null) {
        new Service(componentName).bind();
      }
    }
 else {
      if (service != null) {
        service.unbind();
        componentNameToServiceMap.remove(componentName);
        services.remove(service);
      }
    }
  }
}","/** 
 * Updates the state of each service by starting (or keeping running) enabled ones and stopping the rest.
 * @param installedServices All installed {@link AccessibilityService}s.
 * @param enabledServices The {@link ComponentName}s of the enabled services.
 */
private void updateServicesStateLocked(List<ServiceInfo> installedServices,Set<ComponentName> enabledServices){
  Map<ComponentName,Service> componentNameToServiceMap=mComponentNameToServiceMap;
  List<Service> services=mServices;
  boolean isEnabled=mIsEnabled;
  for (int i=0, count=installedServices.size(); i < count; i++) {
    ServiceInfo intalledService=installedServices.get(i);
    ComponentName componentName=new ComponentName(intalledService.packageName,intalledService.name);
    Service service=componentNameToServiceMap.get(componentName);
    if (isEnabled && enabledServices.contains(componentName)) {
      if (service == null) {
        new Service(componentName).bind();
      }
    }
 else {
      if (service != null) {
        service.unbind();
        componentNameToServiceMap.remove(componentName);
        services.remove(service);
      }
    }
  }
}",0.9799196787148594
182575,"/** 
 * Notifies a service for a scheduled event given the event type.
 * @param service The service.
 * @param eventType The type of the event to dispatch.
 */
private void notifyEventListenerLocked(Service service,int eventType){
  IEventListener listener=service.mServiceInterface;
  AccessibilityEvent event=service.mPendingEvents.get(eventType);
  try {
    listener.onAccessibilityEvent(event);
    if (LOGV) {
      Log.i(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ listener);
    }
  }
 catch (  RemoteException re) {
    if (re instanceof DeadObjectException) {
      Log.w(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
synchronized (mLock) {
        removeDeadServiceLocked(service);
      }
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ service.mService,re);
    }
  }
}","/** 
 * Notifies a service for a scheduled event given the event type.
 * @param service The service.
 * @param eventType The type of the event to dispatch.
 */
private void notifyEventListenerLocked(Service service,int eventType){
  IEventListener listener=service.mServiceInterface;
  AccessibilityEvent event=service.mPendingEvents.get(eventType);
  try {
    listener.onAccessibilityEvent(event);
    if (Config.DEBUG) {
      Log.i(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ listener);
    }
  }
 catch (  RemoteException re) {
    if (re instanceof DeadObjectException) {
      Log.w(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
synchronized (mLock) {
        removeDeadServiceLocked(service);
      }
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ service.mService,re);
    }
  }
}",0.9917840375586856
182576,"/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,streamState.mIndex);
}",0.983529411764706
182577,"private void sendVolumeUpdate(int streamType){
  Intent intent=new Intent(AudioManager.VOLUME_CHANGED_ACTION);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE,streamType);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE,getStreamVolume(streamType));
  if (streamType == AudioSystem.STREAM_BLUETOOTH_SCO) {
    mContext.sendBroadcast(intent);
  }
}","private void sendVolumeUpdate(int streamType,int oldIndex,int index){
  oldIndex=(oldIndex + 5) / 10;
  index=(index + 5) / 10;
  Intent intent=new Intent(AudioManager.VOLUME_CHANGED_ACTION);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE,streamType);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE,index);
  intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE,oldIndex);
  mContext.sendBroadcast(intent);
}",0.6942355889724311
182578,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  final int oldIndex=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}",0.8969422423556059
182579,"/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,streamState.mIndex);
}",0.983529411764706
182580,"private void sendVolumeUpdate(int streamType){
  Intent intent=new Intent(AudioManager.VOLUME_CHANGED_ACTION);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE,streamType);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE,getStreamVolume(streamType));
  if (streamType == AudioSystem.STREAM_BLUETOOTH_SCO) {
    mContext.sendBroadcast(intent);
  }
}","private void sendVolumeUpdate(int streamType,int oldIndex,int index){
  oldIndex=(oldIndex + 5) / 10;
  index=(index + 5) / 10;
  Intent intent=new Intent(AudioManager.VOLUME_CHANGED_ACTION);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE,streamType);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE,index);
  intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE,oldIndex);
  mContext.sendBroadcast(intent);
}",0.6942355889724311
182581,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  final int oldIndex=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}",0.8969422423556059
182582,"private boolean onModifiedTouchEvent(MotionEvent me,boolean possiblePoly){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  final int action=me.getAction();
  final long eventTime=me.getEventTime();
  mOldEventTime=eventTime;
  int keyIndex=getKeyIndices(touchX,touchY,null);
  mPossiblePoly=possiblePoly;
  if (action == MotionEvent.ACTION_DOWN)   mSwipeTracker.clear();
  mSwipeTracker.addMovement(me);
  if (mAbortKey && action != MotionEvent.ACTION_DOWN) {
    return true;
  }
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
repeatKey();
if (mAbortKey) {
mRepeatKeyIndex=NOT_A_KEY;
break;
}
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
break;
case MotionEvent.ACTION_UP:
removeMessages();
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(mCurrentKey,touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
case MotionEvent.ACTION_CANCEL:
removeMessages();
dismissPopupKeyboard();
mAbortKey=true;
showPreview(NOT_A_KEY);
invalidateKey(mCurrentKey);
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}","private boolean onModifiedTouchEvent(MotionEvent me,boolean possiblePoly){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  final int action=me.getAction();
  final long eventTime=me.getEventTime();
  mOldEventTime=eventTime;
  int keyIndex=getKeyIndices(touchX,touchY,null);
  mPossiblePoly=possiblePoly;
  if (action == MotionEvent.ACTION_DOWN)   mSwipeTracker.clear();
  mSwipeTracker.addMovement(me);
  if (mAbortKey && action != MotionEvent.ACTION_DOWN && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
repeatKey();
if (mAbortKey) {
mRepeatKeyIndex=NOT_A_KEY;
break;
}
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
mLastMoveTime=eventTime;
break;
case MotionEvent.ACTION_UP:
removeMessages();
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mCurrentKeyTime < DEBOUNCE_TIME && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(mCurrentKey,touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
case MotionEvent.ACTION_CANCEL:
removeMessages();
dismissPopupKeyboard();
mAbortKey=true;
showPreview(NOT_A_KEY);
invalidateKey(mCurrentKey);
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}",0.9850022723829722
182583,"/** 
 * Checks whether a speech recognition service is available on the system. If this method returns   {@code false},   {@link RecognitionManager#createRecognitionManager(Context)} willfail.
 * @param context with which {@code RecognitionManager} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
public static boolean isRecognitionAvailable(final Context context){
  final List<ResolveInfo> list=context.getPackageManager().queryIntentServices(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),0);
  return list != null && list.size() != 0;
}","/** 
 * Checks whether a speech recognition service is available on the system. If this method returns   {@code false},   {@link RecognitionManager#createRecognitionManager(Context)} willfail.
 * @param context with which {@code RecognitionManager} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
public static boolean isRecognitionAvailable(final Context context){
  final List<ResolveInfo> list=context.getPackageManager().queryIntentServices(new Intent(RecognitionService.SERVICE_INTERFACE),0);
  return list != null && list.size() != 0;
}",0.954468802698145
182584,"/** 
 * Checks whether audio routing to the wired headset is on or off.
 * @return true if audio is being routed to/from wired headset;false if otherwise
 */
public boolean isWiredHeadsetOn(){
  if (AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
    return false;
  }
 else {
    return true;
  }
}","/** 
 * Checks whether audio routing to the wired headset is on or off.
 * @return true if audio is being routed to/from wired headset;false if otherwise
 */
public boolean isWiredHeadsetOn(){
  if (AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE && AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
    return false;
  }
 else {
    return true;
  }
}",0.8486842105263158
182585,"/** 
 * Checks whether a speech recognition service is available on the system. If this method returns   {@code false},   {@link RecognitionManager#createRecognitionManager(Context)} willfail.
 * @param context with which {@code RecognitionManager} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
public static boolean isRecognitionAvailable(final Context context){
  final List<ResolveInfo> list=context.getPackageManager().queryIntentServices(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),0);
  return list != null && list.size() != 0;
}","/** 
 * Checks whether a speech recognition service is available on the system. If this method returns   {@code false},   {@link RecognitionManager#createRecognitionManager(Context)} willfail.
 * @param context with which {@code RecognitionManager} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
public static boolean isRecognitionAvailable(final Context context){
  final List<ResolveInfo> list=context.getPackageManager().queryIntentServices(new Intent(RecognitionService.SERVICE_INTERFACE),0);
  return list != null && list.size() != 0;
}",0.954468802698145
182586,"/** 
 * Checks whether audio routing to the wired headset is on or off.
 * @return true if audio is being routed to/from wired headset;false if otherwise
 */
public boolean isWiredHeadsetOn(){
  if (AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
    return false;
  }
 else {
    return true;
  }
}","/** 
 * Checks whether audio routing to the wired headset is on or off.
 * @return true if audio is being routed to/from wired headset;false if otherwise
 */
public boolean isWiredHeadsetOn(){
  if (AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE && AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
    return false;
  }
 else {
    return true;
  }
}",0.8486842105263158
182587,"private boolean onModifiedTouchEvent(MotionEvent me,boolean possiblePoly){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  final int action=me.getAction();
  final long eventTime=me.getEventTime();
  mOldEventTime=eventTime;
  int keyIndex=getKeyIndices(touchX,touchY,null);
  mPossiblePoly=possiblePoly;
  if (action == MotionEvent.ACTION_DOWN)   mSwipeTracker.clear();
  mSwipeTracker.addMovement(me);
  if (mAbortKey && action != MotionEvent.ACTION_DOWN) {
    return true;
  }
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
repeatKey();
if (mAbortKey) {
mRepeatKeyIndex=NOT_A_KEY;
break;
}
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
break;
case MotionEvent.ACTION_UP:
removeMessages();
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(mCurrentKey,touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
case MotionEvent.ACTION_CANCEL:
removeMessages();
dismissPopupKeyboard();
mAbortKey=true;
showPreview(NOT_A_KEY);
invalidateKey(mCurrentKey);
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}","private boolean onModifiedTouchEvent(MotionEvent me,boolean possiblePoly){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  final int action=me.getAction();
  final long eventTime=me.getEventTime();
  mOldEventTime=eventTime;
  int keyIndex=getKeyIndices(touchX,touchY,null);
  mPossiblePoly=possiblePoly;
  if (action == MotionEvent.ACTION_DOWN)   mSwipeTracker.clear();
  mSwipeTracker.addMovement(me);
  if (mAbortKey && action != MotionEvent.ACTION_DOWN && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
repeatKey();
if (mAbortKey) {
mRepeatKeyIndex=NOT_A_KEY;
break;
}
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
mLastMoveTime=eventTime;
break;
case MotionEvent.ACTION_UP:
removeMessages();
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mCurrentKeyTime < DEBOUNCE_TIME && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(mCurrentKey,touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
case MotionEvent.ACTION_CANCEL:
removeMessages();
dismissPopupKeyboard();
mAbortKey=true;
showPreview(NOT_A_KEY);
invalidateKey(mCurrentKey);
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}",0.9850022723829722
182588,"public void testBasicAccess() throws Exception {
  try {
    byte[] newKey=mSysKeyStore.generateNewKey(128,""String_Node_Str"",keyName);
    assertNotNull(newKey);
    byte[] recKey=mSysKeyStore.retrieveKey(keyName);
    assertEquals(newKey.length,recKey.length);
    for (int i=0; i < newKey.length; i++) {
      assertEquals(newKey[i],recKey[i]);
    }
    mSysKeyStore.deleteKey(keyName);
    byte[] nullKey=mSysKeyStore.retrieveKey(keyName);
    assertNull(nullKey);
    String newKeyStr=mSysKeyStore.generateNewKeyHexString(128,""String_Node_Str"",keyName2);
    assertNotNull(newKeyStr);
    String recKeyStr=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertEquals(newKeyStr,recKeyStr);
    mSysKeyStore.deleteKey(keyName2);
    String nullKey2=mSysKeyStore.retrieveKeyHexString(keyName);
    assertNull(nullKey2);
  }
 catch (  Exception e) {
    fail();
  }
}","public void testBasicAccess() throws Exception {
  try {
    byte[] newKey=mSysKeyStore.generateNewKey(128,""String_Node_Str"",keyName);
    assertNotNull(newKey);
    byte[] recKey=mSysKeyStore.retrieveKey(keyName);
    assertEquals(newKey.length,recKey.length);
    for (int i=0; i < newKey.length; i++) {
      assertEquals(newKey[i],recKey[i]);
    }
    mSysKeyStore.deleteKey(keyName);
    byte[] nullKey=mSysKeyStore.retrieveKey(keyName);
    assertNull(nullKey);
    String newKeyStr=mSysKeyStore.generateNewKeyHexString(128,""String_Node_Str"",keyName2);
    assertNotNull(newKeyStr);
    String recKeyStr=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertEquals(newKeyStr,recKeyStr);
    mSysKeyStore.deleteKey(keyName2);
    String nullKey2=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertNull(nullKey2);
  }
 catch (  Exception e) {
    fail();
  }
}",0.9994249568717654
182589,"public void testBasicAccess() throws Exception {
  try {
    byte[] newKey=mSysKeyStore.generateNewKey(128,""String_Node_Str"",keyName);
    assertNotNull(newKey);
    byte[] recKey=mSysKeyStore.retrieveKey(keyName);
    assertEquals(newKey.length,recKey.length);
    for (int i=0; i < newKey.length; i++) {
      assertEquals(newKey[i],recKey[i]);
    }
    mSysKeyStore.deleteKey(keyName);
    byte[] nullKey=mSysKeyStore.retrieveKey(keyName);
    assertNull(nullKey);
    String newKeyStr=mSysKeyStore.generateNewKeyHexString(128,""String_Node_Str"",keyName2);
    assertNotNull(newKeyStr);
    String recKeyStr=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertEquals(newKeyStr,recKeyStr);
    mSysKeyStore.deleteKey(keyName2);
    String nullKey2=mSysKeyStore.retrieveKeyHexString(keyName);
    assertNull(nullKey2);
  }
 catch (  Exception e) {
    fail();
  }
}","public void testBasicAccess() throws Exception {
  try {
    byte[] newKey=mSysKeyStore.generateNewKey(128,""String_Node_Str"",keyName);
    assertNotNull(newKey);
    byte[] recKey=mSysKeyStore.retrieveKey(keyName);
    assertEquals(newKey.length,recKey.length);
    for (int i=0; i < newKey.length; i++) {
      assertEquals(newKey[i],recKey[i]);
    }
    mSysKeyStore.deleteKey(keyName);
    byte[] nullKey=mSysKeyStore.retrieveKey(keyName);
    assertNull(nullKey);
    String newKeyStr=mSysKeyStore.generateNewKeyHexString(128,""String_Node_Str"",keyName2);
    assertNotNull(newKeyStr);
    String recKeyStr=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertEquals(newKeyStr,recKeyStr);
    mSysKeyStore.deleteKey(keyName2);
    String nullKey2=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertNull(nullKey2);
  }
 catch (  Exception e) {
    fail();
  }
}",0.9994249568717654
182590,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}",0.9890020366598778
182591,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}",0.9969666329625884
182592,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}",0.9972290640394088
182593,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}",0.9890020366598778
182594,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}",0.9969666329625884
182595,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}",0.9972290640394088
182596,"/** 
 * Cancels the speech recognition. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void cancel(){
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  putMessage(Message.obtain(mHandler,MSG_CANCEL));
}","/** 
 * Cancels the speech recognition. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void cancel(){
  checkIsCalledFromMainThread();
  putMessage(Message.obtain(mHandler,MSG_CANCEL));
}",0.9570747217806042
182597,"/** 
 * Starts listening for speech. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 * @param recognizerIntent contains parameters for the recognition to be performed. The intentmay also contain optional extras, see  {@link RecognizerIntent}. If these values are not set explicitly, default values will be used by the recognizer.
 */
public void startListening(final Intent recognizerIntent){
  if (recognizerIntent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  if (mConnection == null) {
    mConnection=new Connection();
    if (!mContext.bindService(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),mConnection,Context.BIND_AUTO_CREATE)) {
      Log.e(TAG,""String_Node_Str"");
      mConnection=null;
      mService=null;
      mListener.onError(ERROR_CLIENT);
      return;
    }
  }
  putMessage(Message.obtain(mHandler,MSG_START,recognizerIntent));
}","/** 
 * Starts listening for speech. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 * @param recognizerIntent contains parameters for the recognition to be performed. The intentmay also contain optional extras, see  {@link RecognizerIntent}. If these values are not set explicitly, default values will be used by the recognizer.
 */
public void startListening(final Intent recognizerIntent){
  if (recognizerIntent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkIsCalledFromMainThread();
  if (mConnection == null) {
    mConnection=new Connection();
    if (!mContext.bindService(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),mConnection,Context.BIND_AUTO_CREATE)) {
      Log.e(TAG,""String_Node_Str"");
      mConnection=null;
      mService=null;
      mListener.onError(ERROR_CLIENT);
      return;
    }
  }
  putMessage(Message.obtain(mHandler,MSG_START,recognizerIntent));
}",0.9870004814636496
182598,"/** 
 * sends the actual message to the service 
 */
private void handleStopMessage(){
  try {
    mService.stopListening(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleStopMessage(){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.stopListening(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}",0.925925925925926
182599,"/** 
 * sends the actual message to the service 
 */
private void handleCancelMessage(){
  try {
    mService.cancel(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleCancelMessage(){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.cancel(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}",0.9247648902821316
182600,"/** 
 * Stops listening for speech. Speech captured so far will be recognized as if the user had stopped speaking at this point. Note that in the default case, this does not need to be called, as the speech endpointer will automatically stop the recognizer listening when it determines speech has completed. However, you can manipulate endpointer parameters directly using the intent extras defined in   {@link RecognizerIntent}, in which case you may sometimes want to manually call this method to stop listening sooner. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void stopListening(){
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  putMessage(Message.obtain(mHandler,MSG_STOP));
}","/** 
 * Stops listening for speech. Speech captured so far will be recognized as if the user had stopped speaking at this point. Note that in the default case, this does not need to be called, as the speech endpointer will automatically stop the recognizer listening when it determines speech has completed. However, you can manipulate endpointer parameters directly using the intent extras defined in   {@link RecognizerIntent}, in which case you may sometimes want to manually call this method to stop listening sooner. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void stopListening(){
  checkIsCalledFromMainThread();
  putMessage(Message.obtain(mHandler,MSG_STOP));
}",0.9831565814098564
182601,"/** 
 * sends the actual message to the service 
 */
private void handleStartListening(Intent recognizerIntent){
  try {
    mService.startListening(recognizerIntent,mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleStartListening(Intent recognizerIntent){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.startListening(recognizerIntent,mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}",0.9347826086956522
182602,"/** 
 * Cancels the speech recognition. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void cancel(){
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  putMessage(Message.obtain(mHandler,MSG_CANCEL));
}","/** 
 * Cancels the speech recognition. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void cancel(){
  checkIsCalledFromMainThread();
  putMessage(Message.obtain(mHandler,MSG_CANCEL));
}",0.9570747217806042
182603,"/** 
 * Starts listening for speech. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 * @param recognizerIntent contains parameters for the recognition to be performed. The intentmay also contain optional extras, see  {@link RecognizerIntent}. If these values are not set explicitly, default values will be used by the recognizer.
 */
public void startListening(final Intent recognizerIntent){
  if (recognizerIntent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  if (mConnection == null) {
    mConnection=new Connection();
    if (!mContext.bindService(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),mConnection,Context.BIND_AUTO_CREATE)) {
      Log.e(TAG,""String_Node_Str"");
      mConnection=null;
      mService=null;
      mListener.onError(ERROR_CLIENT);
      return;
    }
  }
  putMessage(Message.obtain(mHandler,MSG_START,recognizerIntent));
}","/** 
 * Starts listening for speech. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 * @param recognizerIntent contains parameters for the recognition to be performed. The intentmay also contain optional extras, see  {@link RecognizerIntent}. If these values are not set explicitly, default values will be used by the recognizer.
 */
public void startListening(final Intent recognizerIntent){
  if (recognizerIntent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkIsCalledFromMainThread();
  if (mConnection == null) {
    mConnection=new Connection();
    if (!mContext.bindService(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),mConnection,Context.BIND_AUTO_CREATE)) {
      Log.e(TAG,""String_Node_Str"");
      mConnection=null;
      mService=null;
      mListener.onError(ERROR_CLIENT);
      return;
    }
  }
  putMessage(Message.obtain(mHandler,MSG_START,recognizerIntent));
}",0.9870004814636496
182604,"/** 
 * sends the actual message to the service 
 */
private void handleStopMessage(){
  try {
    mService.stopListening(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleStopMessage(){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.stopListening(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}",0.925925925925926
182605,"/** 
 * sends the actual message to the service 
 */
private void handleCancelMessage(){
  try {
    mService.cancel(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleCancelMessage(){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.cancel(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}",0.9247648902821316
182606,"/** 
 * Stops listening for speech. Speech captured so far will be recognized as if the user had stopped speaking at this point. Note that in the default case, this does not need to be called, as the speech endpointer will automatically stop the recognizer listening when it determines speech has completed. However, you can manipulate endpointer parameters directly using the intent extras defined in   {@link RecognizerIntent}, in which case you may sometimes want to manually call this method to stop listening sooner. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void stopListening(){
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  putMessage(Message.obtain(mHandler,MSG_STOP));
}","/** 
 * Stops listening for speech. Speech captured so far will be recognized as if the user had stopped speaking at this point. Note that in the default case, this does not need to be called, as the speech endpointer will automatically stop the recognizer listening when it determines speech has completed. However, you can manipulate endpointer parameters directly using the intent extras defined in   {@link RecognizerIntent}, in which case you may sometimes want to manually call this method to stop listening sooner. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void stopListening(){
  checkIsCalledFromMainThread();
  putMessage(Message.obtain(mHandler,MSG_STOP));
}",0.9831565814098564
182607,"/** 
 * sends the actual message to the service 
 */
private void handleStartListening(Intent recognizerIntent){
  try {
    mService.startListening(recognizerIntent,mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleStartListening(Intent recognizerIntent){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.startListening(recognizerIntent,mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}",0.9347826086956522
182608,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  final int x=(int)ev.getX();
  final int y=(int)ev.getY();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mLastY=y;
          mMotionCorrection=0;
          break;
        }
default :
{
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
          mMotionX=x;
          mMotionY=y;
          mMotionPosition=motionPosition;
        }
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
int motionViewPrevTop=0;
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
if (incrementalDeltaY != 0) {
trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
final int motionViewNewTop=mMotionViewNewTop;
if (motionViewRealTop != motionViewNewTop) {
  mScrollY-=incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  invalidate();
}
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
int topOffset=motionView.getTop() - mMotionViewNewTop;
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
mScrollY-=incrementalDeltaY;
invalidate();
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  final int x=(int)ev.getX();
  final int y=(int)ev.getY();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mLastY=y;
          mMotionCorrection=0;
          break;
        }
default :
{
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
          mMotionX=x;
          mMotionY=y;
          mMotionPosition=motionPosition;
        }
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
int motionViewPrevTop=0;
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
if (incrementalDeltaY != 0) {
trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
final int motionViewNewTop=mMotionViewNewTop;
if (motionViewRealTop != motionViewNewTop) {
  mScrollY-=incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  invalidate();
}
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
mScrollY-=incrementalDeltaY;
invalidate();
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
}
return true;
}",0.9965178854067744
182609,"private boolean startScrollIfNeeded(int deltaY){
  final int distance=Math.abs(deltaY);
  if (distance > mTouchSlop) {
    createScrollingCache();
    mTouchMode=TOUCH_MODE_SCROLL;
    mMotionCorrection=deltaY;
    final Handler handler=getHandler();
    if (handler != null) {
      handler.removeCallbacks(mPendingCheckForLongPress);
    }
    setPressed(false);
    View motionView=getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
      motionView.setPressed(false);
    }
    reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    requestDisallowInterceptTouchEvent(true);
    return true;
  }
  return false;
}","private boolean startScrollIfNeeded(int deltaY){
  final int distance=Math.abs(deltaY);
  final boolean overscroll=mScrollY != 0;
  if (overscroll || distance > mTouchSlop) {
    createScrollingCache();
    mTouchMode=overscroll ? TOUCH_MODE_OVERSCROLL : TOUCH_MODE_SCROLL;
    mMotionCorrection=deltaY;
    final Handler handler=getHandler();
    if (handler != null) {
      handler.removeCallbacks(mPendingCheckForLongPress);
    }
    setPressed(false);
    View motionView=getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
      motionView.setPressed(false);
    }
    reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    requestDisallowInterceptTouchEvent(true);
    return true;
  }
  return false;
}",0.9285208775654636
182610,"private boolean springback(int startX,int startY,int minX,int maxX,int minY,int maxY,Scroller scroller){
  int xoff=0;
  int yoff=0;
  if (startX < minX) {
    xoff=minX - startX;
  }
 else   if (startX > maxX) {
    xoff=maxX - startX;
  }
  if (startY < minY) {
    yoff=minY - startY;
  }
 else   if (startY > maxY) {
    yoff=maxY - startY;
  }
  if (xoff != 0 || yoff != 0) {
    scroller.startScroll(startX,startY,xoff,yoff,SPRINGBACK_DURATION);
    mCurrScroller.abortAnimation();
    mCurrScroller=scroller;
    mScrollMode=MODE_SPRINGBACK;
    return true;
  }
  return false;
}","private boolean springback(int startX,int startY,int minX,int maxX,int minY,int maxY,Scroller scroller){
  int xoff=0;
  int yoff=0;
  if (startX < minX) {
    xoff=minX - startX;
  }
 else   if (startX > maxX) {
    xoff=maxX - startX;
  }
  if (startY < minY) {
    yoff=minY - startY;
  }
 else   if (startY > maxY) {
    yoff=maxY - startY;
  }
  if (xoff != 0 || yoff != 0) {
    mCurrScroller.abortAnimation();
    scroller.startScroll(startX,startY,xoff,yoff,SPRINGBACK_DURATION);
    mCurrScroller=scroller;
    mScrollMode=MODE_SPRINGBACK;
    return true;
  }
  return false;
}",0.938671209540034
182611,"private void overfling(int startx,int starty,float xvel,float yvel){
  Scroller scroller=mDecelScroller;
  final float durationSecs=(OVERFLING_DURATION / 1000.f);
  int dx=(int)(xvel * durationSecs) / 8;
  int dy=(int)(yvel * durationSecs) / 8;
  scroller.startScroll(startx,starty,dx,dy,OVERFLING_DURATION);
  mCurrScroller.abortAnimation();
  mCurrScroller=scroller;
  mScrollMode=MODE_OVERFLING;
}","private void overfling(int startx,int starty,float xvel,float yvel){
  Scroller scroller=mDecelScroller;
  final float durationSecs=(OVERFLING_DURATION / 1000.f);
  int dx=(int)(xvel * durationSecs) / 8;
  int dy=(int)(yvel * durationSecs) / 8;
  mCurrScroller.abortAnimation();
  scroller.startScroll(startx,starty,dx,dy,OVERFLING_DURATION);
  mCurrScroller=scroller;
  mScrollMode=MODE_OVERFLING;
}",0.915
182612,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  final int x=(int)ev.getX();
  final int y=(int)ev.getY();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mLastY=y;
          mMotionCorrection=0;
          break;
        }
default :
{
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
          mMotionX=x;
          mMotionY=y;
          mMotionPosition=motionPosition;
        }
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
int motionViewPrevTop=0;
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
if (incrementalDeltaY != 0) {
trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
final int motionViewNewTop=mMotionViewNewTop;
if (motionViewRealTop != motionViewNewTop) {
  mScrollY-=incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  invalidate();
}
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
int topOffset=motionView.getTop() - mMotionViewNewTop;
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
mScrollY-=incrementalDeltaY;
invalidate();
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  final int x=(int)ev.getX();
  final int y=(int)ev.getY();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mLastY=y;
          mMotionCorrection=0;
          break;
        }
default :
{
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
          mMotionX=x;
          mMotionY=y;
          mMotionPosition=motionPosition;
        }
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
int motionViewPrevTop=0;
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
if (incrementalDeltaY != 0) {
trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
final int motionViewNewTop=mMotionViewNewTop;
if (motionViewRealTop != motionViewNewTop) {
  mScrollY-=incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  invalidate();
}
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
mScrollY-=incrementalDeltaY;
invalidate();
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
}
return true;
}",0.9965178854067744
182613,"private boolean startScrollIfNeeded(int deltaY){
  final int distance=Math.abs(deltaY);
  if (distance > mTouchSlop) {
    createScrollingCache();
    mTouchMode=TOUCH_MODE_SCROLL;
    mMotionCorrection=deltaY;
    final Handler handler=getHandler();
    if (handler != null) {
      handler.removeCallbacks(mPendingCheckForLongPress);
    }
    setPressed(false);
    View motionView=getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
      motionView.setPressed(false);
    }
    reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    requestDisallowInterceptTouchEvent(true);
    return true;
  }
  return false;
}","private boolean startScrollIfNeeded(int deltaY){
  final int distance=Math.abs(deltaY);
  final boolean overscroll=mScrollY != 0;
  if (overscroll || distance > mTouchSlop) {
    createScrollingCache();
    mTouchMode=overscroll ? TOUCH_MODE_OVERSCROLL : TOUCH_MODE_SCROLL;
    mMotionCorrection=deltaY;
    final Handler handler=getHandler();
    if (handler != null) {
      handler.removeCallbacks(mPendingCheckForLongPress);
    }
    setPressed(false);
    View motionView=getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
      motionView.setPressed(false);
    }
    reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    requestDisallowInterceptTouchEvent(true);
    return true;
  }
  return false;
}",0.9285208775654636
182614,"private boolean springback(int startX,int startY,int minX,int maxX,int minY,int maxY,Scroller scroller){
  int xoff=0;
  int yoff=0;
  if (startX < minX) {
    xoff=minX - startX;
  }
 else   if (startX > maxX) {
    xoff=maxX - startX;
  }
  if (startY < minY) {
    yoff=minY - startY;
  }
 else   if (startY > maxY) {
    yoff=maxY - startY;
  }
  if (xoff != 0 || yoff != 0) {
    scroller.startScroll(startX,startY,xoff,yoff,SPRINGBACK_DURATION);
    mCurrScroller.abortAnimation();
    mCurrScroller=scroller;
    mScrollMode=MODE_SPRINGBACK;
    return true;
  }
  return false;
}","private boolean springback(int startX,int startY,int minX,int maxX,int minY,int maxY,Scroller scroller){
  int xoff=0;
  int yoff=0;
  if (startX < minX) {
    xoff=minX - startX;
  }
 else   if (startX > maxX) {
    xoff=maxX - startX;
  }
  if (startY < minY) {
    yoff=minY - startY;
  }
 else   if (startY > maxY) {
    yoff=maxY - startY;
  }
  if (xoff != 0 || yoff != 0) {
    mCurrScroller.abortAnimation();
    scroller.startScroll(startX,startY,xoff,yoff,SPRINGBACK_DURATION);
    mCurrScroller=scroller;
    mScrollMode=MODE_SPRINGBACK;
    return true;
  }
  return false;
}",0.938671209540034
182615,"private void overfling(int startx,int starty,float xvel,float yvel){
  Scroller scroller=mDecelScroller;
  final float durationSecs=(OVERFLING_DURATION / 1000.f);
  int dx=(int)(xvel * durationSecs) / 8;
  int dy=(int)(yvel * durationSecs) / 8;
  scroller.startScroll(startx,starty,dx,dy,OVERFLING_DURATION);
  mCurrScroller.abortAnimation();
  mCurrScroller=scroller;
  mScrollMode=MODE_OVERFLING;
}","private void overfling(int startx,int starty,float xvel,float yvel){
  Scroller scroller=mDecelScroller;
  final float durationSecs=(OVERFLING_DURATION / 1000.f);
  int dx=(int)(xvel * durationSecs) / 8;
  int dy=(int)(yvel * durationSecs) / 8;
  mCurrScroller.abortAnimation();
  scroller.startScroll(startx,starty,dx,dy,OVERFLING_DURATION);
  mCurrScroller=scroller;
  mScrollMode=MODE_OVERFLING;
}",0.915
182616,"private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}","private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}",0.9707792207792209
182617,"void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}","void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}",0.9918831168831168
182618,"void addProvidersForPackageLocked(String pkgName){
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  final int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      addProviderLocked(ri);
    }
  }
}","void addProvidersForPackageLocked(String pkgName){
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  final int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      addProviderLocked(ri);
    }
  }
}",0.9693251533742332
182619,"void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}","void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}",0.9918831168831168
182620,"void addProvidersForPackageLocked(String pkgName){
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  final int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      addProviderLocked(ri);
    }
  }
}","void addProvidersForPackageLocked(String pkgName){
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  final int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      addProviderLocked(ri);
    }
  }
}",0.9693251533742332
182621,"private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}","private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}",0.9707792207792209
182622,"public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  try {
    ((SearchManager)getContext().getSystemService(Context.SEARCH_SERVICE)).stopSearch();
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}","public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  cancel();
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}",0.7684021543985637
182623,"public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  try {
    ((SearchManager)getContext().getSystemService(Context.SEARCH_SERVICE)).stopSearch();
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}","public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  cancel();
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}",0.7684021543985637
182624,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  int delay=0;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    delay=1000;
  }
 else {
    if (mHandler.hasMessages(0)) {
      delay=1000;
    }
  }
  mWakeLock.acquire();
  mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),delay);
}",0.8587570621468926
182625,"protected void startPhotoQuery(long photoId,Uri lookupKey){
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}","/** 
 * startPhotoQuery internal method to query contact photo by photo id and uri.
 * @param photoId the photo id.
 * @param lookupKey the lookup uri.
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not.
 */
protected void startPhotoQuery(long photoId,Uri lookupKey,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}",0.5494505494505495
182626,"private void startContactQuery(Uri contactUri){
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}","/** 
 * startContactQuery internal method to query contact by Uri.
 * @param contactUri the contact uri
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not
 */
private void startContactQuery(Uri contactUri,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}",0.5255731922398589
182627,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param conatctUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  mContactUri=contactLookupUri;
  startContactQuery(contactLookupUri);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param contactLookupUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  bindFromContactUriInternal(contactLookupUri,true);
}",0.8309352517985612
182628,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}",0.9717741935483872
182629,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}",0.9725490196078432
182630,"/** 
 * Method to force this widget to forget everything it knows about the contact. The widget isn't automatically updated or redrawn.
 */
public void wipeClean(){
  setDisplayName(null,null);
  setPhoto(null);
  setSocialSnippet(null);
  mContactUri=null;
  mExcludeMimes=null;
}","/** 
 * Method to force this widget to forget everything it knows about the contact. We need to stop any existing async queries for phone, email, contact, and photos.
 */
public void wipeClean(){
  resetAsyncQueryHandler();
  setDisplayName(null,null);
  setPhoto(loadPlaceholderPhoto(null));
  setSocialSnippet(null);
  setPresence(0);
  mContactUri=null;
  mExcludeMimes=null;
}",0.6928895612708018
182631,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  resetAsyncQueryHandler();
}",0.9805249788314988
182632,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri);
        invalidate();
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (this != mQueryHandler) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri,false);
        invalidate();
      }
 else {
        setDisplayName(null,null);
        setSocialSnippet(null);
        setPhoto(loadPlaceholderPhoto(null));
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      setPhoto(loadPlaceholderPhoto(null));
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    setPhoto(loadPlaceholderPhoto(null));
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}",0.9268398268398268
182633,"public void uploadToBufferObject(){
  mRS.validate();
  mRS.validateSurface();
  mRS.nAllocationUploadToBufferObject(mID);
}","public void uploadToBufferObject(){
  mRS.validate();
  mRS.nAllocationUploadToBufferObject(mID);
}",0.8878923766816144
182634,"public void uploadToTexture(int baseMipLevel){
  mRS.validate();
  mRS.validateSurface();
  mRS.nAllocationUploadToTexture(mID,baseMipLevel);
}","public void uploadToTexture(int baseMipLevel){
  mRS.validate();
  mRS.nAllocationUploadToTexture(mID,baseMipLevel);
}",0.9042145593869731
182635,"public void contextBindProgramFragmentStore(ProgramStore p){
  nContextBindProgramFragmentStore(safeID(p));
}","public void contextBindProgramFragmentStore(ProgramStore p){
  validate();
  nContextBindProgramFragmentStore(safeID(p));
}",0.9396551724137931
182636,"public void contextSetSurface(int w,int h,Surface sur){
  mSurface=sur;
  mWidth=w;
  mHeight=h;
  nContextSetSurface(w,h,mSurface);
}","public void contextSetSurface(int w,int h,Surface sur){
  mSurface=sur;
  mWidth=w;
  mHeight=h;
  validate();
  nContextSetSurface(w,h,mSurface);
}",0.950354609929078
182637,"public void destroy(){
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","public void destroy(){
  validate();
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}",0.9575757575757576
182638,"public void contextBindProgramVertex(ProgramVertex p){
  nContextBindProgramVertex(safeID(p));
}","public void contextBindProgramVertex(ProgramVertex p){
  validate();
  nContextBindProgramVertex(safeID(p));
}",0.9320388349514565
182639,"public void contextBindProgramFragment(ProgramFragment p){
  nContextBindProgramFragment(safeID(p));
}","public void contextBindProgramFragment(ProgramFragment p){
  validate();
  nContextBindProgramFragment(safeID(p));
}",0.9357798165137616
182640,"void resume(){
  nContextResume();
}","void resume(){
  validate();
  nContextResume();
}",0.8372093023255814
182641,"public void contextBindRootScript(Script s){
  nContextBindRootScript(safeID(s));
}","public void contextBindRootScript(Script s){
  validate();
  nContextBindRootScript(safeID(s));
}",0.9222222222222224
182642,"public void contextDump(int bits){
  nContextDump(bits);
}","public void contextDump(int bits){
  validate();
  nContextDump(bits);
}",0.8923076923076924
182643,"void pause(){
  nContextPause();
}","void pause(){
  validate();
  nContextPause();
}",0.8292682926829268
182644,"public void contextBindProgramRaster(ProgramRaster p){
  nContextBindProgramRaster(safeID(p));
}","public void contextBindProgramRaster(ProgramRaster p){
  validate();
  nContextBindProgramRaster(safeID(p));
}",0.9320388349514565
182645,"public void contextSetPriority(Priority p){
  nContextSetPriority(p.mID);
}","public void contextSetPriority(Priority p){
  validate();
  nContextSetPriority(p.mID);
}",0.9146341463414634
182646,"public void uploadToBufferObject(){
  mRS.validate();
  mRS.validateSurface();
  mRS.nAllocationUploadToBufferObject(mID);
}","public void uploadToBufferObject(){
  mRS.validate();
  mRS.nAllocationUploadToBufferObject(mID);
}",0.8878923766816144
182647,"public void uploadToTexture(int baseMipLevel){
  mRS.validate();
  mRS.validateSurface();
  mRS.nAllocationUploadToTexture(mID,baseMipLevel);
}","public void uploadToTexture(int baseMipLevel){
  mRS.validate();
  mRS.nAllocationUploadToTexture(mID,baseMipLevel);
}",0.9042145593869731
182648,"public void contextBindProgramFragmentStore(ProgramStore p){
  nContextBindProgramFragmentStore(safeID(p));
}","public void contextBindProgramFragmentStore(ProgramStore p){
  validate();
  nContextBindProgramFragmentStore(safeID(p));
}",0.9396551724137931
182649,"public void contextSetSurface(int w,int h,Surface sur){
  mSurface=sur;
  mWidth=w;
  mHeight=h;
  nContextSetSurface(w,h,mSurface);
}","public void contextSetSurface(int w,int h,Surface sur){
  mSurface=sur;
  mWidth=w;
  mHeight=h;
  validate();
  nContextSetSurface(w,h,mSurface);
}",0.950354609929078
182650,"public void destroy(){
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","public void destroy(){
  validate();
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}",0.9575757575757576
182651,"public void contextBindProgramVertex(ProgramVertex p){
  nContextBindProgramVertex(safeID(p));
}","public void contextBindProgramVertex(ProgramVertex p){
  validate();
  nContextBindProgramVertex(safeID(p));
}",0.9320388349514565
182652,"public void contextBindProgramFragment(ProgramFragment p){
  nContextBindProgramFragment(safeID(p));
}","public void contextBindProgramFragment(ProgramFragment p){
  validate();
  nContextBindProgramFragment(safeID(p));
}",0.9357798165137616
182653,"void resume(){
  nContextResume();
}","void resume(){
  validate();
  nContextResume();
}",0.8372093023255814
182654,"public void contextBindRootScript(Script s){
  nContextBindRootScript(safeID(s));
}","public void contextBindRootScript(Script s){
  validate();
  nContextBindRootScript(safeID(s));
}",0.9222222222222224
182655,"public void contextDump(int bits){
  nContextDump(bits);
}","public void contextDump(int bits){
  validate();
  nContextDump(bits);
}",0.8923076923076924
182656,"void pause(){
  nContextPause();
}","void pause(){
  validate();
  nContextPause();
}",0.8292682926829268
182657,"public void contextBindProgramRaster(ProgramRaster p){
  nContextBindProgramRaster(safeID(p));
}","public void contextBindProgramRaster(ProgramRaster p){
  validate();
  nContextBindProgramRaster(safeID(p));
}",0.9320388349514565
182658,"public void contextSetPriority(Priority p){
  nContextSetPriority(p.mID);
}","public void contextSetPriority(Priority p){
  validate();
  nContextSetPriority(p.mID);
}",0.9146341463414634
182659,"@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,""String_Node_Str"" + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,""String_Node_Str"",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case SHOW_RECT_MSG_ID:
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
break;
default :
super.handleMessage(msg);
break;
}
}","@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case UPDATE_ZOOM_RANGE:
{
WebViewCore.RestoreState restoreState=(WebViewCore.RestoreState)msg.obj;
updateZoomRange(restoreState,getViewWidth(),restoreState.mScrollX,false);
break;
}
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
updateZoomRange(restoreState,viewSize.x,draw.mMinPrefWidth,true);
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,""String_Node_Str"" + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,""String_Node_Str"",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case SHOW_RECT_MSG_ID:
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
break;
default :
super.handleMessage(msg);
break;
}
}",0.8979010106245141
182660,"private void setupViewport(boolean updateRestoreState){
  setViewportSettingsFromNative();
  float adjust=1.0f;
  if (mViewportDensityDpi == -1) {
    if (WebView.DEFAULT_SCALE_PERCENT != 100) {
      adjust=WebView.DEFAULT_SCALE_PERCENT / 100.0f;
    }
  }
 else   if (mViewportDensityDpi > 0) {
    adjust=(float)mContext.getResources().getDisplayMetrics().densityDpi / mViewportDensityDpi;
  }
  int defaultScale=(int)(adjust * 100);
  if (mViewportInitialScale > 0) {
    mViewportInitialScale*=adjust;
  }
  if (mViewportMinimumScale > 0) {
    mViewportMinimumScale*=adjust;
  }
  if (mViewportMaximumScale > 0) {
    mViewportMaximumScale*=adjust;
  }
  if (mViewportWidth == 0) {
    if (mViewportInitialScale == 0) {
      mViewportInitialScale=defaultScale;
    }
  }
  if (mViewportUserScalable == false) {
    mViewportInitialScale=defaultScale;
    mViewportMinimumScale=defaultScale;
    mViewportMaximumScale=defaultScale;
  }
  if (mViewportMinimumScale > mViewportInitialScale && mViewportInitialScale != 0) {
    mViewportMinimumScale=mViewportInitialScale;
  }
  if (mViewportMaximumScale > 0 && mViewportMaximumScale < mViewportInitialScale) {
    mViewportMaximumScale=mViewportInitialScale;
  }
  if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
    mViewportWidth=0;
  }
  if (mViewportWidth != 0 && !updateRestoreState)   return;
  int webViewWidth;
  int viewportWidth=mCurrentViewWidth;
  if (viewportWidth == 0) {
    webViewWidth=mWebView.getViewWidth();
    viewportWidth=(int)(webViewWidth / adjust);
    if (viewportWidth == 0) {
      Log.w(LOGTAG,""String_Node_Str"");
    }
  }
 else {
    webViewWidth=Math.round(viewportWidth * mCurrentViewScale);
  }
  mRestoreState=new RestoreState();
  mRestoreState.mMinScale=mViewportMinimumScale / 100.0f;
  mRestoreState.mMaxScale=mViewportMaximumScale / 100.0f;
  mRestoreState.mDefaultScale=adjust;
  mRestoreState.mScrollX=mRestoredX;
  mRestoreState.mScrollY=mRestoredY;
  mRestoreState.mMobileSite=(0 == mViewportWidth);
  if (mRestoredScale > 0) {
    mRestoreState.mViewScale=mRestoredScale / 100.0f;
    if (mRestoredScreenWidthScale > 0) {
      mRestoreState.mTextWrapScale=mRestoredScreenWidthScale / 100.0f;
    }
 else {
      mRestoreState.mTextWrapScale=mRestoreState.mViewScale;
    }
  }
 else {
    if (mViewportInitialScale > 0) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=mViewportInitialScale / 100.0f;
    }
 else     if (mViewportWidth > 0 && mViewportWidth < webViewWidth) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=(float)webViewWidth / mViewportWidth;
    }
 else {
      mRestoreState.mTextWrapScale=adjust;
      mRestoreState.mViewScale=0;
    }
  }
  if (mWebView.mHeightCanMeasure) {
    mWebView.mLastHeightSent=0;
    WebView.ViewSizeData data=new WebView.ViewSizeData();
    data.mWidth=mWebView.mLastWidthSent;
    data.mHeight=0;
    data.mTextWrapWidth=data.mWidth;
    data.mScale=-1.0f;
    data.mIgnoreHeight=false;
    data.mAnchorX=data.mAnchorY=0;
    mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
    mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
  }
 else   if (mSettings.getUseWideViewPort()) {
    if (viewportWidth == 0) {
      mWebView.mLastWidthSent=0;
    }
 else {
      WebView.ViewSizeData data=new WebView.ViewSizeData();
      data.mScale=mRestoreState.mViewScale == 0 ? (mRestoredScale > 0 ? mRestoredScale : mRestoreState.mTextWrapScale) : mRestoreState.mViewScale;
      data.mWidth=Math.round(webViewWidth / data.mScale);
      data.mHeight=mCurrentViewHeight * data.mWidth / viewportWidth;
      data.mTextWrapWidth=Math.round(webViewWidth / mRestoreState.mTextWrapScale);
      data.mIgnoreHeight=false;
      data.mAnchorX=data.mAnchorY=0;
      mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
      mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
    }
  }
}","private void setupViewport(boolean updateRestoreState){
  setViewportSettingsFromNative();
  float adjust=1.0f;
  if (mViewportDensityDpi == -1) {
    if (WebView.DEFAULT_SCALE_PERCENT != 100) {
      adjust=WebView.DEFAULT_SCALE_PERCENT / 100.0f;
    }
  }
 else   if (mViewportDensityDpi > 0) {
    adjust=(float)mContext.getResources().getDisplayMetrics().densityDpi / mViewportDensityDpi;
  }
  int defaultScale=(int)(adjust * 100);
  if (mViewportInitialScale > 0) {
    mViewportInitialScale*=adjust;
  }
  if (mViewportMinimumScale > 0) {
    mViewportMinimumScale*=adjust;
  }
  if (mViewportMaximumScale > 0) {
    mViewportMaximumScale*=adjust;
  }
  if (mViewportWidth == 0) {
    if (mViewportInitialScale == 0) {
      mViewportInitialScale=defaultScale;
    }
  }
  if (mViewportUserScalable == false) {
    mViewportInitialScale=defaultScale;
    mViewportMinimumScale=defaultScale;
    mViewportMaximumScale=defaultScale;
  }
  if (mViewportMinimumScale > mViewportInitialScale && mViewportInitialScale != 0) {
    mViewportMinimumScale=mViewportInitialScale;
  }
  if (mViewportMaximumScale > 0 && mViewportMaximumScale < mViewportInitialScale) {
    mViewportMaximumScale=mViewportInitialScale;
  }
  if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
    mViewportWidth=0;
  }
  if (mViewportWidth != 0 && !updateRestoreState) {
    RestoreState restoreState=new RestoreState();
    restoreState.mMinScale=mViewportMinimumScale / 100.0f;
    restoreState.mMaxScale=mViewportMaximumScale / 100.0f;
    restoreState.mDefaultScale=adjust;
    restoreState.mMobileSite=false;
    restoreState.mScrollX=0;
    Message.obtain(mWebView.mPrivateHandler,WebView.UPDATE_ZOOM_RANGE,restoreState).sendToTarget();
    return;
  }
  int webViewWidth;
  int viewportWidth=mCurrentViewWidth;
  if (viewportWidth == 0) {
    webViewWidth=mWebView.getViewWidth();
    viewportWidth=(int)(webViewWidth / adjust);
    if (viewportWidth == 0) {
      Log.w(LOGTAG,""String_Node_Str"");
    }
  }
 else {
    webViewWidth=Math.round(viewportWidth * mCurrentViewScale);
  }
  mRestoreState=new RestoreState();
  mRestoreState.mMinScale=mViewportMinimumScale / 100.0f;
  mRestoreState.mMaxScale=mViewportMaximumScale / 100.0f;
  mRestoreState.mDefaultScale=adjust;
  mRestoreState.mScrollX=mRestoredX;
  mRestoreState.mScrollY=mRestoredY;
  mRestoreState.mMobileSite=(0 == mViewportWidth);
  if (mRestoredScale > 0) {
    mRestoreState.mViewScale=mRestoredScale / 100.0f;
    if (mRestoredScreenWidthScale > 0) {
      mRestoreState.mTextWrapScale=mRestoredScreenWidthScale / 100.0f;
    }
 else {
      mRestoreState.mTextWrapScale=mRestoreState.mViewScale;
    }
  }
 else {
    if (mViewportInitialScale > 0) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=mViewportInitialScale / 100.0f;
    }
 else     if (mViewportWidth > 0 && mViewportWidth < webViewWidth) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=(float)webViewWidth / mViewportWidth;
    }
 else {
      mRestoreState.mTextWrapScale=adjust;
      mRestoreState.mViewScale=0;
    }
  }
  if (mWebView.mHeightCanMeasure) {
    mWebView.mLastHeightSent=0;
    WebView.ViewSizeData data=new WebView.ViewSizeData();
    data.mWidth=mWebView.mLastWidthSent;
    data.mHeight=0;
    data.mTextWrapWidth=data.mWidth;
    data.mScale=-1.0f;
    data.mIgnoreHeight=false;
    data.mAnchorX=data.mAnchorY=0;
    mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
    mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
  }
 else   if (mSettings.getUseWideViewPort()) {
    if (viewportWidth == 0) {
      mWebView.mLastWidthSent=0;
    }
 else {
      WebView.ViewSizeData data=new WebView.ViewSizeData();
      data.mScale=mRestoreState.mViewScale == 0 ? (mRestoredScale > 0 ? mRestoredScale : mRestoreState.mTextWrapScale) : mRestoreState.mViewScale;
      data.mWidth=Math.round(webViewWidth / data.mScale);
      data.mHeight=mCurrentViewHeight * data.mWidth / viewportWidth;
      data.mTextWrapWidth=Math.round(webViewWidth / mRestoreState.mTextWrapScale);
      data.mIgnoreHeight=false;
      data.mAnchorX=data.mAnchorY=0;
      mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
      mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
    }
  }
}",0.9519903498190592
182661,"@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,""String_Node_Str"" + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,""String_Node_Str"",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case SHOW_RECT_MSG_ID:
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
break;
default :
super.handleMessage(msg);
break;
}
}","@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case UPDATE_ZOOM_RANGE:
{
WebViewCore.RestoreState restoreState=(WebViewCore.RestoreState)msg.obj;
updateZoomRange(restoreState,getViewWidth(),restoreState.mScrollX,false);
break;
}
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
updateZoomRange(restoreState,viewSize.x,draw.mMinPrefWidth,true);
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,""String_Node_Str"" + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,""String_Node_Str"",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case SHOW_RECT_MSG_ID:
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
break;
default :
super.handleMessage(msg);
break;
}
}",0.8979010106245141
182662,"private void setupViewport(boolean updateRestoreState){
  setViewportSettingsFromNative();
  float adjust=1.0f;
  if (mViewportDensityDpi == -1) {
    if (WebView.DEFAULT_SCALE_PERCENT != 100) {
      adjust=WebView.DEFAULT_SCALE_PERCENT / 100.0f;
    }
  }
 else   if (mViewportDensityDpi > 0) {
    adjust=(float)mContext.getResources().getDisplayMetrics().densityDpi / mViewportDensityDpi;
  }
  int defaultScale=(int)(adjust * 100);
  if (mViewportInitialScale > 0) {
    mViewportInitialScale*=adjust;
  }
  if (mViewportMinimumScale > 0) {
    mViewportMinimumScale*=adjust;
  }
  if (mViewportMaximumScale > 0) {
    mViewportMaximumScale*=adjust;
  }
  if (mViewportWidth == 0) {
    if (mViewportInitialScale == 0) {
      mViewportInitialScale=defaultScale;
    }
  }
  if (mViewportUserScalable == false) {
    mViewportInitialScale=defaultScale;
    mViewportMinimumScale=defaultScale;
    mViewportMaximumScale=defaultScale;
  }
  if (mViewportMinimumScale > mViewportInitialScale && mViewportInitialScale != 0) {
    mViewportMinimumScale=mViewportInitialScale;
  }
  if (mViewportMaximumScale > 0 && mViewportMaximumScale < mViewportInitialScale) {
    mViewportMaximumScale=mViewportInitialScale;
  }
  if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
    mViewportWidth=0;
  }
  if (mViewportWidth != 0 && !updateRestoreState)   return;
  int webViewWidth;
  int viewportWidth=mCurrentViewWidth;
  if (viewportWidth == 0) {
    webViewWidth=mWebView.getViewWidth();
    viewportWidth=(int)(webViewWidth / adjust);
    if (viewportWidth == 0) {
      Log.w(LOGTAG,""String_Node_Str"");
    }
  }
 else {
    webViewWidth=Math.round(viewportWidth * mCurrentViewScale);
  }
  mRestoreState=new RestoreState();
  mRestoreState.mMinScale=mViewportMinimumScale / 100.0f;
  mRestoreState.mMaxScale=mViewportMaximumScale / 100.0f;
  mRestoreState.mDefaultScale=adjust;
  mRestoreState.mScrollX=mRestoredX;
  mRestoreState.mScrollY=mRestoredY;
  mRestoreState.mMobileSite=(0 == mViewportWidth);
  if (mRestoredScale > 0) {
    mRestoreState.mViewScale=mRestoredScale / 100.0f;
    if (mRestoredScreenWidthScale > 0) {
      mRestoreState.mTextWrapScale=mRestoredScreenWidthScale / 100.0f;
    }
 else {
      mRestoreState.mTextWrapScale=mRestoreState.mViewScale;
    }
  }
 else {
    if (mViewportInitialScale > 0) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=mViewportInitialScale / 100.0f;
    }
 else     if (mViewportWidth > 0 && mViewportWidth < webViewWidth) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=(float)webViewWidth / mViewportWidth;
    }
 else {
      mRestoreState.mTextWrapScale=adjust;
      mRestoreState.mViewScale=0;
    }
  }
  if (mWebView.mHeightCanMeasure) {
    mWebView.mLastHeightSent=0;
    WebView.ViewSizeData data=new WebView.ViewSizeData();
    data.mWidth=mWebView.mLastWidthSent;
    data.mHeight=0;
    data.mTextWrapWidth=data.mWidth;
    data.mScale=-1.0f;
    data.mIgnoreHeight=false;
    data.mAnchorX=data.mAnchorY=0;
    mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
    mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
  }
 else   if (mSettings.getUseWideViewPort()) {
    if (viewportWidth == 0) {
      mWebView.mLastWidthSent=0;
    }
 else {
      WebView.ViewSizeData data=new WebView.ViewSizeData();
      data.mScale=mRestoreState.mViewScale == 0 ? (mRestoredScale > 0 ? mRestoredScale : mRestoreState.mTextWrapScale) : mRestoreState.mViewScale;
      data.mWidth=Math.round(webViewWidth / data.mScale);
      data.mHeight=mCurrentViewHeight * data.mWidth / viewportWidth;
      data.mTextWrapWidth=Math.round(webViewWidth / mRestoreState.mTextWrapScale);
      data.mIgnoreHeight=false;
      data.mAnchorX=data.mAnchorY=0;
      mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
      mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
    }
  }
}","private void setupViewport(boolean updateRestoreState){
  setViewportSettingsFromNative();
  float adjust=1.0f;
  if (mViewportDensityDpi == -1) {
    if (WebView.DEFAULT_SCALE_PERCENT != 100) {
      adjust=WebView.DEFAULT_SCALE_PERCENT / 100.0f;
    }
  }
 else   if (mViewportDensityDpi > 0) {
    adjust=(float)mContext.getResources().getDisplayMetrics().densityDpi / mViewportDensityDpi;
  }
  int defaultScale=(int)(adjust * 100);
  if (mViewportInitialScale > 0) {
    mViewportInitialScale*=adjust;
  }
  if (mViewportMinimumScale > 0) {
    mViewportMinimumScale*=adjust;
  }
  if (mViewportMaximumScale > 0) {
    mViewportMaximumScale*=adjust;
  }
  if (mViewportWidth == 0) {
    if (mViewportInitialScale == 0) {
      mViewportInitialScale=defaultScale;
    }
  }
  if (mViewportUserScalable == false) {
    mViewportInitialScale=defaultScale;
    mViewportMinimumScale=defaultScale;
    mViewportMaximumScale=defaultScale;
  }
  if (mViewportMinimumScale > mViewportInitialScale && mViewportInitialScale != 0) {
    mViewportMinimumScale=mViewportInitialScale;
  }
  if (mViewportMaximumScale > 0 && mViewportMaximumScale < mViewportInitialScale) {
    mViewportMaximumScale=mViewportInitialScale;
  }
  if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
    mViewportWidth=0;
  }
  if (mViewportWidth != 0 && !updateRestoreState) {
    RestoreState restoreState=new RestoreState();
    restoreState.mMinScale=mViewportMinimumScale / 100.0f;
    restoreState.mMaxScale=mViewportMaximumScale / 100.0f;
    restoreState.mDefaultScale=adjust;
    restoreState.mMobileSite=false;
    restoreState.mScrollX=0;
    Message.obtain(mWebView.mPrivateHandler,WebView.UPDATE_ZOOM_RANGE,restoreState).sendToTarget();
    return;
  }
  int webViewWidth;
  int viewportWidth=mCurrentViewWidth;
  if (viewportWidth == 0) {
    webViewWidth=mWebView.getViewWidth();
    viewportWidth=(int)(webViewWidth / adjust);
    if (viewportWidth == 0) {
      Log.w(LOGTAG,""String_Node_Str"");
    }
  }
 else {
    webViewWidth=Math.round(viewportWidth * mCurrentViewScale);
  }
  mRestoreState=new RestoreState();
  mRestoreState.mMinScale=mViewportMinimumScale / 100.0f;
  mRestoreState.mMaxScale=mViewportMaximumScale / 100.0f;
  mRestoreState.mDefaultScale=adjust;
  mRestoreState.mScrollX=mRestoredX;
  mRestoreState.mScrollY=mRestoredY;
  mRestoreState.mMobileSite=(0 == mViewportWidth);
  if (mRestoredScale > 0) {
    mRestoreState.mViewScale=mRestoredScale / 100.0f;
    if (mRestoredScreenWidthScale > 0) {
      mRestoreState.mTextWrapScale=mRestoredScreenWidthScale / 100.0f;
    }
 else {
      mRestoreState.mTextWrapScale=mRestoreState.mViewScale;
    }
  }
 else {
    if (mViewportInitialScale > 0) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=mViewportInitialScale / 100.0f;
    }
 else     if (mViewportWidth > 0 && mViewportWidth < webViewWidth) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=(float)webViewWidth / mViewportWidth;
    }
 else {
      mRestoreState.mTextWrapScale=adjust;
      mRestoreState.mViewScale=0;
    }
  }
  if (mWebView.mHeightCanMeasure) {
    mWebView.mLastHeightSent=0;
    WebView.ViewSizeData data=new WebView.ViewSizeData();
    data.mWidth=mWebView.mLastWidthSent;
    data.mHeight=0;
    data.mTextWrapWidth=data.mWidth;
    data.mScale=-1.0f;
    data.mIgnoreHeight=false;
    data.mAnchorX=data.mAnchorY=0;
    mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
    mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
  }
 else   if (mSettings.getUseWideViewPort()) {
    if (viewportWidth == 0) {
      mWebView.mLastWidthSent=0;
    }
 else {
      WebView.ViewSizeData data=new WebView.ViewSizeData();
      data.mScale=mRestoreState.mViewScale == 0 ? (mRestoredScale > 0 ? mRestoredScale : mRestoreState.mTextWrapScale) : mRestoreState.mViewScale;
      data.mWidth=Math.round(webViewWidth / data.mScale);
      data.mHeight=mCurrentViewHeight * data.mWidth / viewportWidth;
      data.mTextWrapWidth=Math.round(webViewWidth / mRestoreState.mTextWrapScale);
      data.mIgnoreHeight=false;
      data.mAnchorX=data.mAnchorY=0;
      mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
      mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
    }
  }
}",0.9519903498190592
182663,"@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > RETURN_LABEL ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
    mPreventLongPress=false;
    mPreventDoubleTap=false;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=mFullScreenHolder == null ? TOUCH_SHORTPRESS_START_MODE : TOUCH_SHORTPRESS_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventLongPress) {
  mTouchMode=TOUCH_DONE_MODE;
  WebViewCore.TouchEventData ted=new WebViewCore.TouchEventData();
  ted.mAction=WebViewCore.ACTION_LONGPRESS;
  ted.mX=viewToContentX((int)mLastTouchX + mScrollX);
  ted.mY=viewToContentY((int)mLastTouchY + mScrollY);
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  if (mFullScreenHolder == null) {
    performLongClick();
    rebuildWebTextView();
  }
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=PREVENT_DRAG_NO;
mPreventLongPress=false;
mPreventDoubleTap=false;
}
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
boolean hasRestoreState=restoreState != null;
if (hasRestoreState) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
if (getSettings().getBuiltInZoomControls()) {
updateZoomButtonsEnabled();
}
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.min(sMaxViewportWidth,Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x)));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
if (draw.mFocusSizeChanged && inEditingMode()) {
mFocusSizeChanged=true;
}
if (hasRestoreState) {
mViewManager.postReadyToDrawAll();
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case RETURN_LABEL:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setHint((String)msg.obj);
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && imm.isActive(mWebTextView)) {
imm.restartInput(mWebTextView);
}
}
break;
case MOVE_OUT_OF_PLUGIN:
navHandledKey(msg.arg1,1,false,0,true);
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case IMMEDIATE_REPAINT_MSG_ID:
{
int updates=msg.arg1;
if (updates != 0) {
nativeUpdateLayers(mRootLayer,updates);
}
invalidate();
break;
}
case SET_ROOT_LAYER_MSG_ID:
{
int oldLayer=mRootLayer;
mRootLayer=msg.arg1;
if (oldLayer > 0) {
nativeDestroyLayer(oldLayer);
}
if (mRootLayer == 0) {
mLayersHaveAnimations=false;
}
if (mEvaluateThread != null) {
mEvaluateThread.cancel();
mEvaluateThread=null;
}
if (nativeLayersHaveAnimations(mRootLayer)) {
mLayersHaveAnimations=true;
mEvaluateThread=new EvaluateLayersAnimations();
mEvaluateThread.start();
}
invalidate();
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case RESUME_WEBCORE_PRIORITY:
WebViewCore.resumePriority(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=(msg.arg2 & TOUCH_PREVENT_DRAG) == TOUCH_PREVENT_DRAG ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
 else {
mPreventLongPress=(msg.arg2 & TOUCH_PREVENT_LONGPRESS) == TOUCH_PREVENT_LONGPRESS;
mPreventDoubleTap=(msg.arg2 & TOUCH_PREVENT_DOUBLETAP) == TOUCH_PREVENT_DOUBLETAP;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(1 == msg.arg2);
}
break;
case FIND_AGAIN:
if (mFindIsUp) {
findAll(mLastFind);
}
break;
case DRAG_HELD_MOTIONLESS:
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case AWAKEN_SCROLL_BARS:
if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS),ViewConfiguration.getScrollDefaultDelay());
}
break;
case DO_MOTION_UP:
doMotionUp(msg.arg1,msg.arg2);
break;
case SHOW_FULLSCREEN:
{
WebViewCore.PluginFullScreenData data=(WebViewCore.PluginFullScreenData)msg.obj;
if (data.mNpp != 0 && data.mView != null) {
if (mFullScreenHolder != null) {
Log.w(LOGTAG,""String_Node_Str"");
mFullScreenHolder.dismiss();
}
mFullScreenHolder=new PluginFullScreenHolder(WebView.this,data.mNpp);
data.mView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.FILL_PARENT));
mFullScreenHolder.setContentView(data.mView);
mFullScreenHolder.setCancelable(false);
mFullScreenHolder.setCanceledOnTouchOutside(false);
mFullScreenHolder.show();
}
 else if (mFullScreenHolder == null) {
break;
}
int x=contentToViewX(data.mDocX);
int y=contentToViewY(data.mDocY);
int width=contentToViewDimension(data.mDocWidth);
int height=contentToViewDimension(data.mDocHeight);
int viewWidth=getViewWidth();
int viewHeight=getViewHeight();
int newX=mScrollX;
int newY=mScrollY;
if (x < mScrollX) {
newX=x + (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
 else if (x + width > mScrollX + viewWidth) {
newX=x + width - viewWidth - (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
if (y < mScrollY) {
newY=y + (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
 else if (y + height > mScrollY + viewHeight) {
newY=y + height - viewHeight - (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
scrollTo(newX,newY);
if (width > viewWidth || height > viewHeight) {
mZoomCenterX=viewWidth * .5f;
mZoomCenterY=viewHeight * .5f;
setNewZoomScale(mActualScale / Math.max((float)width / viewWidth,(float)height / viewHeight),false,false);
}
mFullScreenHolder.updateBound(contentToViewX(data.mDocX) - mScrollX,contentToViewY(data.mDocY) - mScrollY,contentToViewDimension(data.mDocWidth),contentToViewDimension(data.mDocHeight));
}
break;
case HIDE_FULLSCREEN:
if (mFullScreenHolder != null) {
mFullScreenHolder.dismiss();
mFullScreenHolder=null;
}
break;
case DOM_FOCUS_CHANGED:
if (inEditingMode()) {
nativeClearCursor();
rebuildWebTextView();
}
break;
case SHOW_RECT_MSG_ID:
{
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
}
break;
default :
super.handleMessage(msg);
break;
}
}","@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > RETURN_LABEL ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
    mPreventLongPress=false;
    mPreventDoubleTap=false;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=mFullScreenHolder == null ? TOUCH_SHORTPRESS_START_MODE : TOUCH_SHORTPRESS_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventLongPress) {
  mTouchMode=TOUCH_DONE_MODE;
  WebViewCore.TouchEventData ted=new WebViewCore.TouchEventData();
  ted.mAction=WebViewCore.ACTION_LONGPRESS;
  ted.mX=viewToContentX((int)mLastTouchX + mScrollX);
  ted.mY=viewToContentY((int)mLastTouchY + mScrollY);
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  if (mFullScreenHolder == null) {
    performLongClick();
    rebuildWebTextView();
  }
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=PREVENT_DRAG_NO;
mPreventLongPress=false;
mPreventDoubleTap=false;
}
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
boolean hasRestoreState=restoreState != null;
if (hasRestoreState) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
if (getSettings().getBuiltInZoomControls()) {
updateZoomButtonsEnabled();
}
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.min(sMaxViewportWidth,Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x)));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
if (draw.mFocusSizeChanged && inEditingMode()) {
mFocusSizeChanged=true;
}
if (hasRestoreState) {
mViewManager.postReadyToDrawAll();
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case RETURN_LABEL:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setHint((String)msg.obj);
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && imm.isActive(mWebTextView)) {
imm.restartInput(mWebTextView);
}
}
break;
case MOVE_OUT_OF_PLUGIN:
navHandledKey(msg.arg1,1,false,0,true);
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case IMMEDIATE_REPAINT_MSG_ID:
{
int updates=msg.arg1;
if (updates != 0) {
nativeUpdateLayers(updates);
}
invalidate();
break;
}
case SET_ROOT_LAYER_MSG_ID:
{
int oldLayer=mRootLayer;
mRootLayer=msg.arg1;
if (oldLayer > 0) {
nativeDestroyLayer(oldLayer);
}
if (mRootLayer == 0) {
mLayersHaveAnimations=false;
}
if (mEvaluateThread != null) {
mEvaluateThread.cancel();
mEvaluateThread=null;
}
if (nativeLayersHaveAnimations(mRootLayer)) {
mLayersHaveAnimations=true;
mEvaluateThread=new EvaluateLayersAnimations();
mEvaluateThread.start();
}
invalidate();
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case RESUME_WEBCORE_PRIORITY:
WebViewCore.resumePriority(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=(msg.arg2 & TOUCH_PREVENT_DRAG) == TOUCH_PREVENT_DRAG ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
 else {
mPreventLongPress=(msg.arg2 & TOUCH_PREVENT_LONGPRESS) == TOUCH_PREVENT_LONGPRESS;
mPreventDoubleTap=(msg.arg2 & TOUCH_PREVENT_DOUBLETAP) == TOUCH_PREVENT_DOUBLETAP;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(1 == msg.arg2);
}
break;
case FIND_AGAIN:
if (mFindIsUp) {
findAll(mLastFind);
}
break;
case DRAG_HELD_MOTIONLESS:
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case AWAKEN_SCROLL_BARS:
if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS),ViewConfiguration.getScrollDefaultDelay());
}
break;
case DO_MOTION_UP:
doMotionUp(msg.arg1,msg.arg2);
break;
case SHOW_FULLSCREEN:
{
WebViewCore.PluginFullScreenData data=(WebViewCore.PluginFullScreenData)msg.obj;
if (data.mNpp != 0 && data.mView != null) {
if (mFullScreenHolder != null) {
Log.w(LOGTAG,""String_Node_Str"");
mFullScreenHolder.dismiss();
}
mFullScreenHolder=new PluginFullScreenHolder(WebView.this,data.mNpp);
data.mView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.FILL_PARENT));
mFullScreenHolder.setContentView(data.mView);
mFullScreenHolder.setCancelable(false);
mFullScreenHolder.setCanceledOnTouchOutside(false);
mFullScreenHolder.show();
}
 else if (mFullScreenHolder == null) {
break;
}
int x=contentToViewX(data.mDocX);
int y=contentToViewY(data.mDocY);
int width=contentToViewDimension(data.mDocWidth);
int height=contentToViewDimension(data.mDocHeight);
int viewWidth=getViewWidth();
int viewHeight=getViewHeight();
int newX=mScrollX;
int newY=mScrollY;
if (x < mScrollX) {
newX=x + (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
 else if (x + width > mScrollX + viewWidth) {
newX=x + width - viewWidth - (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
if (y < mScrollY) {
newY=y + (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
 else if (y + height > mScrollY + viewHeight) {
newY=y + height - viewHeight - (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
scrollTo(newX,newY);
if (width > viewWidth || height > viewHeight) {
mZoomCenterX=viewWidth * .5f;
mZoomCenterY=viewHeight * .5f;
setNewZoomScale(mActualScale / Math.max((float)width / viewWidth,(float)height / viewHeight),false,false);
}
mFullScreenHolder.updateBound(contentToViewX(data.mDocX) - mScrollX,contentToViewY(data.mDocY) - mScrollY,contentToViewDimension(data.mDocWidth),contentToViewDimension(data.mDocHeight));
}
break;
case HIDE_FULLSCREEN:
if (mFullScreenHolder != null) {
mFullScreenHolder.dismiss();
mFullScreenHolder=null;
}
break;
case DOM_FOCUS_CHANGED:
if (inEditingMode()) {
nativeClearCursor();
rebuildWebTextView();
}
break;
case SHOW_RECT_MSG_ID:
{
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
}
break;
default :
super.handleMessage(msg);
break;
}
}",0.9995432462733048
182664,"private native void nativeUpdateLayers(int layer,int updates);",private native void nativeUpdateLayers(int updates);,0.912280701754386
182665,"/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9932967702620352
182666,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mMode=AudioSystem.MODE_NORMAL;
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
}",0.8348214285714286
182667,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}",0.6329113924050633
182668,"/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9932967702620352
182669,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mMode=AudioSystem.MODE_NORMAL;
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
}",0.8348214285714286
182670,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}",0.6329113924050633
182671,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<String> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9990520043336945
182672,"ArrayList<String> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<String> ret=new ArrayList<String>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(key);
    }
  }
  return ret;
}","ArrayList<PackageSetting> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<PackageSetting> ret=new ArrayList<PackageSetting>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(ps);
    }
  }
  return ret;
}",0.9442467378410438
182673,"void cleanupInstallFailedPackage(String packageName){
  if (mInstaller != null) {
    int retCode=mInstaller.remove(packageName);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(packageName);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  mSettings.removePackageLP(packageName);
}","void cleanupInstallFailedPackage(PackageSetting ps){
  Log.i(TAG,""String_Node_Str"" + ps.name);
  if (mInstaller != null) {
    int retCode=mInstaller.remove(ps.name);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(ps.name);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  if (ps.codePath != null) {
    if (!ps.codePath.delete()) {
      Log.w(TAG,""String_Node_Str"" + ps.codePath);
    }
  }
  if (ps.resourcePath != null) {
    if (!ps.resourcePath.delete() && !ps.resourcePath.equals(ps.codePath)) {
      Log.w(TAG,""String_Node_Str"" + ps.resourcePath);
    }
  }
  mSettings.removePackageLP(ps.name);
}",0.2106149957877
182674,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<String> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9990520043336945
182675,"ArrayList<String> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<String> ret=new ArrayList<String>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(key);
    }
  }
  return ret;
}","ArrayList<PackageSetting> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<PackageSetting> ret=new ArrayList<PackageSetting>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(ps);
    }
  }
  return ret;
}",0.9442467378410438
182676,"void cleanupInstallFailedPackage(String packageName){
  if (mInstaller != null) {
    int retCode=mInstaller.remove(packageName);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(packageName);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  mSettings.removePackageLP(packageName);
}","void cleanupInstallFailedPackage(PackageSetting ps){
  Log.i(TAG,""String_Node_Str"" + ps.name);
  if (mInstaller != null) {
    int retCode=mInstaller.remove(ps.name);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(ps.name);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  if (ps.codePath != null) {
    if (!ps.codePath.delete()) {
      Log.w(TAG,""String_Node_Str"" + ps.codePath);
    }
  }
  if (ps.resourcePath != null) {
    if (!ps.resourcePath.delete() && !ps.resourcePath.equals(ps.codePath)) {
      Log.w(TAG,""String_Node_Str"" + ps.resourcePath);
    }
  }
  mSettings.removePackageLP(ps.name);
}",0.2106149957877
182677,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<String> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}",0.9990520043336945
182678,"ArrayList<String> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<String> ret=new ArrayList<String>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(key);
    }
  }
  return ret;
}","ArrayList<PackageSetting> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<PackageSetting> ret=new ArrayList<PackageSetting>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(ps);
    }
  }
  return ret;
}",0.9442467378410438
182679,"void cleanupInstallFailedPackage(String packageName){
  if (mInstaller != null) {
    int retCode=mInstaller.remove(packageName);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(packageName);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  mSettings.removePackageLP(packageName);
}","void cleanupInstallFailedPackage(PackageSetting ps){
  Log.i(TAG,""String_Node_Str"" + ps.name);
  if (mInstaller != null) {
    int retCode=mInstaller.remove(ps.name);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(ps.name);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  if (ps.codePath != null) {
    if (!ps.codePath.delete()) {
      Log.w(TAG,""String_Node_Str"" + ps.codePath);
    }
  }
  if (ps.resourcePath != null) {
    if (!ps.resourcePath.delete() && !ps.resourcePath.equals(ps.codePath)) {
      Log.w(TAG,""String_Node_Str"" + ps.resourcePath);
    }
  }
  mSettings.removePackageLP(ps.name);
}",0.2106149957877
182680,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  int delay=0;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    delay=1000;
  }
 else {
    if (mHandler.hasMessages(0)) {
      delay=1000;
    }
  }
  mWakeLock.acquire();
  mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),delay);
}",0.8587570621468926
182681,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  int delay=0;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    delay=1000;
  }
 else {
    if (mHandler.hasMessages(0)) {
      delay=1000;
    }
  }
  mWakeLock.acquire();
  mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),delay);
}",0.8587570621468926
182682,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(this,ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9988148850438492
182683,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        int[] outId=new int[1];
        inm.enqueueNotification(packageName,foregroundId,foregroundNoti,outId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.6879361914257228
182684,"public void cancelNotification(){
  if (foregroundId != 0) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        inm.cancelNotification(packageName,foregroundId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.6299615877080665
182685,"ServiceRecord(BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}","ServiceRecord(ActivityManagerService ams,BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.ams=ams;
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}",0.9683124539425204
182686,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  int delay=0;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    delay=1000;
  }
 else {
    if (mHandler.hasMessages(0)) {
      delay=1000;
    }
  }
  mWakeLock.acquire();
  mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),delay);
}",0.8587570621468926
182687,"protected void startPhotoQuery(long photoId,Uri lookupKey){
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}","/** 
 * startPhotoQuery internal method to query contact photo by photo id and uri.
 * @param photoId the photo id.
 * @param lookupKey the lookup uri.
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not.
 */
protected void startPhotoQuery(long photoId,Uri lookupKey,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}",0.5494505494505495
182688,"private void startContactQuery(Uri contactUri){
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}","/** 
 * startContactQuery internal method to query contact by Uri.
 * @param contactUri the contact uri
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not
 */
private void startContactQuery(Uri contactUri,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}",0.5255731922398589
182689,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param conatctUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  mContactUri=contactLookupUri;
  startContactQuery(contactLookupUri);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param contactLookupUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  bindFromContactUriInternal(contactLookupUri,true);
}",0.8309352517985612
182690,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}",0.9717741935483872
182691,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}",0.9725490196078432
182692,"/** 
 * Method to force this widget to forget everything it knows about the contact. The widget isn't automatically updated or redrawn.
 */
public void wipeClean(){
  setDisplayName(null,null);
  setPhoto(null);
  setSocialSnippet(null);
  mContactUri=null;
  mExcludeMimes=null;
}","/** 
 * Method to force this widget to forget everything it knows about the contact. We need to stop any existing async queries for phone, email, contact, and photos.
 */
public void wipeClean(){
  resetAsyncQueryHandler();
  setDisplayName(null,null);
  setPhoto(loadPlaceholderPhoto(null));
  setSocialSnippet(null);
  setPresence(0);
  mContactUri=null;
  mExcludeMimes=null;
}",0.6928895612708018
182693,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  resetAsyncQueryHandler();
}",0.9805249788314988
182694,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri);
        invalidate();
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (this != mQueryHandler) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri,false);
        invalidate();
      }
 else {
        setDisplayName(null,null);
        setSocialSnippet(null);
        setPhoto(loadPlaceholderPhoto(null));
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      setPhoto(loadPlaceholderPhoto(null));
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    setPhoto(loadPlaceholderPhoto(null));
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}",0.9268398268398268
182695,"protected void startPhotoQuery(long photoId,Uri lookupKey){
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}","/** 
 * startPhotoQuery internal method to query contact photo by photo id and uri.
 * @param photoId the photo id.
 * @param lookupKey the lookup uri.
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not.
 */
protected void startPhotoQuery(long photoId,Uri lookupKey,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}",0.5494505494505495
182696,"private void startContactQuery(Uri contactUri){
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}","/** 
 * startContactQuery internal method to query contact by Uri.
 * @param contactUri the contact uri
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not
 */
private void startContactQuery(Uri contactUri,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}",0.5255731922398589
182697,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param conatctUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  mContactUri=contactLookupUri;
  startContactQuery(contactLookupUri);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param contactLookupUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  bindFromContactUriInternal(contactLookupUri,true);
}",0.8309352517985612
182698,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}",0.9717741935483872
182699,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}",0.9725490196078432
182700,"/** 
 * Method to force this widget to forget everything it knows about the contact. The widget isn't automatically updated or redrawn.
 */
public void wipeClean(){
  setDisplayName(null,null);
  setPhoto(null);
  setSocialSnippet(null);
  mContactUri=null;
  mExcludeMimes=null;
}","/** 
 * Method to force this widget to forget everything it knows about the contact. We need to stop any existing async queries for phone, email, contact, and photos.
 */
public void wipeClean(){
  resetAsyncQueryHandler();
  setDisplayName(null,null);
  setPhoto(loadPlaceholderPhoto(null));
  setSocialSnippet(null);
  setPresence(0);
  mContactUri=null;
  mExcludeMimes=null;
}",0.6928895612708018
182701,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  resetAsyncQueryHandler();
}",0.9805249788314988
182702,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri);
        invalidate();
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (this != mQueryHandler) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri,false);
        invalidate();
      }
 else {
        setDisplayName(null,null);
        setSocialSnippet(null);
        setPhoto(loadPlaceholderPhoto(null));
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      setPhoto(loadPlaceholderPhoto(null));
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    setPhoto(loadPlaceholderPhoto(null));
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}",0.9268398268398268
182703,"protected void startPhotoQuery(long photoId,Uri lookupKey){
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}","/** 
 * startPhotoQuery internal method to query contact photo by photo id and uri.
 * @param photoId the photo id.
 * @param lookupKey the lookup uri.
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not.
 */
protected void startPhotoQuery(long photoId,Uri lookupKey,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}",0.5494505494505495
182704,"private void startContactQuery(Uri contactUri){
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}","/** 
 * startContactQuery internal method to query contact by Uri.
 * @param contactUri the contact uri
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not
 */
private void startContactQuery(Uri contactUri,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}",0.5255731922398589
182705,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param conatctUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  mContactUri=contactLookupUri;
  startContactQuery(contactLookupUri);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param contactLookupUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  bindFromContactUriInternal(contactLookupUri,true);
}",0.8309352517985612
182706,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}",0.9717741935483872
182707,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}",0.9725490196078432
182708,"/** 
 * Method to force this widget to forget everything it knows about the contact. The widget isn't automatically updated or redrawn.
 */
public void wipeClean(){
  setDisplayName(null,null);
  setPhoto(null);
  setSocialSnippet(null);
  mContactUri=null;
  mExcludeMimes=null;
}","/** 
 * Method to force this widget to forget everything it knows about the contact. We need to stop any existing async queries for phone, email, contact, and photos.
 */
public void wipeClean(){
  resetAsyncQueryHandler();
  setDisplayName(null,null);
  setPhoto(loadPlaceholderPhoto(null));
  setSocialSnippet(null);
  setPresence(0);
  mContactUri=null;
  mExcludeMimes=null;
}",0.6928895612708018
182709,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  resetAsyncQueryHandler();
}",0.9805249788314988
182710,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri);
        invalidate();
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (this != mQueryHandler) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri,false);
        invalidate();
      }
 else {
        setDisplayName(null,null);
        setSocialSnippet(null);
        setPhoto(loadPlaceholderPhoto(null));
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      setPhoto(loadPlaceholderPhoto(null));
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    setPhoto(loadPlaceholderPhoto(null));
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}",0.9268398268398268
182711,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(this,ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9988148850438492
182712,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        int[] outId=new int[1];
        inm.enqueueNotification(packageName,foregroundId,foregroundNoti,outId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.6879361914257228
182713,"public void cancelNotification(){
  if (foregroundId != 0) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        inm.cancelNotification(packageName,foregroundId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.6299615877080665
182714,"ServiceRecord(BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}","ServiceRecord(ActivityManagerService ams,BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.ams=ams;
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}",0.9683124539425204
182715,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(this,ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9988148850438492
182716,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        int[] outId=new int[1];
        inm.enqueueNotification(packageName,foregroundId,foregroundNoti,outId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.6879361914257228
182717,"public void cancelNotification(){
  if (foregroundId != 0) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        inm.cancelNotification(packageName,foregroundId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}",0.6299615877080665
182718,"ServiceRecord(BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}","ServiceRecord(ActivityManagerService ams,BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.ams=ams;
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}",0.9683124539425204
182719,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      ProximityAlert alert=mProximityAlerts.remove(i);
      mProximitiesEntered.remove(alert);
    }
  }
}",0.9845986591773872
182720,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      ProximityAlert alert=mProximityAlerts.remove(i);
      mProximitiesEntered.remove(alert);
    }
  }
}",0.9845986591773872
182721,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      ProximityAlert alert=mProximityAlerts.remove(i);
      mProximitiesEntered.remove(alert);
    }
  }
}",0.9845986591773872
182722,"@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  final int touchMode=isInTouchMode() ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
  if (!hasWindowFocus) {
    setChildrenDrawingCacheEnabled(false);
    removeCallbacks(mFlingRunnable);
    dismissPopup();
    if (touchMode == TOUCH_MODE_OFF) {
      mResurrectToPosition=mSelectedPosition;
    }
  }
 else {
    if (mFiltered) {
      showPopup();
    }
    if (touchMode != mLastTouchMode && mLastTouchMode != TOUCH_MODE_UNKNOWN) {
      if (touchMode == TOUCH_MODE_OFF) {
        resurrectSelection();
      }
 else {
        hideSelector();
        mLayoutMode=LAYOUT_NORMAL;
        layoutChildren();
      }
    }
  }
  mLastTouchMode=touchMode;
}","@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  final int touchMode=isInTouchMode() ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
  if (!hasWindowFocus) {
    setChildrenDrawingCacheEnabled(false);
    if (mFlingRunnable != null) {
      removeCallbacks(mFlingRunnable);
      mFlingRunnable.endFling();
    }
    dismissPopup();
    if (touchMode == TOUCH_MODE_OFF) {
      mResurrectToPosition=mSelectedPosition;
    }
  }
 else {
    if (mFiltered) {
      showPopup();
    }
    if (touchMode != mLastTouchMode && mLastTouchMode != TOUCH_MODE_UNKNOWN) {
      if (touchMode == TOUCH_MODE_OFF) {
        resurrectSelection();
      }
 else {
        hideSelector();
        mLayoutMode=LAYOUT_NORMAL;
        layoutChildren();
      }
    }
  }
  mLastTouchMode=touchMode;
}",0.9314896291640478
182723,"@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  final int touchMode=isInTouchMode() ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
  if (!hasWindowFocus) {
    setChildrenDrawingCacheEnabled(false);
    removeCallbacks(mFlingRunnable);
    dismissPopup();
    if (touchMode == TOUCH_MODE_OFF) {
      mResurrectToPosition=mSelectedPosition;
    }
  }
 else {
    if (mFiltered) {
      showPopup();
    }
    if (touchMode != mLastTouchMode && mLastTouchMode != TOUCH_MODE_UNKNOWN) {
      if (touchMode == TOUCH_MODE_OFF) {
        resurrectSelection();
      }
 else {
        hideSelector();
        mLayoutMode=LAYOUT_NORMAL;
        layoutChildren();
      }
    }
  }
  mLastTouchMode=touchMode;
}","@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  final int touchMode=isInTouchMode() ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
  if (!hasWindowFocus) {
    setChildrenDrawingCacheEnabled(false);
    if (mFlingRunnable != null) {
      removeCallbacks(mFlingRunnable);
      mFlingRunnable.endFling();
    }
    dismissPopup();
    if (touchMode == TOUCH_MODE_OFF) {
      mResurrectToPosition=mSelectedPosition;
    }
  }
 else {
    if (mFiltered) {
      showPopup();
    }
    if (touchMode != mLastTouchMode && mLastTouchMode != TOUCH_MODE_UNKNOWN) {
      if (touchMode == TOUCH_MODE_OFF) {
        resurrectSelection();
      }
 else {
        hideSelector();
        mLayoutMode=LAYOUT_NORMAL;
        layoutChildren();
      }
    }
  }
  mLastTouchMode=touchMode;
}",0.9314896291640478
182724,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.9585666293393056
182725,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
AudioSystem.setParameters(""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}",0.9951711106445518
182726,"public String[] listAsec() throws IllegalStateException {
  ArrayList<String> rsp=doCommand(""String_Node_Str"");
  String[] rdata=new String[rsp.size()];
  int idx=0;
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == ResponseCode.AsecPathResult) {
      rdata[idx++]=tok[1];
    }
 else     if (code == ResponseCode.CommandOkay) {
      return rdata;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","public String[] listAsec() throws IllegalStateException {
  ArrayList<String> rsp=doCommand(""String_Node_Str"");
  String[] rdata=new String[rsp.size()];
  int idx=0;
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == ResponseCode.AsecListResult) {
      rdata[idx++]=tok[1];
    }
 else     if (code == ResponseCode.CommandOkay) {
      return rdata;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}",0.9932203389830508
182727,"public String[] listAsec() throws IllegalStateException {
  ArrayList<String> rsp=doCommand(""String_Node_Str"");
  String[] rdata=new String[rsp.size()];
  int idx=0;
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == ResponseCode.AsecPathResult) {
      rdata[idx++]=tok[1];
    }
 else     if (code == ResponseCode.CommandOkay) {
      return rdata;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","public String[] listAsec() throws IllegalStateException {
  ArrayList<String> rsp=doCommand(""String_Node_Str"");
  String[] rdata=new String[rsp.size()];
  int idx=0;
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == ResponseCode.AsecListResult) {
      rdata[idx++]=tok[1];
    }
 else     if (code == ResponseCode.CommandOkay) {
      return rdata;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}",0.9932203389830508
182728,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.9585666293393056
182729,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
AudioSystem.setParameters(""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}",0.9951711106445518
182730,"/** 
 * Run on the webcore thread set the local values with the current ones
 */
private void syncValues(){
  Set<String> tmp=nativeGetOrigins();
  mOrigins=new HashMap<String,Origin>();
  for (  String origin : tmp) {
    Origin website=new Origin(origin,nativeGetUsageForOrigin(origin),nativeGetQuotaForOrigin(origin));
    mOrigins.put(origin,website);
  }
}","/** 
 * Run on the webcore thread set the local values with the current ones
 */
private void syncValues(){
  Set<String> tmp=nativeGetOrigins();
  mOrigins=new HashMap<String,Origin>();
  for (  String origin : tmp) {
    Origin website=new Origin(origin,nativeGetQuotaForOrigin(origin),nativeGetUsageForOrigin(origin));
    mOrigins.put(origin,website);
  }
}",0.8199445983379502
182731,"/** 
 * Run on the webcore thread set the local values with the current ones
 */
private void syncValues(){
  Set<String> tmp=nativeGetOrigins();
  mOrigins=new HashMap<String,Origin>();
  for (  String origin : tmp) {
    Origin website=new Origin(origin,nativeGetUsageForOrigin(origin),nativeGetQuotaForOrigin(origin));
    mOrigins.put(origin,website);
  }
}","/** 
 * Run on the webcore thread set the local values with the current ones
 */
private void syncValues(){
  Set<String> tmp=nativeGetOrigins();
  mOrigins=new HashMap<String,Origin>();
  for (  String origin : tmp) {
    Origin website=new Origin(origin,nativeGetQuotaForOrigin(origin),nativeGetUsageForOrigin(origin));
    mOrigins.put(origin,website);
  }
}",0.8199445983379502
182732,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.9585666293393056
182733,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
AudioSystem.setParameters(""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}",0.9951711106445518
182734,"/** 
 * Get a view and have it show the data associated with the specified position. This is called when we have already discovered that the view is not available for reuse in the recycle bin. The only choices left are converting an old view or making a new one.
 * @param position The position to display
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position){
  View scrapView;
  scrapView=mRecycler.getScrapView(position);
  View child;
  if (scrapView != null) {
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP,position,-1);
    }
    child=mAdapter.getView(position,scrapView,this);
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.BIND_VIEW,position,getChildCount());
    }
    if (child != scrapView) {
      mRecycler.addScrapView(scrapView);
      if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,position,-1);
      }
    }
  }
 else {
    child=mAdapter.getView(position,null,this);
    if (mCacheColorHint != 0) {
      child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.NEW_VIEW,position,getChildCount());
    }
  }
  return child;
}","/** 
 * Get a view and have it show the data associated with the specified position. This is called when we have already discovered that the view is not available for reuse in the recycle bin. The only choices left are converting an old view or making a new one.
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true ifthe returned view was taken from the scrap heap, false if otherwise.
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position,boolean[] isScrap){
  isScrap[0]=false;
  View scrapView;
  scrapView=mRecycler.getScrapView(position);
  View child;
  if (scrapView != null) {
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP,position,-1);
    }
    child=mAdapter.getView(position,scrapView,this);
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.BIND_VIEW,position,getChildCount());
    }
    if (child != scrapView) {
      mRecycler.addScrapView(scrapView);
      if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,position,-1);
      }
    }
 else {
      isScrap[0]=true;
    }
  }
 else {
    child=mAdapter.getView(position,null,this);
    if (mCacheColorHint != 0) {
      child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.NEW_VIEW,position,getChildCount());
    }
  }
  return child;
}",0.929419113054341
182735,"/** 
 * Move all views remaining in mActiveViews to mScrapViews.
 */
void scrapActiveViews(){
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=0; i < count; ++i) {
    final View victim=activeViews[i];
    if (victim != null) {
      int whichScrap=((AbsListView.LayoutParams)victim.getLayoutParams()).viewType;
      activeViews[i]=null;
      if (whichScrap == AdapterView.ITEM_VIEW_TYPE_IGNORE) {
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      scrapViews.add(victim);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}","/** 
 * Move all views remaining in mActiveViews to mScrapViews.
 */
void scrapActiveViews(){
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=0; i < count; ++i) {
    final View victim=activeViews[i];
    if (victim != null) {
      int whichScrap=((AbsListView.LayoutParams)victim.getLayoutParams()).viewType;
      activeViews[i]=null;
      if (whichScrap == AdapterView.ITEM_VIEW_TYPE_IGNORE) {
        removeDetachedView(victim,false);
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      scrapViews.add(victim);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}",0.9797101449275364
182736,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  if (treeObserver != null) {
    treeObserver.removeOnTouchModeChangeListener(this);
    if (mTextFilterEnabled && mPopup != null) {
      treeObserver.removeGlobalOnLayoutListener(this);
      mGlobalLayoutListenerAddedFilter=false;
    }
  }
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  if (treeObserver != null) {
    treeObserver.removeOnTouchModeChangeListener(this);
    if (mTextFilterEnabled && mPopup != null) {
      treeObserver.removeGlobalOnLayoutListener(this);
      mGlobalLayoutListenerAddedFilter=false;
    }
  }
}",0.9747899159663864
182737,"/** 
 * <p>Avoids jarring scrolling effect by ensuring that list elements made of a text view fit on a single line.</p>
 * @param position the item index in the list to get a view for
 * @return the view for the specified item
 */
@Override protected View obtainView(int position){
  View view=super.obtainView(position);
  if (view instanceof TextView) {
    ((TextView)view).setHorizontallyScrolling(true);
  }
  return view;
}","/** 
 * <p>Avoids jarring scrolling effect by ensuring that list elements made of a text view fit on a single line.</p>
 * @param position the item index in the list to get a view for
 * @return the view for the specified item
 */
@Override View obtainView(int position,boolean[] isScrap){
  View view=super.obtainView(position,isScrap);
  if (view instanceof TextView) {
    ((TextView)view).setHorizontallyScrolling(true);
  }
  return view;
}",0.9588100686498856
182738,"/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow if true, align top edge to y. If false, align bottom edge toy.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param where to add new item in the list
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected,int where){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      setupChild(child,position,y,flow,childrenLeft,selected,true,where);
      return child;
    }
  }
  child=obtainView(position);
  setupChild(child,position,y,flow,childrenLeft,selected,false,where);
  return child;
}","/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow if true, align top edge to y. If false, align bottom edge toy.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param where to add new item in the list
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected,int where){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      setupChild(child,position,y,flow,childrenLeft,selected,true,where);
      return child;
    }
  }
  child=obtainView(position,mIsScrap);
  setupChild(child,position,y,flow,childrenLeft,selected,mIsScrap[0],where);
  return child;
}",0.9871860584315736
182739,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    if (mColumnWidth > 0) {
      widthSize=mColumnWidth + mListPadding.left + mListPadding.right;
    }
 else {
      widthSize=mListPadding.left + mListPadding.right;
    }
    widthSize+=getVerticalScrollbarWidth();
  }
  int childWidth=widthSize - mListPadding.left - mListPadding.right;
  determineColumns(childWidth);
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  final int count=mItemCount;
  if (count > 0) {
    final View child=obtainView(0);
    AbsListView.LayoutParams p=(AbsListView.LayoutParams)child.getLayoutParams();
    if (p == null) {
      p=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0);
      child.setLayoutParams(p);
    }
    p.viewType=mAdapter.getItemViewType(0);
    int childHeightSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),0,p.height);
    int childWidthSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth,MeasureSpec.EXACTLY),0,p.width);
    child.measure(childWidthSpec,childHeightSpec);
    childHeight=child.getMeasuredHeight();
    if (mRecycler.shouldRecycleViewType(p.viewType)) {
      mRecycler.addScrapView(child);
    }
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    int ourSize=mListPadding.top + mListPadding.bottom;
    final int numColumns=mNumColumns;
    for (int i=0; i < count; i+=numColumns) {
      ourSize+=childHeight;
      if (i + numColumns < count) {
        ourSize+=mVerticalSpacing;
      }
      if (ourSize >= heightSize) {
        ourSize=heightSize;
        break;
      }
    }
    heightSize=ourSize;
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    if (mColumnWidth > 0) {
      widthSize=mColumnWidth + mListPadding.left + mListPadding.right;
    }
 else {
      widthSize=mListPadding.left + mListPadding.right;
    }
    widthSize+=getVerticalScrollbarWidth();
  }
  int childWidth=widthSize - mListPadding.left - mListPadding.right;
  determineColumns(childWidth);
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  final int count=mItemCount;
  if (count > 0) {
    final View child=obtainView(0,mIsScrap);
    AbsListView.LayoutParams p=(AbsListView.LayoutParams)child.getLayoutParams();
    if (p == null) {
      p=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0);
      child.setLayoutParams(p);
    }
    p.viewType=mAdapter.getItemViewType(0);
    int childHeightSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),0,p.height);
    int childWidthSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth,MeasureSpec.EXACTLY),0,p.width);
    child.measure(childWidthSpec,childHeightSpec);
    childHeight=child.getMeasuredHeight();
    if (mRecycler.shouldRecycleViewType(p.viewType)) {
      mRecycler.addScrapView(child);
    }
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    int ourSize=mListPadding.top + mListPadding.bottom;
    final int numColumns=mNumColumns;
    for (int i=0; i < count; i+=numColumns) {
      ourSize+=childHeight;
      if (i + numColumns < count) {
        ourSize+=mVerticalSpacing;
      }
      if (ourSize >= heightSize) {
        ourSize=heightSize;
        break;
      }
    }
    heightSize=ourSize;
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}",0.9980163103372272
182740,"private View addViewAbove(View theView,int position){
  int abovePosition=position - 1;
  View view=obtainView(abovePosition);
  int edgeOfNewChild=theView.getTop() - mDividerHeight;
  setupChild(view,abovePosition,edgeOfNewChild,false,mListPadding.left,false,false);
  return view;
}","private View addViewAbove(View theView,int position){
  int abovePosition=position - 1;
  View view=obtainView(abovePosition,mIsScrap);
  int edgeOfNewChild=theView.getTop() - mDividerHeight;
  setupChild(view,abovePosition,edgeOfNewChild,false,mListPadding.left,false,mIsScrap[0]);
  return view;
}",0.9571183533447684
182741,"private View addViewBelow(View theView,int position){
  int belowPosition=position + 1;
  View view=obtainView(belowPosition);
  int edgeOfNewChild=theView.getBottom() + mDividerHeight;
  setupChild(view,belowPosition,edgeOfNewChild,true,mListPadding.left,false,false);
  return view;
}","private View addViewBelow(View theView,int position){
  int belowPosition=position + 1;
  View view=obtainView(belowPosition,mIsScrap);
  int edgeOfNewChild=theView.getBottom() + mDividerHeight;
  setupChild(view,belowPosition,edgeOfNewChild,true,mListPadding.left,false,mIsScrap[0]);
  return view;
}",0.9574105621805792
182742,"/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottomedge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());
      }
      setupChild(child,position,y,flow,childrenLeft,selected,true);
      return child;
    }
  }
  child=obtainView(position);
  setupChild(child,position,y,flow,childrenLeft,selected,false);
  return child;
}","/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottomedge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());
      }
      setupChild(child,position,y,flow,childrenLeft,selected,true);
      return child;
    }
  }
  child=obtainView(position,mIsScrap);
  setupChild(child,position,y,flow,childrenLeft,selected,mIsScrap[0]);
  return child;
}",0.9883558453656264
182743,"/** 
 * Measures the height of the given range of children (inclusive) and returns the height with this ListView's padding and divider heights included. If maxHeight is provided, the measuring will stop when the current height reaches maxHeight.
 * @param widthMeasureSpec The width measure spec to be given to a child's{@link View#measure(int,int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to beshown. Specify  {@link #NO_POSITION} if the last child should bethe last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all thechildren don't fit in this value, this value will be returned).
 * @param disallowPartialChildPosition In general, whether the returnedheight should only contain entire children. This is more powerful--it is the first inclusive position at which partial children will not be allowed. Example: it looks nice to have at least 3 completely visible children, and in portrait this will most likely fit; but in landscape there could be times when even 2 children can not be completely shown, so a value of 2 (remember, inclusive) would be good (assuming startPosition is 0).
 * @return The height of this ListView with the given children.
 */
final int measureHeightOfChildren(int widthMeasureSpec,int startPosition,int endPosition,final int maxHeight,int disallowPartialChildPosition){
  final ListAdapter adapter=mAdapter;
  if (adapter == null) {
    return mListPadding.top + mListPadding.bottom;
  }
  int returnedHeight=mListPadding.top + mListPadding.bottom;
  final int dividerHeight=((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
  int prevHeightWithoutPartialChild=0;
  int i;
  View child;
  endPosition=(endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
  final AbsListView.RecycleBin recycleBin=mRecycler;
  final boolean recyle=recycleOnMeasure();
  for (i=startPosition; i <= endPosition; ++i) {
    child=obtainView(i);
    measureScrapChild(child,i,widthMeasureSpec);
    if (i > 0) {
      returnedHeight+=dividerHeight;
    }
    if (recyle) {
      recycleBin.addScrapView(child);
    }
    returnedHeight+=child.getMeasuredHeight();
    if (returnedHeight >= maxHeight) {
      return (disallowPartialChildPosition >= 0) && (i > disallowPartialChildPosition) && (prevHeightWithoutPartialChild > 0)&& (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
    }
    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
      prevHeightWithoutPartialChild=returnedHeight;
    }
  }
  return returnedHeight;
}","/** 
 * Measures the height of the given range of children (inclusive) and returns the height with this ListView's padding and divider heights included. If maxHeight is provided, the measuring will stop when the current height reaches maxHeight.
 * @param widthMeasureSpec The width measure spec to be given to a child's{@link View#measure(int,int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to beshown. Specify  {@link #NO_POSITION} if the last child should bethe last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all thechildren don't fit in this value, this value will be returned).
 * @param disallowPartialChildPosition In general, whether the returnedheight should only contain entire children. This is more powerful--it is the first inclusive position at which partial children will not be allowed. Example: it looks nice to have at least 3 completely visible children, and in portrait this will most likely fit; but in landscape there could be times when even 2 children can not be completely shown, so a value of 2 (remember, inclusive) would be good (assuming startPosition is 0).
 * @return The height of this ListView with the given children.
 */
final int measureHeightOfChildren(int widthMeasureSpec,int startPosition,int endPosition,final int maxHeight,int disallowPartialChildPosition){
  final ListAdapter adapter=mAdapter;
  if (adapter == null) {
    return mListPadding.top + mListPadding.bottom;
  }
  int returnedHeight=mListPadding.top + mListPadding.bottom;
  final int dividerHeight=((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
  int prevHeightWithoutPartialChild=0;
  int i;
  View child;
  endPosition=(endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
  final AbsListView.RecycleBin recycleBin=mRecycler;
  final boolean recyle=recycleOnMeasure();
  final boolean[] isScrap=mIsScrap;
  for (i=startPosition; i <= endPosition; ++i) {
    child=obtainView(i,isScrap);
    measureScrapChild(child,i,widthMeasureSpec);
    if (i > 0) {
      returnedHeight+=dividerHeight;
    }
    if (recyle) {
      recycleBin.addScrapView(child);
    }
    returnedHeight+=child.getMeasuredHeight();
    if (returnedHeight >= maxHeight) {
      return (disallowPartialChildPosition >= 0) && (i > disallowPartialChildPosition) && (prevHeightWithoutPartialChild > 0)&& (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
    }
    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
      prevHeightWithoutPartialChild=returnedHeight;
    }
  }
  return returnedHeight;
}",0.9918427882832778
182744,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int childWidth=0;
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  if (mItemCount > 0 && (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) {
    final View child=obtainView(0);
    measureScrapChild(child,0,widthMeasureSpec);
    childWidth=child.getMeasuredWidth();
    childHeight=child.getMeasuredHeight();
    if (recycleOnMeasure()) {
      mRecycler.addScrapView(child);
    }
  }
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    widthSize=mListPadding.left + mListPadding.right + childWidth+ getVerticalScrollbarWidth();
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    heightSize=measureHeightOfChildren(widthMeasureSpec,0,NO_POSITION,heightSize,-1);
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int childWidth=0;
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  if (mItemCount > 0 && (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) {
    final View child=obtainView(0,mIsScrap);
    measureScrapChild(child,0,widthMeasureSpec);
    childWidth=child.getMeasuredWidth();
    childHeight=child.getMeasuredHeight();
    if (recycleOnMeasure()) {
      mRecycler.addScrapView(child);
    }
  }
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    widthSize=mListPadding.left + mListPadding.right + childWidth+ getVerticalScrollbarWidth();
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    heightSize=measureHeightOfChildren(widthMeasureSpec,0,NO_POSITION,heightSize,-1);
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}",0.9966254218222722
182745,"/** 
 * Get a view and have it show the data associated with the specified position. This is called when we have already discovered that the view is not available for reuse in the recycle bin. The only choices left are converting an old view or making a new one.
 * @param position The position to display
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position){
  View scrapView;
  scrapView=mRecycler.getScrapView(position);
  View child;
  if (scrapView != null) {
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP,position,-1);
    }
    child=mAdapter.getView(position,scrapView,this);
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.BIND_VIEW,position,getChildCount());
    }
    if (child != scrapView) {
      mRecycler.addScrapView(scrapView);
      if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,position,-1);
      }
    }
  }
 else {
    child=mAdapter.getView(position,null,this);
    if (mCacheColorHint != 0) {
      child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.NEW_VIEW,position,getChildCount());
    }
  }
  return child;
}","/** 
 * Get a view and have it show the data associated with the specified position. This is called when we have already discovered that the view is not available for reuse in the recycle bin. The only choices left are converting an old view or making a new one.
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true ifthe returned view was taken from the scrap heap, false if otherwise.
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position,boolean[] isScrap){
  isScrap[0]=false;
  View scrapView;
  scrapView=mRecycler.getScrapView(position);
  View child;
  if (scrapView != null) {
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP,position,-1);
    }
    child=mAdapter.getView(position,scrapView,this);
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.BIND_VIEW,position,getChildCount());
    }
    if (child != scrapView) {
      mRecycler.addScrapView(scrapView);
      if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,position,-1);
      }
    }
 else {
      isScrap[0]=true;
    }
  }
 else {
    child=mAdapter.getView(position,null,this);
    if (mCacheColorHint != 0) {
      child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.NEW_VIEW,position,getChildCount());
    }
  }
  return child;
}",0.929419113054341
182746,"/** 
 * Move all views remaining in mActiveViews to mScrapViews.
 */
void scrapActiveViews(){
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=0; i < count; ++i) {
    final View victim=activeViews[i];
    if (victim != null) {
      int whichScrap=((AbsListView.LayoutParams)victim.getLayoutParams()).viewType;
      activeViews[i]=null;
      if (whichScrap == AdapterView.ITEM_VIEW_TYPE_IGNORE) {
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      scrapViews.add(victim);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}","/** 
 * Move all views remaining in mActiveViews to mScrapViews.
 */
void scrapActiveViews(){
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=0; i < count; ++i) {
    final View victim=activeViews[i];
    if (victim != null) {
      int whichScrap=((AbsListView.LayoutParams)victim.getLayoutParams()).viewType;
      activeViews[i]=null;
      if (whichScrap == AdapterView.ITEM_VIEW_TYPE_IGNORE) {
        removeDetachedView(victim,false);
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      scrapViews.add(victim);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}",0.9797101449275364
182747,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  if (treeObserver != null) {
    treeObserver.removeOnTouchModeChangeListener(this);
    if (mTextFilterEnabled && mPopup != null) {
      treeObserver.removeGlobalOnLayoutListener(this);
      mGlobalLayoutListenerAddedFilter=false;
    }
  }
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  if (treeObserver != null) {
    treeObserver.removeOnTouchModeChangeListener(this);
    if (mTextFilterEnabled && mPopup != null) {
      treeObserver.removeGlobalOnLayoutListener(this);
      mGlobalLayoutListenerAddedFilter=false;
    }
  }
}",0.9747899159663864
182748,"/** 
 * <p>Avoids jarring scrolling effect by ensuring that list elements made of a text view fit on a single line.</p>
 * @param position the item index in the list to get a view for
 * @return the view for the specified item
 */
@Override protected View obtainView(int position){
  View view=super.obtainView(position);
  if (view instanceof TextView) {
    ((TextView)view).setHorizontallyScrolling(true);
  }
  return view;
}","/** 
 * <p>Avoids jarring scrolling effect by ensuring that list elements made of a text view fit on a single line.</p>
 * @param position the item index in the list to get a view for
 * @return the view for the specified item
 */
@Override View obtainView(int position,boolean[] isScrap){
  View view=super.obtainView(position,isScrap);
  if (view instanceof TextView) {
    ((TextView)view).setHorizontallyScrolling(true);
  }
  return view;
}",0.9588100686498856
182749,"/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow if true, align top edge to y. If false, align bottom edge toy.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param where to add new item in the list
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected,int where){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      setupChild(child,position,y,flow,childrenLeft,selected,true,where);
      return child;
    }
  }
  child=obtainView(position);
  setupChild(child,position,y,flow,childrenLeft,selected,false,where);
  return child;
}","/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow if true, align top edge to y. If false, align bottom edge toy.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param where to add new item in the list
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected,int where){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      setupChild(child,position,y,flow,childrenLeft,selected,true,where);
      return child;
    }
  }
  child=obtainView(position,mIsScrap);
  setupChild(child,position,y,flow,childrenLeft,selected,mIsScrap[0],where);
  return child;
}",0.9871860584315736
182750,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    if (mColumnWidth > 0) {
      widthSize=mColumnWidth + mListPadding.left + mListPadding.right;
    }
 else {
      widthSize=mListPadding.left + mListPadding.right;
    }
    widthSize+=getVerticalScrollbarWidth();
  }
  int childWidth=widthSize - mListPadding.left - mListPadding.right;
  determineColumns(childWidth);
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  final int count=mItemCount;
  if (count > 0) {
    final View child=obtainView(0);
    AbsListView.LayoutParams p=(AbsListView.LayoutParams)child.getLayoutParams();
    if (p == null) {
      p=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0);
      child.setLayoutParams(p);
    }
    p.viewType=mAdapter.getItemViewType(0);
    int childHeightSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),0,p.height);
    int childWidthSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth,MeasureSpec.EXACTLY),0,p.width);
    child.measure(childWidthSpec,childHeightSpec);
    childHeight=child.getMeasuredHeight();
    if (mRecycler.shouldRecycleViewType(p.viewType)) {
      mRecycler.addScrapView(child);
    }
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    int ourSize=mListPadding.top + mListPadding.bottom;
    final int numColumns=mNumColumns;
    for (int i=0; i < count; i+=numColumns) {
      ourSize+=childHeight;
      if (i + numColumns < count) {
        ourSize+=mVerticalSpacing;
      }
      if (ourSize >= heightSize) {
        ourSize=heightSize;
        break;
      }
    }
    heightSize=ourSize;
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    if (mColumnWidth > 0) {
      widthSize=mColumnWidth + mListPadding.left + mListPadding.right;
    }
 else {
      widthSize=mListPadding.left + mListPadding.right;
    }
    widthSize+=getVerticalScrollbarWidth();
  }
  int childWidth=widthSize - mListPadding.left - mListPadding.right;
  determineColumns(childWidth);
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  final int count=mItemCount;
  if (count > 0) {
    final View child=obtainView(0,mIsScrap);
    AbsListView.LayoutParams p=(AbsListView.LayoutParams)child.getLayoutParams();
    if (p == null) {
      p=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0);
      child.setLayoutParams(p);
    }
    p.viewType=mAdapter.getItemViewType(0);
    int childHeightSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),0,p.height);
    int childWidthSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth,MeasureSpec.EXACTLY),0,p.width);
    child.measure(childWidthSpec,childHeightSpec);
    childHeight=child.getMeasuredHeight();
    if (mRecycler.shouldRecycleViewType(p.viewType)) {
      mRecycler.addScrapView(child);
    }
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    int ourSize=mListPadding.top + mListPadding.bottom;
    final int numColumns=mNumColumns;
    for (int i=0; i < count; i+=numColumns) {
      ourSize+=childHeight;
      if (i + numColumns < count) {
        ourSize+=mVerticalSpacing;
      }
      if (ourSize >= heightSize) {
        ourSize=heightSize;
        break;
      }
    }
    heightSize=ourSize;
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}",0.9980163103372272
182751,"private View addViewAbove(View theView,int position){
  int abovePosition=position - 1;
  View view=obtainView(abovePosition);
  int edgeOfNewChild=theView.getTop() - mDividerHeight;
  setupChild(view,abovePosition,edgeOfNewChild,false,mListPadding.left,false,false);
  return view;
}","private View addViewAbove(View theView,int position){
  int abovePosition=position - 1;
  View view=obtainView(abovePosition,mIsScrap);
  int edgeOfNewChild=theView.getTop() - mDividerHeight;
  setupChild(view,abovePosition,edgeOfNewChild,false,mListPadding.left,false,mIsScrap[0]);
  return view;
}",0.9571183533447684
182752,"private View addViewBelow(View theView,int position){
  int belowPosition=position + 1;
  View view=obtainView(belowPosition);
  int edgeOfNewChild=theView.getBottom() + mDividerHeight;
  setupChild(view,belowPosition,edgeOfNewChild,true,mListPadding.left,false,false);
  return view;
}","private View addViewBelow(View theView,int position){
  int belowPosition=position + 1;
  View view=obtainView(belowPosition,mIsScrap);
  int edgeOfNewChild=theView.getBottom() + mDividerHeight;
  setupChild(view,belowPosition,edgeOfNewChild,true,mListPadding.left,false,mIsScrap[0]);
  return view;
}",0.9574105621805792
182753,"/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottomedge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());
      }
      setupChild(child,position,y,flow,childrenLeft,selected,true);
      return child;
    }
  }
  child=obtainView(position);
  setupChild(child,position,y,flow,childrenLeft,selected,false);
  return child;
}","/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottomedge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());
      }
      setupChild(child,position,y,flow,childrenLeft,selected,true);
      return child;
    }
  }
  child=obtainView(position,mIsScrap);
  setupChild(child,position,y,flow,childrenLeft,selected,mIsScrap[0]);
  return child;
}",0.9883558453656264
182754,"/** 
 * Measures the height of the given range of children (inclusive) and returns the height with this ListView's padding and divider heights included. If maxHeight is provided, the measuring will stop when the current height reaches maxHeight.
 * @param widthMeasureSpec The width measure spec to be given to a child's{@link View#measure(int,int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to beshown. Specify  {@link #NO_POSITION} if the last child should bethe last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all thechildren don't fit in this value, this value will be returned).
 * @param disallowPartialChildPosition In general, whether the returnedheight should only contain entire children. This is more powerful--it is the first inclusive position at which partial children will not be allowed. Example: it looks nice to have at least 3 completely visible children, and in portrait this will most likely fit; but in landscape there could be times when even 2 children can not be completely shown, so a value of 2 (remember, inclusive) would be good (assuming startPosition is 0).
 * @return The height of this ListView with the given children.
 */
final int measureHeightOfChildren(int widthMeasureSpec,int startPosition,int endPosition,final int maxHeight,int disallowPartialChildPosition){
  final ListAdapter adapter=mAdapter;
  if (adapter == null) {
    return mListPadding.top + mListPadding.bottom;
  }
  int returnedHeight=mListPadding.top + mListPadding.bottom;
  final int dividerHeight=((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
  int prevHeightWithoutPartialChild=0;
  int i;
  View child;
  endPosition=(endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
  final AbsListView.RecycleBin recycleBin=mRecycler;
  final boolean recyle=recycleOnMeasure();
  for (i=startPosition; i <= endPosition; ++i) {
    child=obtainView(i);
    measureScrapChild(child,i,widthMeasureSpec);
    if (i > 0) {
      returnedHeight+=dividerHeight;
    }
    if (recyle) {
      recycleBin.addScrapView(child);
    }
    returnedHeight+=child.getMeasuredHeight();
    if (returnedHeight >= maxHeight) {
      return (disallowPartialChildPosition >= 0) && (i > disallowPartialChildPosition) && (prevHeightWithoutPartialChild > 0)&& (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
    }
    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
      prevHeightWithoutPartialChild=returnedHeight;
    }
  }
  return returnedHeight;
}","/** 
 * Measures the height of the given range of children (inclusive) and returns the height with this ListView's padding and divider heights included. If maxHeight is provided, the measuring will stop when the current height reaches maxHeight.
 * @param widthMeasureSpec The width measure spec to be given to a child's{@link View#measure(int,int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to beshown. Specify  {@link #NO_POSITION} if the last child should bethe last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all thechildren don't fit in this value, this value will be returned).
 * @param disallowPartialChildPosition In general, whether the returnedheight should only contain entire children. This is more powerful--it is the first inclusive position at which partial children will not be allowed. Example: it looks nice to have at least 3 completely visible children, and in portrait this will most likely fit; but in landscape there could be times when even 2 children can not be completely shown, so a value of 2 (remember, inclusive) would be good (assuming startPosition is 0).
 * @return The height of this ListView with the given children.
 */
final int measureHeightOfChildren(int widthMeasureSpec,int startPosition,int endPosition,final int maxHeight,int disallowPartialChildPosition){
  final ListAdapter adapter=mAdapter;
  if (adapter == null) {
    return mListPadding.top + mListPadding.bottom;
  }
  int returnedHeight=mListPadding.top + mListPadding.bottom;
  final int dividerHeight=((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
  int prevHeightWithoutPartialChild=0;
  int i;
  View child;
  endPosition=(endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
  final AbsListView.RecycleBin recycleBin=mRecycler;
  final boolean recyle=recycleOnMeasure();
  final boolean[] isScrap=mIsScrap;
  for (i=startPosition; i <= endPosition; ++i) {
    child=obtainView(i,isScrap);
    measureScrapChild(child,i,widthMeasureSpec);
    if (i > 0) {
      returnedHeight+=dividerHeight;
    }
    if (recyle) {
      recycleBin.addScrapView(child);
    }
    returnedHeight+=child.getMeasuredHeight();
    if (returnedHeight >= maxHeight) {
      return (disallowPartialChildPosition >= 0) && (i > disallowPartialChildPosition) && (prevHeightWithoutPartialChild > 0)&& (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
    }
    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
      prevHeightWithoutPartialChild=returnedHeight;
    }
  }
  return returnedHeight;
}",0.9918427882832778
182755,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int childWidth=0;
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  if (mItemCount > 0 && (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) {
    final View child=obtainView(0);
    measureScrapChild(child,0,widthMeasureSpec);
    childWidth=child.getMeasuredWidth();
    childHeight=child.getMeasuredHeight();
    if (recycleOnMeasure()) {
      mRecycler.addScrapView(child);
    }
  }
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    widthSize=mListPadding.left + mListPadding.right + childWidth+ getVerticalScrollbarWidth();
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    heightSize=measureHeightOfChildren(widthMeasureSpec,0,NO_POSITION,heightSize,-1);
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int childWidth=0;
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  if (mItemCount > 0 && (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) {
    final View child=obtainView(0,mIsScrap);
    measureScrapChild(child,0,widthMeasureSpec);
    childWidth=child.getMeasuredWidth();
    childHeight=child.getMeasuredHeight();
    if (recycleOnMeasure()) {
      mRecycler.addScrapView(child);
    }
  }
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    widthSize=mListPadding.left + mListPadding.right + childWidth+ getVerticalScrollbarWidth();
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    heightSize=measureHeightOfChildren(widthMeasureSpec,0,NO_POSITION,heightSize,-1);
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}",0.9966254218222722
182756,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.951219512195122
182757,"public void run(AccountManagerFuture<Account[]> future){
  boolean hasSAMLAccount=true;
  try {
    hasSAMLAccount=future.getResult().length > 0;
  }
 catch (  OperationCanceledException e) {
  }
catch (  IOException e) {
  }
catch (  AuthenticatorException e) {
  }
  mEnableFallback=!hasSAMLAccount;
  if (mUnlockScreen == null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else   if (mUnlockScreen instanceof UnlockScreen) {
    ((UnlockScreen)mUnlockScreen).setEnableFallback(true);
  }
}","public void run(AccountManagerFuture<Account[]> future){
  int samlAccounts=0;
  try {
    samlAccounts=future.getResult().length;
  }
 catch (  OperationCanceledException e) {
  }
catch (  IOException e) {
  }
catch (  AuthenticatorException e) {
  }
  mEnableFallback=samlAccounts < mNumAccounts;
  if (mUnlockScreen == null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else   if (mUnlockScreen instanceof UnlockScreen) {
    ((UnlockScreen)mUnlockScreen).setEnableFallback(mEnableFallback);
  }
}",0.8638211382113821
182758,"void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}","void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing || win.mViewVisibility != View.VISIBLE) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}",0.9881925522252498
182759,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.951219512195122
182760,"public void run(AccountManagerFuture<Account[]> future){
  boolean hasSAMLAccount=true;
  try {
    hasSAMLAccount=future.getResult().length > 0;
  }
 catch (  OperationCanceledException e) {
  }
catch (  IOException e) {
  }
catch (  AuthenticatorException e) {
  }
  mEnableFallback=!hasSAMLAccount;
  if (mUnlockScreen == null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else   if (mUnlockScreen instanceof UnlockScreen) {
    ((UnlockScreen)mUnlockScreen).setEnableFallback(true);
  }
}","public void run(AccountManagerFuture<Account[]> future){
  int samlAccounts=0;
  try {
    samlAccounts=future.getResult().length;
  }
 catch (  OperationCanceledException e) {
  }
catch (  IOException e) {
  }
catch (  AuthenticatorException e) {
  }
  mEnableFallback=samlAccounts < mNumAccounts;
  if (mUnlockScreen == null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else   if (mUnlockScreen instanceof UnlockScreen) {
    ((UnlockScreen)mUnlockScreen).setEnableFallback(mEnableFallback);
  }
}",0.8638211382113821
182761,"public void onWindowResize(int w,int h){
synchronized (sGLThreadManager) {
    mWidth=w;
    mHeight=h;
    mSizeChanged=true;
    mRequestRender=true;
    sGLThreadManager.notifyAll();
  }
}","public void onWindowResize(int w,int h){
synchronized (sGLThreadManager) {
    mWidth=w;
    mHeight=h;
    mSizeChanged=true;
    mRequestRender=true;
    mRenderComplete=false;
    sGLThreadManager.notifyAll();
    while (!mExited && !mPaused && !mRenderComplete) {
      if (LOG_SURFACE) {
        Log.i(""String_Node_Str"",""String_Node_Str"");
      }
      try {
        sGLThreadManager.wait();
      }
 catch (      InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
    }
  }
}",0.5449358059914408
182762,"private void guardedRun() throws InterruptedException {
  mEglHelper=new EglHelper();
  try {
    GL10 gl=null;
    boolean createEglSurface=false;
    boolean sizeChanged=false;
    int w=0;
    int h=0;
    Runnable event=null;
    while (true) {
synchronized (sGLThreadManager) {
        while (true) {
          if (mShouldExit) {
            return;
          }
          if (!mEventQueue.isEmpty()) {
            event=mEventQueue.remove(0);
            break;
          }
          if (mHaveEgl && mPaused) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            stopEglLocked();
          }
          if ((!mHasSurface) && (!mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            if (mHaveEgl) {
              stopEglLocked();
            }
            mWaitingForSurface=true;
            sGLThreadManager.notifyAll();
          }
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            mWaitingForSurface=false;
            sGLThreadManager.notifyAll();
          }
          if ((!mPaused) && mHasSurface && (mWidth > 0)&& (mHeight > 0)&& (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
            if ((!mHaveEgl) && sGLThreadManager.tryAcquireEglSurfaceLocked(this)) {
              mHaveEgl=true;
              mEglHelper.start();
              createEglSurface=true;
              sizeChanged=true;
              sGLThreadManager.notifyAll();
            }
            if (mHaveEgl) {
              if (mSizeChanged) {
                sizeChanged=true;
                w=mWidth;
                h=mHeight;
                if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
                }
 else {
                  mRequestRender=false;
                }
                mSizeChanged=false;
              }
 else {
                mRequestRender=false;
              }
              sGLThreadManager.notifyAll();
              break;
            }
          }
          if (LOG_THREADS) {
            Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
          }
          sGLThreadManager.wait();
        }
      }
      if (event != null) {
        event.run();
        event=null;
        continue;
      }
      if (createEglSurface) {
        gl=(GL10)mEglHelper.createSurface(getHolder());
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"");
        }
        mRenderer.onSurfaceCreated(gl,mEglHelper.mEglConfig);
        createEglSurface=false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + w + ""String_Node_Str""+ h+ ""String_Node_Str"");
        }
        mRenderer.onSurfaceChanged(gl,w,h);
        sizeChanged=false;
      }
      if (LOG_RENDERER) {
        Log.w(""String_Node_Str"",""String_Node_Str"");
      }
      mRenderer.onDrawFrame(gl);
      if (!mEglHelper.swap()) {
        if (LOG_SURFACE) {
          Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
        }
      }
    }
  }
  finally {
synchronized (sGLThreadManager) {
      stopEglLocked();
    }
  }
}","private void guardedRun() throws InterruptedException {
  mEglHelper=new EglHelper();
  try {
    GL10 gl=null;
    boolean createEglSurface=false;
    boolean sizeChanged=false;
    boolean wantRenderNotification=false;
    boolean doRenderNotification=false;
    int w=0;
    int h=0;
    Runnable event=null;
    while (true) {
synchronized (sGLThreadManager) {
        while (true) {
          if (mShouldExit) {
            return;
          }
          if (!mEventQueue.isEmpty()) {
            event=mEventQueue.remove(0);
            break;
          }
          if (mHaveEgl && mPaused) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            stopEglLocked();
          }
          if ((!mHasSurface) && (!mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            if (mHaveEgl) {
              stopEglLocked();
            }
            mWaitingForSurface=true;
            sGLThreadManager.notifyAll();
          }
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            mWaitingForSurface=false;
            sGLThreadManager.notifyAll();
          }
          if (doRenderNotification) {
            wantRenderNotification=false;
            doRenderNotification=false;
            mRenderComplete=true;
            sGLThreadManager.notifyAll();
          }
          if ((!mPaused) && mHasSurface && (mWidth > 0)&& (mHeight > 0)&& (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
            if ((!mHaveEgl) && sGLThreadManager.tryAcquireEglSurfaceLocked(this)) {
              mHaveEgl=true;
              mEglHelper.start();
              createEglSurface=true;
              sizeChanged=true;
              sGLThreadManager.notifyAll();
            }
            if (mHaveEgl) {
              if (mSizeChanged) {
                sizeChanged=true;
                w=mWidth;
                h=mHeight;
                wantRenderNotification=true;
                if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
                }
 else {
                  mRequestRender=false;
                }
                mSizeChanged=false;
              }
 else {
                mRequestRender=false;
              }
              sGLThreadManager.notifyAll();
              break;
            }
          }
          if (LOG_THREADS) {
            Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
          }
          sGLThreadManager.wait();
        }
      }
      if (event != null) {
        event.run();
        event=null;
        continue;
      }
      if (createEglSurface) {
        gl=(GL10)mEglHelper.createSurface(getHolder());
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"");
        }
        mRenderer.onSurfaceCreated(gl,mEglHelper.mEglConfig);
        createEglSurface=false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + w + ""String_Node_Str""+ h+ ""String_Node_Str"");
        }
        mRenderer.onSurfaceChanged(gl,w,h);
        sizeChanged=false;
      }
      if (LOG_RENDERER) {
        Log.w(""String_Node_Str"",""String_Node_Str"");
      }
      mRenderer.onDrawFrame(gl);
      if (!mEglHelper.swap()) {
        if (LOG_SURFACE) {
          Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
        }
      }
      if (wantRenderNotification) {
        doRenderNotification=true;
      }
    }
  }
  finally {
synchronized (sGLThreadManager) {
      stopEglLocked();
    }
  }
}",0.9407894736842104
182763,"public void onWindowResize(int w,int h){
synchronized (sGLThreadManager) {
    mWidth=w;
    mHeight=h;
    mSizeChanged=true;
    mRequestRender=true;
    sGLThreadManager.notifyAll();
  }
}","public void onWindowResize(int w,int h){
synchronized (sGLThreadManager) {
    mWidth=w;
    mHeight=h;
    mSizeChanged=true;
    mRequestRender=true;
    mRenderComplete=false;
    sGLThreadManager.notifyAll();
    while (!mExited && !mPaused && !mRenderComplete) {
      if (LOG_SURFACE) {
        Log.i(""String_Node_Str"",""String_Node_Str"");
      }
      try {
        sGLThreadManager.wait();
      }
 catch (      InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
    }
  }
}",0.5449358059914408
182764,"private void guardedRun() throws InterruptedException {
  mEglHelper=new EglHelper();
  try {
    GL10 gl=null;
    boolean createEglSurface=false;
    boolean sizeChanged=false;
    int w=0;
    int h=0;
    Runnable event=null;
    while (true) {
synchronized (sGLThreadManager) {
        while (true) {
          if (mShouldExit) {
            return;
          }
          if (!mEventQueue.isEmpty()) {
            event=mEventQueue.remove(0);
            break;
          }
          if (mHaveEgl && mPaused) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            stopEglLocked();
          }
          if ((!mHasSurface) && (!mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            if (mHaveEgl) {
              stopEglLocked();
            }
            mWaitingForSurface=true;
            sGLThreadManager.notifyAll();
          }
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            mWaitingForSurface=false;
            sGLThreadManager.notifyAll();
          }
          if ((!mPaused) && mHasSurface && (mWidth > 0)&& (mHeight > 0)&& (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
            if ((!mHaveEgl) && sGLThreadManager.tryAcquireEglSurfaceLocked(this)) {
              mHaveEgl=true;
              mEglHelper.start();
              createEglSurface=true;
              sizeChanged=true;
              sGLThreadManager.notifyAll();
            }
            if (mHaveEgl) {
              if (mSizeChanged) {
                sizeChanged=true;
                w=mWidth;
                h=mHeight;
                if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
                }
 else {
                  mRequestRender=false;
                }
                mSizeChanged=false;
              }
 else {
                mRequestRender=false;
              }
              sGLThreadManager.notifyAll();
              break;
            }
          }
          if (LOG_THREADS) {
            Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
          }
          sGLThreadManager.wait();
        }
      }
      if (event != null) {
        event.run();
        event=null;
        continue;
      }
      if (createEglSurface) {
        gl=(GL10)mEglHelper.createSurface(getHolder());
        sGLThreadManager.checkGLDriver(gl);
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"");
        }
        mRenderer.onSurfaceCreated(gl,mEglHelper.mEglConfig);
        createEglSurface=false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + w + ""String_Node_Str""+ h+ ""String_Node_Str"");
        }
        mRenderer.onSurfaceChanged(gl,w,h);
        sizeChanged=false;
      }
      if (LOG_RENDERER) {
        Log.w(""String_Node_Str"",""String_Node_Str"");
      }
      mRenderer.onDrawFrame(gl);
      if (!mEglHelper.swap()) {
        if (LOG_SURFACE) {
          Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
        }
      }
    }
  }
  finally {
synchronized (sGLThreadManager) {
      stopEglLocked();
    }
  }
}","private void guardedRun() throws InterruptedException {
  mEglHelper=new EglHelper();
  try {
    GL10 gl=null;
    boolean createEglSurface=false;
    boolean sizeChanged=false;
    boolean wantRenderNotification=false;
    boolean doRenderNotification=false;
    int w=0;
    int h=0;
    Runnable event=null;
    while (true) {
synchronized (sGLThreadManager) {
        while (true) {
          if (mShouldExit) {
            return;
          }
          if (!mEventQueue.isEmpty()) {
            event=mEventQueue.remove(0);
            break;
          }
          if (mHaveEgl && mPaused) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            stopEglLocked();
          }
          if ((!mHasSurface) && (!mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            if (mHaveEgl) {
              stopEglLocked();
            }
            mWaitingForSurface=true;
            sGLThreadManager.notifyAll();
          }
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            mWaitingForSurface=false;
            sGLThreadManager.notifyAll();
          }
          if (doRenderNotification) {
            wantRenderNotification=false;
            doRenderNotification=false;
            mRenderComplete=true;
            sGLThreadManager.notifyAll();
          }
          if ((!mPaused) && mHasSurface && (mWidth > 0)&& (mHeight > 0)&& (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
            if ((!mHaveEgl) && sGLThreadManager.tryAcquireEglSurfaceLocked(this)) {
              mHaveEgl=true;
              mEglHelper.start();
              createEglSurface=true;
              sizeChanged=true;
              sGLThreadManager.notifyAll();
            }
            if (mHaveEgl) {
              if (mSizeChanged) {
                sizeChanged=true;
                w=mWidth;
                h=mHeight;
                wantRenderNotification=true;
                if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
                }
 else {
                  mRequestRender=false;
                }
                mSizeChanged=false;
              }
 else {
                mRequestRender=false;
              }
              sGLThreadManager.notifyAll();
              break;
            }
          }
          if (LOG_THREADS) {
            Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
          }
          sGLThreadManager.wait();
        }
      }
      if (event != null) {
        event.run();
        event=null;
        continue;
      }
      if (createEglSurface) {
        gl=(GL10)mEglHelper.createSurface(getHolder());
        sGLThreadManager.checkGLDriver(gl);
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"");
        }
        mRenderer.onSurfaceCreated(gl,mEglHelper.mEglConfig);
        createEglSurface=false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + w + ""String_Node_Str""+ h+ ""String_Node_Str"");
        }
        mRenderer.onSurfaceChanged(gl,w,h);
        sizeChanged=false;
      }
      if (LOG_RENDERER) {
        Log.w(""String_Node_Str"",""String_Node_Str"");
      }
      mRenderer.onDrawFrame(gl);
      if (!mEglHelper.swap()) {
        if (LOG_SURFACE) {
          Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
        }
      }
      if (wantRenderNotification) {
        doRenderNotification=true;
      }
    }
  }
  finally {
synchronized (sGLThreadManager) {
      stopEglLocked();
    }
  }
}",0.9415254237288136
182765,"/** 
 * Default implementation of   {@link KeyEvent.Callback#onKeyMultiple(int,int,KeyEvent) KeyEvent.Callback.onKeyMultiple()}: perform clicking of the view when   {@link KeyEvent#KEYCODE_DPAD_CENTER} or{@link KeyEvent#KEYCODE_ENTER} is released.
 * @param keyCode A key code that represents the button pressed, from{@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
public boolean onKeyUp(int keyCode,KeyEvent event){
  boolean result=false;
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
{
      if ((mViewFlags & ENABLED_MASK) == DISABLED) {
        return true;
      }
      if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
        setPressed(false);
        if (!mHasPerformedLongPress) {
          cancelLongPress();
          result=performClick();
        }
      }
      break;
    }
}
return result;
}","/** 
 * Default implementation of   {@link KeyEvent.Callback#onKeyMultiple(int,int,KeyEvent) KeyEvent.Callback.onKeyMultiple()}: perform clicking of the view when   {@link KeyEvent#KEYCODE_DPAD_CENTER} or{@link KeyEvent#KEYCODE_ENTER} is released.
 * @param keyCode A key code that represents the button pressed, from{@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
public boolean onKeyUp(int keyCode,KeyEvent event){
  boolean result=false;
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
{
      if ((mViewFlags & ENABLED_MASK) == DISABLED) {
        return true;
      }
      if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
        setPressed(false);
        if (!mHasPerformedLongPress) {
          removeLongPressCallback();
          result=performClick();
        }
      }
      break;
    }
}
return result;
}",0.989106753812636
182766,"private void resetPressedState(){
  if ((mViewFlags & ENABLED_MASK) == DISABLED) {
    return;
  }
  if (isPressed()) {
    setPressed(false);
    if (!mHasPerformedLongPress) {
      cancelLongPress();
    }
  }
}","private void resetPressedState(){
  if ((mViewFlags & ENABLED_MASK) == DISABLED) {
    return;
  }
  if (isPressed()) {
    setPressed(false);
    if (!mHasPerformedLongPress) {
      removeLongPressCallback();
    }
  }
}",0.9541284403669724
182767,"/** 
 * Cancels a pending long press.  Your subclass can use this if you want the context menu to come up if the user presses and holds at the same place, but you don't want it to come up if they press and then move around enough to cause scrolling.
 */
public void cancelLongPress(){
  if (mPendingCheckForLongPress != null) {
    removeCallbacks(mPendingCheckForLongPress);
  }
}","/** 
 * Cancels a pending long press.  Your subclass can use this if you want the context menu to come up if the user presses and holds at the same place, but you don't want it to come up if they press and then move around enough to cause scrolling.
 */
public void cancelLongPress(){
  removeLongPressCallback();
}",0.8390804597701149
182768,"/** 
 * Implement this method to handle touch screen motion events.
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
public boolean onTouchEvent(MotionEvent event){
  final int viewFlags=mViewFlags;
  if ((viewFlags & ENABLED_MASK) == DISABLED) {
    return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
  }
  if (mTouchDelegate != null) {
    if (mTouchDelegate.onTouchEvent(event)) {
      return true;
    }
  }
  if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
switch (event.getAction()) {
case MotionEvent.ACTION_UP:
      if ((mPrivateFlags & PRESSED) != 0) {
        boolean focusTaken=false;
        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
          focusTaken=requestFocus();
        }
        if (!mHasPerformedLongPress) {
          cancelLongPress();
          if (!focusTaken) {
            performClick();
          }
        }
        if (mUnsetPressedState == null) {
          mUnsetPressedState=new UnsetPressedState();
        }
        if (!post(mUnsetPressedState)) {
          mUnsetPressedState.run();
        }
      }
    break;
case MotionEvent.ACTION_DOWN:
  mPrivateFlags|=PRESSED;
refreshDrawableState();
if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {
postCheckForLongClick();
}
break;
case MotionEvent.ACTION_CANCEL:
mPrivateFlags&=~PRESSED;
refreshDrawableState();
break;
case MotionEvent.ACTION_MOVE:
final int x=(int)event.getX();
final int y=(int)event.getY();
int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
if ((x < 0 - slop) || (x >= getWidth() + slop) || (y < 0 - slop)|| (y >= getHeight() + slop)) {
if ((mPrivateFlags & PRESSED) != 0) {
cancelLongPress();
mPrivateFlags&=~PRESSED;
refreshDrawableState();
}
}
 else {
if ((mPrivateFlags & PRESSED) == 0) {
mPrivateFlags|=PRESSED;
refreshDrawableState();
}
}
break;
}
return true;
}
return false;
}","/** 
 * Implement this method to handle touch screen motion events.
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
public boolean onTouchEvent(MotionEvent event){
  final int viewFlags=mViewFlags;
  if ((viewFlags & ENABLED_MASK) == DISABLED) {
    return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
  }
  if (mTouchDelegate != null) {
    if (mTouchDelegate.onTouchEvent(event)) {
      return true;
    }
  }
  if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
switch (event.getAction()) {
case MotionEvent.ACTION_UP:
      if ((mPrivateFlags & PRESSED) != 0) {
        boolean focusTaken=false;
        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
          focusTaken=requestFocus();
        }
        if (!mHasPerformedLongPress) {
          removeLongPressCallback();
          if (!focusTaken) {
            performClick();
          }
        }
        if (mUnsetPressedState == null) {
          mUnsetPressedState=new UnsetPressedState();
        }
        if (!post(mUnsetPressedState)) {
          mUnsetPressedState.run();
        }
      }
    break;
case MotionEvent.ACTION_DOWN:
  mPrivateFlags|=PRESSED;
refreshDrawableState();
if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {
postCheckForLongClick();
}
break;
case MotionEvent.ACTION_CANCEL:
mPrivateFlags&=~PRESSED;
refreshDrawableState();
break;
case MotionEvent.ACTION_MOVE:
final int x=(int)event.getX();
final int y=(int)event.getY();
int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
if ((x < 0 - slop) || (x >= getWidth() + slop) || (y < 0 - slop)|| (y >= getHeight() + slop)) {
if ((mPrivateFlags & PRESSED) != 0) {
removeLongPressCallback();
mPrivateFlags&=~PRESSED;
refreshDrawableState();
}
}
 else {
if ((mPrivateFlags & PRESSED) == 0) {
mPrivateFlags|=PRESSED;
refreshDrawableState();
}
}
break;
}
return true;
}
return false;
}",0.9808467741935484
182769,"/** 
 * Called when the window containing this view gains or loses focus.  Note that this is separate from view focus: to receive key events, both your view and its window must have focus.  If a window is displayed on top of yours that takes input focus, then your own window will lose focus but the view focus will remain unchanged.
 * @param hasWindowFocus True if the window containing this view now hasfocus, false otherwise.
 */
public void onWindowFocusChanged(boolean hasWindowFocus){
  InputMethodManager imm=InputMethodManager.peekInstance();
  if (!hasWindowFocus) {
    if (isPressed()) {
      setPressed(false);
    }
    if (imm != null && (mPrivateFlags & FOCUSED) != 0) {
      imm.focusOut(this);
    }
    cancelLongPress();
    onFocusLost();
  }
 else   if (imm != null && (mPrivateFlags & FOCUSED) != 0) {
    imm.focusIn(this);
  }
  refreshDrawableState();
}","/** 
 * Called when the window containing this view gains or loses focus.  Note that this is separate from view focus: to receive key events, both your view and its window must have focus.  If a window is displayed on top of yours that takes input focus, then your own window will lose focus but the view focus will remain unchanged.
 * @param hasWindowFocus True if the window containing this view now hasfocus, false otherwise.
 */
public void onWindowFocusChanged(boolean hasWindowFocus){
  InputMethodManager imm=InputMethodManager.peekInstance();
  if (!hasWindowFocus) {
    if (isPressed()) {
      setPressed(false);
    }
    if (imm != null && (mPrivateFlags & FOCUSED) != 0) {
      imm.focusOut(this);
    }
    removeLongPressCallback();
    onFocusLost();
  }
 else   if (imm != null && (mPrivateFlags & FOCUSED) != 0) {
    imm.focusIn(this);
  }
  refreshDrawableState();
}",0.9887005649717514
182770,"/** 
 * This is called when the view is detached from a window.  At this point it no longer has a surface for drawing.
 * @see #onAttachedToWindow()
 */
protected void onDetachedFromWindow(){
  cancelLongPress();
  destroyDrawingCache();
}","/** 
 * This is called when the view is detached from a window.  At this point it no longer has a surface for drawing.
 * @see #onAttachedToWindow()
 */
protected void onDetachedFromWindow(){
  removeLongPressCallback();
  destroyDrawingCache();
}",0.9588477366255144
182771,"/** 
 * When visibility is set to   {@link #VISIBLE} or {@link #INVISIBLE},  {@link #inflate()} is invoked and this StubbedView is replaced in its parentby the inflated layout resource.
 * @param visibility One of {@link #VISIBLE},   {@link #INVISIBLE}, or   {@link #GONE}.
 * @see #inflate() 
 */
@Override public void setVisibility(int visibility){
  if (mInflatedViewRef != null) {
    View view=mInflatedViewRef.get();
    if (view != null) {
      view.setVisibility(visibility);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 else   if (visibility == VISIBLE || visibility == INVISIBLE) {
    super.setVisibility(visibility);
    inflate();
  }
}","/** 
 * When visibility is set to   {@link #VISIBLE} or {@link #INVISIBLE},  {@link #inflate()} is invoked and this StubbedView is replaced in its parentby the inflated layout resource.
 * @param visibility One of {@link #VISIBLE},   {@link #INVISIBLE}, or   {@link #GONE}.
 * @see #inflate() 
 */
@Override public void setVisibility(int visibility){
  if (mInflatedViewRef != null) {
    View view=mInflatedViewRef.get();
    if (view != null) {
      view.setVisibility(visibility);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 else {
    super.setVisibility(visibility);
    if (visibility == VISIBLE || visibility == INVISIBLE) {
      inflate();
    }
  }
}",0.92507204610951
182772,"/** 
 * Inflates the layout resource identified by   {@link #getLayoutResource()}and replaces this StubbedView in its parent by the inflated layout resource.
 * @return The inflated layout resource.
 */
public View inflate(){
  final ViewParent viewParent=getParent();
  if (viewParent != null && viewParent instanceof ViewGroup) {
    if (mLayoutResource != 0) {
      final ViewGroup parent=(ViewGroup)viewParent;
      final LayoutInflater factory=LayoutInflater.from(mContext);
      final View view=factory.inflate(mLayoutResource,parent,false);
      if (mInflatedId != NO_ID) {
        view.setId(mInflatedId);
      }
      final int index=parent.indexOfChild(this);
      parent.removeViewInLayout(this);
      final ViewGroup.LayoutParams layoutParams=getLayoutParams();
      if (layoutParams != null) {
        parent.addView(view,index,layoutParams);
      }
 else {
        parent.addView(view,index);
      }
      mInflatedViewRef=new WeakReference(view);
      if (mInflateListener != null) {
        mInflateListener.onInflate(this,view);
      }
      return view;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}","/** 
 * Inflates the layout resource identified by   {@link #getLayoutResource()}and replaces this StubbedView in its parent by the inflated layout resource.
 * @return The inflated layout resource.
 */
public View inflate(){
  final ViewParent viewParent=getParent();
  if (viewParent != null && viewParent instanceof ViewGroup) {
    if (mLayoutResource != 0) {
      final ViewGroup parent=(ViewGroup)viewParent;
      final LayoutInflater factory=LayoutInflater.from(mContext);
      final View view=factory.inflate(mLayoutResource,parent,false);
      if (mInflatedId != NO_ID) {
        view.setId(mInflatedId);
      }
      final int index=parent.indexOfChild(this);
      parent.removeViewInLayout(this);
      final ViewGroup.LayoutParams layoutParams=getLayoutParams();
      if (layoutParams != null) {
        parent.addView(view,index,layoutParams);
      }
 else {
        parent.addView(view,index);
      }
      mInflatedViewRef=new WeakReference<View>(view);
      if (mInflateListener != null) {
        mInflateListener.onInflate(this,view);
      }
      return view;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.9975825946817084
182773,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}",0.9530026109660574
182774,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}",0.7011070110701108
182775,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}",0.8672168042010503
182776,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}",0.842443729903537
182777,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}",0.9530026109660574
182778,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}",0.7011070110701108
182779,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}",0.8672168042010503
182780,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}",0.842443729903537
182781,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}",0.9530026109660574
182782,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}",0.7011070110701108
182783,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}",0.8672168042010503
182784,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}",0.842443729903537
182785,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}",0.9530026109660574
182786,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}",0.7011070110701108
182787,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}",0.8672168042010503
182788,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}",0.842443729903537
182789,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}",0.9530026109660574
182790,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}",0.7011070110701108
182791,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}",0.8672168042010503
182792,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}",0.842443729903537
182793,"public final void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed){
  ActivityRecord r=new ActivityRecord();
  r.token=token;
  r.pendingResults=pendingResults;
  r.pendingIntents=pendingNewIntents;
  r.startsNotResumed=notResumed;
synchronized (mRelaunchingActivities) {
    mRelaunchingActivities.add(r);
  }
  queueOrSendMessage(H.RELAUNCH_ACTIVITY,r,configChanges);
}","public final void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed,Configuration config){
  ActivityRecord r=new ActivityRecord();
  r.token=token;
  r.pendingResults=pendingResults;
  r.pendingIntents=pendingNewIntents;
  r.startsNotResumed=notResumed;
  r.createdConfig=config;
synchronized (mRelaunchingActivities) {
    mRelaunchingActivities.add(r);
  }
  queueOrSendMessage(H.RELAUNCH_ACTIVITY,r,configChanges);
}",0.9515962924819772
182794,"private final void handleRelaunchActivity(ActivityRecord tmp,int configChanges){
  unscheduleGcIdler();
  Configuration changedConfig=null;
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + tmp.token + ""String_Node_Str""+ Integer.toHexString(configChanges));
synchronized (mRelaunchingActivities) {
    int N=mRelaunchingActivities.size();
    IBinder token=tmp.token;
    tmp=null;
    for (int i=0; i < N; i++) {
      ActivityRecord r=mRelaunchingActivities.get(i);
      if (r.token == token) {
        tmp=r;
        mRelaunchingActivities.remove(i);
        i--;
        N--;
      }
    }
    if (tmp == null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"");
      return;
    }
    if (mPendingConfiguration != null) {
      changedConfig=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + tmp.token + ""String_Node_Str""+ changedConfig);
  if (changedConfig != null) {
    handleConfigurationChanged(changedConfig);
  }
  ActivityRecord r=mActivities.get(tmp.token);
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + r);
  if (r == null) {
    return;
  }
  r.activity.mConfigChangeFlags|=configChanges;
  Intent currentIntent=r.activity.mIntent;
  Bundle savedState=null;
  if (!r.paused) {
    savedState=performPauseActivity(r.token,false,true);
  }
  handleDestroyActivity(r.token,false,configChanges,true);
  r.activity=null;
  r.window=null;
  r.hideForNow=false;
  r.nextIdle=null;
  if (tmp.pendingResults != null) {
    if (r.pendingResults == null) {
      r.pendingResults=tmp.pendingResults;
    }
 else {
      r.pendingResults.addAll(tmp.pendingResults);
    }
  }
  if (tmp.pendingIntents != null) {
    if (r.pendingIntents == null) {
      r.pendingIntents=tmp.pendingIntents;
    }
 else {
      r.pendingIntents.addAll(tmp.pendingIntents);
    }
  }
  r.startsNotResumed=tmp.startsNotResumed;
  if (savedState != null) {
    r.state=savedState;
  }
  handleLaunchActivity(r,currentIntent);
}","private final void handleRelaunchActivity(ActivityRecord tmp,int configChanges){
  unscheduleGcIdler();
  Configuration changedConfig=null;
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + tmp.token + ""String_Node_Str""+ Integer.toHexString(configChanges));
synchronized (mRelaunchingActivities) {
    int N=mRelaunchingActivities.size();
    IBinder token=tmp.token;
    tmp=null;
    for (int i=0; i < N; i++) {
      ActivityRecord r=mRelaunchingActivities.get(i);
      if (r.token == token) {
        tmp=r;
        mRelaunchingActivities.remove(i);
        i--;
        N--;
      }
    }
    if (tmp == null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"");
      return;
    }
    if (mPendingConfiguration != null) {
      changedConfig=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  if (tmp.createdConfig != null) {
    if (mConfiguration == null || mConfiguration.diff(tmp.createdConfig) != 0) {
      changedConfig=tmp.createdConfig;
    }
  }
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + tmp.token + ""String_Node_Str""+ changedConfig);
  if (changedConfig != null) {
    handleConfigurationChanged(changedConfig);
  }
  ActivityRecord r=mActivities.get(tmp.token);
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + r);
  if (r == null) {
    return;
  }
  r.activity.mConfigChangeFlags|=configChanges;
  Intent currentIntent=r.activity.mIntent;
  Bundle savedState=null;
  if (!r.paused) {
    savedState=performPauseActivity(r.token,false,true);
  }
  handleDestroyActivity(r.token,false,configChanges,true);
  r.activity=null;
  r.window=null;
  r.hideForNow=false;
  r.nextIdle=null;
  if (tmp.pendingResults != null) {
    if (r.pendingResults == null) {
      r.pendingResults=tmp.pendingResults;
    }
 else {
      r.pendingResults.addAll(tmp.pendingResults);
    }
  }
  if (tmp.pendingIntents != null) {
    if (r.pendingIntents == null) {
      r.pendingIntents=tmp.pendingIntents;
    }
 else {
      r.pendingIntents.addAll(tmp.pendingIntents);
    }
  }
  r.startsNotResumed=tmp.startsNotResumed;
  if (savedState != null) {
    r.state=savedState;
  }
  handleLaunchActivity(r,currentIntent);
}",0.9609282500591996
182795,"private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(a.getResources().getConfiguration());
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.9903076274757692
182796,"public final void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeStrongBinder(token);
  data.writeTypedList(pendingResults);
  data.writeTypedList(pendingNewIntents);
  data.writeInt(configChanges);
  data.writeInt(notResumed ? 1 : 0);
  mRemote.transact(SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}","public final void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed,Configuration config) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeStrongBinder(token);
  data.writeTypedList(pendingResults);
  data.writeTypedList(pendingNewIntents);
  data.writeInt(configChanges);
  data.writeInt(notResumed ? 1 : 0);
  if (config != null) {
    data.writeInt(1);
    config.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}",0.8904649330181245
182797,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.993598940514292
182798,"void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed) throws RemoteException ;","void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed,Configuration config) throws RemoteException ;",0.9415041782729804
182799,"private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    reportResumedActivityLocked(r);
  }
  return true;
}","private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume,mConfiguration);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    reportResumedActivityLocked(r);
  }
  return true;
}",0.9917627677100496
182800,"@Override protected void layoutChildren(){
  final boolean blockLayoutRequests=mBlockLayoutRequests;
  if (!blockLayoutRequests) {
    mBlockLayoutRequests=true;
  }
 else {
    return;
  }
  try {
    super.layoutChildren();
    invalidate();
    if (mAdapter == null) {
      resetList();
      invokeOnItemScrollListener();
      return;
    }
    int childrenTop=mListPadding.top;
    int childrenBottom=mBottom - mTop - mListPadding.bottom;
    int childCount=getChildCount();
    int index;
    int delta=0;
    View sel;
    View oldSel=null;
    View oldFirst=null;
    View newSel=null;
    View focusLayoutRestoreView=null;
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
      index=mNextSelectedPosition - mFirstPosition;
    if (index >= 0 && index < childCount) {
      newSel=getChildAt(index);
    }
  break;
case LAYOUT_FORCE_TOP:
case LAYOUT_FORCE_BOTTOM:
case LAYOUT_SPECIFIC:
case LAYOUT_SYNC:
break;
case LAYOUT_MOVE_SELECTION:
default :
index=mSelectedPosition - mFirstPosition;
if (index >= 0 && index < childCount) {
oldSel=getChildAt(index);
}
oldFirst=getChildAt(0);
if (mNextSelectedPosition >= 0) {
delta=mNextSelectedPosition - mSelectedPosition;
}
newSel=getChildAt(index + delta);
}
boolean dataChanged=mDataChanged;
if (dataChanged) {
handleDataChanged();
}
if (mItemCount == 0) {
resetList();
invokeOnItemScrollListener();
return;
}
 else if (mItemCount != mAdapter.getCount()) {
throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + getId() + ""String_Node_Str""+ getClass()+ ""String_Node_Str""+ mAdapter.getClass()+ ""String_Node_Str"");
}
setSelectedPositionInt(mNextSelectedPosition);
final int firstPosition=mFirstPosition;
final RecycleBin recycleBin=mRecycler;
View focusLayoutRestoreDirectChild=null;
if (dataChanged) {
for (int i=0; i < childCount; i++) {
recycleBin.addScrapView(getChildAt(i));
if (ViewDebug.TRACE_RECYCLER) {
ViewDebug.trace(getChildAt(i),ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,index,i);
}
}
}
 else {
recycleBin.fillActiveViews(childCount,firstPosition);
}
final View focusedChild=getFocusedChild();
if (focusedChild != null) {
if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
focusLayoutRestoreDirectChild=focusedChild;
focusLayoutRestoreView=findFocus();
if (focusLayoutRestoreView != null) {
focusLayoutRestoreView.onStartTemporaryDetach();
}
}
requestFocus();
}
detachAllViewsFromParent();
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
if (newSel != null) {
sel=fillFromSelection(newSel.getTop(),childrenTop,childrenBottom);
}
 else {
sel=fillFromMiddle(childrenTop,childrenBottom);
}
break;
case LAYOUT_SYNC:
sel=fillSpecific(mSyncPosition,mSpecificTop);
break;
case LAYOUT_FORCE_BOTTOM:
sel=fillUp(mItemCount - 1,childrenBottom);
adjustViewsUpOrDown();
break;
case LAYOUT_FORCE_TOP:
mFirstPosition=0;
sel=fillFromTop(childrenTop);
adjustViewsUpOrDown();
break;
case LAYOUT_SPECIFIC:
sel=fillSpecific(reconcileSelectedPosition(),mSpecificTop);
break;
case LAYOUT_MOVE_SELECTION:
sel=moveSelection(oldSel,newSel,delta,childrenTop,childrenBottom);
break;
default :
if (childCount == 0) {
if (!mStackFromBottom) {
final int position=lookForSelectablePosition(0,true);
setSelectedPositionInt(position);
sel=fillFromTop(childrenTop);
}
 else {
final int position=lookForSelectablePosition(mItemCount - 1,false);
setSelectedPositionInt(position);
sel=fillUp(mItemCount - 1,childrenBottom);
}
}
 else {
if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
sel=fillSpecific(mSelectedPosition,oldSel == null ? childrenTop : oldSel.getTop());
}
 else if (mFirstPosition < mItemCount) {
sel=fillSpecific(mFirstPosition,oldFirst == null ? childrenTop : oldFirst.getTop());
}
 else {
sel=fillSpecific(0,childrenTop);
}
}
break;
}
recycleBin.scrapActiveViews();
if (sel != null) {
if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
final boolean focusWasTaken=(sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
if (!focusWasTaken) {
final View focused=getFocusedChild();
if (focused != null) {
focused.clearFocus();
}
positionSelector(sel);
}
 else {
sel.setSelected(false);
mSelectorRect.setEmpty();
}
}
 else {
positionSelector(sel);
}
mSelectedTop=sel.getTop();
}
 else {
if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
View child=getChildAt(mMotionPosition - mFirstPosition);
if (child != null) positionSelector(child);
}
 else {
mSelectedTop=0;
mSelectorRect.setEmpty();
}
if (hasFocus() && focusLayoutRestoreView != null) {
focusLayoutRestoreView.requestFocus();
}
}
if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
focusLayoutRestoreView.onFinishTemporaryDetach();
}
mLayoutMode=LAYOUT_NORMAL;
mDataChanged=false;
mNeedSync=false;
setNextSelectedPositionInt(mSelectedPosition);
updateScrollIndicators();
if (mItemCount > 0) {
checkSelectionChanged();
}
invokeOnItemScrollListener();
}
  finally {
if (!blockLayoutRequests) {
mBlockLayoutRequests=false;
}
}
}","@Override protected void layoutChildren(){
  final boolean blockLayoutRequests=mBlockLayoutRequests;
  if (!blockLayoutRequests) {
    mBlockLayoutRequests=true;
  }
 else {
    return;
  }
  try {
    super.layoutChildren();
    invalidate();
    if (mAdapter == null) {
      resetList();
      invokeOnItemScrollListener();
      return;
    }
    int childrenTop=mListPadding.top;
    int childrenBottom=mBottom - mTop - mListPadding.bottom;
    int childCount=getChildCount();
    int index=0;
    int delta=0;
    View sel;
    View oldSel=null;
    View oldFirst=null;
    View newSel=null;
    View focusLayoutRestoreView=null;
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
      index=mNextSelectedPosition - mFirstPosition;
    if (index >= 0 && index < childCount) {
      newSel=getChildAt(index);
    }
  break;
case LAYOUT_FORCE_TOP:
case LAYOUT_FORCE_BOTTOM:
case LAYOUT_SPECIFIC:
case LAYOUT_SYNC:
break;
case LAYOUT_MOVE_SELECTION:
default :
index=mSelectedPosition - mFirstPosition;
if (index >= 0 && index < childCount) {
oldSel=getChildAt(index);
}
oldFirst=getChildAt(0);
if (mNextSelectedPosition >= 0) {
delta=mNextSelectedPosition - mSelectedPosition;
}
newSel=getChildAt(index + delta);
}
boolean dataChanged=mDataChanged;
if (dataChanged) {
handleDataChanged();
}
if (mItemCount == 0) {
resetList();
invokeOnItemScrollListener();
return;
}
 else if (mItemCount != mAdapter.getCount()) {
throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + getId() + ""String_Node_Str""+ getClass()+ ""String_Node_Str""+ mAdapter.getClass()+ ""String_Node_Str"");
}
setSelectedPositionInt(mNextSelectedPosition);
final int firstPosition=mFirstPosition;
final RecycleBin recycleBin=mRecycler;
View focusLayoutRestoreDirectChild=null;
if (dataChanged) {
for (int i=0; i < childCount; i++) {
recycleBin.addScrapView(getChildAt(i));
if (ViewDebug.TRACE_RECYCLER) {
ViewDebug.trace(getChildAt(i),ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,index,i);
}
}
}
 else {
recycleBin.fillActiveViews(childCount,firstPosition);
}
final View focusedChild=getFocusedChild();
if (focusedChild != null) {
if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
focusLayoutRestoreDirectChild=focusedChild;
focusLayoutRestoreView=findFocus();
if (focusLayoutRestoreView != null) {
focusLayoutRestoreView.onStartTemporaryDetach();
}
}
requestFocus();
}
detachAllViewsFromParent();
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
if (newSel != null) {
sel=fillFromSelection(newSel.getTop(),childrenTop,childrenBottom);
}
 else {
sel=fillFromMiddle(childrenTop,childrenBottom);
}
break;
case LAYOUT_SYNC:
sel=fillSpecific(mSyncPosition,mSpecificTop);
break;
case LAYOUT_FORCE_BOTTOM:
sel=fillUp(mItemCount - 1,childrenBottom);
adjustViewsUpOrDown();
break;
case LAYOUT_FORCE_TOP:
mFirstPosition=0;
sel=fillFromTop(childrenTop);
adjustViewsUpOrDown();
break;
case LAYOUT_SPECIFIC:
sel=fillSpecific(reconcileSelectedPosition(),mSpecificTop);
break;
case LAYOUT_MOVE_SELECTION:
sel=moveSelection(oldSel,newSel,delta,childrenTop,childrenBottom);
break;
default :
if (childCount == 0) {
if (!mStackFromBottom) {
final int position=lookForSelectablePosition(0,true);
setSelectedPositionInt(position);
sel=fillFromTop(childrenTop);
}
 else {
final int position=lookForSelectablePosition(mItemCount - 1,false);
setSelectedPositionInt(position);
sel=fillUp(mItemCount - 1,childrenBottom);
}
}
 else {
if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
sel=fillSpecific(mSelectedPosition,oldSel == null ? childrenTop : oldSel.getTop());
}
 else if (mFirstPosition < mItemCount) {
sel=fillSpecific(mFirstPosition,oldFirst == null ? childrenTop : oldFirst.getTop());
}
 else {
sel=fillSpecific(0,childrenTop);
}
}
break;
}
recycleBin.scrapActiveViews();
if (sel != null) {
if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
final boolean focusWasTaken=(sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
if (!focusWasTaken) {
final View focused=getFocusedChild();
if (focused != null) {
focused.clearFocus();
}
positionSelector(sel);
}
 else {
sel.setSelected(false);
mSelectorRect.setEmpty();
}
}
 else {
positionSelector(sel);
}
mSelectedTop=sel.getTop();
}
 else {
if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
View child=getChildAt(mMotionPosition - mFirstPosition);
if (child != null) positionSelector(child);
}
 else {
mSelectedTop=0;
mSelectorRect.setEmpty();
}
if (hasFocus() && focusLayoutRestoreView != null) {
focusLayoutRestoreView.requestFocus();
}
}
if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
focusLayoutRestoreView.onFinishTemporaryDetach();
}
mLayoutMode=LAYOUT_NORMAL;
mDataChanged=false;
mNeedSync=false;
setNextSelectedPositionInt(mSelectedPosition);
updateScrollIndicators();
if (mItemCount > 0) {
checkSelectionChanged();
}
invokeOnItemScrollListener();
}
  finally {
if (!blockLayoutRequests) {
mBlockLayoutRequests=false;
}
}
}",0.9998011928429424
182801,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}",0.9733534439416792
182802,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}",0.9733534439416792
182803,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}",0.9733534439416792
182804,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}",0.9733534439416792
182805,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}",0.9733534439416792
182806,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.6898326898326899
182807,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.7232947232947233
182808,"private boolean assignPointer(int nextIndex,boolean allowOverlap){
  final int lastNumPointers=mLastNumPointers;
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  final int[] last2Next=mLast2Next;
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int id=nextIndex * MotionEvent.NUM_SAMPLE_DATA;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + nextIndex + ""String_Node_Str""+ id);
  final int x1=nextData[id + MotionEvent.SAMPLE_X];
  final int y1=nextData[id + MotionEvent.SAMPLE_Y];
  long bestDistance=-1;
  int bestIndex=-1;
  for (int j=0; j < lastNumPointers; j++) {
    if (!allowOverlap && last2Next[j] < 0) {
      continue;
    }
    final int jd=j * MotionEvent.NUM_SAMPLE_DATA;
    final int xd=lastData[jd + MotionEvent.SAMPLE_X] - x1;
    final int yd=lastData[jd + MotionEvent.SAMPLE_Y] - y1;
    final long distance=xd * (long)xd + yd * (long)yd;
    if (j == 0 || distance < bestDistance) {
      bestDistance=distance;
      bestIndex=j;
    }
  }
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + nextIndex + ""String_Node_Str""+ bestIndex+ ""String_Node_Str""+ bestDistance+ ""String_Node_Str"");
  next2Last[nextIndex]=bestIndex;
  next2LastDistance[nextIndex]=bestDistance;
  if (bestIndex < 0) {
    return true;
  }
  if (last2Next[bestIndex] == -1) {
    last2Next[bestIndex]=nextIndex;
    return false;
  }
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + bestIndex + ""String_Node_Str"");
  last2Next[bestIndex]=-2;
  return true;
}","private boolean assignPointer(int nextIndex,boolean allowOverlap){
  final int lastNumPointers=mLastNumPointers;
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  final int[] last2Next=mLast2Next;
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int id=nextIndex * MotionEvent.NUM_SAMPLE_DATA;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + nextIndex + ""String_Node_Str""+ id);
  final int x1=nextData[id + MotionEvent.SAMPLE_X];
  final int y1=nextData[id + MotionEvent.SAMPLE_Y];
  long bestDistance=-1;
  int bestIndex=-1;
  for (int j=0; j < lastNumPointers; j++) {
    if (!allowOverlap && last2Next[j] < -1) {
      continue;
    }
    final int jd=j * MotionEvent.NUM_SAMPLE_DATA;
    final int xd=lastData[jd + MotionEvent.SAMPLE_X] - x1;
    final int yd=lastData[jd + MotionEvent.SAMPLE_Y] - y1;
    final long distance=xd * (long)xd + yd * (long)yd;
    if (bestDistance == -1 || distance < bestDistance) {
      bestDistance=distance;
      bestIndex=j;
    }
  }
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + nextIndex + ""String_Node_Str""+ bestIndex+ ""String_Node_Str""+ bestDistance+ ""String_Node_Str"");
  next2Last[nextIndex]=bestIndex;
  next2LastDistance[nextIndex]=bestDistance;
  if (bestIndex < 0) {
    return true;
  }
  if (last2Next[bestIndex] == -1) {
    last2Next[bestIndex]=nextIndex;
    return false;
  }
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + bestIndex + ""String_Node_Str"");
  last2Next[bestIndex]=-2;
  return true;
}",0.9914583992407466
182809,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.7232947232947233
182810,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.7232947232947233
182811,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.7232947232947233
182812,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.6898326898326899
182813,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.6898326898326899
182814,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.6898326898326899
182815,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.7232947232947233
182816,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}",0.6898326898326899
182817,"private ViewManager.ChildView createSurface(WebkitPlugin webkitPlugin,int x,int y,int width,int height){
  if (mWebView == null) {
    return null;
  }
  SurfaceDrawingModel embeddedSurface=webkitPlugin.getEmbeddedSurface();
  if (embeddedSurface == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return null;
  }
  View pluginView=embeddedSurface.getSurface();
  ViewManager.ChildView view=mWebView.mViewManager.createView();
  view.mView=pluginView;
  view.attachView(x,y,width,height);
  return view;
}","private ViewManager.ChildView createSurface(WebkitPlugin webkitPlugin,int x,int y,int width,int height){
  if (mWebView == null) {
    return null;
  }
  SurfaceDrawingModel embeddedSurface=webkitPlugin.getEmbeddedSurface();
  if (embeddedSurface == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return null;
  }
  View pluginView=embeddedSurface.getSurface();
  pluginView.setWillNotDraw(false);
  ViewManager.ChildView view=mWebView.mViewManager.createView();
  view.mView=pluginView;
  view.attachView(x,y,width,height);
  return view;
}",0.9657142857142856
182818,"/** 
 * {@inheritDoc} 
 */
public int interceptKeyTq(RawInputEvent event,boolean screenIsOn){
  int result=ACTION_PASS_TO_USER;
  final boolean isWakeKey=isWakeKeyTq(event);
  final boolean keyguardShowing=keyguardIsShowingTq();
  if (false) {
    Log.d(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ event.keycode+ ""String_Node_Str""+ screenIsOn+ ""String_Node_Str""+ keyguardShowing);
  }
  if (keyguardShowing) {
    if (screenIsOn) {
      result|=ACTION_PASS_TO_USER;
    }
 else {
      result&=~ACTION_PASS_TO_USER;
      final boolean isKeyDown=(event.type == RawInputEvent.EV_KEY) && (event.value != 0);
      if (isWakeKey && isKeyDown) {
        if (!mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(event.keycode) && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
          if (isInCall()) {
            mKeyguardMediator.pokeWakelock();
          }
 else           if (isMusicActive()) {
            handleVolumeKey(AudioManager.STREAM_MUSIC,event.keycode);
          }
        }
      }
    }
  }
 else   if (!screenIsOn) {
    if (isInCall() && event.type == RawInputEvent.EV_KEY && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
      result&=~ACTION_PASS_TO_USER;
      handleVolumeKey(AudioManager.STREAM_VOICE_CALL,event.keycode);
    }
    if (isWakeKey) {
      result|=ACTION_POKE_USER_ACTIVITY;
      result&=~ACTION_PASS_TO_USER;
    }
  }
  int type=event.type;
  int code=event.keycode;
  boolean down=event.value != 0;
  if (type == RawInputEvent.EV_KEY) {
    if (code == KeyEvent.KEYCODE_ENDCALL || code == KeyEvent.KEYCODE_POWER) {
      if (down) {
        boolean handled=false;
        ITelephony phoneServ=getPhoneInterface();
        if (phoneServ != null) {
          try {
            if (code == KeyEvent.KEYCODE_ENDCALL) {
              handled=phoneServ.endCall();
            }
 else             if (code == KeyEvent.KEYCODE_POWER && phoneServ.isRinging()) {
              phoneServ.silenceRinger();
              handled=true;
            }
          }
 catch (          RemoteException ex) {
            Log.w(TAG,""String_Node_Str"" + ex);
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if ((handled && code != KeyEvent.KEYCODE_POWER) || !screenIsOn) {
          mShouldTurnOffOnKeyUp=false;
        }
 else {
          mShouldTurnOffOnKeyUp=true;
          mHandler.postDelayed(mPowerLongPress,ViewConfiguration.getGlobalActionKeyTimeout());
          result&=~ACTION_PASS_TO_USER;
        }
      }
 else {
        mHandler.removeCallbacks(mPowerLongPress);
        if (mShouldTurnOffOnKeyUp) {
          mShouldTurnOffOnKeyUp=false;
          boolean gohome=(mEndcallBehavior & ENDCALL_HOME) != 0;
          boolean sleeps=(mEndcallBehavior & ENDCALL_SLEEPS) != 0;
          if (keyguardShowing || (sleeps && !gohome) || (gohome && !goHome() && sleeps)) {
            Log.d(TAG,""String_Node_Str"" + Integer.toHexString(mEndcallBehavior));
            result&=~ACTION_POKE_USER_ACTIVITY;
            result|=ACTION_GO_TO_SLEEP;
          }
          result&=~ACTION_PASS_TO_USER;
        }
      }
    }
 else     if (isMediaKey(code)) {
      if ((result & ACTION_PASS_TO_USER) == 0) {
        KeyEvent keyEvent=new KeyEvent(event.when,event.when,down ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP,code,0);
        mBroadcastWakeLock.acquire();
        mHandler.post(new PassHeadsetKey(keyEvent));
      }
    }
 else     if (code == KeyEvent.KEYCODE_CALL) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.answerRingingCall();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
 else     if ((code == KeyEvent.KEYCODE_VOLUME_UP) || (code == KeyEvent.KEYCODE_VOLUME_DOWN)) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.silenceRinger();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
  }
  return result;
}","/** 
 * {@inheritDoc} 
 */
public int interceptKeyTq(RawInputEvent event,boolean screenIsOn){
  int result=ACTION_PASS_TO_USER;
  final boolean isWakeKey=isWakeKeyTq(event);
  final boolean keyguardActive=(screenIsOn ? mKeyguardMediator.isShowingAndNotHidden() : mKeyguardMediator.isShowing());
  if (false) {
    Log.d(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ event.keycode+ ""String_Node_Str""+ screenIsOn+ ""String_Node_Str""+ keyguardActive);
  }
  if (keyguardActive) {
    if (screenIsOn) {
      result|=ACTION_PASS_TO_USER;
    }
 else {
      result&=~ACTION_PASS_TO_USER;
      final boolean isKeyDown=(event.type == RawInputEvent.EV_KEY) && (event.value != 0);
      if (isWakeKey && isKeyDown) {
        if (!mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(event.keycode) && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
          if (isInCall()) {
            mKeyguardMediator.pokeWakelock();
          }
 else           if (isMusicActive()) {
            handleVolumeKey(AudioManager.STREAM_MUSIC,event.keycode);
          }
        }
      }
    }
  }
 else   if (!screenIsOn) {
    if (isInCall() && event.type == RawInputEvent.EV_KEY && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
      result&=~ACTION_PASS_TO_USER;
      handleVolumeKey(AudioManager.STREAM_VOICE_CALL,event.keycode);
    }
    if (isWakeKey) {
      result|=ACTION_POKE_USER_ACTIVITY;
      result&=~ACTION_PASS_TO_USER;
    }
  }
  int type=event.type;
  int code=event.keycode;
  boolean down=event.value != 0;
  if (type == RawInputEvent.EV_KEY) {
    if (code == KeyEvent.KEYCODE_ENDCALL || code == KeyEvent.KEYCODE_POWER) {
      if (down) {
        boolean handled=false;
        ITelephony phoneServ=getPhoneInterface();
        if (phoneServ != null) {
          try {
            if (code == KeyEvent.KEYCODE_ENDCALL) {
              handled=phoneServ.endCall();
            }
 else             if (code == KeyEvent.KEYCODE_POWER && phoneServ.isRinging()) {
              phoneServ.silenceRinger();
              handled=true;
            }
          }
 catch (          RemoteException ex) {
            Log.w(TAG,""String_Node_Str"" + ex);
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if ((handled && code != KeyEvent.KEYCODE_POWER) || !screenIsOn) {
          mShouldTurnOffOnKeyUp=false;
        }
 else {
          mShouldTurnOffOnKeyUp=true;
          mHandler.postDelayed(mPowerLongPress,ViewConfiguration.getGlobalActionKeyTimeout());
          result&=~ACTION_PASS_TO_USER;
        }
      }
 else {
        mHandler.removeCallbacks(mPowerLongPress);
        if (mShouldTurnOffOnKeyUp) {
          mShouldTurnOffOnKeyUp=false;
          boolean gohome=(mEndcallBehavior & ENDCALL_HOME) != 0;
          boolean sleeps=(mEndcallBehavior & ENDCALL_SLEEPS) != 0;
          if (keyguardActive || (sleeps && !gohome) || (gohome && !goHome() && sleeps)) {
            Log.d(TAG,""String_Node_Str"" + Integer.toHexString(mEndcallBehavior));
            result&=~ACTION_POKE_USER_ACTIVITY;
            result|=ACTION_GO_TO_SLEEP;
          }
          result&=~ACTION_PASS_TO_USER;
        }
      }
    }
 else     if (isMediaKey(code)) {
      if ((result & ACTION_PASS_TO_USER) == 0) {
        KeyEvent keyEvent=new KeyEvent(event.when,event.when,down ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP,code,0);
        mBroadcastWakeLock.acquire();
        mHandler.post(new PassHeadsetKey(keyEvent));
      }
    }
 else     if (code == KeyEvent.KEYCODE_CALL) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.answerRingingCall();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
 else     if ((code == KeyEvent.KEYCODE_VOLUME_UP) || (code == KeyEvent.KEYCODE_VOLUME_DOWN)) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.silenceRinger();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
  }
  return result;
}",0.9861302276336686
182819,"private void process(){
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  KeyEvent lastKey=null;
  long lastKeyTime=SystemClock.uptimeMillis();
  long nextKeyTime=lastKeyTime + LONG_WAIT;
  long downTime=0;
  int keyRepeatCount=0;
  boolean configChanged=false;
  while (true) {
    long curTime=SystemClock.uptimeMillis();
    if (DEBUG_INPUT)     Log.v(TAG,""String_Node_Str"" + curTime + ""String_Node_Str""+ nextKeyTime);
    QueuedEvent ev=mQueue.getEvent((int)((!configChanged && curTime < nextKeyTime) ? (nextKeyTime - curTime) : 0));
    if (DEBUG_INPUT && ev != null)     Log.v(TAG,""String_Node_Str"" + ev.classType + ""String_Node_Str""+ ev.event);
    if (MEASURE_LATENCY) {
      lt.sample(""String_Node_Str"",System.nanoTime() - ev.whenNano);
    }
    if (lastKey != null && !mPolicy.allowKeyRepeat()) {
      lastKey=null;
      downTime=0;
      lastKeyTime=curTime;
      nextKeyTime=curTime + LONG_WAIT;
    }
    try {
      if (ev != null) {
        curTime=SystemClock.uptimeMillis();
        int eventType;
        if (ev.classType == RawInputEvent.CLASS_TOUCHSCREEN) {
          eventType=eventType((MotionEvent)ev.event);
        }
 else         if (ev.classType == RawInputEvent.CLASS_KEYBOARD || ev.classType == RawInputEvent.CLASS_TRACKBALL) {
          eventType=LocalPowerManager.BUTTON_EVENT;
        }
 else {
          eventType=LocalPowerManager.OTHER_EVENT;
        }
        try {
          if ((curTime - mLastBatteryStatsCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
            mLastBatteryStatsCallTime=curTime;
            mBatteryStats.noteInputEvent();
          }
        }
 catch (        RemoteException e) {
        }
        if (eventType != TOUCH_EVENT && eventType != LONG_TOUCH_EVENT && eventType != CHEEK_EVENT) {
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
 else         if (mLastTouchEventType != eventType || (curTime - mLastUserActivityCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
          mLastUserActivityCallTime=curTime;
          mLastTouchEventType=eventType;
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
switch (ev.classType) {
case RawInputEvent.CLASS_KEYBOARD:
          KeyEvent ke=(KeyEvent)ev.event;
        if (ke.isDown()) {
          lastKey=ke;
          downTime=curTime;
          keyRepeatCount=0;
          lastKeyTime=curTime;
          nextKeyTime=lastKeyTime + ViewConfiguration.getLongPressTimeout();
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKeyTime);
        }
 else {
          lastKey=null;
          downTime=0;
          lastKeyTime=curTime;
          nextKeyTime=curTime + LONG_WAIT;
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKeyTime);
        }
      dispatchKey((KeyEvent)ev.event,0,0);
    mQueue.recycleEvent(ev);
  break;
case RawInputEvent.CLASS_TOUCHSCREEN:
dispatchPointer(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_TRACKBALL:
dispatchTrackball(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_CONFIGURATION_CHANGED:
configChanged=true;
break;
default :
mQueue.recycleEvent(ev);
break;
}
}
 else if (configChanged) {
configChanged=false;
sendNewConfiguration();
}
 else if (lastKey != null) {
curTime=SystemClock.uptimeMillis();
if (DEBUG_INPUT) Log.v(TAG,""String_Node_Str"" + nextKeyTime + ""String_Node_Str""+ curTime);
if (curTime < nextKeyTime) {
continue;
}
lastKeyTime=nextKeyTime;
nextKeyTime=nextKeyTime + KEY_REPEAT_DELAY;
keyRepeatCount++;
if (DEBUG_INPUT) Log.v(TAG,""String_Node_Str"" + keyRepeatCount + ""String_Node_Str""+ nextKeyTime);
KeyEvent newEvent;
if (downTime != 0 && (downTime + ViewConfiguration.getLongPressTimeout()) <= curTime) {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount,lastKey.getFlags() | KeyEvent.FLAG_LONG_PRESS);
downTime=0;
}
 else {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount);
}
dispatchKey(newEvent,0,0);
}
 else {
curTime=SystemClock.uptimeMillis();
lastKeyTime=curTime;
nextKeyTime=curTime + LONG_WAIT;
}
}
 catch (Exception e) {
Log.e(TAG,""String_Node_Str"" + e,e);
}
}
}","private void process(){
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  KeyEvent lastKey=null;
  long lastKeyTime=SystemClock.uptimeMillis();
  long nextKeyTime=lastKeyTime + LONG_WAIT;
  long downTime=0;
  int keyRepeatCount=0;
  boolean configChanged=false;
  while (true) {
    long curTime=SystemClock.uptimeMillis();
    if (DEBUG_INPUT)     Log.v(TAG,""String_Node_Str"" + curTime + ""String_Node_Str""+ nextKeyTime);
    QueuedEvent ev=mQueue.getEvent((int)((!configChanged && curTime < nextKeyTime) ? (nextKeyTime - curTime) : 0));
    if (DEBUG_INPUT && ev != null)     Log.v(TAG,""String_Node_Str"" + ev.classType + ""String_Node_Str""+ ev.event);
    if (MEASURE_LATENCY) {
      lt.sample(""String_Node_Str"",System.nanoTime() - ev.whenNano);
    }
    if (lastKey != null && !mPolicy.allowKeyRepeat()) {
      lastKey=null;
      downTime=0;
      lastKeyTime=curTime;
      nextKeyTime=curTime + LONG_WAIT;
    }
    try {
      if (ev != null) {
        curTime=SystemClock.uptimeMillis();
        int eventType;
        if (ev.classType == RawInputEvent.CLASS_TOUCHSCREEN) {
          eventType=eventType((MotionEvent)ev.event);
        }
 else         if (ev.classType == RawInputEvent.CLASS_KEYBOARD || ev.classType == RawInputEvent.CLASS_TRACKBALL) {
          eventType=LocalPowerManager.BUTTON_EVENT;
        }
 else {
          eventType=LocalPowerManager.OTHER_EVENT;
        }
        try {
          if ((curTime - mLastBatteryStatsCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
            mLastBatteryStatsCallTime=curTime;
            mBatteryStats.noteInputEvent();
          }
        }
 catch (        RemoteException e) {
        }
        if (ev.classType == RawInputEvent.CLASS_CONFIGURATION_CHANGED) {
        }
 else         if (eventType != TOUCH_EVENT && eventType != LONG_TOUCH_EVENT && eventType != CHEEK_EVENT) {
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
 else         if (mLastTouchEventType != eventType || (curTime - mLastUserActivityCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
          mLastUserActivityCallTime=curTime;
          mLastTouchEventType=eventType;
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
switch (ev.classType) {
case RawInputEvent.CLASS_KEYBOARD:
          KeyEvent ke=(KeyEvent)ev.event;
        if (ke.isDown()) {
          lastKey=ke;
          downTime=curTime;
          keyRepeatCount=0;
          lastKeyTime=curTime;
          nextKeyTime=lastKeyTime + ViewConfiguration.getLongPressTimeout();
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKeyTime);
        }
 else {
          lastKey=null;
          downTime=0;
          lastKeyTime=curTime;
          nextKeyTime=curTime + LONG_WAIT;
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKeyTime);
        }
      dispatchKey((KeyEvent)ev.event,0,0);
    mQueue.recycleEvent(ev);
  break;
case RawInputEvent.CLASS_TOUCHSCREEN:
dispatchPointer(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_TRACKBALL:
dispatchTrackball(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_CONFIGURATION_CHANGED:
configChanged=true;
break;
default :
mQueue.recycleEvent(ev);
break;
}
}
 else if (configChanged) {
configChanged=false;
sendNewConfiguration();
}
 else if (lastKey != null) {
curTime=SystemClock.uptimeMillis();
if (DEBUG_INPUT) Log.v(TAG,""String_Node_Str"" + nextKeyTime + ""String_Node_Str""+ curTime);
if (curTime < nextKeyTime) {
continue;
}
lastKeyTime=nextKeyTime;
nextKeyTime=nextKeyTime + KEY_REPEAT_DELAY;
keyRepeatCount++;
if (DEBUG_INPUT) Log.v(TAG,""String_Node_Str"" + keyRepeatCount + ""String_Node_Str""+ nextKeyTime);
KeyEvent newEvent;
if (downTime != 0 && (downTime + ViewConfiguration.getLongPressTimeout()) <= curTime) {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount,lastKey.getFlags() | KeyEvent.FLAG_LONG_PRESS);
downTime=0;
}
 else {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount);
}
dispatchKey(newEvent,0,0);
}
 else {
curTime=SystemClock.uptimeMillis();
lastKeyTime=curTime;
nextKeyTime=curTime + LONG_WAIT;
}
}
 catch (Exception e) {
Log.e(TAG,""String_Node_Str"" + e,e);
}
}
}",0.9893832756769652
182820,"/** 
 * {@inheritDoc} 
 */
public int interceptKeyTq(RawInputEvent event,boolean screenIsOn){
  int result=ACTION_PASS_TO_USER;
  final boolean isWakeKey=isWakeKeyTq(event);
  final boolean keyguardShowing=keyguardIsShowingTq();
  if (false) {
    Log.d(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ event.keycode+ ""String_Node_Str""+ screenIsOn+ ""String_Node_Str""+ keyguardShowing);
  }
  if (keyguardShowing) {
    if (screenIsOn) {
      result|=ACTION_PASS_TO_USER;
    }
 else {
      result&=~ACTION_PASS_TO_USER;
      final boolean isKeyDown=(event.type == RawInputEvent.EV_KEY) && (event.value != 0);
      if (isWakeKey && isKeyDown) {
        if (!mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(event.keycode) && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
          if (isInCall()) {
            mKeyguardMediator.pokeWakelock();
          }
 else           if (isMusicActive()) {
            handleVolumeKey(AudioManager.STREAM_MUSIC,event.keycode);
          }
        }
      }
    }
  }
 else   if (!screenIsOn) {
    if (isInCall() && event.type == RawInputEvent.EV_KEY && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
      result&=~ACTION_PASS_TO_USER;
      handleVolumeKey(AudioManager.STREAM_VOICE_CALL,event.keycode);
    }
    if (isWakeKey) {
      result|=ACTION_POKE_USER_ACTIVITY;
      result&=~ACTION_PASS_TO_USER;
    }
  }
  int type=event.type;
  int code=event.keycode;
  boolean down=event.value != 0;
  if (type == RawInputEvent.EV_KEY) {
    if (code == KeyEvent.KEYCODE_ENDCALL || code == KeyEvent.KEYCODE_POWER) {
      if (down) {
        boolean handled=false;
        ITelephony phoneServ=getPhoneInterface();
        if (phoneServ != null) {
          try {
            if (code == KeyEvent.KEYCODE_ENDCALL) {
              handled=phoneServ.endCall();
            }
 else             if (code == KeyEvent.KEYCODE_POWER && phoneServ.isRinging()) {
              phoneServ.silenceRinger();
              handled=true;
            }
          }
 catch (          RemoteException ex) {
            Log.w(TAG,""String_Node_Str"" + ex);
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if ((handled && code != KeyEvent.KEYCODE_POWER) || !screenIsOn) {
          mShouldTurnOffOnKeyUp=false;
        }
 else {
          mShouldTurnOffOnKeyUp=true;
          mHandler.postDelayed(mPowerLongPress,ViewConfiguration.getGlobalActionKeyTimeout());
          result&=~ACTION_PASS_TO_USER;
        }
      }
 else {
        mHandler.removeCallbacks(mPowerLongPress);
        if (mShouldTurnOffOnKeyUp) {
          mShouldTurnOffOnKeyUp=false;
          boolean gohome=(mEndcallBehavior & ENDCALL_HOME) != 0;
          boolean sleeps=(mEndcallBehavior & ENDCALL_SLEEPS) != 0;
          if (keyguardShowing || (sleeps && !gohome) || (gohome && !goHome() && sleeps)) {
            Log.d(TAG,""String_Node_Str"" + Integer.toHexString(mEndcallBehavior));
            result&=~ACTION_POKE_USER_ACTIVITY;
            result|=ACTION_GO_TO_SLEEP;
          }
          result&=~ACTION_PASS_TO_USER;
        }
      }
    }
 else     if (isMediaKey(code)) {
      if ((result & ACTION_PASS_TO_USER) == 0) {
        KeyEvent keyEvent=new KeyEvent(event.when,event.when,down ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP,code,0);
        mBroadcastWakeLock.acquire();
        mHandler.post(new PassHeadsetKey(keyEvent));
      }
    }
 else     if (code == KeyEvent.KEYCODE_CALL) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.answerRingingCall();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
 else     if ((code == KeyEvent.KEYCODE_VOLUME_UP) || (code == KeyEvent.KEYCODE_VOLUME_DOWN)) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.silenceRinger();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
  }
  return result;
}","/** 
 * {@inheritDoc} 
 */
public int interceptKeyTq(RawInputEvent event,boolean screenIsOn){
  int result=ACTION_PASS_TO_USER;
  final boolean isWakeKey=isWakeKeyTq(event);
  final boolean keyguardActive=(screenIsOn ? mKeyguardMediator.isShowingAndNotHidden() : mKeyguardMediator.isShowing());
  if (false) {
    Log.d(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ event.keycode+ ""String_Node_Str""+ screenIsOn+ ""String_Node_Str""+ keyguardActive);
  }
  if (keyguardActive) {
    if (screenIsOn) {
      result|=ACTION_PASS_TO_USER;
    }
 else {
      result&=~ACTION_PASS_TO_USER;
      final boolean isKeyDown=(event.type == RawInputEvent.EV_KEY) && (event.value != 0);
      if (isWakeKey && isKeyDown) {
        if (!mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(event.keycode) && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
          if (isInCall()) {
            mKeyguardMediator.pokeWakelock();
          }
 else           if (isMusicActive()) {
            handleVolumeKey(AudioManager.STREAM_MUSIC,event.keycode);
          }
        }
      }
    }
  }
 else   if (!screenIsOn) {
    if (isInCall() && event.type == RawInputEvent.EV_KEY && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
      result&=~ACTION_PASS_TO_USER;
      handleVolumeKey(AudioManager.STREAM_VOICE_CALL,event.keycode);
    }
    if (isWakeKey) {
      result|=ACTION_POKE_USER_ACTIVITY;
      result&=~ACTION_PASS_TO_USER;
    }
  }
  int type=event.type;
  int code=event.keycode;
  boolean down=event.value != 0;
  if (type == RawInputEvent.EV_KEY) {
    if (code == KeyEvent.KEYCODE_ENDCALL || code == KeyEvent.KEYCODE_POWER) {
      if (down) {
        boolean handled=false;
        ITelephony phoneServ=getPhoneInterface();
        if (phoneServ != null) {
          try {
            if (code == KeyEvent.KEYCODE_ENDCALL) {
              handled=phoneServ.endCall();
            }
 else             if (code == KeyEvent.KEYCODE_POWER && phoneServ.isRinging()) {
              phoneServ.silenceRinger();
              handled=true;
            }
          }
 catch (          RemoteException ex) {
            Log.w(TAG,""String_Node_Str"" + ex);
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if ((handled && code != KeyEvent.KEYCODE_POWER) || !screenIsOn) {
          mShouldTurnOffOnKeyUp=false;
        }
 else {
          mShouldTurnOffOnKeyUp=true;
          mHandler.postDelayed(mPowerLongPress,ViewConfiguration.getGlobalActionKeyTimeout());
          result&=~ACTION_PASS_TO_USER;
        }
      }
 else {
        mHandler.removeCallbacks(mPowerLongPress);
        if (mShouldTurnOffOnKeyUp) {
          mShouldTurnOffOnKeyUp=false;
          boolean gohome=(mEndcallBehavior & ENDCALL_HOME) != 0;
          boolean sleeps=(mEndcallBehavior & ENDCALL_SLEEPS) != 0;
          if (keyguardActive || (sleeps && !gohome) || (gohome && !goHome() && sleeps)) {
            Log.d(TAG,""String_Node_Str"" + Integer.toHexString(mEndcallBehavior));
            result&=~ACTION_POKE_USER_ACTIVITY;
            result|=ACTION_GO_TO_SLEEP;
          }
          result&=~ACTION_PASS_TO_USER;
        }
      }
    }
 else     if (isMediaKey(code)) {
      if ((result & ACTION_PASS_TO_USER) == 0) {
        KeyEvent keyEvent=new KeyEvent(event.when,event.when,down ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP,code,0);
        mBroadcastWakeLock.acquire();
        mHandler.post(new PassHeadsetKey(keyEvent));
      }
    }
 else     if (code == KeyEvent.KEYCODE_CALL) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.answerRingingCall();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
 else     if ((code == KeyEvent.KEYCODE_VOLUME_UP) || (code == KeyEvent.KEYCODE_VOLUME_DOWN)) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.silenceRinger();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
  }
  return result;
}",0.9861302276336686
182821,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (SDK_VERSION > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,SDK_VERSION);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(SDK_CODENAME)) {
            if (SDK_CODENAME != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ SDK_CODENAME+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > SDK_VERSION) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ SDK_VERSION+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(SDK_CODENAME)) {
            if (SDK_CODENAME != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ SDK_CODENAME+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < SDK_VERSION) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ SDK_VERSION+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (SDK_VERSION > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(SDK_CODENAME)) {
            if (SDK_CODENAME != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ SDK_CODENAME+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > SDK_VERSION) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ SDK_VERSION+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(SDK_CODENAME)) {
            if (SDK_CODENAME != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ SDK_CODENAME+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}",0.9856262833675564
182822,"void logTimeStat(String sql,long beginNanos){
  int samplePercent;
  long nanos=Debug.threadCpuTimeNanos() - beginNanos;
  if (nanos >= QUERY_LOG_TIME_IN_NANOS) {
    samplePercent=100;
  }
 else {
    samplePercent=(int)(100 * nanos / QUERY_LOG_TIME_IN_NANOS) + 1;
    if (mRandom.nextInt(100) < samplePercent)     return;
  }
  if (sql.length() > QUERY_LOG_SQL_LENGTH)   sql=sql.substring(0,QUERY_LOG_SQL_LENGTH);
  String blockingPackage=ActivityThread.currentPackageName();
  if (blockingPackage == null)   blockingPackage=""String_Node_Str"";
  int millis=(int)(nanos / 1000000);
  EventLog.writeEvent(EVENT_DB_OPERATION,mPath,sql,millis,blockingPackage,samplePercent);
}","void logTimeStat(String sql,long beginNanos){
  int samplePercent;
  long nanos=Debug.threadCpuTimeNanos() - beginNanos;
  if (nanos >= QUERY_LOG_TIME_IN_NANOS) {
    samplePercent=100;
  }
 else {
    samplePercent=(int)(100 * nanos / QUERY_LOG_TIME_IN_NANOS) + 1;
    if (mRandom.nextInt(100) >= samplePercent)     return;
  }
  if (sql.length() > QUERY_LOG_SQL_LENGTH)   sql=sql.substring(0,QUERY_LOG_SQL_LENGTH);
  String blockingPackage=ActivityThread.currentPackageName();
  if (blockingPackage == null)   blockingPackage=""String_Node_Str"";
  int millis=(int)(nanos / 1000000);
  EventLog.writeEvent(EVENT_DB_OPERATION,mPath,sql,millis,blockingPackage,samplePercent);
}",0.9977761304670126
182823,"NameValueCache(String versionSystemProperty,Uri uri){
  mVersionSystemProperty=versionSystemProperty;
  mUri=uri;
}","public NameValueCache(String versionSystemProperty,Uri uri){
  mVersionSystemProperty=versionSystemProperty;
  mUri=uri;
}",0.9704641350210972
182824,"public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.allDrawn=false;
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.waitingToHide=true;
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}",0.9586861688478316
182825,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}",0.9764267990074442
182826,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}",0.9764267990074442
182827,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}",0.9764267990074442
182828,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}",0.9764267990074442
182829,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}",0.9764267990074442
182830,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}",0.99906441165887
182831,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}",0.99906441165887
182832,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}",0.99906441165887
182833,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}",0.99906441165887
182834,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}",0.99906441165887
182835,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}",0.9766355140186916
182836,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}",0.2869565217391304
182837,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}",0.1812865497076023
182838,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}",0.8557213930348259
182839,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.9814241486068112
182840,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}",0.9766355140186916
182841,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}",0.2869565217391304
182842,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}",0.1812865497076023
182843,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}",0.8557213930348259
182844,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.9814241486068112
182845,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}",0.9766355140186916
182846,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}",0.2869565217391304
182847,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}",0.1812865497076023
182848,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}",0.8557213930348259
182849,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.9814241486068112
182850,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}",0.9766355140186916
182851,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}",0.2869565217391304
182852,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}",0.1812865497076023
182853,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}",0.8557213930348259
182854,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.9814241486068112
182855,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}",0.9766355140186916
182856,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}",0.2869565217391304
182857,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}",0.1812865497076023
182858,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}",0.8557213930348259
182859,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.9814241486068112
182860,"public void appendAndroidSpecificProperty(final String mimeType,ContentValues contentValues){
  List<String> rawValueList=new ArrayList<String>();
  rawValueList.add(mimeType);
  final List<String> columnNameList;
  if (!sAllowedAndroidPropertySet.contains(mimeType)) {
    return;
  }
  for (int i=1; i <= VCardConstants.MAX_DATA_COLUMN; i++) {
    String value=contentValues.getAsString(""String_Node_Str"" + i);
    if (value == null) {
      value=""String_Node_Str"";
    }
    rawValueList.add(value);
  }
  appendLineWithCharsetAndQPDetection(VCardConstants.PROPERTY_X_ANDROID_CUSTOM,rawValueList);
}","public void appendAndroidSpecificProperty(final String mimeType,ContentValues contentValues){
  if (!sAllowedAndroidPropertySet.contains(mimeType)) {
    return;
  }
  final List<String> rawValueList=new ArrayList<String>();
  for (int i=1; i <= VCardConstants.MAX_DATA_COLUMN; i++) {
    String value=contentValues.getAsString(""String_Node_Str"" + i);
    if (value == null) {
      value=""String_Node_Str"";
    }
    rawValueList.add(value);
  }
  boolean needCharset=(mShouldAppendCharsetParam && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValueList));
  boolean reallyUseQuotedPrintable=(mShouldUseQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValueList));
  mBuilder.append(VCardConstants.PROPERTY_X_ANDROID_CUSTOM);
  if (needCharset) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(mVCardCharsetParameter);
  }
  if (reallyUseQuotedPrintable) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(VCARD_PARAM_ENCODING_QP);
  }
  mBuilder.append(VCARD_DATA_SEPARATOR);
  mBuilder.append(mimeType);
  for (  String rawValue : rawValueList) {
    final String encodedValue;
    if (reallyUseQuotedPrintable) {
      encodedValue=encodeQuotedPrintable(rawValue);
    }
 else {
      encodedValue=escapeCharacters(rawValue);
    }
    mBuilder.append(VCARD_ITEM_SEPARATOR);
    mBuilder.append(encodedValue);
  }
  mBuilder.append(VCARD_END_OF_LINE);
}",0.4260178748758689
182861,"public void appendLine(final String propertyName,final List<String> parameterList,final List<String> rawValueList,final boolean needCharset,final boolean needQuotedPrintable){
  mBuilder.append(propertyName);
  if (parameterList != null && parameterList.size() > 0) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    appendTypeParameters(parameterList);
  }
  if (needCharset) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(mVCardCharsetParameter);
  }
  mBuilder.append(VCARD_DATA_SEPARATOR);
  boolean first=true;
  for (  String rawValue : rawValueList) {
    final String encodedValue;
    if (needQuotedPrintable) {
      mBuilder.append(VCARD_PARAM_SEPARATOR);
      mBuilder.append(VCARD_PARAM_ENCODING_QP);
      encodedValue=encodeQuotedPrintable(rawValue);
    }
 else {
      encodedValue=escapeCharacters(rawValue);
    }
    if (first) {
      first=false;
    }
 else {
      mBuilder.append(VCARD_ITEM_SEPARATOR);
    }
    mBuilder.append(encodedValue);
  }
  mBuilder.append(VCARD_END_OF_LINE);
}","public void appendLine(final String propertyName,final List<String> parameterList,final List<String> rawValueList,final boolean needCharset,final boolean needQuotedPrintable){
  mBuilder.append(propertyName);
  if (parameterList != null && parameterList.size() > 0) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    appendTypeParameters(parameterList);
  }
  if (needCharset) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(mVCardCharsetParameter);
  }
  if (needQuotedPrintable) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(VCARD_PARAM_ENCODING_QP);
  }
  mBuilder.append(VCARD_DATA_SEPARATOR);
  boolean first=true;
  for (  String rawValue : rawValueList) {
    final String encodedValue;
    if (needQuotedPrintable) {
      encodedValue=encodeQuotedPrintable(rawValue);
    }
 else {
      encodedValue=escapeCharacters(rawValue);
    }
    if (first) {
      first=false;
    }
 else {
      mBuilder.append(VCARD_ITEM_SEPARATOR);
    }
    mBuilder.append(encodedValue);
  }
  mBuilder.append(VCARD_END_OF_LINE);
}",0.8149210903873745
182862,"public void appendLineWithCharsetAndQPDetection(final String propertyName,final List<String> parameterList,final List<String> rawValueList){
  boolean needCharset=false;
  boolean reallyUseQuotedPrintable=false;
  for (  String rawValue : rawValueList) {
    if (!needCharset && mShouldUseQuotedPrintable && !VCardUtils.containsOnlyPrintableAscii(rawValue)) {
      needCharset=true;
    }
    if (!reallyUseQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValue)) {
      reallyUseQuotedPrintable=true;
    }
    if (needCharset && reallyUseQuotedPrintable) {
      break;
    }
  }
  appendLine(propertyName,parameterList,rawValueList,needCharset,reallyUseQuotedPrintable);
}","public void appendLineWithCharsetAndQPDetection(final String propertyName,final List<String> parameterList,final List<String> rawValueList){
  boolean needCharset=(mShouldAppendCharsetParam && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValueList));
  boolean reallyUseQuotedPrintable=(mShouldUseQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValueList));
  appendLine(propertyName,parameterList,rawValueList,needCharset,reallyUseQuotedPrintable);
}",0.5858240819812126
182863,"/** 
 * TODO: Merge detector and parser mode.
 */
public VCardParser_V21(int parseType){
  super(parseType);
  if (parseType == VCardConfig.PARSE_TYPE_FOMA) {
    mNestCount=1;
  }
}","public VCardParser_V21(int parseType){
  super(parseType);
  if (parseType == VCardConfig.PARSE_TYPE_FOMA) {
    mNestCount=1;
  }
}",0.8407643312101911
182864,"public static boolean containsOnlyPrintableAscii(final String... values){
  if (values == null) {
    return true;
  }
  final int asciiFirst=0x20;
  final int asciiLast=0x7E;
  for (  final String value : values) {
    if (TextUtils.isEmpty(value)) {
      continue;
    }
    final int length=value.length();
    for (int i=0; i < length; i=value.offsetByCodePoints(i,1)) {
      final int c=value.codePointAt(i);
      if (!((asciiFirst <= c && c <= asciiLast) || c == '\r' || c == '\n')) {
        return false;
      }
    }
  }
  return true;
}","public static boolean containsOnlyPrintableAscii(final Collection<String> values){
  if (values == null) {
    return true;
  }
  final int asciiFirst=0x20;
  final int asciiLast=0x7E;
  for (  final String value : values) {
    if (TextUtils.isEmpty(value)) {
      continue;
    }
    final int length=value.length();
    for (int i=0; i < length; i=value.offsetByCodePoints(i,1)) {
      final int c=value.codePointAt(i);
      if (!((asciiFirst <= c && c <= asciiLast) || c == '\r' || c == '\n')) {
        return false;
      }
    }
  }
  return true;
}",0.9864743011722272
182865,"/** 
 * This is useful since vCard 3.0 often requires the (""X-"") properties and groups should contain only alphabets, digits, and hyphen. Note: It is already known some devices (wrongly) outputs properties with characters which should not be in the field. One example is ""X-GOOGLE TALK"". We accept such kind of input but must never output it unless the target is very specific to the device which is able to parse the malformed input. 
 */
public static boolean containsOnlyAlphaDigitHyphen(final String... values){
  if (values == null) {
    return true;
  }
  final int upperAlphabetFirst=0x41;
  final int upperAlphabetAfterLast=0x5b;
  final int lowerAlphabetFirst=0x61;
  final int lowerAlphabetAfterLast=0x7b;
  final int digitFirst=0x30;
  final int digitAfterLast=0x3A;
  final int hyphen='-';
  for (  final String str : values) {
    if (TextUtils.isEmpty(str)) {
      continue;
    }
    final int length=str.length();
    for (int i=0; i < length; i=str.offsetByCodePoints(i,1)) {
      int codepoint=str.codePointAt(i);
      if (!((lowerAlphabetFirst <= codepoint && codepoint < lowerAlphabetAfterLast) || (upperAlphabetFirst <= codepoint && codepoint < upperAlphabetAfterLast) || (digitFirst <= codepoint && codepoint < digitAfterLast)|| (codepoint == hyphen))) {
        return false;
      }
    }
  }
  return true;
}","public static boolean containsOnlyAlphaDigitHyphen(final Collection<String> values){
  if (values == null) {
    return true;
  }
  final int upperAlphabetFirst=0x41;
  final int upperAlphabetAfterLast=0x5b;
  final int lowerAlphabetFirst=0x61;
  final int lowerAlphabetAfterLast=0x7b;
  final int digitFirst=0x30;
  final int digitAfterLast=0x3A;
  final int hyphen='-';
  for (  final String str : values) {
    if (TextUtils.isEmpty(str)) {
      continue;
    }
    final int length=str.length();
    for (int i=0; i < length; i=str.offsetByCodePoints(i,1)) {
      int codepoint=str.codePointAt(i);
      if (!((lowerAlphabetFirst <= codepoint && codepoint < lowerAlphabetAfterLast) || (upperAlphabetFirst <= codepoint && codepoint < upperAlphabetAfterLast) || (digitFirst <= codepoint && codepoint < digitAfterLast)|| (codepoint == hyphen))) {
        return false;
      }
    }
  }
  return true;
}",0.797146678555506
182866,"/** 
 * This is useful when checking the string should be encoded into quoted-printable or not, which is required by vCard 2.1. See the definition of ""7bit"" in vCard 2.1 spec for more information.
 */
public static boolean containsOnlyNonCrLfPrintableAscii(final String... values){
  if (values == null) {
    return true;
  }
  final int asciiFirst=0x20;
  final int asciiLast=0x7E;
  for (  final String value : values) {
    if (TextUtils.isEmpty(value)) {
      continue;
    }
    final int length=value.length();
    for (int i=0; i < length; i=value.offsetByCodePoints(i,1)) {
      final int c=value.codePointAt(i);
      if (!(asciiFirst <= c && c <= asciiLast)) {
        return false;
      }
    }
  }
  return true;
}","public static boolean containsOnlyNonCrLfPrintableAscii(final Collection<String> values){
  if (values == null) {
    return true;
  }
  final int asciiFirst=0x20;
  final int asciiLast=0x7E;
  for (  final String value : values) {
    if (TextUtils.isEmpty(value)) {
      continue;
    }
    final int length=value.length();
    for (int i=0; i < length; i=value.offsetByCodePoints(i,1)) {
      final int c=value.codePointAt(i);
      if (!(asciiFirst <= c && c <= asciiLast)) {
        return false;
      }
    }
  }
  return true;
}",0.8296529968454258
182867,"public void testContainsOnlyNonCrLfPrintableAscii(){
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((String)null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((String[])null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  StringBuilder builder=new StringBuilder();
  for (int i=0x20; i < 0x7F; i++) {
    builder.append((char)i);
  }
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(builder.toString()));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
}","public void testContainsOnlyNonCrLfPrintableAscii(){
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((String)null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((String[])null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((List<String>)null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  StringBuilder builder=new StringBuilder();
  for (int i=0x20; i < 0x7F; i++) {
    builder.append((char)i);
  }
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(builder.toString()));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
}",0.9597989949748744
182868,"public void testContainsOnlyAlphaDigitHyphen(){
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((String)null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((String[])null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  for (int i=0; i < 0x30; i++) {
    if (i == 0x2D) {
      continue;
    }
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x3A; i < 0x41; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x5B; i < 0x61; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x7B; i < 0x100; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
}","public void testContainsOnlyAlphaDigitHyphen(){
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((String)null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((String[])null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((List<String>)null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  for (int i=0; i < 0x30; i++) {
    if (i == 0x2D) {
      continue;
    }
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x3A; i < 0x41; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x5B; i < 0x61; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x7B; i < 0x100; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
}",0.9649696403549743
182869,"public void testContainsOnlyPrintableAscii(){
  assertTrue(VCardUtils.containsOnlyPrintableAscii((String)null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii((String[])null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  StringBuilder builder=new StringBuilder();
  for (int i=0x20; i < 0x7F; i++) {
    builder.append((char)i);
  }
  assertTrue(VCardUtils.containsOnlyPrintableAscii(builder.toString()));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
}","public void testContainsOnlyPrintableAscii(){
  assertTrue(VCardUtils.containsOnlyPrintableAscii((String)null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii((String[])null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii((List<String>)null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  StringBuilder builder=new StringBuilder();
  for (int i=0x20; i < 0x7F; i++) {
    builder.append((char)i);
  }
  assertTrue(VCardUtils.containsOnlyPrintableAscii(builder.toString()));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
}",0.956573468173706
182870,"private synchronized final void sendIntent(){
  Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  int state=0;
  int microphone=0;
  if ((mHeadsetState & BIT_HEADSET) != (mPrevHeadsetState & BIT_HEADSET)) {
    microphone=1;
    if ((mHeadsetState & BIT_HEADSET) != 0) {
      state=1;
    }
  }
 else   if ((mHeadsetState & BIT_HEADSET_NO_MIC) != (mPrevHeadsetState & BIT_HEADSET_NO_MIC)) {
    if ((mHeadsetState & BIT_HEADSET_NO_MIC) != 0) {
      state=1;
    }
  }
  intent.putExtra(""String_Node_Str"",state);
  intent.putExtra(""String_Node_Str"",mHeadsetName);
  intent.putExtra(""String_Node_Str"",microphone);
  ActivityManagerNative.broadcastStickyIntent(intent,null);
}","private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}",0.6603518267929634
182871,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntent();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}",0.9965870307167236
182872,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & (BIT_HEADSET | BIT_HEADSET_NO_MIC);
  if (headsetState != mHeadsetState) {
    boolean isUnplug=false;
    if (((mHeadsetState & BIT_HEADSET) != 0 && (headsetState & BIT_HEADSET) == 0) || ((mHeadsetState & BIT_HEADSET_NO_MIC) != 0 && (headsetState & BIT_HEADSET_NO_MIC) == 0)) {
      isUnplug=true;
    }
    mHeadsetName=newName;
    mPrevHeadsetState=mHeadsetState;
    mHeadsetState=headsetState;
    mPendingIntent=true;
    if (isUnplug) {
      Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
      mContext.sendBroadcast(intent);
      mWakeLock.acquire();
      mHandler.sendEmptyMessageDelayed(0,1000);
    }
 else {
      sendIntent();
      mPendingIntent=false;
    }
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}",0.5187239944521498
182873,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}",0.9745762711864406
182874,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}",0.9464285714285714
182875,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}",0.9813084112149532
182876,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}",0.9923761118170268
182877,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}",0.9243306169965076
182878,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}",0.9745762711864406
182879,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}",0.9464285714285714
182880,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}",0.9813084112149532
182881,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}",0.9923761118170268
182882,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}",0.9243306169965076
182883,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}",0.9745762711864406
182884,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}",0.9464285714285714
182885,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}",0.9813084112149532
182886,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}",0.9923761118170268
182887,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}",0.9243306169965076
182888,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}",0.9745762711864406
182889,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}",0.9464285714285714
182890,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}",0.9813084112149532
182891,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}",0.9923761118170268
182892,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}",0.9243306169965076
182893,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9929309407286568
182894,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9929309407286568
182895,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}",0.9745762711864406
182896,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}",0.9464285714285714
182897,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}",0.9813084112149532
182898,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}",0.9923761118170268
182899,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}",0.9243306169965076
182900,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9929309407286568
182901,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9929309407286568
182902,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9929309407286568
182903,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}",0.9913151364764268
182904,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}",0.9986383971989884
182905,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}",0.9879518072289156
182906,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}",0.9951422623178348
182907,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}",0.9913151364764268
182908,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}",0.9986383971989884
182909,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}",0.9879518072289156
182910,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}",0.9951422623178348
182911,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}",0.9913151364764268
182912,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}",0.9986383971989884
182913,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}",0.9879518072289156
182914,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}",0.9951422623178348
182915,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}",0.9913151364764268
182916,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}",0.9986383971989884
182917,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}",0.9879518072289156
182918,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}",0.9951422623178348
182919,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}",0.9913151364764268
182920,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}",0.9986383971989884
182921,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}",0.9879518072289156
182922,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}",0.9951422623178348
182923,"/** 
 * Formats the data into a values array suitable for use with the Media Content Provider.
 * @return a map of values
 */
private ContentValues toValues(){
  ContentValues map=new ContentValues();
  map.put(MediaStore.MediaColumns.DATA,mPath);
  map.put(MediaStore.MediaColumns.TITLE,mTitle);
  map.put(MediaStore.MediaColumns.DATE_MODIFIED,mLastModified);
  map.put(MediaStore.MediaColumns.SIZE,mFileSize);
  map.put(MediaStore.MediaColumns.MIME_TYPE,mMimeType);
  if (MediaFile.isVideoFileType(mFileType)) {
    map.put(Video.Media.ARTIST,(mArtist != null && mArtist.length() > 0 ? mArtist : MediaFile.UNKNOWN_STRING));
    map.put(Video.Media.ALBUM,(mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaFile.UNKNOWN_STRING));
    map.put(Video.Media.DURATION,mDuration);
  }
 else   if (MediaFile.isImageFileType(mFileType)) {
  }
 else   if (MediaFile.isAudioFileType(mFileType)) {
    map.put(Audio.Media.ARTIST,(mArtist != null && mArtist.length() > 0 ? mArtist : MediaFile.UNKNOWN_STRING));
    map.put(Audio.Media.ALBUM,(mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaFile.UNKNOWN_STRING));
    map.put(Audio.Media.COMPOSER,mComposer);
    if (mYear != 0) {
      map.put(Audio.Media.YEAR,mYear);
    }
    map.put(Audio.Media.TRACK,mTrack);
    map.put(Audio.Media.DURATION,mDuration);
  }
  return map;
}","/** 
 * Formats the data into a values array suitable for use with the Media Content Provider.
 * @return a map of values
 */
private ContentValues toValues(){
  ContentValues map=new ContentValues();
  map.put(MediaStore.MediaColumns.DATA,mPath);
  map.put(MediaStore.MediaColumns.TITLE,mTitle);
  map.put(MediaStore.MediaColumns.DATE_MODIFIED,mLastModified);
  map.put(MediaStore.MediaColumns.SIZE,mFileSize);
  map.put(MediaStore.MediaColumns.MIME_TYPE,mMimeType);
  if (MediaFile.isVideoFileType(mFileType)) {
    map.put(Video.Media.ARTIST,(mArtist != null && mArtist.length() > 0 ? mArtist : MediaFile.UNKNOWN_STRING));
    map.put(Video.Media.ALBUM,(mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaFile.UNKNOWN_STRING));
    map.put(Video.Media.DURATION,mDuration);
    map.put(Video.Media.DATE_TAKEN,mLastModified);
  }
 else   if (MediaFile.isImageFileType(mFileType)) {
    map.put(Images.Media.DATE_TAKEN,mLastModified);
  }
 else   if (MediaFile.isAudioFileType(mFileType)) {
    map.put(Audio.Media.ARTIST,(mArtist != null && mArtist.length() > 0 ? mArtist : MediaFile.UNKNOWN_STRING));
    map.put(Audio.Media.ALBUM,(mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaFile.UNKNOWN_STRING));
    map.put(Audio.Media.COMPOSER,mComposer);
    if (mYear != 0) {
      map.put(Audio.Media.YEAR,mYear);
    }
    map.put(Audio.Media.TRACK,mTrack);
    map.put(Audio.Media.DURATION,mDuration);
  }
  return map;
}",0.9626134301270416
182924,"/** 
 * Some Japanese mobile phones use this field for phonetic name, since vCard 2.1 does not have ""SORT-STRING"" type. Also, in some cases, the field has some ';'s in it. Assume the ';' means the same meaning in N property
 */
@SuppressWarnings(""String_Node_Str"") private void handlePhoneticNameFromSound(List<String> elems){
  int size;
  if (elems == null || (size=elems.size()) < 1) {
    return;
  }
  if (size > 3) {
    size=3;
  }
switch (size) {
case 3:
    mPhoneticMiddleName=elems.get(2);
case 2:
  mPhoneticGivenName=elems.get(1);
default :
mPhoneticFamilyName=elems.get(0);
}
}","/** 
 * Some Japanese mobile phones use this field for phonetic name, since vCard 2.1 does not have ""SORT-STRING"" type. Also, in some cases, the field has some ';'s in it. Assume the ';' means the same meaning in N property
 */
@SuppressWarnings(""String_Node_Str"") private void handlePhoneticNameFromSound(List<String> elems){
  if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticMiddleName) && TextUtils.isEmpty(mPhoneticGivenName))) {
    return;
  }
  int size;
  if (elems == null || (size=elems.size()) < 1) {
    return;
  }
  if (size > 3) {
    size=3;
  }
  if (elems.get(0).length() > 0) {
    boolean onlyFirstElemIsNonEmpty=true;
    for (int i=1; i < size; i++) {
      if (elems.get(i).length() > 0) {
        onlyFirstElemIsNonEmpty=false;
        break;
      }
    }
    if (onlyFirstElemIsNonEmpty) {
      final String[] namesArray=elems.get(0).split(""String_Node_Str"");
      final int nameArrayLength=namesArray.length;
      if (nameArrayLength == 3) {
        mPhoneticFamilyName=namesArray[0];
        mPhoneticMiddleName=namesArray[1];
        mPhoneticGivenName=namesArray[2];
      }
 else       if (nameArrayLength == 2) {
        mPhoneticFamilyName=namesArray[0];
        mPhoneticGivenName=namesArray[1];
      }
 else {
        mPhoneticFullName=elems.get(0);
      }
      return;
    }
  }
switch (size) {
case 3:
    mPhoneticMiddleName=elems.get(2);
case 2:
  mPhoneticGivenName=elems.get(1);
default :
mPhoneticFamilyName=elems.get(0);
}
}",0.5652797704447633
182925,"/** 
 * Construct the display name. The constructed data must not be null.
 */
private void constructDisplayName(){
  if (!TextUtils.isEmpty(mFullName)) {
    mDisplayName=mFullName;
  }
 else   if (!(TextUtils.isEmpty(mFamilyName) && TextUtils.isEmpty(mGivenName))) {
    StringBuilder builder=new StringBuilder();
    List<String> nameList;
switch (VCardConfig.getNameOrderType(mVCardType)) {
case VCardConfig.NAME_ORDER_JAPANESE:
      if (VCardUtils.containsOnlyPrintableAscii(mFamilyName) && VCardUtils.containsOnlyPrintableAscii(mGivenName)) {
        nameList=Arrays.asList(mPrefix,mGivenName,mMiddleName,mFamilyName,mSuffix);
      }
 else {
        nameList=Arrays.asList(mPrefix,mFamilyName,mMiddleName,mGivenName,mSuffix);
      }
    break;
case VCardConfig.NAME_ORDER_EUROPE:
  nameList=Arrays.asList(mPrefix,mMiddleName,mGivenName,mFamilyName,mSuffix);
break;
default :
nameList=Arrays.asList(mPrefix,mGivenName,mMiddleName,mFamilyName,mSuffix);
break;
}
boolean first=true;
for (String namePart : nameList) {
if (!TextUtils.isEmpty(namePart)) {
if (first) {
first=false;
}
 else {
builder.append(' ');
}
builder.append(namePart);
}
}
mDisplayName=builder.toString();
}
 else if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticGivenName))) {
mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mPhoneticFamilyName,mPhoneticMiddleName,mPhoneticGivenName);
}
 else if (mEmailList != null && mEmailList.size() > 0) {
mDisplayName=mEmailList.get(0).data;
}
 else if (mPhoneList != null && mPhoneList.size() > 0) {
mDisplayName=mPhoneList.get(0).data;
}
 else if (mPostalList != null && mPostalList.size() > 0) {
mDisplayName=mPostalList.get(0).getFormattedAddress(mVCardType);
}
if (mDisplayName == null) {
mDisplayName=""String_Node_Str"";
}
}","/** 
 * Construct the display name. The constructed data must not be null.
 */
private void constructDisplayName(){
  if (!TextUtils.isEmpty(mFullName)) {
    mDisplayName=mFullName;
  }
 else   if (!(TextUtils.isEmpty(mFamilyName) && TextUtils.isEmpty(mGivenName))) {
    mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mFamilyName,mMiddleName,mGivenName,mPrefix,mSuffix);
  }
 else   if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticGivenName))) {
    mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mPhoneticFamilyName,mPhoneticMiddleName,mPhoneticGivenName);
  }
 else   if (mEmailList != null && mEmailList.size() > 0) {
    mDisplayName=mEmailList.get(0).data;
  }
 else   if (mPhoneList != null && mPhoneList.size() > 0) {
    mDisplayName=mPhoneList.get(0).data;
  }
 else   if (mPostalList != null && mPostalList.size() > 0) {
    mDisplayName=mPostalList.get(0).getFormattedAddress(mVCardType);
  }
  if (mDisplayName == null) {
    mDisplayName=""String_Node_Str"";
  }
}",0.260560880369187
182926,"/** 
 * Returns true when the property line should contain charset parameter information. This method may return true even when vCard version is 3.0. Strictly, adding charset information is invalid in VCard 3.0. However we'll add the info only when charset we use is not UTF-8 in vCard 3.0 format, since parser side may be able to use the charset via this field, though we may encounter another problem by adding it. e.g. Japanese mobile phones use Shift_Jis while RFC 2426 recommends UTF-8. By adding this field, parsers may be able to know this text is NOT UTF-8 but Shift_Jis.
 */
private boolean shouldAppendCharsetParameter(final String propertyValue){
  return (!VCardUtils.containsOnlyPrintableAscii(propertyValue) && (!mIsV30 || !mUsesUtf8));
}","/** 
 * Returns true when the property line should contain charset parameter information. This method may return true even when vCard version is 3.0. Strictly, adding charset information is invalid in VCard 3.0. However we'll add the info only when charset we use is not UTF-8 in vCard 3.0 format, since parser side may be able to use the charset via this field, though we may encounter another problem by adding it. e.g. Japanese mobile phones use Shift_Jis while RFC 2426 recommends UTF-8. By adding this field, parsers may be able to know this text is NOT UTF-8 but Shift_Jis.
 */
private boolean shouldAppendCharsetParameter(final String propertyValue){
  return (!(mIsV30 && mUsesUtf8) && !VCardUtils.containsOnlyPrintableAscii(propertyValue));
}",0.9115103127079176
182927,"private boolean containsNonEmptyName(ContentValues contentValues){
  final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=contentValues.getAsString(StructuredName.PREFIX);
  final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
  return !(TextUtils.isEmpty(familyName) && TextUtils.isEmpty(middleName) && TextUtils.isEmpty(givenName)&& TextUtils.isEmpty(prefix)&& TextUtils.isEmpty(suffix)&& TextUtils.isEmpty(displayName));
}","private boolean containsNonEmptyName(ContentValues contentValues){
  final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=contentValues.getAsString(StructuredName.PREFIX);
  final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
  final String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
  final String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
  final String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
  final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
  return !(TextUtils.isEmpty(familyName) && TextUtils.isEmpty(middleName) && TextUtils.isEmpty(givenName)&& TextUtils.isEmpty(prefix)&& TextUtils.isEmpty(suffix)&& TextUtils.isEmpty(phoneticFamilyName)&& TextUtils.isEmpty(phoneticMiddleName)&& TextUtils.isEmpty(phoneticGivenName)&& TextUtils.isEmpty(displayName));
}",0.7810335641981886
182928,"private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  ContentValues primaryContentValues=null;
  ContentValues subprimaryContentValues=null;
  for (  ContentValues contentValues : contentValuesList) {
    if (contentValues == null) {
      continue;
    }
    Integer isSuperPrimary=contentValues.getAsInteger(StructuredName.IS_SUPER_PRIMARY);
    if (isSuperPrimary != null && isSuperPrimary > 0) {
      primaryContentValues=contentValues;
      break;
    }
 else     if (primaryContentValues == null) {
      Integer isPrimary=contentValues.getAsInteger(StructuredName.IS_PRIMARY);
      if (isPrimary != null && isPrimary > 0 && containsNonEmptyName(contentValues)) {
        primaryContentValues=contentValues;
      }
 else       if (subprimaryContentValues == null && containsNonEmptyName(contentValues)) {
        subprimaryContentValues=contentValues;
      }
    }
  }
  if (primaryContentValues == null) {
    if (subprimaryContentValues != null) {
      primaryContentValues=subprimaryContentValues;
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"");
      primaryContentValues=new ContentValues();
    }
  }
  final String familyName=primaryContentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=primaryContentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=primaryContentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=primaryContentValues.getAsString(StructuredName.PREFIX);
  final String suffix=primaryContentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=primaryContentValues.getAsString(StructuredName.DISPLAY_NAME);
  if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
    final boolean shouldAppendCharsetParameterToName=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameters(Arrays.asList(familyName,givenName,middleName,prefix,suffix));
    final boolean reallyUseQuotedPrintableToName=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
    final String formattedName;
    if (!TextUtils.isEmpty(displayName)) {
      formattedName=displayName;
    }
 else {
      formattedName=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),familyName,middleName,givenName,prefix,suffix);
    }
    final boolean shouldAppendCharsetParameterToFN=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameter(formattedName);
    final boolean reallyUseQuotedPrintableToFN=!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
    final String encodedFamily;
    final String encodedGiven;
    final String encodedMiddle;
    final String encodedPrefix;
    final String encodedSuffix;
    if (reallyUseQuotedPrintableToName) {
      encodedFamily=encodeQuotedPrintable(familyName);
      encodedGiven=encodeQuotedPrintable(givenName);
      encodedMiddle=encodeQuotedPrintable(middleName);
      encodedPrefix=encodeQuotedPrintable(prefix);
      encodedSuffix=encodeQuotedPrintable(suffix);
    }
 else {
      encodedFamily=escapeCharacters(familyName);
      encodedGiven=escapeCharacters(givenName);
      encodedMiddle=escapeCharacters(middleName);
      encodedPrefix=escapeCharacters(prefix);
      encodedSuffix=escapeCharacters(suffix);
    }
    final String encodedFormattedname=(reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
    builder.append(Constants.PROPERTY_N);
    if (mIsDoCoMo) {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(formattedName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
    }
 else {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
    }
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameterToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedFormattedname);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (!TextUtils.isEmpty(displayName)) {
    final boolean reallyUseQuotedPrintableToDisplayName=(!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
    final String encodedDisplayName=reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
    builder.append(Constants.PROPERTY_N);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToDisplayName) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
    if (mIsV30) {
      builder.append(Constants.PROPERTY_FN);
      if (shouldAppendCharsetParameter(displayName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedDisplayName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsV30) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
    appendVCardLine(builder,Constants.PROPERTY_FN,""String_Node_Str"");
  }
 else   if (mIsDoCoMo) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
  }
  final String phoneticFamilyName;
  final String phoneticMiddleName;
  final String phoneticGivenName;
{
    String tmpPhoneticFamilyName=primaryContentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String tmpPhoneticMiddleName=primaryContentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String tmpPhoneticGivenName=primaryContentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (mNeedsToConvertPhoneticString) {
      phoneticFamilyName=VCardUtils.toHalfWidthString(tmpPhoneticFamilyName);
      phoneticMiddleName=VCardUtils.toHalfWidthString(tmpPhoneticMiddleName);
      phoneticGivenName=VCardUtils.toHalfWidthString(tmpPhoneticGivenName);
    }
 else {
      phoneticFamilyName=tmpPhoneticFamilyName;
      phoneticMiddleName=tmpPhoneticMiddleName;
      phoneticGivenName=tmpPhoneticGivenName;
    }
  }
  if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
    if (mIsV30) {
      final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
      builder.append(Constants.PROPERTY_SORT_STRING);
      final String encodedSortString=escapeCharacters(sortString);
      if (shouldAppendCharsetParameter(encodedSortString)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedSortString);
      builder.append(VCARD_END_OF_LINE);
    }
 else     if (mIsJapaneseMobilePhone) {
      builder.append(Constants.PROPERTY_SOUND);
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(Constants.PARAM_TYPE_X_IRMC_N);
      boolean reallyUseQuotedPrintable=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName)));
      final String encodedPhoneticFamilyName;
      final String encodedPhoneticMiddleName;
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      if (shouldAppendCharsetParameters(Arrays.asList(encodedPhoneticFamilyName,encodedPhoneticMiddleName,encodedPhoneticGivenName))) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsDoCoMo) {
    builder.append(Constants.PROPERTY_SOUND);
    builder.append(VCARD_PARAM_SEPARATOR);
    builder.append(Constants.PARAM_TYPE_X_IRMC_N);
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
  }
  if (mUsesDefactProperty) {
    if (!TextUtils.isEmpty(phoneticGivenName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName);
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_FIRST_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticGivenName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticMiddleName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName);
      final String encodedPhoneticMiddleName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
      }
 else {
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_MIDDLE_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticMiddleName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticFamilyName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName);
      final String encodedPhoneticFamilyName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_LAST_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticFamilyName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
}","private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  ContentValues primaryContentValues=null;
  ContentValues subprimaryContentValues=null;
  for (  ContentValues contentValues : contentValuesList) {
    if (contentValues == null) {
      continue;
    }
    Integer isSuperPrimary=contentValues.getAsInteger(StructuredName.IS_SUPER_PRIMARY);
    if (isSuperPrimary != null && isSuperPrimary > 0) {
      primaryContentValues=contentValues;
      break;
    }
 else     if (primaryContentValues == null) {
      Integer isPrimary=contentValues.getAsInteger(StructuredName.IS_PRIMARY);
      if (isPrimary != null && isPrimary > 0 && containsNonEmptyName(contentValues)) {
        primaryContentValues=contentValues;
      }
 else       if (subprimaryContentValues == null && containsNonEmptyName(contentValues)) {
        subprimaryContentValues=contentValues;
      }
    }
  }
  if (primaryContentValues == null) {
    if (subprimaryContentValues != null) {
      primaryContentValues=subprimaryContentValues;
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"");
      primaryContentValues=new ContentValues();
    }
  }
  final String familyName=primaryContentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=primaryContentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=primaryContentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=primaryContentValues.getAsString(StructuredName.PREFIX);
  final String suffix=primaryContentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=primaryContentValues.getAsString(StructuredName.DISPLAY_NAME);
  if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
    final boolean shouldAppendCharsetParameterToName=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameters(Arrays.asList(familyName,givenName,middleName,prefix,suffix));
    final boolean reallyUseQuotedPrintableToName=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
    final String formattedName;
    if (!TextUtils.isEmpty(displayName)) {
      formattedName=displayName;
    }
 else {
      formattedName=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),familyName,middleName,givenName,prefix,suffix);
    }
    final boolean shouldAppendCharsetParameterToFN=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameter(formattedName);
    final boolean reallyUseQuotedPrintableToFN=!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
    final String encodedFamily;
    final String encodedGiven;
    final String encodedMiddle;
    final String encodedPrefix;
    final String encodedSuffix;
    if (reallyUseQuotedPrintableToName) {
      encodedFamily=encodeQuotedPrintable(familyName);
      encodedGiven=encodeQuotedPrintable(givenName);
      encodedMiddle=encodeQuotedPrintable(middleName);
      encodedPrefix=encodeQuotedPrintable(prefix);
      encodedSuffix=encodeQuotedPrintable(suffix);
    }
 else {
      encodedFamily=escapeCharacters(familyName);
      encodedGiven=escapeCharacters(givenName);
      encodedMiddle=escapeCharacters(middleName);
      encodedPrefix=escapeCharacters(prefix);
      encodedSuffix=escapeCharacters(suffix);
    }
    final String encodedFormattedname=(reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
    builder.append(Constants.PROPERTY_N);
    if (mIsDoCoMo) {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(formattedName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
    }
 else {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
    }
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameterToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedFormattedname);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (!TextUtils.isEmpty(displayName)) {
    final boolean reallyUseQuotedPrintableToDisplayName=(!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
    final String encodedDisplayName=reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
    builder.append(Constants.PROPERTY_N);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToDisplayName) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (mIsV30) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
    appendVCardLine(builder,Constants.PROPERTY_FN,""String_Node_Str"");
  }
 else   if (mIsDoCoMo) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
  }
  final String phoneticFamilyName;
  final String phoneticMiddleName;
  final String phoneticGivenName;
{
    String tmpPhoneticFamilyName=primaryContentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String tmpPhoneticMiddleName=primaryContentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String tmpPhoneticGivenName=primaryContentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (mNeedsToConvertPhoneticString) {
      phoneticFamilyName=VCardUtils.toHalfWidthString(tmpPhoneticFamilyName);
      phoneticMiddleName=VCardUtils.toHalfWidthString(tmpPhoneticMiddleName);
      phoneticGivenName=VCardUtils.toHalfWidthString(tmpPhoneticGivenName);
    }
 else {
      phoneticFamilyName=tmpPhoneticFamilyName;
      phoneticMiddleName=tmpPhoneticMiddleName;
      phoneticGivenName=tmpPhoneticGivenName;
    }
  }
  if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
    if (mIsV30) {
      final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
      builder.append(Constants.PROPERTY_SORT_STRING);
      if (shouldAppendCharsetParameter(sortString)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(sortString));
      builder.append(VCARD_END_OF_LINE);
    }
 else     if (mIsJapaneseMobilePhone) {
      builder.append(Constants.PROPERTY_SOUND);
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(Constants.PARAM_TYPE_X_IRMC_N);
      boolean reallyUseQuotedPrintable=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName)));
      final String encodedPhoneticFamilyName;
      final String encodedPhoneticMiddleName;
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      if (shouldAppendCharsetParameters(Arrays.asList(encodedPhoneticFamilyName,encodedPhoneticMiddleName,encodedPhoneticGivenName))) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
{
        boolean first=true;
        if (!TextUtils.isEmpty(encodedPhoneticFamilyName)) {
          builder.append(encodedPhoneticFamilyName);
          first=false;
        }
        if (!TextUtils.isEmpty(encodedPhoneticMiddleName)) {
          if (first) {
            first=false;
          }
 else {
            builder.append(' ');
          }
          builder.append(encodedPhoneticMiddleName);
        }
        if (!TextUtils.isEmpty(encodedPhoneticGivenName)) {
          if (!first) {
            builder.append(' ');
          }
          builder.append(encodedPhoneticGivenName);
        }
      }
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsDoCoMo) {
    builder.append(Constants.PROPERTY_SOUND);
    builder.append(VCARD_PARAM_SEPARATOR);
    builder.append(Constants.PARAM_TYPE_X_IRMC_N);
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
  }
  if (mUsesDefactProperty) {
    if (!TextUtils.isEmpty(phoneticGivenName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName));
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_FIRST_NAME);
      if (shouldAppendCharsetParameter(phoneticGivenName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticMiddleName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName));
      final String encodedPhoneticMiddleName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
      }
 else {
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_MIDDLE_NAME);
      if (shouldAppendCharsetParameter(phoneticMiddleName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticFamilyName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName));
      final String encodedPhoneticFamilyName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_LAST_NAME);
      if (shouldAppendCharsetParameter(phoneticFamilyName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
}",0.9343050048226342
182929,"public static boolean usesQuotedPrintable(int vcardType){
  return !isV30(vcardType);
}","public static boolean usesQuotedPrintable(final int vcardType){
  return !isV30(vcardType);
}",0.9666666666666668
182930,"public static int getVCardTypeFromString(String vcardTypeString){
  String loweredKey=vcardTypeString.toLowerCase();
  if (sVCardTypeMap.containsKey(loweredKey)) {
    return sVCardTypeMap.get(loweredKey);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + vcardTypeString + ""String_Node_Str"");
    return VCARD_TYPE_DEFAULT;
  }
}","public static int getVCardTypeFromString(final String vcardTypeString){
  final String loweredKey=vcardTypeString.toLowerCase();
  if (sVCardTypeMap.containsKey(loweredKey)) {
    return sVCardTypeMap.get(loweredKey);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + vcardTypeString + ""String_Node_Str"");
    return VCARD_TYPE_DEFAULT;
  }
}",0.9821428571428572
182931,"public static boolean usesAndroidSpecificProperty(int vcardType){
  return ((vcardType & FLAG_USE_ANDROID_PROPERTY) != 0);
}","public static boolean usesAndroidSpecificProperty(final int vcardType){
  return ((vcardType & FLAG_USE_ANDROID_PROPERTY) != 0);
}",0.9763779527559056
182932,"public static boolean appendTypeParamName(int vcardType){
  return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}","public static boolean appendTypeParamName(final int vcardType){
  return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}",0.9782608695652174
182933,"public static boolean refrainsQPToPrimaryProperties(int vcardType){
  return (!usesQuotedPrintable(vcardType) || ((vcardType & FLAG_REFRAIN_QP_TO_PRIMARY_PROPERTIES) != 0));
}","public static boolean refrainsQPToPrimaryProperties(final int vcardType){
  return (!usesQuotedPrintable(vcardType) || ((vcardType & FLAG_REFRAIN_QP_TO_PRIMARY_PROPERTIES) != 0));
}",0.9831460674157304
182934,"public static boolean isDoCoMo(int vcardType){
  return ((vcardType & FLAG_DOCOMO) != 0);
}","public static boolean isDoCoMo(final int vcardType){
  return ((vcardType & FLAG_DOCOMO) != 0);
}",0.9680851063829788
182935,"public static boolean usesShiftJis(int vcardType){
  return ((vcardType & FLAG_CHARSET_SHIFT_JIS) != 0);
}","public static boolean usesShiftJis(final int vcardType){
  return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_SHIFT_JIS);
}",0.8547008547008547
182936,"/** 
 * @return true if the device is Japanese and some Japanese convension isapplied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
public static boolean isJapaneseDevice(int vcardType){
  return sJapaneseMobileTypeSet.contains(vcardType);
}","/** 
 * @return true if the device is Japanese and some Japanese convension isapplied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
public static boolean isJapaneseDevice(final int vcardType){
  return sJapaneseMobileTypeSet.contains(vcardType);
}",0.9884615384615384
182937,"public static boolean usesUtf8(int vcardType){
  return ((vcardType & FLAG_CHARSET_UTF8) != 0);
}","public static boolean usesUtf8(final int vcardType){
  return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_UTF8);
}",0.8425925925925926
182938,"public static boolean isV30(int vcardType){
  return ((vcardType & FLAG_V30) != 0);
}","public static boolean isV30(final int vcardType){
  return ((vcardType & FLAG_V30) != 0);
}",0.9659090909090908
182939,"public static int getNameOrderType(int vcardType){
  return vcardType & NAME_ORDER_MASK;
}","public static int getNameOrderType(final int vcardType){
  return vcardType & NAME_ORDER_MASK;
}",0.967741935483871
182940,"public static boolean needsToConvertPhoneticString(int vcardType){
  return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}","public static boolean needsToConvertPhoneticString(final int vcardType){
  return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}",0.978102189781022
182941,"public static boolean onlyOneNoteFieldIsAvailable(int vcardType){
  return vcardType == VCARD_TYPE_DOCOMO;
}","public static boolean onlyOneNoteFieldIsAvailable(final int vcardType){
  return vcardType == VCARD_TYPE_DOCOMO;
}",0.972972972972973
182942,"public static boolean usesDefactProperty(int vcardType){
  return ((vcardType & FLAG_USE_DEFACT_PROPERTY) != 0);
}","public static boolean usesDefactProperty(final int vcardType){
  return ((vcardType & FLAG_USE_DEFACT_PROPERTY) != 0);
}",0.9743589743589745
182943,"/** 
 * Some Japanese mobile phones use this field for phonetic name, since vCard 2.1 does not have ""SORT-STRING"" type. Also, in some cases, the field has some ';'s in it. Assume the ';' means the same meaning in N property
 */
@SuppressWarnings(""String_Node_Str"") private void handlePhoneticNameFromSound(List<String> elems){
  int size;
  if (elems == null || (size=elems.size()) < 1) {
    return;
  }
  if (size > 3) {
    size=3;
  }
switch (size) {
case 3:
    mPhoneticMiddleName=elems.get(2);
case 2:
  mPhoneticGivenName=elems.get(1);
default :
mPhoneticFamilyName=elems.get(0);
}
}","/** 
 * Some Japanese mobile phones use this field for phonetic name, since vCard 2.1 does not have ""SORT-STRING"" type. Also, in some cases, the field has some ';'s in it. Assume the ';' means the same meaning in N property
 */
@SuppressWarnings(""String_Node_Str"") private void handlePhoneticNameFromSound(List<String> elems){
  if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticMiddleName) && TextUtils.isEmpty(mPhoneticGivenName))) {
    return;
  }
  int size;
  if (elems == null || (size=elems.size()) < 1) {
    return;
  }
  if (size > 3) {
    size=3;
  }
  if (elems.get(0).length() > 0) {
    boolean onlyFirstElemIsNonEmpty=true;
    for (int i=1; i < size; i++) {
      if (elems.get(i).length() > 0) {
        onlyFirstElemIsNonEmpty=false;
        break;
      }
    }
    if (onlyFirstElemIsNonEmpty) {
      final String[] namesArray=elems.get(0).split(""String_Node_Str"");
      final int nameArrayLength=namesArray.length;
      if (nameArrayLength == 3) {
        mPhoneticFamilyName=namesArray[0];
        mPhoneticMiddleName=namesArray[1];
        mPhoneticGivenName=namesArray[2];
      }
 else       if (nameArrayLength == 2) {
        mPhoneticFamilyName=namesArray[0];
        mPhoneticGivenName=namesArray[1];
      }
 else {
        mPhoneticFullName=elems.get(0);
      }
      return;
    }
  }
switch (size) {
case 3:
    mPhoneticMiddleName=elems.get(2);
case 2:
  mPhoneticGivenName=elems.get(1);
default :
mPhoneticFamilyName=elems.get(0);
}
}",0.5652797704447633
182944,"/** 
 * Construct the display name. The constructed data must not be null.
 */
private void constructDisplayName(){
  if (!TextUtils.isEmpty(mFullName)) {
    mDisplayName=mFullName;
  }
 else   if (!(TextUtils.isEmpty(mFamilyName) && TextUtils.isEmpty(mGivenName))) {
    StringBuilder builder=new StringBuilder();
    List<String> nameList;
switch (VCardConfig.getNameOrderType(mVCardType)) {
case VCardConfig.NAME_ORDER_JAPANESE:
      if (VCardUtils.containsOnlyPrintableAscii(mFamilyName) && VCardUtils.containsOnlyPrintableAscii(mGivenName)) {
        nameList=Arrays.asList(mPrefix,mGivenName,mMiddleName,mFamilyName,mSuffix);
      }
 else {
        nameList=Arrays.asList(mPrefix,mFamilyName,mMiddleName,mGivenName,mSuffix);
      }
    break;
case VCardConfig.NAME_ORDER_EUROPE:
  nameList=Arrays.asList(mPrefix,mMiddleName,mGivenName,mFamilyName,mSuffix);
break;
default :
nameList=Arrays.asList(mPrefix,mGivenName,mMiddleName,mFamilyName,mSuffix);
break;
}
boolean first=true;
for (String namePart : nameList) {
if (!TextUtils.isEmpty(namePart)) {
if (first) {
first=false;
}
 else {
builder.append(' ');
}
builder.append(namePart);
}
}
mDisplayName=builder.toString();
}
 else if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticGivenName))) {
mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mPhoneticFamilyName,mPhoneticMiddleName,mPhoneticGivenName);
}
 else if (mEmailList != null && mEmailList.size() > 0) {
mDisplayName=mEmailList.get(0).data;
}
 else if (mPhoneList != null && mPhoneList.size() > 0) {
mDisplayName=mPhoneList.get(0).data;
}
 else if (mPostalList != null && mPostalList.size() > 0) {
mDisplayName=mPostalList.get(0).getFormattedAddress(mVCardType);
}
if (mDisplayName == null) {
mDisplayName=""String_Node_Str"";
}
}","/** 
 * Construct the display name. The constructed data must not be null.
 */
private void constructDisplayName(){
  if (!TextUtils.isEmpty(mFullName)) {
    mDisplayName=mFullName;
  }
 else   if (!(TextUtils.isEmpty(mFamilyName) && TextUtils.isEmpty(mGivenName))) {
    mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mFamilyName,mMiddleName,mGivenName,mPrefix,mSuffix);
  }
 else   if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticGivenName))) {
    mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mPhoneticFamilyName,mPhoneticMiddleName,mPhoneticGivenName);
  }
 else   if (mEmailList != null && mEmailList.size() > 0) {
    mDisplayName=mEmailList.get(0).data;
  }
 else   if (mPhoneList != null && mPhoneList.size() > 0) {
    mDisplayName=mPhoneList.get(0).data;
  }
 else   if (mPostalList != null && mPostalList.size() > 0) {
    mDisplayName=mPostalList.get(0).getFormattedAddress(mVCardType);
  }
  if (mDisplayName == null) {
    mDisplayName=""String_Node_Str"";
  }
}",0.260560880369187
182945,"/** 
 * Returns true when the property line should contain charset parameter information. This method may return true even when vCard version is 3.0. Strictly, adding charset information is invalid in VCard 3.0. However we'll add the info only when charset we use is not UTF-8 in vCard 3.0 format, since parser side may be able to use the charset via this field, though we may encounter another problem by adding it. e.g. Japanese mobile phones use Shift_Jis while RFC 2426 recommends UTF-8. By adding this field, parsers may be able to know this text is NOT UTF-8 but Shift_Jis.
 */
private boolean shouldAppendCharsetParameter(final String propertyValue){
  return (!VCardUtils.containsOnlyPrintableAscii(propertyValue) && (!mIsV30 || !mUsesUtf8));
}","/** 
 * Returns true when the property line should contain charset parameter information. This method may return true even when vCard version is 3.0. Strictly, adding charset information is invalid in VCard 3.0. However we'll add the info only when charset we use is not UTF-8 in vCard 3.0 format, since parser side may be able to use the charset via this field, though we may encounter another problem by adding it. e.g. Japanese mobile phones use Shift_Jis while RFC 2426 recommends UTF-8. By adding this field, parsers may be able to know this text is NOT UTF-8 but Shift_Jis.
 */
private boolean shouldAppendCharsetParameter(final String propertyValue){
  return (!(mIsV30 && mUsesUtf8) && !VCardUtils.containsOnlyPrintableAscii(propertyValue));
}",0.9115103127079176
182946,"private boolean containsNonEmptyName(ContentValues contentValues){
  final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=contentValues.getAsString(StructuredName.PREFIX);
  final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
  return !(TextUtils.isEmpty(familyName) && TextUtils.isEmpty(middleName) && TextUtils.isEmpty(givenName)&& TextUtils.isEmpty(prefix)&& TextUtils.isEmpty(suffix)&& TextUtils.isEmpty(displayName));
}","private boolean containsNonEmptyName(ContentValues contentValues){
  final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=contentValues.getAsString(StructuredName.PREFIX);
  final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
  final String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
  final String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
  final String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
  final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
  return !(TextUtils.isEmpty(familyName) && TextUtils.isEmpty(middleName) && TextUtils.isEmpty(givenName)&& TextUtils.isEmpty(prefix)&& TextUtils.isEmpty(suffix)&& TextUtils.isEmpty(phoneticFamilyName)&& TextUtils.isEmpty(phoneticMiddleName)&& TextUtils.isEmpty(phoneticGivenName)&& TextUtils.isEmpty(displayName));
}",0.7810335641981886
182947,"private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  ContentValues primaryContentValues=null;
  ContentValues subprimaryContentValues=null;
  for (  ContentValues contentValues : contentValuesList) {
    if (contentValues == null) {
      continue;
    }
    Integer isSuperPrimary=contentValues.getAsInteger(StructuredName.IS_SUPER_PRIMARY);
    if (isSuperPrimary != null && isSuperPrimary > 0) {
      primaryContentValues=contentValues;
      break;
    }
 else     if (primaryContentValues == null) {
      Integer isPrimary=contentValues.getAsInteger(StructuredName.IS_PRIMARY);
      if (isPrimary != null && isPrimary > 0 && containsNonEmptyName(contentValues)) {
        primaryContentValues=contentValues;
      }
 else       if (subprimaryContentValues == null && containsNonEmptyName(contentValues)) {
        subprimaryContentValues=contentValues;
      }
    }
  }
  if (primaryContentValues == null) {
    if (subprimaryContentValues != null) {
      primaryContentValues=subprimaryContentValues;
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"");
      primaryContentValues=new ContentValues();
    }
  }
  final String familyName=primaryContentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=primaryContentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=primaryContentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=primaryContentValues.getAsString(StructuredName.PREFIX);
  final String suffix=primaryContentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=primaryContentValues.getAsString(StructuredName.DISPLAY_NAME);
  if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
    final boolean shouldAppendCharsetParameterToName=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameters(Arrays.asList(familyName,givenName,middleName,prefix,suffix));
    final boolean reallyUseQuotedPrintableToName=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
    final String formattedName;
    if (!TextUtils.isEmpty(displayName)) {
      formattedName=displayName;
    }
 else {
      formattedName=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),familyName,middleName,givenName,prefix,suffix);
    }
    final boolean shouldAppendCharsetParameterToFN=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameter(formattedName);
    final boolean reallyUseQuotedPrintableToFN=!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
    final String encodedFamily;
    final String encodedGiven;
    final String encodedMiddle;
    final String encodedPrefix;
    final String encodedSuffix;
    if (reallyUseQuotedPrintableToName) {
      encodedFamily=encodeQuotedPrintable(familyName);
      encodedGiven=encodeQuotedPrintable(givenName);
      encodedMiddle=encodeQuotedPrintable(middleName);
      encodedPrefix=encodeQuotedPrintable(prefix);
      encodedSuffix=encodeQuotedPrintable(suffix);
    }
 else {
      encodedFamily=escapeCharacters(familyName);
      encodedGiven=escapeCharacters(givenName);
      encodedMiddle=escapeCharacters(middleName);
      encodedPrefix=escapeCharacters(prefix);
      encodedSuffix=escapeCharacters(suffix);
    }
    final String encodedFormattedname=(reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
    builder.append(Constants.PROPERTY_N);
    if (mIsDoCoMo) {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(formattedName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
    }
 else {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
    }
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameterToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedFormattedname);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (!TextUtils.isEmpty(displayName)) {
    final boolean reallyUseQuotedPrintableToDisplayName=(!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
    final String encodedDisplayName=reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
    builder.append(Constants.PROPERTY_N);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToDisplayName) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
    if (mIsV30) {
      builder.append(Constants.PROPERTY_FN);
      if (shouldAppendCharsetParameter(displayName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedDisplayName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsV30) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
    appendVCardLine(builder,Constants.PROPERTY_FN,""String_Node_Str"");
  }
 else   if (mIsDoCoMo) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
  }
  final String phoneticFamilyName;
  final String phoneticMiddleName;
  final String phoneticGivenName;
{
    String tmpPhoneticFamilyName=primaryContentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String tmpPhoneticMiddleName=primaryContentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String tmpPhoneticGivenName=primaryContentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (mNeedsToConvertPhoneticString) {
      phoneticFamilyName=VCardUtils.toHalfWidthString(tmpPhoneticFamilyName);
      phoneticMiddleName=VCardUtils.toHalfWidthString(tmpPhoneticMiddleName);
      phoneticGivenName=VCardUtils.toHalfWidthString(tmpPhoneticGivenName);
    }
 else {
      phoneticFamilyName=tmpPhoneticFamilyName;
      phoneticMiddleName=tmpPhoneticMiddleName;
      phoneticGivenName=tmpPhoneticGivenName;
    }
  }
  if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
    if (mIsV30) {
      final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
      builder.append(Constants.PROPERTY_SORT_STRING);
      final String encodedSortString=escapeCharacters(sortString);
      if (shouldAppendCharsetParameter(encodedSortString)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedSortString);
      builder.append(VCARD_END_OF_LINE);
    }
 else     if (mIsJapaneseMobilePhone) {
      builder.append(Constants.PROPERTY_SOUND);
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(Constants.PARAM_TYPE_X_IRMC_N);
      boolean reallyUseQuotedPrintable=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName)));
      final String encodedPhoneticFamilyName;
      final String encodedPhoneticMiddleName;
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      if (shouldAppendCharsetParameters(Arrays.asList(encodedPhoneticFamilyName,encodedPhoneticMiddleName,encodedPhoneticGivenName))) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsDoCoMo) {
    builder.append(Constants.PROPERTY_SOUND);
    builder.append(VCARD_PARAM_SEPARATOR);
    builder.append(Constants.PARAM_TYPE_X_IRMC_N);
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
  }
  if (mUsesDefactProperty) {
    if (!TextUtils.isEmpty(phoneticGivenName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName);
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_FIRST_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticGivenName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticMiddleName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName);
      final String encodedPhoneticMiddleName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
      }
 else {
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_MIDDLE_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticMiddleName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticFamilyName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName);
      final String encodedPhoneticFamilyName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_LAST_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticFamilyName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
}","private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  ContentValues primaryContentValues=null;
  ContentValues subprimaryContentValues=null;
  for (  ContentValues contentValues : contentValuesList) {
    if (contentValues == null) {
      continue;
    }
    Integer isSuperPrimary=contentValues.getAsInteger(StructuredName.IS_SUPER_PRIMARY);
    if (isSuperPrimary != null && isSuperPrimary > 0) {
      primaryContentValues=contentValues;
      break;
    }
 else     if (primaryContentValues == null) {
      Integer isPrimary=contentValues.getAsInteger(StructuredName.IS_PRIMARY);
      if (isPrimary != null && isPrimary > 0 && containsNonEmptyName(contentValues)) {
        primaryContentValues=contentValues;
      }
 else       if (subprimaryContentValues == null && containsNonEmptyName(contentValues)) {
        subprimaryContentValues=contentValues;
      }
    }
  }
  if (primaryContentValues == null) {
    if (subprimaryContentValues != null) {
      primaryContentValues=subprimaryContentValues;
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"");
      primaryContentValues=new ContentValues();
    }
  }
  final String familyName=primaryContentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=primaryContentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=primaryContentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=primaryContentValues.getAsString(StructuredName.PREFIX);
  final String suffix=primaryContentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=primaryContentValues.getAsString(StructuredName.DISPLAY_NAME);
  if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
    final boolean shouldAppendCharsetParameterToName=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameters(Arrays.asList(familyName,givenName,middleName,prefix,suffix));
    final boolean reallyUseQuotedPrintableToName=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
    final String formattedName;
    if (!TextUtils.isEmpty(displayName)) {
      formattedName=displayName;
    }
 else {
      formattedName=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),familyName,middleName,givenName,prefix,suffix);
    }
    final boolean shouldAppendCharsetParameterToFN=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameter(formattedName);
    final boolean reallyUseQuotedPrintableToFN=!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
    final String encodedFamily;
    final String encodedGiven;
    final String encodedMiddle;
    final String encodedPrefix;
    final String encodedSuffix;
    if (reallyUseQuotedPrintableToName) {
      encodedFamily=encodeQuotedPrintable(familyName);
      encodedGiven=encodeQuotedPrintable(givenName);
      encodedMiddle=encodeQuotedPrintable(middleName);
      encodedPrefix=encodeQuotedPrintable(prefix);
      encodedSuffix=encodeQuotedPrintable(suffix);
    }
 else {
      encodedFamily=escapeCharacters(familyName);
      encodedGiven=escapeCharacters(givenName);
      encodedMiddle=escapeCharacters(middleName);
      encodedPrefix=escapeCharacters(prefix);
      encodedSuffix=escapeCharacters(suffix);
    }
    final String encodedFormattedname=(reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
    builder.append(Constants.PROPERTY_N);
    if (mIsDoCoMo) {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(formattedName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
    }
 else {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
    }
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameterToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedFormattedname);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (!TextUtils.isEmpty(displayName)) {
    final boolean reallyUseQuotedPrintableToDisplayName=(!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
    final String encodedDisplayName=reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
    builder.append(Constants.PROPERTY_N);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToDisplayName) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (mIsV30) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
    appendVCardLine(builder,Constants.PROPERTY_FN,""String_Node_Str"");
  }
 else   if (mIsDoCoMo) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
  }
  final String phoneticFamilyName;
  final String phoneticMiddleName;
  final String phoneticGivenName;
{
    String tmpPhoneticFamilyName=primaryContentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String tmpPhoneticMiddleName=primaryContentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String tmpPhoneticGivenName=primaryContentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (mNeedsToConvertPhoneticString) {
      phoneticFamilyName=VCardUtils.toHalfWidthString(tmpPhoneticFamilyName);
      phoneticMiddleName=VCardUtils.toHalfWidthString(tmpPhoneticMiddleName);
      phoneticGivenName=VCardUtils.toHalfWidthString(tmpPhoneticGivenName);
    }
 else {
      phoneticFamilyName=tmpPhoneticFamilyName;
      phoneticMiddleName=tmpPhoneticMiddleName;
      phoneticGivenName=tmpPhoneticGivenName;
    }
  }
  if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
    if (mIsV30) {
      final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
      builder.append(Constants.PROPERTY_SORT_STRING);
      if (shouldAppendCharsetParameter(sortString)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(sortString));
      builder.append(VCARD_END_OF_LINE);
    }
 else     if (mIsJapaneseMobilePhone) {
      builder.append(Constants.PROPERTY_SOUND);
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(Constants.PARAM_TYPE_X_IRMC_N);
      boolean reallyUseQuotedPrintable=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName)));
      final String encodedPhoneticFamilyName;
      final String encodedPhoneticMiddleName;
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      if (shouldAppendCharsetParameters(Arrays.asList(encodedPhoneticFamilyName,encodedPhoneticMiddleName,encodedPhoneticGivenName))) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
{
        boolean first=true;
        if (!TextUtils.isEmpty(encodedPhoneticFamilyName)) {
          builder.append(encodedPhoneticFamilyName);
          first=false;
        }
        if (!TextUtils.isEmpty(encodedPhoneticMiddleName)) {
          if (first) {
            first=false;
          }
 else {
            builder.append(' ');
          }
          builder.append(encodedPhoneticMiddleName);
        }
        if (!TextUtils.isEmpty(encodedPhoneticGivenName)) {
          if (!first) {
            builder.append(' ');
          }
          builder.append(encodedPhoneticGivenName);
        }
      }
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsDoCoMo) {
    builder.append(Constants.PROPERTY_SOUND);
    builder.append(VCARD_PARAM_SEPARATOR);
    builder.append(Constants.PARAM_TYPE_X_IRMC_N);
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
  }
  if (mUsesDefactProperty) {
    if (!TextUtils.isEmpty(phoneticGivenName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName));
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_FIRST_NAME);
      if (shouldAppendCharsetParameter(phoneticGivenName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticMiddleName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName));
      final String encodedPhoneticMiddleName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
      }
 else {
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_MIDDLE_NAME);
      if (shouldAppendCharsetParameter(phoneticMiddleName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticFamilyName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName));
      final String encodedPhoneticFamilyName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_LAST_NAME);
      if (shouldAppendCharsetParameter(phoneticFamilyName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
}",0.9343050048226342
182948,"public static boolean usesQuotedPrintable(int vcardType){
  return !isV30(vcardType);
}","public static boolean usesQuotedPrintable(final int vcardType){
  return !isV30(vcardType);
}",0.9666666666666668
182949,"public static int getVCardTypeFromString(String vcardTypeString){
  String loweredKey=vcardTypeString.toLowerCase();
  if (sVCardTypeMap.containsKey(loweredKey)) {
    return sVCardTypeMap.get(loweredKey);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + vcardTypeString + ""String_Node_Str"");
    return VCARD_TYPE_DEFAULT;
  }
}","public static int getVCardTypeFromString(final String vcardTypeString){
  final String loweredKey=vcardTypeString.toLowerCase();
  if (sVCardTypeMap.containsKey(loweredKey)) {
    return sVCardTypeMap.get(loweredKey);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + vcardTypeString + ""String_Node_Str"");
    return VCARD_TYPE_DEFAULT;
  }
}",0.9821428571428572
182950,"public static boolean usesAndroidSpecificProperty(int vcardType){
  return ((vcardType & FLAG_USE_ANDROID_PROPERTY) != 0);
}","public static boolean usesAndroidSpecificProperty(final int vcardType){
  return ((vcardType & FLAG_USE_ANDROID_PROPERTY) != 0);
}",0.9763779527559056
182951,"public static boolean appendTypeParamName(int vcardType){
  return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}","public static boolean appendTypeParamName(final int vcardType){
  return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}",0.9782608695652174
182952,"public static boolean refrainsQPToPrimaryProperties(int vcardType){
  return (!usesQuotedPrintable(vcardType) || ((vcardType & FLAG_REFRAIN_QP_TO_PRIMARY_PROPERTIES) != 0));
}","public static boolean refrainsQPToPrimaryProperties(final int vcardType){
  return (!usesQuotedPrintable(vcardType) || ((vcardType & FLAG_REFRAIN_QP_TO_PRIMARY_PROPERTIES) != 0));
}",0.9831460674157304
182953,"public static boolean isDoCoMo(int vcardType){
  return ((vcardType & FLAG_DOCOMO) != 0);
}","public static boolean isDoCoMo(final int vcardType){
  return ((vcardType & FLAG_DOCOMO) != 0);
}",0.9680851063829788
182954,"public static boolean usesShiftJis(int vcardType){
  return ((vcardType & FLAG_CHARSET_SHIFT_JIS) != 0);
}","public static boolean usesShiftJis(final int vcardType){
  return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_SHIFT_JIS);
}",0.8547008547008547
182955,"/** 
 * @return true if the device is Japanese and some Japanese convension isapplied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
public static boolean isJapaneseDevice(int vcardType){
  return sJapaneseMobileTypeSet.contains(vcardType);
}","/** 
 * @return true if the device is Japanese and some Japanese convension isapplied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
public static boolean isJapaneseDevice(final int vcardType){
  return sJapaneseMobileTypeSet.contains(vcardType);
}",0.9884615384615384
182956,"public static boolean usesUtf8(int vcardType){
  return ((vcardType & FLAG_CHARSET_UTF8) != 0);
}","public static boolean usesUtf8(final int vcardType){
  return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_UTF8);
}",0.8425925925925926
182957,"public static boolean isV30(int vcardType){
  return ((vcardType & FLAG_V30) != 0);
}","public static boolean isV30(final int vcardType){
  return ((vcardType & FLAG_V30) != 0);
}",0.9659090909090908
182958,"public static int getNameOrderType(int vcardType){
  return vcardType & NAME_ORDER_MASK;
}","public static int getNameOrderType(final int vcardType){
  return vcardType & NAME_ORDER_MASK;
}",0.967741935483871
182959,"public static boolean needsToConvertPhoneticString(int vcardType){
  return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}","public static boolean needsToConvertPhoneticString(final int vcardType){
  return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}",0.978102189781022
182960,"public static boolean onlyOneNoteFieldIsAvailable(int vcardType){
  return vcardType == VCARD_TYPE_DOCOMO;
}","public static boolean onlyOneNoteFieldIsAvailable(final int vcardType){
  return vcardType == VCARD_TYPE_DOCOMO;
}",0.972972972972973
182961,"public static boolean usesDefactProperty(int vcardType){
  return ((vcardType & FLAG_USE_DEFACT_PROPERTY) != 0);
}","public static boolean usesDefactProperty(final int vcardType){
  return ((vcardType & FLAG_USE_DEFACT_PROPERTY) != 0);
}",0.9743589743589745
182962,"public Bitmap peekWallpaperBitmap(Context context,boolean returnDefault){
synchronized (this) {
    if (mWallpaper != null) {
      return mWallpaper;
    }
    if (mDefaultWallpaper != null) {
      return mDefaultWallpaper;
    }
    mWallpaper=getCurrentWallpaperLocked(context);
    if (mWallpaper == null && returnDefault) {
      mDefaultWallpaper=getDefaultWallpaperLocked(context);
      return mDefaultWallpaper;
    }
    return mWallpaper;
  }
}","public Bitmap peekWallpaperBitmap(Context context,boolean returnDefault){
synchronized (this) {
    if (mWallpaper != null) {
      return mWallpaper;
    }
    if (mDefaultWallpaper != null) {
      return mDefaultWallpaper;
    }
    mWallpaper=null;
    try {
      mWallpaper=getCurrentWallpaperLocked(context);
    }
 catch (    OutOfMemoryError e) {
      Log.w(TAG,""String_Node_Str"",e);
    }
    if (mWallpaper == null && returnDefault) {
      mDefaultWallpaper=getDefaultWallpaperLocked(context);
      return mDefaultWallpaper;
    }
    return mWallpaper;
  }
}",0.8862973760932945
182963,"private Bitmap getDefaultWallpaperLocked(Context context){
  try {
    InputStream is=context.getResources().openRawResource(com.android.internal.R.drawable.default_wallpaper);
    if (is != null) {
      int width=mService.getWidthHint();
      int height=mService.getHeightHint();
      if (width <= 0 || height <= 0) {
        Bitmap bm=BitmapFactory.decodeStream(is,null,null);
        try {
          is.close();
        }
 catch (        IOException e) {
        }
        if (bm != null) {
          bm.setDensity(DisplayMetrics.DENSITY_DEVICE);
        }
        return bm;
      }
      BitmapFactory.Options options=new BitmapFactory.Options();
      options.inDither=false;
      options.inPreferredConfig=Bitmap.Config.ARGB_8888;
      Bitmap bm=BitmapFactory.decodeStream(is,null,options);
      try {
        is.close();
      }
 catch (      IOException e) {
      }
      return generateBitmap(context,bm,width,height);
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","private Bitmap getDefaultWallpaperLocked(Context context){
  try {
    InputStream is=context.getResources().openRawResource(com.android.internal.R.drawable.default_wallpaper);
    if (is != null) {
      int width=mService.getWidthHint();
      int height=mService.getHeightHint();
      if (width <= 0 || height <= 0) {
        Bitmap bm=BitmapFactory.decodeStream(is,null,null);
        try {
          is.close();
        }
 catch (        IOException e) {
        }
        if (bm != null) {
          bm.setDensity(DisplayMetrics.DENSITY_DEVICE);
        }
        return bm;
      }
      BitmapFactory.Options options=new BitmapFactory.Options();
      options.inDither=false;
      options.inPreferredConfig=Bitmap.Config.ARGB_8888;
      Bitmap bm=BitmapFactory.decodeStream(is,null,options);
      try {
        is.close();
      }
 catch (      IOException e) {
      }
      try {
        return generateBitmap(context,bm,width,height);
      }
 catch (      OutOfMemoryError e) {
        Log.w(TAG,""String_Node_Str"",e);
        return bm;
      }
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}",0.9410099103350638
182964,"void drawFrame(){
  SurfaceHolder sh=getSurfaceHolder();
  Canvas c=sh.lockCanvas();
  if (c != null) {
    final Rect frame=sh.getSurfaceFrame();
synchronized (mLock) {
      final Drawable background=mBackground;
      final int dw=frame.width();
      final int dh=frame.height();
      final int bw=mBackground.getIntrinsicWidth();
      final int bh=mBackground.getIntrinsicHeight();
      final int availw=dw - bw;
      final int availh=dh - bh;
      int xPixels=availw < 0 ? (int)(availw * mXOffset + .5f) : (availw / 2);
      int yPixels=availh < 0 ? (int)(availh * mYOffset + .5f) : (availh / 2);
      c.translate(xPixels,yPixels);
      if (availw < 0 || availh < 0) {
        c.save(Canvas.CLIP_SAVE_FLAG);
        c.clipRect(0,0,bw,bh,Op.DIFFERENCE);
        c.drawColor(0xff000000);
        c.restore();
      }
      background.draw(c);
    }
    sh.unlockCanvasAndPost(c);
  }
}","void drawFrame(){
  SurfaceHolder sh=getSurfaceHolder();
  Canvas c=sh.lockCanvas();
  if (c != null) {
    final Rect frame=sh.getSurfaceFrame();
synchronized (mLock) {
      final Drawable background=mBackground;
      final int dw=frame.width();
      final int dh=frame.height();
      final int bw=background != null ? background.getIntrinsicWidth() : 0;
      final int bh=background != null ? background.getIntrinsicHeight() : 0;
      final int availw=dw - bw;
      final int availh=dh - bh;
      int xPixels=availw < 0 ? (int)(availw * mXOffset + .5f) : (availw / 2);
      int yPixels=availh < 0 ? (int)(availh * mYOffset + .5f) : (availh / 2);
      c.translate(xPixels,yPixels);
      if (availw < 0 || availh < 0) {
        c.save(Canvas.CLIP_SAVE_FLAG);
        c.clipRect(0,0,bw,bh,Op.DIFFERENCE);
        c.drawColor(0xff000000);
        c.restore();
      }
      if (background != null) {
        background.draw(c);
      }
    }
    sh.unlockCanvasAndPost(c);
  }
}",0.9044585987261148
182965,"void updateWallpaper(){
synchronized (mLock) {
    mBackground=mWallpaperManager.getFastDrawable();
  }
}","void updateWallpaper(){
synchronized (mLock) {
    try {
      mBackground=mWallpaperManager.getFastDrawable();
    }
 catch (    RuntimeException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"",e);
    }
  }
}",0.6375
182966,"public int getMaxPacketSize(){
  return mMaxPacketSize - 6;
}","public int getMaxPacketSize(){
  return mMaxPacketSize - 6 - getHeaderLength();
}",0.8591549295774648
182967,"/** 
 * Open and return an output stream for a connection.
 * @return an output stream
 * @throws IOException if an I/O error occurs
 */
public OutputStream openOutputStream() throws IOException {
  ensureOpen();
  ensureNotDone();
  if (mPrivateOutputOpen)   throw new IOException(""String_Node_Str"");
  if (mPrivateOutput == null) {
    mPrivateOutput=new PrivateOutputStream(this,mMaxPacketSize - 6);
  }
  mPrivateOutputOpen=true;
  return mPrivateOutput;
}","/** 
 * Open and return an output stream for a connection.
 * @return an output stream
 * @throws IOException if an I/O error occurs
 */
public OutputStream openOutputStream() throws IOException {
  ensureOpen();
  ensureNotDone();
  if (mPrivateOutputOpen)   throw new IOException(""String_Node_Str"");
  if (mPrivateOutput == null) {
    mPrivateOutput=new PrivateOutputStream(this,getMaxPacketSize());
  }
  mPrivateOutputOpen=true;
  return mPrivateOutput;
}",0.9891304347826086
182968,"public int getMaxPacketSize(){
  return mMaxPacketLength - 6;
}","public int getMaxPacketSize(){
  return mMaxPacketLength - 6 - getHeaderLength();
}",0.863013698630137
182969,"/** 
 * Open and return an output stream for a connection.
 * @return an output stream
 * @throws IOException if an I/O error occurs
 */
public OutputStream openOutputStream() throws IOException {
  ensureOpen();
  if (mPrivateOutputOpen) {
    throw new IOException(""String_Node_Str"");
  }
  if (!mRequestFinished) {
    throw new IOException(""String_Node_Str"");
  }
  if (mPrivateOutput == null) {
    mPrivateOutput=new PrivateOutputStream(this,mMaxPacketLength - 6);
  }
  mPrivateOutputOpen=true;
  return mPrivateOutput;
}","/** 
 * Open and return an output stream for a connection.
 * @return an output stream
 * @throws IOException if an I/O error occurs
 */
public OutputStream openOutputStream() throws IOException {
  ensureOpen();
  if (mPrivateOutputOpen) {
    throw new IOException(""String_Node_Str"");
  }
  if (!mRequestFinished) {
    throw new IOException(""String_Node_Str"");
  }
  if (mPrivateOutput == null) {
    mPrivateOutput=new PrivateOutputStream(this,getMaxPacketSize());
  }
  mPrivateOutputOpen=true;
  return mPrivateOutput;
}",0.9810246679316889
182970,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if (mGetOperation && type == ResponseCodes.OBEX_HTTP_OK) {
    finalBitSet=true;
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL)) {
        finalBitSet=true;
      }
 else       if (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL) {
        mRequestFinished=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}",0.9852813852813852
182971,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
    if ((request & 0x80) == 0) {
      finalBitSet=false;
    }
 else {
      finalBitSet=true;
      mRequestFinished=true;
    }
  }
 else   if ((request == 0x03) || (request == 0x83)) {
    mGetOperation=true;
    finalBitSet=false;
    if (request == 0x83) {
      mRequestFinished=true;
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !mRequestFinished) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
}",0.9428001840208556
182972,"private final void handleReceiver(ReceiverData data){
  unscheduleGcIdler();
  String component=data.intent.getComponent().getClassName();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.info.applicationInfo);
  IActivityManager mgr=ActivityManagerNative.getDefault();
  BroadcastReceiver receiver=null;
  try {
    java.lang.ClassLoader cl=packageInfo.getClassLoader();
    data.intent.setExtrasClassLoader(cl);
    if (data.resultExtras != null) {
      data.resultExtras.setClassLoader(cl);
    }
    receiver=(BroadcastReceiver)cl.loadClass(component).newInstance();
  }
 catch (  Exception e) {
    try {
      mgr.finishReceiver(mAppThread.asBinder(),data.resultCode,data.resultData,data.resultExtras,data.resultAbort);
    }
 catch (    RemoteException ex) {
    }
    throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
  }
  try {
    Application app=packageInfo.makeApplication(false);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + data.intent + ""String_Node_Str""+ app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ packageInfo.getPackageName()+ ""String_Node_Str""+ data.intent.getComponent().toShortString()+ ""String_Node_Str""+ packageInfo.getAppDir());
    ApplicationContext context=(ApplicationContext)app.getBaseContext();
    receiver.setOrderedHint(true);
    receiver.setResult(data.resultCode,data.resultData,data.resultExtras);
    receiver.setOrderedHint(data.sync);
    receiver.onReceive(context.getReceiverRestrictedContext(),data.intent);
  }
 catch (  Exception e) {
    try {
      mgr.finishReceiver(mAppThread.asBinder(),data.resultCode,data.resultData,data.resultExtras,data.resultAbort);
    }
 catch (    RemoteException ex) {
    }
    if (!mInstrumentation.onException(receiver,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    if (data.sync) {
      mgr.finishReceiver(mAppThread.asBinder(),receiver.getResultCode(),receiver.getResultData(),receiver.getResultExtras(false),receiver.getAbortBroadcast());
    }
 else {
      mgr.finishReceiver(mAppThread.asBinder(),0,null,null,false);
    }
  }
 catch (  RemoteException ex) {
  }
}","private final void handleReceiver(ReceiverData data){
  unscheduleGcIdler();
  String component=data.intent.getComponent().getClassName();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.info.applicationInfo);
  IActivityManager mgr=ActivityManagerNative.getDefault();
  BroadcastReceiver receiver=null;
  try {
    java.lang.ClassLoader cl=packageInfo.getClassLoader();
    data.intent.setExtrasClassLoader(cl);
    if (data.resultExtras != null) {
      data.resultExtras.setClassLoader(cl);
    }
    receiver=(BroadcastReceiver)cl.loadClass(component).newInstance();
  }
 catch (  Exception e) {
    try {
      mgr.finishReceiver(mAppThread.asBinder(),data.resultCode,data.resultData,data.resultExtras,data.resultAbort);
    }
 catch (    RemoteException ex) {
    }
    throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
  }
  try {
    Application app=packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + data.intent + ""String_Node_Str""+ app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ packageInfo.getPackageName()+ ""String_Node_Str""+ data.intent.getComponent().toShortString()+ ""String_Node_Str""+ packageInfo.getAppDir());
    ApplicationContext context=(ApplicationContext)app.getBaseContext();
    receiver.setOrderedHint(true);
    receiver.setResult(data.resultCode,data.resultData,data.resultExtras);
    receiver.setOrderedHint(data.sync);
    receiver.onReceive(context.getReceiverRestrictedContext(),data.intent);
  }
 catch (  Exception e) {
    try {
      mgr.finishReceiver(mAppThread.asBinder(),data.resultCode,data.resultData,data.resultExtras,data.resultAbort);
    }
 catch (    RemoteException ex) {
    }
    if (!mInstrumentation.onException(receiver,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    if (data.sync) {
      mgr.finishReceiver(mAppThread.asBinder(),receiver.getResultCode(),receiver.getResultData(),receiver.getResultExtras(false),receiver.getAbortBroadcast());
    }
 else {
      mgr.finishReceiver(mAppThread.asBinder(),0,null,null,false);
    }
  }
 catch (  RemoteException ex) {
  }
}",0.996175478065242
182973,"private final void handleCreateService(CreateServiceData data){
  unscheduleGcIdler();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.info.applicationInfo);
  Service service=null;
  try {
    java.lang.ClassLoader cl=packageInfo.getClassLoader();
    service=(Service)cl.loadClass(data.info.name).newInstance();
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(service,e)) {
      throw new RuntimeException(""String_Node_Str"" + data.info.name + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + data.info.name);
    ApplicationContext context=new ApplicationContext();
    context.init(packageInfo,null,this);
    Application app=packageInfo.makeApplication(false);
    context.setOuterContext(service);
    service.attach(context,this,data.info.name,data.token,app,ActivityManagerNative.getDefault());
    service.onCreate();
    mServices.put(data.token,service);
    try {
      ActivityManagerNative.getDefault().serviceDoneExecuting(data.token,0,0,0);
    }
 catch (    RemoteException e) {
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(service,e)) {
      throw new RuntimeException(""String_Node_Str"" + data.info.name + ""String_Node_Str""+ e.toString(),e);
    }
  }
}","private final void handleCreateService(CreateServiceData data){
  unscheduleGcIdler();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.info.applicationInfo);
  Service service=null;
  try {
    java.lang.ClassLoader cl=packageInfo.getClassLoader();
    service=(Service)cl.loadClass(data.info.name).newInstance();
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(service,e)) {
      throw new RuntimeException(""String_Node_Str"" + data.info.name + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + data.info.name);
    ApplicationContext context=new ApplicationContext();
    context.init(packageInfo,null,this);
    Application app=packageInfo.makeApplication(false,mInstrumentation);
    context.setOuterContext(service);
    service.attach(context,this,data.info.name,data.token,app,ActivityManagerNative.getDefault());
    service.onCreate();
    mServices.put(data.token,service);
    try {
      ActivityManagerNative.getDefault().serviceDoneExecuting(data.token,0,0,0);
    }
 catch (    RemoteException e) {
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(service,e)) {
      throw new RuntimeException(""String_Node_Str"" + data.info.name + ""String_Node_Str""+ e.toString(),e);
    }
  }
}",0.9934134056567222
182974,"private final void handleBindApplication(AppBindData data){
  mBoundApplication=data;
  mConfiguration=new Configuration(data.config);
  Process.setArgV0(data.processName);
  android.ddm.DdmHandleAppName.setAppName(data.processName);
  TimeZone.setDefault(null);
  Locale.setDefault(data.config.locale);
  Resources.getSystem().updateConfiguration(mConfiguration,null);
  data.info=getPackageInfoNoCheck(data.appInfo);
  if ((data.appInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) {
    Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);
  }
  if (data.debugMode != IApplicationThread.DEBUG_OFF) {
    Debug.changeDebugPort(8100);
    if (data.debugMode == IApplicationThread.DEBUG_WAIT) {
      Log.w(TAG,""String_Node_Str"" + data.info.getPackageName() + ""String_Node_Str"");
      IActivityManager mgr=ActivityManagerNative.getDefault();
      try {
        mgr.showWaitingForDebugger(mAppThread,true);
      }
 catch (      RemoteException ex) {
      }
      Debug.waitForDebugger();
      try {
        mgr.showWaitingForDebugger(mAppThread,false);
      }
 catch (      RemoteException ex) {
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + data.info.getPackageName() + ""String_Node_Str"");
    }
  }
  if (data.instrumentationName != null) {
    ApplicationContext appContext=new ApplicationContext();
    appContext.init(data.info,null,this);
    InstrumentationInfo ii=null;
    try {
      ii=appContext.getPackageManager().getInstrumentationInfo(data.instrumentationName,0);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName);
    }
    mInstrumentationAppDir=ii.sourceDir;
    mInstrumentationAppPackage=ii.packageName;
    mInstrumentedAppDir=data.info.getAppDir();
    ApplicationInfo instrApp=new ApplicationInfo();
    instrApp.packageName=ii.packageName;
    instrApp.sourceDir=ii.sourceDir;
    instrApp.publicSourceDir=ii.publicSourceDir;
    instrApp.dataDir=ii.dataDir;
    PackageInfo pi=getPackageInfo(instrApp,appContext.getClassLoader(),false,true);
    ApplicationContext instrContext=new ApplicationContext();
    instrContext.init(pi,null,this);
    try {
      java.lang.ClassLoader cl=instrContext.getClassLoader();
      mInstrumentation=(Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName + ""String_Node_Str""+ e.toString(),e);
    }
    mInstrumentation.init(this,instrContext,appContext,new ComponentName(ii.packageName,ii.name),data.instrumentationWatcher);
    if (data.profileFile != null && !ii.handleProfiling) {
      data.handlingProfiling=true;
      File file=new File(data.profileFile);
      file.getParentFile().mkdirs();
      Debug.startMethodTracing(file.toString(),8 * 1024 * 1024);
    }
    try {
      mInstrumentation.onCreate(data.instrumentationArgs);
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName + ""String_Node_Str""+ e.toString(),e);
    }
  }
 else {
    mInstrumentation=new Instrumentation();
  }
  Application app=data.info.makeApplication(data.restrictedBackupMode);
  mInitialApplication=app;
  List<ProviderInfo> providers=data.providers;
  if (providers != null) {
    installContentProviders(app,providers);
  }
  try {
    mInstrumentation.callApplicationOnCreate(app);
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(app,e)) {
      throw new RuntimeException(""String_Node_Str"" + app.getClass().getName() + ""String_Node_Str""+ e.toString(),e);
    }
  }
}","private final void handleBindApplication(AppBindData data){
  mBoundApplication=data;
  mConfiguration=new Configuration(data.config);
  Process.setArgV0(data.processName);
  android.ddm.DdmHandleAppName.setAppName(data.processName);
  TimeZone.setDefault(null);
  Locale.setDefault(data.config.locale);
  Resources.getSystem().updateConfiguration(mConfiguration,null);
  data.info=getPackageInfoNoCheck(data.appInfo);
  if ((data.appInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) {
    Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);
  }
  if (data.debugMode != IApplicationThread.DEBUG_OFF) {
    Debug.changeDebugPort(8100);
    if (data.debugMode == IApplicationThread.DEBUG_WAIT) {
      Log.w(TAG,""String_Node_Str"" + data.info.getPackageName() + ""String_Node_Str"");
      IActivityManager mgr=ActivityManagerNative.getDefault();
      try {
        mgr.showWaitingForDebugger(mAppThread,true);
      }
 catch (      RemoteException ex) {
      }
      Debug.waitForDebugger();
      try {
        mgr.showWaitingForDebugger(mAppThread,false);
      }
 catch (      RemoteException ex) {
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + data.info.getPackageName() + ""String_Node_Str"");
    }
  }
  if (data.instrumentationName != null) {
    ApplicationContext appContext=new ApplicationContext();
    appContext.init(data.info,null,this);
    InstrumentationInfo ii=null;
    try {
      ii=appContext.getPackageManager().getInstrumentationInfo(data.instrumentationName,0);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName);
    }
    mInstrumentationAppDir=ii.sourceDir;
    mInstrumentationAppPackage=ii.packageName;
    mInstrumentedAppDir=data.info.getAppDir();
    ApplicationInfo instrApp=new ApplicationInfo();
    instrApp.packageName=ii.packageName;
    instrApp.sourceDir=ii.sourceDir;
    instrApp.publicSourceDir=ii.publicSourceDir;
    instrApp.dataDir=ii.dataDir;
    PackageInfo pi=getPackageInfo(instrApp,appContext.getClassLoader(),false,true);
    ApplicationContext instrContext=new ApplicationContext();
    instrContext.init(pi,null,this);
    try {
      java.lang.ClassLoader cl=instrContext.getClassLoader();
      mInstrumentation=(Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName + ""String_Node_Str""+ e.toString(),e);
    }
    mInstrumentation.init(this,instrContext,appContext,new ComponentName(ii.packageName,ii.name),data.instrumentationWatcher);
    if (data.profileFile != null && !ii.handleProfiling) {
      data.handlingProfiling=true;
      File file=new File(data.profileFile);
      file.getParentFile().mkdirs();
      Debug.startMethodTracing(file.toString(),8 * 1024 * 1024);
    }
    try {
      mInstrumentation.onCreate(data.instrumentationArgs);
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName + ""String_Node_Str""+ e.toString(),e);
    }
  }
 else {
    mInstrumentation=new Instrumentation();
  }
  Application app=data.info.makeApplication(data.restrictedBackupMode,null);
  mInitialApplication=app;
  List<ProviderInfo> providers=data.providers;
  if (providers != null) {
    installContentProviders(app,providers);
  }
  try {
    mInstrumentation.callApplicationOnCreate(app);
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(app,e)) {
      throw new RuntimeException(""String_Node_Str"" + app.getClass().getName() + ""String_Node_Str""+ e.toString(),e);
    }
  }
}",0.99932478055368
182975,"private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ApplicationContext appContext=new ApplicationContext();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
      r.state=null;
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}","private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ApplicationContext appContext=new ApplicationContext();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
      r.state=null;
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}",0.9976810803437456
182976,"public Application makeApplication(boolean forceDefaultAppClass){
  if (mApplication != null) {
    return mApplication;
  }
  Application app=null;
  String appClass=mApplicationInfo.className;
  if (forceDefaultAppClass || (appClass == null)) {
    appClass=""String_Node_Str"";
  }
  try {
    java.lang.ClassLoader cl=getClassLoader();
    ApplicationContext appContext=new ApplicationContext();
    appContext.init(this,null,mActivityThread);
    app=mActivityThread.mInstrumentation.newApplication(cl,appClass,appContext);
    appContext.setOuterContext(app);
  }
 catch (  Exception e) {
    if (!mActivityThread.mInstrumentation.onException(app,e)) {
      throw new RuntimeException(""String_Node_Str"" + appClass + ""String_Node_Str""+ e.toString(),e);
    }
  }
  mActivityThread.mAllApplications.add(app);
  return mApplication=app;
}","public Application makeApplication(boolean forceDefaultAppClass,Instrumentation instrumentation){
  if (mApplication != null) {
    return mApplication;
  }
  Application app=null;
  String appClass=mApplicationInfo.className;
  if (forceDefaultAppClass || (appClass == null)) {
    appClass=""String_Node_Str"";
  }
  try {
    java.lang.ClassLoader cl=getClassLoader();
    ApplicationContext appContext=new ApplicationContext();
    appContext.init(this,null,mActivityThread);
    app=mActivityThread.mInstrumentation.newApplication(cl,appClass,appContext);
    appContext.setOuterContext(app);
  }
 catch (  Exception e) {
    if (!mActivityThread.mInstrumentation.onException(app,e)) {
      throw new RuntimeException(""String_Node_Str"" + appClass + ""String_Node_Str""+ e.toString(),e);
    }
  }
  mActivityThread.mAllApplications.add(app);
  mApplication=app;
  if (instrumentation != null) {
    try {
      instrumentation.callApplicationOnCreate(app);
    }
 catch (    Exception e) {
      if (!instrumentation.onException(app,e)) {
        throw new RuntimeException(""String_Node_Str"" + app.getClass().getName() + ""String_Node_Str""+ e.toString(),e);
      }
    }
  }
  return app;
}",0.8198818897637795
182977,"public void start(GLThread thread) throws InterruptedException {
  GLThread oldThread=null;
synchronized (this) {
    mMostRecentGLThread=thread;
    oldThread=mMostRecentGLThread;
  }
  if (oldThread != null) {
synchronized (oldThread) {
      oldThread.notifyAll();
    }
  }
  sEglSemaphore.acquire();
}","public void start(GLThread thread) throws InterruptedException {
  GLThread oldThread=null;
synchronized (this) {
    oldThread=mMostRecentGLThread;
    mMostRecentGLThread=thread;
  }
  if (oldThread != null) {
synchronized (oldThread) {
      oldThread.notifyAll();
    }
  }
  sEglSemaphore.acquire();
}",0.8954248366013072
182978,"/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param force ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
  }
  return ted;
}","/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param force ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}",0.7314069161534817
182979,"private boolean signaturesMatch(Signature[] storedSigs,Signature[] deviceSigs){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + storedSigs + ""String_Node_Str""+ deviceSigs);
  if ((storedSigs == null || storedSigs.length == 0) && (deviceSigs == null || deviceSigs.length == 0)) {
    return true;
  }
  if (storedSigs == null || deviceSigs == null) {
    return false;
  }
  int nStored=storedSigs.length;
  int nDevice=deviceSigs.length;
  for (int i=0; i < nStored; i++) {
    boolean match=false;
    for (int j=0; j < nDevice; j++) {
      if (storedSigs[i].equals(deviceSigs[j])) {
        match=true;
        break;
      }
    }
    if (!match) {
      return false;
    }
  }
  return true;
}","private boolean signaturesMatch(Signature[] storedSigs,PackageInfo target){
  if ((target.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + target.packageName + ""String_Node_Str"");
    return true;
  }
  Signature[] deviceSigs=target.signatures;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + storedSigs + ""String_Node_Str""+ deviceSigs);
  if ((storedSigs == null || storedSigs.length == 0) && (deviceSigs == null || deviceSigs.length == 0)) {
    return true;
  }
  if (storedSigs == null || deviceSigs == null) {
    return false;
  }
  int nStored=storedSigs.length;
  int nDevice=deviceSigs.length;
  for (int i=0; i < nStored; i++) {
    boolean match=false;
    for (int j=0; j < nDevice; j++) {
      if (storedSigs[i].equals(deviceSigs[j])) {
        match=true;
        break;
      }
    }
    if (!match) {
      return false;
    }
  }
  return true;
}",0.8331273176761433
182980,"private void forceUserActivityLocked(){
  boolean savedActivityAllowed=mUserActivityAllowed;
  mUserActivityAllowed=true;
  userActivity(SystemClock.uptimeMillis(),false);
  mUserActivityAllowed=savedActivityAllowed;
}","private void forceUserActivityLocked(){
  mScreenBrightness.animating=false;
  boolean savedActivityAllowed=mUserActivityAllowed;
  mUserActivityAllowed=true;
  userActivity(SystemClock.uptimeMillis(),false);
  mUserActivityAllowed=savedActivityAllowed;
}",0.9217758985200846
182981,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}",0.7439724454649828
182982,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}",0.7439724454649828
182983,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}",0.7439724454649828
182984,"private VolumeStreamState(String settingName,int streamType){
  mVolumeIndexSettingName=settingName;
  mLastAudibleVolumeIndexSettingName=settingName + System.APPEND_FOR_LAST_AUDIBLE;
  mStreamType=streamType;
  final ContentResolver cr=mContentResolver;
  mIndexMax=MAX_STREAM_VOLUME[streamType];
  mIndex=Settings.System.getInt(cr,mVolumeIndexSettingName,AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
  mLastAudibleIndex=Settings.System.getInt(cr,mLastAudibleVolumeIndexSettingName,(mIndex > 0) ? mIndex : AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
  AudioSystem.initStreamVolume(streamType,0,mIndexMax);
  mIndexMax*=10;
  mIndex=getValidIndex(10 * mIndex);
  mLastAudibleIndex=getValidIndex(10 * mLastAudibleIndex);
  setStreamVolumeIndex(streamType,mIndex);
  mDeathHandlers=new ArrayList<VolumeDeathHandler>();
}","private VolumeStreamState(String settingName,int streamType){
  setVolumeIndexSettingName(settingName);
  mStreamType=streamType;
  final ContentResolver cr=mContentResolver;
  mIndexMax=MAX_STREAM_VOLUME[streamType];
  mIndex=Settings.System.getInt(cr,mVolumeIndexSettingName,AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
  mLastAudibleIndex=Settings.System.getInt(cr,mLastAudibleVolumeIndexSettingName,(mIndex > 0) ? mIndex : AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
  AudioSystem.initStreamVolume(streamType,0,mIndexMax);
  mIndexMax*=10;
  mIndex=getValidIndex(10 * mIndex);
  mLastAudibleIndex=getValidIndex(10 * mLastAudibleIndex);
  setStreamVolumeIndex(streamType,mIndex);
  mDeathHandlers=new ArrayList<VolumeDeathHandler>();
}",0.9428208386277002
182985,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,0,0,mStreamStates[AudioSystem.STREAM_NOTIFICATION],PERSIST_DELAY);
      }
    }
  }
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,0,0,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}",0.863784665579119
182986,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}",0.7439724454649828
182987,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}",0.7439724454649828
182988,"public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mSuspending=false;
  mResuming=false;
}","public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mTargetA2dpState=-1;
}",0.9731506849315068
182989,"public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mResuming+ ""String_Node_Str""+ mSuspending);
  if (mResuming) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_PLAYING:
    if (mSuspending) {
      mResuming=true;
    }
  return true;
case BluetoothA2dp.STATE_CONNECTED:
mResuming=resumeSinkNative(path);
mAudioManager.setParameters(""String_Node_Str"");
return mResuming;
default :
return false;
}
}","public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mTargetA2dpState);
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
  mTargetA2dpState=BluetoothA2dp.STATE_PLAYING;
  return checkSinkSuspendState(state.intValue());
}",0.696140350877193
182990,"public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mSuspending+ ""String_Node_Str""+ mResuming);
  if (mSuspending) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_CONNECTED:
    if (mResuming) {
      mSuspending=true;
    }
  return true;
case BluetoothA2dp.STATE_PLAYING:
mAudioManager.setParameters(""String_Node_Str"");
mSuspending=suspendSinkNative(path);
return mSuspending;
default :
return false;
}
}","public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mTargetA2dpState);
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
  mTargetA2dpState=BluetoothA2dp.STATE_CONNECTED;
  return checkSinkSuspendState(state.intValue());
}",0.6949860724233984
182991,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state == BluetoothA2dp.STATE_DISCONNECTED) {
    mSuspending=false;
    mResuming=false;
  }
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    if (state == BluetoothA2dp.STATE_CONNECTED && prevState == BluetoothA2dp.STATE_PLAYING) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mSuspending) {
        mSuspending=false;
        if (mResuming) {
          mResuming=false;
          resumeSink(device);
        }
      }
    }
    if (state == BluetoothA2dp.STATE_PLAYING && prevState == BluetoothA2dp.STATE_CONNECTED) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mResuming) {
        mResuming=false;
        if (mSuspending) {
          mSuspending=false;
          suspendSink(device);
        }
      }
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.4878378378378378
182992,"public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mSuspending=false;
  mResuming=false;
}","public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mTargetA2dpState=-1;
}",0.9731506849315068
182993,"public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mResuming+ ""String_Node_Str""+ mSuspending);
  if (mResuming) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_PLAYING:
    if (mSuspending) {
      mResuming=true;
    }
  return true;
case BluetoothA2dp.STATE_CONNECTED:
mResuming=resumeSinkNative(path);
mAudioManager.setParameters(""String_Node_Str"");
return mResuming;
default :
return false;
}
}","public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mTargetA2dpState);
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
  mTargetA2dpState=BluetoothA2dp.STATE_PLAYING;
  return checkSinkSuspendState(state.intValue());
}",0.696140350877193
182994,"public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mSuspending+ ""String_Node_Str""+ mResuming);
  if (mSuspending) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_CONNECTED:
    if (mResuming) {
      mSuspending=true;
    }
  return true;
case BluetoothA2dp.STATE_PLAYING:
mAudioManager.setParameters(""String_Node_Str"");
mSuspending=suspendSinkNative(path);
return mSuspending;
default :
return false;
}
}","public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mTargetA2dpState);
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
  mTargetA2dpState=BluetoothA2dp.STATE_CONNECTED;
  return checkSinkSuspendState(state.intValue());
}",0.6949860724233984
182995,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state == BluetoothA2dp.STATE_DISCONNECTED) {
    mSuspending=false;
    mResuming=false;
  }
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    if (state == BluetoothA2dp.STATE_CONNECTED && prevState == BluetoothA2dp.STATE_PLAYING) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mSuspending) {
        mSuspending=false;
        if (mResuming) {
          mResuming=false;
          resumeSink(device);
        }
      }
    }
    if (state == BluetoothA2dp.STATE_PLAYING && prevState == BluetoothA2dp.STATE_CONNECTED) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mResuming) {
        mResuming=false;
        if (mSuspending) {
          mSuspending=false;
          suspendSink(device);
        }
      }
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.4878378378378378
182996,"@Override public void onReceive(Context context,Intent intent){
synchronized (mMethodMap) {
    buildInputMethodListLocked(mMethodList,mMethodMap);
    InputMethodInfo curIm=null;
    String curInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
    final int N=mMethodList.size();
    if (curInputMethodId != null) {
      for (int i=0; i < N; i++) {
        if (mMethodList.get(i).getId().equals(curInputMethodId)) {
          curIm=mMethodList.get(i);
        }
      }
    }
    boolean changed=false;
    Uri uri=intent.getData();
    String pkg=uri != null ? uri.getSchemeSpecificPart() : null;
    if (curIm != null && curIm.getPackageName().equals(pkg)) {
      ServiceInfo si=null;
      try {
        si=mContext.getPackageManager().getServiceInfo(curIm.getComponent(),0);
      }
 catch (      PackageManager.NameNotFoundException ex) {
      }
      if (si == null) {
        Log.i(TAG,""String_Node_Str"" + curInputMethodId);
        List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
        if (enabled != null && enabled.size() > 0) {
          changed=true;
          curIm=enabled.get(0);
          curInputMethodId=curIm.getId();
          Log.i(TAG,""String_Node_Str"" + curInputMethodId);
          Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,curInputMethodId);
        }
 else         if (curIm != null) {
          changed=true;
          curIm=null;
          curInputMethodId=""String_Node_Str"";
          Log.i(TAG,""String_Node_Str"");
          Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,curInputMethodId);
        }
      }
    }
 else     if (curIm == null) {
      List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
      if (enabled != null && enabled.size() > 0) {
        changed=true;
        curIm=enabled.get(0);
        curInputMethodId=curIm.getId();
        Log.i(TAG,""String_Node_Str"" + curInputMethodId);
        Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,curInputMethodId);
      }
    }
    if (changed) {
      updateFromSettingsLocked();
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
synchronized (mMethodMap) {
    buildInputMethodListLocked(mMethodList,mMethodMap);
    InputMethodInfo curIm=null;
    String curInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
    final int N=mMethodList.size();
    if (curInputMethodId != null) {
      for (int i=0; i < N; i++) {
        if (mMethodList.get(i).getId().equals(curInputMethodId)) {
          curIm=mMethodList.get(i);
        }
      }
    }
    boolean changed=false;
    Uri uri=intent.getData();
    String pkg=uri != null ? uri.getSchemeSpecificPart() : null;
    if (curIm != null && curIm.getPackageName().equals(pkg)) {
      ServiceInfo si=null;
      try {
        si=mContext.getPackageManager().getServiceInfo(curIm.getComponent(),0);
      }
 catch (      PackageManager.NameNotFoundException ex) {
      }
      if (si == null) {
        Log.i(TAG,""String_Node_Str"" + curInputMethodId);
        if (!chooseNewDefaultIME()) {
          changed=true;
          curIm=null;
          curInputMethodId=""String_Node_Str"";
          Log.i(TAG,""String_Node_Str"");
          Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,curInputMethodId);
        }
      }
    }
 else     if (curIm == null) {
      changed=chooseNewDefaultIME();
    }
    if (changed) {
      updateFromSettingsLocked();
    }
  }
}",0.6821155943293348
182997,"void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Log.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Log.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Log.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
}","void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Log.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabled(p.getId(),true);
      }
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Log.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Log.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIME()) {
      updateFromSettingsLocked();
    }
  }
}",0.8794763188294186
182998,"MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData;
  if (KeyInputQueue.BAD_TOUCH_HACK) {
    rawData=generateAveragedData(upOrDownPointer,lastNumPointers,nextNumPointers);
  }
 else {
    rawData=mLastData;
  }
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[j + MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[j + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}","MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mSkipLastPointers) {
    mSkipLastPointers=false;
    mLastNumPointers=0;
  }
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData;
  if (KeyInputQueue.BAD_TOUCH_HACK) {
    rawData=generateAveragedData(upOrDownPointer,lastNumPointers,nextNumPointers);
  }
 else {
    rawData=mLastData;
  }
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[j + MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[j + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}",0.991668319777822
182999,"public void run(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Log.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Log.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && ms.mLastNumPointers == 0) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (false)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Log.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Log.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}",0.9957001856738004
183000,"private void latch(){
  if ((mFlags & COLOR) != 0) {
    makeSpace(4);
    mVtxData[mVtxCount++]=mR;
    mVtxData[mVtxCount++]=mG;
    mVtxData[mVtxCount++]=mB;
    mVtxData[mVtxCount++]=mA;
  }
  if ((mFlags & NORMAL) != 0) {
    makeSpace(3);
    mVtxData[mVtxCount++]=mNX;
    mVtxData[mVtxCount++]=mNY;
    mVtxData[mVtxCount++]=mNZ;
  }
  if ((mFlags & TEXTURE_0) != 0) {
    makeSpace(2);
    mVtxData[mVtxCount++]=mS0;
    mVtxData[mVtxCount++]=mT0;
  }
}","private void latch(){
  if ((mFlags & COLOR) != 0) {
    makeSpace(4);
    mVtxData[mVtxCount++]=mR;
    mVtxData[mVtxCount++]=mG;
    mVtxData[mVtxCount++]=mB;
    mVtxData[mVtxCount++]=mA;
  }
  if ((mFlags & TEXTURE_0) != 0) {
    makeSpace(2);
    mVtxData[mVtxCount++]=mS0;
    mVtxData[mVtxCount++]=mT0;
  }
  if ((mFlags & NORMAL) != 0) {
    makeSpace(3);
    mVtxData[mVtxCount++]=mNX;
    mVtxData[mVtxCount++]=mNY;
    mVtxData[mVtxCount++]=mNZ;
  }
}",0.6818181818181818
