record_number,buggy_code,fixed_code,code_similarity
54001,"public Widget asWidget(){
  return this;
}","@Override public Widget asWidget(){
  return this;
}",0.8936170212765957
54002,"public ReportEditView asWidget(){
  return this;
}","@Override public ReportEditView asWidget(){
  return this;
}",0.9090909090909092
54003,"public void start(AcceptsOneWidget display,EventBus eventBus){
  this.display=display;
  view.setDelegate(this);
  view.setCreating(creating);
  if (creating) {
    P tempRecord=requests.create(proxyType);
    stableId=tempRecord.stableId();
    doStart(display,tempRecord);
  }
 else {
    ProxyRequest<P> findRequest=getFindRequest(getRecord().getId());
    findRequest.with(getView().getPaths()).fire(new Receiver<P>(){
      public void onSuccess(      P record,      Set<SyncResult> syncResults){
        if (AbstractProxyEditActivity.this.display != null) {
          doStart(AbstractProxyEditActivity.this.display,record);
        }
      }
    }
);
  }
}","public void start(AcceptsOneWidget display,EventBus eventBus){
  this.display=display;
  view.setDelegate(this);
  view.setCreating(creating);
  if (creating) {
    P tempRecord=requests.create(proxyType);
    stableId=tempRecord.stableId();
    doStart(display,tempRecord);
  }
 else {
    ProxyRequest<P> findRequest=getFindRequest(getRecord().getId());
    findRequest.with(getView().getPaths()).fire(new Receiver<P>(){
      @Override public void onSuccess(      P record,      Set<SyncResult> syncResults){
        if (AbstractProxyEditActivity.this.display != null) {
          doStart(AbstractProxyEditActivity.this.display,record);
        }
      }
    }
);
  }
}",0.992503748125937
54004,"public void onSuccess(P record,Set<SyncResult> syncResults){
  if (AbstractProxyEditActivity.this.display != null) {
    doStart(AbstractProxyEditActivity.this.display,record);
  }
}","@Override public void onSuccess(P record,Set<SyncResult> syncResults){
  if (AbstractProxyEditActivity.this.display != null) {
    doStart(AbstractProxyEditActivity.this.display,record);
  }
}",0.9732620320855616
54005,"public AbstractProxyListView<P> asWidget(){
  return this;
}","@Override public AbstractProxyListView<P> asWidget(){
  return this;
}",0.9230769230769232
54006,"/** 
 * Calls   {@link ValueBoxBase#getValueOrThrow()}. If a   {@link ParseException}is thrown, it will be available through  {@link com.google.gwt.editor.client.EditorError#getUserData() EditorError.getUserData()}.
 */
public T getValue(){
  try {
    value=peer.getValueOrThrow();
  }
 catch (  ParseException e) {
    getDelegate().recordError(""String_Node_Str"" + peer.getText() + ""String_Node_Str"",peer.getText(),e);
  }
  return value;
}","/** 
 * Calls   {@link ValueBoxBase#getValueOrThrow()}. If a   {@link ParseException}is thrown, it will be available through  {@link com.google.gwt.editor.client.EditorError#getUserData() EditorError.getUserData()}.
 */
@Override public T getValue(){
  try {
    value=peer.getValueOrThrow();
  }
 catch (  ParseException e) {
    getDelegate().recordError(""String_Node_Str"" + peer.getText() + ""String_Node_Str"",peer.getText(),e);
  }
  return value;
}",0.988814317673378
54007,"public void setValue(T value){
  peer.setValue(this.value=value);
}","@Override public void setValue(T value){
  peer.setValue(this.value=value);
}",0.9305555555555556
54008,"/** 
 * For debugging use only.
 */
public String toString(){
  return path + ""String_Node_Str"" + type.getParameterizedQualifiedSourceName();
}","/** 
 * For debugging use only.
 */
@Override public String toString(){
  return path + ""String_Node_Str"" + type.getParameterizedQualifiedSourceName();
}",0.9662162162162162
54009,"/** 
 * Process a child element that should be added using a   {@link UiChild} method
 */
private void handleChild(XMLElement child) throws UnableToCompleteException {
  String tag=child.getLocalName();
  Pair<JMethod,Integer> methodPair=uiChildMethods.get(tag);
  JMethod method=methodPair.left;
  int limit=methodPair.right;
  Iterator<XMLElement> children=child.consumeChildElements().iterator();
  if (!children.hasNext()) {
    return;
  }
  XMLElement toAdd=children.next();
  if (!writer.isWidgetElement(toAdd)) {
    writer.die(child,""String_Node_Str"",child);
  }
  if (children.hasNext()) {
    writer.die(toAdd,""String_Node_Str"");
  }
  checkLimit(limit,tag,toAdd);
  String[] parameters=makeArgsList(child,method,toAdd);
  writer.addStatement(""String_Node_Str"",fieldName,method.getName(),UiBinderWriter.asCommaSeparatedList(parameters));
}","/** 
 * Process a child element that should be added using a   {@link UiChild} method.
 */
private void handleChild(XMLElement child) throws UnableToCompleteException {
  String tag=child.getLocalName();
  Pair<JMethod,Integer> methodPair=uiChildMethods.get(tag);
  JMethod method=methodPair.left;
  int limit=methodPair.right;
  Iterator<XMLElement> children=child.consumeChildElements().iterator();
  if (!children.hasNext()) {
    return;
  }
  XMLElement toAdd=children.next();
  if (!writer.isWidgetElement(toAdd)) {
    writer.die(child,""String_Node_Str"",child);
  }
  if (children.hasNext()) {
    writer.die(toAdd,""String_Node_Str"");
  }
  checkLimit(limit,tag,toAdd);
  String[] parameters=makeArgsList(child,method,toAdd);
  writer.addStatement(""String_Node_Str"",fieldName,method.getName(),UiBinderWriter.asCommaSeparatedList(parameters));
}",0.9994121105232217
54010,"/** 
 * Scans the class to find all methods annotated with @UiChild
 * @param ownerType the type of the owner class
 * @throws UnableToCompleteException
 */
private void findUiChildren(JClassType ownerType) throws UnableToCompleteException {
  JMethod[] methods=ownerType.getMethods();
  while (ownerType != null) {
    for (    JMethod method : methods) {
      UiChild annotation=method.getAnnotation(UiChild.class);
      if (annotation != null) {
        String tag=annotation.tagname();
        int limit=annotation.limit();
        if (tag.equals(""String_Node_Str"")) {
          String name=method.getName();
          if (name.startsWith(""String_Node_Str"")) {
            tag=name.substring(3).toLowerCase();
          }
 else {
            logger.die(method.getName() + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        uiChildren.put(tag,Pair.create(method,limit));
      }
    }
    ownerType=ownerType.getSuperclass();
  }
}","/** 
 * Scans the class to find all methods annotated with @UiChild.
 * @param ownerType the type of the owner class
 * @throws UnableToCompleteException
 */
private void findUiChildren(JClassType ownerType) throws UnableToCompleteException {
  JMethod[] methods=ownerType.getMethods();
  while (ownerType != null) {
    for (    JMethod method : methods) {
      UiChild annotation=method.getAnnotation(UiChild.class);
      if (annotation != null) {
        String tag=annotation.tagname();
        int limit=annotation.limit();
        if (tag.equals(""String_Node_Str"")) {
          String name=method.getName();
          if (name.startsWith(""String_Node_Str"")) {
            tag=name.substring(3).toLowerCase();
          }
 else {
            logger.die(method.getName() + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
        uiChildren.put(tag,Pair.create(method,limit));
      }
    }
    ownerType=ownerType.getSuperclass();
  }
}",0.999476713762428
54011,"/** 
 * Gets the panel's child widget.
 * @return the child widget, or <code>null</code> if none is present
 */
public Widget getWidget();","/** 
 * Gets the panel's child widget.
 * @return the child widget, or <code>null</code> if none is present
 */
Widget getWidget();",0.9739776951672864
54012,"/** 
 * Sets this panel's widget. Any existing child widget will be removed.
 * @param w the panel's new widget, or <code>null</code> to clear the panel
 */
public void setWidget(Widget w);","/** 
 * Sets this panel's widget. Any existing child widget will be removed.
 * @param w the panel's new widget, or <code>null</code> to clear the panel
 */
void setWidget(Widget w);",0.981132075471698
54013,"/** 
 * Validates all constraints placed on the property named <code>propertyName</code> of the class <code>beanType</code> would the property value be <code>value</code> <p/> <code>ConstraintViolation</code> objects return null for  {@link ConstraintViolation#getRootBean()} and{@link ConstraintViolation#getLeafBean()}
 * @param < T > the type of the RootBean for this validation context
 * @param context The gwt validation context
 * @param beanType the bean type
 * @param propertyName property to validate
 * @param value property value to validate
 * @param groups group or list of groups targeted for validation (default to{@link javax.validation.groups.Default})
 * @return constraint violations or an empty Set if none
 * @throws IllegalArgumentException if <code>beanType</code> is null, if<code>propertyName</code> null, empty or not a valid object property or if null is passed to the varargs groups
 * @throws ValidationException if a non recoverable error happens during thevalidation process
 */
<T>Set<ConstraintViolation<T>> validateValue(GwtValidationContext<T> context,Class<G> beanType,String propertyName,Object value,Class<?>... groups) throws ValidationException ;","/** 
 * Validates all constraints placed on the property named <code>propertyName</code> of the class <code>beanType</code> where the property value is <code>value</code>. <p/> <code>ConstraintViolation</code> objects return null for  {@link ConstraintViolation#getRootBean()} and{@link ConstraintViolation#getLeafBean()}
 * @param < T > the type of the RootBean for this validation context
 * @param context The gwt validation context
 * @param beanType the bean type
 * @param propertyName property to validate
 * @param value property value to validate
 * @param groups group or list of groups targeted for validation (default to{@link javax.validation.groups.Default})
 * @return constraint violations or an empty Set if none
 * @throws IllegalArgumentException if <code>beanType</code> is null, if<code>propertyName</code> null, empty or not a valid object property or if null is passed to the varargs groups
 * @throws ValidationException if a non recoverable error happens during thevalidation process
 */
<T>Set<ConstraintViolation<T>> validateValue(GwtValidationContext<T> context,Class<G> beanType,String propertyName,Object value,Class<?>... groups) throws ValidationException ;",0.9777029869583508
54014,"public final String create(){
  SourceWriter sourceWriter=getSourceWriter(logger,context);
  if (sourceWriter != null) {
    writeClassBody(sourceWriter);
    sourceWriter.commit(logger);
  }
  return getQaulifiedName();
}","public final String create(){
  SourceWriter sourceWriter=getSourceWriter(logger,context);
  if (sourceWriter != null) {
    writeClassBody(sourceWriter);
    sourceWriter.commit(logger);
  }
  return getQualifiedName();
}",0.990990990990991
54015,"private final String getSimpleName(){
  return validatorType.getSimpleSourceName() + ""String_Node_Str"";
}","private String getSimpleName(){
  return validatorType.getSimpleSourceName() + ""String_Node_Str"";
}",0.9705882352941176
54016,"private final SourceWriter getSourceWriter(TreeLogger logger,GeneratorContext ctx){
  String packageName=getPackage();
  String simpleName=getSimpleName();
  PrintWriter printWriter=ctx.tryCreate(logger,packageName,simpleName);
  if (printWriter == null) {
    return null;
  }
  ClassSourceFileComposerFactory composerFactory=new ClassSourceFileComposerFactory(packageName,simpleName);
  compose(composerFactory);
  SourceWriter sourceWriter=composerFactory.createSourceWriter(ctx,printWriter);
  return sourceWriter;
}","private SourceWriter getSourceWriter(TreeLogger logger,GeneratorContext ctx){
  String packageName=getPackage();
  String simpleName=getSimpleName();
  PrintWriter printWriter=ctx.tryCreate(logger,packageName,simpleName);
  if (printWriter == null) {
    return null;
  }
  ClassSourceFileComposerFactory composerFactory=new ClassSourceFileComposerFactory(packageName,simpleName);
  compose(composerFactory);
  SourceWriter sourceWriter=composerFactory.createSourceWriter(ctx,printWriter);
  return sourceWriter;
}",0.9941972920696324
54017,"public void onWindowClosing(ClosingEvent event){
  StringBuilder sb=new StringBuilder();
  for (  EntityProxyId id : favoriteIds) {
    sb.append(id.asString()).append(""String_Node_Str"");
  }
  Cookies.setCookie(COOKIE_NAME,sb.toString());
}","public void onWindowClosing(ClosingEvent event){
  StringBuilder sb=new StringBuilder();
  for (  EntityProxyId id : favoriteIds) {
    sb.append(requestFactory.getHistoryToken(id)).append(""String_Node_Str"");
  }
  Cookies.setCookie(COOKIE_NAME,sb.toString());
}",0.9105367793240556
54018,"public FavoritesManager(RequestFactory requestFactory){
  String cookie=Cookies.getCookie(COOKIE_NAME);
  if (cookie != null) {
    try {
      for (      String fragment : cookie.split(""String_Node_Str"")) {
        if (fragment.length() == 0) {
          continue;
        }
        EntityProxyId id=requestFactory.getProxyId(fragment);
        favoriteIds.add(id);
      }
    }
 catch (    NumberFormatException e) {
      favoriteIds.clear();
    }
  }
  Window.addWindowClosingHandler(new ClosingHandler(){
    public void onWindowClosing(    ClosingEvent event){
      StringBuilder sb=new StringBuilder();
      for (      EntityProxyId id : favoriteIds) {
        sb.append(id.asString()).append(""String_Node_Str"");
      }
      Cookies.setCookie(COOKIE_NAME,sb.toString());
    }
  }
);
}","public FavoritesManager(final RequestFactory requestFactory){
  String cookie=Cookies.getCookie(COOKIE_NAME);
  if (cookie != null) {
    try {
      for (      String fragment : cookie.split(""String_Node_Str"")) {
        if (fragment.length() == 0) {
          continue;
        }
        EntityProxyId id=requestFactory.getProxyId(fragment);
        favoriteIds.add(id);
      }
    }
 catch (    NumberFormatException e) {
      favoriteIds.clear();
    }
  }
  Window.addWindowClosingHandler(new ClosingHandler(){
    public void onWindowClosing(    ClosingEvent event){
      StringBuilder sb=new StringBuilder();
      for (      EntityProxyId id : favoriteIds) {
        sb.append(requestFactory.getHistoryToken(id)).append(""String_Node_Str"");
      }
      Cookies.setCookie(COOKIE_NAME,sb.toString());
    }
  }
);
}",0.9685767097966728
54019,"@UiHandler(""String_Node_Str"") void onSave(ClickEvent e){
  final RequestObject<Void> request=editorDriver.<Void>flush();
  if (editorDriver.hasErrors()) {
    dialog.setText(""String_Node_Str"");
    return;
  }
  request.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void response,    Set<SyncResult> syncResults){
      dialog.hide();
    }
    @Override public void onViolation(    Set<Violation> errors){
      dialog.setText(""String_Node_Str"");
      editorDriver.setViolations(errors);
    }
  }
);
}","@UiHandler(""String_Node_Str"") void onSave(ClickEvent e){
  final RequestObject<Void> request=editorDriver.<Void>flush();
  if (editorDriver.hasErrors()) {
    dialog.setText(""String_Node_Str"");
    return;
  }
  request.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void response){
      dialog.hide();
    }
    @Override public void onViolation(    Set<Violation> errors){
      dialog.setText(""String_Node_Str"");
      editorDriver.setViolations(errors);
    }
  }
);
}",0.9685658153241652
54020,"private void edit(){
  ProxyRequest<PersonProxy> fetchRequest=requestFactory.personRequest().findPerson(person.getId());
  editorDriver=GWT.create(Driver.class);
  editorDriver.initialize(null,requestFactory,personEditor);
  fetchRequest.with(editorDriver.getPaths());
  fetchRequest.fire(new Receiver<PersonProxy>(){
    public void onSuccess(    PersonProxy person,    Set<SyncResult> syncResults){
      editorDriver.edit(person,requestFactory.personRequest().persist(person));
      personEditor.focus();
    }
  }
);
  favorite.setValue(manager.isFavorite(person),false);
  dialog.center();
}","private void edit(){
  ProxyRequest<PersonProxy> fetchRequest=requestFactory.personRequest().findPerson(person.getId());
  editorDriver=GWT.create(Driver.class);
  editorDriver.initialize(null,requestFactory,personEditor);
  fetchRequest.with(editorDriver.getPaths());
  fetchRequest.fire(new Receiver<PersonProxy>(){
    @Override public void onSuccess(    PersonProxy person){
      editorDriver.edit(person,requestFactory.personRequest().persist(person));
      personEditor.focus();
    }
  }
);
  favorite.setValue(manager.isFavorite(person),false);
  dialog.center();
}",0.6296928327645052
54021,"public void onSuccess(PersonProxy person,Set<SyncResult> syncResults){
  editorDriver.edit(person,requestFactory.personRequest().persist(person));
  personEditor.focus();
}","@Override public void onSuccess(PersonProxy person){
  editorDriver.edit(person,requestFactory.personRequest().persist(person));
  personEditor.focus();
}",0.8834355828220859
54022,"@Override protected void onLoad(){
  subscription=manager.addMarkFavoriteHandler(new MarkFavoriteEvent.Handler(){
    public void onMarkFavorite(    MarkFavoriteEvent event){
      FavoritesWidget.this.onMarkFavorite(event);
    }
  }
);
  for (  EntityProxyId id : manager.getFavoriteIds()) {
    factory.find(id).fire(new Receiver<EntityProxy>(){
      public void onSuccess(      EntityProxy response,      Set<SyncResult> syncResults){
        PersonProxy person=(PersonProxy)response;
        onMarkFavorite(new MarkFavoriteEvent(person,true));
      }
    }
);
  }
}","@Override protected void onLoad(){
  subscription=manager.addMarkFavoriteHandler(new MarkFavoriteEvent.Handler(){
    public void onMarkFavorite(    MarkFavoriteEvent event){
      FavoritesWidget.this.onMarkFavorite(event);
    }
  }
);
  for (  EntityProxyId id : manager.getFavoriteIds()) {
    factory.find(id).fire(new Receiver<EntityProxy>(){
      @Override public void onSuccess(      EntityProxy response){
        PersonProxy person=(PersonProxy)response;
        onMarkFavorite(new MarkFavoriteEvent(person,true));
      }
    }
);
  }
}",0.7517857142857143
54023,"public void onSuccess(EntityProxy response,Set<SyncResult> syncResults){
  PersonProxy person=(PersonProxy)response;
  onMarkFavorite(new MarkFavoriteEvent(person,true));
}","@Override public void onSuccess(EntityProxy response){
  PersonProxy person=(PersonProxy)response;
  onMarkFavorite(new MarkFavoriteEvent(person,true));
}",0.8834355828220859
54024,"private void fetch(final int start){
  requestFactory.schoolCalendarRequest().getPeople(start,numRows).fire(new Receiver<List<PersonProxy>>(){
    public void onSuccess(    List<PersonProxy> response,    Set<SyncResult> syncResults){
      int responses=response.size();
      table.setRowData(start,response);
      if (!table.isRowCountExact()) {
        table.setRowCount(start + responses,responses < numRows);
      }
    }
  }
);
}","private void fetch(final int start){
  requestFactory.schoolCalendarRequest().getPeople(start,numRows).fire(new Receiver<List<PersonProxy>>(){
    @Override public void onSuccess(    List<PersonProxy> response){
      int responses=response.size();
      table.setRowData(start,response);
      if (!table.isRowCountExact()) {
        table.setRowCount(start + responses,responses < numRows);
      }
    }
  }
);
}",0.9507042253521126
54025,"void onPersonChanged(EntityProxyChange<PersonProxy> event){
  if (WriteOperation.UPDATE.equals(event.getWriteOperation())) {
    PersonProxy record=event.getProxy();
    int displayOffset=offsetOf(record);
    if (displayOffset != -1) {
      requestFactory.personRequest().findPerson(record.getId()).fire(new Receiver<PersonProxy>(){
        public void onSuccess(        PersonProxy response,        Set<SyncResult> syncResults){
          int offset=offsetOf(response);
          if (offset != -1) {
            table.setRowData(table.getPageStart() + offset,Collections.singletonList(response));
          }
        }
      }
);
    }
  }
}","void onPersonChanged(EntityProxyChange<PersonProxy> event){
  if (WriteOperation.UPDATE.equals(event.getWriteOperation())) {
    PersonProxy record=event.getProxy();
    int displayOffset=offsetOf(record);
    if (displayOffset != -1) {
      requestFactory.personRequest().findPerson(record.getId()).fire(new Receiver<PersonProxy>(){
        @Override public void onSuccess(        PersonProxy response){
          int offset=offsetOf(response);
          if (offset != -1) {
            table.setRowData(table.getPageStart() + offset,Collections.singletonList(response));
          }
        }
      }
);
    }
  }
}",0.9635499207606972
54026,"public void onSuccess(List<PersonProxy> response,Set<SyncResult> syncResults){
  int responses=response.size();
  table.setRowData(start,response);
  if (!table.isRowCountExact()) {
    table.setRowCount(start + responses,responses < numRows);
  }
}","@Override public void onSuccess(List<PersonProxy> response){
  int responses=response.size();
  table.setRowData(start,response);
  if (!table.isRowCountExact()) {
    table.setRowCount(start + responses,responses < numRows);
  }
}",0.9208333333333332
54027,"/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  lastReceiver=new Receiver<List<ExpenseProxy>>(){
    @Override public void onSuccess(    List<ExpenseProxy> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        List<ExpenseProxy> list=new ArrayList<ExpenseProxy>(newValues);
        if (lastComparator != null) {
          sortExpenses(list,lastComparator);
        }
        items.setList(list);
        refreshCost();
        boolean isInitialData=knownExpenseKeys == null;
        if (knownExpenseKeys == null) {
          knownExpenseKeys=new HashMap<Object,ExpenseProxy>();
        }
        for (        ExpenseProxy value : newValues) {
          Object key=items.getKey(value);
          if (!isInitialData) {
            ExpenseProxy existing=knownExpenseKeys.get(key);
            if (existing == null || !value.getAmount().equals(existing.getAmount()) || !value.getDescription().equals(existing.getDescription()) || !value.getCategory().equals(existing.getCategory())) {
              (new PhaseAnimation.CellTablePhaseAnimation<ExpenseProxy>(table,value,items)).run();
            }
          }
          knownExpenseKeys.put(key,value);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  expensesRequestFactory.expenseRequest().findExpensesByReport(report.getId()).with(getExpenseColumns()).fire(lastReceiver);
}","/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  lastReceiver=new Receiver<List<ExpenseProxy>>(){
    @Override public void onSuccess(    List<ExpenseProxy> newValues){
      if (this == lastReceiver) {
        List<ExpenseProxy> list=new ArrayList<ExpenseProxy>(newValues);
        if (lastComparator != null) {
          sortExpenses(list,lastComparator);
        }
        items.setList(list);
        refreshCost();
        boolean isInitialData=knownExpenseKeys == null;
        if (knownExpenseKeys == null) {
          knownExpenseKeys=new HashMap<Object,ExpenseProxy>();
        }
        for (        ExpenseProxy value : newValues) {
          Object key=items.getKey(value);
          if (!isInitialData) {
            ExpenseProxy existing=knownExpenseKeys.get(key);
            if (existing == null || !value.getAmount().equals(existing.getAmount()) || !value.getDescription().equals(existing.getDescription()) || !value.getCategory().equals(existing.getCategory())) {
              (new PhaseAnimation.CellTablePhaseAnimation<ExpenseProxy>(table,value,items)).run();
            }
          }
          knownExpenseKeys.put(key,value);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  expensesRequestFactory.expenseRequest().findExpensesByReport(report.getId()).with(getExpenseColumns()).fire(lastReceiver);
}",0.9886765746638358
54028,"/** 
 * Save the notes that the user entered in the notes box.
 */
private void saveNotes(){
  final String pendingNotes=notesBox.getText();
  if (pendingNotes.equals(report.getNotes())) {
    setNotesEditState(false,false,pendingNotes);
    return;
  }
  setNotesEditState(false,true,pendingNotes);
  RequestObject<Void> editRequest=expensesRequestFactory.reportRequest().persist(report);
  ReportProxy editableReport=editRequest.edit(report);
  editableReport.setNotes(pendingNotes);
  editRequest.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=getErrorMessageFromSync(response);
      if (errorMessage.length() > 0) {
        showErrorPopup(errorMessage);
        setNotesEditState(false,false,report.getNotes());
      }
    }
  }
);
}","/** 
 * Save the notes that the user entered in the notes box.
 */
private void saveNotes(){
  final String pendingNotes=notesBox.getText();
  if (pendingNotes.equals(report.getNotes())) {
    setNotesEditState(false,false,pendingNotes);
    return;
  }
  setNotesEditState(false,true,pendingNotes);
  RequestObject<Void> editRequest=expensesRequestFactory.reportRequest().persist(report);
  ReportProxy editableReport=editRequest.edit(report);
  editableReport.setNotes(pendingNotes);
  editRequest.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore){
    }
  }
);
}",0.8320449754040758
54029,"public void onReportChanged(EntityProxyChange<ReportProxy> event){
  ReportProxy changed=event.getProxy();
  if (report != null && report.getId().equals(changed.getId())) {
    expensesRequestFactory.reportRequest().findReport(report.getId()).fire(new Receiver<ReportProxy>(){
      @Override public void onSuccess(      ReportProxy response,      Set<SyncResult> syncResults){
        report=response;
        setNotesEditState(false,false,response.getNotes());
      }
    }
);
  }
}","public void onReportChanged(EntityProxyChange<ReportProxy> event){
  ReportProxy changed=event.getProxy();
  if (report != null && report.getId().equals(changed.getId())) {
    expensesRequestFactory.reportRequest().findReport(report.getId()).fire(new Receiver<ReportProxy>(){
      @Override public void onSuccess(      ReportProxy response){
        report=response;
        setNotesEditState(false,false,response.getNotes());
      }
    }
);
  }
}",0.9636752136752136
54030,"private void updateExpenseRecord(final ExpenseProxy record,String approval,String reasonDenied){
  if (Expenses.Approval.APPROVED.is(approval) && !Expenses.Approval.APPROVED.is(record.getApproval())) {
    double amount=record.getAmount();
    if (amount + totalApproved > MAX_COST) {
      syncCommit(record,""String_Node_Str"" + MAX_COST + ""String_Node_Str"");
      return;
    }
  }
  RequestObject<Void> editRequest=expensesRequestFactory.expenseRequest().persist(record);
  ExpenseProxy editableRecord=editRequest.edit(record);
  editableRecord.setApproval(approval);
  editableRecord.setReasonDenied(reasonDenied);
  editRequest.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore,    Set<SyncResult> response){
      String errorMessage=getErrorMessageFromSync(response);
      if (errorMessage.length() > 0) {
        syncCommit(record,errorMessage.length() > 0 ? errorMessage : null);
      }
    }
  }
);
}","private void updateExpenseRecord(final ExpenseProxy record,String approval,String reasonDenied){
  if (Expenses.Approval.APPROVED.is(approval) && !Expenses.Approval.APPROVED.is(record.getApproval())) {
    double amount=record.getAmount();
    if (amount + totalApproved > MAX_COST) {
      syncCommit(record,""String_Node_Str"" + MAX_COST + ""String_Node_Str"");
      return;
    }
  }
  RequestObject<Void> editRequest=expensesRequestFactory.expenseRequest().persist(record);
  ExpenseProxy editableRecord=editRequest.edit(record);
  editableRecord.setApproval(approval);
  editableRecord.setReasonDenied(reasonDenied);
  editRequest.fire(new Receiver<Void>(){
    @Override public void onSuccess(    Void ignore){
    }
  }
);
}",0.8651887357699221
54031,"@Override public void onSuccess(Void ignore,Set<SyncResult> response){
  String errorMessage=getErrorMessageFromSync(response);
  if (errorMessage.length() > 0) {
    syncCommit(record,errorMessage.length() > 0 ? errorMessage : null);
  }
}","@Override public void onSuccess(Void ignore){
}",0.3275261324041811
54032,"/** 
 * Send a request for reports in the current range.
 * @param isPolling true if this request is caused by polling
 */
private void requestReports(boolean isPolling){
  refreshTimer.cancel();
  if (requestFactory == null) {
    return;
  }
  if (!isPolling) {
    knownReportKeys=null;
  }
  String startsWith=startsWithSearch;
  if (startsWith == null || searchBox.getDefaultText().equals(startsWith)) {
    startsWith=""String_Node_Str"";
  }
  Range range=table.getVisibleRange();
  Long employeeId=employee == null ? -1 : new Long(employee.getId());
  String dept=department == null ? ""String_Node_Str"" : department;
  if (startsWith.length() > 0) {
    for (    SortableHeader header : allHeaders) {
      header.setSorted(false);
      header.setReverseSort(false);
    }
    table.redrawHeaders();
  }
  if (isCountStale) {
    isCountStale=false;
    if (!isPolling) {
      pager.startLoading();
    }
    lastDataSizeReceiver=new Receiver<Long>(){
      @Override public void onSuccess(      Long response,      Set<SyncResult> syncResults){
        if (this == lastDataSizeReceiver) {
          int count=response.intValue();
          reports.updateRowCount(count,count != 1000);
        }
      }
    }
;
    requestFactory.reportRequest().countReportsBySearch(employeeId,dept,startsWith).fire(lastDataSizeReceiver);
  }
  lastDataReceiver=new Receiver<List<ReportProxy>>(){
    @Override public void onSuccess(    List<ReportProxy> newValues,    Set<SyncResult> syncResults){
      if (this == lastDataReceiver) {
        int size=newValues.size();
        if (size < table.getPageSize()) {
          reports.updateRowCount(table.getPageStart() + size,true);
        }
        if (size > 0) {
          reports.updateRowData(table.getPageStart(),newValues);
        }
        boolean isInitialData=knownReportKeys == null;
        if (knownReportKeys == null) {
          knownReportKeys=new HashSet<Object>();
        }
        for (        ReportProxy value : newValues) {
          Object key=reports.getKey(value);
          if (!isInitialData && !knownReportKeys.contains(key)) {
            (new PhaseAnimation.CellTablePhaseAnimation<ReportProxy>(table,value,reports)).run();
          }
          knownReportKeys.add(key);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employeeId,dept,startsWith,orderBy,range.getStart(),range.getLength()).with(reportColumns).fire(lastDataReceiver);
}","/** 
 * Send a request for reports in the current range.
 * @param isPolling true if this request is caused by polling
 */
private void requestReports(boolean isPolling){
  refreshTimer.cancel();
  if (requestFactory == null) {
    return;
  }
  if (!isPolling) {
    knownReportKeys=null;
  }
  String startsWith=startsWithSearch;
  if (startsWith == null || searchBox.getDefaultText().equals(startsWith)) {
    startsWith=""String_Node_Str"";
  }
  Range range=table.getVisibleRange();
  Long employeeId=employee == null ? -1 : new Long(employee.getId());
  String dept=department == null ? ""String_Node_Str"" : department;
  if (startsWith.length() > 0) {
    for (    SortableHeader header : allHeaders) {
      header.setSorted(false);
      header.setReverseSort(false);
    }
    table.redrawHeaders();
  }
  if (isCountStale) {
    isCountStale=false;
    if (!isPolling) {
      pager.startLoading();
    }
    lastDataSizeReceiver=new Receiver<Long>(){
      @Override public void onSuccess(      Long response){
        if (this == lastDataSizeReceiver) {
          int count=response.intValue();
          reports.updateRowCount(count,count != 1000);
        }
      }
    }
;
    requestFactory.reportRequest().countReportsBySearch(employeeId,dept,startsWith).fire(lastDataSizeReceiver);
  }
  lastDataReceiver=new Receiver<List<ReportProxy>>(){
    @Override public void onSuccess(    List<ReportProxy> newValues){
      if (this == lastDataReceiver) {
        int size=newValues.size();
        if (size < table.getPageSize()) {
          reports.updateRowCount(table.getPageStart() + size,true);
        }
        if (size > 0) {
          reports.updateRowData(table.getPageStart(),newValues);
        }
        boolean isInitialData=knownReportKeys == null;
        if (knownReportKeys == null) {
          knownReportKeys=new HashSet<Object>();
        }
        for (        ReportProxy value : newValues) {
          Object key=reports.getKey(value);
          if (!isInitialData && !knownReportKeys.contains(key)) {
            (new PhaseAnimation.CellTablePhaseAnimation<ReportProxy>(table,value,reports)).run();
          }
          knownReportKeys.add(key);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employeeId,dept,startsWith,orderBy,range.getStart(),range.getLength()).with(reportColumns).fire(lastDataReceiver);
}",0.98661800486618
54033,"@Override public void onSuccess(List<ReportProxy> newValues,Set<SyncResult> syncResults){
  if (this == lastDataReceiver) {
    int size=newValues.size();
    if (size < table.getPageSize()) {
      reports.updateRowCount(table.getPageStart() + size,true);
    }
    if (size > 0) {
      reports.updateRowData(table.getPageStart(),newValues);
    }
    boolean isInitialData=knownReportKeys == null;
    if (knownReportKeys == null) {
      knownReportKeys=new HashSet<Object>();
    }
    for (    ReportProxy value : newValues) {
      Object key=reports.getKey(value);
      if (!isInitialData && !knownReportKeys.contains(key)) {
        (new PhaseAnimation.CellTablePhaseAnimation<ReportProxy>(table,value,reports)).run();
      }
      knownReportKeys.add(key);
    }
  }
  refreshTimer.schedule(REFRESH_INTERVAL);
}","@Override public void onSuccess(List<ReportProxy> newValues){
  if (this == lastDataReceiver) {
    int size=newValues.size();
    if (size < table.getPageSize()) {
      reports.updateRowCount(table.getPageStart() + size,true);
    }
    if (size > 0) {
      reports.updateRowData(table.getPageStart(),newValues);
    }
    boolean isInitialData=knownReportKeys == null;
    if (knownReportKeys == null) {
      knownReportKeys=new HashSet<Object>();
    }
    for (    ReportProxy value : newValues) {
      Object key=reports.getKey(value);
      if (!isInitialData && !knownReportKeys.contains(key)) {
        (new PhaseAnimation.CellTablePhaseAnimation<ReportProxy>(table,value,reports)).run();
      }
      knownReportKeys.add(key);
    }
  }
  refreshTimer.schedule(REFRESH_INTERVAL);
}",0.9826946847960444
54034,"@Override protected void onRangeChanged(HasData<EmployeeProxy> view){
  Range range=view.getVisibleRange();
  requestFactory.employeeRequest().findEmployeeEntriesByDepartment(department,range.getStart(),range.getLength()).with(getEmployeeMenuProperties()).fire(new Receiver<List<EmployeeProxy>>(){
    @Override public void onSuccess(    List<EmployeeProxy> response,    Set<SyncResult> syncResults){
      updateRowData(0,response);
    }
  }
);
}","@Override protected void onRangeChanged(HasData<EmployeeProxy> view){
  Range range=view.getVisibleRange();
  requestFactory.employeeRequest().findEmployeeEntriesByDepartment(department,range.getStart(),range.getLength()).with(getEmployeeMenuProperties()).fire(new Receiver<List<EmployeeProxy>>(){
    @Override public void onSuccess(    List<EmployeeProxy> response){
      updateRowData(0,response);
    }
  }
);
}",0.9629629629629628
54035,"@Override public void addDataDisplay(HasData<EmployeeProxy> display){
  super.addDataDisplay(display);
  requestFactory.employeeRequest().countEmployeesByDepartment(department).fire(new Receiver<Long>(){
    @Override public void onSuccess(    Long response,    Set<SyncResult> syncResults){
      updateRowCount(response.intValue(),true);
    }
  }
);
}","@Override public void addDataDisplay(HasData<EmployeeProxy> display){
  super.addDataDisplay(display);
  requestFactory.employeeRequest().countEmployeesByDepartment(department).fire(new Receiver<Long>(){
    @Override public void onSuccess(    Long response){
      updateRowCount(response.intValue(),true);
    }
  }
);
}",0.9526627218934912
54036,"@Override public void onSuccess(List<EmployeeProxy> response,Set<SyncResult> syncResults){
  updateRowData(0,response);
}","@Override public void onSuccess(List<EmployeeProxy> response){
  updateRowData(0,response);
}",0.8691588785046729
54037,"public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  final EventBus eventBus=new SimpleEventBus();
  requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  RootLayoutPanel root=RootLayoutPanel.get();
  shell=new ExpensesShell();
  final ExpenseTree expenseTree=shell.getExpenseTree();
  final ExpenseList expenseList=shell.getExpenseList();
  final ExpenseDetails expenseDetails=shell.getExpenseDetails();
  root.add(shell);
  RequestEvent.register(eventBus,new AuthenticationFailureHandler());
  final LoginWidget login=shell.getLoginWidget();
  Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
    @Override public void onSuccess(    UserInformationProxy userInformationRecord,    Set<SyncResult> syncResults){
      login.setUserInformation(userInformationRecord);
    }
  }
;
  requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
  expenseTree.setListener(new ExpenseTree.Listener(){
    public void onSelection(    String department,    EmployeeProxy employee){
      lastDepartment=department;
      lastEmployee=employee;
      expenseList.setEmployee(department,employee);
      shell.showExpenseDetails(false);
    }
  }
);
  expenseTree.setRequestFactory(requestFactory);
  expenseList.setListener(new ExpenseList.Listener(){
    public void onReportSelected(    ReportProxy report){
      expenseDetails.setExpensesRequestFactory(requestFactory);
      expenseDetails.setReportRecord(report,lastDepartment,lastEmployee);
      shell.showExpenseDetails(true);
    }
  }
);
  expenseList.init(requestFactory,eventBus);
  expenseDetails.init(eventBus);
}","public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  final EventBus eventBus=new SimpleEventBus();
  requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  RootLayoutPanel root=RootLayoutPanel.get();
  shell=new ExpensesShell();
  final ExpenseTree expenseTree=shell.getExpenseTree();
  final ExpenseList expenseList=shell.getExpenseList();
  final ExpenseDetails expenseDetails=shell.getExpenseDetails();
  root.add(shell);
  RequestEvent.register(eventBus,new AuthenticationFailureHandler());
  final LoginWidget login=shell.getLoginWidget();
  Receiver<UserInformationProxy> receiver=new Receiver<UserInformationProxy>(){
    @Override public void onSuccess(    UserInformationProxy userInformationRecord){
      login.setUserInformation(userInformationRecord);
    }
  }
;
  requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
  expenseTree.setListener(new ExpenseTree.Listener(){
    public void onSelection(    String department,    EmployeeProxy employee){
      lastDepartment=department;
      lastEmployee=employee;
      expenseList.setEmployee(department,employee);
      shell.showExpenseDetails(false);
    }
  }
);
  expenseTree.setRequestFactory(requestFactory);
  expenseList.setListener(new ExpenseList.Listener(){
    public void onReportSelected(    ReportProxy report){
      expenseDetails.setExpensesRequestFactory(requestFactory);
      expenseDetails.setReportRecord(report,lastDepartment,lastEmployee);
      shell.showExpenseDetails(true);
    }
  }
);
  expenseList.init(requestFactory,eventBus);
  expenseDetails.init(eventBus);
}",0.5229257641921398
54038,"@Override public void onSuccess(UserInformationProxy userInformationRecord,Set<SyncResult> syncResults){
  login.setUserInformation(userInformationRecord);
}","@Override public void onSuccess(UserInformationProxy userInformationRecord){
  login.setUserInformation(userInformationRecord);
}",0.902097902097902
54039,"/** 
 * Gets the container element associated with this layer. <p> This is the element that sits between the parent and child elements. It is normally necessary to operate on this element only when you need to modify certain CSS properties, such as visibility. </p>
 * @return the container element
 */
public Element getContainerElement(){
  return container;
}","/** 
 * Gets the container element associated with this layer. <p> This is the element that sits between the parent and child elements. It is normally necessary to operate on this element only when you need to modify CSS properties that are not directly modeled by the Layer class. </p>
 * @return the container element
 */
public Element getContainerElement(){
  return container;
}",0.8993288590604027
54040,"public void layout(Layer layer){
  Style style=layer.container.getStyle();
  style.setProperty(""String_Node_Str"",layer.setLeft ? (layer.left + layer.leftUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setTop ? (layer.top + layer.topUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setRight ? (layer.right + layer.rightUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setBottom ? (layer.bottom + layer.bottomUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setWidth ? (layer.width + layer.widthUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setHeight ? (layer.height + layer.heightUnit.getType()) : ""String_Node_Str"");
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}","public void layout(Layer layer){
  Style style=layer.container.getStyle();
  if (layer.visible) {
    style.clearDisplay();
  }
 else {
    style.setDisplay(Display.NONE);
  }
  style.setProperty(""String_Node_Str"",layer.setLeft ? (layer.left + layer.leftUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setTop ? (layer.top + layer.topUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setRight ? (layer.right + layer.rightUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setBottom ? (layer.bottom + layer.bottomUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setWidth ? (layer.width + layer.widthUnit.getType()) : ""String_Node_Str"");
  style.setProperty(""String_Node_Str"",layer.setHeight ? (layer.height + layer.heightUnit.getType()) : ""String_Node_Str"");
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}",0.9619585687382296
54041,"@Override public void layout(Layer layer){
  Element elem=layer.getContainerElement();
  setLayer(elem,layer);
}","@Override public void layout(Layer layer){
  Element elem=layer.container;
  Style style=elem.getStyle();
  if (layer.visible) {
    style.clearDisplay();
  }
 else {
    style.setDisplay(Display.NONE);
  }
  setLayer(elem,layer);
}",0.5755813953488372
54042,"@Override public void layout(Layer layer){
  Style style=layer.container.getStyle();
  if (layer.setLeft) {
    setValue(layer,""String_Node_Str"",layer.left,layer.leftUnit,false,false);
  }
 else {
    style.clearLeft();
  }
  if (layer.setRight) {
    setValue(layer,""String_Node_Str"",layer.right,layer.rightUnit,false,false);
  }
 else {
    style.clearRight();
  }
  if (layer.setTop) {
    setValue(layer,""String_Node_Str"",layer.top,layer.topUnit,true,false);
  }
 else {
    style.clearTop();
  }
  if (layer.setBottom) {
    setValue(layer,""String_Node_Str"",layer.bottom,layer.bottomUnit,true,false);
  }
 else {
    style.clearBottom();
  }
  if (layer.setWidth) {
    setValue(layer,""String_Node_Str"",layer.width,layer.widthUnit,false,true);
  }
 else {
    style.clearWidth();
  }
  if (layer.setHeight) {
    setValue(layer,""String_Node_Str"",layer.height,layer.heightUnit,true,true);
  }
 else {
    style.clearHeight();
  }
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}","@Override public void layout(Layer layer){
  Style style=layer.container.getStyle();
  setLayer(layer.container,layer);
  if (layer.visible) {
    String oldDisplay=style.getDisplay();
    style.clearDisplay();
    if (oldDisplay.length() > 0) {
      updateVisibility(layer.container);
    }
  }
 else {
    style.setDisplay(Display.NONE);
  }
  if (layer.setLeft) {
    setValue(layer,""String_Node_Str"",layer.left,layer.leftUnit,false,false);
  }
 else {
    style.clearLeft();
  }
  if (layer.setRight) {
    setValue(layer,""String_Node_Str"",layer.right,layer.rightUnit,false,false);
  }
 else {
    style.clearRight();
  }
  if (layer.setTop) {
    setValue(layer,""String_Node_Str"",layer.top,layer.topUnit,true,false);
  }
 else {
    style.clearTop();
  }
  if (layer.setBottom) {
    setValue(layer,""String_Node_Str"",layer.bottom,layer.bottomUnit,true,false);
  }
 else {
    style.clearBottom();
  }
  if (layer.setWidth) {
    setValue(layer,""String_Node_Str"",layer.width,layer.widthUnit,false,true);
  }
 else {
    style.clearWidth();
  }
  if (layer.setHeight) {
    setValue(layer,""String_Node_Str"",layer.height,layer.heightUnit,true,true);
  }
 else {
    style.clearHeight();
  }
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}",0.9163987138263664
54043,"/** 
 * Shows or hides the given widget and its layer. This method explicitly calls   {@link UIObject#setVisible(boolean)} on the child widget and ensuresthat its associated layer is shown/hidden.
 * @param child
 * @param visible
 */
public void setWidgetVisible(Widget child,boolean visible){
  assertIsChild(child);
  Element container=getWidgetContainerElement(child);
  setVisible(container,visible);
  child.setVisible(visible);
  animate(0);
}","/** 
 * Shows or hides the given widget and its layer. This method explicitly calls   {@link UIObject#setVisible(boolean)} on the child widget and ensuresthat its associated layer is shown/hidden.
 * @param child
 * @param visible
 */
public void setWidgetVisible(Widget child,boolean visible){
  assertIsChild(child);
  getLayer(child).setVisible(visible);
  child.setVisible(visible);
  animate(0);
}",0.7652582159624414
54044,"private void layoutChild(Widget child){
  panel.setWidgetLeftRight(child,0,Unit.PX,0,Unit.PX);
  panel.setWidgetTopBottom(child,barHeight,barUnit,0,Unit.PX);
  panel.getWidgetContainerElement(child).getStyle().setDisplay(Display.NONE);
  child.addStyleName(CONTENT_STYLE);
  child.setVisible(false);
}","private void layoutChild(Widget child){
  panel.setWidgetLeftRight(child,0,Unit.PX,0,Unit.PX);
  panel.setWidgetTopBottom(child,barHeight,barUnit,0,Unit.PX);
  panel.setWidgetVisible(child,false);
  child.addStyleName(CONTENT_STYLE);
  child.setVisible(false);
}",0.8312611012433393
54045,"public void execute(){
  assertEquals(128,bar.getOffsetWidth());
  assertEquals(128 - 32,bar.getOffsetHeight());
  finishTest();
}","public void execute(){
  assertTrue(bar.getOffsetWidth() > 0);
  assertTrue(bar.getOffsetHeight() > 0);
  finishTest();
}",0.852589641434263
54046,"public void testInternalPrecision(){
  long millis=System.currentTimeMillis();
  Date now=new Date(millis);
  Date after=new Date(now.getTime() + 1);
  Date before=new Date(now.getTime() - 1);
  assertTrue(after.after(now));
  assertTrue(before.before(now));
}","public void testInternalPrecision(){
  long millis=1283895273475L;
  Date now=new Date(millis);
  Date after=new Date(now.getTime() + 1);
  Date before=new Date(now.getTime() - 1);
  assertTrue(after.after(now));
  assertTrue(before.before(now));
}",0.3543307086614173
54047,"public void testInternalPrecision(){
  long millis=System.currentTimeMillis();
  Time today=new Time(millis);
  Time after=new Time(today.getTime() + 1);
  Time before=new Time(today.getTime() - 1);
  assertTrue(after.after(today));
  assertTrue(before.before(today));
}","public void testInternalPrecision(){
  long millis=1283895273475L;
  Time today=new Time(millis);
  Time after=new Time(today.getTime() + 1);
  Time before=new Time(today.getTime() - 1);
  assertTrue(after.after(today));
  assertTrue(before.before(today));
}",0.3484848484848485
54048,"public void testNanosAffectTime(){
  long now=System.currentTimeMillis();
  int millis=(int)(now % 1000);
  Timestamp t=new Timestamp(now);
  assertEquals(now,t.getTime());
  assertEquals(millis * 1000000,t.getNanos());
  t.setNanos(0);
  assertEquals(now - millis,t.getTime());
  t.setNanos(999999999);
  assertEquals(now - millis + 999,t.getTime());
}","public void testNanosAffectTime(){
  long now=1283895273475L;
  int millis=(int)(now % 1000);
  Timestamp t=new Timestamp(now);
  assertEquals(now,t.getTime());
  assertEquals(millis * 1000000,t.getNanos());
  t.setNanos(0);
  assertEquals(now - millis,t.getTime());
  t.setNanos(999999999);
  assertEquals(now - millis + 999,t.getTime());
}",0.9423631123919308
54049,"public void testNanosRange(){
  long now=System.currentTimeMillis();
  Timestamp t=new Timestamp(now);
  assertEquals(now,t.getTime());
  assertEquals((now % 1000) * 1000000,t.getNanos());
  try {
    t.setNanos(-1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  t.setNanos(0);
  try {
    t.setNanos(1000000000);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  t.setNanos(999999999);
}","public void testNanosRange(){
  long now=1283895273475L;
  Timestamp t=new Timestamp(now);
  assertEquals(now,t.getTime());
  assertEquals((now % 1000) * 1000000,t.getNanos());
  try {
    t.setNanos(-1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  t.setNanos(0);
  try {
    t.setNanos(1000000000);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  t.setNanos(999999999);
}",0.954954954954955
54050,"public void testTimeAffectsNanos(){
  long now=(System.currentTimeMillis() / 1000) * 1000 + 5;
  Timestamp t=new Timestamp(now);
  assertEquals(5000000,t.getNanos());
  t.setTime(now + 1);
  assertEquals(6000000,t.getNanos());
}","public void testTimeAffectsNanos(){
  long now=1283895273005L;
  Timestamp t=new Timestamp(now);
  assertEquals(5000000,t.getNanos());
  t.setTime(now + 1);
  assertEquals(6000000,t.getNanos());
}",0.8773584905660378
54051,"public void testNanosComparison(){
  long now=System.currentTimeMillis();
  Timestamp t=new Timestamp(now);
  t.setNanos(0);
  Timestamp t2=new Timestamp(t.getTime());
  t2.setNanos(0);
  assertEquals(t,t2);
  assertEquals(0,t.compareTo(t2));
  assertFalse(t.before(t2));
  assertFalse(t.after(t2));
  t2.setNanos(1);
  assertFalse(t.equals(t2));
  assertTrue(t.compareTo(t2) < 0);
  assertTrue(t2.compareTo(t) > 0);
  assertTrue(t.before(t2));
  assertTrue(t2.after(t));
}","public void testNanosComparison(){
  long now=1283895273475L;
  Timestamp t=new Timestamp(now);
  t.setNanos(0);
  Timestamp t2=new Timestamp(t.getTime());
  t2.setNanos(0);
  assertEquals(t,t2);
  assertEquals(0,t.compareTo(t2));
  assertFalse(t.before(t2));
  assertFalse(t.after(t2));
  t2.setNanos(1);
  assertFalse(t.equals(t2));
  assertTrue(t.compareTo(t2) < 0);
  assertTrue(t2.compareTo(t) > 0);
  assertTrue(t.before(t2));
  assertTrue(t2.after(t));
}",0.9571734475374732
54052,"/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  assertEquals(1,t.compareTo(d2));
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(t.getNanos() + 1);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}","/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  testDateComparisonOneValue(1283895274000L);
  testDateComparisonOneValue(1283895273475L);
}",0.2836734693877551
54053,"public void computeTypeCastabilityMaps(){
  computeSourceType(program.getTypeJavaLangString());
  assert(castableTypeMaps.size() == 3);
  for (  JReferenceType type : program.getDeclaredTypes()) {
    if (type instanceof JClassType) {
      computeSourceType(type);
    }
  }
  for (  JArrayType type : program.getAllArrayTypes()) {
    computeSourceType(type);
  }
  program.initTypeInfo(castableTypeMaps);
  JClassType jsoType=program.getJavaScriptObject();
  if (jsoType != null) {
    queryIds.put(jsoType,-1);
  }
  program.recordQueryIds(queryIds);
}","public void computeTypeCastabilityMaps(){
  computeSourceType(program.getTypeJavaLangString());
  assert(castableTypeMaps.size() == 2);
  for (  JReferenceType type : program.getDeclaredTypes()) {
    if (type instanceof JClassType) {
      computeSourceType(type);
    }
  }
  for (  JArrayType type : program.getAllArrayTypes()) {
    computeSourceType(type);
  }
  program.initTypeInfo(castableTypeMaps);
  JClassType jsoType=program.getJavaScriptObject();
  if (jsoType != null) {
    queryIds.put(jsoType,-1);
  }
  program.recordQueryIds(queryIds);
}",0.9982014388489208
54054,"Sandbox(AbstractCompiler outer,boolean doGenerateBytes){
  this.outer=outer;
  this.doGenerateBytes=doGenerateBytes;
  rememberPackage(""String_Node_Str"");
  INameEnvironment env=new INameEnvironmentImpl();
  IErrorHandlingPolicy pol=DefaultErrorHandlingPolicies.proceedWithAllProblems();
  IProblemFactory probFact=new DefaultProblemFactory(Locale.getDefault());
  ICompilerRequestor req=new ICompilerRequestorImpl();
  CompilerOptions options=getCompilerOptions();
  options.docCommentSupport=false;
  compiler=new CompilerImpl(env,pol,options,req,probFact);
  for (  CompilationUnit unit : outer.compilationState.getCompilationUnits()) {
    String packageName=Shared.getPackageName(unit.getTypeName());
    rememberPackage(packageName);
  }
}","Sandbox(AbstractCompiler outer,boolean doGenerateBytes){
  this.outer=outer;
  this.doGenerateBytes=doGenerateBytes;
  rememberPackage(""String_Node_Str"");
  INameEnvironment env=new INameEnvironmentImpl();
  IErrorHandlingPolicy pol=DefaultErrorHandlingPolicies.proceedWithAllProblems();
  IProblemFactory probFact=new DefaultProblemFactory(Locale.getDefault());
  ICompilerRequestor req=new ICompilerRequestorImpl();
  CompilerOptions options=getCompilerOptions();
  options.docCommentSupport=false;
  compiler=new CompilerImpl(env,pol,options,req,probFact);
  refreshPackagesFromCompState();
}",0.8492537313432836
54055,"/** 
 * Causes the compilation service itself to recognize the specified package name (and all its parent packages), avoiding a call back into the host. This is useful as an optimization, but more importantly, it is useful to compile against bytecode that was pre-compiled to which we don't have the source. This ability is crucial bridging the gap between user-level and ""dev"" code in hosted mode for classes such as JavaScriptHost and ShellJavaScriptHost.
 */
private void rememberPackage(String packageName){
  int i=packageName.lastIndexOf('.');
  if (i != -1) {
    rememberPackage(packageName.substring(0,i));
  }
  knownPackages.add(packageName);
}","/** 
 * Causes the compilation service itself to recognize the specified package name (and all its parent packages), avoiding a call back into the host. This is useful as an optimization, but more importantly, it is useful to compile against bytecode that was pre-compiled to which we don't have the source. This ability is crucial bridging the gap between user-level and ""dev"" code in hosted mode for classes such as JavaScriptHost and ShellJavaScriptHost.
 */
private void rememberPackage(String packageName){
  if (knownPackages.add(packageName)) {
    int i=packageName.lastIndexOf('.');
    if (i != -1) {
      rememberPackage(packageName.substring(0,i));
    }
  }
}",0.9382530120481928
54056,"@Override public void process(CompilationUnitDeclaration unit,int index){
  long processBeginNanos=System.nanoTime();
{
    this.lookupEnvironment.unitBeingCompleted=unit;
    long parseStart=System.currentTimeMillis();
    this.parser.getMethodBodies(unit);
    long resolveStart=System.currentTimeMillis();
    this.stats.parseTime+=resolveStart - parseStart;
    if (unit.scope != null) {
      unit.scope.faultInTypes();
    }
    if (unit.scope != null) {
      unit.scope.verifyMethods(lookupEnvironment.methodVerifier());
    }
    unit.resolve();
    long analyzeStart=System.currentTimeMillis();
    this.stats.resolveTime+=analyzeStart - resolveStart;
    unit.analyseCode();
    long generateStart=System.currentTimeMillis();
    this.stats.analyzeTime+=generateStart - analyzeStart;
    if (doGenerateBytes) {
      unit.generateCode();
    }
    if (options.produceReferenceInfo && unit.scope != null) {
      unit.scope.storeDependencyInfo();
    }
    unit.finalizeProblems();
    this.stats.generateTime+=System.currentTimeMillis() - generateStart;
    unit.compilationResult.totalUnitsKnown=totalUnits;
    this.lookupEnvironment.unitBeingCompleted=null;
  }
  ICompilationUnit cu=unit.compilationResult.compilationUnit;
  String loc=String.valueOf(cu.getFileName());
  TreeLogger branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"" + loc,null);
  String[] typeNames=outer.doFindAdditionalTypesUsingJsni(branch,unit);
  addAdditionalTypes(branch,typeNames);
  typeNames=outer.doFindAdditionalTypesUsingRebinds(branch,unit);
  addAdditionalTypes(branch,typeNames);
  typeNames=outer.doFindAdditionalTypesUsingArtificialRescues(branch,unit);
  addAdditionalTypes(branch,typeNames);
  if (cuds != null) {
    cuds.add(unit);
  }
  jdtProcessNanos+=System.nanoTime() - processBeginNanos;
}","@Override public void process(CompilationUnitDeclaration unit,int index){
  long processBeginNanos=System.nanoTime();
{
    this.lookupEnvironment.unitBeingCompleted=unit;
    long parseStart=System.currentTimeMillis();
    this.parser.getMethodBodies(unit);
    long resolveStart=System.currentTimeMillis();
    this.stats.parseTime+=resolveStart - parseStart;
    if (unit.scope != null) {
      unit.scope.faultInTypes();
    }
    if (unit.scope != null) {
      unit.scope.verifyMethods(lookupEnvironment.methodVerifier());
    }
    unit.resolve();
    long analyzeStart=System.currentTimeMillis();
    this.stats.resolveTime+=analyzeStart - resolveStart;
    unit.analyseCode();
    long generateStart=System.currentTimeMillis();
    this.stats.analyzeTime+=generateStart - analyzeStart;
    if (doGenerateBytes) {
      unit.generateCode();
    }
    if (options.produceReferenceInfo && unit.scope != null) {
      unit.scope.storeDependencyInfo();
    }
    unit.finalizeProblems();
    this.stats.generateTime+=System.currentTimeMillis() - generateStart;
    unit.compilationResult.totalUnitsKnown=totalUnits;
    this.lookupEnvironment.unitBeingCompleted=null;
  }
  ICompilationUnit cu=unit.compilationResult.compilationUnit;
  String loc=String.valueOf(cu.getFileName());
  TreeLogger branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"" + loc,null);
  String[] typeNames=outer.doFindAdditionalTypesUsingJsni(branch,unit);
  addAdditionalTypes(branch,typeNames);
  typeNames=outer.doFindAdditionalTypesUsingArtificialRescues(branch,unit);
  addAdditionalTypes(branch,typeNames);
  typeNames=outer.doFindAdditionalTypesUsingRebinds(branch,unit);
  addAdditionalTypes(branch,typeNames);
  if (typeNames.length > 0) {
    refreshPackagesFromCompState();
  }
  if (cuds != null) {
    cuds.add(unit);
  }
  jdtProcessNanos+=System.nanoTime() - processBeginNanos;
}",0.8619565217391304
54057,"/** 
 * Pull in types implicitly referenced through rebind answers.
 */
@Override protected String[] doFindAdditionalTypesUsingRebinds(TreeLogger logger,CompilationUnitDeclaration cud){
  Set<String> dependentTypeNames=new HashSet<String>();
  FindDeferredBindingSitesVisitor v=new FindDeferredBindingSitesVisitor();
  cud.traverse(v,cud.scope);
  Map<String,MessageSendSite> requestedTypes=v.getSites();
  Map<String,String[]> rebindAnswers=new HashMap<String,String[]>();
  boolean doFinish=false;
  for (  Map.Entry<String,MessageSendSite> entry : requestedTypes.entrySet()) {
    String reqType=entry.getKey();
    MessageSendSite site=entry.getValue();
    try {
      String[] resultTypes=rebindPermOracle.getAllPossibleRebindAnswers(logger,reqType);
      rebindAnswers.put(reqType,resultTypes);
      Collections.addAll(dependentTypeNames,resultTypes);
      doFinish=true;
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + reqType + ""String_Node_Str"");
      rebindAnswers.put(reqType,new String[0]);
    }
  }
  for (  MessageSendSite site : v.getRunAsyncSites()) {
    String resultType;
    try {
      resultType=fragmentLoaderCreator.create(logger);
      dependentTypeNames.add(resultType);
      doFinish=true;
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"");
    }
  }
  if (doFinish) {
    try {
      rebindPermOracle.getGeneratorContext().finish(logger);
    }
 catch (    UnableToCompleteException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
  for (  Map.Entry<String,MessageSendSite> entry : requestedTypes.entrySet()) {
    String reqType=entry.getKey();
    MessageSendSite site=entry.getValue();
    String[] resultTypes=rebindAnswers.get(reqType);
    for (    String typeName : resultTypes) {
      checkRebindResultInstantiable(site,typeName);
    }
  }
  return dependentTypeNames.toArray(new String[dependentTypeNames.size()]);
}","/** 
 * Pull in types implicitly referenced through rebind answers.
 */
@Override protected String[] doFindAdditionalTypesUsingRebinds(TreeLogger logger,CompilationUnitDeclaration cud){
  Set<String> dependentTypeNames=new LinkedHashSet<String>();
  FindDeferredBindingSitesVisitor v=new FindDeferredBindingSitesVisitor();
  cud.traverse(v,cud.scope);
  Map<String,MessageSendSite> requestedTypes=v.getSites();
  Map<String,String[]> rebindAnswers=new HashMap<String,String[]>();
  boolean doFinish=false;
  for (  Map.Entry<String,MessageSendSite> entry : requestedTypes.entrySet()) {
    String reqType=entry.getKey();
    MessageSendSite site=entry.getValue();
    try {
      String[] resultTypes=rebindPermOracle.getAllPossibleRebindAnswers(logger,reqType);
      rebindAnswers.put(reqType,resultTypes);
      Collections.addAll(dependentTypeNames,resultTypes);
      doFinish=true;
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + reqType + ""String_Node_Str"");
      rebindAnswers.put(reqType,new String[0]);
    }
  }
  for (  MessageSendSite site : v.getRunAsyncSites()) {
    String resultType;
    try {
      resultType=fragmentLoaderCreator.create(logger);
      dependentTypeNames.add(resultType);
      doFinish=true;
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"");
    }
  }
  if (doFinish) {
    try {
      rebindPermOracle.getGeneratorContext().finish(logger);
    }
 catch (    UnableToCompleteException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
  for (  Map.Entry<String,MessageSendSite> entry : requestedTypes.entrySet()) {
    String reqType=entry.getKey();
    MessageSendSite site=entry.getValue();
    String[] resultTypes=rebindAnswers.get(reqType);
    for (    String typeName : resultTypes) {
      checkRebindResultInstantiable(site,typeName);
    }
  }
  return dependentTypeNames.toArray(new String[dependentTypeNames.size()]);
}",0.9985387238188016
54058,"@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  if (resolveChanges()) {
    SelectionChangeEvent.fire(this);
  }
}","@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  resolveChanges();
}",0.8517350157728707
54059,"private boolean resolveChanges(){
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    boolean defaultSelected=isDefaultSelected(object);
    Object key=getKey(object);
    Boolean previousException=exceptions.get(key);
    if (defaultSelected == selected) {
      if (previousException != null) {
        exceptions.remove(key);
        changed=true;
      }
    }
 else {
      if (previousException != Boolean.valueOf(selected)) {
        exceptions.put(key,selected);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  return changed;
}","private void resolveChanges(){
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    boolean defaultSelected=isDefaultSelected(object);
    Object key=getKey(object);
    Boolean previousException=exceptions.get(key);
    if (defaultSelected == selected) {
      if (previousException != null) {
        exceptions.remove(key);
        changed=true;
      }
    }
 else {
      if (previousException != Boolean.valueOf(selected)) {
        exceptions.put(key,selected);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}",0.939898624185373
54060,"@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  if (resolveChanges()) {
    SelectionChangeEvent.fire(this);
  }
}","@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  resolveChanges();
}",0.8517350157728707
54061,"private boolean resolveChanges(){
  if (selectionChanges.isEmpty()) {
    return false;
  }
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    Object key=getKey(object);
    T oldValue=selectedSet.get(key);
    if (selected) {
      if (oldValue == null || !oldValue.equals(object)) {
        selectedSet.put(getKey(object),object);
        changed=true;
      }
    }
 else {
      if (oldValue != null) {
        selectedSet.remove(key);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  return changed;
}","private void resolveChanges(){
  if (selectionChanges.isEmpty()) {
    return;
  }
  boolean changed=false;
  for (  Map.Entry<T,Boolean> entry : selectionChanges.entrySet()) {
    T object=entry.getKey();
    boolean selected=entry.getValue();
    Object key=getKey(object);
    T oldValue=selectedSet.get(key);
    if (selected) {
      if (oldValue == null || !oldValue.equals(object)) {
        selectedSet.put(getKey(object),object);
        changed=true;
      }
    }
 else {
      if (oldValue != null) {
        selectedSet.remove(key);
        changed=true;
      }
    }
  }
  selectionChanges.clear();
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}",0.9307984790874524
54062,"@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  if (resolveChanges()) {
    SelectionChangeEvent.fire(this);
  }
}","@Override protected void fireSelectionChangeEvent(){
  if (isEventScheduled()) {
    setEventCancelled(true);
  }
  resolveChanges();
}",0.8517350157728707
54063,"private boolean resolveChanges(){
  if (newSelectedObject == null) {
    return false;
  }
  Object key=getKey(newSelectedObject);
  boolean sameKey=curKey == null ? key == null : curKey.equals(key);
  boolean changed=false;
  if (newSelected) {
    changed=!sameKey;
    curSelection=newSelectedObject;
    curKey=key;
  }
 else   if (sameKey) {
    changed=true;
    curSelection=null;
    curKey=null;
  }
  newSelectedObject=null;
  return changed;
}","private void resolveChanges(){
  if (newSelectedObject == null) {
    return;
  }
  Object key=getKey(newSelectedObject);
  boolean sameKey=curKey == null ? key == null : curKey.equals(key);
  boolean changed=false;
  if (newSelected) {
    changed=!sameKey;
    curSelection=newSelectedObject;
    curKey=key;
  }
 else   if (sameKey) {
    changed=true;
    curSelection=null;
    curKey=null;
  }
  newSelectedObject=null;
  if (changed) {
    SelectionChangeEvent.fire(this);
  }
}",0.8924387646432375
54064,"public void setSelected(T object,boolean selected){
}","public void setSelected(T object,boolean selected){
  scheduleSelectionChangeEvent();
}",0.7571428571428571
54065,"public void testLoadModuleMessage() throws IOException, BrowserChannelException {
  String url=""String_Node_Str"";
  String sessionKey=""String_Node_Str"";
  String tabKey=""String_Node_Str"";
  String moduleName=""String_Node_Str"";
  String userAgent=""String_Node_Str"";
  new LoadModuleMessage(channel,url,tabKey,sessionKey,moduleName,userAgent).send();
  MessageType type=channel.readMessageType();
  assertEquals(MessageType.LOAD_MODULE,type);
  LoadModuleMessage message=LoadModuleMessage.receive(channel);
  assertEquals(url,message.getUrl());
  assertEquals(tabKey,message.getTabKey());
  assertEquals(sessionKey,message.getSessionKey());
  assertEquals(moduleName,message.getModuleName());
  assertEquals(userAgent,message.getUserAgent());
  url=""String_Node_Str"";
  sessionKey=""String_Node_Str"";
  tabKey=""String_Node_Str"";
  moduleName=""String_Node_Str"";
  userAgent=""String_Node_Str"";
  new LoadModuleMessage(channel,url,tabKey,sessionKey,moduleName,userAgent).send();
  type=channel.readMessageType();
  assertEquals(MessageType.LOAD_MODULE,type);
  message=LoadModuleMessage.receive(channel);
  assertEquals(url,message.getUrl());
  assertEquals(tabKey,message.getTabKey());
  assertEquals(sessionKey,message.getSessionKey());
  assertEquals(moduleName,message.getModuleName());
  assertEquals(userAgent,message.getUserAgent());
  TemporaryBufferStream tempBufferStream=new TemporaryBufferStream();
  TestBrowserChannel trashableChannel=new TestBrowserChannel(tempBufferStream.getInputStream(),tempBufferStream.getOutputStream());
  try {
    new LoadModuleMessage(trashableChannel,null,tabKey,sessionKey,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,null,sessionKey,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,null,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,sessionKey,null,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,sessionKey,moduleName,null).send();
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
}","public void testLoadModuleMessage() throws IOException, BrowserChannelException {
  String url=""String_Node_Str"";
  String sessionKey=""String_Node_Str"";
  String tabKey=""String_Node_Str"";
  String moduleName=""String_Node_Str"";
  String userAgent=""String_Node_Str"";
  new LoadModuleMessage(channel,url,tabKey,sessionKey,moduleName,userAgent).send();
  MessageType type=channel.readMessageType();
  assertEquals(MessageType.LOAD_MODULE,type);
  LoadModuleMessage message=LoadModuleMessage.receive(channel);
  assertEquals(url,message.getUrl());
  assertEquals(tabKey,message.getTabKey());
  assertEquals(sessionKey,message.getSessionKey());
  assertEquals(moduleName,message.getModuleName());
  assertEquals(userAgent,message.getUserAgent());
  url=""String_Node_Str"";
  sessionKey=""String_Node_Str"";
  tabKey=""String_Node_Str"";
  moduleName=""String_Node_Str"";
  userAgent=""String_Node_Str"";
  new LoadModuleMessage(channel,url,tabKey,sessionKey,moduleName,userAgent).send();
  type=channel.readMessageType();
  assertEquals(MessageType.LOAD_MODULE,type);
  message=LoadModuleMessage.receive(channel);
  assertEquals(url,message.getUrl());
  assertEquals(tabKey,message.getTabKey());
  assertEquals(sessionKey,message.getSessionKey());
  assertEquals(moduleName,message.getModuleName());
  assertEquals(userAgent,message.getUserAgent());
  TemporaryBufferStream tempBufferStream=new TemporaryBufferStream();
  TestBrowserChannel trashableChannel=new TestBrowserChannel(tempBufferStream.getInputStream(),tempBufferStream.getOutputStream());
  try {
    new LoadModuleMessage(trashableChannel,null,tabKey,sessionKey,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,null,sessionKey,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,null,moduleName,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,sessionKey,null,userAgent).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
  try {
    new LoadModuleMessage(trashableChannel,url,tabKey,sessionKey,moduleName,null).send();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
catch (  NullPointerException expected) {
  }
}",0.9491525423728814
54066,"private void setValue(Layer layer,String prop,double value,Unit unit,boolean vertical,boolean noNegative){
switch (unit) {
case PX:
case PCT:
    break;
default :
  value=value * (int)getUnitSizeInPixels(layer.container,unit,vertical);
unit=Unit.PX;
break;
}
if (noNegative) {
if (value < 0) {
value=0;
}
}
layer.getContainerElement().getStyle().setProperty(prop,value,unit);
}","private void setValue(Layer layer,String prop,double value,Unit unit,boolean vertical,boolean noNegative){
switch (unit) {
case PX:
case PCT:
    break;
default :
  value=value * getUnitSizeInPixels(layer.container,unit,vertical);
unit=Unit.PX;
break;
}
if (noNegative) {
if (value < 0) {
value=0;
}
}
layer.getContainerElement().getStyle().setProperty(prop,(int)(value + 0.5),unit);
}",0.963254593175853
54067,"/** 
 * Get the columns displayed in the expense table.
 */
private Collection<Property<?>> getExpenseColumns(){
  List<Property<?>> columns=new ArrayList<Property<?>>();
  columns.add(ExpenseRecord.amount);
  columns.add(ExpenseRecord.approval);
  columns.add(ExpenseRecord.category);
  columns.add(ExpenseRecord.created);
  columns.add(ExpenseRecord.description);
  columns.add(ExpenseRecord.reasonDenied);
  return columns;
}","/** 
 * Get the columns displayed in the expense table.
 */
private String[] getExpenseColumns(){
  return new String[]{ExpenseRecord.amount.getName(),ExpenseRecord.approval.getName(),ExpenseRecord.category.getName(),ExpenseRecord.created.getName(),ExpenseRecord.description.getName(),ExpenseRecord.reasonDenied.getName()};
}",0.199203187250996
54068,"/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  lastReceiver=new Receiver<List<ExpenseRecord>>(){
    public void onSuccess(    List<ExpenseRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        List<ExpenseRecord> list=new ArrayList<ExpenseRecord>(newValues);
        sortExpenses(list,lastComparator);
        items.setList(list);
        refreshCost();
        boolean isInitialData=knownExpenseKeys == null;
        if (knownExpenseKeys == null) {
          knownExpenseKeys=new HashMap<Object,ExpenseRecord>();
        }
        for (        ExpenseRecord value : newValues) {
          Object key=items.getKey(value);
          if (!isInitialData) {
            ExpenseRecord existing=knownExpenseKeys.get(key);
            if (existing == null || !value.getAmount().equals(existing.getAmount()) || !value.getDescription().equals(existing.getDescription()) || !value.getCategory().equals(existing.getCategory())) {
              (new PhaseAnimation.CellTablePhaseAnimation<ExpenseRecord>(table,value,items)).run();
            }
          }
          knownExpenseKeys.put(key,value);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  expensesRequestFactory.expenseRequest().findExpensesByReport(report.getRef(Record.id)).forProperties(getExpenseColumns()).fire(lastReceiver);
}","/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  lastReceiver=new Receiver<List<ExpenseRecord>>(){
    public void onSuccess(    List<ExpenseRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        List<ExpenseRecord> list=new ArrayList<ExpenseRecord>(newValues);
        sortExpenses(list,lastComparator);
        items.setList(list);
        refreshCost();
        boolean isInitialData=knownExpenseKeys == null;
        if (knownExpenseKeys == null) {
          knownExpenseKeys=new HashMap<Object,ExpenseRecord>();
        }
        for (        ExpenseRecord value : newValues) {
          Object key=items.getKey(value);
          if (!isInitialData) {
            ExpenseRecord existing=knownExpenseKeys.get(key);
            if (existing == null || !value.getAmount().equals(existing.getAmount()) || !value.getDescription().equals(existing.getDescription()) || !value.getCategory().equals(existing.getCategory())) {
              (new PhaseAnimation.CellTablePhaseAnimation<ExpenseRecord>(table,value,items)).run();
            }
          }
          knownExpenseKeys.put(key,value);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  expensesRequestFactory.expenseRequest().findExpensesByReport(report.getRef(Record.id)).with(getExpenseColumns()).fire(lastReceiver);
}",0.9780812073302192
54069,"public void onReportChanged(ReportRecordChanged event){
  ReportRecord changed=event.getRecord();
  if (report != null && report.getId().equals(changed.getId())) {
    report=changed;
    setNotesEditState(false,false,changed.getNotes());
  }
}","public void onReportChanged(ReportRecordChanged event){
  ReportRecord changed=event.getRecord();
  if (report != null && report.getId().equals(changed.getId())) {
    expensesRequestFactory.reportRequest().findReport(report.getRef(ReportRecord.id)).with(ReportRecord.notes.getName()).fire(new Receiver<ReportRecord>(){
      @Override public void onSuccess(      ReportRecord response,      Set<SyncResult> syncResults){
        report=response;
        setNotesEditState(false,false,response.getNotes());
      }
    }
);
  }
}",0.5950840879689522
54070,"public ExpenseList(){
  reports.setKeyProvider(Expenses.REPORT_RECORD_KEY_PROVIDER);
  reportColumns=new ArrayList<Property<?>>();
  reportColumns.add(ReportRecord.created);
  reportColumns.add(ReportRecord.purpose);
  reportColumns.add(ReportRecord.notes);
  createTable();
  searchBox=new DefaultTextBox(""String_Node_Str"");
  initWidget(uiBinder.createAndBindUi(this));
  reports.addDataDisplay(table);
  searchBox.addKeyUpHandler(new KeyUpHandler(){
    public void onKeyUp(    KeyUpEvent event){
      if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
        search();
        return;
      }
      String text=searchBox.getText();
      if (text.length() > 0) {
        searchRegExp=RegExp.compile(""String_Node_Str"" + text + ""String_Node_Str"",""String_Node_Str"");
      }
 else {
        searchRegExp=null;
      }
      table.redraw();
    }
  }
);
  searchButton.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      search();
    }
  }
);
}","public ExpenseList(){
  reports.setKeyProvider(Expenses.REPORT_RECORD_KEY_PROVIDER);
  createTable();
  searchBox=new DefaultTextBox(""String_Node_Str"");
  initWidget(uiBinder.createAndBindUi(this));
  reports.addDataDisplay(table);
  searchBox.addKeyUpHandler(new KeyUpHandler(){
    public void onKeyUp(    KeyUpEvent event){
      if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
        search();
        return;
      }
      String text=searchBox.getText();
      if (text.length() > 0) {
        searchRegExp=RegExp.compile(""String_Node_Str"" + text + ""String_Node_Str"",""String_Node_Str"");
      }
 else {
        searchRegExp=null;
      }
      table.redraw();
    }
  }
);
  searchButton.addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      search();
    }
  }
);
}",0.9039422543031648
54071,"/** 
 * Send a request for reports in the current range.
 * @param isPolling true if this request is caused by polling
 */
private void requestReports(boolean isPolling){
  refreshTimer.cancel();
  if (requestFactory == null) {
    return;
  }
  if (!isPolling) {
    knownReportKeys=null;
  }
  String startsWith=startsWithSearch;
  if (startsWith == null || searchBox.getDefaultText().equals(startsWith)) {
    startsWith=""String_Node_Str"";
  }
  Range range=table.getVisibleRange();
  Long employeeId=employee == null ? -1 : new Long(employee.getId());
  String dept=department == null ? ""String_Node_Str"" : department;
  if (startsWith.length() > 0) {
    for (    SortableHeader header : allHeaders) {
      header.setSorted(false);
      header.setReverseSort(false);
    }
    table.redrawHeaders();
  }
  if (isCountStale) {
    isCountStale=false;
    if (!isPolling) {
      pager.startLoading();
    }
    lastDataSizeReceiver=new Receiver<Long>(){
      public void onSuccess(      Long response,      Set<SyncResult> syncResults){
        if (this == lastDataSizeReceiver) {
          int count=response.intValue();
          reports.updateRowCount(count,count != 1000);
        }
      }
    }
;
    requestFactory.reportRequest().countReportsBySearch(employeeId,dept,startsWith).fire(lastDataSizeReceiver);
  }
  lastDataReceiver=new Receiver<List<ReportRecord>>(){
    public void onSuccess(    List<ReportRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastDataReceiver) {
        int size=newValues.size();
        if (size < table.getPageSize()) {
          reports.updateRowCount(table.getPageStart() + size,true);
        }
        if (size > 0) {
          reports.updateRowData(table.getPageStart(),newValues);
        }
        boolean isInitialData=knownReportKeys == null;
        if (knownReportKeys == null) {
          knownReportKeys=new HashSet<Object>();
        }
        for (        ReportRecord value : newValues) {
          Object key=reports.getKey(value);
          if (!isInitialData && !knownReportKeys.contains(key)) {
            (new PhaseAnimation.CellTablePhaseAnimation<ReportRecord>(table,value,reports)).run();
          }
          knownReportKeys.add(key);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employeeId,dept,startsWith,orderBy,range.getStart(),range.getLength()).forProperties(reportColumns).fire(lastDataReceiver);
}","/** 
 * Send a request for reports in the current range.
 * @param isPolling true if this request is caused by polling
 */
private void requestReports(boolean isPolling){
  refreshTimer.cancel();
  if (requestFactory == null) {
    return;
  }
  if (!isPolling) {
    knownReportKeys=null;
  }
  String startsWith=startsWithSearch;
  if (startsWith == null || searchBox.getDefaultText().equals(startsWith)) {
    startsWith=""String_Node_Str"";
  }
  Range range=table.getVisibleRange();
  Long employeeId=employee == null ? -1 : new Long(employee.getId());
  String dept=department == null ? ""String_Node_Str"" : department;
  if (startsWith.length() > 0) {
    for (    SortableHeader header : allHeaders) {
      header.setSorted(false);
      header.setReverseSort(false);
    }
    table.redrawHeaders();
  }
  if (isCountStale) {
    isCountStale=false;
    if (!isPolling) {
      pager.startLoading();
    }
    lastDataSizeReceiver=new Receiver<Long>(){
      public void onSuccess(      Long response,      Set<SyncResult> syncResults){
        if (this == lastDataSizeReceiver) {
          int count=response.intValue();
          reports.updateRowCount(count,count != 1000);
        }
      }
    }
;
    requestFactory.reportRequest().countReportsBySearch(employeeId,dept,startsWith).fire(lastDataSizeReceiver);
  }
  lastDataReceiver=new Receiver<List<ReportRecord>>(){
    public void onSuccess(    List<ReportRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastDataReceiver) {
        int size=newValues.size();
        if (size < table.getPageSize()) {
          reports.updateRowCount(table.getPageStart() + size,true);
        }
        if (size > 0) {
          reports.updateRowData(table.getPageStart(),newValues);
        }
        boolean isInitialData=knownReportKeys == null;
        if (knownReportKeys == null) {
          knownReportKeys=new HashSet<Object>();
        }
        for (        ReportRecord value : newValues) {
          Object key=reports.getKey(value);
          if (!isInitialData && !knownReportKeys.contains(key)) {
            (new PhaseAnimation.CellTablePhaseAnimation<ReportRecord>(table,value,reports)).run();
          }
          knownReportKeys.add(key);
        }
      }
      refreshTimer.schedule(REFRESH_INTERVAL);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employeeId,dept,startsWith,orderBy,range.getStart(),range.getLength()).with(reportColumns).fire(lastDataReceiver);
}",0.9901507537688442
54072,"@Override protected void onRangeChanged(HasData<EmployeeRecord> view){
  Range range=view.getVisibleRange();
  requestFactory.employeeRequest().findEmployeeEntriesByDepartment(department,range.getStart(),range.getLength()).forProperties(getEmployeeMenuProperties()).fire(this);
}","@Override protected void onRangeChanged(HasData<EmployeeRecord> view){
  Range range=view.getVisibleRange();
  requestFactory.employeeRequest().findEmployeeEntriesByDepartment(department,range.getStart(),range.getLength()).with(getEmployeeMenuProperties()).fire(this);
}",0.9690346083788708
54073,"public boolean isLeaf(Object value){
  return !isDepartment(value) || isAllDepartment(value);
}","public boolean isLeaf(Object value){
  return value != null && (!isDepartment(value) || isAllDepartment(value));
}",0.9090909090909092
54074,"private Collection<Property<?>> getEmployeeMenuProperties(){
  List<Property<?>> columns=new ArrayList<Property<?>>();
  columns.add(EmployeeRecord.displayName);
  columns.add(EmployeeRecord.userName);
  return columns;
}","private String[] getEmployeeMenuProperties(){
  return new String[]{EmployeeRecord.displayName.getName(),EmployeeRecord.userName.getName()};
}",0.6005509641873278
54075,"/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  long employeeId=1;
  try {
    String value=Window.Location.getParameter(EMPLOYEE_ID_PARAM);
    if (value != null && value.length() > 0) {
      employeeId=Long.parseLong(value);
    }
  }
 catch (  NumberFormatException e) {
    RootPanel.get().add(new Label(""String_Node_Str""));
    return;
  }
  final HandlerManager eventBus=new HandlerManager(null);
  final ExpensesRequestFactory requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  final long finalEmployeeId=employeeId;
  requestFactory.employeeRequest().findEmployee(Value.of(employeeId)).fire(new Receiver<EmployeeRecord>(){
    public void onSuccess(    EmployeeRecord employee,    Set<SyncResult> syncResults){
      final ExpensesMobileShell shell=new ExpensesMobileShell(eventBus,requestFactory,employee);
      RootPanel.get().add(shell);
      eventBus.addHandler(RequestEvent.TYPE,new AuthenticationFailureHandler());
      final LoginWidget login=shell.getLoginWidget();
      Receiver<UserInformationRecord> receiver=new Receiver<UserInformationRecord>(){
        public void onSuccess(        UserInformationRecord userInformationRecord,        Set<SyncResult> syncResults){
          login.setUserInformation(userInformationRecord);
        }
      }
;
      requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
    }
  }
);
}","/** 
 * This is the entry point method.
 */
public void onModuleLoad(){
  GWT.setUncaughtExceptionHandler(new GWT.UncaughtExceptionHandler(){
    public void onUncaughtException(    Throwable e){
      Window.alert(""String_Node_Str"" + e.getMessage());
    }
  }
);
  long employeeId=1;
  try {
    String value=Window.Location.getParameter(EMPLOYEE_ID_PARAM);
    if (value != null && value.length() > 0) {
      employeeId=Long.parseLong(value);
    }
  }
 catch (  NumberFormatException e) {
    RootPanel.get().add(new Label(""String_Node_Str""));
    return;
  }
  final HandlerManager eventBus=new HandlerManager(null);
  final ExpensesRequestFactory requestFactory=GWT.create(ExpensesRequestFactory.class);
  requestFactory.init(eventBus);
  requestFactory.employeeRequest().findEmployee(Value.of(employeeId)).fire(new Receiver<EmployeeRecord>(){
    public void onSuccess(    EmployeeRecord employee,    Set<SyncResult> syncResults){
      final ExpensesMobileShell shell=new ExpensesMobileShell(eventBus,requestFactory,employee);
      RootPanel.get().add(shell);
      eventBus.addHandler(RequestEvent.TYPE,new AuthenticationFailureHandler());
      final LoginWidget login=shell.getLoginWidget();
      Receiver<UserInformationRecord> receiver=new Receiver<UserInformationRecord>(){
        public void onSuccess(        UserInformationRecord userInformationRecord,        Set<SyncResult> syncResults){
          login.setUserInformation(userInformationRecord);
        }
      }
;
      requestFactory.userInformationRequest().getCurrentUserInformation(Location.getHref()).fire(receiver);
    }
  }
);
}",0.9874425727411944
54076,"public void create(ReportRecord report){
  expense=(ExpenseRecord)requestFactory.create(ExpenseRecord.class);
  requestObject=requestFactory.expenseRequest().persist(expense);
  ExpenseRecord editableExpense=requestObject.edit(expense);
  editableExpense.setReport(report);
  displayExpense();
}","public void create(ReportRecord report){
  expense=requestFactory.create(ExpenseRecord.class);
  requestObject=requestFactory.expenseRequest().persist(expense);
  ExpenseRecord editableExpense=requestObject.edit(expense);
  editableExpense.setReport(report);
  displayExpense();
}",0.9739130434782608
54077,"private Collection<Property<?>> getExpenseColumns(){
  List<Property<?>> columns=new ArrayList<Property<?>>();
  columns.add(ExpenseRecord.description);
  columns.add(ExpenseRecord.amount);
  return columns;
}","private String[] getExpenseColumns(){
  return new String[]{ExpenseRecord.description.getName(),ExpenseRecord.amount.getName()};
}",0.5722713864306784
54078,"/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  if (requestFactory == null || report == null) {
    return;
  }
  lastReceiver=new Receiver<List<ExpenseRecord>>(){
    public void onSuccess(    List<ExpenseRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        int size=newValues.size();
        expenseDataProvider.updateRowCount(size,true);
        expenseDataProvider.updateRowData(0,newValues);
        boolean isInitialData=knownDeniedKeys == null;
        if (knownDeniedKeys == null) {
          knownDeniedKeys=new HashSet<Object>();
        }
        for (        ExpenseRecord value : newValues) {
          Object key=expenseDataProvider.getKey(value);
          String approval=value.getApproval();
          if (Expenses.Approval.DENIED.getText().equals(approval)) {
            if (!isInitialData && !knownDeniedKeys.contains(key)) {
              (new PhaseAnimation.CellListPhaseAnimation<ExpenseRecord>(expenseList,value,expenseDataProvider)).run();
            }
            knownDeniedKeys.add(key);
          }
 else {
            knownDeniedKeys.remove(key);
          }
        }
        refreshTimer.schedule(REFRESH_INTERVAL);
      }
    }
  }
;
  requestFactory.expenseRequest().findExpensesByReport(report.getRef(ReportRecord.id)).forProperties(getExpenseColumns()).fire(lastReceiver);
}","/** 
 * Request the expenses.
 */
private void requestExpenses(){
  refreshTimer.cancel();
  if (requestFactory == null || report == null) {
    return;
  }
  lastReceiver=new Receiver<List<ExpenseRecord>>(){
    public void onSuccess(    List<ExpenseRecord> newValues,    Set<SyncResult> syncResults){
      if (this == lastReceiver) {
        int size=newValues.size();
        expenseDataProvider.updateRowCount(size,true);
        expenseDataProvider.updateRowData(0,newValues);
        boolean isInitialData=knownDeniedKeys == null;
        if (knownDeniedKeys == null) {
          knownDeniedKeys=new HashSet<Object>();
        }
        for (        ExpenseRecord value : newValues) {
          Object key=expenseDataProvider.getKey(value);
          String approval=value.getApproval();
          if (Expenses.Approval.DENIED.getText().equals(approval)) {
            if (!isInitialData && !knownDeniedKeys.contains(key)) {
              (new PhaseAnimation.CellListPhaseAnimation<ExpenseRecord>(expenseList,value,expenseDataProvider)).run();
            }
            knownDeniedKeys.add(key);
          }
 else {
            knownDeniedKeys.remove(key);
          }
        }
        refreshTimer.schedule(REFRESH_INTERVAL);
      }
    }
  }
;
  requestFactory.expenseRequest().findExpensesByReport(report.getRef(ReportRecord.id)).with(getExpenseColumns()).fire(lastReceiver);
}",0.9781126659490492
54079,"public void create(EmployeeRecord reporter){
  report=(ReportRecord)requestFactory.create(ReportRecord.class);
  requestObject=requestFactory.reportRequest().persist(report);
  ReportRecord editableReport=requestObject.edit(report);
  editableReport.setReporter(reporter);
  displayReport();
}","public void create(EmployeeRecord reporter){
  report=requestFactory.create(ReportRecord.class);
  requestObject=requestFactory.reportRequest().persist(report);
  ReportRecord editableReport=requestObject.edit(report);
  editableReport.setReporter(reporter);
  displayReport();
}",0.9755244755244756
54080,"private void requestReports(){
  if (requestFactory == null) {
    return;
  }
  lastReceiver=new Receiver<List<ReportRecord>>(){
    public void onSuccess(    List<ReportRecord> newValues,    Set<SyncResult> syncResults){
      int size=newValues.size();
      reportDataProvider.updateRowCount(size,true);
      reportDataProvider.updateRowData(0,newValues);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employee.getId(),""String_Node_Str"",""String_Node_Str"",ReportRecord.created.getName() + ""String_Node_Str"",0,25).forProperties(getReportColumns()).fire(lastReceiver);
}","private void requestReports(){
  if (requestFactory == null) {
    return;
  }
  lastReceiver=new Receiver<List<ReportRecord>>(){
    public void onSuccess(    List<ReportRecord> newValues,    Set<SyncResult> syncResults){
      int size=newValues.size();
      reportDataProvider.updateRowCount(size,true);
      reportDataProvider.updateRowData(0,newValues);
    }
  }
;
  requestFactory.reportRequest().findReportEntriesBySearch(employee.getId(),""String_Node_Str"",""String_Node_Str"",ReportRecord.created.getName() + ""String_Node_Str"",0,25).with(getReportColumns()).fire(lastReceiver);
}",0.950210970464135
54081,"private Collection<Property<?>> getReportColumns(){
  List<Property<?>> columns=new ArrayList<Property<?>>();
  columns.add(ReportRecord.created);
  columns.add(ReportRecord.purpose);
  return columns;
}","private String[] getReportColumns(){
  return new String[]{ReportRecord.created.getName(),ReportRecord.purpose.getName()};
}",0.5565749235474006
54082,"/** 
 * Create an instance with the given default value.
 * @param the value that will be returned by {@link #process} if{@link #setResult} is not called.
 */
public ExpensesEntityTypesProcessor(T defaultValue){
  this.defaultValue=defaultValue;
}","/** 
 * Create an instance with the given default value.
 * @param defaultValue the value that will be returned by {@link #process} if{@link #setResult} is not called.
 */
public ExpensesEntityTypesProcessor(T defaultValue){
  this.defaultValue=defaultValue;
}",0.9743589743589745
54083,"/** 
 * Flush pending list changes to the displays. By default,
 */
private void flushNow(){
  if (flushPending) {
    flushCancelled=true;
  }
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateRowCount(curSize,true);
  }
  if (modified) {
    updateRowData(minModified,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
}","/** 
 * Flush pending list changes to the displays. By default,
 */
private void flushNow(){
  if (flushPending) {
    flushCancelled=true;
  }
  if (listWrapper != this) {
    return;
  }
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateRowCount(curSize,true);
  }
  if (modified) {
    updateRowData(minModified,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
}",0.9510337323177368
54084,"public void testSetList(){
  ListDataProvider<String> provider=createListDataProvider(10);
  MockHasData<String> display=new MockHasData<String>();
  display.setVisibleRange(0,15);
  provider.addDataDisplay(display);
  provider.flush();
  display.clearLastRowDataAndRange();
  assertEquals(""String_Node_Str"",provider.getList().get(0));
  List<String> replace=new ArrayList<String>();
  replace.add(""String_Node_Str"");
  provider.setList(replace);
  assertEquals(""String_Node_Str"",provider.getList().get(0));
  assertEquals(1,display.getRowCount());
  assertEquals(replace,display.getLastRowData());
  assertEquals(new Range(0,1),display.getLastRowDataRange());
}","public void testSetList(){
  ListDataProvider<String> provider=createListDataProvider(10);
  final MockHasData<String> display=new MockHasData<String>();
  display.setVisibleRange(0,15);
  provider.addDataDisplay(display);
  provider.flush();
  display.clearLastRowDataAndRange();
  List<String> oldList=provider.getList();
  assertEquals(""String_Node_Str"",oldList.get(0));
  List<String> replace=new ArrayList<String>();
  replace.add(""String_Node_Str"");
  provider.setList(replace);
  assertEquals(""String_Node_Str"",provider.getList().get(0));
  assertEquals(1,display.getRowCount());
  assertEquals(replace,display.getLastRowData());
  assertEquals(new Range(0,1),display.getLastRowDataRange());
  display.clearLastRowDataAndRange();
  oldList.set(0,""String_Node_Str"");
  delayTestFinish(2000);
  Scheduler.get().scheduleDeferred(new ScheduledCommand(){
    public void execute(){
      assertNull(display.getLastRowData());
      finishTest();
    }
  }
);
}",0.7931034482758621
54085,"public Object encodePropertyValue(Object value){
  if (value == null) {
    return value;
  }
  Class<?> type=value.getClass();
  if (Boolean.class == type) {
    return value;
  }
  if (Date.class == type) {
    return String.valueOf(((Date)value).getTime());
  }
  if (Enum.class.isAssignableFrom(type)) {
    return Double.valueOf(((Enum<?>)value).ordinal());
  }
  if (BigDecimal.class == type || BigInteger.class == type || Long.class == type) {
    return String.valueOf(value);
  }
  if (Number.class.isAssignableFrom(type)) {
    return ((Number)value).doubleValue();
  }
  return String.valueOf(value);
}","public Object encodePropertyValue(Object value){
  if (value == null) {
    return value;
  }
  Class<?> type=value.getClass();
  if (Boolean.class == type) {
    return value;
  }
  if (Date.class.isAssignableFrom(type)) {
    return String.valueOf(((Date)value).getTime());
  }
  if (Enum.class.isAssignableFrom(type)) {
    return Double.valueOf(((Enum<?>)value).ordinal());
  }
  if (BigDecimal.class == type || BigInteger.class == type || Long.class == type) {
    return String.valueOf(value);
  }
  if (Number.class.isAssignableFrom(type)) {
    return ((Number)value).doubleValue();
  }
  return String.valueOf(value);
}",0.9750201450443192
54086,"public void testEndToEndSmartDiff_SomeChange(){
  com.google.gwt.valuestore.server.SimpleFoo.reset();
  try {
    JSONObject foo=fetchVerifyAndGetInitialObject();
    SimpleFoo fooResult=SimpleFoo.getSingleton();
    fooResult.setUserName(""String_Node_Str"");
    fooResult.setIntId(45);
    foo.put(""String_Node_Str"",""String_Node_Str"");
    foo.put(""String_Node_Str"",45);
    Date now=new Date();
    foo.put(""String_Node_Str"",""String_Node_Str"" + now.getTime());
    JSONObject result=getResultFromServer(foo);
    assertTrue(result.getJSONObject(""String_Node_Str"").has(""String_Node_Str""));
    fooResult=SimpleFoo.getSingleton();
    assertEquals((int)45,(int)fooResult.getIntId());
    assertEquals(""String_Node_Str"",fooResult.getUserName());
    assertEquals(now,fooResult.getCreated());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.toString());
  }
}","public void testEndToEndSmartDiff_SomeChange(){
  com.google.gwt.valuestore.server.SimpleFoo.reset();
  try {
    JSONObject foo=fetchVerifyAndGetInitialObject();
    SimpleFoo fooResult=SimpleFoo.getSingleton();
    fooResult.setUserName(""String_Node_Str"");
    fooResult.setIntId(45);
    foo.put(""String_Node_Str"",""String_Node_Str"");
    foo.put(""String_Node_Str"",45);
    Date now=new Date();
    long newTime=now.getTime() + 10000;
    foo.put(""String_Node_Str"",""String_Node_Str"" + newTime);
    JSONObject result=getResultFromServer(foo);
    assertTrue(result.getJSONObject(""String_Node_Str"").has(""String_Node_Str""));
    fooResult=SimpleFoo.getSingleton();
    assertEquals((int)45,(int)fooResult.getIntId());
    assertEquals(""String_Node_Str"",fooResult.getUserName());
    assertEquals(newTime,fooResult.getCreated().getTime());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.toString());
  }
}",0.9643652561247216
54087,"/** 
 * Handle a keyboard event to move focus away from the current item.
 */
void keyboardExit(){
  if (keyboardSelection == null) {
    return;
  }
  Element child=keyboardSelection.getFirstChildElement().getFirstChildElement();
  child.removeAttribute(""String_Node_Str"");
  child.removeClassName(tree.getStyle().keyboardSelectedItem());
  keyboardSelection=null;
  keyboardSelectedIndex=-1;
  keyboardFocused=false;
}","/** 
 * Handle a keyboard event to move focus away from the current item.
 */
void keyboardExit(){
  if (keyboardSelection == null) {
    return;
  }
  Element child=keyboardSelection.getFirstChildElement().getFirstChildElement();
  child.removeAttribute(""String_Node_Str"");
  child.removeClassName(tree.getStyle().keyboardSelectedItem());
  keyboardSelection=null;
  keyboardFocused=false;
}",0.9655172413793104
54088,"String toJson(){
  if (operations.size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return toJsonWithoutChecks();
}","String toJson(){
}",0.2155688622754491
54089,"public void testSeparateIds(){
  RecordImpl createRecord=(RecordImpl)requestFactory.create(SimpleFooRecord.class);
  assertTrue(createRecord.isFuture());
  Long futureId=createRecord.getId();
  RecordImpl mockRecord=new RecordImpl(RecordJsoImpl.create(futureId,1,SimpleFooRecordImpl.SCHEMA),RequestFactoryJsonImpl.NOT_FUTURE);
  valueStore.setRecord(mockRecord.asJso(),requestFactory);
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.set(SimpleFooRecord.userName,createRecord,""String_Node_Str"");
  deltaValueStore.set(SimpleFooRecord.userName,mockRecord,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  String jsonString=deltaValueStore.toJsonWithoutChecks();
  JSONObject jsonObject=(JSONObject)JSONParser.parse(jsonString);
  assertFalse(jsonObject.containsKey(WriteOperation.DELETE.name()));
  assertTrue(jsonObject.containsKey(WriteOperation.CREATE.name()));
  assertTrue(jsonObject.containsKey(WriteOperation.UPDATE.name()));
  JSONArray createOperationArray=jsonObject.get(WriteOperation.CREATE.name()).isArray();
  assertEquals(1,createOperationArray.size());
  assertEquals(""String_Node_Str"",createOperationArray.get(0).isObject().get(SimpleFooRecord.class.getName()).isObject().get(SimpleFooRecord.userName.getName()).isString().stringValue());
  JSONArray updateOperationArray=jsonObject.get(WriteOperation.UPDATE.name()).isArray();
  assertEquals(1,updateOperationArray.size());
  assertEquals(""String_Node_Str"",updateOperationArray.get(0).isObject().get(SimpleFooRecord.class.getName()).isObject().get(SimpleFooRecord.userName.getName()).isString().stringValue());
}","public void testSeparateIds(){
  RecordImpl createRecord=(RecordImpl)requestFactory.create(SimpleFooRecord.class);
  assertTrue(createRecord.isFuture());
  Long futureId=createRecord.getId();
  RecordImpl mockRecord=new RecordImpl(RecordJsoImpl.create(futureId,1,SimpleFooRecordImpl.SCHEMA),RequestFactoryJsonImpl.NOT_FUTURE);
  valueStore.setRecord(mockRecord.asJso(),requestFactory);
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.set(SimpleFooRecord.userName,createRecord,""String_Node_Str"");
  deltaValueStore.set(SimpleFooRecord.userName,mockRecord,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  String jsonString=deltaValueStore.toJson();
  JSONObject jsonObject=(JSONObject)JSONParser.parse(jsonString);
  assertFalse(jsonObject.containsKey(WriteOperation.DELETE.name()));
  assertTrue(jsonObject.containsKey(WriteOperation.CREATE.name()));
  assertTrue(jsonObject.containsKey(WriteOperation.UPDATE.name()));
  JSONArray createOperationArray=jsonObject.get(WriteOperation.CREATE.name()).isArray();
  assertEquals(1,createOperationArray.size());
  assertEquals(""String_Node_Str"",createOperationArray.get(0).isObject().get(SimpleFooRecord.class.getName()).isObject().get(SimpleFooRecord.userName.getName()).isString().stringValue());
  JSONArray updateOperationArray=jsonObject.get(WriteOperation.UPDATE.name()).isArray();
  assertEquals(1,updateOperationArray.size());
  assertEquals(""String_Node_Str"",updateOperationArray.get(0).isObject().get(SimpleFooRecord.class.getName()).isObject().get(SimpleFooRecord.userName.getName()).isString().stringValue());
}",0.9960736937481124
54090,"public void testCreate(){
  Record created=requestFactory.create(SimpleFooRecord.class);
  assertNotNull(created.getId());
  assertNotNull(created.getVersion());
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  assertFalse(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,created,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.CREATE);
}","public void testCreate(){
  Record created=requestFactory.create(SimpleFooRecord.class);
  assertNotNull(created.getId());
  assertNotNull(created.getVersion());
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  String json=deltaValueStore.toJson();
  testAndGetChangeRecord(json,WriteOperation.CREATE);
}",0.704225352112676
54091,"@Override public void gwtSetUp(){
  valueStore=new ValueStoreJsonImpl();
  requestFactory=new RequestFactoryJsonImpl(){
    public Record create(    Class token){
      return create(token,typeMap);
    }
    public RecordSchema getSchema(    String token){
      return typeMap.getType(token);
    }
    @Override public void init(    EventBus eventBus){
    }
    public LoggingRequest loggingRequest(){
      return null;
    }
    public Class<? extends Record> getClass(    String token){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    public Record getProxy(    String token){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    public String getToken(    Class<? extends Record> clazz){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
;
  jso=RecordJsoImpl.fromJson(""String_Node_Str"");
  jso.set(SimpleFooRecord.id,42L);
  jso.set(SimpleFooRecord.version,1);
  jso.set(SimpleFooRecord.userName,""String_Node_Str"");
  jso.set(SimpleFooRecord.password,""String_Node_Str"");
  jso.set(SimpleFooRecord.intId,4);
  jso.set(SimpleFooRecord.created,new Date());
  jso.setSchema(SimpleFooRecordImpl.SCHEMA);
  valueStore.setRecord(jso,requestFactory);
}","@Override public void gwtSetUp(){
  valueStore=new ValueStoreJsonImpl();
  requestFactory=new RequestFactoryJsonImpl(){
    public Record create(    Class token){
      return create(token,typeMap);
    }
    @Override public RecordSchema getSchema(    String token){
      return typeMap.getType(token);
    }
    @Override public void init(    EventBus eventBus){
    }
    public LoggingRequest loggingRequest(){
      return null;
    }
    public Class<? extends Record> getClass(    String token){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    public Record getProxy(    String token){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    public String getToken(    Class<? extends Record> clazz){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
;
  jso=RecordJsoImpl.fromJson(""String_Node_Str"");
  jso.set(SimpleFooRecord.id,42L);
  jso.set(SimpleFooRecord.version,1);
  jso.set(SimpleFooRecord.userName,""String_Node_Str"");
  jso.set(SimpleFooRecord.password,""String_Node_Str"");
  jso.set(SimpleFooRecord.intId,4);
  jso.set(SimpleFooRecord.created,new Date());
  jso.setSchema(SimpleFooRecordImpl.SCHEMA);
  valueStore.setRecord(jso,requestFactory);
}",0.9959514170040484
54092,"public RecordSchema getSchema(String token){
  return typeMap.getType(token);
}","@Override public RecordSchema getSchema(String token){
  return typeMap.getType(token);
}",0.9404761904761904
54093,"/** 
 * Returns the propertyValue in the right type, from the DataStore. The value is sent into the response.
 */
public Object encodePropertyValueFromDataStore(Object entityElement,Class<?> propertyType,String propertyName,RequestProperty propertyContext) throws SecurityException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, JSONException {
  String methodName=getMethodNameFromPropertyName(propertyName,""String_Node_Str"");
  Method method=entityElement.getClass().getMethod(methodName);
  Object returnValue=method.invoke(entityElement);
  if (returnValue != null && Record.class.isAssignableFrom(propertyType)) {
    Method idMethod=entityElement.getClass().getMethod(""String_Node_Str"");
    Long id=(Long)idMethod.invoke(entityElement);
    String keyRef=operationRegistry.getSecurityProvider().encodeClassType(propertyType) + ""String_Node_Str"" + id;
    addRelatedObject(keyRef,returnValue,(Class<? extends Record>)propertyType,propertyContext.getProperty(propertyName));
    return keyRef;
  }
  return encodePropertyValue(returnValue);
}","/** 
 * Returns the propertyValue in the right type, from the DataStore. The value is sent into the response.
 */
public Object encodePropertyValueFromDataStore(Object entityElement,Class<?> propertyType,String propertyName,RequestProperty propertyContext) throws SecurityException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, JSONException {
  String methodName=getMethodNameFromPropertyName(propertyName,""String_Node_Str"");
  Method method=entityElement.getClass().getMethod(methodName);
  Object returnValue=method.invoke(entityElement);
  if (returnValue != null && Record.class.isAssignableFrom(propertyType)) {
    Method idMethod=returnValue.getClass().getMethod(""String_Node_Str"");
    Long id=(Long)idMethod.invoke(returnValue);
    String keyRef=operationRegistry.getSecurityProvider().encodeClassType(propertyType) + ""String_Node_Str"" + id;
    addRelatedObject(keyRef,returnValue,(Class<? extends Record>)propertyType,propertyContext.getProperty(propertyName));
    return keyRef;
  }
  return encodePropertyValue(returnValue);
}",0.977632805219012
54094,"public void onWindowResized(int width,int height){
  if (width == windowWidth || width < 1) {
    return;
  }
  windowWidth=width;
  onWindowResizedImpl(width);
}","@SuppressWarnings(""String_Node_Str"") public void onWindowResized(int width,int height){
  if (width == windowWidth || width < 1) {
    return;
  }
  windowWidth=width;
  onWindowResizedImpl(width);
}",0.8975069252077562
54095,"/** 
 * Load the contents of a remote file into the specified widget.
 * @param url a partial path relative to the module base URL
 * @param target the target Widget to place the contents
 * @param callback the callback when the call completes
 */
private void requestSourceContents(String url,final HTML target,final RequestCallback callback){
  if (loadingImage == null) {
    loadingImage=""String_Node_Str"" + GWT.getModuleBaseURL() + ""String_Node_Str"";
  }
  target.setDirection(HasDirection.Direction.LTR);
  DOM.setStyleAttribute(target.getElement(),""String_Node_Str"",""String_Node_Str"");
  target.setHTML(""String_Node_Str"" + loadingImage);
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,GWT.getModuleBaseURL() + url);
  RequestCallback realCallback=new RequestCallback(){
    public void onError(    Request request,    Throwable exception){
      target.setHTML(""String_Node_Str"");
      if (callback != null) {
        callback.onError(request,exception);
      }
    }
    public void onResponseReceived(    Request request,    Response response){
      target.setHTML(response.getText());
      if (callback != null) {
        callback.onResponseReceived(request,response);
      }
    }
  }
;
  builder.setCallback(realCallback);
  try {
    builder.send();
  }
 catch (  RequestException e) {
    realCallback.onError(null,e);
  }
}","/** 
 * Load the contents of a remote file into the specified widget.
 * @param url a partial path relative to the module base URL
 * @param target the target Widget to place the contents
 * @param callback the callback when the call completes
 */
@SuppressWarnings(""String_Node_Str"") private void requestSourceContents(String url,final HTML target,final RequestCallback callback){
  if (loadingImage == null) {
    loadingImage=""String_Node_Str"" + GWT.getModuleBaseURL() + ""String_Node_Str"";
  }
  target.setDirection(HasDirection.Direction.LTR);
  DOM.setStyleAttribute(target.getElement(),""String_Node_Str"",""String_Node_Str"");
  target.setHTML(""String_Node_Str"" + loadingImage);
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,GWT.getModuleBaseURL() + url);
  RequestCallback realCallback=new RequestCallback(){
    public void onError(    Request request,    Throwable exception){
      target.setHTML(""String_Node_Str"");
      if (callback != null) {
        callback.onError(request,exception);
      }
    }
    public void onResponseReceived(    Request request,    Response response){
      target.setHTML(response.getText());
      if (callback != null) {
        callback.onResponseReceived(request,response);
      }
    }
  }
;
  builder.setCallback(realCallback);
  try {
    builder.send();
  }
 catch (  RequestException e) {
    realCallback.onError(null,e);
  }
}",0.9865698729582576
54096,"/** 
 * Initialize this example.
 */
@ShowcaseSource @Override public Widget onInitialize(){
  DecoratedTabPanel tabPanel=new DecoratedTabPanel();
  tabPanel.setWidth(""String_Node_Str"");
  tabPanel.setAnimationEnabled(true);
  String[] tabTitles=constants.cwTabPanelTabs();
  HTML homeText=new HTML(constants.cwTabPanelTab0());
  tabPanel.add(homeText,tabTitles[0]);
  VerticalPanel vPanel=new VerticalPanel();
  vPanel.add(new Image(Showcase.images.gwtLogo()));
  tabPanel.add(vPanel,tabTitles[1]);
  HTML moreInfo=new HTML(constants.cwTabPanelTab2());
  tabPanel.add(moreInfo,tabTitles[2]);
  tabPanel.selectTab(0);
  tabPanel.ensureDebugId(""String_Node_Str"");
  return tabPanel;
}","/** 
 * Initialize this example.
 */
@SuppressWarnings(""String_Node_Str"") @ShowcaseSource @Override public Widget onInitialize(){
  DecoratedTabPanel tabPanel=new DecoratedTabPanel();
  tabPanel.setWidth(""String_Node_Str"");
  tabPanel.setAnimationEnabled(true);
  String[] tabTitles=constants.cwTabPanelTabs();
  HTML homeText=new HTML(constants.cwTabPanelTab0());
  tabPanel.add(homeText,tabTitles[0]);
  VerticalPanel vPanel=new VerticalPanel();
  vPanel.add(new Image(Showcase.images.gwtLogo()));
  tabPanel.add(vPanel,tabTitles[1]);
  HTML moreInfo=new HTML(constants.cwTabPanelTab2());
  tabPanel.add(moreInfo,tabTitles[2]);
  tabPanel.selectTab(0);
  tabPanel.ensureDebugId(""String_Node_Str"");
  return tabPanel;
}",0.9736279401282965
54097,"/** 
 * Initialize this example.
 */
@ShowcaseSource @Override public Widget onInitialize(){
  DatePicker datePicker=new DatePicker();
  final Label text=new Label();
  datePicker.addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      String dateString=DateTimeFormat.getMediumDateFormat().format(date);
      text.setText(dateString);
    }
  }
);
  datePicker.setValue(new Date(),true);
  DateTimeFormat dateFormat=DateTimeFormat.getLongDateFormat();
  DateBox dateBox=new DateBox();
  dateBox.setFormat(new DateBox.DefaultFormat(dateFormat));
  VerticalPanel vPanel=new VerticalPanel();
  vPanel.add(new HTML(constants.cwDatePickerLabel()));
  vPanel.add(text);
  vPanel.add(datePicker);
  vPanel.add(new HTML(constants.cwDatePickerBoxLabel()));
  vPanel.add(dateBox);
  return vPanel;
}","/** 
 * Initialize this example.
 */
@SuppressWarnings(""String_Node_Str"") @ShowcaseSource @Override public Widget onInitialize(){
  DatePicker datePicker=new DatePicker();
  final Label text=new Label();
  datePicker.addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      String dateString=DateTimeFormat.getMediumDateFormat().format(date);
      text.setText(dateString);
    }
  }
);
  datePicker.setValue(new Date(),true);
  DateTimeFormat dateFormat=DateTimeFormat.getLongDateFormat();
  DateBox dateBox=new DateBox();
  dateBox.setFormat(new DateBox.DefaultFormat(dateFormat));
  VerticalPanel vPanel=new VerticalPanel();
  vPanel.add(new HTML(constants.cwDatePickerLabel()));
  vPanel.add(text);
  vPanel.add(datePicker);
  vPanel.add(new HTML(constants.cwDatePickerBoxLabel()));
  vPanel.add(dateBox);
  return vPanel;
}",0.9797260273972602
54098,"@SuppressWarnings(""String_Node_Str"") public <P extends Record>P edit(P record){
  P returnRecordImpl=(P)((RecordImpl)record).getSchema().create(((RecordImpl)record).asJso());
  ((RecordImpl)returnRecordImpl).setDeltaValueStore(deltaValueStore);
  return returnRecordImpl;
}","@SuppressWarnings(""String_Node_Str"") public <P extends Record>P edit(P record){
  P returnRecordImpl=(P)((RecordImpl)record).getSchema().create(((RecordImpl)record).asJso(),((RecordImpl)record).isFuture());
  ((RecordImpl)returnRecordImpl).setDeltaValueStore(deltaValueStore);
  return returnRecordImpl;
}",0.944636678200692
54099,"public String toJson(){
  used=true;
  if (operations.size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  StringBuffer jsonData=new StringBuffer(""String_Node_Str"");
  for (  WriteOperation writeOperation : WriteOperation.values()) {
    String jsonDataForOperation=getJsonForOperation(writeOperation);
    if (jsonDataForOperation.equals(""String_Node_Str"")) {
      continue;
    }
    if (jsonData.length() > 1) {
      jsonData.append(""String_Node_Str"");
    }
    jsonData.append(jsonDataForOperation);
  }
  jsonData.append(""String_Node_Str"");
  return jsonData.toString();
}","String toJson(){
  if (operations.size() > 1) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return toJsonWithoutChecks();
}",0.3552631578947368
54100,"protected RecordKey(Long id,RecordSchema<?> schema){
}","protected RecordKey(Long id,RecordSchema<?> schema,boolean isFuture){
}",0.864
54101,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((id == null) ? 0 : id.hashCode());
  result=prime * result + ((schema == null) ? 0 : schema.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=(isFuture ? 0 : 1);
  result=prime * result + ((id == null) ? 0 : id.hashCode());
  result=prime * result + ((schema == null) ? 0 : schema.hashCode());
  return result;
}",0.9629629629629628
54102,"@Override public String toString(){
  return ""String_Node_Str"" + schema.getClass().getName() + ""String_Node_Str""+ id+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + schema.getClass().getName() + ""String_Node_Str""+ id+ ""String_Node_Str""+ (isFuture ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"";
}",0.7953890489913544
54103,"private Record createFuture(RecordSchema<? extends Record> schema){
  Long futureId=futureIdGenerator.getFutureId();
  RecordJsoImpl newRecord=RecordJsoImpl.create(futureId,INITIAL_VERSION,schema);
  RecordKey recordKey=new RecordKey(newRecord);
  creates.put(recordKey,newRecord);
  return schema.create(newRecord);
}","private Record createFuture(RecordSchema<? extends Record> schema){
  Long futureId=++currentFutureId;
  RecordJsoImpl newRecord=RecordJsoImpl.create(futureId,INITIAL_VERSION,schema);
  RecordKey recordKey=new RecordKey(newRecord,IS_FUTURE);
  creates.put(recordKey,newRecord);
  return schema.create(newRecord,IS_FUTURE);
}",0.9221183800623052
54104,"public void fire(final RequestObject<?> requestObject){
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,GWT.getHostPageBaseURL() + RequestFactory.URL);
  builder.setHeader(""String_Node_Str"",RequestFactory.JSON_CONTENT_TYPE_UTF8);
  builder.setHeader(""String_Node_Str"",Location.getHref());
  builder.setRequestData(ClientRequestHelper.getRequestString(requestObject.getRequestData().getRequestMap(((AbstractRequest)requestObject).deltaValueStore.toJson())));
  builder.setCallback(new RequestCallback(){
    public void onError(    Request request,    Throwable exception){
      postRequestEvent(State.RECEIVED,null);
      wireLogger.log(Level.SEVERE,SERVER_ERROR,exception);
    }
    public void onResponseReceived(    Request request,    Response response){
      wireLogger.finest(""String_Node_Str"");
      if (200 == response.getStatusCode()) {
        String text=response.getText();
        requestObject.handleResponseText(text);
      }
 else       if (Response.SC_UNAUTHORIZED == response.getStatusCode()) {
        wireLogger.finest(""String_Node_Str"");
      }
 else       if (response.getStatusCode() > 0) {
        wireLogger.severe(SERVER_ERROR + ""String_Node_Str"" + response.getStatusCode()+ ""String_Node_Str""+ response.getText());
      }
      postRequestEvent(State.RECEIVED,response);
    }
  }
);
  try {
    wireLogger.finest(""String_Node_Str"");
    builder.send();
    postRequestEvent(State.SENT,null);
  }
 catch (  RequestException e) {
    wireLogger.log(Level.SEVERE,SERVER_ERROR + ""String_Node_Str"" + e.getMessage()+ ""String_Node_Str"",e);
  }
}","public void fire(final RequestObject<?> requestObject){
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,GWT.getHostPageBaseURL() + RequestFactory.URL);
  builder.setHeader(""String_Node_Str"",RequestFactory.JSON_CONTENT_TYPE_UTF8);
  builder.setHeader(""String_Node_Str"",Location.getHref());
  builder.setRequestData(ClientRequestHelper.getRequestString(requestObject.getRequestData().getRequestMap(((AbstractRequest<?,?>)requestObject).deltaValueStore.toJson())));
  builder.setCallback(new RequestCallback(){
    public void onError(    Request request,    Throwable exception){
      postRequestEvent(State.RECEIVED,null);
      wireLogger.log(Level.SEVERE,SERVER_ERROR,exception);
    }
    public void onResponseReceived(    Request request,    Response response){
      wireLogger.finest(""String_Node_Str"");
      if (200 == response.getStatusCode()) {
        String text=response.getText();
        requestObject.handleResponseText(text);
      }
 else       if (Response.SC_UNAUTHORIZED == response.getStatusCode()) {
        wireLogger.finest(""String_Node_Str"");
      }
 else       if (response.getStatusCode() > 0) {
        wireLogger.severe(SERVER_ERROR + ""String_Node_Str"" + response.getStatusCode()+ ""String_Node_Str""+ response.getText());
      }
      postRequestEvent(State.RECEIVED,response);
    }
  }
);
  try {
    wireLogger.finest(""String_Node_Str"");
    builder.send();
    postRequestEvent(State.SENT,null);
  }
 catch (  RequestException e) {
    wireLogger.log(Level.SEVERE,SERVER_ERROR + ""String_Node_Str"" + e.getMessage()+ ""String_Node_Str"",e);
  }
}",0.9984291548853284
54105,"/** 
 * @param newRecord
 * @param i
 * @param array
 */
private void setRecordInList(RecordJsoImpl newRecord,int i,JsArray<RecordJsoImpl> array){
  RecordKey recordKey=new RecordKey(newRecord);
  RecordJsoImpl oldRecord=records.get(recordKey);
  if (oldRecord == null) {
    records.put(recordKey,newRecord);
  }
 else {
    boolean changed=oldRecord.merge(newRecord);
    newRecord=oldRecord.cast();
    if (array != null) {
      array.set(i,newRecord);
    }
    if (changed) {
      eventBus.fireEvent(newRecord.getSchema().createChangeEvent(newRecord,WriteOperation.UPDATE));
    }
  }
}","/** 
 * @param newRecord
 * @param i
 * @param array
 */
private void setRecordInList(RecordJsoImpl newRecord,int i,JsArray<RecordJsoImpl> array){
  RecordKey recordKey=new RecordKey(newRecord,RequestFactoryJsonImpl.NOT_FUTURE);
  RecordJsoImpl oldRecord=records.get(recordKey);
  if (oldRecord == null) {
    records.put(recordKey,newRecord);
  }
 else {
    boolean changed=oldRecord.merge(newRecord);
    newRecord=oldRecord.cast();
    if (array != null) {
      array.set(i,newRecord);
    }
    if (changed) {
      eventBus.fireEvent(newRecord.getSchema().createChangeEvent(newRecord,WriteOperation.UPDATE));
    }
  }
}",0.9721311475409836
54106,"public void init(HandlerManager eventBus){
}","@Override public void init(HandlerManager eventBus){
}",0.8979591836734694
54107,"@Override public void gwtSetUp(){
  valueStore=new ValueStoreJsonImpl(null);
  requestFactory=new RequestFactoryJsonImpl(){
    public Record create(    Class token){
      return create(token,typeMap);
    }
    public void init(    HandlerManager eventBus){
    }
    public LoggingRequest loggingRequest(){
      return null;
    }
  }
;
  jso=RecordJsoImpl.fromJson(""String_Node_Str"");
  jso.set(SimpleFooRecord.id,42L);
  jso.set(SimpleFooRecord.version,1);
  jso.set(SimpleFooRecord.userName,""String_Node_Str"");
  jso.set(SimpleFooRecord.password,""String_Node_Str"");
  jso.set(SimpleFooRecord.intId,4);
  jso.set(SimpleFooRecord.created,new Date());
  jso.setSchema(SimpleFooRecordImpl.SCHEMA);
  valueStore.setRecord(jso);
}","@Override public void gwtSetUp(){
  valueStore=new ValueStoreJsonImpl(null);
  requestFactory=new RequestFactoryJsonImpl(){
    public Record create(    Class token){
      return create(token,typeMap);
    }
    @Override public void init(    HandlerManager eventBus){
    }
    public LoggingRequest loggingRequest(){
      return null;
    }
  }
;
  jso=RecordJsoImpl.fromJson(""String_Node_Str"");
  jso.set(SimpleFooRecord.id,42L);
  jso.set(SimpleFooRecord.version,1);
  jso.set(SimpleFooRecord.userName,""String_Node_Str"");
  jso.set(SimpleFooRecord.password,""String_Node_Str"");
  jso.set(SimpleFooRecord.intId,4);
  jso.set(SimpleFooRecord.created,new Date());
  jso.setSchema(SimpleFooRecordImpl.SCHEMA);
  valueStore.setRecord(jso);
}",0.9932065217391304
54108,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}",0.9230769230769232
54109,"public void testDeleteUpdate(){
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.delete(new MyRecordImpl(jso));
  assertTrue(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,new MyRecordImpl(jso),""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.UPDATE);
  changeRecord.get(SimpleFooRecord.userName.getName());
}","public void testDeleteUpdate(){
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.delete(new MyRecordImpl(jso));
  assertTrue(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,new MyRecordImpl(jso),""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.UPDATE);
  assertEquals(""String_Node_Str"",changeRecord.get(SimpleFooRecord.userName.getName()).isString().stringValue());
}",0.9469767441860464
54110,"public void testCreateUpdate(){
  Record created=requestFactory.create(SimpleFooRecord.class);
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  assertFalse(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,created,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.CREATE);
  changeRecord.get(SimpleFooRecord.userName.getName());
}","public void testCreateUpdate(){
  Record created=requestFactory.create(SimpleFooRecord.class);
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  assertFalse(deltaValueStore.isChanged());
  deltaValueStore.set(SimpleFooRecord.userName,created,""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.CREATE);
  assertEquals(""String_Node_Str"",changeRecord.get(SimpleFooRecord.userName.getName()).isString().stringValue());
}",0.947075208913649
54111,"public void testUpdate(){
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.set(SimpleFooRecord.userName,new MyRecordImpl(jso),""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.UPDATE);
  changeRecord.get(SimpleFooRecord.userName.getName());
}","public void testUpdate(){
  DeltaValueStoreJsonImpl deltaValueStore=new DeltaValueStoreJsonImpl(valueStore,requestFactory);
  deltaValueStore.set(SimpleFooRecord.userName,new MyRecordImpl(jso),""String_Node_Str"");
  assertTrue(deltaValueStore.isChanged());
  JSONObject changeRecord=testAndGetChangeRecord(deltaValueStore.toJson(),WriteOperation.UPDATE);
  assertEquals(""String_Node_Str"",changeRecord.get(SimpleFooRecord.userName.getName()).isString().stringValue());
}",0.9351535836177476
54112,"/** 
 * Called to fetch the string token needed to get a new record via  {@link DeltaValueStore#create}.
 */
protected abstract Class getRecordClass();","/** 
 * Called to fetch the string token needed to get a new record via  {@link DeltaValueStore#create}.
 */
protected abstract Class<? extends Record> getRecordClass();",0.94375
54113,"/** 
 * Ignore DevMode's normal WEB-INF classloader rules and just allow the system classloader to dominate. This makes JUnitHostImpl live in the right classloader (mine).
 */
@SuppressWarnings(""String_Node_Str"") @Override protected WebAppContext createWebAppContext(TreeLogger logger,File appRootDir){
  return new WebAppContext(appRootDir.getAbsolutePath(),""String_Node_Str""){
{
      getInitParams().put(""String_Node_Str"",""String_Node_Str"");
      setParentLoaderPriority(true);
    }
  }
;
}","/** 
 * Ignore DevMode's normal WEB-INF classloader rules and just allow the system classloader to dominate. This makes JUnitHostImpl live in the right classloader (mine).
 */
@Override protected WebAppContext createWebAppContext(TreeLogger logger,File appRootDir){
  return new WebAppContext(appRootDir.getAbsolutePath(),""String_Node_Str""){
{
      getInitParams().put(""String_Node_Str"",""String_Node_Str"");
      setParentLoaderPriority(true);
    }
  }
;
}",0.9611752360965372
54114,"@Override public void flush(){
  if (!closed) {
    for (    LogRecord record : records) {
      Receiver<Long> loggingReciever=new LoggingReceiver();
      requestFactory.loggingRequest().logMessage(record.getLevel().toString(),record.getLoggerName(),record.getMessage()).fire(loggingReciever);
    }
  }
}","@Override public void flush(){
  if (!closed) {
    for (    LogRecord record : records) {
      Receiver<Long> loggingReceiver=new LoggingReceiver();
      requestFactory.loggingRequest().logMessage(record.getLevel().toString(),record.getLoggerName(),record.getMessage()).fire(loggingReceiver);
    }
  }
}",0.986970684039088
54115,"/** 
 * Generate an ID for a new record. The default behavior is to return null and let the data store generate the ID automatically.
 * @param key the key of the record field
 * @return the ID of the new record, or null to auto generate
 */
protected Long generateIdForCreate(@SuppressWarnings(""String_Node_Str"") String key){
  return null;
}","/** 
 * Generate an ID for a new record. The default behavior is to return null and let the data store generate the ID automatically.
 * @param key the key of the record field
 * @return the ID of the new record, or null to auto generate
 */
protected Long generateIdForCreate(String key){
  return null;
}",0.9429892141756548
54116,"/** 
 * Failed in all modes due to HtmlUnit bug:
 */
@DoNotRunWith({Platform.HtmlUnitBug}) public void testValueChangeEvent(){
  TextBoxBase tb=createTextBoxBase();
  RootPanel.get().add(tb);
  Handler h=new Handler();
  tb.addValueChangeHandler(h);
  tb.setValue(null);
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setText(""String_Node_Str"");
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"");
  assertNull(h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",h.received);
}","/** 
 * Failed in all modes due to HtmlUnit bug.
 */
@DoNotRunWith({Platform.HtmlUnitBug}) public void testValueChangeEvent(){
  TextBoxBase tb=createTextBoxBase();
  RootPanel.get().add(tb);
  Handler h=new Handler();
  tb.addValueChangeHandler(h);
  tb.setValue(null);
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setText(""String_Node_Str"");
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"");
  assertNull(h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",tb.getValue());
  assertNull(h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",h.received);
  tb.setValue(""String_Node_Str"",true);
  assertEquals(""String_Node_Str"",h.received);
}",0.998898678414097
54117,"/** 
 * Adds a widget to the panel at the specified position. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the widget to be added
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void add(Widget w,int left,int top){
  w.removeFromParent();
  int beforeIndex=getWidgetCount();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
}","/** 
 * Adds a widget to the panel at the specified position. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the widget to be added
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void add(Widget w,int left,int top){
  w.removeFromParent();
  int beforeIndex=getWidgetCount();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
  verifyPositionNotStatic(w);
}",0.9678111587982832
54118,"/** 
 * Inserts a child widget at the specified position before the specified index. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically. If the widget is already a child of this panel, it will be moved to the specified index.
 * @param w the child widget to be inserted
 * @param left the widget's left position
 * @param top the widget's top position
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int left,int top,int beforeIndex){
  w.removeFromParent();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
}","/** 
 * Inserts a child widget at the specified position before the specified index. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically. If the widget is already a child of this panel, it will be moved to the specified index.
 * @param w the child widget to be inserted
 * @param left the widget's left position
 * @param top the widget's top position
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int left,int top,int beforeIndex){
  w.removeFromParent();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
  verifyPositionNotStatic(w);
}",0.9790209790209792
54119,"/** 
 * Sets the position of the specified child widget. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the child widget to be positioned
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void setWidgetPosition(Widget w,int left,int top){
  checkWidgetParent(w);
  setWidgetPositionImpl(w,left,top);
}","/** 
 * Sets the position of the specified child widget. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the child widget to be positioned
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void setWidgetPosition(Widget w,int left,int top){
  checkWidgetParent(w);
  setWidgetPositionImpl(w,left,top);
  verifyPositionNotStatic(w);
}",0.9647058823529412
54120,"public void configureClientSideLogging(){
  Logger root=Logger.getLogger(""String_Node_Str"");
  setLevels(root);
  setDefaultHandlers(root);
}","public void configureClientSideLogging(){
  root=Logger.getLogger(""String_Node_Str"");
  setLevels(root);
  setDefaultHandlers(root);
}",0.9745454545454544
54121,"public void removeView(ListView<T> view){
  if (!views.contains(view)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  views.remove(view);
  view.setDelegate(null);
}","public void removeView(ListView<T> view){
  if (!views.contains(view)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  views.remove(view);
  view.setDataProvider(null);
}",0.967391304347826
54122,"/** 
 * Inform the views of the total number of items that are available.
 * @param size the new size
 * @param exact true if the size is exact, false if it is a guess
 */
protected void updateDataSize(int size,boolean exact){
  for (  ListView<T> view : views) {
    view.setDataSize(size,exact);
  }
}","/** 
 * Inform the views of the total number of items that are available.
 * @param size the new size
 * @param exact true if the size is exact, false if it is a guess
 */
protected void updateDataSize(int size,boolean exact){
  lastDataSize=size;
  lastDataSizeExact=exact;
  for (  ListView<T> view : views) {
    view.setDataSize(size,exact);
  }
}",0.926605504587156
54123,"/** 
 * Adds a view to this adapter. The current range of interest of the view will be populated with data.
 * @param view a {@link ListView}.
 */
public void addView(ListView<T> view){
  if (views.contains(view)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  views.add(view);
  view.setDelegate(delegate);
  delegate.onRangeChanged(view);
}","/** 
 * Adds a view to this adapter. The current range of interest of the view will be populated with data.
 * @param view a {@link ListView}.
 */
public void addView(ListView<T> view){
  if (views.contains(view)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  views.add(view);
  view.setDataProvider(dataProvider,false);
  if (lastDataSize >= 0) {
    view.setDataSize(lastDataSize,lastDataSizeExact);
  }
  dataProvider.onRangeChanged(view);
}",0.7600487210718636
54124,"/** 
 * This method will dispatch commands from the command queue. It will dispatch commands until one of the following conditions is <code>true</code>: <ul> <li>It consumed its dispatching time slice  {@value #DEFAULT_TIME_SLICE_MILLIS}</li> <li>It encounters a <code>null</code> in the command queue</li> <li>All commands which were present at the start of the dispatching have been removed from the command queue</li> <li>The command that it was processing was canceled due to a false cancellation -- in this case we exit without updating any state</li> </ul>
 * @param startTimeMillis the time when this method started
 */
protected void doExecuteCommands(double startTimeMillis){
  assert(!isExecutionTimerPending());
  boolean wasCanceled=false;
  try {
    setExecuting(true);
    iterator.setEnd(commands.size());
    cancellationTimer.schedule(DEFAULT_CANCELLATION_TIMEOUT_MILLIS);
    while (iterator.hasNext()) {
      Object element=iterator.next();
      boolean removeCommand=true;
      try {
        if (element == null) {
          return;
        }
        if (element instanceof Command) {
          Command command=(Command)element;
          command.execute();
        }
 else         if (element instanceof IncrementalCommand) {
          IncrementalCommand incrementalCommand=(IncrementalCommand)element;
          removeCommand=!incrementalCommand.execute();
        }
      }
  finally {
        wasCanceled=iterator.wasRemoved();
        if (wasCanceled) {
          return;
        }
        if (removeCommand) {
          iterator.remove();
        }
      }
      if (hasTimeSliceExpired(Duration.currentTimeMillis(),startTimeMillis)) {
        return;
      }
    }
  }
  finally {
    if (!wasCanceled) {
      cancellationTimer.cancel();
      setExecuting(false);
      maybeStartExecutionTimer();
    }
  }
}","/** 
 * This method will dispatch commands from the command queue. It will dispatch commands until one of the following conditions is <code>true</code>: <ul> <li>It consumed its dispatching time slice  {@value #DEFAULT_TIME_SLICE_MILLIS}</li> <li>It encounters a <code>null</code> in the command queue</li> <li>All commands which were present at the start of the dispatching have been removed from the command queue</li> <li>The command that it was processing was canceled due to a false cancellation -- in this case we exit without updating any state</li> </ul>
 * @param startTimeMillis the time when this method started
 */
protected void doExecuteCommands(double startTimeMillis){
  assert(!isExecutionTimerPending());
  boolean wasCanceled=false;
  try {
    setExecuting(true);
    iterator.setEnd(commands.size());
    cancellationTimer.schedule(DEFAULT_CANCELLATION_TIMEOUT_MILLIS);
    while (iterator.hasNext()) {
      Object element=iterator.next();
      boolean removeCommand=true;
      try {
        if (element == null) {
          return;
        }
        if (element instanceof Command) {
          Command command=(Command)element;
          command.execute();
        }
 else         if (element instanceof IncrementalCommand) {
          IncrementalCommand incrementalCommand=(IncrementalCommand)element;
          removeCommand=!incrementalCommand.execute();
        }
      }
  finally {
        wasCanceled=iterator.wasRemoved();
        if (!wasCanceled) {
          if (removeCommand) {
            iterator.remove();
          }
        }
      }
      if (hasTimeSliceExpired(Duration.currentTimeMillis(),startTimeMillis)) {
        return;
      }
    }
  }
  finally {
    if (!wasCanceled) {
      cancellationTimer.cancel();
      setExecuting(false);
      maybeStartExecutionTimer();
    }
  }
}",0.9681459297576912
54125,"/** 
 * Formats Fractional seconds field according to pattern specified.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatFractionalSeconds(StringBuffer buf,int count,Date date){
  long time=date.getTime();
  int value;
  if (time < 0) {
    value=1000 - (int)(-time % 1000);
  }
 else {
    value=(int)(time % 1000);
  }
  if (count == 1) {
    value=Math.min((value + 50) / 100,9);
    buf.append((char)('0' + value));
  }
 else   if (count == 2) {
    value=Math.min((value + 5) / 10,99);
    zeroPaddingNumber(buf,value,2);
  }
 else {
    zeroPaddingNumber(buf,value,3);
    if (count > 3) {
      zeroPaddingNumber(buf,0,count - 3);
    }
  }
}","/** 
 * Formats Fractional seconds field according to pattern specified.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatFractionalSeconds(StringBuffer buf,int count,Date date){
  long time=date.getTime();
  int value;
  if (time < 0) {
    value=1000 - (int)(-time % 1000);
    if (value == 1000) {
      value=0;
    }
  }
 else {
    value=(int)(time % 1000);
  }
  if (count == 1) {
    value=Math.min((value + 50) / 100,9);
    buf.append((char)('0' + value));
  }
 else   if (count == 2) {
    value=Math.min((value + 5) / 10,99);
    zeroPaddingNumber(buf,value,2);
  }
 else {
    zeroPaddingNumber(buf,value,3);
    if (count > 3) {
      zeroPaddingNumber(buf,0,count - 3);
    }
  }
}",0.9730679156908664
54126,"public void testPre1970Milliseconds(){
  Date date=new Date(-631151998945L);
  long midnight=Date.UTC(1950 - 1900,0,1,0,0,1);
  assertEquals(-631151998945L,midnight + 55);
  TimeZone utc=TimeZone.createTimeZone(0);
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
}","public void testPre1970Milliseconds(){
  Date date=new Date(-631151998945L);
  long midnight=Date.UTC(1950 - 1900,0,1,0,0,1);
  assertEquals(-631151998945L,midnight + 55);
  TimeZone utc=TimeZone.createTimeZone(0);
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
  date=new Date(midnight);
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,utc));
}",0.8912466843501327
54127,"/** 
 * Create an ActivityManager. Next call   {@link #setDisplay} and{@link #activate}.
 * @param mapper finds the {@link Activity} for a given {@link Place}
 * @param eventBus source of {@link PlaceChangeEvent} and{@link PlaceChangeRequestedEvent} events.
 */
public ActivityManager(ActivityMapper<P> mapper,HandlerManager eventBus){
  this.mapper=mapper;
  this.eventBus=eventBus;
}","/** 
 * Create an ActivityManager. Next call   {@link #setDisplay}.
 * @param mapper finds the {@link Activity} for a given {@link Place}
 * @param eventBus source of {@link PlaceChangeEvent} and{@link PlaceChangeRequestedEvent} events.
 */
public ActivityManager(ActivityMapper<P> mapper,HandlerManager eventBus){
  this.mapper=mapper;
  this.eventBus=eventBus;
}",0.97196261682243
54128,"public int compare(JMethod m1,JMethod m2){
  String name1=m1.getName();
  String name2=m2.getName();
  return name1.compareTo(name2);
}","public int compare(JClassType o1,JClassType o2){
  return o1.getQualifiedSourceName().compareTo(o2.getQualifiedSourceName());
}",0.465648854961832
54129,"/** 
 * Gets all types, both top-level and nested.
 * @return an array of types, possibly of zero length
 */
public JClassType[] getTypes(){
  Collection<JRealClassType> values=allTypes.values();
  return values.toArray(new JClassType[values.size()]);
}","/** 
 * Gets all types, both top-level and nested.
 * @return an array of types, possibly of zero length
 */
public JClassType[] getTypes(){
  Collection<JRealClassType> values=allTypes.values();
  JClassType[] result=values.toArray(new JClassType[values.size()]);
  Arrays.sort(result,new Comparator<JClassType>(){
    public int compare(    JClassType o1,    JClassType o2){
      return o1.getQualifiedSourceName().compareTo(o2.getQualifiedSourceName());
    }
  }
);
  return result;
}",0.6630727762803235
54130,"/** 
 * Validates the given module can be compiled.
 * @param logger a logger to use
 * @param jjsOptions a set of compiler options
 * @param module the module to compile
 * @param genDir optional directory to dump generated source, may be<code>null</code>
 */
public static boolean validate(TreeLogger logger,JJSOptions jjsOptions,ModuleDef module,File genDir,File dumpSignatureFile){
  try {
    CompilationState compilationState=module.getCompilationState(logger);
    if (dumpSignatureFile != null) {
      SignatureDumper.dumpSignatures(logger,compilationState.getTypeOracle(),dumpSignatureFile);
    }
    String[] declEntryPts=module.getEntryPointTypeNames();
    String[] additionalRootTypes=null;
    if (declEntryPts.length == 0) {
      Collection<CompilationUnit> compilationUnits=compilationState.getCompilationUnits();
      additionalRootTypes=new String[compilationUnits.size()];
      int i=0;
      for (      CompilationUnit unit : compilationUnits) {
        additionalRootTypes[i++]=unit.getTypeName();
      }
    }
    ArtifactSet generatorArtifacts=new ArtifactSet();
    DistillerRebindPermutationOracle rpo=new DistillerRebindPermutationOracle(module,compilationState,generatorArtifacts,new PropertyPermutations(module.getProperties(),module.getActiveLinkerNames()),genDir);
    compilationState=null;
    if (dumpSignatureFile != null) {
      SignatureDumper.dumpSignatures(logger,compilationState.getTypeOracle(),dumpSignatureFile);
    }
    jjsOptions.setOptimizePrecompile(false);
    getCompiler(module).precompile(logger,module,rpo,declEntryPts,additionalRootTypes,jjsOptions,true);
    return true;
  }
 catch (  UnableToCompleteException e) {
    return false;
  }
}","/** 
 * Validates the given module can be compiled.
 * @param logger a logger to use
 * @param jjsOptions a set of compiler options
 * @param module the module to compile
 * @param genDir optional directory to dump generated source, may be<code>null</code>
 */
public static boolean validate(TreeLogger logger,JJSOptions jjsOptions,ModuleDef module,File genDir,File dumpSignatureFile){
  try {
    CompilationState compilationState=module.getCompilationState(logger);
    if (dumpSignatureFile != null) {
      SignatureDumper.dumpSignatures(logger,compilationState.getTypeOracle(),dumpSignatureFile);
    }
    String[] declEntryPts=module.getEntryPointTypeNames();
    String[] additionalRootTypes=null;
    if (declEntryPts.length == 0) {
      Collection<CompilationUnit> compilationUnits=compilationState.getCompilationUnits();
      additionalRootTypes=new String[compilationUnits.size()];
      int i=0;
      for (      CompilationUnit unit : compilationUnits) {
        additionalRootTypes[i++]=unit.getTypeName();
      }
    }
    ArtifactSet generatorArtifacts=new ArtifactSet();
    DistillerRebindPermutationOracle rpo=new DistillerRebindPermutationOracle(module,compilationState,generatorArtifacts,new PropertyPermutations(module.getProperties(),module.getActiveLinkerNames()),genDir);
    compilationState=null;
    jjsOptions.setOptimizePrecompile(false);
    getCompiler(module).precompile(logger,module,rpo,declEntryPts,additionalRootTypes,jjsOptions,true);
    return true;
  }
 catch (  UnableToCompleteException e) {
    return false;
  }
}",0.883578431372549
54131,"/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  if (GWT.isScript()) {
    try {
      t.compareTo(d2);
      fail(""String_Node_Str"");
    }
 catch (    ClassCastException e) {
    }
  }
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(t.getNanos() + 1);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}","/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  assertEquals(1,t.compareTo(d2));
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(t.getNanos() + 1);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}",0.7418761496014715
54132,"public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    lhs=visitor.accept(lhs);
    rhs=visitor.accept(rhs);
  }
  visitor.endVisit(this,ctx);
}","public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    if (isAssignment()) {
      lhs=visitor.acceptLvalue(lhs);
    }
 else {
      lhs=visitor.accept(lhs);
    }
    rhs=visitor.accept(rhs);
  }
  visitor.endVisit(this,ctx);
}",0.780045351473923
54133,"public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    variableRef=(JVariableRef)visitor.accept(variableRef);
    if (initializer != null) {
      initializer=visitor.accept(initializer);
    }
  }
  visitor.endVisit(this,ctx);
}","public void traverse(JVisitor visitor,Context ctx){
  if (visitor.visit(this,ctx)) {
    variableRef=(JVariableRef)visitor.acceptLvalue(variableRef);
    if (initializer != null) {
      initializer=visitor.accept(initializer);
    }
  }
  visitor.endVisit(this,ctx);
}",0.9887218045112782
54134,"public void traverse(JVisitor visitor,Context ctx){
  arg=visitor.accept(arg);
}","public void traverse(JVisitor visitor,Context ctx){
  if (getOp().isModifying()) {
    arg=visitor.acceptLvalue(arg);
  }
 else {
    arg=visitor.accept(arg);
  }
}",0.6557377049180327
54135,"@Override public final boolean visit(JStatement x,Context ctx){
  if (ctx.canInsert()) {
    insertionStack.push(ctx);
  }
  return super.visit(x,ctx);
}","@Override public final boolean visit(JStatement x,Context ctx){
  if (ctx.canInsert() && !banList.contains(x)) {
    insertionStack.push(ctx);
  }
  if (x instanceof JForStatement) {
    JForStatement forStmt=(JForStatement)x;
    banList.addAll(forStmt.getIncrements());
  }
  return super.visit(x,ctx);
}",0.6666666666666666
54136,"@Override public void endVisit(JExpression x,Context ctx){
  SourceInfo info=x.getSourceInfo();
  JType type=x.getType();
  JLocal local=createTempLocal(info,type);
  local.getDeclarationStatement().initializer=x;
  ctx.replaceMe(new JLocalRef(info,local));
}","@Override public void endVisit(JExpression x,Context ctx){
  if (x != dontBother && !ctx.isLvalue()) {
    SourceInfo info=x.getSourceInfo();
    JType type=x.getType();
    JLocal local=createTempLocal(info,type);
    local.getDeclarationStatement().initializer=x;
    ctx.replaceMe(new JLocalRef(info,local));
  }
}",0.8993055555555556
54137,"@Override public boolean visit(JPrefixOperation x,Context ctx){
  if (x.getOp().isModifying()) {
    return false;
  }
  return true;
}","@Override public boolean visit(JExpressionStatement x,Context ctx){
  dontBother=x.getExpr();
  return super.visit(x,ctx);
}",0.61003861003861
54138,"public void testForStatement() throws Exception {
  StringBuilder original=new StringBuilder();
  original.append(""String_Node_Str"");
  StringBuilder expected=new StringBuilder();
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  assertTransform(original.toString()).into(expected.toString());
}","public void testForStatement() throws Exception {
  StringBuilder original=new StringBuilder();
  original.append(""String_Node_Str"");
  StringBuilder expected=new StringBuilder();
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  expected.append(""String_Node_Str"");
  assertTransform(original.toString()).into(expected.toString());
}",0.9444444444444444
54139,"/** 
 * Method parses GMT type timezone.
 * @param text the time text to be parsed
 * @param start from where parse start
 * @param pos Parse position
 * @param cal DateRecord object that holds parsed value
 * @return <code>true</code> if parsing successful, otherwise<code>false</code>
 */
private boolean subParseTimeZoneInGMT(String text,int start,int[] pos,DateRecord cal){
  if (text.startsWith(GMT,start)) {
    pos[0]=start + GMT.length();
    return parseTimeZoneOffset(text,pos,cal);
  }
  return parseTimeZoneOffset(text,pos,cal);
}","/** 
 * Method parses GMT type timezone.
 * @param text the time text to be parsed
 * @param start from where parse start
 * @param pos Parse position
 * @param cal DateRecord object that holds parsed value
 * @return <code>true</code> if parsing successful, otherwise<code>false</code>
 */
private boolean subParseTimeZoneInGMT(String text,int start,int[] pos,DateRecord cal){
  if (text.startsWith(GMT,start)) {
    pos[0]=start + GMT.length();
    return parseTimeZoneOffset(text,pos,cal);
  }
  if (text.startsWith(UTC,start)) {
    pos[0]=start + UTC.length();
    return parseTimeZoneOffset(text,pos,cal);
  }
  return parseTimeZoneOffset(text,pos,cal);
}",0.9010806317539484
54140,"public void test_timezonez(){
  TimeZoneConstants timeZoneData=GWT.create(TimeZoneConstants.class);
  String str=timeZoneData.americaLosAngeles();
  TimeZone usPacific=TimeZone.createTimeZone(str);
  Date date=new Date();
  date.setTime(Date.UTC(2006 - 1900,6,27,13,10,10));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  date.setTime(Date.UTC(2006 - 1900,1,27,13,10,10));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
}","public void test_timezonez(){
  TimeZoneConstants timeZoneData=GWT.create(TimeZoneConstants.class);
  String str=timeZoneData.americaLosAngeles();
  TimeZone usPacific=TimeZone.createTimeZone(str);
  Date date=new Date();
  date.setTime(Date.UTC(2006 - 1900,6,27,13,10,10));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  date.setTime(Date.UTC(2006 - 1900,1,27,13,10,10));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  assertEquals(""String_Node_Str"",DateTimeFormat.getFormat(""String_Node_Str"").format(date,usPacific));
  DateTimeFormat format=DateTimeFormat.getFormat(""String_Node_Str"");
  assertEquals(date,format.parse(format.format(date)));
}",0.94824016563147
54141,"/** 
 * Return the parsed value, or null if the field is empty.
 * @throws ParseFailedException if the value cannot be parsed
 */
public T getValueOrThrow() throws ParseException {
  String text=getText().trim();
  if (""String_Node_Str"".equals(text)) {
    return null;
  }
  return parser.parse(text);
}","/** 
 * Return the parsed value, or null if the field is empty.
 * @throws ParseException if the value cannot be parsed
 */
public T getValueOrThrow() throws ParseException {
  String text=getText().trim();
  if (""String_Node_Str"".equals(text)) {
    return null;
  }
  return parser.parse(text);
}",0.9900332225913622
54142,"public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
}","public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertEquals(1.0d,Double.parseDouble(""String_Node_Str""),0.0);
  assertEquals(1.0d,Double.parseDouble(""String_Node_Str""),0.0);
  assertEquals(1.0d,Double.parseDouble(""String_Node_Str""),0.0);
  assertEquals(1.0d,Double.parseDouble(""String_Node_Str""),0.0);
}",0.9253644314868804
54143,"public void testParse(){
  assertEquals(0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(-1.5f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(3.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(0.5f,Float.parseFloat(""String_Node_Str""),0.0);
}","public void testParse(){
  assertEquals(0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(-1.5f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(3.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(0.5f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(1.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(1.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(1.0f,Float.parseFloat(""String_Node_Str""),0.0);
  assertEquals(1.0f,Float.parseFloat(""String_Node_Str""),0.0);
}",0.6876574307304786
54144,"@Override public void finalizeLayout(Element parent){
  if (!isIE6()) {
    super.finalizeLayout(parent);
    return;
  }
  resizeRelativeToParent(parent);
  resizeHandler(parent,true);
}","@Override public void finalizeLayout(Element parent){
  resizeRelativeToParent(parent);
  resizeHandler(parent,true);
}",0.7777777777777778
54145,"@Override public void fillParent(Element elem){
  if (!isIE6()) {
    super.fillParent(elem);
    return;
  }
  fillParentImpl(elem);
}","@Override public void fillParent(Element elem){
  fillParentImpl(elem);
}",0.7019230769230769
54146,"@Override public void onDetach(Element parent){
  if (isIE6()) {
    removeLayerRefs(parent);
    removeResizeHandler(parent);
    removeUnitChangeHandler(relativeRuler);
  }
}","@Override public void onDetach(Element parent){
  removeLayerRefs(parent);
  removeResizeHandler(parent);
  removeUnitChangeHandler(relativeRuler);
}",0.916923076923077
54147,"@Override public void layout(Layer layer){
  if (!isIE6()) {
    super.layout(layer);
    return;
  }
  Element elem=layer.getContainerElement();
  setLayer(elem,layer);
}","@Override public void layout(Layer layer){
  Element elem=layer.getContainerElement();
  setLayer(elem,layer);
}",0.7915194346289752
54148,"@Override public void onAttach(Element parent){
  if (isIE6()) {
    initResizeHandler(parent);
    initUnitChangeHandler(parent,relativeRuler);
  }
}","@Override public void onAttach(Element parent){
  initResizeHandler(parent);
  initUnitChangeHandler(parent,relativeRuler);
}",0.9090909090909092
54149,"@Override public void initParent(Element parent){
  super.initParent(parent);
  if (isIE6()) {
    setPropertyElement(parent,""String_Node_Str"",createStyleRuler(parent));
  }
}","@Override public void initParent(Element parent){
  super.initParent(parent);
  setPropertyElement(parent,""String_Node_Str"",createStyleRuler(parent));
}",0.9296636085626911
54150,"public void layout(Layer layer){
  Style style=layer.container.getStyle();
  if (layer.setLeft) {
    setValue(layer,""String_Node_Str"",layer.left,layer.leftUnit,false,false);
  }
 else {
    style.clearLeft();
  }
  if (layer.setRight) {
    setValue(layer,""String_Node_Str"",layer.right,layer.rightUnit,false,false);
  }
 else {
    style.clearRight();
  }
  if (layer.setTop) {
    setValue(layer,""String_Node_Str"",layer.top,layer.topUnit,true,false);
  }
 else {
    style.clearTop();
  }
  if (layer.setBottom) {
    setValue(layer,""String_Node_Str"",layer.bottom,layer.bottomUnit,true,false);
  }
 else {
    style.clearBottom();
  }
  if (layer.setWidth) {
    setValue(layer,""String_Node_Str"",layer.width,layer.widthUnit,false,true);
  }
 else {
    style.clearWidth();
  }
  if (layer.setHeight) {
    setValue(layer,""String_Node_Str"",layer.height,layer.heightUnit,true,true);
  }
 else {
    style.clearHeight();
  }
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}","@Override public void layout(Layer layer){
  Style style=layer.container.getStyle();
  if (layer.setLeft) {
    setValue(layer,""String_Node_Str"",layer.left,layer.leftUnit,false,false);
  }
 else {
    style.clearLeft();
  }
  if (layer.setRight) {
    setValue(layer,""String_Node_Str"",layer.right,layer.rightUnit,false,false);
  }
 else {
    style.clearRight();
  }
  if (layer.setTop) {
    setValue(layer,""String_Node_Str"",layer.top,layer.topUnit,true,false);
  }
 else {
    style.clearTop();
  }
  if (layer.setBottom) {
    setValue(layer,""String_Node_Str"",layer.bottom,layer.bottomUnit,true,false);
  }
 else {
    style.clearBottom();
  }
  if (layer.setWidth) {
    setValue(layer,""String_Node_Str"",layer.width,layer.widthUnit,false,true);
  }
 else {
    style.clearWidth();
  }
  if (layer.setHeight) {
    setValue(layer,""String_Node_Str"",layer.height,layer.heightUnit,true,true);
  }
 else {
    style.clearHeight();
  }
  style=layer.child.getStyle();
switch (layer.hPos) {
case BEGIN:
    style.setLeft(0,Unit.PX);
  style.clearRight();
break;
case END:
style.clearLeft();
style.setRight(0,Unit.PX);
break;
case STRETCH:
style.setLeft(0,Unit.PX);
style.setRight(0,Unit.PX);
break;
}
switch (layer.vPos) {
case BEGIN:
style.setTop(0,Unit.PX);
style.clearBottom();
break;
case END:
style.clearTop();
style.setBottom(0,Unit.PX);
break;
case STRETCH:
style.setTop(0,Unit.PX);
style.setBottom(0,Unit.PX);
break;
}
}",0.9964788732394366
54151,"/** 
 * Evaluates a JSON expression. This method does not validate the JSON text and should only be used on JSON from trusted sources.
 * @param < T > The type of JavaScriptObject that should be returned
 * @param json The source JSON text
 * @return The evaluated object
 */
public static native <T extends JavaScriptObject>T unsafeEval(String json);","/** 
 * Evaluates a JSON expression using   {@code eval()}. This method does not validate the JSON text and should only be used on JSON from trusted sources. The payload must evaluate to an Object or an Array (not a primitive or a String).
 * @param < T > The type of JavaScriptObject that should be returned
 * @param json The source JSON text
 * @return The evaluated object
 */
public static native <T extends JavaScriptObject>T unsafeEval(String json);",0.8698884758364313
54152,"/** 
 * Evaluates a trusted JSON string and returns its JSONValue representation. CAUTION! For efficiency, this method is implemented using the JavaScript <code>eval()</code> function, which can execute arbitrary script. DO NOT pass an untrusted string into this method.
 * @param jsonString a JSON object to parse
 * @return a JSONValue that has been built by parsing the JSON string
 * @throws NullPointerException if <code>jsonString</code> is<code>null</code>
 * @throws IllegalArgumentException if <code>jsonString</code> is empty
 */
public static JSONValue parse(String jsonString){
  if (jsonString == null) {
    throw new NullPointerException();
  }
  if (jsonString.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return evaluate(jsonString);
  }
 catch (  JavaScriptException ex) {
    throw new JSONException(ex);
  }
}","private static JSONValue parse(String jsonString,boolean strict){
  if (jsonString == null) {
    throw new NullPointerException();
  }
  if (jsonString.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return evaluate(jsonString,strict);
  }
 catch (  JavaScriptException ex) {
    throw new JSONException(ex);
  }
}",0.4923076923076923
54153,"/** 
 * This method converts <code>jsonString</code> into a JSONValue.
 */
private static native JSONValue evaluate(String jsonString);","/** 
 * This method converts <code>jsonString</code> into a JSONValue. In strict mode (strict == true), one of two code paths is taken: 1) Call JSON.parse if available, or 2) Validate the input and call eval() In lenient mode (strict == false), eval() is called without validation.
 * @param strict if true, parse in strict mode. 
 */
private static native JSONValue evaluate(String json,boolean strict);",0.4786641929499072
54154,"private void checkIndexForAdd(int index){
  checkIndex(index,size - 1);
}","private void checkIndexForAdd(int index){
  checkIndex(index,size + 1);
}",0.9863013698630136
54155,"private void checkListSizeAndContent(List<Integer> in,int[] expected){
  assertEquals(expected.length,in.size());
  for (int i=0; i < expected.length; i++) {
    assertEquals(expected[i],(int)in.get(i));
  }
}","private void checkListSizeAndContent(List<Integer> in,int... expected){
  assertEquals(expected.length,in.size());
  for (int i=0; i < expected.length; i++) {
    assertEquals(expected[i],(int)in.get(i));
  }
}",0.9880668257756564
54156,"public void testSubList(){
  List<Integer> wrappedList=createListWithContent(new int[]{1,2,3,4,5});
  List<Integer> testList=wrappedList.subList(1,4);
  assertEquals(3,testList.size());
  assertEquals(testList,Arrays.asList(2,3,4));
  checkListSizeAndContent(testList,new int[]{2,3,4});
  testList.add(1,6);
  assertEquals(testList,Arrays.asList(2,6,3,4));
  checkListSizeAndContent(testList,new int[]{2,6,3,4});
  assertEquals(wrappedList,Arrays.asList(1,2,6,3,4,5));
  checkListSizeAndContent(wrappedList,new int[]{1,2,6,3,4,5});
  testList.remove(2);
  assertEquals(testList,Arrays.asList(2,6,4));
  checkListSizeAndContent(testList,new int[]{2,6,4});
  try {
    testList.remove(3);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  checkListSizeAndContent(wrappedList,new int[]{1,2,6,4,5});
  testList.set(0,7);
  checkListSizeAndContent(testList,new int[]{7,6,4});
  checkListSizeAndContent(wrappedList,new int[]{1,7,6,4,5});
  try {
    wrappedList.subList(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,15);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(5,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    wrappedList.subList(0,1).add(2,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).add(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).get(1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).get(-1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).set(2,2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).set(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
}","public void testSubList(){
  List<Integer> wrappedList=createListWithContent(new int[]{1,2,3,4,5});
  List<Integer> testList=wrappedList.subList(1,4);
  assertEquals(3,testList.size());
  assertEquals(testList,Arrays.asList(2,3,4));
  checkListSizeAndContent(testList,2,3,4);
  testList.add(1,6);
  assertEquals(testList,Arrays.asList(2,6,3,4));
  checkListSizeAndContent(testList,2,6,3,4);
  assertEquals(wrappedList,Arrays.asList(1,2,6,3,4,5));
  checkListSizeAndContent(wrappedList,1,2,6,3,4,5);
  testList.remove(2);
  assertEquals(testList,Arrays.asList(2,6,4));
  checkListSizeAndContent(testList,2,6,4);
  try {
    testList.remove(3);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  checkListSizeAndContent(wrappedList,1,2,6,4,5);
  testList.set(0,7);
  checkListSizeAndContent(testList,7,6,4);
  checkListSizeAndContent(wrappedList,1,7,6,4,5);
  try {
    wrappedList.subList(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,15);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(5,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    wrappedList.subList(0,1).add(2,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).add(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).get(1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).get(-1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).set(2,2);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  try {
    wrappedList.subList(0,1).set(-1,5);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
}",0.9245982694684796
54157,"public void testSin(){
  double v=Math.sin(0.0);
  assertEquals(0.0,v,1e-7);
  v=Math.sin(Math.PI * .5);
  assertEquals(1.0,v,1e-7);
  v=Math.sin(Math.PI);
  assertEquals(0.0,v,1e-7);
  v=Math.sin(Math.PI * 1.5);
  assertEquals(-1.0,v,1e-7);
}","public void testSin(){
  double v=Math.sin(0.0);
  assertEquals(0.0,v,1e-7);
  v=Math.sin(-0.0);
  assertEquals(-0.0,v,1e-7);
  v=Math.sin(Math.PI * .5);
  assertEquals(1.0,v,1e-7);
  v=Math.sin(Math.PI);
  assertEquals(0.0,v,1e-7);
  v=Math.sin(Math.PI * 1.5);
  assertEquals(-1.0,v,1e-7);
  v=Math.sin(Double.NaN);
  assertTrue(Double.isNaN(v));
  v=Math.sin(Double.NEGATIVE_INFINITY);
  assertTrue(Double.isNaN(v));
  v=Math.sin(Double.POSITIVE_INFINITY);
  assertTrue(Double.isNaN(v));
}",0.662125340599455
54158,"public void testCos(){
  double v=Math.cos(0.0);
  assertEquals(1.0,v,1e-7);
  v=Math.cos(Math.PI * .5);
  assertEquals(0.0,v,1e-7);
  v=Math.cos(Math.PI);
  assertEquals(-1.0,v,1e-7);
  v=Math.cos(Math.PI * 1.5);
  assertEquals(0.0,v,1e-7);
}","public void testCos(){
  double v=Math.cos(0.0);
  assertEquals(1.0,v,1e-7);
  v=Math.cos(-0.0);
  assertEquals(1.0,v,1e-7);
  v=Math.cos(Math.PI * .5);
  assertEquals(0.0,v,1e-7);
  v=Math.cos(Math.PI);
  assertEquals(-1.0,v,1e-7);
  v=Math.cos(Math.PI * 1.5);
  assertEquals(0.0,v,1e-7);
  v=Math.cos(Double.NaN);
  assertTrue(Double.isNaN(v));
  v=Math.cos(Double.NEGATIVE_INFINITY);
  assertTrue(Double.isNaN(v));
  v=Math.cos(Double.POSITIVE_INFINITY);
  assertTrue(Double.isNaN(v));
}",0.6630286493860846
54159,"public static int compare(double x,double y){
  if (x < y) {
    return -1;
  }
 else   if (x > y) {
    return 1;
  }
 else {
    return 0;
  }
}","public static int compare(double x,double y){
  if (isNaN(x)) {
    if (isNaN(y)) {
      return 0;
    }
 else {
      return 1;
    }
  }
 else   if (isNaN(y)) {
    return -1;
  }
  if (x < y) {
    return -1;
  }
 else   if (x > y) {
    return 1;
  }
 else {
    return 0;
  }
}",0.6806526806526807
54160,"public int compareTo(Double b){
  if (value < b.value) {
    return -1;
  }
 else   if (value > b.value) {
    return 1;
  }
 else {
    return 0;
  }
}","public int compareTo(Double b){
  return compare(this.value,b.value);
}",0.4573991031390134
54161,"private static TypedProgramReference typedProgramReference(JsName name,JavaToJavaScriptMap jjsmap,Map<JsName,String> obfuscateMap){
  JMethod method=jjsmap.nameToMethod(name);
  if (method != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(method.getEnclosingType().getName());
    sb.append(""String_Node_Str"");
    sb.append(method.getName());
    sb.append(""String_Node_Str"");
    for (    JType type : method.getOriginalParamTypes()) {
      sb.append(type.getJsniSignatureName());
    }
    sb.append(""String_Node_Str"");
    sb.append(method.getOriginalReturnType().getJsniSignatureName());
    String desc=sb.toString();
    return new TypedProgramReference(""String_Node_Str"",desc);
  }
  JClassType type=jjsmap.nameToType(name);
  if (type != null) {
    return new TypedProgramReference(""String_Node_Str"",type.getName());
  }
  String string=obfuscateMap.get(name);
  if (string != null) {
    return new TypedProgramReference(""String_Node_Str"",string);
  }
  return new TypedProgramReference(""String_Node_Str"",name.getShortIdent());
}","private static TypedProgramReference typedProgramReference(JsName name,JavaToJavaScriptMap jjsmap,Map<JsName,String> obfuscateMap){
  JMethod method=jjsmap.nameToMethod(name);
  if (method != null) {
    StringBuilder sb=new StringBuilder();
    sb.append(method.getEnclosingType().getName());
    sb.append(""String_Node_Str"");
    sb.append(method.getName());
    sb.append(""String_Node_Str"");
    for (    JType type : method.getOriginalParamTypes()) {
      sb.append(type.getJsniSignatureName());
    }
    sb.append(""String_Node_Str"");
    sb.append(method.getOriginalReturnType().getJsniSignatureName());
    String desc=sb.toString();
    return new TypedProgramReference(""String_Node_Str"",desc);
  }
  JField field=jjsmap.nameToField(name);
  if ((field != null) && (field.getEnclosingType() != null)) {
    StringBuilder sb=new StringBuilder();
    sb.append(field.getEnclosingType().getName());
    sb.append(""String_Node_Str"");
    sb.append(field.getName());
    return new TypedProgramReference(""String_Node_Str"",sb.toString());
  }
  JClassType type=jjsmap.nameToType(name);
  if (type != null) {
    return new TypedProgramReference(""String_Node_Str"",type.getName());
  }
  String string=obfuscateMap.get(name);
  if (string != null) {
    return new TypedProgramReference(""String_Node_Str"",string);
  }
  return new TypedProgramReference(""String_Node_Str"",name.getShortIdent());
}",0.7171964140179299
54162,"private void assertIsChild(Widget widget){
}","void assertIsChild(Widget widget){
}",0.9
54163,"/** 
 * Sets the minimum allowable size for the given widget. <p> Its assocated splitter cannot be dragged to a position that would make it smaller than this size. This method has no effect for the  {@link DockLayoutPanel.Direction#CENTER} widget.</p>
 * @param child the child whose minimum size will be set
 * @param minSize the minimum size for this widget
 */
public void setWidgetMinSize(Widget child,int minSize){
  Splitter splitter=getAssociatedSplitter(child);
  splitter.setMinSize(minSize);
}","/** 
 * Sets the minimum allowable size for the given widget. <p> Its associated splitter cannot be dragged to a position that would make it smaller than this size. This method has no effect for the  {@link DockLayoutPanel.Direction#CENTER} widget.</p>
 * @param child the child whose minimum size will be set
 * @param minSize the minimum size for this widget
 */
public void setWidgetMinSize(Widget child,int minSize){
  assertIsChild(child);
  Splitter splitter=getAssociatedSplitter(child);
  if (splitter != null) {
    splitter.setMinSize(minSize);
  }
}",0.8240827845719662
54164,"private static Set<ExpensesKey<?>> get(){
  if (instance == null) {
    instance=new HashSet<ExpensesKey<?>>();
    instance.add(ReportKey.get());
    instance.add(EmployeeKey.get());
  }
  return instance;
}","private static Set<ExpensesKey<?>> get(){
  if (instance == null) {
    HashSet<ExpensesKey<?>> newInstance=new HashSet<ExpensesKey<?>>();
    newInstance.add(ReportKey.get());
    newInstance.add(EmployeeKey.get());
    instance=newInstance;
  }
  return instance;
}",0.7789473684210526
54165,"public Response execute(Request request) throws Exception {
  if (request.getServiceType() != Request.ServiceType.DEV_MODE) {
    throw new IllegalArgumentException(""String_Node_Str"" + request.getServiceType().name());
  }
switch (request.getDevModeRequest().getRequestType()) {
case CAPABILITY_EXCHANGE:
    return processCapabilityExchange();
case RESTART_WEB_SERVER:
  return processRestartServer();
default :
{
  break;
}
}
throw new IllegalArgumentException(""String_Node_Str"" + request.getDevModeRequest().getRequestType().name());
}","public Response execute(Request request) throws Exception {
  if (request.getServiceType() != Request.ServiceType.DEV_MODE) {
    throw new IllegalArgumentException(""String_Node_Str"" + request.getServiceType().name());
  }
  RequestType requestType=request.getDevModeRequest().getRequestType();
  if (requestType != null) {
switch (requestType) {
case CAPABILITY_EXCHANGE:
      return processCapabilityExchange();
case RESTART_WEB_SERVER:
    return processRestartServer();
default :
{
    break;
  }
}
}
throw new IllegalArgumentException(""String_Node_Str"" + requestType == null ? ""String_Node_Str"" : requestType.name());
}",0.8529664660361135
54166,"private void processMessage(final Message message) throws InterruptedException {
switch (message.getMessageType()) {
case RESPONSE:
{
      processServerResponse(message.getMessageId(),message.getResponse());
      break;
    }
case REQUEST:
{
    processClientRequest(message.getMessageId(),message.getRequest());
    break;
  }
case FAILURE:
{
  processFailure(message.getMessageId(),message.getFailure());
  break;
}
default :
{
processUnknownMessageType(message.getMessageId(),message.getMessageType().name());
break;
}
}
}","private void processMessage(final Message message) throws InterruptedException {
  MessageType messageType=message.getMessageType();
  if (messageType == null) {
    processUnknownMessageType(message.getMessageId(),""String_Node_Str"");
    return;
  }
switch (messageType) {
case RESPONSE:
{
      processServerResponse(message.getMessageId(),message.getResponse());
      break;
    }
case REQUEST:
{
    processClientRequest(message.getMessageId(),message.getRequest());
    break;
  }
case FAILURE:
{
  processFailure(message.getMessageId(),message.getFailure());
  break;
}
default :
{
processUnknownMessageType(message.getMessageId(),messageType.name());
break;
}
}
}",0.8213689482470785
54167,"private String getContent(HttpServletRequest request) throws IOException {
  int contentLength=request.getContentLength();
  byte contentBytes[]=new byte[contentLength];
  BufferedInputStream bis=new BufferedInputStream(request.getInputStream());
  int readBytes=0;
  while (bis.read(contentBytes,readBytes,contentLength - readBytes) > 0) {
  }
  return new String(contentBytes);
}","private String getContent(HttpServletRequest request) throws IOException {
  int contentLength=request.getContentLength();
  byte contentBytes[]=new byte[contentLength];
  BufferedInputStream bis=new BufferedInputStream(request.getInputStream());
  try {
    int readBytes=0;
    while (bis.read(contentBytes,readBytes,contentLength - readBytes) > 0) {
    }
    return new String(contentBytes);
  }
  finally {
    bis.close();
  }
}",0.9349693251533744
54168,"/** 
 * Shows the popup and attach it to the page. It must have a child widget before this method is called.
 */
public void show(){
  if (showing) {
    return;
  }
  resizeAnimation.setState(true,false);
}","/** 
 * Shows the popup and attach it to the page. It must have a child widget before this method is called.
 */
public void show(){
  if (showing) {
    return;
  }
 else   if (isAttached()) {
    this.removeFromParent();
  }
  resizeAnimation.setState(true,false);
}",0.871578947368421
54169,"/** 
 * Test the showing a popup while it is hiding will not result in an illegal state.
 */
public void testShowWhileHiding(){
  PopupPanel popup=createPopupPanel();
  popup.setAnimationEnabled(false);
  popup.show();
  assertTrue(popup.isShowing());
  popup.setAnimationEnabled(true);
  popup.hide();
  assertFalse(popup.isShowing());
  popup.show();
  assertTrue(popup.isShowing());
}","/** 
 * Test that showing a popup while it is hiding will not result in an illegal state.
 */
public void testShowWhileHiding(){
  PopupPanel popup=createPopupPanel();
  popup.setAnimationEnabled(false);
  popup.show();
  assertTrue(popup.isShowing());
  popup.setAnimationEnabled(true);
  popup.hide();
  assertFalse(popup.isShowing());
  popup.show();
  assertTrue(popup.isShowing());
}",0.9961290322580644
54170,"/** 
 * Resizes the grid to the specified number of columns.
 * @param columns the number of columns
 * @throws IndexOutOfBoundsException
 */
public void resizeColumns(int columns){
  if (numColumns == columns) {
    return;
  }
  if (columns < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + columns);
  }
  if (numColumns > columns) {
    for (int i=0; i < numRows; i++) {
      for (int j=numColumns - 1; j >= columns; j--) {
        removeCell(i,j);
      }
    }
  }
 else {
    for (int i=0; i < numRows; i++) {
      for (int j=numColumns; j < columns; j++) {
        insertCell(i,j);
      }
    }
  }
  numColumns=columns;
  getColumnFormatter().resizeColumnGroup(columns);
}","/** 
 * Resizes the grid to the specified number of columns.
 * @param columns the number of columns
 * @throws IndexOutOfBoundsException
 */
public void resizeColumns(int columns){
  if (numColumns == columns) {
    return;
  }
  if (columns < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + columns);
  }
  if (numColumns > columns) {
    for (int i=0; i < numRows; i++) {
      for (int j=numColumns - 1; j >= columns; j--) {
        removeCell(i,j);
      }
    }
  }
 else {
    for (int i=0; i < numRows; i++) {
      for (int j=numColumns; j < columns; j++) {
        insertCell(i,j);
      }
    }
  }
  numColumns=columns;
  getColumnFormatter().resizeColumnGroup(columns,false);
}",0.9900568181818182
54171,"/** 
 * Resize the column group element.
 * @param columns the number of columns
 */
void resizeColumnGroup(int columns){
  columns=Math.max(columns,1);
  int num=columnGroup.getChildCount();
  if (num < columns) {
    for (int i=num; i < columns; i++) {
      columnGroup.appendChild(Document.get().createColElement());
    }
  }
 else   if (num > columns) {
    for (int i=num; i > columns; i--) {
      columnGroup.removeChild(columnGroup.getLastChild());
    }
  }
}","/** 
 * Resize the column group element.
 * @param columns the number of columns
 * @param growOnly true to only grow, false to shrink if needed
 */
void resizeColumnGroup(int columns,boolean growOnly){
  columns=Math.max(columns,1);
  int num=columnGroup.getChildCount();
  if (num < columns) {
    for (int i=num; i < columns; i++) {
      columnGroup.appendChild(Document.get().createColElement());
    }
  }
 else   if (!growOnly && num > columns) {
    for (int i=num; i > columns; i--) {
      columnGroup.removeChild(columnGroup.getLastChild());
    }
  }
}",0.9090909090909092
54172,"private Element ensureColumn(int col){
  prepareColumn(col);
  prepareColumnGroup();
  resizeColumnGroup(col + 1);
  return columnGroup.getChild(col).cast();
}","private Element ensureColumn(int col){
  prepareColumn(col);
  prepareColumnGroup();
  resizeColumnGroup(col + 1,true);
  return columnGroup.getChild(col).cast();
}",0.9845201238390092
54173,"public void testColumnFormatterStyleName(){
  Grid r=new Grid(4,5);
  Grid.ColumnFormatter columns=r.getColumnFormatter();
  columns.setStyleName(0,""String_Node_Str"");
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.removeStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.removeStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  Element e=DOM.getChild(r.getElement(),0);
  assertEquals(1,DOM.getChildCount(e));
  columns.addStyleName(3,""String_Node_Str"");
  e=DOM.getChild(r.getElement(),0);
  assertEquals(4,DOM.getChildCount(e));
}","public void testColumnFormatterStyleName(){
  Grid r=new Grid(4,5);
  Grid.ColumnFormatter columns=r.getColumnFormatter();
  columns.setStyleName(0,""String_Node_Str"");
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.addStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.removeStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  columns.removeStyleName(0,""String_Node_Str"");
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  Element e=DOM.getChild(r.getElement(),0);
  assertEquals(5,DOM.getChildCount(e));
  columns.addStyleName(3,""String_Node_Str"");
  e=DOM.getChild(r.getElement(),0);
  assertEquals(5,DOM.getChildCount(e));
  assertEquals(""String_Node_Str"",columns.getStyleName(0));
  assertEquals(""String_Node_Str"",columns.getStyleName(3));
}",0.9363920750782064
54174,"/** 
 * Inform the views of the new data.
 * @param start the start index
 * @param length the length of the data
 * @param values the data values
 */
protected void updateViewData(int start,int length,List<T> values){
  int end=start + length;
  for (  DefaultListRegistration reg : registrations) {
    int curStart=reg.getStart();
    int curLength=reg.getLength();
    int curEnd=curStart + curLength;
    if (curStart < end && curEnd > start) {
      int realStart=curStart < start ? start : curStart;
      int realEnd=curEnd > end ? end : curEnd;
      int realLength=realEnd - realStart;
      List<T> realValues=values.subList(0,realLength);
      ListEvent<T> event=new ListEvent<T>(realStart,realLength,realValues);
      reg.getHandler().onDataChanged(event);
    }
  }
}","/** 
 * Inform the views of the new data.
 * @param start the start index
 * @param length the length of the data
 * @param values the data values
 */
protected void updateViewData(int start,int length,List<T> values){
  int end=start + length;
  for (  DefaultListRegistration reg : registrations) {
    int curStart=reg.getStart();
    int curLength=reg.getLength();
    int curEnd=curStart + curLength;
    if (curStart < end && curEnd > start) {
      int realStart=curStart < start ? start : curStart;
      int realEnd=curEnd > end ? end : curEnd;
      int realLength=realEnd - realStart;
      List<T> realValues=values.subList(realStart - start,realStart - start + realLength);
      ListEvent<T> event=new ListEvent<T>(realStart,realLength,realValues);
      reg.getHandler().onDataChanged(event);
    }
  }
}",0.976279650436954
54175,"public void execute(){
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateDataSize(curSize,true);
  }
  if (modified) {
    int length=maxModified - minModified;
    updateViewData(minModified,length,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
  flushPending=false;
}","public void execute(){
  flushPending=false;
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateDataSize(curSize,true);
  }
  if (modified) {
    int length=maxModified - minModified;
    updateViewData(minModified,length,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
}",0.9432989690721648
54176,"@Override protected void moveSelectionUp(){
  if (isSuggestionListShowing()) {
    suggestionMenu.selectItem(suggestionMenu.getSelectedItemIndex() - 1);
  }
}","@Override protected void moveSelectionUp(){
  if (isSuggestionListShowing()) {
    if (suggestionMenu.getSelectedItemIndex() == -1) {
      suggestionMenu.selectItem(suggestionMenu.getNumItems() - 1);
    }
 else {
      suggestionMenu.selectItem(suggestionMenu.getSelectedItemIndex() - 1);
    }
  }
}",0.5739130434782609
54177,"@Override public synchronized void launchModule(String moduleName){
  String domain=""String_Node_Str"" + getLocalHostName() + ""String_Node_Str""+ shell.getPort()+ ""String_Node_Str"";
  for (  SeleniumWrapper remote : remotes) {
    try {
      String url=shell.getModuleUrl(moduleName);
      shell.getTopLogger().log(TreeLogger.TRACE,""String_Node_Str"" + domain + ""String_Node_Str""+ url);
      remote.createSelenium(domain);
      remote.getSelenium().start();
      remote.getSelenium().open(url);
    }
 catch (    Exception e) {
      shell.getTopLogger().log(TreeLogger.ERROR,""String_Node_Str"" + remote.getSpecifier(),e);
    }
  }
}","@Override public void launchModule(String moduleName){
  String domain=""String_Node_Str"" + getLocalHostName() + ""String_Node_Str""+ shell.getPort()+ ""String_Node_Str"";
synchronized (lock) {
    for (    SeleniumWrapper remote : remotes) {
      try {
        String url=shell.getModuleUrl(moduleName);
        shell.getTopLogger().log(TreeLogger.TRACE,""String_Node_Str"" + domain + ""String_Node_Str""+ url);
        remote.createSelenium(domain);
        remote.getSelenium().start();
        remote.getSelenium().open(url);
      }
 catch (      Exception e) {
        shell.getTopLogger().log(TreeLogger.ERROR,""String_Node_Str"" + remote.getSpecifier(),e);
      }
    }
  }
}",0.9503437738731856
54178,"private synchronized boolean doKeepAlives(){
  if (remotes != null) {
    for (    SeleniumWrapper remote : remotes) {
      try {
        if (remote.getSelenium() != null) {
          remote.getSelenium().getTitle();
        }
      }
 catch (      Throwable e) {
synchronized (wasInterruptedLock) {
          if (interruptedHosts == null) {
            interruptedHosts=new HashSet<String>();
          }
          interruptedHosts.add(remote.getSpecifier());
        }
      }
    }
  }
  return interruptedHosts == null;
}","private boolean doKeepAlives(){
synchronized (lock) {
    if (remotes != null) {
      if (stopped) {
        return false;
      }
      for (      SeleniumWrapper remote : remotes) {
        try {
          if (remote.getSelenium() != null) {
            remote.getSelenium().getTitle();
          }
        }
 catch (        Throwable e) {
          String message=e.getMessage();
          if (message != null && message.toLowerCase().contains(""String_Node_Str"")) {
            if (interruptedHosts == null) {
              interruptedHosts=new HashSet<String>();
            }
            interruptedHosts.add(remote.getSpecifier());
          }
        }
      }
    }
    return interruptedHosts == null;
  }
}",0.4312148028962188
54179,"@Override public String[] getInterruptedHosts(){
synchronized (wasInterruptedLock) {
    if (interruptedHosts == null) {
      return null;
    }
    return interruptedHosts.toArray(new String[interruptedHosts.size()]);
  }
}","@Override public String[] getInterruptedHosts(){
synchronized (lock) {
    if (interruptedHosts == null) {
      return null;
    }
    return interruptedHosts.toArray(new String[interruptedHosts.size()]);
  }
}",0.963302752293578
54180,"@Override public int initialize(String args){
  if (args == null || args.length() == 0) {
    getLogger().log(TreeLogger.ERROR,""String_Node_Str"");
    return -1;
  }
  String[] targetsIn=args.split(""String_Node_Str"");
  SeleniumWrapper targets[]=new SeleniumWrapper[targetsIn.length];
  for (int i=0; i < targets.length; ++i) {
    try {
      targets[i]=createSeleniumWrapper(targetsIn[i]);
    }
 catch (    IllegalArgumentException e) {
      getLogger().log(TreeLogger.ERROR,e.getMessage());
      return -1;
    }
  }
  this.remotes=targets;
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      for (      SeleniumWrapper remote : remotes) {
        if (remote.getSelenium() != null) {
          try {
            remote.getSelenium().stop();
          }
 catch (          SeleniumException se) {
            shell.getTopLogger().log(TreeLogger.WARN,""String_Node_Str"",se);
          }
        }
      }
    }
  }
);
  start();
  return targets.length;
}","@Override public int initialize(String args){
  if (args == null || args.length() == 0) {
    getLogger().log(TreeLogger.ERROR,""String_Node_Str"");
    return -1;
  }
  String[] targetsIn=args.split(""String_Node_Str"");
  SeleniumWrapper targets[]=new SeleniumWrapper[targetsIn.length];
  for (int i=0; i < targets.length; ++i) {
    try {
      targets[i]=createSeleniumWrapper(targetsIn[i]);
    }
 catch (    IllegalArgumentException e) {
      getLogger().log(TreeLogger.ERROR,e.getMessage());
      return -1;
    }
  }
  this.remotes=targets;
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
synchronized (lock) {
        stopped=true;
        for (        SeleniumWrapper remote : remotes) {
          if (remote.getSelenium() != null) {
            try {
              remote.getSelenium().stop();
            }
 catch (            SeleniumException se) {
              shell.getTopLogger().log(TreeLogger.WARN,""String_Node_Str"",se);
            }
          }
        }
      }
    }
  }
);
  start();
  return targets.length;
}",0.9361702127659576
54181,"/** 
 * Intended to be used to pull the value out of a CSS length. We rely on the behavior of parseFloat to ignore non-numeric chars in its input. If the value is ""auto"" or ""inherit"", 0 will be returned.
 * @param s The CSS length string to extract
 * @return The leading numeric portion of <code>s</code>, or 0 if ""auto"" or""inherit"" are passed in.
 */
private native double extractLengthValue(String s);","/** 
 * Intended to be used to pull the value out of a CSS length. If the value is ""auto"" or ""inherit"", 0 will be returned.
 * @param s The CSS length string to extract
 * @return The leading numeric portion of <code>s</code>, or 0 if ""auto"" or""inherit"" are passed in.
 */
private native double extractLengthValue(String s);",0.8901098901098901
54182,"public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
}","public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-100 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
}",0.9603668522764494
54183,"public void testBadStrings(){
  try {
    new Double(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}","public void testBadStrings(){
  try {
    new Double(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.parseDouble(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Double.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}",0.6118012422360248
54184,"public void onSizeChanged(SizeChangeEvent event){
  int size=event.getSize();
  if (size > maxSize) {
    showMoreElem.getStyle().clearDisplay();
  }
 else {
    showMoreElem.getStyle().setDisplay(Display.NONE);
  }
  int dataSize=data.size();
  if (size < dataSize) {
    while (size < dataSize) {
      data.remove(dataSize - 1);
      dataSize--;
    }
  }
 else {
    data.ensureCapacity(size);
    while (dataSize < size) {
      data.add(null);
      dataSize++;
    }
  }
  gc(size);
}","public void onSizeChanged(SizeChangeEvent event){
  size=event.getSize();
  showOrHide(showMoreElem,size > maxSize);
  showOrHide(showFewerElem,maxSize > initialMaxSize);
}",0.3855421686746988
54185,"@Override protected void onLoad(){
  super.onLoad();
  this.reg=model.addListHandler(new ListHandler<T>(){
    public void onDataChanged(    ListEvent<T> event){
      int start=event.getStart(), len=event.getLength();
      List<T> values=event.getValues();
      for (int i=0; i < len; ++i) {
        data.set(start + i,values.get(i));
      }
      render(start,len,values);
    }
    public void onSizeChanged(    SizeChangeEvent event){
      int size=event.getSize();
      if (size > maxSize) {
        showMoreElem.getStyle().clearDisplay();
      }
 else {
        showMoreElem.getStyle().setDisplay(Display.NONE);
      }
      int dataSize=data.size();
      if (size < dataSize) {
        while (size < dataSize) {
          data.remove(dataSize - 1);
          dataSize--;
        }
      }
 else {
        data.ensureCapacity(size);
        while (dataSize < size) {
          data.add(null);
          dataSize++;
        }
      }
      gc(size);
    }
  }
);
  reg.setRangeOfInterest(0,maxSize);
}","@Override protected void onLoad(){
  super.onLoad();
  this.reg=model.addListHandler(new ListHandler<T>(){
    public void onDataChanged(    ListEvent<T> event){
      int start=event.getStart();
      int len=event.getLength();
      List<T> values=event.getValues();
      StringBuilder sb=new StringBuilder();
      for (int i=0; i < len; i++) {
        sb.append(""String_Node_Str"" + (start + i) + ""String_Node_Str""+ seq+++ ""String_Node_Str"");
        cell.render(values.get(i),null,sb);
        sb.append(""String_Node_Str"");
      }
      Element parent=getElement().getFirstChildElement();
      if (start == 0 && len == maxSize) {
        parent.setInnerHTML(sb.toString());
      }
 else {
        makeElements();
        tmpElem.setInnerHTML(sb.toString());
        for (int i=0; i < len; i++) {
          Element child=parent.getChild(start + i).cast();
          parent.replaceChild(tmpElem.getChild(0),child);
        }
      }
    }
    public void onSizeChanged(    SizeChangeEvent event){
      size=event.getSize();
      showOrHide(showMoreElem,size > maxSize);
      showOrHide(showFewerElem,maxSize > initialMaxSize);
    }
    private void makeElements(){
      Element parent=getElement().getFirstChildElement();
      int childCount=parent.getChildCount();
      int actualSize=Math.min(size,maxSize);
      if (actualSize > childCount) {
        StringBuilder sb=new StringBuilder();
        int newElements=actualSize - childCount;
        for (int i=0; i < newElements; i++) {
          sb.append(""String_Node_Str"" + (childCount + i) + ""String_Node_Str"");
        }
        if (childCount == 0) {
          parent.setInnerHTML(sb.toString());
        }
 else {
          tmpElem.setInnerHTML(sb.toString());
          for (int i=0; i < newElements; i++) {
            parent.appendChild(tmpElem.getChild(0));
          }
        }
      }
 else       if (actualSize < childCount) {
        while (actualSize < childCount) {
          parent.getChild(--childCount).removeFromParent();
        }
      }
    }
  }
);
  reg.setRangeOfInterest(0,maxSize);
}",0.3688126819799417
54186,"public SimpleCellList(ListModel<T> model,Cell<T,Void> cell,int maxSize,int increment){
  this.maxSize=maxSize;
  this.increment=increment;
  this.model=model;
  this.cell=cell;
  tmpElem=Document.get().createDivElement();
  showMoreElem=Document.get().createDivElement();
  showMoreElem.setInnerHTML(""String_Node_Str"" + increment + ""String_Node_Str"");
  showMoreElem.getStyle().setDisplay(Display.NONE);
  DivElement outerDiv=Document.get().createDivElement();
  DivElement innerDiv=Document.get().createDivElement();
  outerDiv.appendChild(innerDiv);
  outerDiv.appendChild(showMoreElem);
  setElement(outerDiv);
  sinkEvents(Event.ONCLICK);
  sinkEvents(Event.ONCHANGE);
}","public SimpleCellList(ListModel<T> model,Cell<T,Void> cell,int maxSize,int increment){
  this.initialMaxSize=this.maxSize=maxSize;
  this.increment=increment;
  this.model=model;
  this.cell=cell;
  this.seq=0;
  tmpElem=Document.get().createDivElement();
  showMoreElem=Document.get().createDivElement();
  showMoreElem.setInnerHTML(""String_Node_Str"");
  showFewerElem=Document.get().createDivElement();
  showFewerElem.setInnerHTML(""String_Node_Str"");
  showOrHide(showMoreElem,false);
  showOrHide(showFewerElem,false);
  DivElement outerDiv=Document.get().createDivElement();
  DivElement innerDiv=Document.get().createDivElement();
  outerDiv.appendChild(innerDiv);
  outerDiv.appendChild(showFewerElem);
  outerDiv.appendChild(showMoreElem);
  setElement(outerDiv);
  sinkEvents(Event.ONCLICK);
  sinkEvents(Event.ONCHANGE);
}",0.7410358565737052
54187,"@Override public void onBrowserEvent(Event event){
  Element target=event.getEventTarget().cast();
  String idxString=""String_Node_Str"";
  while ((target != null) && ((idxString=target.getAttribute(""String_Node_Str"")).length() == 0)) {
    target=target.getParentElement();
  }
  if (idxString.length() > 0) {
    int idx=Integer.parseInt(idxString);
    cell.onBrowserEvent(target,data.get(idx),null,event,valueUpdater);
  }
}","@Override public void onBrowserEvent(Event event){
  Element target=event.getEventTarget().cast();
  if (target.getParentElement() == showMoreElem) {
    this.maxSize+=increment;
    reg.setRangeOfInterest(0,maxSize);
  }
 else   if (target.getParentElement() == showFewerElem) {
    this.maxSize=Math.max(initialMaxSize,maxSize - increment);
    reg.setRangeOfInterest(0,maxSize);
  }
 else {
    String idxString=""String_Node_Str"";
    while ((target != null) && ((idxString=target.getAttribute(""String_Node_Str"")).length() == 0)) {
      target=target.getParentElement();
    }
    if (idxString.length() > 0) {
      int idx=Integer.parseInt(idxString);
      cell.onBrowserEvent(target,data.get(idx),null,event,valueUpdater);
    }
  }
}",0.7305389221556886
54188,"public void onDataChanged(ListEvent<T> event){
  int start=event.getStart(), len=event.getLength();
  List<T> values=event.getValues();
  for (int i=0; i < len; ++i) {
    data.set(start + i,values.get(i));
  }
  render(start,len,values);
}","public void onDataChanged(ListEvent<T> event){
  int start=event.getStart();
  int len=event.getLength();
  List<T> values=event.getValues();
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < len; i++) {
    sb.append(""String_Node_Str"" + (start + i) + ""String_Node_Str""+ seq+++ ""String_Node_Str"");
    cell.render(values.get(i),null,sb);
    sb.append(""String_Node_Str"");
  }
  Element parent=getElement().getFirstChildElement();
  if (start == 0 && len == maxSize) {
    parent.setInnerHTML(sb.toString());
  }
 else {
    makeElements();
    tmpElem.setInnerHTML(sb.toString());
    for (int i=0; i < len; i++) {
      Element child=parent.getChild(start + i).cast();
      parent.replaceChild(tmpElem.getChild(0),child);
    }
  }
}",0.3675126903553299
54189,"public boolean remove(Object o){
  return flush(list.remove(o));
}","public boolean remove(Object o){
  int index=indexOf(o);
  if (index == -1) {
    return false;
  }
  remove(index);
  return true;
}",0.5628140703517588
54190,"public boolean removeAll(Collection<?> c){
  return flush(list.removeAll(c));
}","public boolean removeAll(Collection<?> c){
  boolean toRet=list.removeAll(c);
  minModified=0;
  maxModified=size();
  modified=true;
  return flush(toRet);
}",0.5738396624472574
54191,"public boolean add(T e){
  return flush(list.add(e));
}","public boolean add(T e){
  boolean toRet=list.add(e);
  minModified=Math.min(minModified,size() - 1);
  maxModified=size();
  modified=true;
  return flush(toRet);
}",0.4181818181818181
54192,"public T set(int index,T element){
  T toRet=list.set(index,element);
  flush();
  return toRet;
}","public T set(int index,T element){
  T toRet=list.set(index,element);
  minModified=Math.min(minModified,index);
  maxModified=Math.max(maxModified,index + 1);
  modified=true;
  flush();
  return toRet;
}",0.5610561056105611
54193,"public void clear(){
  list.clear();
  flush();
}","public void clear(){
  list.clear();
  minModified=maxModified=0;
  modified=true;
  flush();
}",0.6805555555555556
54194,"public ListWrapper(List<T> list){
  this.list=list;
}","public ListWrapper(List<T> list){
  this.list=list;
  minModified=0;
  maxModified=list.size();
  modified=true;
}",0.6347305389221557
54195,"public void execute(){
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateDataSize(curSize,true);
  }
  updateViewData(0,list.size(),list);
  flushPending=false;
}","public void execute(){
  int newSize=list.size();
  if (curSize != newSize) {
    curSize=newSize;
    updateDataSize(curSize,true);
  }
  if (modified) {
    int length=maxModified - minModified;
    updateViewData(minModified,length,list.subList(minModified,maxModified));
    modified=false;
  }
  minModified=Integer.MAX_VALUE;
  maxModified=Integer.MIN_VALUE;
  flushPending=false;
}",0.6382252559726962
54196,"public boolean addAll(int index,Collection<? extends T> c){
  return flush(list.addAll(index,c));
}","public boolean addAll(int index,Collection<? extends T> c){
  try {
    boolean toRet=list.addAll(index,c);
    minModified=Math.min(minModified,index);
    maxModified=size();
    modified=true;
    return flush(toRet);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new IndexOutOfBoundsException(e.getMessage());
  }
}",0.3091334894613583
54197,"public boolean retainAll(Collection<?> c){
  return flush(list.retainAll(c));
}","public boolean retainAll(Collection<?> c){
  boolean toRet=list.retainAll(c);
  minModified=0;
  maxModified=size();
  modified=true;
  return flush(toRet);
}",0.5738396624472574
54198,"public void execute(){
  p.animate(100,new AnimationCallback(){
    public void onLayout(    Layer layer,    double progress){
    }
    public void onAnimationComplete(){
      finishTest();
    }
  }
);
}","public void execute(){
  int offsetWidth=lp.getOffsetWidth();
  int offsetHeight=lp.getOffsetHeight();
  assertTrue(offsetWidth > 0);
  assertTrue(offsetHeight > 0);
  finishTest();
}",0.3701799485861182
54199,"/** 
 * Testing for public void java.util.Date.setHours(int). 
 */
public void testSetHours(){
  for (int i=0; i < 24; i++) {
    Date accum0=create();
    accum0.setHours(i);
    assertEquals(accum0.getHours(),i);
  }
}","/** 
 * Testing for public void java.util.Date.setHours(int). 
 */
public void testSetHours(){
  for (int i=0; i < 24; i++) {
    Date accum0=create();
    if (isDst(accum0)) {
      return;
    }
    accum0.setHours(i);
    assertEquals(accum0.getHours(),i);
  }
}",0.9072164948453608
54200,"@Override public void render(String value,StringBuilder sb){
  sb.append(""String_Node_Str"");
  if (value.charAt(0) == '-') {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(value);
  sb.append(""String_Node_Str"");
}","@Override public void render(String value,StringBuilder sb){
  if (value == null || value.length() == 0) {
    return;
  }
  sb.append(""String_Node_Str"");
  if (value.charAt(0) == '-') {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(value);
  sb.append(""String_Node_Str"");
}",0.89419795221843
54201,"@Override public void render(String value,StringBuilder sb){
  sb.append(""String_Node_Str"");
  if (highlightRegex == null || highlightRegex.length() == 0) {
    sb.append(value);
    sb.append(""String_Node_Str"");
    return;
  }
  RegExp regExp=RegExp.compile(highlightRegex,""String_Node_Str"");
  int fromIndex=0;
  int length=value.length();
  MatchResult result;
  while (fromIndex < length) {
    result=regExp.exec(value);
    if (result == null) {
      break;
    }
    int index=result.getIndex();
    String match=result.getGroup(0);
    sb.append(value.substring(fromIndex,index));
    sb.append(""String_Node_Str"");
    sb.append(match);
    sb.append(""String_Node_Str"");
    fromIndex=index + match.length();
    regExp.setLastIndex(fromIndex);
  }
  if (fromIndex < length) {
    sb.append(value.substring(fromIndex));
  }
  sb.append(""String_Node_Str"");
}","@Override public void render(String value,StringBuilder sb){
  sb.append(""String_Node_Str"");
  if (highlightRegex == null) {
    sb.append(value);
    sb.append(""String_Node_Str"");
    return;
  }
  int fromIndex=0;
  int length=value.length();
  MatchResult result;
  highlightRegex.setLastIndex(0);
  while (fromIndex < length) {
    result=highlightRegex.exec(value);
    if (result == null) {
      break;
    }
    int index=result.getIndex();
    String match=result.getGroup(0);
    sb.append(value.substring(fromIndex,index));
    sb.append(""String_Node_Str"");
    sb.append(match);
    sb.append(""String_Node_Str"");
    fromIndex=index + match.length();
    highlightRegex.setLastIndex(fromIndex);
  }
  if (fromIndex < length) {
    sb.append(value.substring(fromIndex));
  }
  sb.append(""String_Node_Str"");
}",0.2467378410438908
54202,"public void setHighlightRegex(String highlightRegex){
  this.highlightRegex=highlightRegex;
}","public void setHighlightRegex(String highlightText){
  if (highlightText != null && highlightText.length() > 0) {
    highlightRegex=RegExp.compile(highlightText,""String_Node_Str"");
  }
 else {
    highlightRegex=null;
  }
}",0.4416403785488959
54203,"private Result getQuotes(SortedSet<String> symbols,Range range){
  int start=range.getStart();
  int end=Math.min(start + range.getLength(),symbols.size());
  if (end <= start) {
    return new Result(new StockQuoteList(0),0);
  }
  SortedSet<String> symbolsInRange=new TreeSet<String>();
  int idx=0;
  for (  String symbol : symbols) {
    if (idx >= start && idx < end) {
      symbolsInRange.add(symbol);
    }
    idx++;
  }
  SortedSet<String> symbolsToQuery=new TreeSet<String>();
  long now=System.currentTimeMillis();
  for (  String symbol : symbolsInRange) {
    Quote quote=QUOTES.get(symbol);
    if (quote == null || now - quote.getCreatedTime() >= 5000) {
      symbolsToQuery.add(symbol);
    }
 else {
    }
  }
  if (symbolsToQuery.size() > 0) {
    GoogleFinance.queryServer(symbolsToQuery,QUOTES);
  }
  StockQuoteList toRet=new StockQuoteList(start);
  for (  String symbol : symbolsInRange) {
    Quote quote=QUOTES.get(symbol);
    if (quote == null) {
      System.out.println(""String_Node_Str"" + symbol);
    }
 else {
      String name=Stocks.companyNamesBySymbol.get(symbol);
      PlayerStatus player=ensurePlayer();
      Integer sharesOwned=player.getSharesOwned(symbol);
      boolean favorite=player.isFavorite(symbol);
      int totalPaid=player.getAverageCostBasis(symbol);
      toRet.add(new StockQuote(symbol,name,quote.getPrice(),quote.getChange(),sharesOwned == null ? 0 : sharesOwned.intValue(),favorite,totalPaid));
    }
  }
  return new Result(toRet,symbols.size());
}","private Result getQuotes(SortedSet<String> symbols,Range range){
  int start=range.getStart();
  int end=Math.min(start + range.getLength(),symbols.size());
  if (end <= start) {
    return new Result(new StockQuoteList(0),0);
  }
  SortedSet<String> symbolsInRange=new TreeSet<String>();
  int idx=0;
  for (  String symbol : symbols) {
    if (idx >= start && idx < end) {
      symbolsInRange.add(symbol);
    }
    idx++;
  }
  SortedSet<String> symbolsToQuery=new TreeSet<String>();
  long now=System.currentTimeMillis();
  for (  String symbol : symbolsInRange) {
    Quote quote=QUOTES.get(symbol);
    if (quote == null || now - quote.getCreatedTime() >= 5000) {
      symbolsToQuery.add(symbol);
    }
 else {
    }
  }
  if (symbolsToQuery.size() > 0) {
    GoogleFinance.queryServer(symbolsToQuery,QUOTES);
  }
  StockQuoteList toRet=new StockQuoteList(start);
  for (  String symbol : symbolsInRange) {
    Quote quote=QUOTES.get(symbol);
    if (quote == null) {
      System.out.println(""String_Node_Str"" + symbol);
    }
 else {
      String name=Stocks.companyNamesBySymbol.get(symbol);
      PlayerStatus player=ensurePlayer();
      Integer sharesOwned=player.getSharesOwned(symbol);
      boolean favorite=player.isFavorite(symbol);
      int totalPaid=player.getAverageCostBasis(symbol);
      toRet.add(new StockQuote(symbol,name,quote.getPrice(),quote.getChange(),sharesOwned == null ? 0 : sharesOwned.intValue(),favorite,totalPaid));
    }
  }
  return new Result(toRet,toRet.size());
}",0.9960264900662252
54204,"private Result getSearchQuotes(String query,Range searchRange){
  SortedSet<String> symbols=new TreeSet<String>();
  boolean queryIsAlpha=true;
  for (int i=0; i < query.length(); i++) {
    char c=query.charAt(i);
    if ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) {
      queryIsAlpha=false;
      break;
    }
  }
  query=query.toUpperCase(Locale.US);
  if (queryIsAlpha) {
    getTickersByPrefix(query,symbols);
  }
  Pattern pattern=compile(""String_Node_Str"" + query + ""String_Node_Str"");
  if (pattern != null) {
    if (!queryIsAlpha) {
      getTickersBySymbolRegex(pattern,symbols);
    }
    getTickersByNameRegex(pattern,symbols);
  }
  return getQuotes(symbols,searchRange);
}","private Result getSearchQuotes(String query,Range searchRange){
  SortedSet<String> symbols=new TreeSet<String>();
  boolean queryIsAlpha=true;
  for (int i=0; i < query.length(); i++) {
    char c=query.charAt(i);
    if ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) {
      queryIsAlpha=false;
      break;
    }
  }
  query=query.toUpperCase(Locale.US);
  if (queryIsAlpha) {
    getTickersByPrefix(query,symbols);
  }
  Pattern pattern=compile(""String_Node_Str"" + query + ""String_Node_Str"");
  if (pattern != null) {
    if (!queryIsAlpha) {
      getTickersBySymbolRegex(pattern,symbols);
    }
    if (query.length() > 2) {
      getTickersByNameRegex(pattern,symbols);
    }
  }
  return getQuotes(symbols,searchRange);
}",0.9732394366197183
54205,"/** 
 * Returns the precision of this   {@code BigDecimal}. The precision is the number of decimal digits used to represent this decimal. It is equivalent to the number of digits of the unscaled value. The precision of   {@code 0}is   {@code 1} (independent of the scale).
 * @return the precision of this {@code BigDecimal}.
 */
public int precision(){
  if (precision > 0) {
    return precision;
  }
  int decimalDigits=1;
  double doubleUnsc=1;
  if (bitLength < 1024) {
    if (bitLength >= 54) {
      doubleUnsc=getUnscaledValue().doubleValue();
    }
 else     if (bitLength >= 1) {
      doubleUnsc=smallValue;
    }
    decimalDigits+=(int)Math.log10(Math.abs(doubleUnsc));
  }
 else {
    decimalDigits+=(bitLength - 1) * LOG10_2;
    if (getUnscaledValue().divide(Multiplication.powerOf10(decimalDigits)).signum() != 0) {
      decimalDigits++;
    }
  }
  precision=decimalDigits;
  return precision;
}","/** 
 * Returns the precision of this   {@code BigDecimal}. The precision is the number of decimal digits used to represent this decimal. It is equivalent to the number of digits of the unscaled value. The precision of   {@code 0}is   {@code 1} (independent of the scale).
 * @return the precision of this {@code BigDecimal}.
 */
public int precision(){
  if (precision > 0) {
    return precision;
  }
  double decimalDigits=1;
  double doubleUnsc=1;
  if (bitLength < SMALL_VALUE_BITS) {
    if (bitLength >= 1) {
      doubleUnsc=smallValue;
    }
    decimalDigits+=Math.log10(Math.abs(doubleUnsc));
  }
 else {
    decimalDigits+=(bitLength - 1) * LOG10_2;
    if (getUnscaledValue().divide(Multiplication.powerOf10(decimalDigits)).signum() != 0) {
      decimalDigits++;
    }
  }
  precision=(int)decimalDigits;
  return precision;
}",0.9264957264957264
54206,"private static BigDecimal addAndMult10(BigDecimal thisValue,BigDecimal augend,double diffScale){
  if (diffScale < DOUBLE_TEN_POW.length && Math.max(thisValue.bitLength,augend.bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)diffScale]) + 1 < 54) {
    return valueOf(thisValue.smallValue + augend.smallValue * DOUBLE_TEN_POW[(int)diffScale],thisValue.scale);
  }
  return new BigDecimal(thisValue.getUnscaledValue().add(Multiplication.multiplyByTenPow(augend.getUnscaledValue(),(int)diffScale)),thisValue.scale);
}","private static BigDecimal addAndMult10(BigDecimal thisValue,BigDecimal augend,double diffScale){
  if (diffScale < DOUBLE_TEN_POW.length && Math.max(thisValue.bitLength,augend.bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)diffScale]) + 1 < SMALL_VALUE_BITS) {
    return valueOf(thisValue.smallValue + augend.smallValue * DOUBLE_TEN_POW[(int)diffScale],thisValue.scale);
  }
  return new BigDecimal(thisValue.getUnscaledValue().add(Multiplication.multiplyByTenPow(augend.getUnscaledValue(),(int)diffScale)),thisValue.scale);
}",0.9825581395348836
54207,"/** 
 * Compares this   {@code BigDecimal} with {@code val}. Returns one of the three values   {@code 1},   {@code 0}, or   {@code -1}. The method behaves as if  {@code this.subtract(val)} is computed. If this difference is > 0 then 1 isreturned, if the difference is < 0 then -1 is returned, and if the difference is 0 then 0 is returned. This means, that if two decimal instances are compared which are equal in value but differ in scale, then these two instances are considered as equal.
 * @param val value to be compared with {@code this}.
 * @return {@code 1} if {@code this > val},   {@code -1} if {@code this < val},  {@code 0} if {@code this == val}.
 * @throws NullPointerException if {@code val == null}.
 */
public int compareTo(BigDecimal val){
  int thisSign=signum();
  int valueSign=val.signum();
  if (thisSign == valueSign) {
    if (this.scale == val.scale && this.bitLength < 54 && val.bitLength < 54) {
      return (smallValue < val.smallValue) ? -1 : (smallValue > val.smallValue) ? 1 : 0;
    }
    double diffScale=this.scale - val.scale;
    double diffPrecision=this.approxPrecision() - val.approxPrecision();
    if (diffPrecision > diffScale + 1) {
      return thisSign;
    }
 else     if (diffPrecision < diffScale - 1) {
      return -thisSign;
    }
 else {
      BigInteger thisUnscaled=this.getUnscaledValue();
      BigInteger valUnscaled=val.getUnscaledValue();
      if (diffScale < 0) {
        thisUnscaled=thisUnscaled.multiply(Multiplication.powerOf10(-diffScale));
      }
 else       if (diffScale > 0) {
        valUnscaled=valUnscaled.multiply(Multiplication.powerOf10(diffScale));
      }
      return thisUnscaled.compareTo(valUnscaled);
    }
  }
 else   if (thisSign < valueSign) {
    return -1;
  }
 else {
    return 1;
  }
}","/** 
 * Compares this   {@code BigDecimal} with {@code val}. Returns one of the three values   {@code 1},   {@code 0}, or   {@code -1}. The method behaves as if  {@code this.subtract(val)} is computed. If this difference is > 0 then 1 isreturned, if the difference is < 0 then -1 is returned, and if the difference is 0 then 0 is returned. This means, that if two decimal instances are compared which are equal in value but differ in scale, then these two instances are considered as equal.
 * @param val value to be compared with {@code this}.
 * @return {@code 1} if {@code this > val},   {@code -1} if {@code this < val},  {@code 0} if {@code this == val}.
 * @throws NullPointerException if {@code val == null}.
 */
public int compareTo(BigDecimal val){
  int thisSign=signum();
  int valueSign=val.signum();
  if (thisSign == valueSign) {
    if (this.scale == val.scale && this.bitLength < SMALL_VALUE_BITS && val.bitLength < SMALL_VALUE_BITS) {
      return (smallValue < val.smallValue) ? -1 : (smallValue > val.smallValue) ? 1 : 0;
    }
    double diffScale=this.scale - val.scale;
    double diffPrecision=this.approxPrecision() - val.approxPrecision();
    if (diffPrecision > diffScale + 1) {
      return thisSign;
    }
 else     if (diffPrecision < diffScale - 1) {
      return -thisSign;
    }
 else {
      BigInteger thisUnscaled=this.getUnscaledValue();
      BigInteger valUnscaled=val.getUnscaledValue();
      if (diffScale < 0) {
        thisUnscaled=thisUnscaled.multiply(Multiplication.powerOf10(-diffScale));
      }
 else       if (diffScale > 0) {
        valUnscaled=valUnscaled.multiply(Multiplication.powerOf10(diffScale));
      }
      return thisUnscaled.compareTo(valUnscaled);
    }
  }
 else   if (thisSign < valueSign) {
    return -1;
  }
 else {
    return 1;
  }
}",0.9899609592861126
54208,"/** 
 * Returns the sign of this   {@code BigDecimal}.
 * @return {@code -1} if {@code this < 0},   {@code 0} if {@code this == 0},  {@code 1} if {@code this > 0}.
 */
public int signum(){
  if (bitLength < 54) {
    return this.smallValue < 0 ? -1 : this.smallValue > 0 ? 1 : 0;
  }
  return getUnscaledValue().signum();
}","/** 
 * Returns the sign of this   {@code BigDecimal}.
 * @return {@code -1} if {@code this < 0},   {@code 0} if {@code this == 0},  {@code 1} if {@code this > 0}.
 */
public int signum(){
  if (bitLength < SMALL_VALUE_BITS) {
    return this.smallValue < 0 ? -1 : this.smallValue > 0 ? 1 : 0;
  }
  return getUnscaledValue().signum();
}",0.9727272727272728
54209,"/** 
 * It does all rounding work of the public method   {@code round(MathContext)}, performing an inplace rounding without creating a new object.
 * @param mc the {@code MathContext} for perform the rounding.
 * @see #round(MathContext)
 */
private void inplaceRound(MathContext mc){
  int mcPrecision=mc.getPrecision();
  if (approxPrecision() - mcPrecision <= 0 || mcPrecision == 0) {
    return;
  }
  int discardedPrecision=precision() - mcPrecision;
  if ((discardedPrecision <= 0)) {
    return;
  }
  if (this.bitLength < 54) {
    smallRound(mc,discardedPrecision);
    return;
  }
  BigInteger sizeOfFraction=Multiplication.powerOf10(discardedPrecision);
  BigInteger[] integerAndFraction=getUnscaledValue().divideAndRemainder(sizeOfFraction);
  double newScale=scale - discardedPrecision;
  int compRem;
  BigDecimal tempBD;
  if (integerAndFraction[1].signum() != 0) {
    compRem=(integerAndFraction[1].abs().shiftLeftOneBit().compareTo(sizeOfFraction));
    compRem=roundingBehavior(integerAndFraction[0].testBit(0) ? 1 : 0,integerAndFraction[1].signum() * (5 + compRem),mc.getRoundingMode());
    if (compRem != 0) {
      integerAndFraction[0]=integerAndFraction[0].add(BigInteger.valueOf(compRem));
    }
    tempBD=new BigDecimal(integerAndFraction[0]);
    if (tempBD.precision() > mcPrecision) {
      integerAndFraction[0]=integerAndFraction[0].divide(BigInteger.TEN);
      newScale--;
    }
  }
  scale=toIntScale(newScale);
  precision=mcPrecision;
  setUnscaledValue(integerAndFraction[0]);
}","/** 
 * It does all rounding work of the public method   {@code round(MathContext)}, performing an inplace rounding without creating a new object.
 * @param mc the {@code MathContext} for perform the rounding.
 * @see #round(MathContext)
 */
private void inplaceRound(MathContext mc){
  int mcPrecision=mc.getPrecision();
  if (approxPrecision() - mcPrecision < 0 || mcPrecision == 0) {
    return;
  }
  int discardedPrecision=precision() - mcPrecision;
  if ((discardedPrecision <= 0)) {
    return;
  }
  if (this.bitLength < SMALL_VALUE_BITS) {
    smallRound(mc,discardedPrecision);
    return;
  }
  BigInteger sizeOfFraction=Multiplication.powerOf10(discardedPrecision);
  BigInteger[] integerAndFraction=getUnscaledValue().divideAndRemainder(sizeOfFraction);
  double newScale=scale - discardedPrecision;
  int compRem;
  BigDecimal tempBD;
  if (integerAndFraction[1].signum() != 0) {
    compRem=(integerAndFraction[1].abs().shiftLeftOneBit().compareTo(sizeOfFraction));
    compRem=roundingBehavior(integerAndFraction[0].testBit(0) ? 1 : 0,integerAndFraction[1].signum() * (5 + compRem),mc.getRoundingMode());
    if (compRem != 0) {
      integerAndFraction[0]=integerAndFraction[0].add(BigInteger.valueOf(compRem));
    }
    tempBD=new BigDecimal(integerAndFraction[0]);
    if (tempBD.precision() > mcPrecision) {
      integerAndFraction[0]=integerAndFraction[0].divide(BigInteger.TEN);
      newScale--;
    }
  }
  scale=toIntScale(newScale);
  precision=mcPrecision;
  setUnscaledValue(integerAndFraction[0]);
}",0.993764358385297
54210,"private void initFrom(String val){
  int begin=0;
  int offset=0;
  int last=val.length() - 1;
  String scaleString=null;
  StringBuilder unscaledBuffer;
  if (val == null) {
    throw new NullPointerException();
  }
  unscaledBuffer=new StringBuilder(val.length());
  if ((offset <= last) && (val.charAt(offset) == '+')) {
    offset++;
    begin++;
  }
  int counter=0;
  boolean wasNonZero=false;
  for (; (offset <= last) && (val.charAt(offset) != '.') && (val.charAt(offset) != 'e')&& (val.charAt(offset) != 'E'); offset++) {
    if (!wasNonZero) {
      if (val.charAt(offset) == '0') {
        counter++;
      }
 else {
        wasNonZero=true;
      }
    }
  }
  unscaledBuffer.append(val,begin,offset);
  if ((offset <= last) && (val.charAt(offset) == '.')) {
    offset++;
    begin=offset;
    for (; (offset <= last) && (val.charAt(offset) != 'e') && (val.charAt(offset) != 'E'); offset++) {
      if (!wasNonZero) {
        if (val.charAt(offset) == '0') {
          counter++;
        }
 else {
          wasNonZero=true;
        }
      }
    }
    scale=offset - begin;
    unscaledBuffer.append(val,begin,offset);
  }
 else {
    scale=0;
  }
  if ((offset <= last) && ((val.charAt(offset) == 'e') || (val.charAt(offset) == 'E'))) {
    offset++;
    begin=offset;
    if ((offset <= last) && (val.charAt(offset) == '+')) {
      offset++;
      if ((offset <= last) && (val.charAt(offset) != '-')) {
        begin++;
      }
    }
    scaleString=val.substring(begin,last + 1);
    scale=scale - Integer.parseInt(scaleString);
    if (scale != (int)scale) {
      throw new NumberFormatException(""String_Node_Str"");
    }
  }
  String unscaled=unscaledBuffer.toString();
  if (unscaled.length() < 16) {
    smallValue=parseUnscaled(unscaled);
    if (Double.isNaN(smallValue)) {
      throw new NumberFormatException(""String_Node_Str"" + val + ""String_Node_Str"");
    }
    bitLength=bitLength(smallValue);
  }
 else {
    setUnscaledValue(new BigInteger(unscaled));
  }
  precision=unscaledBuffer.length() - counter;
  if (unscaledBuffer.charAt(0) == '-') {
    precision--;
  }
}","private void initFrom(String val){
  int begin=0;
  int offset=0;
  int last=val.length() - 1;
  String scaleString=null;
  StringBuilder unscaledBuffer;
  unscaledBuffer=new StringBuilder(val.length());
  if ((offset <= last) && (val.charAt(offset) == '+')) {
    offset++;
    begin++;
  }
  int counter=0;
  boolean wasNonZero=false;
  for (; (offset <= last) && (val.charAt(offset) != '.') && (val.charAt(offset) != 'e')&& (val.charAt(offset) != 'E'); offset++) {
    if (!wasNonZero) {
      if (val.charAt(offset) == '0') {
        counter++;
      }
 else {
        wasNonZero=true;
      }
    }
  }
  unscaledBuffer.append(val,begin,offset);
  if ((offset <= last) && (val.charAt(offset) == '.')) {
    offset++;
    begin=offset;
    for (; (offset <= last) && (val.charAt(offset) != 'e') && (val.charAt(offset) != 'E'); offset++) {
      if (!wasNonZero) {
        if (val.charAt(offset) == '0') {
          counter++;
        }
 else {
          wasNonZero=true;
        }
      }
    }
    scale=offset - begin;
    unscaledBuffer.append(val,begin,offset);
  }
 else {
    scale=0;
  }
  if ((offset <= last) && ((val.charAt(offset) == 'e') || (val.charAt(offset) == 'E'))) {
    offset++;
    begin=offset;
    if ((offset <= last) && (val.charAt(offset) == '+')) {
      offset++;
      if ((offset <= last) && (val.charAt(offset) != '-')) {
        begin++;
      }
    }
    scaleString=val.substring(begin,last + 1);
    scale=scale - Integer.parseInt(scaleString);
    if (scale != (int)scale) {
      throw new NumberFormatException(""String_Node_Str"");
    }
  }
  String unscaled=unscaledBuffer.toString();
  if (unscaled.length() < 16) {
    smallValue=parseUnscaled(unscaled);
    if (Double.isNaN(smallValue)) {
      throw new NumberFormatException(""String_Node_Str"" + val + ""String_Node_Str"");
    }
    bitLength=bitLength(smallValue);
  }
 else {
    setUnscaledValue(new BigInteger(unscaled));
  }
  precision=unscaledBuffer.length() - counter;
  for (int i=0; i < unscaledBuffer.length(); ++i) {
    char ch=unscaledBuffer.charAt(i);
    if (ch != '-' && ch != '0') {
      break;
    }
    --precision;
  }
}",0.1146496815286624
54211,"/** 
 * Returns a new   {@code BigDecimal} instance with the specified scale.<p> If the new scale is greater than the old scale, then additional zeros are added to the unscaled value. In this case no rounding is necessary. <p> If the new scale is smaller than the old scale, then trailing digits are removed. If these trailing digits are not zero, then the remaining unscaled value has to be rounded. For this rounding operation the specified rounding mode is used.
 * @param newScale scale of the result returned.
 * @param roundingMode rounding mode to be used to round the result.
 * @return a new {@code BigDecimal} instance with the specified scale.
 * @throws NullPointerException if {@code roundingMode == null}.
 * @throws ArithmeticException if {@code roundingMode == ROUND_UNNECESSARY}and rounding is necessary according to the given scale.
 */
public BigDecimal setScale(int newScale,RoundingMode roundingMode){
  if (roundingMode == null) {
    throw new NullPointerException();
  }
  double diffScale=newScale - scale;
  if (diffScale == 0) {
    return this;
  }
  if (diffScale > 0) {
    if (diffScale < DOUBLE_TEN_POW.length && (this.bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)diffScale]) < 54) {
      return valueOf(this.smallValue * DOUBLE_TEN_POW[(int)diffScale],newScale);
    }
    return new BigDecimal(Multiplication.multiplyByTenPow(getUnscaledValue(),(int)diffScale),newScale);
  }
  if (this.bitLength < 54 && -diffScale < DOUBLE_TEN_POW.length) {
    return dividePrimitiveLongs((long)this.smallValue,(long)DOUBLE_TEN_POW[(int)-diffScale],newScale,roundingMode);
  }
  return divideBigIntegers(this.getUnscaledValue(),Multiplication.powerOf10(-diffScale),newScale,roundingMode);
}","/** 
 * Returns a new   {@code BigDecimal} instance with the specified scale.<p> If the new scale is greater than the old scale, then additional zeros are added to the unscaled value. In this case no rounding is necessary. <p> If the new scale is smaller than the old scale, then trailing digits are removed. If these trailing digits are not zero, then the remaining unscaled value has to be rounded. For this rounding operation the specified rounding mode is used.
 * @param newScale scale of the result returned.
 * @param roundingMode rounding mode to be used to round the result.
 * @return a new {@code BigDecimal} instance with the specified scale.
 * @throws NullPointerException if {@code roundingMode == null}.
 * @throws ArithmeticException if {@code roundingMode == ROUND_UNNECESSARY}and rounding is necessary according to the given scale.
 */
public BigDecimal setScale(int newScale,RoundingMode roundingMode){
  if (roundingMode == null) {
    throw new NullPointerException();
  }
  double diffScale=newScale - scale;
  if (diffScale == 0) {
    return this;
  }
  if (diffScale > 0) {
    if (diffScale < DOUBLE_TEN_POW.length && (this.bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)diffScale]) < SMALL_VALUE_BITS) {
      return valueOf(this.smallValue * DOUBLE_TEN_POW[(int)diffScale],newScale);
    }
    return new BigDecimal(Multiplication.multiplyByTenPow(getUnscaledValue(),(int)diffScale),newScale);
  }
  if (this.bitLength < SMALL_VALUE_BITS && -diffScale < DOUBLE_TEN_POW.length) {
    return dividePrimitiveLongs((long)this.smallValue,(long)DOUBLE_TEN_POW[(int)-diffScale],newScale,roundingMode);
  }
  return divideBigIntegers(this.getUnscaledValue(),Multiplication.powerOf10(-diffScale),newScale,roundingMode);
}",0.9895531050493326
54212,"/** 
 * Returns a hash code for this   {@code BigDecimal}.
 * @return hash code for {@code this}.
 */
@Override public int hashCode(){
  if (hashCode != 0) {
    return hashCode;
  }
  if (bitLength < 54) {
    long longValue=(long)smallValue;
    hashCode=(int)(longValue & 0xffffffff);
    hashCode=33 * hashCode + (int)((longValue >> 32) & 0xffffffff);
    hashCode=17 * hashCode + (int)scale;
    return hashCode;
  }
  hashCode=17 * intVal.hashCode() + (int)scale;
  return hashCode;
}","/** 
 * Returns a hash code for this   {@code BigDecimal}.
 * @return hash code for {@code this}.
 */
@Override public int hashCode(){
  if (hashCode != 0) {
    return hashCode;
  }
  if (bitLength < SMALL_VALUE_BITS) {
    long longValue=(long)smallValue;
    hashCode=(int)(longValue & 0xffffffff);
    hashCode=33 * hashCode + (int)((longValue >> 32) & 0xffffffff);
    hashCode=17 * hashCode + (int)scale;
    return hashCode;
  }
  hashCode=17 * intVal.hashCode() + (int)scale;
  return hashCode;
}",0.9818913480885312
54213,"/** 
 * Returns a new   {@code BigDecimal} whose value is {@code this} 10^{@code n}. The scale of the result is   {@code this.scale()} - {@code n}. The precision of the result is the precision of   {@code this}. <p> This method has the same effect as   {@link #movePointRight}, except that the precision is not changed.
 * @param n number of places the decimal point has to be moved.
 * @return {@code this * 10^n}
 */
public BigDecimal scaleByPowerOfTen(int n){
  double newScale=scale - n;
  if (bitLength < 54) {
    if (smallValue == 0) {
      return zeroScaledBy(newScale);
    }
    return valueOf(smallValue,toIntScale(newScale));
  }
  return new BigDecimal(getUnscaledValue(),toIntScale(newScale));
}","/** 
 * Returns a new   {@code BigDecimal} whose value is {@code this} 10^{@code n}. The scale of the result is   {@code this.scale()} - {@code n}. The precision of the result is the precision of   {@code this}. <p> This method has the same effect as   {@link #movePointRight}, except that the precision is not changed.
 * @param n number of places the decimal point has to be moved.
 * @return {@code this * 10^n}
 */
public BigDecimal scaleByPowerOfTen(int n){
  double newScale=scale - n;
  if (bitLength < SMALL_VALUE_BITS) {
    if (smallValue == 0) {
      return zeroScaledBy(newScale);
    }
    return valueOf(smallValue,toIntScale(newScale));
  }
  return new BigDecimal(getUnscaledValue(),toIntScale(newScale));
}",0.98744769874477
54214,"private void setUnscaledValue(BigInteger unscaledValue){
  this.intVal=unscaledValue;
  this.bitLength=unscaledValue.bitLength();
  if (this.bitLength < 54) {
    this.smallValue=unscaledValue.longValue();
  }
}","private void setUnscaledValue(BigInteger unscaledValue){
  this.intVal=unscaledValue;
  this.bitLength=unscaledValue.bitLength();
  if (this.bitLength < SMALL_VALUE_BITS) {
    this.smallValue=unscaledValue.longValue();
  }
}",0.9587155963302753
54215,"private static BigDecimal divideBigIntegers(BigInteger scaledDividend,BigInteger scaledDivisor,int scale,RoundingMode roundingMode){
  BigInteger[] quotAndRem=scaledDividend.divideAndRemainder(scaledDivisor);
  BigInteger quotient=quotAndRem[0];
  BigInteger remainder=quotAndRem[1];
  if (remainder.signum() == 0) {
    return new BigDecimal(quotient,scale);
  }
  int sign=scaledDividend.signum() * scaledDivisor.signum();
  int compRem;
  if (scaledDivisor.bitLength() < 54) {
    long rem=remainder.longValue();
    long divisor=scaledDivisor.longValue();
    compRem=longCompareTo(Math.abs(rem) << 1,Math.abs(divisor));
    compRem=roundingBehavior(quotient.testBit(0) ? 1 : 0,sign * (5 + compRem),roundingMode);
  }
 else {
    compRem=remainder.abs().shiftLeftOneBit().compareTo(scaledDivisor.abs());
    compRem=roundingBehavior(quotient.testBit(0) ? 1 : 0,sign * (5 + compRem),roundingMode);
  }
  if (compRem != 0) {
    if (quotient.bitLength() < 54) {
      return valueOf(quotient.longValue() + compRem,scale);
    }
    quotient=quotient.add(BigInteger.valueOf(compRem));
    return new BigDecimal(quotient,scale);
  }
  return new BigDecimal(quotient,scale);
}","private static BigDecimal divideBigIntegers(BigInteger scaledDividend,BigInteger scaledDivisor,int scale,RoundingMode roundingMode){
  BigInteger[] quotAndRem=scaledDividend.divideAndRemainder(scaledDivisor);
  BigInteger quotient=quotAndRem[0];
  BigInteger remainder=quotAndRem[1];
  if (remainder.signum() == 0) {
    return new BigDecimal(quotient,scale);
  }
  int sign=scaledDividend.signum() * scaledDivisor.signum();
  int compRem;
  if (scaledDivisor.bitLength() < SMALL_VALUE_BITS) {
    long rem=remainder.longValue();
    long divisor=scaledDivisor.longValue();
    compRem=longCompareTo(Math.abs(rem) << 1,Math.abs(divisor));
    compRem=roundingBehavior(quotient.testBit(0) ? 1 : 0,sign * (5 + compRem),roundingMode);
  }
 else {
    compRem=remainder.abs().shiftLeftOneBit().compareTo(scaledDivisor.abs());
    compRem=roundingBehavior(quotient.testBit(0) ? 1 : 0,sign * (5 + compRem),roundingMode);
  }
  if (compRem != 0) {
    if (quotient.bitLength() < SMALL_VALUE_BITS) {
      return valueOf(quotient.longValue() + compRem,scale);
    }
    quotient=quotient.add(BigInteger.valueOf(compRem));
    return new BigDecimal(quotient,scale);
  }
  return new BigDecimal(quotient,scale);
}",0.984861227922624
54216,"private BigDecimal movePoint(double newScale){
  if (isZero()) {
    return zeroScaledBy(Math.max(newScale,0));
  }
  if (newScale >= 0) {
    if (bitLength < 54) {
      return valueOf(smallValue,toIntScale(newScale));
    }
    return new BigDecimal(getUnscaledValue(),toIntScale(newScale));
  }
  if (-newScale < DOUBLE_TEN_POW.length && bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)-newScale] < 54) {
    return valueOf(smallValue * DOUBLE_TEN_POW[(int)-newScale],0);
  }
  return new BigDecimal(Multiplication.multiplyByTenPow(getUnscaledValue(),(int)-newScale),0);
}","private BigDecimal movePoint(double newScale){
  if (isZero()) {
    return zeroScaledBy(Math.max(newScale,0));
  }
  if (newScale >= 0) {
    if (bitLength < SMALL_VALUE_BITS) {
      return valueOf(smallValue,toIntScale(newScale));
    }
    return new BigDecimal(getUnscaledValue(),toIntScale(newScale));
  }
  if (-newScale < DOUBLE_TEN_POW.length && bitLength + DOUBLE_TEN_POW_BIT_LENGTH[(int)-newScale] < SMALL_VALUE_BITS) {
    return valueOf(smallValue * DOUBLE_TEN_POW[(int)-newScale],0);
  }
  return new BigDecimal(Multiplication.multiplyByTenPow(getUnscaledValue(),(int)-newScale),0);
}",0.9691780821917808
54217,"private BigDecimal(long smallValue,int scale){
  this.scale=scale;
  this.bitLength=bitLength(smallValue);
  if (bitLength < 54) {
    this.smallValue=smallValue;
  }
 else {
    this.intVal=BigInteger.valueOf(smallValue);
  }
}","private BigDecimal(long smallValue,int scale){
  this.scale=scale;
  this.bitLength=bitLength(smallValue);
  if (bitLength < SMALL_VALUE_BITS) {
    this.smallValue=smallValue;
  }
 else {
    this.intVal=BigInteger.valueOf(smallValue);
  }
}",0.9617021276595744
54218,"/** 
 * Returns   {@code true} if {@code x} is a {@code BigDecimal} instance and ifthis instance is equal to this big decimal. Two big decimals are equal if their unscaled value and their scale is equal. For example, 1.0 (10*10^(-1)) is not equal to 1.00 (100*10^(-2)). Similarly, zero instances are not equal if their scale differs.
 * @param x object to be compared with {@code this}.
 * @return true if {@code x} is a {@code BigDecimal} and {@code this == x}.
 */
@Override public boolean equals(Object x){
  if (this == x) {
    return true;
  }
  if (x instanceof BigDecimal) {
    BigDecimal x1=(BigDecimal)x;
    return x1.scale == scale && (bitLength < 54 ? (x1.smallValue == smallValue) : intVal.equals(x1.intVal));
  }
  return false;
}","/** 
 * Returns   {@code true} if {@code x} is a {@code BigDecimal} instance and ifthis instance is equal to this big decimal. Two big decimals are equal if their unscaled value and their scale is equal. For example, 1.0 (10*10^(-1)) is not equal to 1.00 (100*10^(-2)). Similarly, zero instances are not equal if their scale differs.
 * @param x object to be compared with {@code this}.
 * @return true if {@code x} is a {@code BigDecimal} and {@code this == x}.
 */
@Override public boolean equals(Object x){
  if (this == x) {
    return true;
  }
  if (x instanceof BigDecimal) {
    BigDecimal x1=(BigDecimal)x;
    return x1.scale == scale && (bitLength < SMALL_VALUE_BITS ? (x1.smallValue == smallValue) : intVal.equals(x1.intVal));
  }
  return false;
}",0.9880478087649402
54219,"private void record(JsExpression x,JsContext<JsExpression> ctx){
  if (ctx.isLvalue()) {
    return;
  }
 else   if (x.getSourceInfo().getStartLine() == lastLine && (!recordFileNames || x.getSourceInfo().getFileName().equals(lastFile))) {
    return;
  }
  SourceInfo info=x.getSourceInfo().makeChild(JsStackEmulator.class,""String_Node_Str"");
  JsExpression location=program.getStringLiteral(info,String.valueOf(lastLine=info.getStartLine()));
  if (recordFileNames) {
    JsStringLiteral stringLit=program.getStringLiteral(info,baseName(lastFile=info.getFileName()) + ""String_Node_Str"");
    location=new JsBinaryOperation(info,JsBinaryOperator.ADD,stringLit,location);
  }
  JsArrayAccess access=new JsArrayAccess(info,lineNumbers.makeRef(info),stackIndexRef(info));
  JsBinaryOperation asg=new JsBinaryOperation(info,JsBinaryOperator.ASG,access,location);
  JsBinaryOperation comma=new JsBinaryOperation(info,JsBinaryOperator.COMMA,asg,x);
  ctx.replaceMe(comma);
}","private void record(JsExpression x,JsContext<JsExpression> ctx){
  if (ctx.isLvalue()) {
    return;
  }
 else   if (nodesInRefContext.contains(x)) {
    return;
  }
 else   if (x.getSourceInfo().getStartLine() == lastLine && (!recordFileNames || x.getSourceInfo().getFileName().equals(lastFile))) {
    return;
  }
  SourceInfo info=x.getSourceInfo().makeChild(JsStackEmulator.class,""String_Node_Str"");
  JsExpression location=program.getStringLiteral(info,String.valueOf(lastLine=info.getStartLine()));
  if (recordFileNames) {
    JsStringLiteral stringLit=program.getStringLiteral(info,baseName(lastFile=info.getFileName()) + ""String_Node_Str"");
    location=new JsBinaryOperation(info,JsBinaryOperator.ADD,stringLit,location);
  }
  JsArrayAccess access=new JsArrayAccess(info,lineNumbers.makeRef(info),stackIndexRef(info));
  JsBinaryOperation asg=new JsBinaryOperation(info,JsBinaryOperator.ASG,access,location);
  JsBinaryOperation comma=new JsBinaryOperation(info,JsBinaryOperator.COMMA,asg,x);
  ctx.replaceMe(comma);
}",0.969454181271908
54220,"public void traverse(JsVisitor v,JsContext<JsStatement> ctx){
  if (v.visit(this,ctx)) {
    if (iterExpr != null) {
      iterExpr=v.accept(iterExpr);
    }
    objExpr=v.accept(objExpr);
    body=v.accept(body);
  }
  v.endVisit(this,ctx);
}","public void traverse(JsVisitor v,JsContext<JsStatement> ctx){
  if (v.visit(this,ctx)) {
    if (iterExpr != null) {
      iterExpr=v.acceptLvalue(iterExpr);
    }
    objExpr=v.accept(objExpr);
    body=v.accept(body);
  }
  v.endVisit(this,ctx);
}",0.9878048780487804
54221,"/** 
 * Closes the menu bar.
 * @deprecated Use {@link #addCloseHandler(CloseHandler)} instead
 */
@Deprecated public void onPopupClosed(PopupPanel sender,boolean autoClosed){
  if (autoClosed) {
    closeAllParents();
  }
  onHide(autoClosed);
  CloseEvent.fire(MenuBar.this,sender);
  shownChildMenu=null;
  popup=null;
  if (parentMenu != null && parentMenu.popup != null) {
    parentMenu.popup.setPreviewingAllNativeEvents(true);
  }
}","/** 
 * Closes the menu bar.
 * @deprecated Use {@link #addCloseHandler(CloseHandler)} instead
 */
@Deprecated public void onPopupClosed(PopupPanel sender,boolean autoClosed){
  if (autoClosed) {
    closeAllParents();
  }
  onHide(!autoClosed);
  CloseEvent.fire(MenuBar.this,sender);
  shownChildMenu=null;
  popup=null;
  if (parentMenu != null && parentMenu.popup != null) {
    parentMenu.popup.setPreviewingAllNativeEvents(true);
  }
}",0.9988649262202044
54222,"/** 
 * Set the bind address for the web server socket. <p> Will be called before   {@link #start(TreeLogger,int,File)}, if at all. If not called, the SCL should listen on all addresses.
 * @param bindAddress host name or IP address, suitable for use with{@link InetAddress#getByName(String)}
 */
public void setBindAddress(String bindAddress){
}","/** 
 * Set the bind address for the web server socket. <p> Will be called before   {@link #start(TreeLogger,int,File)}, if at all. If not called, the SCL should listen on all addresses.
 * @param bindAddress host name or IP address, suitable for use with{@link java.net.InetAddress#getByName(String)}
 */
public void setBindAddress(String bindAddress){
}",0.9871611982881596
54223,"/** 
 * Extract the module's base path from the current request.
 * @return the module's base path, modulo protocol and host, as reported by{@link com.google.gwt.core.client.GWT#getModuleBaseURL()} or<code>null</code> if the request did not contain the {@value com.google.gwt.user.client.rpc.RpcRequestBuilder#MODULE_BASE_HEADER} header
 */
protected final String getRequestModuleBasePath(){
  try {
    String header=getThreadLocalRequest().getHeader(MODULE_BASE_HEADER);
    if (header == null) {
      return null;
    }
    return new URL(header).getPath();
  }
 catch (  MalformedURLException e) {
    return null;
  }
}","/** 
 * Extract the module's base path from the current request.
 * @return the module's base path, modulo protocol and host, as reported by{@link com.google.gwt.core.client.GWT#getModuleBaseURL()} or<code>null</code> if the request did not contain the {@value com.google.gwt.user.client.rpc.RpcRequestBuilder#MODULE_BASE_HEADER} header
 */
protected final String getRequestModuleBasePath(){
  try {
    String header=getThreadLocalRequest().getHeader(MODULE_BASE_HEADER);
    if (header == null) {
      return null;
    }
    String path=new URL(header).getPath();
    String contextPath=getThreadLocalRequest().getContextPath();
    if (!path.startsWith(contextPath)) {
      return null;
    }
    return path.substring(contextPath.length());
  }
 catch (  MalformedURLException e) {
    return null;
  }
}",0.8613240418118467
54224,"/** 
 * This method treats arrays in a special way.
 */
private static Class<?> computeHasCustomFieldSerializer(Class<?> instanceType){
  assert(instanceType != null);
  String qualifiedTypeName=instanceType.getName();
  ClassLoader classLoader=SerializabilityUtil.class.getClassLoader();
  String simpleSerializerName=qualifiedTypeName + ""String_Node_Str"";
  Class<?> customSerializer=getCustomFieldSerializer(classLoader,simpleSerializerName);
  if (customSerializer != null) {
    return customSerializer;
  }
  Class<?> customSerializerClass=getCustomFieldSerializer(classLoader,JRE_SERIALIZER_PACKAGE + ""String_Node_Str"" + simpleSerializerName);
  if (customSerializerClass != null) {
    return customSerializerClass;
  }
  return null;
}","/** 
 * This method treats arrays in a special way.
 */
private static Class<?> computeHasCustomFieldSerializer(Class<?> instanceType){
  assert(instanceType != null);
  String qualifiedTypeName=instanceType.getName();
  ClassLoader classLoader=GWT.isClient() ? SerializabilityUtil.class.getClassLoader() : Thread.currentThread().getContextClassLoader();
  String simpleSerializerName=qualifiedTypeName + ""String_Node_Str"";
  Class<?> customSerializer=getCustomFieldSerializer(classLoader,simpleSerializerName);
  if (customSerializer != null) {
    return customSerializer;
  }
  Class<?> customSerializerClass=getCustomFieldSerializer(classLoader,JRE_SERIALIZER_PACKAGE + ""String_Node_Str"" + simpleSerializerName);
  if (customSerializerClass != null) {
    return customSerializerClass;
  }
  return null;
}",0.9575289575289576
54225,"public void process(CompilationUnitBuilder builder,CompilationUnitDeclaration cud,List<CompiledClass> compiledClasses){
  Map<AbstractMethodDeclaration,JsniMethod> jsniMethods=JsniCollector.collectJsniMethods(cud,builder.getSource(),jsProgram);
  final Set<String> jsniDeps=new HashSet<String>();
  JsniChecker.check(cud,jsniMethods,new JsniChecker.TypeResolver(){
    public ReferenceBinding resolveType(    String typeName){
      ReferenceBinding resolveType=compiler.resolveType(typeName);
      if (resolveType != null) {
        String fileName=String.valueOf(resolveType.getFileName());
        jsniDeps.add(fileName);
      }
      return resolveType;
    }
  }
);
  JSORestrictionsChecker.check(jsoState,cud);
  ArtificialRescueChecker.check(cud,builder.isGenerated());
  BinaryTypeReferenceRestrictionsChecker.check(cud);
  CompilationUnitInvalidator.reportErrors(logger,cud,builder.getSource());
  Set<ContentId> dependencies=compiler.computeDependencies(cud,jsniDeps);
  CompilationUnit unit=builder.build(compiledClasses,dependencies,jsniMethods.values(),cud.compilationResult().getProblems());
  if (cud.compilationResult().hasErrors()) {
    unit=new ErrorCompilationUnit(unit);
  }
 else {
    addValidUnit(unit);
    ContentId contentId=builder.getContentId();
    unitCache.put(contentId,unit);
    if (builder instanceof ResourceCompilationUnitBuilder) {
      ResourceCompilationUnitBuilder rcub=(ResourceCompilationUnitBuilder)builder;
      ResourceTag resourceTag=new ResourceTag(rcub.getLastModifed(),contentId);
      resourceContentCache.put(builder.getLocation(),resourceTag);
      keepAliveLatestVersion.put(resourceTag,unit);
    }
 else     if (builder instanceof GeneratedCompilationUnitBuilder) {
      keepAliveRecentlyGenerated.put(unit.getTypeName(),unit);
    }
  }
  resultUnits.put(unit.getTypeName(),unit);
}","public void process(CompilationUnitBuilder builder,CompilationUnitDeclaration cud,List<CompiledClass> compiledClasses){
  Map<AbstractMethodDeclaration,JsniMethod> jsniMethods=JsniCollector.collectJsniMethods(cud,builder.getSource(),jsProgram);
  final Set<String> jsniDeps=new HashSet<String>();
  JsniChecker.check(cud,jsniMethods,new JsniChecker.TypeResolver(){
    public ReferenceBinding resolveType(    String typeName){
      ReferenceBinding resolveType=compiler.resolveType(typeName);
      if (resolveType != null) {
        String fileName=String.valueOf(resolveType.getFileName());
        jsniDeps.add(fileName);
      }
      return resolveType;
    }
  }
);
  JSORestrictionsChecker.check(jsoState,cud);
  ArtificialRescueChecker.check(cud,builder.isGenerated());
  BinaryTypeReferenceRestrictionsChecker.check(cud);
  MethodArgNamesLookup methodArgs=MethodParamCollector.collect(cud);
  CompilationUnitInvalidator.reportErrors(logger,cud,builder.getSource());
  Set<ContentId> dependencies=compiler.computeDependencies(cud,jsniDeps);
  CompilationUnit unit=builder.build(compiledClasses,dependencies,jsniMethods.values(),methodArgs,cud.compilationResult().getProblems());
  if (cud.compilationResult().hasErrors()) {
    unit=new ErrorCompilationUnit(unit);
  }
 else {
    addValidUnit(unit);
    ContentId contentId=builder.getContentId();
    unitCache.put(contentId,unit);
    if (builder instanceof ResourceCompilationUnitBuilder) {
      ResourceCompilationUnitBuilder rcub=(ResourceCompilationUnitBuilder)builder;
      ResourceTag resourceTag=new ResourceTag(rcub.getLastModifed(),contentId);
      resourceContentCache.put(builder.getLocation(),resourceTag);
      keepAliveLatestVersion.put(resourceTag,unit);
    }
 else     if (builder instanceof GeneratedCompilationUnitBuilder) {
      keepAliveRecentlyGenerated.put(unit.getTypeName(),unit);
    }
  }
  resultUnits.put(unit.getTypeName(),unit);
}",0.9788135593220338
54226,"public GeneratedCompilationUnit(GeneratedUnit generatedUnit,List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,CategorizedProblem[] problems){
  super(compiledClasses,dependencies,jsniMethods,problems);
  this.generatedUnit=generatedUnit;
}","public GeneratedCompilationUnit(GeneratedUnit generatedUnit,List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,MethodArgNamesLookup methodArgs,CategorizedProblem[] problems){
  super(compiledClasses,dependencies,jsniMethods,methodArgs,problems);
  this.generatedUnit=generatedUnit;
}",0.9327073552425664
54227,"@Override public boolean isSuperSource(){
  return false;
}","@Deprecated @Override public boolean isSuperSource(){
  return false;
}",0.9076923076923076
54228,"public CompilationUnit build(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,CategorizedProblem[] problems){
  source=null;
  return makeUnit(compiledClasses,dependencies,jsniMethods,problems);
}","public CompilationUnit build(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,MethodArgNamesLookup methodArgs,CategorizedProblem[] problems){
  source=null;
  return makeUnit(compiledClasses,dependencies,jsniMethods,methodArgs,problems);
}",0.9225225225225224
54229,"protected abstract CompilationUnit makeUnit(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,CategorizedProblem[] errors);","protected abstract CompilationUnit makeUnit(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,MethodArgNamesLookup methodArgs,CategorizedProblem[] errors);",0.9191919191919192
54230,"public CompilationUnitImpl(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,CategorizedProblem[] problems){
  this.exposedCompiledClasses=Lists.normalizeUnmodifiable(compiledClasses);
  this.dependencies=dependencies;
  this.jsniMethods=Lists.create(jsniMethods.toArray(new JsniMethod[jsniMethods.size()]));
  this.problems=problems;
  for (  CompiledClass cc : compiledClasses) {
    cc.initUnit(this);
  }
}","public CompilationUnitImpl(List<CompiledClass> compiledClasses,Set<ContentId> dependencies,Collection<? extends JsniMethod> jsniMethods,MethodArgNamesLookup methodArgs,CategorizedProblem[] problems){
  this.exposedCompiledClasses=Lists.normalizeUnmodifiable(compiledClasses);
  this.dependencies=dependencies;
  this.jsniMethods=Lists.create(jsniMethods.toArray(new JsniMethod[jsniMethods.size()]));
  this.methodArgs=methodArgs;
  this.problems=problems;
  for (  CompiledClass cc : compiledClasses) {
    cc.initUnit(this);
  }
}",0.938
54231,"Set<ContentId> getDependencies(){
  return dependencies;
}","@Override Set<ContentId> getDependencies(){
  return dependencies;
}",0.9206349206349206
54232,"public List<JsniMethod> getJsniMethods(){
  return jsniMethods;
}","@Override public List<JsniMethod> getJsniMethods(){
  return jsniMethods;
}",0.9285714285714286
54233,"/** 
 * Returns all contained classes.
 */
Collection<CompiledClass> getCompiledClasses(){
  return exposedCompiledClasses;
}","/** 
 * Returns all contained classes.
 */
@Override Collection<CompiledClass> getCompiledClasses(){
  return exposedCompiledClasses;
}",0.9615384615384616
54234,"CategorizedProblem[] getProblems(){
  return problems;
}","@Override CategorizedProblem[] getProblems(){
  return problems;
}",0.918032786885246
54235,"public boolean isCompiled(){
  return false;
}","@Override public boolean isCompiled(){
  return false;
}",0.9019607843137256
54236,"public long getLastModified(){
  return unit.getLastModified();
}","@Override public long getLastModified(){
  return unit.getLastModified();
}",0.9285714285714286
54237,"public boolean isSuperSource(){
  return unit.isSuperSource();
}","@Override @Deprecated public boolean isSuperSource(){
  return unit.isSuperSource();
}",0.8533333333333334
54238,"public List<JsniMethod> getJsniMethods(){
  return unit.getJsniMethods();
}","@Override public List<JsniMethod> getJsniMethods(){
  return unit.getJsniMethods();
}",0.9375
54239,"public boolean isGenerated(){
  return unit.isGenerated();
}","@Override @Deprecated public boolean isGenerated(){
  return unit.isGenerated();
}",0.8450704225352113
54240,"public boolean isError(){
  return true;
}","@Override public boolean isError(){
  return true;
}",0.8936170212765957
54241,"public String getDisplayLocation(){
  return unit.getDisplayLocation();
}","@Override public String getDisplayLocation(){
  return unit.getDisplayLocation();
}",0.935897435897436
54242,"public String getSource(){
  return unit.getSource();
}","@Override @Deprecated public String getSource(){
  return unit.getSource();
}",0.8333333333333334
54243,"public String getTypeName(){
  return unit.getTypeName();
}","@Override public String getTypeName(){
  return unit.getTypeName();
}",0.921875
54244,"public boolean isCompiled(){
  return false;
}","@Override public boolean isCompiled(){
  return false;
}",0.9019607843137256
54245,"public long getLastModified(){
  return unit.getLastModified();
}","@Override public long getLastModified(){
  return unit.getLastModified();
}",0.9285714285714286
54246,"public boolean isSuperSource(){
  return unit.isSuperSource();
}","@Override @Deprecated public boolean isSuperSource(){
  return unit.isSuperSource();
}",0.8533333333333334
54247,"public List<JsniMethod> getJsniMethods(){
  return unit.getJsniMethods();
}","@Override public List<JsniMethod> getJsniMethods(){
  return unit.getJsniMethods();
}",0.9375
54248,"public boolean isGenerated(){
  return unit.isGenerated();
}","@Override @Deprecated public boolean isGenerated(){
  return unit.isGenerated();
}",0.8450704225352113
54249,"public boolean isError(){
  return false;
}","@Override public boolean isError(){
  return false;
}",0.8958333333333334
54250,"public String getDisplayLocation(){
  return unit.getDisplayLocation();
}","@Override public String getDisplayLocation(){
  return unit.getDisplayLocation();
}",0.935897435897436
54251,"public String getSource(){
  return unit.getSource();
}","@Override @Deprecated public String getSource(){
  return unit.getSource();
}",0.8333333333333334
54252,"public String getTypeName(){
  return unit.getTypeName();
}","@Override public String getTypeName(){
  return unit.getTypeName();
}",0.921875
54253,"public final void execute(){
  if (canceled) {
    return;
  }
  scheduled=false;
  doBeforeLayout();
  layout.layout(duration,new Layout.AnimationCallback(){
    public void onAnimationComplete(){
      if (callback != null) {
        callback.onAnimationComplete();
      }
    }
    public void onLayout(    Layer layer,    double progress){
      Widget child=(Widget)layer.getUserObject();
      if (child instanceof RequiresResize) {
        ((RequiresResize)child).onResize();
      }
      if (callback != null) {
        callback.onLayout(layer,progress);
      }
    }
  }
);
}","public final void execute(){
  scheduled=false;
  if (canceled) {
    return;
  }
  doBeforeLayout();
  layout.layout(duration,new Layout.AnimationCallback(){
    public void onAnimationComplete(){
      if (callback != null) {
        callback.onAnimationComplete();
      }
    }
    public void onLayout(    Layer layer,    double progress){
      Widget child=(Widget)layer.getUserObject();
      if (child instanceof RequiresResize) {
        ((RequiresResize)child).onResize();
      }
      if (callback != null) {
        callback.onLayout(layer,progress);
      }
    }
  }
);
}",0.9420783645655876
54254,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(AsyncProxyTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(CalendarUtilTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FileUploadTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(FormPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HorizontalSplitPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(TreeItemTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(VerticalSplitPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  suite.addTestSuite(RootPanelTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(AsyncProxyTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(CalendarUtilTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FileUploadTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(FormPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HorizontalSplitPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LayoutPanelTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(TreeItemTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(VerticalSplitPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  suite.addTestSuite(RootPanelTest.class);
  return suite;
}",0.9936323758313288
54255,"private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}","private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}",0.9760403530895334
54256,"/** 
 * Instructs the writer to initialize the field with a specific contructor invocaction, instead of the default GWT.create call.
 */
public void setFieldInitializerAsConstructor(String fieldName,JClassType type,String... args){
  setFieldInitializer(fieldName,formatCode(""String_Node_Str"",type.getQualifiedSourceName(),asCommaSeparatedList(args)));
}","/** 
 * Instructs the writer to initialize the field with a specific contructor invocaction, instead of the default GWT.create call.
 * @param fieldName the field to intialize
 * @param type the type of the field
 * @param arguments to the constructor call
 */
public void setFieldInitializerAsConstructor(String fieldName,JClassType type,String... args){
  setFieldInitializer(fieldName,formatCode(""String_Node_Str"",type.getQualifiedSourceName(),asCommaSeparatedList(args)));
}",0.8509615384615384
54257,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(FieldWriterOfGeneratedCssResourceTest.class);
  suite.addTestSuite(GwtResourceEntityResolverTest.class);
  suite.addTestSuite(HandlerEvaluatorTest.class);
  suite.addTestSuite(TokenatorTest.class);
  suite.addTestSuite(XMLElementTest.class);
  suite.addTestSuite(OwnerClassTest.class);
  suite.addTestSuite(OwnerFieldClassTest.class);
  suite.addTestSuite(OwnerFieldTest.class);
  suite.addTestSuite(CssNameConverterTest.class);
  suite.addTestSuite(IntAttributeParserTest.class);
  suite.addTestSuite(FieldReferenceConverterTest.class);
  suite.addTestSuite(StrictAttributeParserTest.class);
  suite.addTestSuite(StringAttributeParserTest.class);
  suite.addTestSuite(LengthAttributeParserTest.class);
  suite.addTestSuite(DialogBoxParserTest.class);
  suite.addTestSuite(DockLayoutPanelParserTest.class);
  suite.addTestSuite(IsEmptyParserTest.class);
  suite.addTestSuite(LayoutPanelParserTest.class);
  suite.addTestSuite(StackLayoutPanelParserTest.class);
  suite.addTestSuite(TabLayoutPanelParserTest.class);
  suite.addTestSuite(UIObjectParserTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(FieldWriterOfGeneratedCssResourceTest.class);
  suite.addTestSuite(GwtResourceEntityResolverTest.class);
  suite.addTestSuite(HandlerEvaluatorTest.class);
  suite.addTestSuite(TokenatorTest.class);
  suite.addTestSuite(XMLElementTest.class);
  suite.addTestSuite(OwnerClassTest.class);
  suite.addTestSuite(OwnerFieldClassTest.class);
  suite.addTestSuite(OwnerFieldTest.class);
  suite.addTestSuite(CssNameConverterTest.class);
  suite.addTestSuite(IntAttributeParserTest.class);
  suite.addTestSuite(FieldReferenceConverterTest.class);
  suite.addTestSuite(StrictAttributeParserTest.class);
  suite.addTestSuite(StringAttributeParserTest.class);
  suite.addTestSuite(LengthAttributeParserTest.class);
  suite.addTestSuite(DialogBoxParserTest.class);
  suite.addTestSuite(DockLayoutPanelParserTest.class);
  suite.addTestSuite(ImageParserTest.class);
  suite.addTestSuite(IsEmptyParserTest.class);
  suite.addTestSuite(LayoutPanelParserTest.class);
  suite.addTestSuite(StackLayoutPanelParserTest.class);
  suite.addTestSuite(TabLayoutPanelParserTest.class);
  suite.addTestSuite(UIObjectParserTest.class);
  return suite;
}",0.9813045284586622
54258,"/** 
 * @return a pale reflection of com.google.gwt.user.ui, plus{@link JavaResourceBase#getStandardResources}
 */
public static Set<Resource> getUiResources(){
  Set<Resource> rtn=new HashSet<Resource>(Arrays.asList(JavaResourceBase.getStandardResources()));
  rtn.add(BUTTON);
  rtn.add(CLICK_EVENT);
  rtn.add(CLICK_HANDLER);
  rtn.add(DIALOG_BOX);
  rtn.add(DOCK_LAYOUT_PANEL);
  rtn.add(EVENT_HANDLER);
  rtn.add(GWT_EVENT);
  rtn.add(HANDLER_REGISTRATION);
  rtn.add(HAS_CLICK_HANDLERS);
  rtn.add(HAS_HORIZONTAL_ALIGNMENT);
  rtn.add(HAS_VERTICAL_ALIGNMENT);
  rtn.add(LABEL);
  rtn.add(LAYOUT_PANEL);
  rtn.add(MOUSE_OVER_EVENT);
  rtn.add(MOUSE_OVER_HANDLER);
  rtn.add(SPLIT_LAYOUT_PANEL);
  rtn.add(STACK_LAYOUT_PANEL);
  rtn.add(STYLE);
  rtn.add(TAB_LAYOUT_PANEL);
  rtn.add(UI_OBJECT);
  rtn.add(UI_BINDER);
  rtn.add(UI_FACTORY);
  rtn.add(WIDGET);
  return rtn;
}","/** 
 * @return a pale reflection of com.google.gwt.user.ui, plus{@link JavaResourceBase#getStandardResources}
 */
public static Set<Resource> getUiResources(){
  Set<Resource> rtn=new HashSet<Resource>(Arrays.asList(JavaResourceBase.getStandardResources()));
  rtn.add(BUTTON);
  rtn.add(CLICK_EVENT);
  rtn.add(CLICK_HANDLER);
  rtn.add(DIALOG_BOX);
  rtn.add(DOCK_LAYOUT_PANEL);
  rtn.add(EVENT_HANDLER);
  rtn.add(GWT_EVENT);
  rtn.add(IMAGE);
  rtn.add(IMAGE_RESOURCE);
  rtn.add(HANDLER_REGISTRATION);
  rtn.add(HAS_CLICK_HANDLERS);
  rtn.add(HAS_HORIZONTAL_ALIGNMENT);
  rtn.add(HAS_VERTICAL_ALIGNMENT);
  rtn.add(LABEL);
  rtn.add(LAYOUT_PANEL);
  rtn.add(MOUSE_OVER_EVENT);
  rtn.add(MOUSE_OVER_HANDLER);
  rtn.add(SPLIT_LAYOUT_PANEL);
  rtn.add(STACK_LAYOUT_PANEL);
  rtn.add(STYLE);
  rtn.add(TAB_LAYOUT_PANEL);
  rtn.add(UI_OBJECT);
  rtn.add(UI_BINDER);
  rtn.add(UI_FACTORY);
  rtn.add(WIDGET);
  return rtn;
}",0.9750415973377704
54259,"public void testImageResourceInImageWidget(){
  assertEquals(widgetUi.prettyImage.getWidth(),widgetUi.babyWidget.getOffsetWidth());
  assertEquals(widgetUi.prettyImage.getHeight(),widgetUi.babyWidget.getOffsetHeight());
  assertEquals(widgetUi.prettyImage.getTop(),widgetUi.babyWidget.getOriginTop());
  assertEquals(widgetUi.prettyImage.getLeft(),widgetUi.babyWidget.getOriginLeft());
}","public void testImageResourceInImageWidget(){
  ImageResource resource=widgetUi.prettyImage;
  Image widget=widgetUi.babyWidget;
  assertEquals(resource.getWidth(),widget.getOffsetWidth());
  assertEquals(resource.getHeight(),widget.getOffsetHeight());
  assertEquals(resource.getTop(),widget.getOriginTop());
  assertEquals(resource.getLeft(),widget.getOriginLeft());
  assertEquals(""String_Node_Str"",widget.getAltText());
  assertEquals(""String_Node_Str"",widget.getStyleName());
}",0.4579976985040276
54260,"public void parse(XMLElement elem,String fieldName,JClassType type,UiBinderWriter writer) throws UnableToCompleteException {
  String debugId=elem.consumeStringAttribute(""String_Node_Str"",null);
  if (null != debugId) {
    writer.addStatement(""String_Node_Str"",fieldName,debugId);
  }
  String[] styleNames=elem.consumeStringArrayAttribute(""String_Node_Str"");
  for (  String s : styleNames) {
    writer.addStatement(""String_Node_Str"",fieldName,s);
  }
  styleNames=elem.consumeStringArrayAttribute(""String_Node_Str"");
  for (  String s : styleNames) {
    writer.addStatement(""String_Node_Str"",fieldName,s);
  }
}","public void parse(XMLElement elem,String fieldName,JClassType type,UiBinderWriter writer) throws UnableToCompleteException {
  String debugId=elem.consumeStringAttribute(""String_Node_Str"",null);
  if (null != debugId) {
    writer.addStatement(""String_Node_Str"",fieldName,debugId);
  }
  String styleName=elem.consumeStringAttribute(""String_Node_Str"",null);
  String stylePrimaryName=elem.consumeStringAttribute(""String_Node_Str"",null);
  if (null != styleName && null != stylePrimaryName) {
    writer.die(""String_Node_Str"" + ""String_Node_Str"",elem);
  }
  if (null != styleName) {
    writer.addStatement(""String_Node_Str"",fieldName,styleName);
  }
  if (null != stylePrimaryName) {
    writer.addStatement(""String_Node_Str"",fieldName,stylePrimaryName);
  }
  String[] extraStyleNames=elem.consumeStringArrayAttribute(""String_Node_Str"");
  for (  String s : extraStyleNames) {
    writer.addStatement(""String_Node_Str"",fieldName,s);
  }
  extraStyleNames=elem.consumeStringArrayAttribute(""String_Node_Str"");
  for (  String s : extraStyleNames) {
    writer.addStatement(""String_Node_Str"",fieldName,s);
  }
}",0.709154113557358
54261,"private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}","private void registerParsers(){
  addElementParser(""String_Node_Str"",""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
  addWidgetParser(""String_Node_Str"");
}",0.9760403530895334
54262,"public void testHappy() throws UnableToCompleteException, SAXException, IOException {
  StringBuffer b=new StringBuffer();
  b.append(""String_Node_Str"");
  b.append(""String_Node_Str"");
  b.append(""String_Node_Str"");
  String[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  tester.parse(b.toString());
  Iterator<String> i=tester.writer.statements.iterator();
  for (  String e : expected) {
    assertEquals(e,i.next());
  }
  assertFalse(i.hasNext());
  assertNull(tester.logger.died);
}","public void testHappy() throws UnableToCompleteException, SAXException, IOException {
  StringBuffer b=new StringBuffer();
  b.append(""String_Node_Str"" + ""String_Node_Str"");
  b.append(""String_Node_Str"");
  b.append(""String_Node_Str"");
  String[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  tester.parse(b.toString());
  Iterator<String> i=tester.writer.statements.iterator();
  for (  String e : expected) {
    assertEquals(e,i.next());
  }
  assertFalse(i.hasNext());
  assertNull(tester.logger.died);
}",0.9683860232945092
54263,"@Override public void gwtTearDown() throws Exception {
  RootPanel.get().clear();
  super.gwtTearDown();
}","@Override public void gwtTearDown() throws Exception {
  domUi.root.getParentElement().removeChild(domUi.root);
  RootPanel.get().clear();
  super.gwtTearDown();
}",0.7881040892193308
54264,"public void testAddStyleNamesAndDebugId(){
  Label l=widgetUi.lblDebugId;
  assertEquals(""String_Node_Str"",l.getElement().getId());
  WidgetBasedUiExternalResources resources=GWT.create(WidgetBasedUiExternalResources.class);
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(resources.style().prettyText()));
}","public void testAddStyleNamesAndDebugId(){
  Label l=widgetUi.lblDebugId;
  assertEquals(""String_Node_Str"",l.getElement().getId());
  assertEquals(""String_Node_Str"",l.getStylePrimaryName());
  WidgetBasedUiExternalResources resources=GWT.create(WidgetBasedUiExternalResources.class);
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str""));
  assertTrue(l.getStyleName().contains(""String_Node_Str"" + resources.style().prettyText()));
}",0.9317199654278306
54265,"private void writeClassOpen(IndentedWriter w){
  w.write(""String_Node_Str"",implClassName,uiRootType.getName(),uiOwnerType.getName(),baseClass.getName());
  w.indent();
}","private void writeClassOpen(IndentedWriter w){
  w.write(""String_Node_Str"",implClassName,uiRootType.getParameterizedQualifiedSourceName(),uiOwnerType.getParameterizedQualifiedSourceName(),baseClass.getParameterizedQualifiedSourceName());
  w.indent();
}",0.8009478672985783
54266,"/** 
 * Writes the UiBinder's source.
 */
private void writeBinder(IndentedWriter w,String rootField) throws UnableToCompleteException {
  writePackage(w);
  writeImports(w);
  w.newline();
  writeClassOpen(w);
  writeStatics(w);
  w.newline();
  w.write(""String_Node_Str"",uiRootType.getName(),uiOwnerType.getName());
  w.indent();
  w.newline();
  writeGwtFields(w);
  w.newline();
  writeAddedStatements(w);
  w.newline();
  writeInitStatements(w);
  w.newline();
  writeHandlers(w);
  w.newline();
  writeOwnerFieldSetters(w);
  writeCssInjectors(w);
  w.write(""String_Node_Str"",rootField);
  w.outdent();
  w.write(""String_Node_Str"");
  w.outdent();
  w.write(""String_Node_Str"");
}","/** 
 * Writes the UiBinder's source.
 */
private void writeBinder(IndentedWriter w,String rootField) throws UnableToCompleteException {
  writePackage(w);
  writeImports(w);
  w.newline();
  writeClassOpen(w);
  writeStatics(w);
  w.newline();
  w.write(""String_Node_Str"",uiRootType.getParameterizedQualifiedSourceName(),uiOwnerType.getParameterizedQualifiedSourceName());
  w.indent();
  w.newline();
  writeGwtFields(w);
  w.newline();
  writeAddedStatements(w);
  w.newline();
  writeInitStatements(w);
  w.newline();
  writeHandlers(w);
  w.newline();
  writeOwnerFieldSetters(w);
  writeCssInjectors(w);
  w.write(""String_Node_Str"",rootField);
  w.outdent();
  w.write(""String_Node_Str"");
  w.outdent();
  w.write(""String_Node_Str"");
}",0.9607293127629734
54267,"private void doLayout(){
  int left=0, top=0, right=0, bottom=0;
  for (  Widget child : getChildren()) {
    LayoutData data=(LayoutData)child.getLayoutData();
    Layer layer=data.layer;
switch (data.direction) {
case NORTH:
      layer.setLeftRight(left,unit,right,unit);
    layer.setTopHeight(top,unit,data.size,unit);
  top+=data.size;
break;
case SOUTH:
layer.setLeftRight(left,unit,right,unit);
layer.setBottomHeight(bottom,unit,data.size,unit);
bottom+=data.size;
break;
case WEST:
layer.setTopBottom(top,unit,bottom,unit);
layer.setLeftWidth(left,unit,data.size,unit);
left+=data.size;
break;
case EAST:
layer.setTopBottom(top,unit,bottom,unit);
layer.setRightWidth(right,unit,data.size,unit);
right+=data.size;
break;
case CENTER:
layer.setLeftRight(left,unit,right,unit);
layer.setTopBottom(top,unit,bottom,unit);
break;
}
}
}","private void doLayout(){
  double left=0, top=0, right=0, bottom=0;
  for (  Widget child : getChildren()) {
    LayoutData data=(LayoutData)child.getLayoutData();
    Layer layer=data.layer;
switch (data.direction) {
case NORTH:
      layer.setLeftRight(left,unit,right,unit);
    layer.setTopHeight(top,unit,data.size,unit);
  top+=data.size;
break;
case SOUTH:
layer.setLeftRight(left,unit,right,unit);
layer.setBottomHeight(bottom,unit,data.size,unit);
bottom+=data.size;
break;
case WEST:
layer.setTopBottom(top,unit,bottom,unit);
layer.setLeftWidth(left,unit,data.size,unit);
left+=data.size;
break;
case EAST:
layer.setTopBottom(top,unit,bottom,unit);
layer.setRightWidth(right,unit,data.size,unit);
right+=data.size;
break;
case CENTER:
layer.setLeftRight(left,unit,right,unit);
layer.setTopBottom(top,unit,bottom,unit);
break;
}
}
}",0.9946396664681358
54268,"/** 
 * Clear the opacity css property.
 */
public final void clearOpacity(){
  clearProperty(STYLE_OPACITY);
}","/** 
 * Clear the opacity css property.
 */
public final void clearOpacity(){
  DOMImpl.impl.cssClearOpacity(this);
}",0.8157894736842105
54269,"/** 
 * Set the opacity css property.
 */
public final void setOpacity(double value){
  setProperty(STYLE_OPACITY,value + ""String_Node_Str"");
}","/** 
 * Set the opacity css property.
 */
public final void setOpacity(double value){
  DOMImpl.impl.cssSetOpacity(this,value);
}",0.7720588235294118
54270,"public Tab(Widget child){
  super(Document.get().createDivElement());
  getElement().appendChild(inner=Document.get().createDivElement());
  setWidget(child);
  setStyleName(""String_Node_Str"");
  inner.setClassName(""String_Node_Str"");
  getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
}","public Tab(Widget child){
  super(Document.get().createDivElement());
  getElement().appendChild(inner=Document.get().createDivElement());
  setWidget(child);
  setStyleName(""String_Node_Str"");
  inner.setClassName(""String_Node_Str"");
  getElement().getStyle().setFloat(Style.Float.LEFT);
}",0.8970099667774086
54271,"/** 
 * Checks whether the given method qualifies as a setter. This looks at the method qualifiers, name and return type, but not at the parameter types.
 * @param method the method to look at
 * @return whether it's a setter
 */
private boolean isSetterMethod(JMethod method){
  return method.isPublic() && !method.isStatic() && method.getName().startsWith(""String_Node_Str"")&& method.getReturnType() == JPrimitiveType.VOID;
}","/** 
 * Checks whether the given method qualifies as a setter. This looks at the method qualifiers, name and return type, but not at the parameter types.
 * @param method the method to look at
 * @return whether it's a setter
 */
private boolean isSetterMethod(JMethod method){
  return method.isPublic() && !method.isStatic() && method.getName().startsWith(""String_Node_Str"")&& method.getName().length() > 3 && method.getReturnType() == JPrimitiveType.VOID;
}",0.9627959413754228
54272,"/** 
 * Escapes '&', '<', '>', '""', and optionally ''' to their XML entity equivalents. The portion of the input string between start (inclusive) and end (exclusive) is scanned.  The output is appended to the given StringBuilder.
 * @param code the input String
 * @param start the first character position to scan.
 * @param end the character position following the last character to scan.
 * @param quoteApostrophe if true, the &apos; character is quoted as&amp;apos;
 * @param builder a StringBuilder to be appended with the output.
 */
public static void escapeXml(String code,int start,int end,boolean quoteApostrophe,StringBuilder builder){
  int lastIndex=0;
  int len=end - start;
  char[] c=new char[len];
  code.getChars(start,end,c,0);
  for (int i=0; i < len; i++) {
    if ((c[i] >= '\uD800') && (c[i] <= '\uDBFF')) {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
      break;
    }
 else     if ((c[i] >= '\uDC00') && (c[i] <= '\uDFFF')) {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
      break;
    }
 else     if (c[i] == '\0') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
      break;
    }
 else     if (c[i] == '\uffff') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
      break;
    }
 else     if (c[i] == '\ufffe') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '&') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '>') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '<') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '\""') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '\'') {
      if (quoteApostrophe) {
        builder.append(c,lastIndex,i - lastIndex);
        builder.append(""String_Node_Str"");
        lastIndex=i + 1;
      }
    }
  }
  builder.append(c,lastIndex,len - lastIndex);
}","/** 
 * Escapes '&', '<', '>', '""', and optionally ''' to their XML entity equivalents. The portion of the input string between start (inclusive) and end (exclusive) is scanned.  The output is appended to the given StringBuilder.
 * @param code the input String
 * @param start the first character position to scan.
 * @param end the character position following the last character to scan.
 * @param quoteApostrophe if true, the &apos; character is quoted as&amp;apos;
 * @param builder a StringBuilder to be appended with the output.
 */
public static void escapeXml(String code,int start,int end,boolean quoteApostrophe,StringBuilder builder){
  int lastIndex=0;
  int len=end - start;
  char[] c=new char[len];
  code.getChars(start,end,c,0);
  for (int i=0; i < len; i++) {
    if ((c[i] < '\u0020')) {
      builder.append(c,lastIndex,i - lastIndex);
      if (c[i] == '\u0000') {
        builder.append(""String_Node_Str"");
      }
 else       if (c[i] == '\u0009') {
        builder.append(""String_Node_Str"");
      }
 else       if (c[i] == '\n') {
        builder.append(""String_Node_Str"");
      }
 else       if (c[i] == '\r') {
        builder.append(""String_Node_Str"");
      }
 else {
        builder.append(""String_Node_Str"" + charToHex(c[i]) + ""String_Node_Str"");
      }
      lastIndex=i + 1;
    }
 else     if (((c[i] >= '\u007F') && (c[i] <= '\u0084')) || ((c[i] >= '\u0086') && (c[i] <= '\u009F')) || ((c[i] >= '\uD800') && (c[i] <= '\uDBFF'))|| ((c[i] >= '\uDC00') && (c[i] <= '\uDFFF'))|| ((c[i] >= '\uFDD0') && (c[i] <= '\uFDDF'))|| (c[i] == '\u00A0')|| (c[i] == '\uFFFF')|| (c[i] == '\uFFFE')) {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"" + charToHex(c[i]) + ""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '&') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '>') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '<') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '\""') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"");
      lastIndex=i + 1;
    }
 else     if (c[i] == '\'') {
      if (quoteApostrophe) {
        builder.append(c,lastIndex,i - lastIndex);
        builder.append(""String_Node_Str"");
        lastIndex=i + 1;
      }
    }
 else     if (c[i] > '\u007F') {
      builder.append(c,lastIndex,i - lastIndex);
      builder.append(""String_Node_Str"" + charToHex(c[i]) + ""String_Node_Str"");
      lastIndex=i + 1;
    }
  }
  builder.append(c,lastIndex,len - lastIndex);
}",0.4949782073147621
54273,"private static String escapeXml(String unescaped){
  String escaped=unescaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  escaped=escaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  escaped=escaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  escaped=escaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  escaped=escaped.replaceAll(""String_Node_Str"",""String_Node_Str"");
  return escaped;
}","private static String escapeXml(String unescaped){
  return SizeMapRecorder.escapeXml(unescaped);
}",0.2884990253411306
54274,"@Override @SuppressWarnings(""String_Node_Str"") public <T>T[] toArray(T[] a){
  Object[] result=super.toArray(a);
  for (int i=0, c=result.length; i < c; ++i) {
    result[i]=new UnmodifiableEntry<K,V>((Map.Entry<K,V>)result[i]);
  }
  return (T[])result;
}","@Override @SuppressWarnings(""String_Node_Str"") public <T>T[] toArray(T[] a){
  Object[] result=super.toArray(a);
  wrap(result,coll.size());
  return (T[])result;
}",0.7238095238095238
54275,"public int compare(Object o1,Object o2){
  String s1=(String)o1;
  String s2=(String)o2;
  return s2.compareTo(s1);
}","public int compare(String s1,String s2){
  return s2.compareTo(s1);
}",0.7204301075268817
54276,"public void testSort(){
  List a=createSortedList();
  Collections.reverse(a);
  Collections.sort(a);
  assertEquals(createSortedList(),a);
}","public void testSort(){
  List<String> a=createSortedList();
  Collections.reverse(a);
  Collections.sort(a);
  assertEquals(createSortedList(),a);
}",0.9724137931034482
54277,"public static List createSortedList(){
  ArrayList l=new ArrayList();
  l.add(""String_Node_Str"");
  l.add(""String_Node_Str"");
  l.add(""String_Node_Str"");
  return l;
}","public static List<String> createSortedList(){
  ArrayList<String> l=new ArrayList<String>();
  l.add(""String_Node_Str"");
  l.add(""String_Node_Str"");
  l.add(""String_Node_Str"");
  return l;
}",0.9329608938547486
54278,"/** 
 * Test Collections.binarySearch(List, Object, Comparator). Verify the following cases: empty List odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements null Comparator uses natural ordering
 */
public void testBinarySearchObjectComparator(){
  Comparator inverseSort=new Comparator(){
    public int compare(    Object o1,    Object o2){
      return ((Comparable)o2).compareTo(o1);
    }
  }
;
  List a1=new ArrayList();
  int ret=Collections.binarySearch(a1,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  List a2=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(-3,ret);
  ret=Collections.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(2,ret);
  List a3=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-5,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(0,ret);
  List a4=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a4,""String_Node_Str"",null);
  assertEquals(3,ret);
}","/** 
 * Test Collections.binarySearch(List, Object, Comparator). Verify the following cases: empty List odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements null Comparator uses natural ordering
 */
public void testBinarySearchObjectComparator(){
  Comparator<String> inverseSort=new Comparator<String>(){
    public int compare(    String o1,    String o2){
      return o2.compareTo(o1);
    }
  }
;
  List<String> a1=new ArrayList<String>();
  int ret=Collections.binarySearch(a1,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  List<String> a2=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(-3,ret);
  ret=Collections.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(2,ret);
  List<String> a3=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-5,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(0,ret);
  List<String> a4=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a4,""String_Node_Str"",null);
  assertEquals(3,ret);
}",0.9592233009708738
54279,"public void testReverse(){
  List a=createSortedList();
  Collections.reverse(a);
  Object[] x={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,a);
  List b=createRandomList();
  Collections.reverse(b);
  Collections.reverse(b);
  assertEquals(b,createRandomList());
}","public void testReverse(){
  List<String> a=createSortedList();
  Collections.reverse(a);
  Object[] x={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,a);
  List<Integer> b=createRandomList();
  Collections.reverse(b);
  Collections.reverse(b);
  assertEquals(b,createRandomList());
}",0.9718076285240465
54280,"public void testSortWithComparator(){
  Comparator x=new Comparator(){
    public int compare(    Object o1,    Object o2){
      String s1=(String)o1;
      String s2=(String)o2;
      return s2.compareTo(s1);
    }
  }
;
  List a=createSortedList();
  Collections.sort(a,x);
  Object[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(expected,a);
}","public void testSortWithComparator(){
  Comparator<String> x=new Comparator<String>(){
    public int compare(    String s1,    String s2){
      return s2.compareTo(s1);
    }
  }
;
  List<String> a=createSortedList();
  Collections.sort(a,x);
  Object[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(expected,a);
}",0.5504087193460491
54281,"public void testFill(){
  List a=createSortedList();
  Collections.fill(a,null);
  assertEquals(new Object[a.size()],a);
  List b=createRandomList();
  Collections.fill(b,null);
  assertEquals(new Object[b.size()],b);
}","public void testFill(){
  List<String> a=createSortedList();
  Collections.fill(a,null);
  assertEquals(new Object[a.size()],a);
  List<Integer> b=createRandomList();
  Collections.fill(b,null);
  assertEquals(new Object[b.size()],b);
}",0.9626373626373628
54282,"/** 
 * Test Collections.binarySearch(List, Object). Verify the following cases: empty List odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements
 */
public void testBinarySearchObject(){
  List a1=new ArrayList();
  int ret=Collections.binarySearch(a1,""String_Node_Str"");
  assertEquals(-1,ret);
  List a2=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a2,""String_Node_Str"");
  assertEquals(-2,ret);
  ret=Collections.binarySearch(a2,""String_Node_Str"");
  assertEquals(2,ret);
  List a3=new ArrayList(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(-5,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(-1,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(0,ret);
}","/** 
 * Test Collections.binarySearch(List, Object). Verify the following cases: empty List odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements
 */
public void testBinarySearchObject(){
  List<String> a1=new ArrayList<String>();
  int ret=Collections.binarySearch(a1,""String_Node_Str"");
  assertEquals(-1,ret);
  List<String> a2=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a2,""String_Node_Str"");
  assertEquals(-2,ret);
  ret=Collections.binarySearch(a2,""String_Node_Str"");
  assertEquals(2,ret);
  List<String> a3=new ArrayList<String>(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(-5,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(-1,ret);
  ret=Collections.binarySearch(a3,""String_Node_Str"");
  assertEquals(0,ret);
}",0.9765625
54283,"public static List createRandomList(){
  ArrayList l=new ArrayList();
  l.add(new Integer(5));
  l.add(new Integer(2));
  l.add(new Integer(3));
  l.add(new Integer(1));
  l.add(new Integer(4));
  return l;
}","public static List<Integer> createRandomList(){
  ArrayList<Integer> l=new ArrayList<Integer>();
  l.add(new Integer(5));
  l.add(new Integer(2));
  l.add(new Integer(3));
  l.add(new Integer(1));
  l.add(new Integer(4));
  return l;
}",0.9390519187358916
54284,"/** 
 * Formats Year field according to pattern specified. Javascript Date object seems incapable handling 1BC and year before. It can show you year 0 which does not exists. following we just keep consistent with javascript's toString method. But keep in mind those things should be unsupported.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatYear(StringBuffer buf,int count,Date date){
  int value=date.getYear() + JS_START_YEAR;
  if (value < 0) {
    value=-value;
  }
  if (count == 2) {
    zeroPaddingNumber(buf,value % 100,2);
  }
 else {
    buf.append(Integer.toString(value));
  }
}","/** 
 * Formats Year field according to pattern specified. Javascript Date object seems incapable handling 1BC and year before. It can show you year 0 which does not exists. following we just keep consistent with javascript's toString method. But keep in mind those things should be unsupported.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatYear(StringBuffer buf,int count,Date date){
  int value=date.getYear() + JS_START_YEAR;
  if (value < 0) {
    value=-value;
  }
  if (count == 2) {
    zeroPaddingNumber(buf,value % 100,2);
  }
 else {
    buf.append(value);
  }
}",0.9817232375979112
54285,"/** 
 * Formats Fractional seconds field according to pattern specified.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatFractionalSeconds(StringBuffer buf,int count,Date date){
  long time=date.getTime();
  int value;
  if (time < 0) {
    value=1000 - (int)(-time % 1000);
  }
 else {
    value=(int)(time % 1000);
  }
  if (count == 1) {
    value=(value + 50) / 100;
    buf.append(Integer.toString(value));
  }
 else   if (count == 2) {
    value=(value + 5) / 10;
    zeroPaddingNumber(buf,value,2);
  }
 else {
    zeroPaddingNumber(buf,value,3);
    if (count > 3) {
      zeroPaddingNumber(buf,0,count - 3);
    }
  }
}","/** 
 * Formats Fractional seconds field according to pattern specified.
 * @param buf where formatted string will be appended to
 * @param count number of time pattern char repeats; this controls how a fieldshould be formatted
 * @param date hold the date object to be formatted
 */
private void formatFractionalSeconds(StringBuffer buf,int count,Date date){
  long time=date.getTime();
  int value;
  if (time < 0) {
    value=1000 - (int)(-time % 1000);
  }
 else {
    value=(int)(time % 1000);
  }
  if (count == 1) {
    value=Math.min((value + 50) / 100,9);
    buf.append((char)('0' + value));
  }
 else   if (count == 2) {
    value=Math.min((value + 5) / 10,99);
    zeroPaddingNumber(buf,value,2);
  }
 else {
    zeroPaddingNumber(buf,value,3);
    if (count > 3) {
      zeroPaddingNumber(buf,0,count - 3);
    }
  }
}",0.9664838513101768
54286,"/** 
 * Formats a number with the specified minimum number of digits, using zero to fill the gap.
 * @param buf where zero padded string will be written to
 * @param value the number value being formatted
 * @param minWidth minimum width of the formatted string; zero will be paddedto reach this width
 */
private void zeroPaddingNumber(StringBuffer buf,int value,int minWidth){
  int b=NUMBER_BASE;
  for (int i=0; i < minWidth - 1; i++) {
    if (value < b) {
      buf.append('0');
    }
    b*=NUMBER_BASE;
  }
  buf.append(Integer.toString(value));
}","/** 
 * Formats a number with the specified minimum number of digits, using zero to fill the gap.
 * @param buf where zero padded string will be written to
 * @param value the number value being formatted
 * @param minWidth minimum width of the formatted string; zero will be paddedto reach this width
 */
private void zeroPaddingNumber(StringBuffer buf,int value,int minWidth){
  int b=NUMBER_BASE;
  for (int i=0; i < minWidth - 1; i++) {
    if (value < b) {
      buf.append('0');
    }
    b*=NUMBER_BASE;
  }
  buf.append(value);
}",0.9835164835164836
54287,"/** 
 * Adapted from  {@link com.google.gwt.dev.js.rhino.ScriptRuntime#escapeString(String)}. The difference is that we quote with either &quot; or &apos; depending on which one is used less inside the string.
 */
private void printStringLiteral(String value){
  char[] chars=value.toCharArray();
  final int n=chars.length;
  int quoteCount=0;
  int aposCount=0;
  for (int i=0; i < n; ++i) {
switch (chars[i]) {
case '""':
      ++quoteCount;
    break;
case '\'':
  ++aposCount;
break;
}
}
StringBuffer result=new StringBuffer(value.length() + 16);
char quoteChar=(quoteCount < aposCount) ? '""' : '\'';
p.print(quoteChar);
for (int i=0; i < n; ++i) {
char c=chars[i];
if (' ' <= c && c <= '~' && c != quoteChar && c != '\\') {
result.append(c);
continue;
}
int escape=-1;
switch (c) {
case 0:
escape='0';
break;
case '\b':
escape='b';
break;
case '\f':
escape='f';
break;
case '\n':
escape='n';
break;
case '\r':
escape='r';
break;
case '\t':
escape='t';
break;
case '""':
escape='""';
break;
case '\'':
escape='\'';
break;
case '\\':
escape='\\';
break;
}
if (escape >= 0) {
result.append('\\');
result.append((char)escape);
}
 else {
int hexSize;
if (c < 256) {
result.append(""String_Node_Str"");
hexSize=2;
}
 else {
result.append(""String_Node_Str"");
hexSize=4;
}
for (int shift=(hexSize - 1) * 4; shift >= 0; shift-=4) {
int digit=0xf & (c >> shift);
result.append(HEX_DIGITS[digit]);
}
}
}
result.append(quoteChar);
escapeClosingTags(result);
p.print(result.toString());
}","/** 
 * Adapted from  {@link com.google.gwt.dev.js.rhino.ScriptRuntime#escapeString(String)}. The difference is that we quote with either &quot; or &apos; depending on which one is used less inside the string.
 */
private void printStringLiteral(String value){
  char[] chars=value.toCharArray();
  final int n=chars.length;
  int quoteCount=0;
  int aposCount=0;
  for (int i=0; i < n; ++i) {
switch (chars[i]) {
case '""':
      ++quoteCount;
    break;
case '\'':
  ++aposCount;
break;
}
}
StringBuffer result=new StringBuffer(value.length() + 16);
char quoteChar=(quoteCount < aposCount) ? '""' : '\'';
p.print(quoteChar);
for (int i=0; i < n; ++i) {
char c=chars[i];
if (' ' <= c && c <= '~' && c != quoteChar && c != '\\') {
result.append(c);
continue;
}
int escape=-1;
switch (c) {
case '\b':
escape='b';
break;
case '\f':
escape='f';
break;
case '\n':
escape='n';
break;
case '\r':
escape='r';
break;
case '\t':
escape='t';
break;
case '""':
escape='""';
break;
case '\'':
escape='\'';
break;
case '\\':
escape='\\';
break;
}
if (escape >= 0) {
result.append('\\');
result.append((char)escape);
}
 else {
if (c < ' ' && (i == n - 1 || chars[i + 1] < '0' || chars[i + 1] > '9')) {
result.append('\\');
if (c > 0x7) {
result.append((char)('0' + (0x7 & (c >> 3))));
}
result.append((char)('0' + (0x7 & c)));
}
 else {
int hexSize;
if (c < 256) {
result.append(""String_Node_Str"");
hexSize=2;
}
 else {
result.append(""String_Node_Str"");
hexSize=4;
}
for (int shift=(hexSize - 1) * 4; shift >= 0; shift-=4) {
int digit=0xf & (c >> shift);
result.append(HEX_DIGITS[digit]);
}
}
}
}
result.append(quoteChar);
escapeClosingTags(result);
p.print(result.toString());
}",0.7357347784507491
54288,"/** 
 * Constructor.
 * @param enableSourceInfoDescendants Controls whether or not SourceInfo nodescreated via the JProgram will record descendant information. Enabling this feature will collect extra data during the compilation cycle, but at a cost of memory and object allocations.
 */
public JProgram(CorrelationFactory correlator){
  super(correlator.makeSourceInfo(SourceOrigin.create(0,JProgram.class.getName())));
  this.correlator=correlator;
  intrinsic=createSourceInfo(0,getClass().getName());
  stringPoolSourceInfo=createLiteralSourceInfo(""String_Node_Str"",Literal.STRING);
}","/** 
 * Constructor.
 * @param correlator Controls whether or not SourceInfo nodes created via theJProgram will record descendant information. Enabling this feature will collect extra data during the compilation cycle, but at a cost of memory and object allocations.
 */
public JProgram(CorrelationFactory correlator){
  super(correlator.makeSourceInfo(SourceOrigin.create(0,JProgram.class.getName())));
  this.correlator=correlator;
  intrinsic=createSourceInfo(0,getClass().getName());
  stringPoolSourceInfo=createLiteralSourceInfo(""String_Node_Str"",Literal.STRING);
}",0.9663503019844694
54289,"public JInterfaceType createInterface(SourceInfo info,char[][] name){
  String sname=dotify(name);
  JInterfaceType x=new JInterfaceType(info,sname);
  allTypes.add(x);
  putIntoTypeMap(sname,x);
  if (INDEX_TYPES_SET.contains(sname)) {
    indexedTypes.put(x.getShortName(),x);
  }
  return x;
}","public JInterfaceType createInterface(SourceInfo info,char[][] name){
  String sname=dotify(name);
  JInterfaceType x=new JInterfaceType(info,sname);
  allTypes.add(x);
  putIntoTypeMap(sname,x);
  if (INDEX_TYPES_SET.contains(sname)) {
    indexedTypes.put(x.getShortName(),x);
    if (sname.equals(""String_Node_Str"")) {
      typeJavaLangCloneable=x;
    }
 else     if (sname.equals(""String_Node_Str"")) {
      typeJavaIoSerializable=x;
    }
  }
  return x;
}",0.7509881422924901
54290,"public boolean canTriviallyCast(JReferenceType type,JReferenceType qType){
  if (type.canBeNull() && !qType.canBeNull()) {
    return false;
  }
  type=type.getUnderlyingType();
  qType=qType.getUnderlyingType();
  JClassType jlo=program.getTypeJavaLangObject();
  if (type == qType || qType == jlo) {
    return true;
  }
  if (type instanceof JArrayType) {
    JArrayType aType=(JArrayType)type;
    if (qType instanceof JArrayType) {
      JArrayType qaType=(JArrayType)qType;
      JType leafType=aType.getLeafType();
      JType qLeafType=qaType.getLeafType();
      int dims=aType.getDims();
      int qDims=qaType.getDims();
      if (dims > qDims && (qLeafType == jlo || qLeafType instanceof JNullType)) {
        return true;
      }
      if (dims == qDims) {
        if (leafType instanceof JReferenceType && qLeafType instanceof JReferenceType) {
          return canTriviallyCast((JReferenceType)leafType,(JReferenceType)qLeafType);
        }
      }
    }
  }
 else   if (type instanceof JClassType) {
    JClassType cType=(JClassType)type;
    if (qType instanceof JClassType) {
      JClassType qcType=(JClassType)qType;
      if (isSuperClass(cType,qcType)) {
        return true;
      }
      JClassType jsoType=program.getJavaScriptObject();
      if (jsoType != null) {
        return isSameOrSuper(cType,jsoType) && isSameOrSuper(qcType,jsoType);
      }
    }
 else     if (qType instanceof JInterfaceType) {
      return implementsInterface(cType,(JInterfaceType)qType);
    }
  }
 else   if (type instanceof JInterfaceType) {
    JInterfaceType iType=(JInterfaceType)type;
    if (qType instanceof JInterfaceType) {
      return extendsInterface(iType,(JInterfaceType)qType);
    }
  }
 else   if (type instanceof JNullType) {
    return true;
  }
  return false;
}","public boolean canTriviallyCast(JReferenceType type,JReferenceType qType){
  if (type.canBeNull() && !qType.canBeNull()) {
    return false;
  }
  type=type.getUnderlyingType();
  qType=qType.getUnderlyingType();
  JClassType jlo=program.getTypeJavaLangObject();
  if (type == qType || qType == jlo) {
    return true;
  }
  if (type instanceof JArrayType) {
    JArrayType aType=(JArrayType)type;
    if (qType instanceof JArrayType) {
      JArrayType qaType=(JArrayType)qType;
      JType leafType=aType.getLeafType();
      JType qLeafType=qaType.getLeafType();
      int dims=aType.getDims();
      int qDims=qaType.getDims();
      if (dims > qDims && (qLeafType == jlo || qLeafType instanceof JNullType)) {
        return true;
      }
      if (dims == qDims) {
        if (leafType instanceof JReferenceType && qLeafType instanceof JReferenceType) {
          return canTriviallyCast((JReferenceType)leafType,(JReferenceType)qLeafType);
        }
      }
    }
    if (qType == javaIoSerializable || qType == javaLangCloneable) {
      return true;
    }
  }
 else   if (type instanceof JClassType) {
    JClassType cType=(JClassType)type;
    if (qType instanceof JClassType) {
      JClassType qcType=(JClassType)qType;
      if (isSuperClass(cType,qcType)) {
        return true;
      }
      JClassType jsoType=program.getJavaScriptObject();
      if (jsoType != null) {
        return isSameOrSuper(cType,jsoType) && isSameOrSuper(qcType,jsoType);
      }
    }
 else     if (qType instanceof JInterfaceType) {
      return implementsInterface(cType,(JInterfaceType)qType);
    }
  }
 else   if (type instanceof JInterfaceType) {
    JInterfaceType iType=(JInterfaceType)type;
    if (qType instanceof JInterfaceType) {
      return extendsInterface(iType,(JInterfaceType)qType);
    }
  }
 else   if (type instanceof JNullType) {
    return true;
  }
  return false;
}",0.974414806750136
54291,"public void testCanTriviallyCast(){
  assertTrue(typeOracle.canTriviallyCast(classB,classB));
  assertTrue(typeOracle.canTriviallyCast(classBSub,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,classBSub));
  assertFalse(typeOracle.canTriviallyCast(classC,classA));
  assertFalse(typeOracle.canTriviallyCast(classA,classC));
  assertTrue(typeOracle.canTriviallyCast(classB,intfI));
  assertFalse(typeOracle.canTriviallyCast(intfI,classB));
  assertTrue(typeOracle.canTriviallyCast(classB,classObject));
  assertFalse(typeOracle.canTriviallyCast(classObject,classB));
  assertTrue(typeOracle.canTriviallyCast(classB,intfI));
  assertFalse(typeOracle.canTriviallyCast(intfI,classB));
  assertTrue(typeOracle.canTriviallyCast(classBnn,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,classBnn));
  assertTrue(typeOracle.canTriviallyCast(typeNull,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,typeNull));
  assertTrue(typeOracle.canTriviallyCast(arrayOfBSub,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfBSub));
  assertFalse(typeOracle.canTriviallyCast(arrayOfA,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfA));
  assertFalse(typeOracle.canTriviallyCast(arrayOfArrayOfB,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfArrayOfB));
  assertTrue(typeOracle.canTriviallyCast(arrayOfArrayOfB,arrayOfObject));
  assertFalse(typeOracle.canTriviallyCast(arrayOfObject,arrayOfArrayOfB));
  assertTrue(typeOracle.canTriviallyCast(classJso1,classJso2));
  assertTrue(typeOracle.canTriviallyCast(classJso2,classJso1));
  assertTrue(typeOracle.canTriviallyCast(classJso,classJso1));
  assertTrue(typeOracle.canTriviallyCast(classJso,classJso1));
  for (  JReferenceType type1 : severalTypes()) {
    for (    JReferenceType type2 : severalTypes()) {
      if (type1 != type2) {
        if (!isJso(type1) || !isJso(type2)) {
          assertFalse(typeOracle.canTriviallyCast(type1,type2) && typeOracle.canTriviallyCast(type2,type1));
        }
      }
    }
  }
}","public void testCanTriviallyCast(){
  assertTrue(typeOracle.canTriviallyCast(classB,classB));
  assertTrue(typeOracle.canTriviallyCast(classBSub,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,classBSub));
  assertFalse(typeOracle.canTriviallyCast(classC,classA));
  assertFalse(typeOracle.canTriviallyCast(classA,classC));
  assertTrue(typeOracle.canTriviallyCast(classB,intfI));
  assertFalse(typeOracle.canTriviallyCast(intfI,classB));
  assertTrue(typeOracle.canTriviallyCast(classB,classObject));
  assertFalse(typeOracle.canTriviallyCast(classObject,classB));
  assertTrue(typeOracle.canTriviallyCast(classB,intfI));
  assertFalse(typeOracle.canTriviallyCast(intfI,classB));
  assertTrue(typeOracle.canTriviallyCast(classBnn,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,classBnn));
  assertTrue(typeOracle.canTriviallyCast(typeNull,classB));
  assertFalse(typeOracle.canTriviallyCast(classB,typeNull));
  assertTrue(typeOracle.canTriviallyCast(arrayOfBSub,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfBSub));
  assertFalse(typeOracle.canTriviallyCast(arrayOfA,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfA));
  assertFalse(typeOracle.canTriviallyCast(arrayOfArrayOfB,arrayOfB));
  assertFalse(typeOracle.canTriviallyCast(arrayOfB,arrayOfArrayOfB));
  assertTrue(typeOracle.canTriviallyCast(arrayOfArrayOfB,arrayOfObject));
  assertFalse(typeOracle.canTriviallyCast(arrayOfObject,arrayOfArrayOfB));
  assertTrue(typeOracle.canTriviallyCast(classJso1,classJso2));
  assertTrue(typeOracle.canTriviallyCast(classJso2,classJso1));
  assertTrue(typeOracle.canTriviallyCast(classJso,classJso1));
  assertTrue(typeOracle.canTriviallyCast(classJso,classJso1));
  assertTrue(typeOracle.canTriviallyCast(arrayOfA,intfSerializable));
  assertFalse(typeOracle.canTriviallyCast(intfSerializable,arrayOfA));
  assertTrue(typeOracle.canTriviallyCast(arrayOfA,intfCloneable));
  assertFalse(typeOracle.canTriviallyCast(intfCloneable,arrayOfA));
  for (  JReferenceType type1 : severalTypes()) {
    for (    JReferenceType type2 : severalTypes()) {
      if (type1 != type2) {
        if (!isJso(type1) || !isJso(type2)) {
          assertFalse(typeOracle.canTriviallyCast(type1,type2) && typeOracle.canTriviallyCast(type2,type1));
        }
      }
    }
  }
}",0.9369287020109688
54292,"private void createSampleProgram(){
  program=new JProgram();
  typeOracle=program.typeOracle;
  synthSource=program.createSourceInfoSynthetic(JjsTypeTest.class,""String_Node_Str"");
  classObject=createClass(""String_Node_Str"",null,false,false);
  classString=createClass(""String_Node_Str"",classObject,false,true);
  classJso=createClass(""String_Node_Str"",classObject,false,false);
  intfIBase=createInterface(""String_Node_Str"");
  intfI=createInterface(""String_Node_Str"");
  intfI.addImplements(intfIBase);
  intfJ=createInterface(""String_Node_Str"");
  classBase=createClass(""String_Node_Str"",classObject,false,false);
  classA=createClass(""String_Node_Str"",classBase,false,false);
  classB=createClass(""String_Node_Str"",classBase,false,false);
  classB.addImplements(intfI);
  classC=createClass(""String_Node_Str"",classObject,false,false);
  classC.addImplements(intfI);
  classBSub=createClass(""String_Node_Str"",classB,false,false);
  classJso1=createClass(""String_Node_Str"",classJso,false,false);
  classJso2=createClass(""String_Node_Str"",classJso,false,false);
  program.typeOracle.computeBeforeAST();
  typeNull=program.getTypeNull();
  classBnn=program.getNonNullType(classB);
  classBaseNn=program.getNonNullType(classBase);
  arrayOfA=program.getTypeArray(classA,1);
  arrayOfB=program.getTypeArray(classB,1);
  arrayOfBSub=program.getTypeArray(classBSub,1);
  arrayOfC=program.getTypeArray(classC,1);
  arrayOfObject=program.getTypeArray(classObject,1);
  arrayOfInt=program.getTypeArray(program.getTypePrimitiveInt(),1);
  arrayOfArrayOfInt=program.getTypeArray(program.getTypePrimitiveInt(),2);
  arrayOfArrayOfB=program.getTypeArray(classB,2);
}","private void createSampleProgram(){
  program=new JProgram();
  typeOracle=program.typeOracle;
  synthSource=program.createSourceInfoSynthetic(JjsTypeTest.class,""String_Node_Str"");
  classObject=createClass(""String_Node_Str"",null,false,false);
  classString=createClass(""String_Node_Str"",classObject,false,true);
  classJso=createClass(""String_Node_Str"",classObject,false,false);
  intfSerializable=createInterface(""String_Node_Str"");
  intfCloneable=createInterface(""String_Node_Str"");
  intfIBase=createInterface(""String_Node_Str"");
  intfI=createInterface(""String_Node_Str"");
  intfI.addImplements(intfIBase);
  intfJ=createInterface(""String_Node_Str"");
  classBase=createClass(""String_Node_Str"",classObject,false,false);
  classA=createClass(""String_Node_Str"",classBase,false,false);
  classB=createClass(""String_Node_Str"",classBase,false,false);
  classB.addImplements(intfI);
  classC=createClass(""String_Node_Str"",classObject,false,false);
  classC.addImplements(intfI);
  classBSub=createClass(""String_Node_Str"",classB,false,false);
  classJso1=createClass(""String_Node_Str"",classJso,false,false);
  classJso2=createClass(""String_Node_Str"",classJso,false,false);
  program.typeOracle.computeBeforeAST();
  typeNull=program.getTypeNull();
  classBnn=program.getNonNullType(classB);
  classBaseNn=program.getNonNullType(classBase);
  arrayOfA=program.getTypeArray(classA,1);
  arrayOfB=program.getTypeArray(classB,1);
  arrayOfBSub=program.getTypeArray(classBSub,1);
  arrayOfC=program.getTypeArray(classC,1);
  arrayOfObject=program.getTypeArray(classObject,1);
  arrayOfInt=program.getTypeArray(program.getTypePrimitiveInt(),1);
  arrayOfArrayOfInt=program.getTypeArray(program.getTypePrimitiveInt(),2);
  arrayOfArrayOfB=program.getTypeArray(classB,2);
}",0.9687042995027786
54293,"public void testGeneralizeTypes(){
  assertSame(classA,generalizeTypes(classA,classA));
  assertSame(classB,generalizeTypes(classB,classBnn));
  assertSame(classB,generalizeTypes(classBnn,classB));
  assertSame(classBaseNn,generalizeTypes(classBnn,classBaseNn));
  assertSame(classB,generalizeTypes(classB,typeNull));
  assertSame(classB,generalizeTypes(typeNull,classB));
  assertSame(intfIBase,generalizeTypes(intfI,intfIBase));
  assertSame(intfIBase,generalizeTypes(intfIBase,intfI));
  assertSame(classObject,generalizeTypes(intfJ,intfI));
  assertSame(classObject,generalizeTypes(arrayOfB,arrayOfInt));
  assertSame(classObject,generalizeTypes(arrayOfC,arrayOfArrayOfB));
  assertSame(arrayOfObject,generalizeTypes(arrayOfC,arrayOfB));
  assertSame(arrayOfObject,generalizeTypes(arrayOfObject,arrayOfArrayOfInt));
  assertSame(intfI,generalizeTypes(classB,intfI));
  assertSame(classObject,generalizeTypes(classB,intfJ));
  assertSame(classObject,generalizeTypes(intfI,arrayOfInt));
  for (  JReferenceType type1 : severalTypes()) {
    for (    JReferenceType type2 : severalTypes()) {
      JReferenceType generalized=generalizeTypes(type1,type2);
      assertTrue(typeOracle.canTriviallyCast(type1,generalized));
      assertTrue(typeOracle.canTriviallyCast(type2,generalized));
    }
  }
}","public void testGeneralizeTypes(){
  assertSame(classA,generalizeTypes(classA,classA));
  assertSame(classB,generalizeTypes(classB,classBnn));
  assertSame(classB,generalizeTypes(classBnn,classB));
  assertSame(classBaseNn,generalizeTypes(classBnn,classBaseNn));
  assertSame(classB,generalizeTypes(classB,typeNull));
  assertSame(classB,generalizeTypes(typeNull,classB));
  assertSame(intfIBase,generalizeTypes(intfI,intfIBase));
  assertSame(intfIBase,generalizeTypes(intfIBase,intfI));
  assertSame(classObject,generalizeTypes(intfJ,intfI));
  assertSame(classObject,generalizeTypes(arrayOfB,arrayOfInt));
  assertSame(classObject,generalizeTypes(arrayOfC,arrayOfArrayOfB));
  assertSame(arrayOfObject,generalizeTypes(arrayOfC,arrayOfB));
  assertSame(arrayOfObject,generalizeTypes(arrayOfObject,arrayOfArrayOfInt));
  assertSame(intfI,generalizeTypes(classB,intfI));
  assertSame(classObject,generalizeTypes(classB,intfJ));
  assertSame(classObject,generalizeTypes(intfI,arrayOfInt));
  assertSame(intfSerializable,generalizeTypes(intfSerializable,arrayOfA));
  assertSame(intfCloneable,generalizeTypes(intfCloneable,arrayOfA));
  for (  JReferenceType type1 : severalTypes()) {
    for (    JReferenceType type2 : severalTypes()) {
      JReferenceType generalized=generalizeTypes(type1,type2);
      assertTrue(typeOracle.canTriviallyCast(type1,generalized));
      assertTrue(typeOracle.canTriviallyCast(type2,generalized));
    }
  }
}",0.9474835886214442
54294,"public void testCanTheoreticallyCast(){
  assertFalse(typeOracle.canTheoreticallyCast(classBnn,typeNull));
  assertTrue(typeOracle.canTheoreticallyCast(classBSub,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classBSub));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classBnn));
  assertTrue(typeOracle.canTheoreticallyCast(classBnn,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classObject,arrayOfB));
  assertFalse(typeOracle.canTheoreticallyCast(arrayOfA,arrayOfArrayOfB));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfObject,arrayOfArrayOfB));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfB,arrayOfBSub));
  assertTrue(typeOracle.canTheoreticallyCast(classBase,intfI));
  assertFalse(typeOracle.canTheoreticallyCast(classA,intfJ));
  assertTrue(typeOracle.canTheoreticallyCast(intfIBase,intfI));
  assertTrue(typeOracle.canTheoreticallyCast(intfIBase,classBase));
  assertFalse(typeOracle.canTheoreticallyCast(intfJ,classA));
}","public void testCanTheoreticallyCast(){
  assertFalse(typeOracle.canTheoreticallyCast(classBnn,typeNull));
  assertTrue(typeOracle.canTheoreticallyCast(classBSub,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classBSub));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classBnn));
  assertTrue(typeOracle.canTheoreticallyCast(classBnn,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classB,classB));
  assertTrue(typeOracle.canTheoreticallyCast(classObject,arrayOfB));
  assertFalse(typeOracle.canTheoreticallyCast(arrayOfA,arrayOfArrayOfB));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfObject,arrayOfArrayOfB));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfB,arrayOfBSub));
  assertTrue(typeOracle.canTheoreticallyCast(classBase,intfI));
  assertFalse(typeOracle.canTheoreticallyCast(classA,intfJ));
  assertTrue(typeOracle.canTheoreticallyCast(intfIBase,intfI));
  assertTrue(typeOracle.canTheoreticallyCast(intfIBase,classBase));
  assertFalse(typeOracle.canTheoreticallyCast(intfJ,classA));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfA,intfSerializable));
  assertTrue(typeOracle.canTheoreticallyCast(intfSerializable,arrayOfA));
  assertTrue(typeOracle.canTheoreticallyCast(arrayOfA,intfCloneable));
  assertTrue(typeOracle.canTheoreticallyCast(intfCloneable,arrayOfA));
}",0.8774302620456467
54295,"public void testStrongerType(){
  assertSame(classA,program.strongerType(classA,classA));
  assertSame(classBnn,program.strongerType(classB,classBnn));
  assertSame(classB,program.strongerType(classB,classBase));
  assertSame(classB,program.strongerType(classBase,classB));
  assertSame(intfI,program.strongerType(intfI,intfJ));
}","public void testStrongerType(){
  assertSame(classA,program.strongerType(classA,classA));
  assertSame(classBnn,program.strongerType(classB,classBnn));
  assertSame(classB,program.strongerType(classB,classBase));
  assertSame(classB,program.strongerType(classBase,classB));
  assertSame(intfI,program.strongerType(intfI,intfJ));
  assertSame(arrayOfA,program.strongerType(intfSerializable,arrayOfA));
  assertSame(arrayOfA,program.strongerType(intfCloneable,arrayOfA));
}",0.8239700374531835
54296,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}",0.9230769230769232
54297,"public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
}","public void testParse(){
  assertTrue(0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-1.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(3.0 == Double.parseDouble(""String_Node_Str""));
  assertTrue(0.5 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.98e8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.98e-8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(+2.98E+8 == Double.parseDouble(""String_Node_Str""));
  assertTrue(""String_Node_Str"",Double.MIN_VALUE == Double.parseDouble(String.valueOf(Double.MIN_VALUE)));
  assertTrue(""String_Node_Str"",Double.MAX_VALUE == Double.parseDouble(String.valueOf(Double.MAX_VALUE)));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
  assertTrue(-2.56789e1 == Double.parseDouble(""String_Node_Str""));
}",0.6273408239700374
54298,"public void testBadStrings(){
  try {
    new Integer(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.decode(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf(Long.MAX_VALUE));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf(Long.MIN_VALUE));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf((long)Integer.MAX_VALUE + 1));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf((long)Integer.MIN_VALUE - 1));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}","public void testBadStrings(){
  try {
    new Integer(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.decode(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf(Long.MAX_VALUE));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf(Long.MIN_VALUE));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf((long)Integer.MAX_VALUE + 1));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(String.valueOf((long)Integer.MIN_VALUE - 1));
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
  try {
    Integer.parseInt(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException e) {
  }
}",0.8383442265795207
54299,"public static Timestamp valueOf(String s){
  String[] components=s.split(""String_Node_Str"");
  if (components.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  String[] timeComponents=components[1].split(""String_Node_Str"");
  boolean hasNanos=true;
  int nanos=0;
  if (timeComponents.length == 1) {
    hasNanos=false;
  }
 else   if (timeComponents.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  Date d=Date.valueOf(components[0]);
  Time t=Time.valueOf(timeComponents[0]);
  if (hasNanos) {
    String nanosString=timeComponents[1];
    int len=nanosString.length();
    assert(len > 0);
    if (len > 9) {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
    if (len < 9) {
      nanosString+=""String_Node_Str"".substring(len - 1);
    }
    try {
      nanos=Integer.valueOf(nanosString);
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
  }
  return new Timestamp(d.getYear(),d.getMonth(),d.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),nanos);
}","public static Timestamp valueOf(String s){
}",0.0757314974182444
54300,"public static Timestamp valueOf(String s){
  String[] components=s.split(""String_Node_Str"");
  if (components.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  String[] timeComponents=components[1].split(""String_Node_Str"");
  if (timeComponents.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
 else   if (timeComponents[1].length() != 9) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  Date d=Date.valueOf(components[0]);
  Time t=Time.valueOf(timeComponents[0]);
  int nanos;
  try {
    nanos=Integer.valueOf(timeComponents[1]);
  }
 catch (  NumberFormatException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  return new Timestamp(d.getYear(),d.getMonth(),d.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),nanos);
}","public static Timestamp valueOf(String s){
  String[] components=s.split(""String_Node_Str"");
  if (components.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  String[] timeComponents=components[1].split(""String_Node_Str"");
  boolean hasNanos=true;
  int nanos=0;
  if (timeComponents.length == 1) {
    hasNanos=false;
  }
 else   if (timeComponents.length != 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + s);
  }
  Date d=Date.valueOf(components[0]);
  Time t=Time.valueOf(timeComponents[0]);
  if (hasNanos) {
    String nanosString=timeComponents[1];
    int len=nanosString.length();
    assert(len > 0);
    if (len > 9) {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
    if (len < 9) {
      nanosString+=""String_Node_Str"".substring(len - 1);
    }
    try {
      nanos=Integer.valueOf(nanosString);
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + s);
    }
  }
  return new Timestamp(d.getYear(),d.getMonth(),d.getDate(),t.getHours(),t.getMinutes(),t.getSeconds(),nanos);
}",0.6989795918367347
54301,"public void testValueOf(){
  try {
    Timestamp.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Timestamp.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  Timestamp expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456789);
  Timestamp actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
}","public void testValueOf(){
  try {
    Timestamp.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Timestamp.valueOf(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  Timestamp expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456789);
  Timestamp actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,0);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,100000000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,120000000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123000000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123400000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123450000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456000);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456700);
  actual=Timestamp.valueOf(""String_Node_Str"");
  assertEquals(expected,actual);
  expected=new Timestamp(2000 - 1900,1 - 1,1,12,34,56,123456780);
  actual=Timestamp.valueOf(""String_Node_Str"");
}",0.413093591516828
54302,"public static void retainValidUnits(Collection<CompilationUnit> units,Set<ContentId> knownValidRefs){
  Set<CompilationUnit> currentlyValidUnits=new HashSet<CompilationUnit>();
  Set<ContentId> currentlyValidRefs=new HashSet<ContentId>(knownValidRefs);
  for (  CompilationUnit unit : units) {
    if (unit.isCompiled()) {
      currentlyValidUnits.add(unit);
      currentlyValidRefs.add(unit.getContentId());
    }
  }
  boolean changed;
  do {
    changed=false;
    iterating:     for (Iterator<CompilationUnit> it=currentlyValidUnits.iterator(); it.hasNext(); ) {
      CompilationUnit unitToCheck=it.next();
      for (      ContentId ref : unitToCheck.getDependencies()) {
        if (!currentlyValidRefs.contains(ref)) {
          it.remove();
          currentlyValidRefs.remove(unitToCheck.getDisplayLocation());
          changed=true;
          continue iterating;
        }
      }
    }
  }
 while (changed);
  units.retainAll(currentlyValidUnits);
}","public static void retainValidUnits(Collection<CompilationUnit> units,Set<ContentId> knownValidRefs){
  Set<CompilationUnit> currentlyValidUnits=new HashSet<CompilationUnit>();
  Set<ContentId> currentlyValidRefs=new HashSet<ContentId>(knownValidRefs);
  for (  CompilationUnit unit : units) {
    if (unit.isCompiled()) {
      currentlyValidUnits.add(unit);
      currentlyValidRefs.add(unit.getContentId());
    }
  }
  boolean changed;
  do {
    changed=false;
    iterating:     for (Iterator<CompilationUnit> it=currentlyValidUnits.iterator(); it.hasNext(); ) {
      CompilationUnit unitToCheck=it.next();
      for (      ContentId ref : unitToCheck.getDependencies()) {
        if (!currentlyValidRefs.contains(ref)) {
          it.remove();
          currentlyValidRefs.remove(unitToCheck.getContentId());
          changed=true;
          continue iterating;
        }
      }
    }
  }
 while (changed);
  units.retainAll(currentlyValidUnits);
}",0.8376690946930281
54303,"/** 
 * Returns a pretty printed list of clients that have not retrieved the current test. Used for error reporting.
 * @param testInfo the {@link TestInfo} we are waiting for
 * @return a string containing the list of clients that have not retrieved thecurrent test.
 */
String getUnretrievedClients(TestInfo testInfo){
synchronized (clientStatusesLock) {
    Map<ClientStatus,JUnitResult> results=testResults.get(testInfo);
    StringBuilder buf=new StringBuilder();
    int lineCount=0;
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      if (results == null || !results.containsKey(clientStatus)) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(clientStatus.clientDesc);
      ++lineCount;
    }
    int difference=numClients - getNumClientsRetrievedTest(testInfo);
    if (difference > 0) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      buf.append(""String_Node_Str"" + difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}","/** 
 * Returns a pretty printed list of clients that have not retrieved the current test. Used for error reporting.
 * @param testInfo the {@link TestInfo} we are waiting for
 * @return a string containing the list of clients that have not retrieved thecurrent test.
 */
String getUnretrievedClients(TestInfo testInfo){
synchronized (clientStatusesLock) {
    Map<ClientStatus,JUnitResult> results=testResults.get(testInfo);
    StringBuilder buf=new StringBuilder();
    int lineCount=0;
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      if (results == null || !results.containsKey(clientStatus)) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(clientStatus.getDesc());
      ++lineCount;
    }
    int difference=numClients - getNumClientsRetrievedTest(testInfo);
    if (difference > 0) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      buf.append(""String_Node_Str"" + difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}",0.9959839357429718
54304,"public void reportFatalLaunch(String clientId,String clientDesc,String userAgent,JUnitResult result){
  ClientStatus clientStatus=ensureClientStatus(clientId,clientDesc);
  Map<TestInfo,JUnitResult> results=new HashMap<TestInfo,JUnitResult>();
  for (  TestInfo testInfo : testBlocks.get(clientStatus.blockIndex)) {
    results.put(testInfo,result);
  }
  reportResults(clientId,clientDesc,userAgent,results);
}","/** 
 * Reports a failure from a client that cannot startup.
 * @param clientInfo information about the client
 * @param result the failure result
 */
public void reportFatalLaunch(ClientInfoExt clientInfo,JUnitResult result){
  ClientStatus clientStatus=ensureClientStatus(clientInfo);
  Map<TestInfo,JUnitResult> results=new HashMap<TestInfo,JUnitResult>();
  for (  TestInfo testInfo : testBlocks.get(clientStatus.blockIndex)) {
    results.put(testInfo,result);
  }
  reportResults(clientInfo,results);
}",0.7072905331882481
54305,"/** 
 * Returns any new clients that have contacted the server since the last call. The same client will never be returned from this method twice.
 */
String[] getNewClients(){
synchronized (clientStatusesLock) {
    List<String> results=new ArrayList<String>();
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (clientStatus.isNew) {
        results.add(clientStatus.clientDesc);
        clientStatus.isNew=false;
      }
    }
    clientStatusesLock.notifyAll();
    return results.toArray(new String[results.size()]);
  }
}","/** 
 * Returns any new clients that have contacted the server since the last call. The same client will never be returned from this method twice.
 */
String[] getNewClients(){
synchronized (clientStatusesLock) {
    List<String> results=new ArrayList<String>();
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (clientStatus.isNew) {
        results.add(clientStatus.getDesc());
        clientStatus.isNew=false;
      }
    }
    clientStatusesLock.notifyAll();
    return results.toArray(new String[results.size()]);
  }
}",0.991869918699187
54306,"public ClientStatus(String clientId,String clientDesc){
  this.clientId=clientId;
  this.clientDesc=clientDesc;
}","public ClientStatus(ClientInfoExt clientInfo){
  this.clientInfo=clientInfo;
}",0.6282722513089005
54307,"/** 
 * Ensure that a   {@link ClientStatus} for the clientId exists.
 * @param clientId the id of the client
 * @return the {@link ClientStatus} for the client
 */
private ClientStatus ensureClientStatus(String clientId,String clientDesc){
  ClientStatus clientStatus=clientStatuses.get(clientId);
  if (clientStatus == null) {
    clientStatus=new ClientStatus(clientId,clientDesc);
    clientStatuses.put(clientId,clientStatus);
  }
 else {
    clientStatus.clientDesc=clientDesc;
  }
  return clientStatus;
}","/** 
 * Ensure that a   {@link ClientStatus} for the clientId exists.
 * @param clientId the id of the client
 * @return the {@link ClientStatus} for the client
 */
private ClientStatus ensureClientStatus(ClientInfoExt clientInfo){
  int id=clientInfo.getSessionId();
  ClientStatus clientStatus=clientStatuses.get(id);
  if (clientStatus == null) {
    clientStatus=new ClientStatus(clientInfo);
    clientStatuses.put(id,clientStatus);
  }
 else {
    clientStatus.updateClientInfo(clientInfo);
  }
  return clientStatus;
}",0.7675988428158148
54308,"/** 
 * Called by the servlet to report the results of the last test to run.
 * @param clientId the ID of the client
 * @param userAgent the user agent property of the client
 * @param results the result of running the test block
 */
public void reportResults(String clientId,String clientDesc,String userAgent,Map<TestInfo,JUnitResult> results){
synchronized (clientStatusesLock) {
    if (results == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    userAgents.add(userAgent);
    ClientStatus clientStatus=ensureClientStatus(clientId,clientDesc);
    for (    Map.Entry<TestInfo,JUnitResult> entry : results.entrySet()) {
      TestInfo testInfo=entry.getKey();
      ensureResults(testInfo).put(clientStatus,entry.getValue());
    }
    clientStatusesLock.notifyAll();
  }
}","/** 
 * Called by the servlet to report the results of the last test to run.
 * @param clientInfo information about the client
 * @param results the result of running the test block
 */
public void reportResults(ClientInfoExt clientInfo,Map<TestInfo,JUnitResult> results){
synchronized (clientStatusesLock) {
    if (results == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    userAgents.add(clientInfo.getUserAgent());
    ClientStatus clientStatus=ensureClientStatus(clientInfo);
    for (    Map.Entry<TestInfo,JUnitResult> entry : results.entrySet()) {
      TestInfo testInfo=entry.getKey();
      ensureResults(testInfo).put(clientStatus,entry.getValue());
    }
    clientStatusesLock.notifyAll();
  }
}",0.8739495798319328
54309,"/** 
 * Returns a human-formatted message identifying what clients have connected but have not yet reported results for this test. It is used in a timeout condition, to identify what we're still waiting on.
 * @param testInfo the {@link TestInfo} that the clients are working on
 * @return human readable message
 */
String getWorkingClients(TestInfo testInfo){
synchronized (clientStatusesLock) {
    int itemCount=0;
    StringBuilder buf=new StringBuilder();
    Map<ClientStatus,JUnitResult> results=testResults.get(testInfo);
    if (results != null) {
      for (      Map.Entry<ClientStatus,JUnitResult> entry : results.entrySet()) {
        if (entry.getValue() == null) {
          buf.append(entry.getKey().clientDesc);
          buf.append(""String_Node_Str"");
          itemCount++;
        }
      }
    }
    int difference=numClients - itemCount;
    if (difference > 0) {
      if (itemCount > 0) {
        buf.append('\n');
      }
      buf.append(difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}","/** 
 * Returns a human-formatted message identifying what clients have connected but have not yet reported results for this test. It is used in a timeout condition, to identify what we're still waiting on.
 * @param testInfo the {@link TestInfo} that the clients are working on
 * @return human readable message
 */
String getWorkingClients(TestInfo testInfo){
synchronized (clientStatusesLock) {
    int itemCount=0;
    StringBuilder buf=new StringBuilder();
    Map<ClientStatus,JUnitResult> results=testResults.get(testInfo);
    if (results != null) {
      for (      Map.Entry<ClientStatus,JUnitResult> entry : results.entrySet()) {
        if (entry.getValue() == null) {
          buf.append(entry.getKey().getDesc());
          buf.append(""String_Node_Str"");
          itemCount++;
        }
      }
    }
    int difference=numClients - itemCount;
    if (difference > 0) {
      if (itemCount > 0) {
        buf.append('\n');
      }
      buf.append(difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}",0.9956542732979236
54310,"/** 
 * Called by the servlet to query for for the next block to test.
 * @param clientId the ID of the client
 * @param userAgent the user agent property of the client
 * @param blockIndex the index of the test block to get
 * @param timeout how long to wait for an answer
 * @return the next test to run, or <code>null</code> if<code>timeout</code> is exceeded or the next test does not match <code>testClassName</code>
 */
public TestBlock getTestBlock(String clientId,String clientDesc,String userAgent,int blockIndex,long timeout) throws TimeoutException {
synchronized (clientStatusesLock) {
    userAgents.add(userAgent);
    ClientStatus clientStatus=ensureClientStatus(clientId,clientDesc);
    clientStatus.blockIndex=blockIndex;
    if (isLastTestBlockAvailable && blockIndex >= testBlocks.size()) {
      return null;
    }
    long startTime=System.currentTimeMillis();
    long stopTime=startTime + timeout;
    while (blockIndex >= testBlocks.size()) {
      long timeToWait=stopTime - System.currentTimeMillis();
      if (timeToWait < 1) {
        double elapsed=(System.currentTimeMillis() - startTime) / 1000.0;
        throw new TimeoutException(""String_Node_Str"" + ""String_Node_Str"" + timeout + ""String_Node_Str""+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
      }
      try {
        clientStatusesLock.wait(timeToWait);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
        return null;
      }
    }
    TestInfo[] tests=testBlocks.get(blockIndex);
    for (    TestInfo testInfo : tests) {
      ensureResults(testInfo).put(clientStatus,null);
    }
    return new TestBlock(tests,blockIndex);
  }
}","/** 
 * Called by the servlet to query for for the next block to test.
 * @param clientInfo information about the client
 * @param blockIndex the index of the test block to get
 * @param timeout how long to wait for an answer
 * @return the next test to run, or <code>null</code> if<code>timeout</code> is exceeded or the next test does not match <code>testClassName</code>
 */
public TestBlock getTestBlock(ClientInfoExt clientInfo,int blockIndex,long timeout) throws TimeoutException {
synchronized (clientStatusesLock) {
    userAgents.add(clientInfo.getUserAgent());
    ClientStatus clientStatus=ensureClientStatus(clientInfo);
    clientStatus.blockIndex=blockIndex;
    if (isLastTestBlockAvailable && blockIndex >= testBlocks.size()) {
      return null;
    }
    long startTime=System.currentTimeMillis();
    long stopTime=startTime + timeout;
    while (blockIndex >= testBlocks.size()) {
      long timeToWait=stopTime - System.currentTimeMillis();
      if (timeToWait < 1) {
        double elapsed=(System.currentTimeMillis() - startTime) / 1000.0;
        throw new TimeoutException(""String_Node_Str"" + ""String_Node_Str"" + timeout + ""String_Node_Str""+ ""String_Node_Str""+ clientInfo.getDesc()+ ""String_Node_Str""+ ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
      }
      try {
        clientStatusesLock.wait(timeToWait);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
        return null;
      }
    }
    TestInfo[] tests=testBlocks.get(blockIndex);
    for (    TestInfo testInfo : tests) {
      ensureResults(testInfo).put(clientStatus,null);
    }
    return new TestBlock(tests,blockIndex);
  }
}",0.9209840810419682
54311,"/** 
 * Reports results for the last method run and gets the name of next method to run.
 * @param results the results of executing the test
 * @param blockIndex the index of the test block to retrieve
 * @param userAgent the user agent property of this client
 * @return the next test block
 * @throws TimeoutException if the wait for the next method times out.
 */
TestBlock reportResultsAndGetTestBlock(HashMap<TestInfo,JUnitResult> results,int blockIndex,String userAgent) throws TimeoutException ;","/** 
 * Reports results for the last method run and gets the name of next method to run.
 * @param results the results of executing the test
 * @param blockIndex the index of the test block to retrieve
 * @param clientInfo the info for this client
 * @return the next test block
 * @throws TimeoutException if the wait for the next method times out.
 */
TestBlock reportResultsAndGetTestBlock(HashMap<TestInfo,JUnitResult> results,int blockIndex,ClientInfo clientInfo) throws TimeoutException ;",0.9036144578313252
54312,"/** 
 * Gets a specific block of tests to run.
 * @param blockIndex the index of the test block to retrieve
 * @param userAgent the user agent property of this client
 * @return the test block
 * @throws TimeoutException if the wait for the next method times out.
 */
TestBlock getTestBlock(int blockIndex,String userAgent) throws TimeoutException ;","/** 
 * Gets a specific block of tests to run.
 * @param blockIndex the index of the test block to retrieve
 * @param clientInfo the info for this client
 * @return the initial response
 * @throws TimeoutException if the wait for the next method times out.
 */
InitialResponse getTestBlock(int blockIndex,ClientInfo clientInfo) throws TimeoutException ;",0.433048433048433
54313,"public static String toSourceName(String dottedName){
  return dottedName.replaceAll(""String_Node_Str"",""String_Node_Str"");
}","public static String toSourceName(String dottedName){
  return NON_TRAILING_DOLLAR.matcher(dottedName).replaceAll(""String_Node_Str"");
}",0.8185328185328186
54314,"/** 
 * React to messages from the other side, where a return value is expected.
 * @param handler
 * @throws RemoteDeathError
 */
public ReturnMessage reactToMessagesWhileWaitingForReturn(SessionHandler handler){
  do {
    try {
      getStreamToOtherSide().flush();
      MessageType messageType=Message.readMessageType(getStreamFromOtherSide());
switch (messageType) {
case FREE_VALUE:
        final FreeMessage freeMsg=FreeMessage.receive(this);
      handler.freeValue(this,freeMsg.getIds());
    break;
case RETURN:
  return ReturnMessage.receive(this);
case INVOKE:
InvokeOnServerMessage imsg=InvokeOnServerMessage.receive(this);
ExceptionOrReturnValue result=handler.invoke(this,imsg.getThis(),imsg.getMethodDispatchId(),imsg.getArgs());
sendFreedValues();
ReturnMessage.send(this,result);
break;
case INVOKE_SPECIAL:
handleInvokeSpecial(handler);
break;
case QUIT:
throw new RemoteDeathError(null);
default :
throw new BrowserChannelException(""String_Node_Str"" + messageType + ""String_Node_Str"");
}
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
catch (BrowserChannelException e) {
throw new RemoteDeathError(e);
}
}
 while (true);
}","/** 
 * React to messages from the other side, where a return value is expected.
 * @param handler
 * @throws BrowserChannelException 
 * @throws RemoteDeathError
 */
public ReturnMessage reactToMessagesWhileWaitingForReturn(SessionHandler handler) throws BrowserChannelException, RemoteDeathError {
  do {
    try {
      getStreamToOtherSide().flush();
      MessageType messageType=Message.readMessageType(getStreamFromOtherSide());
switch (messageType) {
case FREE_VALUE:
        final FreeMessage freeMsg=FreeMessage.receive(this);
      handler.freeValue(this,freeMsg.getIds());
    break;
case RETURN:
  return ReturnMessage.receive(this);
case INVOKE:
InvokeOnServerMessage imsg=InvokeOnServerMessage.receive(this);
ExceptionOrReturnValue result=handler.invoke(this,imsg.getThis(),imsg.getMethodDispatchId(),imsg.getArgs());
sendFreedValues();
ReturnMessage.send(this,result);
break;
case INVOKE_SPECIAL:
handleInvokeSpecial(handler);
break;
case QUIT:
throw new RemoteDeathError(null);
default :
throw new BrowserChannelException(""String_Node_Str"" + messageType + ""String_Node_Str"");
}
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
catch (BrowserChannelException e) {
throw new RemoteDeathError(e);
}
}
 while (true);
}",0.964136780650542
54315,"/** 
 * Load a new instance of a module.
 * @param channel
 * @param moduleName
 * @param userAgent
 * @param url top-level URL of the main page, null if using an old plugin
 * @param tabKey opaque key of the tab, may be empty if the plugin can'tdistinguish tabs or null if using an old plugin
 * @param sessionKey opaque key for this session, null if using an old plugin
 * @param userAgentIcon byte array containing an icon (which fits within24x24) representing the user agent or null if unavailable
 * @return a TreeLogger to use for the module's logs
 */
public abstract TreeLogger loadModule(BrowserChannel channel,String moduleName,String userAgent,String url,String tabKey,String sessionKey,byte[] userAgentIcon);","/** 
 * Load a new instance of a module.
 * @param channel
 * @param moduleName
 * @param userAgent
 * @param url top-level URL of the main page, null if using an old plugin
 * @param tabKey opaque key of the tab, may be empty if the plugin can'tdistinguish tabs or null if using an old plugin
 * @param sessionKey opaque key for this session, null if using an old plugin
 * @param userAgentIcon byte array containing an icon (which fits within24x24) representing the user agent or null if unavailable
 * @return a TreeLogger to use for the module's logs, or null if the moduleload failed
 */
public abstract TreeLogger loadModule(BrowserChannel channel,String moduleName,String userAgent,String url,String tabKey,String sessionKey,byte[] userAgentIcon);",0.9769335142469472
54316,"protected void BrowserChannel(InputStream inputStream,OutputStream outputStream,ObjectRefFactory objectRefFactory) throws IOException {
  streamFromOtherSide=new DataInputStream(inputStream);
  streamToOtherSide=new DataOutputStream(outputStream);
  socket=null;
  this.objectRefFactory=objectRefFactory;
}","protected void BrowserChannel(InputStream inputStream,OutputStream outputStream,ObjectRefFactory objectRefFactory){
  streamFromOtherSide=new DataInputStream(inputStream);
  streamToOtherSide=new DataOutputStream(outputStream);
  socket=null;
  this.objectRefFactory=objectRefFactory;
}",0.9662162162162162
54317,"BrowserChannelServer(TreeLogger initialLogger,InputStream inputStream,OutputStream outputStream,SessionHandler handler,boolean ignoreRemoteDeath) throws IOException {
  super(inputStream,outputStream,new ServerObjectRefFactory());
  this.handler=handler;
  this.ignoreRemoteDeath=ignoreRemoteDeath;
  init(initialLogger);
}","BrowserChannelServer(TreeLogger initialLogger,InputStream inputStream,OutputStream outputStream,SessionHandler handler,boolean ignoreRemoteDeath){
  super(inputStream,outputStream,new ServerObjectRefFactory());
  this.handler=handler;
  this.ignoreRemoteDeath=ignoreRemoteDeath;
  init(initialLogger);
}",0.9680511182108626
54318,"protected void processConnection() throws IOException, BrowserChannelException {
  MessageType type=Message.readMessageType(getStreamFromOtherSide());
  String url=null;
  String tabKey=null;
  String sessionKey=null;
  byte[] iconBytes=null;
switch (type) {
case OLD_LOAD_MODULE:
    OldLoadModuleMessage oldLoadModule=OldLoadModuleMessage.receive(this);
  if (oldLoadModule.getProtoVersion() != 1) {
    throw new BrowserChannelException(""String_Node_Str"");
  }
moduleName=oldLoadModule.getModuleName();
userAgent=oldLoadModule.getUserAgent();
protocolVersion=1;
HelpInfo helpInfo=new HelpInfo(){
@Override public String getAnchorText(){
return ""String_Node_Str"";
}
@Override public URL getURL(){
try {
return new URL(""String_Node_Str"");
}
 catch (MalformedURLException e) {
return null;
}
}
}
;
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"",null,helpInfo);
break;
case CHECK_VERSIONS:
String connectError=null;
CheckVersionsMessage hello=CheckVersionsMessage.receive(this);
int minVersion=hello.getMinVersion();
int maxVersion=hello.getMaxVersion();
String hostedHtmlVersion=hello.getHostedHtmlVersion();
if (minVersion > PROTOCOL_VERSION_CURRENT || maxVersion < PROTOCOL_VERSION_OLDEST) {
connectError=""String_Node_Str"" + minVersion + ""String_Node_Str""+ maxVersion+ ""String_Node_Str""+ PROTOCOL_VERSION_OLDEST+ ""String_Node_Str""+ PROTOCOL_VERSION_CURRENT;
}
 else {
if (!HostedHtmlVersion.validHostedHtmlVersion(logger,hostedHtmlVersion)) {
new FatalErrorMessage(this,""String_Node_Str"").send();
return;
}
}
if (connectError != null) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + connectError,null);
new FatalErrorMessage(this,connectError).send();
return;
}
protocolVersion=Math.min(PROTOCOL_VERSION_CURRENT,maxVersion);
new ProtocolVersionMessage(this,protocolVersion).send();
type=Message.readMessageType(getStreamFromOtherSide());
if (type == MessageType.CHOOSE_TRANSPORT) {
ChooseTransportMessage chooseTransport=ChooseTransportMessage.receive(this);
String transport=selectTransport(chooseTransport.getTransports());
String transportArgs=null;
if (transport != null) {
transportArgs=createTransport(transport);
}
new SwitchTransportMessage(this,transport,transportArgs).send();
type=Message.readMessageType(getStreamFromOtherSide());
}
if (type != MessageType.LOAD_MODULE) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
LoadModuleMessage loadModule=LoadModuleMessage.receive(this);
url=loadModule.getUrl();
tabKey=loadModule.getTabKey();
sessionKey=loadModule.getSessionKey();
moduleName=loadModule.getModuleName();
userAgent=loadModule.getUserAgent();
break;
case REQUEST_PLUGIN:
logger.log(TreeLogger.ERROR,""String_Node_Str"");
new FatalErrorMessage(this,""String_Node_Str"").send();
return;
default :
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
if (protocolVersion >= PROTOCOL_VERSION_GET_ICON) {
synchronized (cacheLock) {
if (iconCache.containsKey(userAgent)) {
iconBytes=iconCache.get(userAgent);
}
 else {
RequestIconMessage.send(this);
type=Message.readMessageType(getStreamFromOtherSide());
if (type != MessageType.USER_AGENT_ICON) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
UserAgentIconMessage uaIconMessage=UserAgentIconMessage.receive(this);
iconBytes=uaIconMessage.getIconBytes();
iconCache.put(userAgent,iconBytes);
}
}
}
Thread.currentThread().setName(""String_Node_Str"" + moduleName + ""String_Node_Str""+ userAgent+ ""String_Node_Str""+ url+ ""String_Node_Str""+ sessionKey);
logger=handler.loadModule(this,moduleName,userAgent,url,tabKey,sessionKey,iconBytes);
try {
try {
ReturnMessage.send(this,false,new Value());
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
reactToMessages(handler);
}
 catch (RemoteDeathError e) {
if (!ignoreRemoteDeath) {
logger.log(TreeLogger.ERROR,e.getMessage(),e);
}
}
 finally {
handler.unloadModule(this,moduleName);
}
}","protected void processConnection() throws IOException, BrowserChannelException {
  MessageType type=Message.readMessageType(getStreamFromOtherSide());
  String url=null;
  String tabKey=null;
  String sessionKey=null;
  byte[] iconBytes=null;
switch (type) {
case OLD_LOAD_MODULE:
    OldLoadModuleMessage oldLoadModule=OldLoadModuleMessage.receive(this);
  if (oldLoadModule.getProtoVersion() != 1) {
    throw new BrowserChannelException(""String_Node_Str"");
  }
moduleName=oldLoadModule.getModuleName();
userAgent=oldLoadModule.getUserAgent();
protocolVersion=1;
HelpInfo helpInfo=new HelpInfo(){
@Override public String getAnchorText(){
return ""String_Node_Str"";
}
@Override public URL getURL(){
try {
return new URL(""String_Node_Str"");
}
 catch (MalformedURLException e) {
return null;
}
}
}
;
logger.log(TreeLogger.WARN,""String_Node_Str"" + ""String_Node_Str"",null,helpInfo);
break;
case CHECK_VERSIONS:
String connectError=null;
CheckVersionsMessage hello=CheckVersionsMessage.receive(this);
int minVersion=hello.getMinVersion();
int maxVersion=hello.getMaxVersion();
String hostedHtmlVersion=hello.getHostedHtmlVersion();
if (minVersion > PROTOCOL_VERSION_CURRENT || maxVersion < PROTOCOL_VERSION_OLDEST) {
connectError=""String_Node_Str"" + minVersion + ""String_Node_Str""+ maxVersion+ ""String_Node_Str""+ PROTOCOL_VERSION_OLDEST+ ""String_Node_Str""+ PROTOCOL_VERSION_CURRENT;
}
 else {
if (!HostedHtmlVersion.validHostedHtmlVersion(logger,hostedHtmlVersion)) {
new FatalErrorMessage(this,""String_Node_Str"").send();
return;
}
}
if (connectError != null) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + connectError,null);
new FatalErrorMessage(this,connectError).send();
return;
}
protocolVersion=Math.min(PROTOCOL_VERSION_CURRENT,maxVersion);
new ProtocolVersionMessage(this,protocolVersion).send();
type=Message.readMessageType(getStreamFromOtherSide());
if (type == MessageType.CHOOSE_TRANSPORT) {
ChooseTransportMessage chooseTransport=ChooseTransportMessage.receive(this);
String transport=selectTransport(chooseTransport.getTransports());
String transportArgs=null;
if (transport != null) {
transportArgs=createTransport(transport);
}
new SwitchTransportMessage(this,transport,transportArgs).send();
type=Message.readMessageType(getStreamFromOtherSide());
}
if (type != MessageType.LOAD_MODULE) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
LoadModuleMessage loadModule=LoadModuleMessage.receive(this);
url=loadModule.getUrl();
tabKey=loadModule.getTabKey();
sessionKey=loadModule.getSessionKey();
moduleName=loadModule.getModuleName();
userAgent=loadModule.getUserAgent();
break;
case REQUEST_PLUGIN:
logger.log(TreeLogger.ERROR,""String_Node_Str"");
new FatalErrorMessage(this,""String_Node_Str"").send();
return;
default :
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
if (protocolVersion >= PROTOCOL_VERSION_GET_ICON) {
synchronized (cacheLock) {
if (iconCache.containsKey(userAgent)) {
iconBytes=iconCache.get(userAgent);
}
 else {
RequestIconMessage.send(this);
type=Message.readMessageType(getStreamFromOtherSide());
if (type != MessageType.USER_AGENT_ICON) {
logger.log(TreeLogger.ERROR,""String_Node_Str"" + type + ""String_Node_Str"");
return;
}
UserAgentIconMessage uaIconMessage=UserAgentIconMessage.receive(this);
iconBytes=uaIconMessage.getIconBytes();
iconCache.put(userAgent,iconBytes);
}
}
}
Thread.currentThread().setName(""String_Node_Str"" + moduleName + ""String_Node_Str""+ userAgent+ ""String_Node_Str""+ url+ ""String_Node_Str""+ sessionKey);
logger=handler.loadModule(this,moduleName,userAgent,url,tabKey,sessionKey,iconBytes);
if (logger == null) {
try {
Value errMsg=new Value();
errMsg.setString(""String_Node_Str"" + moduleName);
ReturnMessage.send(this,true,errMsg);
return;
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
}
try {
try {
ReturnMessage.send(this,false,new Value());
}
 catch (IOException e) {
throw new RemoteDeathError(e);
}
reactToMessages(handler);
}
 catch (RemoteDeathError e) {
if (!ignoreRemoteDeath) {
logger.log(TreeLogger.ERROR,e.getMessage(),e);
}
}
 finally {
handler.unloadModule(this,moduleName);
}
}",0.9737363726461844
54319,"/** 
 * @param ccl
 * @param jsthis
 * @param methodName
 * @param args
 * @param returnJsValue
 * @throws Throwable
 */
public void invokeJavascript(CompilingClassLoader ccl,JsValueOOPHM jsthis,String methodName,JsValueOOPHM[] args,JsValueOOPHM returnJsValue) throws Throwable {
  final ServerObjectsTable remoteObjects=getJavaObjectsExposedInBrowser();
  Value vthis=convertFromJsValue(remoteObjects,jsthis);
  Value[] vargs=new Value[args.length];
  for (int i=0; i < args.length; ++i) {
    vargs[i]=convertFromJsValue(remoteObjects,args[i]);
  }
  try {
    InvokeOnClientMessage invokeMessage=new InvokeOnClientMessage(this,methodName,vthis,vargs);
    invokeMessage.send();
    final ReturnMessage msg=reactToMessagesWhileWaitingForReturn(handler);
    Value returnValue=msg.getReturnValue();
    convertToJsValue(ccl,remoteObjects,returnValue,returnJsValue);
    if (msg.isException()) {
      if (returnValue.isNull() || returnValue.isUndefined()) {
        throw ModuleSpace.createJavaScriptException(ccl,null);
      }
 else       if (returnValue.isString()) {
        throw ModuleSpace.createJavaScriptException(ccl,returnValue.getString());
      }
 else       if (returnValue.isJsObject()) {
        Object jso=JsValueGlue.createJavaScriptObject(returnJsValue,ccl);
        throw ModuleSpace.createJavaScriptException(ccl,jso);
      }
 else       if (returnValue.isJavaObject()) {
        Object object=remoteObjects.get(returnValue.getJavaObject().getRefid());
        Object target=((JsValueOOPHM.DispatchObjectOOPHM)object).getTarget();
        if (target instanceof Throwable) {
          throw (Throwable)(target);
        }
 else {
          throw ModuleSpace.createJavaScriptException(ccl,target);
        }
      }
      throw ModuleSpace.createJavaScriptException(ccl,returnValue.getValue().toString());
    }
  }
 catch (  IOException e) {
    throw new RemoteDeathError(e);
  }
catch (  BrowserChannelException e) {
    throw new RemoteDeathError(e);
  }
}","/** 
 * @param ccl
 * @param jsthis
 * @param methodName
 * @param args
 * @param returnJsValue
 * @throws Throwable
 */
public void invokeJavascript(CompilingClassLoader ccl,JsValueOOPHM jsthis,String methodName,JsValueOOPHM[] args,JsValueOOPHM returnJsValue) throws Throwable {
  final ServerObjectsTable remoteObjects=getJavaObjectsExposedInBrowser();
  Value vthis=convertFromJsValue(remoteObjects,jsthis);
  Value[] vargs=new Value[args.length];
  for (int i=0; i < args.length; ++i) {
    vargs[i]=convertFromJsValue(remoteObjects,args[i]);
  }
  try {
    InvokeOnClientMessage invokeMessage=new InvokeOnClientMessage(this,methodName,vthis,vargs);
    invokeMessage.send();
    final ReturnMessage msg=reactToMessagesWhileWaitingForReturn(handler);
    Value returnValue=msg.getReturnValue();
    convertToJsValue(ccl,remoteObjects,returnValue,returnJsValue);
    if (msg.isException()) {
      Object exceptionValue;
      if (returnValue.isNull() || returnValue.isUndefined()) {
        exceptionValue=null;
      }
 else       if (returnValue.isString()) {
        exceptionValue=returnValue.getString();
      }
 else       if (returnValue.isJsObject()) {
        exceptionValue=JsValueGlue.createJavaScriptObject(returnJsValue,ccl);
      }
 else       if (returnValue.isJavaObject()) {
        Object object=remoteObjects.get(returnValue.getJavaObject().getRefid());
        Object target=((JsValueOOPHM.DispatchObjectOOPHM)object).getTarget();
        if (target instanceof Throwable) {
          throw (Throwable)(target);
        }
 else {
          exceptionValue=target;
        }
      }
 else {
        exceptionValue=returnValue.getValue().toString();
      }
      RuntimeException exception=ModuleSpace.createJavaScriptException(ccl,exceptionValue);
      exception.fillInStackTrace();
      throw exception;
    }
  }
 catch (  IOException e) {
    throw new RemoteDeathError(e);
  }
catch (  BrowserChannelException e) {
    throw new RemoteDeathError(e);
  }
}",0.7883064516129032
54320,"protected ModuleSpace(TreeLogger logger,ModuleSpaceHost host,String moduleName,Object key){
  this.host=host;
  this.moduleName=moduleName;
  this.key=key;
  this.logger=logger;
  threadLocalLogger.set(host.getLogger());
}","protected ModuleSpace(TreeLogger logger,ModuleSpaceHost host,String moduleName){
  this.host=host;
  this.moduleName=moduleName;
  this.logger=logger;
  threadLocalLogger.set(host.getLogger());
}",0.935251798561151
54321,"public ModuleSpaceOOPHM(ModuleSpaceHost msh,String moduleName,BrowserChannelServer channel){
  super(msh.getLogger(),msh,moduleName,moduleName);
  this.channel=channel;
  msh.getLogger().log(TreeLogger.DEBUG,""String_Node_Str"" + moduleName,null);
}","public ModuleSpaceOOPHM(ModuleSpaceHost msh,String moduleName,BrowserChannelServer channel){
  super(msh.getLogger(),msh,moduleName);
  this.channel=channel;
  msh.getLogger().log(TreeLogger.DEBUG,""String_Node_Str"" + moduleName,null);
}",0.9772256728778468
54322,"@Override public synchronized TreeLogger loadModule(BrowserChannel channel,String moduleName,String userAgent,String url,String tabKey,String sessionKey,byte[] userAgentIcon){
  PerfLogger.start(""String_Node_Str"" + moduleName);
  BrowserChannelServer serverChannel=(BrowserChannelServer)channel;
  ModuleHandle moduleHandle=host.createModuleLogger(moduleName,userAgent,url,tabKey,sessionKey,serverChannel,userAgentIcon);
  TreeLogger logger=moduleHandle.getLogger();
  moduleHandleMap.put(serverChannel,moduleHandle);
  ModuleSpace moduleSpace=null;
  try {
    ModuleSpaceHost msh=host.createModuleSpaceHost(moduleHandle,moduleName);
    moduleSpace=new ModuleSpaceOOPHM(msh,moduleName,serverChannel);
    moduleMap.put(serverChannel,moduleSpace);
    PerfLogger.start(""String_Node_Str"");
    moduleSpace.onLoad(logger);
  }
 catch (  Throwable e) {
    moduleHandle.getLogger().log(TreeLogger.ERROR,""String_Node_Str"" + moduleName + ""String_Node_Str""+ userAgent+ ""String_Node_Str""+ channel.getRemoteEndpoint(),e);
    if (moduleSpace != null) {
      moduleSpace.dispose();
    }
    moduleHandle.unload();
    moduleMap.remove(serverChannel);
    moduleHandleMap.remove(serverChannel);
  }
 finally {
    PerfLogger.end();
    PerfLogger.end();
  }
  return moduleHandle.getLogger();
}","@Override public synchronized TreeLogger loadModule(BrowserChannel channel,String moduleName,String userAgent,String url,String tabKey,String sessionKey,byte[] userAgentIcon){
  PerfLogger.start(""String_Node_Str"" + moduleName);
  BrowserChannelServer serverChannel=(BrowserChannelServer)channel;
  ModuleHandle moduleHandle=host.createModuleLogger(moduleName,userAgent,url,tabKey,sessionKey,serverChannel,userAgentIcon);
  TreeLogger logger=moduleHandle.getLogger();
  moduleHandleMap.put(serverChannel,moduleHandle);
  ModuleSpace moduleSpace=null;
  try {
    ModuleSpaceHost msh=host.createModuleSpaceHost(moduleHandle,moduleName);
    moduleSpace=new ModuleSpaceOOPHM(msh,moduleName,serverChannel);
    moduleMap.put(serverChannel,moduleSpace);
    PerfLogger.start(""String_Node_Str"");
    moduleSpace.onLoad(logger);
  }
 catch (  Throwable e) {
    moduleHandle.getLogger().log(TreeLogger.ERROR,""String_Node_Str"" + moduleName + ""String_Node_Str""+ userAgent+ ""String_Node_Str""+ channel.getRemoteEndpoint(),e);
    if (moduleSpace != null) {
      moduleSpace.dispose();
    }
    moduleHandle.unload();
    moduleMap.remove(serverChannel);
    moduleHandleMap.remove(serverChannel);
    return null;
  }
 finally {
    PerfLogger.end();
    PerfLogger.end();
  }
  return moduleHandle.getLogger();
}",0.9934388267078348
54323,"/** 
 * @return full text of log event.
 */
public String getFullText(){
  StringBuffer sb=new StringBuffer();
  formatTimestamp(timestamp.getTime() - firstLog.getTime(),sb);
  sb.append(""String_Node_Str"");
  if (type != null) {
    sb.append(""String_Node_Str"");
    sb.append(type.getLabel());
    sb.append(""String_Node_Str"");
  }
  sb.append(htmlEscape(message));
  sb.append(""String_Node_Str"");
  if (exceptionDetail != null) {
    sb.append(""String_Node_Str"" + htmlEscape(exceptionDetail) + ""String_Node_Str"");
  }
  if (helpInfo != null) {
    URL url=helpInfo.getURL();
    String anchorText=helpInfo.getAnchorText();
    if (anchorText == null) {
      anchorText=url.toExternalForm();
    }
    String prefix=helpInfo.getPrefix();
    if (url != null) {
      sb.append(""String_Node_Str"" + prefix + ""String_Node_Str"");
      sb.append(url.toString());
      sb.append(""String_Node_Str"");
      sb.append(anchorText);
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  return sb.toString();
}","/** 
 * @return full text of log event.
 */
public String getFullText(){
  StringBuffer sb=new StringBuffer();
  formatTimestamp(timestamp.getTime() - firstLog.getTime(),sb);
  sb.append(""String_Node_Str"");
  if (type != null) {
    sb.append(""String_Node_Str"");
    sb.append(type.getLabel());
    sb.append(""String_Node_Str"");
  }
  sb.append(htmlEscape(message));
  sb.append(""String_Node_Str"");
  if (exceptionDetail != null) {
    sb.append(""String_Node_Str"" + htmlEscape(exceptionDetail) + ""String_Node_Str"");
  }
  if (helpInfo != null) {
    URL url=helpInfo.getURL();
    String anchorText=helpInfo.getAnchorText();
    if (anchorText == null && url != null) {
      anchorText=url.toExternalForm();
    }
    String prefix=helpInfo.getPrefix();
    if (url != null) {
      sb.append(""String_Node_Str"" + prefix + ""String_Node_Str"");
      sb.append(url.toString());
      sb.append(""String_Node_Str"");
      sb.append(anchorText);
      sb.append(""String_Node_Str"");
      sb.append(""String_Node_Str"");
    }
  }
  return sb.toString();
}",0.9927919269581932
54324,"/** 
 * The height of the scroll view of an element.
 */
public final native int getScrollWidth();","/** 
 * The width of the scroll view of an element.
 */
public final native int getScrollWidth();",0.953846153846154
54325,"protected static DivElement createRuler(Unit widthUnit,Unit heightUnit){
  DivElement ruler=Document.get().createDivElement();
  ruler.setInnerHTML(""String_Node_Str"");
  Style style=ruler.getStyle();
  style.setPosition(Position.ABSOLUTE);
  style.setZIndex(-32767);
  style.setLeft(-10000,PX);
  style.setWidth(10,widthUnit);
  style.setHeight(10,heightUnit);
  return ruler;
}","protected static DivElement createRuler(Unit widthUnit,Unit heightUnit){
  DivElement ruler=Document.get().createDivElement();
  ruler.setInnerHTML(""String_Node_Str"");
  Style style=ruler.getStyle();
  style.setPosition(Position.ABSOLUTE);
  style.setZIndex(-32767);
  style.setLeft(-20,widthUnit);
  style.setTop(-20,heightUnit);
  style.setWidth(10,widthUnit);
  style.setHeight(10,heightUnit);
  return ruler;
}",0.9393939393939394
54326,"/** 
 * @param classNames css class names to convert
 * @return map of the same class names in a form safe for use as Javaidentifiers, with the order of the input set preserved
 * @throws Failure on collisions due to conversions
 */
public Map<String,String> convertSet(Set<String> classNames) throws Failure {
  Map<String,String> rawToConverted=new LinkedHashMap<String,String>();
  Map<String,String> convertedToRaw=new LinkedHashMap<String,String>();
  for (  String className : classNames) {
    String converted=convertName(className);
    String already=convertedToRaw.get(converted);
    if (already != null) {
      throw new Failure(""String_Node_Str"",already,className);
    }
    if (!converted.equals(className)) {
      convertedToRaw.put(converted,className);
    }
    rawToConverted.put(className,converted);
  }
  return rawToConverted;
}","/** 
 * @param classNames css class names to convert
 * @return map of the same class names in a form safe for use as Javaidentifiers, with the order of the input set preserved
 * @throws Failure on collisions due to conversions
 */
public Map<String,String> convertSet(Set<String> classNames) throws Failure {
  Map<String,String> rawToConverted=new LinkedHashMap<String,String>();
  Map<String,String> convertedToRaw=new LinkedHashMap<String,String>();
  for (  String className : classNames) {
    String converted=convertName(className);
    String already=convertedToRaw.get(converted);
    if (already != null) {
      throw new Failure(""String_Node_Str"",already,className);
    }
    convertedToRaw.put(converted,className);
    rawToConverted.put(className,converted);
  }
  return rawToConverted;
}",0.8748495788206979
54327,"public void testSomeOp() throws CssNameConverter.Failure {
  Set<String> in=Sets.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Pair[] expected={new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str"")};
  Map<String,String> out=converter.convertSet(in);
  for (  Pair pair : expected) {
    String convert=out.remove(pair.before);
    assertEquals(pair.after,convert);
  }
  assertTrue(out.isEmpty());
}","public void testSomeOp() throws CssNameConverter.Failure {
  Set<String> in=makeOrderedSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Pair[] expected={new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str""),new Pair(""String_Node_Str"",""String_Node_Str"")};
  Map<String,String> out=converter.convertSet(in);
  for (  Pair pair : expected) {
    String convert=out.remove(pair.before);
    assertEquals(pair.after,convert);
  }
  assertTrue(out.isEmpty());
}",0.9802371541501976
54328,"public void testNoOp() throws CssNameConverter.Failure {
  Set<String> in=Sets.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Map<String,String> out=converter.convertSet(in);
  for (  Map.Entry<String,String> entry : out.entrySet()) {
    String key=entry.getKey();
    assertTrue(in.remove(key));
    assertEquals(key,entry.getValue());
  }
  assertTrue(in.isEmpty());
}","public void testNoOp() throws CssNameConverter.Failure {
  Set<String> in=makeOrderedSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Map<String,String> out=converter.convertSet(in);
  for (  Map.Entry<String,String> entry : out.entrySet()) {
    String key=entry.getKey();
    assertTrue(in.remove(key));
    assertEquals(key,entry.getValue());
  }
  assertTrue(in.isEmpty());
}",0.9694002447980417
54329,"public void testCollision(){
  Set<String> in=Sets.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  try {
    converter.convertSet(in);
  }
 catch (  CssNameConverter.Failure e) {
    assertContains(e.getMessage(),""String_Node_Str"");
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}","public void testCollision(){
  Set<String> in=makeOrderedSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  try {
    converter.convertSet(in);
    fail();
  }
 catch (  CssNameConverter.Failure e) {
    assertContains(e.getMessage(),""String_Node_Str"");
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}",0.6397608370702541
54330,"public void testReverseCollision(){
  Set<String> in=Sets.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  try {
    converter.convertSet(in);
  }
 catch (  CssNameConverter.Failure e) {
    assertContains(e.getMessage(),""String_Node_Str"");
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}","public void testReverseCollision(){
  Set<String> in=makeOrderedSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  try {
    converter.convertSet(in);
    fail();
  }
 catch (  CssNameConverter.Failure e) {
    assertContains(e.getMessage(),""String_Node_Str"");
    assertContains(e.getMessage(),""String_Node_Str"");
  }
}",0.6295754026354319
54331,"private boolean resolveMethod(TreeLogger logger,JRealClassType type,CollectMethodData methodData,TypeParameterLookup typeParamLookup){
  Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
  resolveAnnotations(logger,methodData.getAnnotations(),declaredAnnotations);
  String name=methodData.getName();
  if (""String_Node_Str"".equals(name) || (methodData.getAccess() & Opcodes.ACC_SYNTHETIC) != 0) {
    return true;
  }
  if (type.isEnum() != null && ""String_Node_Str"".equals(name)) {
    return true;
  }
  JAbstractMethod method;
  JTypeParameter[] typeParams=collectTypeParams(methodData.getSignature());
  typeParamLookup.pushScope(typeParams);
  boolean hasReturnType=true;
  if (""String_Node_Str"".equals(name)) {
    name=type.getSimpleSourceName();
    method=new JConstructor(type,name,declaredAnnotations,typeParams);
    hasReturnType=false;
  }
 else {
    if (type.isAnnotation() != null) {
      method=new JAnnotationMethod(type,name,typeParams,declaredAnnotations);
    }
 else {
      method=new JMethod(type,name,declaredAnnotations,typeParams);
    }
  }
  method.addModifierBits(mapBits(ASM_TO_SHARED_MODIFIERS,methodData.getAccess()));
  if (type.isInterface() != null) {
    method.addModifierBits(Shared.MOD_PUBLIC | Shared.MOD_ABSTRACT);
  }
  if ((methodData.getAccess() & Opcodes.ACC_VARARGS) != 0) {
    method.setVarArgs();
  }
  String signature=methodData.getSignature();
  Type[] argTypes=methodData.getArgTypes();
  String[] argNames=methodData.getArgNames();
  if (signature != null) {
    SignatureReader reader=new SignatureReader(signature);
    ResolveMethodSignature methodResolver=new ResolveMethodSignature(resolver,logger,method,typeParamLookup,hasReturnType,methodData,argTypes,argNames);
    reader.accept(methodResolver);
    if (!methodResolver.finish()) {
      return false;
    }
  }
 else {
    if (hasReturnType) {
      Type returnType=Type.getReturnType(methodData.getDesc());
      JType returnJType=resolveType(returnType);
      if (returnJType == null) {
        return false;
      }
      ((JMethod)method).setReturnType(returnJType);
    }
    if (!resolveParameters(logger,method,methodData)) {
      return false;
    }
  }
  if (!resolveThrows(method,methodData)) {
    return false;
  }
  typeParamLookup.popScope();
  return true;
}","private boolean resolveMethod(TreeLogger logger,JRealClassType type,CollectMethodData methodData,TypeParameterLookup typeParamLookup){
  Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
  resolveAnnotations(logger,methodData.getAnnotations(),declaredAnnotations);
  String name=methodData.getName();
  if (""String_Node_Str"".equals(name) || (methodData.getAccess() & Opcodes.ACC_SYNTHETIC) != 0) {
    return true;
  }
  if (type.isEnum() != null && ""String_Node_Str"".equals(name)) {
    return true;
  }
  JAbstractMethod method;
  JTypeParameter[] typeParams=collectTypeParams(methodData.getSignature());
  typeParamLookup.pushScope(typeParams);
  boolean hasReturnType=true;
  if (""String_Node_Str"".equals(name)) {
    name=type.getSimpleSourceName();
    method=new JConstructor(type,name,declaredAnnotations,typeParams);
    hasReturnType=false;
  }
 else {
    if (type.isAnnotation() != null) {
      method=new JAnnotationMethod(type,name,typeParams,declaredAnnotations);
    }
 else {
      method=new JMethod(type,name,declaredAnnotations,typeParams);
    }
  }
  method.addModifierBits(mapBits(ASM_TO_SHARED_MODIFIERS,methodData.getAccess()));
  if (type.isInterface() != null) {
    method.addModifierBits(Shared.MOD_PUBLIC | Shared.MOD_ABSTRACT);
  }
  if ((methodData.getAccess() & Opcodes.ACC_VARARGS) != 0) {
    method.setVarArgs();
  }
  String signature=methodData.getSignature();
  if (signature != null) {
    SignatureReader reader=new SignatureReader(signature);
    ResolveMethodSignature methodResolver=new ResolveMethodSignature(resolver,logger,method,typeParamLookup,hasReturnType,methodData,methodData.getArgTypes(),methodData.getArgNames(),methodData.hasActualArgNames());
    reader.accept(methodResolver);
    if (!methodResolver.finish()) {
      return false;
    }
  }
 else {
    if (hasReturnType) {
      Type returnType=Type.getReturnType(methodData.getDesc());
      JType returnJType=resolveType(returnType);
      if (returnJType == null) {
        return false;
      }
      ((JMethod)method).setReturnType(returnJType);
    }
    if (!resolveParameters(logger,method,methodData)) {
      return false;
    }
  }
  if (!resolveThrows(method,methodData)) {
    return false;
  }
  typeParamLookup.popScope();
  return true;
}",0.963183656097042
54332,"public ResolveMethodSignature(Resolver resolver,TreeLogger logger,JAbstractMethod method,TypeParameterLookup typeParamLookup,boolean hasReturnType,CollectMethodData methodData,Type[] argTypes,String[] argNames){
  this.resolver=resolver;
  this.logger=logger;
  this.method=method;
  this.typeParamLookup=typeParamLookup;
  this.hasReturnType=hasReturnType;
  this.methodData=methodData;
  this.argTypes=argTypes;
  this.argNames=argNames;
}","/** 
 * Resolve a method signature.
 * @param resolver
 * @param logger
 * @param method
 * @param typeParamLookup
 * @param hasReturnType
 * @param methodData
 * @param argTypes
 * @param argNames
 * @param argNamesAreReal
 */
public ResolveMethodSignature(Resolver resolver,TreeLogger logger,JAbstractMethod method,TypeParameterLookup typeParamLookup,boolean hasReturnType,CollectMethodData methodData,Type[] argTypes,String[] argNames,boolean argNamesAreReal){
  this.resolver=resolver;
  this.logger=logger;
  this.method=method;
  this.typeParamLookup=typeParamLookup;
  this.hasReturnType=hasReturnType;
  this.methodData=methodData;
  this.argTypes=argTypes;
  this.argNames=argNames;
  this.argNamesAreReal=argNamesAreReal;
}",0.7512776831345827
54333,"/** 
 * @return true if resolution succeeded.
 */
public boolean finish(){
  boolean failed=false;
  finishBound();
  if (hasReturnType) {
    failed|=(returnType[0] == null);
    ((JMethod)method).setReturnType(returnType[0]);
  }
  List<CollectAnnotationData>[] argAnnotations=methodData.getArgAnnotations();
  if (argTypes.length != params.size()) {
    throw new IllegalStateException(""String_Node_Str"" + methodData.getDesc() + ""String_Node_Str""+ methodData.getSignature()+ ""String_Node_Str"");
  }
  for (int i=0; i < argTypes.length; ++i) {
    JType argType=params.get(i)[0];
    if (argType == null) {
      failed=true;
      continue;
    }
    Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
    resolver.resolveAnnotations(logger,argAnnotations[i],declaredAnnotations);
    new JParameter(method,argType,argNames[i],declaredAnnotations);
  }
  for (  JType[] exc : exceptions) {
    if (exc[0] == null) {
      failed=true;
      continue;
    }
    method.addThrows(exc[0]);
  }
  return !failed;
}","/** 
 * @return true if resolution succeeded.
 */
public boolean finish(){
  boolean failed=false;
  finishBound();
  if (hasReturnType) {
    failed|=(returnType[0] == null);
    ((JMethod)method).setReturnType(returnType[0]);
  }
  List<CollectAnnotationData>[] argAnnotations=methodData.getArgAnnotations();
  if (argTypes.length != params.size()) {
    throw new IllegalStateException(""String_Node_Str"" + methodData.getDesc() + ""String_Node_Str""+ methodData.getSignature()+ ""String_Node_Str"");
  }
  for (int i=0; i < argTypes.length; ++i) {
    JType argType=params.get(i)[0];
    if (argType == null) {
      failed=true;
      continue;
    }
    Map<Class<? extends Annotation>,Annotation> declaredAnnotations=new HashMap<Class<? extends Annotation>,Annotation>();
    resolver.resolveAnnotations(logger,argAnnotations[i],declaredAnnotations);
    new JParameter(method,argType,argNames[i],declaredAnnotations,argNamesAreReal);
  }
  for (  JType[] exc : exceptions) {
    if (exc[0] == null) {
      failed=true;
      continue;
    }
    method.addThrows(exc[0]);
  }
  return !failed;
}",0.992653810835629
54334,"private void resolveMethodSignature(ReflectedMethod method,String signature){
  TypeParameterLookup lookup=new TypeParameterLookup();
  lookup.pushEnclosingScopes(method.getEnclosingType());
  lookup.pushScope(method.getTypeParameters());
  int access=Opcodes.ACC_PUBLIC;
  String desc=Type.getMethodDescriptor(method.getMethod());
  CollectMethodData methodData=new CollectMethodData(ClassType.TopLevel,access,method.getName(),desc,signature,null);
  Class<?>[] paramTypes=method.getMethod().getParameterTypes();
  int n=paramTypes.length;
  Type[] argTypes=new Type[n];
  String[] argNames=new String[n];
  for (int i=0; i < n; ++i) {
    argNames[i]=""String_Node_Str"" + i;
    argTypes[i]=Type.getType(paramTypes[i]);
  }
  ResolveMethodSignature methodResolver=new ResolveMethodSignature(resolver,failTreeLogger,method,lookup,true,methodData,argTypes,argNames);
  new SignatureReader(signature).accept(methodResolver);
  methodResolver.finish();
}","private void resolveMethodSignature(ReflectedMethod method,String signature){
  TypeParameterLookup lookup=new TypeParameterLookup();
  lookup.pushEnclosingScopes(method.getEnclosingType());
  lookup.pushScope(method.getTypeParameters());
  int access=Opcodes.ACC_PUBLIC;
  String desc=Type.getMethodDescriptor(method.getMethod());
  CollectMethodData methodData=new CollectMethodData(ClassType.TopLevel,access,method.getName(),desc,signature,null);
  Class<?>[] paramTypes=method.getMethod().getParameterTypes();
  int n=paramTypes.length;
  Type[] argTypes=new Type[n];
  String[] argNames=new String[n];
  for (int i=0; i < n; ++i) {
    argNames[i]=""String_Node_Str"" + i;
    argTypes[i]=Type.getType(paramTypes[i]);
  }
  ResolveMethodSignature methodResolver=new ResolveMethodSignature(resolver,failTreeLogger,method,lookup,true,methodData,argTypes,argNames,false);
  new SignatureReader(signature).accept(methodResolver);
  methodResolver.finish();
}",0.9968553459119496
54335,"/** 
 * Adds new units to an existing TypeOracle.
 */
public void addNewUnits(TreeLogger logger,Collection<CompilationUnit> units){
  PerfLogger.start(""String_Node_Str"");
  classMap=new HashMap<String,CollectClassData>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      CollectClassData cv=processClass(compiledClass);
      if (!cv.hasNoExternalName()) {
        classMap.put(compiledClass.getInternalName(),cv);
      }
    }
  }
  classMapType=new HashMap<JRealClassType,CollectClassData>();
  Set<JRealClassType> unresolvedTypes=new HashSet<JRealClassType>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      String internalName=compiledClass.getInternalName();
      CollectClassData cv=classMap.get(internalName);
      if (cv == null) {
        continue;
      }
      JRealClassType type=createType(compiledClass,unresolvedTypes);
      if (type != null) {
        if (unit instanceof SourceFileCompilationUnit) {
          SourceFileCompilationUnit sourceUnit=(SourceFileCompilationUnit)unit;
          Resource sourceFile=sourceUnit.getSourceFile();
          typeOracle.addSourceReference(type,sourceFile);
        }
        binaryMapper.put(internalName,type);
        classMapType.put(type,cv);
      }
    }
  }
  TreeLogger branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"");
  for (Iterator<JRealClassType> it=unresolvedTypes.iterator(); it.hasNext(); ) {
    JRealClassType type=it.next();
    if (!resolveEnclosingClass(branch,type)) {
      it.remove();
    }
  }
  for (  JRealClassType type : unresolvedTypes) {
    branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"" + type.getQualifiedSourceName());
    if (!resolveClass(branch,type)) {
    }
  }
  typeOracle.finish();
  classMap=null;
  classMapType=null;
  PerfLogger.end();
}","/** 
 * Adds new units to an existing TypeOracle.
 * @param logger logger to use
 * @param units collection of compilation units to process 
 */
public void addNewUnits(TreeLogger logger,Collection<CompilationUnit> units){
  PerfLogger.start(""String_Node_Str"");
  classMap=new HashMap<String,CollectClassData>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      CollectClassData cv=processClass(compiledClass);
      if (!cv.hasNoExternalName()) {
        classMap.put(compiledClass.getInternalName(),cv);
      }
    }
  }
  classMapType=new HashMap<JRealClassType,CollectClassData>();
  Set<JRealClassType> unresolvedTypes=new HashSet<JRealClassType>();
  for (  CompilationUnit unit : units) {
    if (!unit.isCompiled()) {
      continue;
    }
    Collection<CompiledClass> compiledClasses=unit.getCompiledClasses();
    for (    CompiledClass compiledClass : compiledClasses) {
      String internalName=compiledClass.getInternalName();
      CollectClassData cv=classMap.get(internalName);
      if (cv == null) {
        continue;
      }
      JRealClassType type=createType(compiledClass,unresolvedTypes);
      if (type != null) {
        if (unit instanceof SourceFileCompilationUnit) {
          SourceFileCompilationUnit sourceUnit=(SourceFileCompilationUnit)unit;
          Resource sourceFile=sourceUnit.getSourceFile();
          typeOracle.addSourceReference(type,sourceFile);
        }
        binaryMapper.put(internalName,type);
        classMapType.put(type,cv);
      }
    }
  }
  TreeLogger branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"");
  for (Iterator<JRealClassType> it=unresolvedTypes.iterator(); it.hasNext(); ) {
    JRealClassType type=it.next();
    if (!resolveEnclosingClass(branch,type)) {
      it.remove();
    }
  }
  for (  JRealClassType type : unresolvedTypes) {
    branch=logger.branch(TreeLogger.SPAM,""String_Node_Str"" + type.getQualifiedSourceName());
    if (!resolveClass(branch,type)) {
    }
  }
  typeOracle.finish();
  classMap=null;
  classMapType=null;
  PerfLogger.end();
}",0.9791044776119404
54336,"/** 
 * Collects data about a class which only needs the bytecode and no TypeOracle data structures. This is used to make the initial shallow identity pass for creating JRealClassType/JGenericType objects.
 */
private CollectClassData processClass(CompiledClass compiledClass){
  byte[] classBytes=compiledClass.getBytes();
  ClassReader reader=new ClassReader(classBytes);
  CollectClassData mcv=new CollectClassData(classBytes);
  ClassVisitor cv=mcv;
  if (false) {
    cv=new TraceClassVisitor(cv,new PrintWriter(System.out));
  }
  reader.accept(cv,0);
  return mcv;
}","/** 
 * Collects data about a class which only needs the bytecode and no TypeOracle data structures. This is used to make the initial shallow identity pass for creating JRealClassType/JGenericType objects.
 */
private CollectClassData processClass(CompiledClass compiledClass){
  byte[] classBytes=compiledClass.getBytes();
  ClassReader reader=new ClassReader(classBytes);
  CollectClassData mcv=new CollectClassData();
  ClassVisitor cv=mcv;
  if (false) {
    cv=new TraceClassVisitor(cv,new PrintWriter(System.out));
  }
  reader.accept(cv,0);
  return mcv;
}",0.9911971830985916
54337,"/** 
 * Returns the binary name of a type. This is the same name that would be returned by   {@link Class#getName()} for this type.
 */
public static String computeBinaryClassName(JType type){
  JPrimitiveType primitiveType=type.isPrimitive();
  if (primitiveType != null) {
    return primitiveType.getJNISignature();
  }
  JArrayType arrayType=type.isArray();
  if (arrayType != null) {
    JType component=arrayType.getComponentType();
    if (component.isClassOrInterface() != null) {
      return ""String_Node_Str"" + computeBinaryClassName(arrayType.getComponentType()) + ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"" + computeBinaryClassName(arrayType.getComponentType());
    }
  }
  JParameterizedType parameterizedType=type.isParameterized();
  if (parameterizedType != null) {
    return computeBinaryClassName(parameterizedType.getBaseType());
  }
  JClassType classType=type.isClassOrInterface();
  assert(classType != null);
  JClassType enclosingType=classType.getEnclosingType();
  if (enclosingType != null) {
    return computeBinaryClassName(enclosingType) + ""String_Node_Str"" + classType.getSimpleSourceName();
  }
  return classType.getQualifiedSourceName();
}","/** 
 * Returns the binary name of a type. This is the same name that would be returned by   {@link Class#getName()} for this type.
 * @param type TypeOracle type to get the name for
 * @return binary name for a type 
 */
public static String computeBinaryClassName(JType type){
  JPrimitiveType primitiveType=type.isPrimitive();
  if (primitiveType != null) {
    return primitiveType.getJNISignature();
  }
  JArrayType arrayType=type.isArray();
  if (arrayType != null) {
    JType component=arrayType.getComponentType();
    if (component.isClassOrInterface() != null) {
      return ""String_Node_Str"" + computeBinaryClassName(arrayType.getComponentType()) + ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"" + computeBinaryClassName(arrayType.getComponentType());
    }
  }
  JParameterizedType parameterizedType=type.isParameterized();
  if (parameterizedType != null) {
    return computeBinaryClassName(parameterizedType.getBaseType());
  }
  JClassType classType=type.isClassOrInterface();
  assert(classType != null);
  JClassType enclosingType=classType.getEnclosingType();
  if (enclosingType != null) {
    return computeBinaryClassName(enclosingType) + ""String_Node_Str"" + classType.getSimpleSourceName();
  }
  return classType.getQualifiedSourceName();
}",0.9653505237711524
54338,"public Map<String,JRealClassType> getBinaryMapper(){
  return binaryMapper;
}","/** 
 * @return a map from binary class names to JRealClassType.
 */
public Map<String,JRealClassType> getBinaryMapper(){
  return binaryMapper;
}",0.6905829596412556
54339,"public TypeOracleMediator(TypeOracle typeOracle){
  if (typeOracle == null) {
    typeOracle=new TypeOracle();
  }
  this.typeOracle=typeOracle;
  resolver=new Resolver(){
    public Map<String,JRealClassType> getBinaryMapper(){
      return TypeOracleMediator.this.binaryMapper;
    }
    public TypeOracle getTypeOracle(){
      return TypeOracleMediator.this.typeOracle;
    }
    public boolean resolveAnnotation(    TreeLogger logger,    CollectAnnotationData annotVisitor,    Map<Class<? extends Annotation>,Annotation> declaredAnnotations){
      return TypeOracleMediator.this.resolveAnnotation(logger,annotVisitor,declaredAnnotations);
    }
    public boolean resolveAnnotations(    TreeLogger logger,    List<CollectAnnotationData> annotations,    Map<Class<? extends Annotation>,Annotation> declaredAnnotations){
      return TypeOracleMediator.this.resolveAnnotations(logger,annotations,declaredAnnotations);
    }
    public boolean resolveClass(    TreeLogger logger,    JRealClassType type){
      return TypeOracleMediator.this.resolveClass(logger,type);
    }
  }
;
}","/** 
 * Construct a TypeOracleMediator.
 * @param typeOracle TypeOracle instance to use, or null to create a new one
 */
public TypeOracleMediator(TypeOracle typeOracle){
  if (typeOracle == null) {
    typeOracle=new TypeOracle();
  }
  this.typeOracle=typeOracle;
  resolver=new Resolver(){
    public Map<String,JRealClassType> getBinaryMapper(){
      return TypeOracleMediator.this.binaryMapper;
    }
    public TypeOracle getTypeOracle(){
      return TypeOracleMediator.this.typeOracle;
    }
    public boolean resolveAnnotation(    TreeLogger logger,    CollectAnnotationData annotVisitor,    Map<Class<? extends Annotation>,Annotation> declaredAnnotations){
      return TypeOracleMediator.this.resolveAnnotation(logger,annotVisitor,declaredAnnotations);
    }
    public boolean resolveAnnotations(    TreeLogger logger,    List<CollectAnnotationData> annotations,    Map<Class<? extends Annotation>,Annotation> declaredAnnotations){
      return TypeOracleMediator.this.resolveAnnotations(logger,annotations,declaredAnnotations);
    }
    public boolean resolveClass(    TreeLogger logger,    JRealClassType type){
      return TypeOracleMediator.this.resolveClass(logger,type);
    }
  }
;
}",0.947184635530336
54340,"public TypeOracle getTypeOracle(){
  return typeOracle;
}","/** 
 * @return the TypeOracle managed by the mediator.
 */
public TypeOracle getTypeOracle(){
  return typeOracle;
}",0.6551724137931034
54341,"public AnnotationEnum(String desc,String value){
  this.desc=desc;
  this.value=value;
}","/** 
 * Construct the value of an Enum-valued annotation.
 * @param desc type descriptor of this enum
 * @param value actual value in this enum
 */
public AnnotationEnum(String desc,String value){
  this.desc=desc;
  this.value=value;
}",0.5432098765432098
54342,"public void CollectClassData(byte[] bytes){
  this.bytes=bytes;
}","/** 
 * Construct a visitor that will collect data about a class.
 */
public void CollectClassData(){
}",0.3928571428571428
54343,"/** 
 * @return the access
 */
public int getAccess(){
  return access;
}","/** 
 * @return the access flags for this class (ie, bitwise or of Opcodes.ACC_*).
 */
public int getAccess(){
  return access;
}",0.7227722772277227
54344,"/** 
 * @return the interfaces
 */
public String[] getInterfaces(){
  return interfaces;
}","/** 
 * @return an array of internal names of interfaces implemented by this class.
 */
public String[] getInterfaces(){
  return interfaces;
}",0.7639484978540773
54345,"/** 
 * @return annotations on this class
 */
public List<CollectAnnotationData> getAnnotations(){
  return annotations;
}","/** 
 * @return a list of annotations on this class.
 */
public List<CollectAnnotationData> getAnnotations(){
  return annotations;
}",0.9568627450980391
54346,"/** 
 * @return the value
 */
public String getValue(){
  return value;
}","/** 
 * @return the annotation value.
 */
public String getValue(){
  return value;
}",0.9240506329113924
54347,"public boolean isAnonymous(){
  return classType == ClassType.Anonymous;
}","/** 
 * @return true if this class has no source name at all.
 */
public boolean isAnonymous(){
  return classType == ClassType.Anonymous;
}",0.6915887850467289
54348,"/** 
 * @return the fields
 */
public List<CollectFieldData> getFields(){
  return fields;
}","/** 
 * @return a list of fields in this class.
 */
public List<CollectFieldData> getFields(){
  return fields;
}",0.8780487804878049
54349,"/** 
 * @return the descriptor
 */
public String getDesc(){
  return desc;
}","/** 
 * @return the type descriptor of the enum type.
 */
public String getDesc(){
  return desc;
}",0.8685714285714285
54350,"public boolean hasNoExternalName(){
  return classType == ClassType.Anonymous || classType == ClassType.Local;
}","/** 
 * @return true if this class has no external name (ie, is defined insidea method).
 */
public boolean hasNoExternalName(){
  return classType.hasNoExternalName();
}",0.4468085106382978
54351,"public boolean hasHiddenConstructorArg(){
  return false;
}","/** 
 * @return true if this class type has a hidden constructor argumentfor the containing instance (ie, this$0).
 */
public boolean hasHiddenConstructorArg(){
  return false;
}",0.4978902953586498
54352,"@SuppressWarnings(""String_Node_Str"") public CollectMethodData(CollectClassData.ClassType classType,int access,String name,String desc,String signature,String[] exceptions){
  this.access=access;
  this.name=name;
  this.desc=desc;
  this.signature=signature;
  this.exceptions=exceptions;
  syntheticArgs=0;
  argTypes=Type.getArgumentTypes(desc);
  if (classType.hasHiddenConstructorArg() && ""String_Node_Str"".equals(name)) {
    syntheticArgs=1;
    int n=argTypes.length - syntheticArgs;
    Type[] newArgTypes=new Type[n];
    System.arraycopy(argTypes,syntheticArgs,newArgTypes,0,n);
    argTypes=newArgTypes;
  }
  argNames=new String[argTypes.length];
  paramAnnots=new List[argTypes.length];
  for (int i=0; i < argNames.length; ++i) {
    argNames[i]=""String_Node_Str"" + i;
    paramAnnots[i]=new ArrayList<CollectAnnotationData>();
  }
}","/** 
 * Prepare to collect data for a method from bytecode.
 * @param classType
 * @param access
 * @param name
 * @param desc
 * @param signature
 * @param exceptions
 */
@SuppressWarnings(""String_Node_Str"") public CollectMethodData(CollectClassData.ClassType classType,int access,String name,String desc,String signature,String[] exceptions){
  this.access=access;
  this.name=name;
  this.desc=desc;
  this.signature=signature;
  this.exceptions=exceptions;
  syntheticArgs=0;
  argTypes=Type.getArgumentTypes(desc);
  if (classType.hasHiddenConstructorArg() && ""String_Node_Str"".equals(name)) {
    if (argTypes.length < 1) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    syntheticArgs=1;
    int n=argTypes.length - syntheticArgs;
    Type[] newArgTypes=new Type[n];
    System.arraycopy(argTypes,syntheticArgs,newArgTypes,0,n);
    argTypes=newArgTypes;
  }
  argNames=new String[argTypes.length];
  paramAnnots=new List[argTypes.length];
  for (int i=0; i < argNames.length; ++i) {
    argNames[i]=""String_Node_Str"" + i;
    paramAnnots[i]=new ArrayList<CollectAnnotationData>();
  }
}",0.8638449770525243
54353,"/** 
 * Attempts to get a named configuration property. Throws <code>BadPropertyValueException</code> if the property is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 */
ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named configuration property. Throws <code>BadPropertyValueException</code> if the property is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param propertyName 
 * @return the configuration property instance (never null)
 * @throws BadPropertyValueException if the property is unknown or not aconfiguration property
 */
ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException ;",0.7861409796893668
54354,"/** 
 * Attempts to get a named deferred binding property or configuration property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return a value for the property
 */
@Deprecated String getPropertyValue(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property or configuration property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return a value for the property
 * @throws BadPropertyValueException if the property is unknown or not of theright type
 */
@Deprecated String getPropertyValue(TreeLogger logger,String propertyName) throws BadPropertyValueException ;",0.9229422066549912
54355,"/** 
 * Attempts to get a named deferred binding property and returns the list of possible values. Throws <code>BadPropertyValueException</code> if the property is a configuration property or is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return the possible values for the property
 */
@Deprecated String[] getPropertyValueSet(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property and returns the list of possible values. Throws <code>BadPropertyValueException</code> if the property is a configuration property or is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return the possible values for the property
 * @throws BadPropertyValueException if the property is unknown or not of theright type 
 */
@Deprecated String[] getPropertyValueSet(TreeLogger logger,String propertyName) throws BadPropertyValueException ;",0.9247675401521556
54356,"/** 
 * Attempts to get a named deferred binding property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 */
SelectionProperty getSelectionProperty(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger 
 * @param propertyName 
 * @return the selection property instance (never null)
 * @throws BadPropertyValueException if the property is unknown or not aselection property
 */
SelectionProperty getSelectionProperty(TreeLogger logger,String propertyName) throws BadPropertyValueException ;",0.8025078369905956
54357,"public com.google.gwt.core.ext.ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException {
  for (  final ConfigurationProperty prop : configProps) {
    if (prop.getName().equals(propertyName)) {
      return new com.google.gwt.core.ext.ConfigurationProperty(){
        public String getName(){
          return prop.getName();
        }
        public List<String> getValues(){
          return prop.getValues();
        }
      }
;
    }
  }
  throw new BadPropertyValueException(propertyName);
}","public com.google.gwt.core.ext.ConfigurationProperty getConfigurationProperty(String propertyName) throws BadPropertyValueException {
  for (  final ConfigurationProperty prop : configProps) {
    if (prop.getName().equals(propertyName)) {
      return new DefaultConfigurationProperty(prop.getName(),prop.getValues());
    }
  }
  throw new BadPropertyValueException(propertyName);
}",0.7473002159827213
54358,"public String[] getOrderedPropValues(){
  return orderedPropValues;
}","/** 
 * @return an array of binding property values.
 */
public String[] getOrderedPropValues(){
  return orderedPropValues;
}",0.7076923076923077
54359,"public BindingProperty[] getOrderedProps(){
  return orderedProps;
}","/** 
 * @return an array of binding properties.
 */
public BindingProperty[] getOrderedProps(){
  return orderedProps;
}",0.723404255319149
54360,"public StaticPropertyOracle(BindingProperty[] orderedProps,String[] orderedPropValues,ConfigurationProperty[] configProps){
  this.orderedProps=orderedProps;
  this.orderedPropValues=orderedPropValues;
  this.configProps=configProps;
  int len=orderedProps.length;
  for (int i=0; i < len; i++) {
    BindingProperty prop=orderedProps[i];
    String value=orderedPropValues[i];
    if (!prop.isAllowedValue(value)) {
      throw new IllegalArgumentException(""String_Node_Str"" + prop.getName() + ""String_Node_Str""+ value);
    }
  }
}","/** 
 * Create a property oracle that will return the supplied values.
 * @param orderedProps array of binding properties
 * @param orderedPropValues values of the above binding properties
 * @param configProps array of config properties
 */
public StaticPropertyOracle(BindingProperty[] orderedProps,String[] orderedPropValues,ConfigurationProperty[] configProps){
  this.orderedProps=orderedProps;
  this.orderedPropValues=orderedPropValues;
  this.configProps=configProps;
  int len=orderedProps.length;
  for (int i=0; i < len; i++) {
    BindingProperty prop=orderedProps[i];
    String value=orderedPropValues[i];
    if (!prop.isAllowedValue(value)) {
      throw new IllegalArgumentException(""String_Node_Str"" + prop.getName() + ""String_Node_Str""+ value);
    }
  }
}",0.8149847094801224
54361,"public com.google.gwt.core.ext.SelectionProperty getSelectionProperty(TreeLogger logger,String propertyName) throws BadPropertyValueException {
  for (int i=0; i < orderedProps.length; i++) {
    final BindingProperty prop=orderedProps[i];
    final String name=prop.getName();
    final String fallback=prop.getFallback();
    if (name.equals(propertyName)) {
      final String value=orderedPropValues[i];
      String[] values=prop.getDefinedValues();
      final TreeSet<String> possibleValues=new TreeSet<String>();
      for (      String v : values) {
        possibleValues.add(v);
      }
      return new com.google.gwt.core.ext.SelectionProperty(){
        public String getCurrentValue(){
          return value;
        }
        public String getFallbackValue(){
          return fallback;
        }
        public String getName(){
          return name;
        }
        public SortedSet<String> getPossibleValues(){
          return possibleValues;
        }
      }
;
    }
  }
  throw new BadPropertyValueException(propertyName);
}","public com.google.gwt.core.ext.SelectionProperty getSelectionProperty(TreeLogger logger,String propertyName) throws BadPropertyValueException {
  for (int i=0; i < orderedProps.length; i++) {
    final BindingProperty prop=orderedProps[i];
    final String name=prop.getName();
    if (name.equals(propertyName)) {
      final String value=orderedPropValues[i];
      String[] values=prop.getDefinedValues();
      final TreeSet<String> possibleValues=new TreeSet<String>();
      for (      String v : values) {
        possibleValues.add(v);
      }
      return new DefaultSelectionProperty(value,prop.getFallback(),name,possibleValues);
    }
  }
  throw new BadPropertyValueException(propertyName);
}",0.7323462414578588
54362,"/** 
 * Invoke a JS method and return its value.
 * @param name method name to invoke
 * @param jthis object to invoke method on, null if static method
 * @param types argument types
 * @param args argument values
 */
@Override protected JsValue doInvoke(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  TreeLogger branch=host.getLogger().branch(TreeLogger.DEBUG,""String_Node_Str"" + name,null);
  CompilingClassLoader isolatedClassLoader=getIsolatedClassLoader();
  JsValueOOPHM jsthis=new JsValueOOPHM();
  Class<?> jthisType=(jthis == null) ? Object.class : jthis.getClass();
  JsValueGlue.set(jsthis,isolatedClassLoader,jthisType,jthis);
  branch.log(TreeLogger.SPAM,""String_Node_Str"" + jsthis);
  int argc=args.length;
  JsValueOOPHM argv[]=new JsValueOOPHM[argc];
  for (int i=0; i < argc; ++i) {
    argv[i]=new JsValueOOPHM();
    JsValueGlue.set(argv[i],isolatedClassLoader,types[i],args[i]);
    branch.log(TreeLogger.SPAM,""String_Node_Str"" + i + ""String_Node_Str""+ argv[i]);
  }
  JsValueOOPHM returnVal=new JsValueOOPHM();
  try {
    channel.invokeJavascript(isolatedClassLoader,jsthis,name,argv,returnVal);
    branch.log(TreeLogger.SPAM,""String_Node_Str"" + returnVal);
  }
 catch (  Throwable t) {
    branch.log(TreeLogger.DEBUG,""String_Node_Str"",t);
    throw t;
  }
  return returnVal;
}","/** 
 * Invoke a JS method and return its value.
 * @param name method name to invoke
 * @param jthis object to invoke method on, null if static method
 * @param types argument types
 * @param args argument values
 */
@Override protected JsValue doInvoke(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  TreeLogger branch=host.getLogger().branch(TreeLogger.SPAM,""String_Node_Str"" + name,null);
  CompilingClassLoader isolatedClassLoader=getIsolatedClassLoader();
  JsValueOOPHM jsthis=new JsValueOOPHM();
  Class<?> jthisType=(jthis == null) ? Object.class : jthis.getClass();
  JsValueGlue.set(jsthis,isolatedClassLoader,jthisType,jthis);
  branch.log(TreeLogger.SPAM,""String_Node_Str"" + jsthis);
  int argc=args.length;
  JsValueOOPHM argv[]=new JsValueOOPHM[argc];
  for (int i=0; i < argc; ++i) {
    argv[i]=new JsValueOOPHM();
    JsValueGlue.set(argv[i],isolatedClassLoader,types[i],args[i]);
    branch.log(TreeLogger.SPAM,""String_Node_Str"" + i + ""String_Node_Str""+ argv[i]);
  }
  JsValueOOPHM returnVal=new JsValueOOPHM();
  try {
    channel.invokeJavascript(isolatedClassLoader,jsthis,name,argv,returnVal);
    branch.log(TreeLogger.SPAM,""String_Node_Str"" + returnVal);
  }
 catch (  Throwable t) {
    branch.log(TreeLogger.SPAM,""String_Node_Str"",t);
    throw t;
  }
  return returnVal;
}",0.9932432432432432
54363,"/** 
 * Return true if we are running on a Mac.
 */
private static boolean isMac(){
  String lcOSName=System.getProperty(""String_Node_Str"").toLowerCase();
  return lcOSName.startsWith(""String_Node_Str"");
}","/** 
 * Return true if we are running on a Mac.
 */
private static boolean isMac(){
  String lcOSName=System.getProperty(""String_Node_Str"").toLowerCase(Locale.ENGLISH);
  return lcOSName.startsWith(""String_Node_Str"");
}",0.9669811320754716
54364,"public static String checkHost(String hostUnderConsideration,Set<String> hosts){
  hostUnderConsideration=hostUnderConsideration.toLowerCase();
  for (  String rule : hosts) {
    if (hostUnderConsideration.matches(""String_Node_Str"" + rule + ""String_Node_Str"")) {
      return rule;
    }
  }
  return null;
}","public static String checkHost(String hostUnderConsideration,Set<String> hosts){
  hostUnderConsideration=hostUnderConsideration.toLowerCase(Locale.ENGLISH);
  for (  String rule : hosts) {
    if (hostUnderConsideration.matches(""String_Node_Str"" + rule + ""String_Node_Str"")) {
      return rule;
    }
  }
  return null;
}",0.9778481012658228
54365,"static String suggestServletName(String servletClass){
  int pos=servletClass.lastIndexOf('.');
  String suggest=(pos < 0) ? servletClass : servletClass.substring(pos + 1);
  suggest=Character.toLowerCase(suggest.charAt(0)) + suggest.substring(1);
  return suggest;
}","static String suggestServletName(String servletClass){
  int pos=servletClass.lastIndexOf('.');
  String suggest=(pos < 0) ? servletClass : servletClass.substring(pos + 1);
  String firstChar=suggest.substring(0,1).toLowerCase(Locale.ENGLISH);
  suggest=firstChar + suggest.substring(1);
  return suggest;
}",0.7804878048780488
54366,"private Set<String> getSuppressedWarnings(MethodDeclaration method){
  Annotation[] annotations=method.annotations;
  if (annotations == null) {
    return Sets.create();
  }
  for (  Annotation a : annotations) {
    if (SuppressWarnings.class.getName().equals(CharOperation.toString(((ReferenceBinding)a.resolvedType).compoundName))) {
      for (      MemberValuePair pair : a.memberValuePairs()) {
        if (String.valueOf(pair.name).equals(""String_Node_Str"")) {
          Expression valueExpr=pair.value;
          if (valueExpr instanceof StringLiteral) {
            return Sets.create(((StringLiteral)valueExpr).constant.stringValue().toLowerCase());
          }
 else           if (valueExpr instanceof ArrayInitializer) {
            ArrayInitializer ai=(ArrayInitializer)valueExpr;
            String[] values=new String[ai.expressions.length];
            for (int i=0, j=values.length; i < j; i++) {
              values[i]=((StringLiteral)ai.expressions[i]).constant.stringValue().toLowerCase();
            }
            return Sets.create(values);
          }
 else {
            throw new InternalCompilerException(""String_Node_Str"");
          }
        }
      }
    }
  }
  return Sets.create();
}","private Set<String> getSuppressedWarnings(MethodDeclaration method){
  Annotation[] annotations=method.annotations;
  if (annotations == null) {
    return Sets.create();
  }
  for (  Annotation a : annotations) {
    if (SuppressWarnings.class.getName().equals(CharOperation.toString(((ReferenceBinding)a.resolvedType).compoundName))) {
      for (      MemberValuePair pair : a.memberValuePairs()) {
        if (String.valueOf(pair.name).equals(""String_Node_Str"")) {
          Expression valueExpr=pair.value;
          if (valueExpr instanceof StringLiteral) {
            return Sets.create(((StringLiteral)valueExpr).constant.stringValue().toLowerCase(Locale.ENGLISH));
          }
 else           if (valueExpr instanceof ArrayInitializer) {
            ArrayInitializer ai=(ArrayInitializer)valueExpr;
            String[] values=new String[ai.expressions.length];
            for (int i=0, j=values.length; i < j; i++) {
              values[i]=((StringLiteral)ai.expressions[i]).constant.stringValue().toLowerCase(Locale.ENGLISH);
            }
            return Sets.create(values);
          }
 else {
            throw new InternalCompilerException(""String_Node_Str"");
          }
        }
      }
    }
  }
  return Sets.create();
}",0.9886455798864558
54367,"public static ClassPathEntry createEntryForUrl(TreeLogger logger,URL url) throws URISyntaxException, IOException {
  if (url.getProtocol().equals(""String_Node_Str"")) {
    File f=new File(url.toURI());
    String lowerCaseFileName=f.getName().toLowerCase();
    if (f.isDirectory()) {
      return new DirectoryClassPathEntry(f);
    }
 else     if (f.isFile() && lowerCaseFileName.endsWith(""String_Node_Str"")) {
      return new ZipFileClassPathEntry(new JarFile(f));
    }
 else     if (f.isFile() && lowerCaseFileName.endsWith(""String_Node_Str"")) {
      return new ZipFileClassPathEntry(new ZipFile(f));
    }
 else {
      try {
        return new ZipFileClassPathEntry(new JarFile(f));
      }
 catch (      Exception ignored) {
      }
      try {
        return new ZipFileClassPathEntry(new ZipFile(f));
      }
 catch (      Exception ignored) {
      }
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + f + ""String_Node_Str"");
      return null;
    }
  }
 else {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + url,null);
    return null;
  }
}","public static ClassPathEntry createEntryForUrl(TreeLogger logger,URL url) throws URISyntaxException, IOException {
  if (url.getProtocol().equals(""String_Node_Str"")) {
    File f=new File(url.toURI());
    String lowerCaseFileName=f.getName().toLowerCase(Locale.ENGLISH);
    if (f.isDirectory()) {
      return new DirectoryClassPathEntry(f);
    }
 else     if (f.isFile() && lowerCaseFileName.endsWith(""String_Node_Str"")) {
      return new ZipFileClassPathEntry(new JarFile(f));
    }
 else     if (f.isFile() && lowerCaseFileName.endsWith(""String_Node_Str"")) {
      return new ZipFileClassPathEntry(new ZipFile(f));
    }
 else {
      try {
        return new ZipFileClassPathEntry(new JarFile(f));
      }
 catch (      Exception ignored) {
      }
      try {
        return new ZipFileClassPathEntry(new ZipFile(f));
      }
 catch (      Exception ignored) {
      }
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + f + ""String_Node_Str"");
      return null;
    }
  }
 else {
    logger.log(TreeLogger.WARN,""String_Node_Str"" + url,null);
    return null;
  }
}",0.9934579439252336
54368,"/** 
 * This method checks the host to see if it is in the supplied set of regexes.
 * @param hostUnderConsideration the host to be checked
 * @param hosts the set of regexes to be checked against
 * @return true if the host matches
 */
public static String checkHost(String hostUnderConsideration,Set<String> hosts){
  hostUnderConsideration=hostUnderConsideration.toLowerCase();
  for (  String rule : hosts) {
    rule=rule.toLowerCase();
    if (hostUnderConsideration.matches(""String_Node_Str"" + rule + ""String_Node_Str"")) {
      return rule;
    }
  }
  return null;
}","/** 
 * This method checks the host to see if it is in the supplied set of regexes.
 * @param hostUnderConsideration the host to be checked
 * @param hosts the set of regexes to be checked against
 * @return true if the host matches
 */
public static String checkHost(String hostUnderConsideration,Set<String> hosts){
  hostUnderConsideration=hostUnderConsideration.toLowerCase(Locale.ENGLISH);
  for (  String rule : hosts) {
    rule=rule.toLowerCase(Locale.ENGLISH);
    if (hostUnderConsideration.matches(""String_Node_Str"" + rule + ""String_Node_Str"")) {
      return rule;
    }
  }
  return null;
}",0.9762308998302208
54369,"public static CheckForUpdates createUpdateChecker(TreeLogger logger,String entryPoint){
  if (System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"")) {
    return new CheckForUpdatesIE6(logger,entryPoint);
  }
 else {
    return new CheckForUpdates(logger,entryPoint);
  }
}","public static CheckForUpdates createUpdateChecker(TreeLogger logger,String entryPoint){
  if (System.getProperty(""String_Node_Str"").toLowerCase(Locale.ENGLISH).contains(""String_Node_Str"")) {
    return new CheckForUpdatesIE6(logger,entryPoint);
  }
 else {
    return new CheckForUpdates(logger,entryPoint);
  }
}",0.977124183006536
54370,"/** 
 * Retrieve a short name, suitable for use in a tab or filename, for a given user agent.
 * @param userAgent
 * @return short name of user agent
 */
public static String getShortName(String userAgent){
  String lcAgent=userAgent.toLowerCase();
  if (lcAgent.contains(""String_Node_Str"")) {
    return IE;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return CHROME;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return OPERA;
  }
 else   if (lcAgent.contains(""String_Node_Str"") || lcAgent.contains(""String_Node_Str"")) {
    return SAFARI;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return FIREFOX;
  }
  return UNKNOWN;
}","/** 
 * Retrieve a short name, suitable for use in a tab or filename, for a given user agent.
 * @param userAgent
 * @return short name of user agent
 */
public static String getShortName(String userAgent){
  String lcAgent=userAgent.toLowerCase(Locale.ENGLISH);
  if (lcAgent.contains(""String_Node_Str"")) {
    return IE;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return CHROME;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return OPERA;
  }
 else   if (lcAgent.contains(""String_Node_Str"") || lcAgent.contains(""String_Node_Str"")) {
    return SAFARI;
  }
 else   if (lcAgent.contains(""String_Node_Str"")) {
    return FIREFOX;
  }
  return UNKNOWN;
}",0.9896142433234422
54371,"public int handle(String[] args,int startIndex){
  if (startIndex + 1 < args.length) {
    String style=args[startIndex + 1].toLowerCase();
    if (style.startsWith(""String_Node_Str"")) {
      option.setOutput(JsOutputOption.OBFUSCATED);
      return 1;
    }
 else     if (""String_Node_Str"".equals(style)) {
      option.setOutput(JsOutputOption.PRETTY);
      return 1;
    }
 else     if (""String_Node_Str"".equals(style)) {
      option.setOutput(JsOutputOption.DETAILED);
      return 1;
    }
  }
  System.err.println(getTag() + ""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return -1;
}","public int handle(String[] args,int startIndex){
  if (startIndex + 1 < args.length) {
    String style=args[startIndex + 1].toLowerCase(Locale.ENGLISH);
    if (style.startsWith(""String_Node_Str"")) {
      option.setOutput(JsOutputOption.OBFUSCATED);
      return 1;
    }
 else     if (""String_Node_Str"".equals(style)) {
      option.setOutput(JsOutputOption.PRETTY);
      return 1;
    }
 else     if (""String_Node_Str"".equals(style)) {
      option.setOutput(JsOutputOption.DETAILED);
      return 1;
    }
  }
  System.err.println(getTag() + ""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  return -1;
}",0.9886363636363636
54372,"public void testNonOverlappingPrefixesNonEmptyFilter(){
  PathPrefixSet pps=new PathPrefixSet();
  ResourceFilter allowsGifs=new ResourceFilter(){
    public boolean allows(    String path){
      return path.toLowerCase().endsWith(""String_Node_Str"");
    }
  }
;
  PathPrefix pp1=new PathPrefix(""String_Node_Str"",allowsGifs);
  PathPrefix pp2=new PathPrefix(""String_Node_Str"",allowsGifs);
  pps.add(pp1);
  pps.add(pp2);
  assertEquals(pp1,pps.includesResource(""String_Node_Str""));
  assertEquals(pp2,pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
}","public void testNonOverlappingPrefixesNonEmptyFilter(){
  PathPrefixSet pps=new PathPrefixSet();
  ResourceFilter allowsGifs=new ResourceFilter(){
    public boolean allows(    String path){
      return path.toLowerCase(Locale.ENGLISH).endsWith(""String_Node_Str"");
    }
  }
;
  PathPrefix pp1=new PathPrefix(""String_Node_Str"",allowsGifs);
  PathPrefix pp2=new PathPrefix(""String_Node_Str"",allowsGifs);
  pps.add(pp1);
  pps.add(pp2);
  assertEquals(pp1,pps.includesResource(""String_Node_Str""));
  assertEquals(pp2,pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
  assertNull(pps.includesResource(""String_Node_Str""));
}",0.9915356711003628
54373,"private void writeClassSerializationStatements(){
  if (typesSentToBrowser.maybeEnhanced(serializableClass) && typesSentFromBrowser.maybeEnhanced(serializableClass)) {
    sourceWriter.println(""String_Node_Str"" + WEAK_MAPPING_CLASS_NAME + ""String_Node_Str"");
  }
  for (  JField serializableField : serializableFields) {
    JType fieldType=serializableField.getType();
    String writeMethodName=Shared.getStreamWriteMethodNameFor(fieldType);
    sourceWriter.print(""String_Node_Str"");
    sourceWriter.print(writeMethodName);
    sourceWriter.print(""String_Node_Str"");
    if (needsAccessorMethods(serializableField)) {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(Shared.capitalize(serializableField.getName()));
      sourceWriter.println(""String_Node_Str"");
    }
 else {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(serializableField.getName());
      sourceWriter.println(""String_Node_Str"");
    }
  }
  sourceWriter.println();
  JClassType superClass=serializableClass.getSuperclass();
  if (superClass != null && (typesSentFromBrowser.isSerializable(superClass) || typesSentToBrowser.isSerializable(superClass))) {
    String fieldSerializerName=SerializationUtils.getFieldSerializerName(typeOracle,superClass);
    sourceWriter.print(fieldSerializerName);
    sourceWriter.println(""String_Node_Str"");
  }
}","private void writeClassSerializationStatements(){
  if (serializableClass.isEnhanced()) {
    sourceWriter.println(""String_Node_Str"" + WEAK_MAPPING_CLASS_NAME + ""String_Node_Str"");
  }
  for (  JField serializableField : serializableFields) {
    JType fieldType=serializableField.getType();
    String writeMethodName=Shared.getStreamWriteMethodNameFor(fieldType);
    sourceWriter.print(""String_Node_Str"");
    sourceWriter.print(writeMethodName);
    sourceWriter.print(""String_Node_Str"");
    if (needsAccessorMethods(serializableField)) {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(Shared.capitalize(serializableField.getName()));
      sourceWriter.println(""String_Node_Str"");
    }
 else {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(serializableField.getName());
      sourceWriter.println(""String_Node_Str"");
    }
  }
  sourceWriter.println();
  JClassType superClass=serializableClass.getSuperclass();
  if (superClass != null && (typesSentFromBrowser.isSerializable(superClass) || typesSentToBrowser.isSerializable(superClass))) {
    String fieldSerializerName=SerializationUtils.getFieldSerializerName(typeOracle,superClass);
    sourceWriter.print(fieldSerializerName);
    sourceWriter.println(""String_Node_Str"");
  }
}",0.9562923888470234
54374,"private void writeClassDeserializationStatements(){
  if (typesSentToBrowser.maybeEnhanced(serializableClass) && typesSentFromBrowser.maybeEnhanced(serializableClass)) {
    sourceWriter.println(WEAK_MAPPING_CLASS_NAME + ""String_Node_Str"" + ""String_Node_Str"");
  }
  for (  JField serializableField : serializableFields) {
    JType fieldType=serializableField.getType();
    String readMethodName=Shared.getStreamReadMethodNameFor(fieldType);
    String streamReadExpression=""String_Node_Str"" + readMethodName + ""String_Node_Str"";
    if (Shared.typeNeedsCast(fieldType)) {
      streamReadExpression=""String_Node_Str"" + fieldType.getQualifiedSourceName() + ""String_Node_Str""+ streamReadExpression;
    }
    if (needsAccessorMethods(serializableField)) {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(Shared.capitalize(serializableField.getName()));
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(streamReadExpression);
      sourceWriter.println(""String_Node_Str"");
    }
 else {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(serializableField.getName());
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(streamReadExpression);
      sourceWriter.println(""String_Node_Str"");
    }
  }
  sourceWriter.println();
  JClassType superClass=serializableClass.getSuperclass();
  if (superClass != null && (typesSentFromBrowser.isSerializable(superClass) || typesSentToBrowser.isSerializable(superClass))) {
    String fieldSerializerName=SerializationUtils.getFieldSerializerName(typeOracle,superClass);
    sourceWriter.print(fieldSerializerName);
    sourceWriter.println(""String_Node_Str"");
  }
}","private void writeClassDeserializationStatements(){
  if (serializableClass.isEnhanced()) {
    sourceWriter.println(WEAK_MAPPING_CLASS_NAME + ""String_Node_Str"" + ""String_Node_Str"");
  }
  for (  JField serializableField : serializableFields) {
    JType fieldType=serializableField.getType();
    String readMethodName=Shared.getStreamReadMethodNameFor(fieldType);
    String streamReadExpression=""String_Node_Str"" + readMethodName + ""String_Node_Str"";
    if (Shared.typeNeedsCast(fieldType)) {
      streamReadExpression=""String_Node_Str"" + fieldType.getQualifiedSourceName() + ""String_Node_Str""+ streamReadExpression;
    }
    if (needsAccessorMethods(serializableField)) {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(Shared.capitalize(serializableField.getName()));
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(streamReadExpression);
      sourceWriter.println(""String_Node_Str"");
    }
 else {
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(serializableField.getName());
      sourceWriter.print(""String_Node_Str"");
      sourceWriter.print(streamReadExpression);
      sourceWriter.println(""String_Node_Str"");
    }
  }
  sourceWriter.println();
  JClassType superClass=serializableClass.getSuperclass();
  if (superClass != null && (typesSentFromBrowser.isSerializable(superClass) || typesSentToBrowser.isSerializable(superClass))) {
    String fieldSerializerName=SerializationUtils.getFieldSerializerName(typeOracle,superClass);
    sourceWriter.print(fieldSerializerName);
    sourceWriter.println(""String_Node_Str"");
  }
}",0.9648058252427184
54375,"protected String writeSerializationPolicyFile(TreeLogger logger,GeneratorContext ctx,SerializableTypeOracle serializationSto,SerializableTypeOracle deserializationSto) throws UnableToCompleteException {
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    OutputStreamWriter osw=new OutputStreamWriter(baos,SerializationPolicyLoader.SERIALIZATION_POLICY_FILE_ENCODING);
    TypeOracle oracle=ctx.getTypeOracle();
    PrintWriter pw=new PrintWriter(osw);
    JType[] serializableTypes=unionOfTypeArrays(serializationSto.getSerializableTypes(),deserializationSto.getSerializableTypes(),new JType[]{serviceIntf});
    for (int i=0; i < serializableTypes.length; ++i) {
      JType type=serializableTypes[i];
      String binaryTypeName=TypeOracleMediator.computeBinaryClassName(type);
      pw.print(binaryTypeName);
      pw.print(""String_Node_Str"" + Boolean.toString(deserializationSto.isSerializable(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(deserializationSto.maybeInstantiated(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(serializationSto.isSerializable(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(serializationSto.maybeInstantiated(type)));
      pw.print(""String_Node_Str"" + typeStrings.get(type));
      pw.print(""String_Node_Str"" + SerializationUtils.getSerializationSignature(oracle,type));
      pw.print('\n');
      if ((type instanceof JClassType) && serializationSto.maybeEnhanced(type) && deserializationSto.maybeEnhanced(type)) {
        JField[] fields=((JClassType)type).getFields();
        JField[] rpcFields=new JField[fields.length];
        int numRpcFields=0;
        for (        JField f : fields) {
          if (f.isTransient() || f.isStatic() || f.isFinal()) {
            continue;
          }
          rpcFields[numRpcFields++]=f;
        }
        pw.print(SerializationPolicyLoader.CLIENT_FIELDS_KEYWORD);
        pw.print(',');
        pw.print(binaryTypeName);
        for (int idx=0; idx < numRpcFields; idx++) {
          pw.print(',');
          pw.print(rpcFields[idx].getName());
        }
        pw.print('\n');
      }
    }
    pw.close();
    byte[] serializationPolicyFileContents=baos.toByteArray();
    String serializationPolicyName=Util.computeStrongName(serializationPolicyFileContents);
    String serializationPolicyFileName=SerializationPolicyLoader.getSerializationPolicyFileName(serializationPolicyName);
    OutputStream os=ctx.tryCreateResource(logger,serializationPolicyFileName);
    if (os != null) {
      os.write(serializationPolicyFileContents);
      GeneratedResource resource=ctx.commitResource(logger,os);
      ctx.commitArtifact(logger,new RpcPolicyFileArtifact(serviceIntf.getQualifiedSourceName(),resource));
    }
 else {
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + serviceIntf.getQualifiedSourceName() + ""String_Node_Str"",null);
    }
    return serializationPolicyName;
  }
 catch (  UnsupportedEncodingException e) {
    logger.log(TreeLogger.ERROR,SerializationPolicyLoader.SERIALIZATION_POLICY_FILE_ENCODING + ""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
catch (  IOException e) {
    logger.log(TreeLogger.ERROR,null,e);
    throw new UnableToCompleteException();
  }
}","protected String writeSerializationPolicyFile(TreeLogger logger,GeneratorContext ctx,SerializableTypeOracle serializationSto,SerializableTypeOracle deserializationSto) throws UnableToCompleteException {
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    OutputStreamWriter osw=new OutputStreamWriter(baos,SerializationPolicyLoader.SERIALIZATION_POLICY_FILE_ENCODING);
    TypeOracle oracle=ctx.getTypeOracle();
    PrintWriter pw=new PrintWriter(osw);
    JType[] serializableTypes=unionOfTypeArrays(serializationSto.getSerializableTypes(),deserializationSto.getSerializableTypes(),new JType[]{serviceIntf});
    for (int i=0; i < serializableTypes.length; ++i) {
      JType type=serializableTypes[i];
      String binaryTypeName=TypeOracleMediator.computeBinaryClassName(type);
      pw.print(binaryTypeName);
      pw.print(""String_Node_Str"" + Boolean.toString(deserializationSto.isSerializable(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(deserializationSto.maybeInstantiated(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(serializationSto.isSerializable(type)));
      pw.print(""String_Node_Str"" + Boolean.toString(serializationSto.maybeInstantiated(type)));
      pw.print(""String_Node_Str"" + typeStrings.get(type));
      pw.print(""String_Node_Str"" + SerializationUtils.getSerializationSignature(oracle,type));
      pw.print('\n');
      if ((type instanceof JClassType) && ((JClassType)type).isEnhanced()) {
        JField[] fields=((JClassType)type).getFields();
        JField[] rpcFields=new JField[fields.length];
        int numRpcFields=0;
        for (        JField f : fields) {
          if (f.isTransient() || f.isStatic() || f.isFinal()) {
            continue;
          }
          rpcFields[numRpcFields++]=f;
        }
        pw.print(SerializationPolicyLoader.CLIENT_FIELDS_KEYWORD);
        pw.print(',');
        pw.print(binaryTypeName);
        for (int idx=0; idx < numRpcFields; idx++) {
          pw.print(',');
          pw.print(rpcFields[idx].getName());
        }
        pw.print('\n');
      }
    }
    pw.close();
    byte[] serializationPolicyFileContents=baos.toByteArray();
    String serializationPolicyName=Util.computeStrongName(serializationPolicyFileContents);
    String serializationPolicyFileName=SerializationPolicyLoader.getSerializationPolicyFileName(serializationPolicyName);
    OutputStream os=ctx.tryCreateResource(logger,serializationPolicyFileName);
    if (os != null) {
      os.write(serializationPolicyFileContents);
      GeneratedResource resource=ctx.commitResource(logger,os);
      ctx.commitArtifact(logger,new RpcPolicyFileArtifact(serviceIntf.getQualifiedSourceName(),resource));
    }
 else {
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + serviceIntf.getQualifiedSourceName() + ""String_Node_Str"",null);
    }
    return serializationPolicyName;
  }
 catch (  UnsupportedEncodingException e) {
    logger.log(TreeLogger.ERROR,SerializationPolicyLoader.SERIALIZATION_POLICY_FILE_ENCODING + ""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
catch (  IOException e) {
    logger.log(TreeLogger.ERROR,null,e);
    throw new UnableToCompleteException();
  }
}",0.9862207772100944
54376,"/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=computeTypeInstantiability(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems).hasInstantiableSubtypes();
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyEnhancedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (!(tic.getType() instanceof JClassType)) {
      continue;
    }
    JClassType type=(JClassType)tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if ((enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName())) || tic.maybeEnhanced()) {
      possiblyEnhancedTypes.add(type);
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes,possiblyEnhancedTypes);
}","/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=computeTypeInstantiability(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems).hasInstantiableSubtypes();
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (!(tic.getType() instanceof JClassType)) {
      continue;
    }
    JClassType type=(JClassType)tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if (tic.maybeEnhanced() || (enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName()))) {
      type.setEnhanced();
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes);
}",0.8894451397580309
54377,"public SerializableTypeOracleImpl(Set<JClassType> serializableTypes,Set<JClassType> possiblyInstantiatedTypes,Set<JClassType> possiblyEnhancedTypes){
  serializableTypesSet=serializableTypes;
  this.possiblyInstantiatedTypes=possiblyInstantiatedTypes;
  this.possiblyEnhancedTypes=possiblyEnhancedTypes;
}","public SerializableTypeOracleImpl(Set<JClassType> serializableTypes,Set<JClassType> possiblyInstantiatedTypes){
  serializableTypesSet=serializableTypes;
  this.possiblyInstantiatedTypes=possiblyInstantiatedTypes;
}",0.8269230769230769
54378,"/** 
 * Set any created BrowserChannelServers to ignore remote deaths. <p>This is most commonly wanted by JUnitShell.
 * @param ignoreRemoteDeath
 */
public void setIgnoreRemoteDeath(boolean ignoreRemoteDeath){
  this.ignoreRemoteDeath=ignoreRemoteDeath;
}","/** 
 * Set any created BrowserChannelServers to ignore remote deaths. <p> This is most commonly wanted by JUnitShell.
 * @param ignoreRemoteDeath
 */
public void setIgnoreRemoteDeath(boolean ignoreRemoteDeath){
  this.ignoreRemoteDeath=ignoreRemoteDeath;
}",0.9980506822612084
54379,"/** 
 * Create a new instance using the given streams and request processor. Closing either stream will cause the termination of the transport.
 * @param inputStream an input stream for reading messages
 * @param outputStream an output stream for writing messages
 * @param requestProcessor a callback interface for handling remote clientrequests
 */
public MessageTransport(final InputStream inputStream,final OutputStream outputStream,RequestProcessor requestProcessor){
  this.requestProcessor=requestProcessor;
  serverRequestExecutor=Executors.newFixedThreadPool(DEFAULT_SERVICE_THREADS);
  messageProcessingThread=new Thread(new Runnable(){
    public void run(){
      try {
        while (true) {
          Message message=Message.parseDelimitedFrom(inputStream);
          processMessage(message);
        }
      }
 catch (      IOException e) {
        terminateDueToException(e);
      }
catch (      InterruptedException e) {
        terminateDueToException(e);
      }
    }
  }
);
  messageProcessingThread.start();
  sendThread=new Thread(new Runnable(){
    public void run(){
      while (true) {
        try {
          PendingSend pendingSend=sendQueue.take();
          try {
            pendingSend.send(outputStream);
          }
 catch (          IOException e) {
            pendingSend.failed(e);
          }
        }
 catch (        InterruptedException e) {
          break;
        }
      }
    }
  }
);
  sendThread.setDaemon(true);
  sendThread.start();
}","/** 
 * Create a new instance using the given streams and request processor. Closing either stream will cause the termination of the transport.
 * @param inputStream an input stream for reading messages
 * @param outputStream an output stream for writing messages
 * @param requestProcessor a callback interface for handling remote clientrequests
 * @param terminationCallback a callback that is invoked when the transportterminates
 */
public MessageTransport(final InputStream inputStream,final OutputStream outputStream,RequestProcessor requestProcessor,TerminationCallback terminationCallback){
  this.requestProcessor=requestProcessor;
  this.terminationCallback=terminationCallback;
  serverRequestExecutor=Executors.newFixedThreadPool(DEFAULT_SERVICE_THREADS);
  messageProcessingThread=new Thread(new Runnable(){
    public void run(){
      try {
        while (true) {
          Message message=Message.parseDelimitedFrom(inputStream);
          processMessage(message);
        }
      }
 catch (      IOException e) {
        terminateDueToException(e);
      }
catch (      InterruptedException e) {
        terminateDueToException(e);
      }
    }
  }
);
  messageProcessingThread.start();
  sendThread=new Thread(new Runnable(){
    public void run(){
      while (true) {
        try {
          PendingSend pendingSend=sendQueue.take();
          try {
            pendingSend.send(outputStream);
          }
 catch (          IOException e) {
            pendingSend.failed(e);
          }
        }
 catch (        InterruptedException e) {
          break;
        }
      }
    }
  }
);
  sendThread.setDaemon(true);
  sendThread.start();
}",0.9447619047619048
54380,"private void terminateDueToException(Exception e){
  pendingRequestMap.blockAdds(e);
}","private void terminateDueToException(Exception e){
  pendingRequestMap.blockAdds(e);
  if (terminationCallback != null) {
    terminationCallback.onTermination(e);
  }
}",0.6745098039215687
54381,"public RemoteUI(String host,int port,String clientId,int webServerPort,int browserChannelPort){
  try {
    this.clientId=clientId;
    this.browserChannelPort=browserChannelPort;
    this.webServerPort=webServerPort;
    Socket socket=new Socket(host,port);
    devModeRequestProcessor=new DevModeServiceRequestProcessor(this);
    transport=new MessageTransport(socket.getInputStream(),socket.getOutputStream(),devModeRequestProcessor);
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","public RemoteUI(String host,int port,String clientId,int webServerPort,int browserChannelPort){
  try {
    this.clientId=clientId;
    this.browserChannelPort=browserChannelPort;
    this.webServerPort=webServerPort;
    Socket socket=new Socket(host,port);
    socket.setKeepAlive(true);
    socket.setTcpNoDelay(true);
    devModeRequestProcessor=new DevModeServiceRequestProcessor(this);
    transport=new MessageTransport(socket.getInputStream(),socket.getOutputStream(),devModeRequestProcessor,this);
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9449838187702264
54382,"public void makeTopLevelShell() throws IOException {
  String permutationId=getPermutationId();
  PrintWriter outFile=new PrintWriter(getOutFile(""String_Node_Str"" + ""String_Node_Str"" + getPermutationId() + ""String_Node_Str""));
  addStandardHtmlProlog(outFile,""String_Node_Str"" + permutationId,""String_Node_Str"" + permutationId,""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getInitialCodeBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getTotalCodeBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getLeftoversBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  if (globalInformation.getSplitPointToLocation().size() > 1) {
    int numSplitPoints=globalInformation.getSplitPointToLocation().size();
    float maxSize=globalInformation.getTotalCodeBreakdown().sizeAllCode;
    for (int i=FRAGMENT_NUMBER_TOTAL_PROGRAM; i <= numSplitPoints + 1; i++) {
      SizeBreakdown breakdown;
      if (i == FRAGMENT_NUMBER_TOTAL_PROGRAM) {
        continue;
      }
 else       if (i == numSplitPoints + 1) {
        continue;
      }
 else       if (i == FRAGMENT_NUMBER_INITIAL_DOWNLOAD) {
        continue;
      }
 else {
        breakdown=globalInformation.splitPointCodeBreakdown(i);
      }
      String drillDownFileName=shellFileName(breakdown,getPermutationId());
      String splitPointDescription=globalInformation.getSplitPointToLocation().get(i);
      float size=breakdown.sizeAllCode;
      float ratio;
      ratio=(size / maxSize) * 100;
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"" + i + ""String_Node_Str"");
      outFile.println(""String_Node_Str"" + drillDownFileName + ""String_Node_Str""+ splitPointDescription+ ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"" + ratio + ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println((int)size + ""String_Node_Str"" + formatNumber(ratio)+ ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"");
    }
  }
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  addStandardHtmlEnding(outFile);
  outFile.close();
}","public void makeTopLevelShell() throws IOException {
  String permutationId=getPermutationId();
  PrintWriter outFile=new PrintWriter(getOutFile(""String_Node_Str"" + ""String_Node_Str"" + getPermutationId() + ""String_Node_Str""));
  addStandardHtmlProlog(outFile,""String_Node_Str"" + permutationId,""String_Node_Str"" + permutationId,""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getTotalCodeBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getInitialCodeBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"" + globalInformation.getLeftoversBreakdown().sizeAllCode + ""String_Node_Str"");
  outFile.println(""String_Node_Str"" + permutationId + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  if (globalInformation.getSplitPointToLocation().size() >= 1) {
    int numSplitPoints=globalInformation.getSplitPointToLocation().size();
    float maxSize=globalInformation.getTotalCodeBreakdown().sizeAllCode;
    for (int i=FRAGMENT_NUMBER_TOTAL_PROGRAM; i <= numSplitPoints + 1; i++) {
      SizeBreakdown breakdown;
      if (i == FRAGMENT_NUMBER_TOTAL_PROGRAM) {
        continue;
      }
 else       if (i == numSplitPoints + 1) {
        continue;
      }
 else       if (i == FRAGMENT_NUMBER_INITIAL_DOWNLOAD) {
        continue;
      }
 else {
        breakdown=globalInformation.splitPointCodeBreakdown(i);
      }
      String drillDownFileName=shellFileName(breakdown,getPermutationId());
      String splitPointDescription=globalInformation.getSplitPointToLocation().get(i);
      float size=breakdown.sizeAllCode;
      float ratio;
      ratio=(size / maxSize) * 100;
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"" + i + ""String_Node_Str"");
      outFile.println(""String_Node_Str"" + drillDownFileName + ""String_Node_Str""+ splitPointDescription+ ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"" + ratio + ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println((int)size + ""String_Node_Str"" + formatNumber(ratio)+ ""String_Node_Str"");
      outFile.println(""String_Node_Str"");
      outFile.println(""String_Node_Str"");
    }
  }
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  addStandardHtmlEnding(outFile);
  outFile.close();
}",0.9328161795262502
54383,"@Override protected void doCommitBranch(AbstractTreeLogger childBeingCommitted,Type type,String msg,Throwable caught,HelpInfo helpInfo){
  SwingTreeLogger commitChild=(SwingTreeLogger)childBeingCommitted;
  LogEvent logEvent=new LogEvent(commitChild,true,commitChild.getBranchedIndex(),type,msg,caught,helpInfo);
  commitChild.treeNode=new DefaultMutableTreeNode(logEvent);
  addUpdate(logEvent);
}","@Override protected void doCommitBranch(AbstractTreeLogger childBeingCommitted,Type type,String msg,Throwable caught,HelpInfo helpInfo){
}",0.5149253731343284
54384,"/** 
 * Constructs the top-level TreeItemLogger.
 * @param panel
 */
public SwingTreeLogger(SwingLoggerPanel panel){
  this.panel=panel;
  treeNode=(DefaultMutableTreeNode)panel.treeModel.getRoot();
}","/** 
 * Used to create a branch treelogger, supplying a tree node to use rather than the panel's.
 * @param panel
 * @param treeNode
 */
private SwingTreeLogger(SwingLoggerPanel panel,DefaultMutableTreeNode treeNode){
  this.panel=panel;
  this.treeNode=treeNode;
}",0.3698924731182795
54385,"private int findInsertionPoint(DefaultMutableTreeNode parent,int index){
  int high=parent.getChildCount() - 1;
  if (high < 0) {
    return 0;
  }
  int low=0;
  while (low <= high) {
    final int mid=low + ((high - low) >> 1);
    DefaultMutableTreeNode midChild=(DefaultMutableTreeNode)parent.getChildAt(mid);
    final Object userObject=midChild.getUserObject();
    int compIdx=-1;
    if (userObject instanceof LogEvent) {
      LogEvent event=(LogEvent)userObject;
      compIdx=event.index;
    }
    if (compIdx < index) {
      low=mid + 1;
    }
 else     if (compIdx > index) {
      high=mid - 1;
    }
 else {
      return mid;
    }
  }
  return low;
}","private int findInsertionPoint(DefaultMutableTreeNode parentNode,int index){
  int high=parentNode.getChildCount() - 1;
  if (high < 0) {
    return 0;
  }
  int low=0;
  while (low <= high) {
    final int mid=low + ((high - low) >> 1);
    DefaultMutableTreeNode midChild=(DefaultMutableTreeNode)parentNode.getChildAt(mid);
    final Object userObject=midChild.getUserObject();
    int compIdx=-1;
    if (userObject instanceof LogEvent) {
      LogEvent event=(LogEvent)userObject;
      compIdx=event.index;
    }
    if (compIdx < index) {
      low=mid + 1;
    }
 else     if (compIdx > index) {
      high=mid - 1;
    }
 else {
      return mid;
    }
  }
  return low;
}",0.9910979228486648
54386,"/** 
 * Update this log event's inherited priority, which is the highest priority of this event and any child events.
 * @param inheritedPriority
 * @return true if the priority was upgraded
 */
public boolean updateInheritedPriority(Type inheritedPriority){
  if (this.inheritedPriority.isLowerPriorityThan(inheritedPriority)) {
    this.inheritedPriority=inheritedPriority;
    return true;
  }
  return false;
}","/** 
 * Update this log event's inherited priority, which is the highest priority of this event and any child events.
 * @param childPriority
 * @return true if the priority was upgraded
 */
public boolean updateInheritedPriority(Type childPriority){
  if (this.inheritedPriority.isLowerPriorityThan(childPriority)) {
    this.inheritedPriority=childPriority;
    return true;
  }
  return false;
}",0.9408866995073892
54387,"public LogEvent(SwingTreeLogger logger,boolean isBranchCommit,int index,Type type,String message,Throwable caught,HelpInfo helpInfo){
  this.childLogger=logger;
  this.isBranchCommit=isBranchCommit;
  this.index=index;
  this.type=type;
  this.inheritedPriority=type;
  this.message=message;
  this.helpInfo=helpInfo;
  this.timestamp=new Date();
  this.exceptionDetail=AbstractTreeLogger.getStackTraceAsString(caught);
  this.exceptionName=AbstractTreeLogger.getExceptionName(caught);
}","/** 
 * Create a log event.
 * @param logger
 * @param isBranchCommit
 * @param index
 * @param type
 * @param message
 * @param caught
 * @param helpInfo
 */
public LogEvent(SwingTreeLogger logger,boolean isBranchCommit,int index,Type type,String message,Throwable caught,HelpInfo helpInfo){
  this.childLogger=logger;
  this.isBranchCommit=isBranchCommit;
  this.index=index;
  this.type=type;
  this.inheritedPriority=type;
  this.message=message;
  this.helpInfo=helpInfo;
  this.timestamp=new Date();
  this.exceptionDetail=AbstractTreeLogger.getStackTraceAsString(caught);
  this.exceptionName=AbstractTreeLogger.getExceptionName(caught);
}",0.8596646072374228
54388,"public Type getInheritedPriority(){
  return inheritedPriority;
}","/** 
 * @return the inherited priority, which will be the highest priority ofthis event or any child.
 */
public Type getInheritedPriority(){
  return inheritedPriority;
}",0.5508474576271186
54389,"@Override protected AbstractTreeLogger doBranch(){
  SwingTreeLogger newLogger=new SwingTreeLogger(panel);
  return newLogger;
}","@Override protected AbstractTreeLogger doBranch(){
  SwingTreeLogger newLogger=new SwingTreeLogger(panel,new DefaultMutableTreeNode(null));
  return newLogger;
}",0.8858131487889274
54390,"/** 
 * @param logEvent
 */
private void addUpdate(final LogEvent logEvent){
  new SwingWorker<LogEvent,Void>(){
    @Override protected LogEvent doInBackground() throws Exception {
      return logEvent;
    }
    @Override protected void done(){
      LogEvent event;
      try {
        event=get();
        SwingTreeLogger logger=event.childLogger;
        DefaultMutableTreeNode node;
        DefaultMutableTreeNode parent;
        int idx;
        if (event.isBranchCommit) {
          SwingTreeLogger parentLogger=(SwingTreeLogger)logger.getParentLogger();
          parent=parentLogger.treeNode;
          idx=logger.getBranchedIndex();
          node=logger.treeNode;
        }
 else {
          parent=logger.treeNode;
          idx=event.index;
          node=new DefaultMutableTreeNode(event);
        }
        int insertIndex=findInsertionPoint(parent,idx);
        panel.treeModel.insertNodeInto(node,parent,insertIndex);
        if (parent == panel.treeModel.getRoot() && parent.getChildCount() == 1) {
          panel.treeModel.reload();
        }
        if (event.type.needsAttention()) {
          panel.tree.makeVisible(new TreePath(node.getPath()));
        }
        Type priority=event.getInheritedPriority();
        while (parent != panel.treeModel.getRoot()) {
          LogEvent parentEvent=(LogEvent)parent.getUserObject();
          if (!parentEvent.updateInheritedPriority(priority)) {
            break;
          }
          parent=(DefaultMutableTreeNode)parent.getParent();
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
catch (      ExecutionException e) {
        e.printStackTrace();
      }
    }
    private int findInsertionPoint(    DefaultMutableTreeNode parent,    int index){
      int high=parent.getChildCount() - 1;
      if (high < 0) {
        return 0;
      }
      int low=0;
      while (low <= high) {
        final int mid=low + ((high - low) >> 1);
        DefaultMutableTreeNode midChild=(DefaultMutableTreeNode)parent.getChildAt(mid);
        final Object userObject=midChild.getUserObject();
        int compIdx=-1;
        if (userObject instanceof LogEvent) {
          LogEvent event=(LogEvent)userObject;
          compIdx=event.index;
        }
        if (compIdx < index) {
          low=mid + 1;
        }
 else         if (compIdx > index) {
          high=mid - 1;
        }
 else {
          return mid;
        }
      }
      return low;
    }
  }
.execute();
}","/** 
 * Add a log event to be processed on the event thread.
 * @param logEvent LogEvent to process
 */
private void addUpdate(final LogEvent logEvent){
  EventQueue.invokeLater(new Runnable(){
    public void run(){
      SwingTreeLogger logger=logEvent.childLogger;
      DefaultMutableTreeNode node;
      DefaultMutableTreeNode parentNode;
      int idx;
      if (logEvent.isBranchCommit) {
        SwingTreeLogger parentLogger=(SwingTreeLogger)logger.getParentLogger();
        logger.treeNode.setUserObject(logEvent);
        parentNode=parentLogger.treeNode;
        idx=logger.getBranchedIndex();
        node=logger.treeNode;
      }
 else {
        parentNode=logger.treeNode;
        idx=logEvent.index;
        node=new DefaultMutableTreeNode(logEvent);
      }
      int insertIndex=findInsertionPoint(parentNode,idx);
      panel.treeModel.insertNodeInto(node,parentNode,insertIndex);
      if (parentNode == panel.treeModel.getRoot() && parentNode.getChildCount() == 1) {
        panel.treeModel.reload();
      }
      if (logEvent.type.needsAttention()) {
        panel.tree.makeVisible(new TreePath(node.getPath()));
      }
      Type priority=logEvent.getInheritedPriority();
      while (parentNode != panel.treeModel.getRoot()) {
        LogEvent parentEvent=(LogEvent)parentNode.getUserObject();
        if (!parentEvent.updateInheritedPriority(priority)) {
          break;
        }
        parentNode=((DefaultMutableTreeNode)parentNode.getParent());
      }
    }
    private int findInsertionPoint(    DefaultMutableTreeNode parentNode,    int index){
      int high=parentNode.getChildCount() - 1;
      if (high < 0) {
        return 0;
      }
      int low=0;
      while (low <= high) {
        final int mid=low + ((high - low) >> 1);
        DefaultMutableTreeNode midChild=(DefaultMutableTreeNode)parentNode.getChildAt(mid);
        final Object userObject=midChild.getUserObject();
        int compIdx=-1;
        if (userObject instanceof LogEvent) {
          LogEvent event=(LogEvent)userObject;
          compIdx=event.index;
        }
        if (compIdx < index) {
          low=mid + 1;
        }
 else         if (compIdx > index) {
          high=mid - 1;
        }
 else {
          return mid;
        }
      }
      return low;
    }
  }
);
}",0.1981151832460733
54391,"public void animate(int duration,final Layout.AnimationCallback callback){
  animCmd.schedule(duration,callback);
}","public void animate(int duration,final Layout.AnimationCallback callback){
  layoutCmd.schedule(duration,callback);
}",0.9655172413793104
54392,"public void forceLayout(){
  animCmd.cancel();
  doLayout();
  layout.layout();
  onResize();
}","public void forceLayout(){
  layoutCmd.cancel();
  doLayout();
  layout.layout();
  onResize();
}",0.9583333333333334
54393,"/** 
 * Creates an empty dock panel.
 * @param unit the unit to be used for layout
 */
public DockLayoutPanel(Unit unit){
  this.unit=unit;
  setElement(Document.get().createDivElement());
  layout=new Layout(getElement());
  animCmd=new DockAnimateCommand(layout);
}","/** 
 * Creates an empty dock panel.
 * @param unit the unit to be used for layout
 */
public DockLayoutPanel(Unit unit){
  this.unit=unit;
  setElement(Document.get().createDivElement());
  layout=new Layout(getElement());
  layoutCmd=new DockAnimateCommand(layout);
}",0.9813432835820896
54394,"/** 
 * Creates a new command for the given layout object
 * @param layout
 */
public LayoutCommand(Layout layout){
  this.layout=layout;
}","/** 
 * Creates a new command for the given layout object.
 * @param layout
 */
public LayoutCommand(Layout layout){
  this.layout=layout;
}",0.996415770609319
54395,"public void animate(final int duration,final AnimationCallback callback){
  animCmd.schedule(duration,callback);
}","public void animate(final int duration,final AnimationCallback callback){
  layoutCmd.schedule(duration,callback);
}",0.9652173913043478
54396,"/** 
 * Creates an empty layout panel.
 */
public LayoutPanel(){
  setElement(Document.get().createDivElement());
  layout=new Layout(getElement());
  animCmd=new LayoutCommand(layout);
}","/** 
 * Creates an empty layout panel.
 */
public LayoutPanel(){
  setElement(Document.get().createDivElement());
  layout=new Layout(getElement());
  layoutCmd=new LayoutCommand(layout);
}",0.9787234042553192
54397,"public void forceLayout(){
  animCmd.cancel();
  layout.layout();
  onResize();
}","public void forceLayout(){
  layoutCmd.cancel();
  layout.layout();
  onResize();
}",0.951219512195122
54398,"public void parse(XMLElement elem,String fieldName,JClassType type,UiBinderWriter writer) throws UnableToCompleteException {
  for (  XMLElement child : elem.consumeChildElements()) {
    String ns=child.getNamespaceUri();
    String tagName=child.getLocalName();
    if (ns.equals(elem.getNamespaceUri()) && localTagNameIsCell(tagName)) {
      XMLElement widget=child.consumeSingleChildElement();
      String childFieldName=writer.parseElementToField(widget);
      writer.addStatement(""String_Node_Str"",fieldName,childFieldName);
      parseCellAttributes(child,fieldName,childFieldName,writer);
    }
 else {
      String childFieldName=writer.parseElementToField(child);
      writer.addStatement(""String_Node_Str"",fieldName,childFieldName);
    }
  }
}","public void parse(XMLElement elem,String fieldName,JClassType type,UiBinderWriter writer) throws UnableToCompleteException {
  for (  XMLElement child : elem.consumeChildElements()) {
    String ns=child.getNamespaceUri();
    String tagName=child.getLocalName();
    if (ns != null && ns.equals(elem.getNamespaceUri()) && localTagNameIsCell(tagName)) {
      XMLElement widget=child.consumeSingleChildElement();
      String childFieldName=writer.parseElementToField(widget);
      writer.addStatement(""String_Node_Str"",fieldName,childFieldName);
      parseCellAttributes(child,fieldName,childFieldName,writer);
    }
 else {
      if (!writer.isWidgetElement(child)) {
        writer.die(""String_Node_Str"",elem,elem.getPrefix(),CELL_TAG.toLowerCase(),child);
      }
      String childFieldName=writer.parseElementToField(child);
      writer.addStatement(""String_Node_Str"",fieldName,childFieldName);
    }
  }
}",0.906810035842294
54399,"/** 
 * Parses the root UiBinder element, and kicks off the parsing of the rest of the document.
 */
public String parse(XMLElement elem) throws UnableToCompleteException {
  findResources(elem);
  messagesWriter.findMessagesConfig(elem);
  XMLElement uiRoot=elem.consumeSingleChildElement();
  return writer.parseElementToField(uiRoot);
}","/** 
 * Parses the root UiBinder element, and kicks off the parsing of the rest of the document.
 */
public String parse(XMLElement elem) throws UnableToCompleteException {
  if (!writer.isBinderElement(elem)) {
    writer.die(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",elem.getPrefix(),elem.getLocalName(),UiBinderWriter.BINDER_URI,elem.getPrefix());
  }
  if (!TAG.equals(elem.getLocalName())) {
    writer.die(""String_Node_Str"",elem.getPrefix(),TAG,elem);
  }
  findResources(elem);
  messagesWriter.findMessagesConfig(elem);
  XMLElement uiRoot=elem.consumeSingleChildElement();
  return writer.parseElementToField(uiRoot);
}",0.6897253306205493
54400,"/** 
 * Consumes a single child element, ignoring any text nodes and throwing an exception if no child is found, or more than one child element is found.
 * @throws UnableToCompleteException on no children, or too many
 */
public XMLElement consumeSingleChildElement() throws UnableToCompleteException {
  XMLElement ret=null;
  for (  XMLElement child : consumeChildElements()) {
    if (ret != null) {
      writer.die(""String_Node_Str"" + ""String_Node_Str"",getLocalName(),ret,child);
    }
    ret=child;
  }
  if (ret == null) {
    writer.die(""String_Node_Str"",this);
  }
  return ret;
}","/** 
 * Consumes a single child element, ignoring any text nodes and throwing an exception if no child is found, or more than one child element is found.
 * @throws UnableToCompleteException on no children, or too many
 */
public XMLElement consumeSingleChildElement() throws UnableToCompleteException {
  XMLElement ret=null;
  for (  XMLElement child : consumeChildElements()) {
    if (ret != null) {
      writer.die(""String_Node_Str"" + ""String_Node_Str"",this,ret,child);
    }
    ret=child;
  }
  if (ret == null) {
    writer.die(""String_Node_Str"",this);
  }
  return ret;
}",0.984641638225256
54401,"/** 
 * Removes the given handler from the specified event type. Normally, applications should call   {@link HandlerRegistration#removeHandler()}instead.
 * @param < H > handler type
 * @param type the event type
 * @param handler the handler
 * @deprecated This method is likely to be removed along with ""listener""interfaces in a future release. If you have a reason it should be retained beyond that time, please add your comments to GWT <a href=""http://code.google.com/p/google-web-toolkit/issues/detail?id=3102"">issue 3102</a>
 */
@Deprecated public <H extends EventHandler>void removeHandler(GwtEvent.Type<H> type,final H handler){
  if (firingDepth > 0) {
    enqueueRemove(type,handler);
  }
 else {
    doRemove(type,handler);
  }
}","/** 
 * Removes the given handler from the specified event type. Normally, applications should call   {@link HandlerRegistration#removeHandler()}instead.
 * @param < H > handler type
 * @param type the event type
 * @param handler the handler
 */
public <H extends EventHandler>void removeHandler(GwtEvent.Type<H> type,final H handler){
  if (firingDepth > 0) {
    enqueueRemove(type,handler);
  }
 else {
    doRemove(type,handler);
  }
}",0.7440677966101695
54402,"@SuppressWarnings(""String_Node_Str"") public void testRemoveHandlers(){
  HandlerManager manager=new HandlerManager(""String_Node_Str"");
  addHandlers(manager);
  manager.removeHandler(MouseDownEvent.getType(),adaptor1);
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(mouse1,mouse2,mouse3,adaptor1);
  assertNotFired(click1,click2);
  manager.removeHandler(MouseDownEvent.getType(),adaptor1);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(mouse1,mouse2,mouse3);
  assertNotFired(adaptor1,click1,click2);
  reset();
  manager.fireEvent(new ClickEvent(){
  }
);
  assertNotFired(mouse1,mouse2,mouse3);
  assertFired(click1,click2,adaptor1);
}","public void testRemoveHandlers(){
  HandlerManager manager=new HandlerManager(""String_Node_Str"");
  addHandlers(manager);
  manager.removeHandler(MouseDownEvent.getType(),adaptor1);
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(mouse1,mouse2,mouse3,adaptor1);
  assertNotFired(click1,click2);
  manager.removeHandler(MouseDownEvent.getType(),adaptor1);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(mouse1,mouse2,mouse3);
  assertNotFired(adaptor1,click1,click2);
  reset();
  manager.fireEvent(new ClickEvent(){
  }
);
  assertNotFired(mouse1,mouse2,mouse3);
  assertFired(click1,click2,adaptor1);
}",0.8560663149962321
54403,"@SuppressWarnings(""String_Node_Str"") public void testConcurrentAddAfterRemoveIsNotClobbered(){
  final HandlerManager manager=new HandlerManager(""String_Node_Str"");
  MouseDownHandler one=new MouseDownHandler(){
    public void onMouseDown(    MouseDownEvent event){
      manager.removeHandler(MouseDownEvent.getType(),mouse1);
      manager.addHandler(MouseDownEvent.getType(),mouse1);
      add(this);
    }
  }
;
  manager.addHandler(MouseDownEvent.getType(),one);
  if (!GWT.isScript()) {
    try {
      manager.fireEvent(new MouseDownEvent(){
      }
);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    return;
  }
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one,mouse1);
}","public void testConcurrentAddAfterRemoveIsNotClobbered(){
  final HandlerManager manager=new HandlerManager(""String_Node_Str"");
  MouseDownHandler one=new MouseDownHandler(){
    public void onMouseDown(    MouseDownEvent event){
      manager.removeHandler(MouseDownEvent.getType(),mouse1);
      manager.addHandler(MouseDownEvent.getType(),mouse1);
      add(this);
    }
  }
;
  manager.addHandler(MouseDownEvent.getType(),one);
  if (!GWT.isScript()) {
    try {
      manager.fireEvent(new MouseDownEvent(){
      }
);
      fail(""String_Node_Str"");
    }
 catch (    AssertionError e) {
    }
    return;
  }
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one);
  reset();
  manager.fireEvent(new MouseDownEvent(){
  }
);
  assertFired(one,mouse1);
}",0.9765970904490828
54404,"/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger, LinkerContext, CompilationResult).}
 */
@Override protected String getModulePrefix(TreeLogger logger,LinkerContext context,String strongName) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}","/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger,LinkerContext,CompilationResult)}.
 */
@Override protected String getModulePrefix(TreeLogger logger,LinkerContext context,String strongName) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}",0.9933554817275748
54405,"/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger, LinkerContext, CompilationResult).}
 */
@Override protected String getCompilationExtension(TreeLogger logger,LinkerContext context) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}","/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger,LinkerContext,CompilationResult)}.
 */
@Override protected String getCompilationExtension(TreeLogger logger,LinkerContext context) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}",0.993127147766323
54406,"/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger, LinkerContext, CompilationResult).}
 */
@Override protected String getModuleSuffix(TreeLogger logger,LinkerContext context) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}","/** 
 * Unimplemented. Normally required by  {@link #doEmitCompilation(TreeLogger,LinkerContext,CompilationResult)}.
 */
@Override protected String getModuleSuffix(TreeLogger logger,LinkerContext context) throws UnableToCompleteException {
  throw new UnableToCompleteException();
}",0.9929328621908128
54407,"/** 
 * Returns a string where all URL component escape sequences have been converted back to their original character representations.
 * @param encodedURLComponent string containing encoded URL componentsequences
 * @return string with no encoded URL component encoded sequences
 * @throws NullPointerException if encodedURLComponent is <code>null</code>
 */
public static String decodeComponent(String encodedURLComponent){
  StringValidator.throwIfNull(""String_Node_Str"",encodedURLComponent);
  return decodeComponentImpl(encodedURLComponent);
}","/** 
 * Returns a string where all URL component escape sequences have been converted back to their original character representations.
 * @param encodedURLComponent string containing encoded URL componentsequences
 * @param fromQueryString if <code>true</code>, +'s will be turned intospaces, otherwise they'll be kept as-is.
 * @return string with no encoded URL component encoded sequences
 * @throws NullPointerException if encodedURLComponent is <code>null</code>
 */
public static String decodeComponent(String encodedURLComponent,boolean fromQueryString){
  StringValidator.throwIfNull(""String_Node_Str"",encodedURLComponent);
  return fromQueryString ? decodeComponentImpl(encodedURLComponent) : decodeComponentRawImpl(encodedURLComponent);
}",0.8228043143297381
54408,"/** 
 * Returns a string where all characters that are not valid for a URL component have been escaped. The escaping of a character is done by converting it into its UTF-8 encoding and then encoding each of the resulting bytes as a %xx hexadecimal escape sequence. <p> The following character sets are <em>not</em> escaped by this method: <ul> <li>ASCII digits or letters</li> <li>ASCII punctuation characters: <pre>- _ . ! ~ * ' ( )</pre></li> </ul> </p> <p> Notice that this method <em>does</em> encode the URL component delimiter characters:<blockquote> <pre> ; / ? : &amp; = + $ , # </pre> </blockquote> </p>
 * @param decodedURLComponent a string containing invalid URL characters
 * @return a string with all invalid URL characters escaped
 * @throws NullPointerException if decodedURLComponent is <code>null</code>
 */
public static String encodeComponent(String decodedURLComponent){
  StringValidator.throwIfNull(""String_Node_Str"",decodedURLComponent);
  return encodeComponentImpl(decodedURLComponent);
}","/** 
 * Returns a string where all characters that are not valid for a URL component have been escaped. The escaping of a character is done by converting it into its UTF-8 encoding and then encoding each of the resulting bytes as a %xx hexadecimal escape sequence. <p> The following character sets are <em>not</em> escaped by this method: <ul> <li>ASCII digits or letters</li> <li>ASCII punctuation characters: <pre>- _ . ! ~ * ' ( )</pre></li> </ul> </p> <p> Notice that this method <em>does</em> encode the URL component delimiter characters:<blockquote> <pre> ; / ? : &amp; = + $ , # </pre> </blockquote> </p>
 * @param decodedURLComponent a string containing invalid URL characters
 * @param queryStringSpaces if <code>true</code>, spaces will be encoded as +'s.
 * @return a string with all invalid URL characters escaped
 * @throws NullPointerException if decodedURLComponent is <code>null</code>
 */
public static String encodeComponent(String decodedURLComponent,boolean queryStringSpaces){
  StringValidator.throwIfNull(""String_Node_Str"",decodedURLComponent);
  return queryStringSpaces ? encodeComponentImpl(decodedURLComponent) : encodeComponentRawImpl(decodedURLComponent);
}",0.9213993639254884
54409,"/** 
 * Test method for  {@link com.google.gwt.http.client.URL#decodeComponent(java.lang.String)}.
 */
public void testDecodeComponent(){
  try {
    URL.decodeComponent(null);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException ex) {
  }
  assertEquals(""String_Node_Str"",URL.decodeComponent(""String_Node_Str""));
  assertEquals(""String_Node_Str"",URL.decodeComponent(""String_Node_Str""));
  String actualURLComponent=URL.decodeComponent(ENCODED_URL_COMPONENT);
  assertEquals(DECODED_URL_COMPONENT,actualURLComponent);
}","/** 
 * Test method for  {@link com.google.gwt.http.client.URL#decodeComponent(java.lang.String)}.
 */
public void testDecodeComponent(){
  try {
    URL.decodeComponent(null);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException ex) {
  }
  assertEquals(""String_Node_Str"",URL.decodeComponent(""String_Node_Str""));
  assertEquals(""String_Node_Str"",URL.decodeComponent(""String_Node_Str""));
  String actualURLComponent=URL.decodeComponent(ENCODED_URL_COMPONENT);
  assertEquals(DECODED_URL_COMPONENT,actualURLComponent);
  actualURLComponent=URL.decodeComponent(ENCODED_URL_COMPONENT_QS);
  assertEquals(DECODED_URL_COMPONENT,actualURLComponent);
}",0.893760539629005
54410,"/** 
 * Test method for  {@link com.google.gwt.http.client.URL#encodeComponent(java.lang.String)}.
 */
public void testEncodeComponent(){
  try {
    URL.encodeComponent(null);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException ex) {
  }
  assertEquals(""String_Node_Str"",URL.encodeComponent(""String_Node_Str""));
  assertEquals(""String_Node_Str"",URL.encodeComponent(""String_Node_Str""));
  String actualURLComponent=URL.encodeComponent(DECODED_URL_COMPONENT);
  assertEquals(ENCODED_URL_COMPONENT,actualURLComponent);
}","/** 
 * Test method for  {@link com.google.gwt.http.client.URL#encodeComponent(java.lang.String)}.
 */
public void testEncodeComponent(){
  try {
    URL.encodeComponent(null);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException ex) {
  }
  assertEquals(""String_Node_Str"",URL.encodeComponent(""String_Node_Str""));
  assertEquals(""String_Node_Str"",URL.encodeComponent(""String_Node_Str""));
  String actualURLComponent=URL.encodeComponent(DECODED_URL_COMPONENT);
  assertEquals(ENCODED_URL_COMPONENT_QS,actualURLComponent);
}",0.9971777986829728
54411,"/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a{@link #precompile(TreeLogger,WebModeCompilerFrontEnd,String[],JJSOptions,boolean)}
 * @param permutation the permutation to compile
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Permutation permutation) throws UnableToCompleteException {
  PropertyOracle[] propertyOracles=permutation.getPropertyOracles();
  int permutationId=permutation.getId();
  Map<String,String> rebindAnswers=permutation.getRebindAnswers();
  int printId=permutationId + 1;
  logger.log(TreeLogger.INFO,""String_Node_Str"" + printId + ""String_Node_Str"");
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    JJSOptions options=unifiedAst.getOptions();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,rebindAnswers);
    if (options.isDraftCompile()) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    LongCastNormalizer.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeAfterOptimizations();
    JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable);
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      boolean didChange;
      do {
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
        didChange=false;
        didChange=JsStaticEval.exec(jsProgram) || didChange;
        didChange=JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
    JsStackEmulator.exec(jsProgram,propertyOracles);
    SyntheticArtifact dependencies=null;
    if (options.isAggressivelyOptimize() && options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      CodeSplitter.exec(logger,jprogram,jsProgram,map,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      if (baos.size() == 0 && options.isSoycEnabled()) {
        recordNonSplitDependencies(jprogram,baos);
      }
      if (baos.size() > 0) {
        dependencies=new SyntheticArtifact(SoycReportLinker.class,""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
SelectionProperty userAgentProperty=null;
for (PropertyOracle oracle : propertyOracles) {
userAgentProperty=oracle.getSelectionProperty(logger,""String_Node_Str"");
if (userAgentProperty != null) {
break;
}
}
boolean splitBlocks=userAgentProperty == null || (""String_Node_Str"".equals(userAgentProperty.getCurrentValue()));
if (splitBlocks) {
JsIEBlockSizeVisitor.exec(jsProgram);
}
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=options.isSoycExtra() ? new ArrayList<Map<Range,SourceInfo>>() : null;
generateJavaScriptCode(options,jsProgram,map,js,ranges,sizeBreakdowns,sourceInfoMaps,splitBlocks);
PermutationResult toReturn=new PermutationResultImpl(js,permutation,makeSymbolMap(symbolTable),ranges);
toReturn.addArtifacts(makeSoycArtifacts(logger,permutationId,jprogram,js,sizeBreakdowns,sourceInfoMaps,dependencies,map,obfuscateMap));
logger.log(TreeLogger.TRACE,""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
return toReturn;
}
 catch (Throwable e) {
throw logAndTranslateException(logger,e);
}
}","/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a{@link #precompile(TreeLogger,WebModeCompilerFrontEnd,String[],JJSOptions,boolean)}
 * @param permutation the permutation to compile
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Permutation permutation) throws UnableToCompleteException {
  PropertyOracle[] propertyOracles=permutation.getPropertyOracles();
  int permutationId=permutation.getId();
  Map<String,String> rebindAnswers=permutation.getRebindAnswers();
  int printId=permutationId + 1;
  logger.log(TreeLogger.INFO,""String_Node_Str"" + printId + ""String_Node_Str"");
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    JJSOptions options=unifiedAst.getOptions();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,rebindAnswers);
    if (options.isDraftCompile()) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    LongCastNormalizer.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeAfterOptimizations();
    JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable);
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      boolean didChange;
      do {
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
        didChange=false;
        didChange=JsStaticEval.exec(jsProgram) || didChange;
        didChange=JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
    JsStackEmulator.exec(jsProgram,propertyOracles);
    SyntheticArtifact dependencies=null;
    if (options.isAggressivelyOptimize() && options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      CodeSplitter.exec(logger,jprogram,jsProgram,map,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      if (baos.size() == 0 && options.isSoycEnabled()) {
        recordNonSplitDependencies(jprogram,baos);
      }
      if (baos.size() > 0) {
        dependencies=new SyntheticArtifact(SoycReportLinker.class,""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
SelectionProperty userAgentProperty=null;
for (PropertyOracle oracle : propertyOracles) {
try {
userAgentProperty=oracle.getSelectionProperty(logger,""String_Node_Str"");
}
 catch (BadPropertyValueException e) {
break;
}
}
boolean splitBlocks=userAgentProperty == null || (""String_Node_Str"".equals(userAgentProperty.getCurrentValue()));
if (splitBlocks) {
JsIEBlockSizeVisitor.exec(jsProgram);
}
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=options.isSoycExtra() ? new ArrayList<Map<Range,SourceInfo>>() : null;
generateJavaScriptCode(options,jsProgram,map,js,ranges,sizeBreakdowns,sourceInfoMaps,splitBlocks);
PermutationResult toReturn=new PermutationResultImpl(js,permutation,makeSymbolMap(symbolTable),ranges);
toReturn.addArtifacts(makeSoycArtifacts(logger,permutationId,jprogram,js,sizeBreakdowns,sourceInfoMaps,dependencies,map,obfuscateMap));
logger.log(TreeLogger.TRACE,""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
return toReturn;
}
 catch (Throwable e) {
throw logAndTranslateException(logger,e);
}
}",0.9944400317712472
54412,"static JMethodCall makeStaticCall(JMethodCall x,JMethod newMethod){
  JMethodCall newCall=new JMethodCall(x.getSourceInfo().makeChild(MakeCallsStatic.class,""String_Node_Str""),null,newMethod);
  newCall.addArg(x.getInstance());
  newCall.addArgs(x.getArgs());
  return newCall;
}","static JExpression makeStaticCall(JMethodCall x,JMethod newMethod){
  JMethodCall newCall=new JMethodCall(x.getSourceInfo().makeChild(MakeCallsStatic.class,""String_Node_Str""),null,newMethod);
  if (x.getInstance() instanceof JMultiExpression) {
    JMultiExpression multi=(JMultiExpression)x.getInstance();
    int lastIndex=multi.exprs.size() - 1;
    newCall.addArg(multi.exprs.get(lastIndex));
    newCall.addArgs(x.getArgs());
    multi.exprs.set(lastIndex,newCall);
    return multi;
  }
 else {
    newCall.addArg(x.getInstance());
    newCall.addArgs(x.getArgs());
    return newCall;
  }
}",0.5348571428571428
54413,"private void addAllOuterThisRefs(List<? super JFieldRef> list,JExpression expr,JClassType classType){
  if (classType.getFields().size() > 0) {
    JField field=classType.getFields().get(0);
    if (field.getName().startsWith(""String_Node_Str"")) {
      list.add(new JFieldRef(expr.getSourceInfo(),expr,field,currentClass));
    }
  }
}","private void addAllOuterThisRefs(List<? super JFieldRef> list,JExpression expr,JClassType classType){
  if (classType.getFields().size() > 0) {
    JField field=classType.getFields().get(0);
    if (field.getName().startsWith(""String_Node_Str"") || field.getName().startsWith(""String_Node_Str"")) {
      list.add(new JFieldRef(expr.getSourceInfo(),expr,field,currentClass));
    }
  }
}",0.9320388349514565
54414,"static String generateConstantOrMessageClass(TreeLogger logger,GeneratorContext context,GwtLocale locale,JClassType targetClass) throws UnableToCompleteException {
  TypeOracle oracle=context.getTypeOracle();
  JClassType constantsClass;
  JClassType messagesClass;
  JClassType constantsWithLookupClass;
  boolean seenError=false;
  try {
    constantsClass=oracle.getType(LocalizableGenerator.CONSTANTS_NAME);
    constantsWithLookupClass=oracle.getType(LocalizableGenerator.CONSTANTS_WITH_LOOKUP_NAME);
    messagesClass=oracle.getType(LocalizableGenerator.MESSAGES_NAME);
  }
 catch (  NotFoundException e) {
    throw error(logger,e);
  }
  String name=targetClass.getName();
  String packageName=targetClass.getPackage().getName();
  boolean assignableToConstants=constantsClass.isAssignableFrom(targetClass);
  boolean assignableToMessages=messagesClass.isAssignableFrom(targetClass);
  if (!assignableToConstants && !assignableToMessages) {
    return null;
  }
  if (assignableToConstants && assignableToMessages) {
    throw error(logger,name + ""String_Node_Str"");
  }
  if (targetClass.isInterface() == null) {
    throw error(logger,name + ""String_Node_Str"");
  }
  ResourceList resourceList=null;
  try {
    resourceList=ResourceFactory.getBundle(logger,targetClass,locale,assignableToConstants,context.getResourcesOracle().getResourceMap());
  }
 catch (  MissingResourceException e) {
    throw error(logger,""String_Node_Str"" + ""String_Node_Str"" + packageName + ""String_Node_Str""+ ResourceFactory.getResourceName(targetClass)+ ""String_Node_Str"");
  }
catch (  IllegalArgumentException e) {
    throw error(logger,e.getMessage());
  }
  GwtLocale generatedLocale=resourceList.findLeastDerivedLocale(locale);
  String localeSuffix=String.valueOf(ResourceFactory.LOCALE_SEPARATOR);
  localeSuffix+=generatedLocale.getAsString();
  String resourceName=targetClass.getName().replace('.','_');
  String className=resourceName + localeSuffix;
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.addImplementedInterface(targetClass.getQualifiedSourceName());
    SourceWriter writer=factory.createSourceWriter(context,pw);
    if (constantsWithLookupClass.isAssignableFrom(targetClass)) {
      ConstantsWithLookupImplCreator c=new ConstantsWithLookupImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      c.emitClass(logger,generatedLocale);
    }
 else     if (constantsClass.isAssignableFrom(targetClass)) {
      ConstantsImplCreator c=new ConstantsImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      c.emitClass(logger,generatedLocale);
    }
 else {
      MessagesImplCreator messages=new MessagesImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      messages.emitClass(logger,generatedLocale);
    }
    context.commit(logger,pw);
  }
  Generate generate=getClassAnnotation(targetClass,Generate.class);
  if (generate != null) {
    String path=generate.fileName();
    if (Generate.DEFAULT.equals(path)) {
      path=targetClass.getPackage().getName() + ""String_Node_Str"" + targetClass.getName().replace('.','_');
    }
 else     if (path.endsWith(File.pathSeparator)) {
      path=path + targetClass.getName().replace('.','_');
    }
    String[] genLocales=generate.locales();
    boolean found=false;
    if (genLocales.length != 0) {
      for (      String genLocale : genLocales) {
        if (GwtLocale.DEFAULT_LOCALE.equals(genLocale)) {
          try {
            SelectionProperty localeProp=context.getPropertyOracle().getSelectionProperty(logger,""String_Node_Str"");
            String defaultLocale=localeProp.getFallbackValue();
            if (defaultLocale.length() > 0) {
              genLocale=defaultLocale;
            }
          }
 catch (          BadPropertyValueException e) {
            throw error(logger,""String_Node_Str"");
          }
        }
        if (genLocale.equals(locale.toString())) {
          found=true;
          break;
        }
      }
    }
 else {
      found=true;
    }
    if (found) {
      for (      String genClassName : generate.format()) {
        MessageCatalogFormat msgWriter=null;
        try {
          Class<? extends MessageCatalogFormat> msgFormatClass=Class.forName(genClassName,false,MessageCatalogFormat.class.getClassLoader()).asSubclass(MessageCatalogFormat.class);
          msgWriter=msgFormatClass.newInstance();
        }
 catch (        InstantiationException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName,e);
          seenError=true;
          continue;
        }
catch (        IllegalAccessException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName + ""String_Node_Str"",e);
          seenError=true;
          continue;
        }
catch (        ClassNotFoundException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName + ""String_Node_Str"");
          seenError=true;
          continue;
        }
        String genPath=path;
        if (genLocales.length != 1) {
          genPath+='_' + locale.toString();
        }
        genPath+=msgWriter.getExtension();
        OutputStream outStr=context.tryCreateResource(logger,genPath);
        if (outStr != null) {
          TreeLogger branch=logger.branch(TreeLogger.INFO,""String_Node_Str"" + genPath + ""String_Node_Str""+ className+ ""String_Node_Str""+ locale,null);
          PrintWriter out=null;
          try {
            out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStr,""String_Node_Str"")),false);
          }
 catch (          UnsupportedEncodingException e) {
            throw error(logger,e.getMessage());
          }
          try {
            msgWriter.write(branch,locale.toString(),resourceList,out,targetClass);
            out.flush();
            context.commitResource(logger,outStr).setPrivate(true);
          }
 catch (          UnableToCompleteException e) {
            seenError=true;
          }
        }
      }
    }
  }
  if (seenError) {
    throw new UnableToCompleteException();
  }
  return packageName + ""String_Node_Str"" + className;
}","static String generateConstantOrMessageClass(TreeLogger logger,GeneratorContext context,GwtLocale locale,JClassType targetClass) throws UnableToCompleteException {
  TypeOracle oracle=context.getTypeOracle();
  JClassType constantsClass;
  JClassType messagesClass;
  JClassType constantsWithLookupClass;
  boolean seenError=false;
  try {
    constantsClass=oracle.getType(LocalizableGenerator.CONSTANTS_NAME);
    constantsWithLookupClass=oracle.getType(LocalizableGenerator.CONSTANTS_WITH_LOOKUP_NAME);
    messagesClass=oracle.getType(LocalizableGenerator.MESSAGES_NAME);
  }
 catch (  NotFoundException e) {
    throw error(logger,e);
  }
  String name=targetClass.getName();
  String packageName=targetClass.getPackage().getName();
  boolean assignableToConstants=constantsClass.isAssignableFrom(targetClass);
  boolean assignableToMessages=messagesClass.isAssignableFrom(targetClass);
  if (!assignableToConstants && !assignableToMessages) {
    return null;
  }
  if (assignableToConstants && assignableToMessages) {
    throw error(logger,name + ""String_Node_Str"");
  }
  if (targetClass.isInterface() == null) {
    throw error(logger,name + ""String_Node_Str"");
  }
  ResourceList resourceList=null;
  try {
    resourceList=ResourceFactory.getBundle(logger,targetClass,locale,assignableToConstants,context.getResourcesOracle().getResourceMap());
  }
 catch (  MissingResourceException e) {
    throw error(logger,""String_Node_Str"" + ""String_Node_Str"" + packageName + ""String_Node_Str""+ ResourceFactory.getResourceName(targetClass)+ ""String_Node_Str"");
  }
catch (  IllegalArgumentException e) {
    throw error(logger,e.getMessage());
  }
  GwtLocale generatedLocale=resourceList.findLeastDerivedLocale(logger,locale);
  String localeSuffix=String.valueOf(ResourceFactory.LOCALE_SEPARATOR);
  localeSuffix+=generatedLocale.getAsString();
  String resourceName=targetClass.getName().replace('.','_');
  String className=resourceName + localeSuffix;
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.addImplementedInterface(targetClass.getQualifiedSourceName());
    SourceWriter writer=factory.createSourceWriter(context,pw);
    if (constantsWithLookupClass.isAssignableFrom(targetClass)) {
      ConstantsWithLookupImplCreator c=new ConstantsWithLookupImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      c.emitClass(logger,generatedLocale);
    }
 else     if (constantsClass.isAssignableFrom(targetClass)) {
      ConstantsImplCreator c=new ConstantsImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      c.emitClass(logger,generatedLocale);
    }
 else {
      MessagesImplCreator messages=new MessagesImplCreator(logger,writer,targetClass,resourceList,context.getTypeOracle());
      messages.emitClass(logger,generatedLocale);
    }
    context.commit(logger,pw);
  }
  Generate generate=getClassAnnotation(targetClass,Generate.class);
  if (generate != null) {
    String path=generate.fileName();
    if (Generate.DEFAULT.equals(path)) {
      path=targetClass.getPackage().getName() + ""String_Node_Str"" + targetClass.getName().replace('.','_');
    }
 else     if (path.endsWith(File.pathSeparator)) {
      path=path + targetClass.getName().replace('.','_');
    }
    String[] genLocales=generate.locales();
    boolean found=false;
    if (genLocales.length != 0) {
      for (      String genLocale : genLocales) {
        if (GwtLocale.DEFAULT_LOCALE.equals(genLocale)) {
          try {
            SelectionProperty localeProp=context.getPropertyOracle().getSelectionProperty(logger,""String_Node_Str"");
            String defaultLocale=localeProp.getFallbackValue();
            if (defaultLocale.length() > 0) {
              genLocale=defaultLocale;
            }
          }
 catch (          BadPropertyValueException e) {
            throw error(logger,""String_Node_Str"");
          }
        }
        if (genLocale.equals(locale.toString())) {
          found=true;
          break;
        }
      }
    }
 else {
      found=true;
    }
    if (found) {
      for (      String genClassName : generate.format()) {
        MessageCatalogFormat msgWriter=null;
        try {
          Class<? extends MessageCatalogFormat> msgFormatClass=Class.forName(genClassName,false,MessageCatalogFormat.class.getClassLoader()).asSubclass(MessageCatalogFormat.class);
          msgWriter=msgFormatClass.newInstance();
        }
 catch (        InstantiationException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName,e);
          seenError=true;
          continue;
        }
catch (        IllegalAccessException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName + ""String_Node_Str"",e);
          seenError=true;
          continue;
        }
catch (        ClassNotFoundException e) {
          logger.log(TreeLogger.ERROR,""String_Node_Str"" + genClassName + ""String_Node_Str"");
          seenError=true;
          continue;
        }
        String genPath=path;
        if (genLocales.length != 1) {
          genPath+='_' + locale.toString();
        }
        genPath+=msgWriter.getExtension();
        OutputStream outStr=context.tryCreateResource(logger,genPath);
        if (outStr != null) {
          TreeLogger branch=logger.branch(TreeLogger.INFO,""String_Node_Str"" + genPath + ""String_Node_Str""+ className+ ""String_Node_Str""+ locale,null);
          PrintWriter out=null;
          try {
            out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStr,""String_Node_Str"")),false);
          }
 catch (          UnsupportedEncodingException e) {
            throw error(logger,e.getMessage());
          }
          try {
            msgWriter.write(branch,locale.toString(),resourceList,out,targetClass);
            out.flush();
            context.commitResource(logger,outStr).setPrivate(true);
          }
 catch (          UnableToCompleteException e) {
            seenError=true;
          }
        }
      }
    }
  }
  if (seenError) {
    throw new UnableToCompleteException();
  }
  return packageName + ""String_Node_Str"" + className;
}",0.9994404923667172
54415,"/** 
 * From the list of locales matched for any resources in this resource list, choose the one that is least derived from the original search locale.
 * @param locale originally requested locale
 * @return least derived matched locale
 */
public GwtLocale findLeastDerivedLocale(GwtLocale locale){
}","/** 
 * From the list of locales matched for any resources in this resource list, choose the one that is least derived from the original search locale.
 * @param logger logger to use
 * @param locale originally requested locale
 * @return least derived matched locale
 */
public GwtLocale findLeastDerivedLocale(TreeLogger logger,GwtLocale locale){
  List<GwtLocale> searchList=locale.getCompleteSearchList();
  Map<GwtLocale,Integer> derivedIndex=new HashMap<GwtLocale,Integer>();
  for (int i=0; i < searchList.size(); ++i) {
    derivedIndex.put(searchList.get(i),i);
  }
  GwtLocale best=LocaleUtils.getLocaleFactory().getDefault();
  int bestIdx=Integer.MAX_VALUE;
  for (int i=0; i < list.size(); ++i) {
    GwtLocale matchLocale=list.get(i).getMatchLocale();
    Integer wrappedIdx=derivedIndex.get(matchLocale);
    if (wrappedIdx == null) {
      logger.log(TreeLogger.WARN,""String_Node_Str"" + matchLocale + ""String_Node_Str""+ searchList);
      continue;
    }
    int idx=wrappedIdx;
    if (idx < bestIdx) {
      bestIdx=idx;
      best=matchLocale;
    }
  }
  return best;
}",0.4330935251798561
54416,"/** 
 * This function parses a ""localized"" text into a <code>double</code>. It needs to handle locale specific decimal, grouping, exponent and digit.
 * @param text the text that need to be parsed
 * @param pos in/out parsing position. in case of failure, this shouldn't bechanged
 * @return double value, could be 0.0 if nothing can be parsed
 */
private double parseNumber(String text,int[] pos){
  double ret;
  boolean sawDecimal=false;
  boolean sawExponent=false;
  boolean sawDigit=false;
  int scale=1;
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String exponentChar=numberConstants.exponentialSymbol();
  StringBuffer normalizedText=new StringBuffer();
  for (; pos[0] < text.length(); ++pos[0]) {
    char ch=text.charAt(pos[0]);
    int digit=getDigit(ch);
    if (digit >= 0 && digit <= 9) {
      normalizedText.append((char)(digit + '0'));
      sawDigit=true;
    }
 else     if (ch == decimal.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      normalizedText.append('.');
      sawDecimal=true;
    }
 else     if (ch == grouping.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      continue;
    }
 else     if (ch == exponentChar.charAt(0)) {
      if (sawExponent) {
        break;
      }
      normalizedText.append('E');
      sawExponent=true;
    }
 else     if (ch == '+' || ch == '-') {
      normalizedText.append(ch);
    }
 else     if (ch == numberConstants.percent().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=100;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else     if (ch == numberConstants.perMill().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=1000;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else {
      break;
    }
  }
  ret=Double.parseDouble(normalizedText.toString());
  ret=ret / scale;
  return ret;
}","/** 
 * This function parses a ""localized"" text into a <code>double</code>. It needs to handle locale specific decimal, grouping, exponent and digit.
 * @param text the text that need to be parsed
 * @param pos in/out parsing position. in case of failure, this shouldn't bechanged
 * @return double value, could be 0.0 if nothing can be parsed
 */
private double parseNumber(String text,int[] pos){
  double ret;
  boolean sawDecimal=false;
  boolean sawExponent=false;
  boolean sawDigit=false;
  int scale=1;
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String exponentChar=numberConstants.exponentialSymbol();
  StringBuffer normalizedText=new StringBuffer();
  for (; pos[0] < text.length(); ++pos[0]) {
    char ch=text.charAt(pos[0]);
    int digit=getDigit(ch);
    if (digit >= 0 && digit <= 9) {
      normalizedText.append((char)(digit + '0'));
      sawDigit=true;
    }
 else     if (ch == decimal.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      normalizedText.append('.');
      sawDecimal=true;
    }
 else     if (ch == grouping.charAt(0)) {
      if (sawDecimal || sawExponent) {
        break;
      }
      continue;
    }
 else     if (ch == exponentChar.charAt(0)) {
      if (sawExponent) {
        break;
      }
      normalizedText.append('E');
      sawExponent=true;
    }
 else     if (ch == '+' || ch == '-') {
      normalizedText.append(ch);
    }
 else     if (ch == numberConstants.percent().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=100;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else     if (ch == numberConstants.perMill().charAt(0)) {
      if (scale != 1) {
        break;
      }
      scale=1000;
      if (sawDigit) {
        ++pos[0];
        break;
      }
    }
 else {
      break;
    }
  }
  try {
    ret=Double.parseDouble(normalizedText.toString());
  }
 catch (  NumberFormatException e) {
    throw new NumberFormatException(text);
  }
  ret=ret / scale;
  return ret;
}",0.9772093023255812
54417,"public Contacts(){
  initWidget(panel=binder.createAndBindUi(this));
  for (int i=0; i < contacts.length; ++i) {
    addContact(contacts[i]);
  }
}","public Contacts(){
  initWidget(binder.createAndBindUi(this));
  for (int i=0; i < contacts.length; ++i) {
    addContact(contacts[i]);
  }
}",0.9791666666666666
54418,"/** 
 * Add a statement to be run after everything has been instantiated, in the style of   {@link String#format}
 */
public void addInitStatement(String format,Object... params){
  initStatements.add(String.format(format,params));
}","/** 
 * Add a statement to be run after everything has been instantiated, in the style of   {@link String#format}
 */
public void addInitStatement(String format,Object... params){
  initStatements.add(formatCode(format,params));
}",0.9503239740820736
54419,"/** 
 * Adds a statement to the block run after fields are declared, in the style of   {@link String#format}
 */
public void addStatement(String format,Object... args){
  statements.add(String.format(format,args));
}","/** 
 * Adds a statement to the block run after fields are declared, in the style of   {@link String#format}
 */
public void addStatement(String format,Object... args){
  statements.add(formatCode(format,args));
}",0.9463869463869464
54420,"/** 
 * Instructs the writer to initialize the field with a specific contructor invocaction, instead of the default GWT.create call.
 */
public void setFieldInitializerAsConstructor(String fieldName,JClassType type,String... args){
  setFieldInitializer(fieldName,String.format(""String_Node_Str"",type.getQualifiedSourceName(),asCommaSeparatedList(args)));
}","/** 
 * Instructs the writer to initialize the field with a specific contructor invocaction, instead of the default GWT.create call.
 */
public void setFieldInitializerAsConstructor(String fieldName,JClassType type,String... args){
  setFieldInitializer(fieldName,formatCode(""String_Node_Str"",type.getQualifiedSourceName(),asCommaSeparatedList(args)));
}",0.9676511954992968
54421,"/** 
 * Write declarations for variables or fields to hold elements declared with gwt:field in the template. For those that have not had constructor generation suppressed, emit GWT.create() calls instantiating them (or die if they have no default constructor).
 * @throws UnableToCompleteException on constructor problem
 */
private void writeGwtFields(IndentedWriter niceWriter) throws UnableToCompleteException {
  Collection<OwnerField> ownerFields=getOwnerClass().getUiFields();
  for (  OwnerField ownerField : ownerFields) {
    if (ownerField.isProvided()) {
      String fieldName=ownerField.getName();
      FieldWriter fieldWriter=fieldManager.lookup(fieldName);
      if (fieldWriter != null) {
        fieldManager.lookup(fieldName).setInitializerMaybe(String.format(""String_Node_Str"",fieldName));
      }
    }
  }
  fieldManager.writeGwtFieldsDeclaration(niceWriter,uiOwnerType.getName());
}","/** 
 * Write declarations for variables or fields to hold elements declared with gwt:field in the template. For those that have not had constructor generation suppressed, emit GWT.create() calls instantiating them (or die if they have no default constructor).
 * @throws UnableToCompleteException on constructor problem
 */
private void writeGwtFields(IndentedWriter niceWriter) throws UnableToCompleteException {
  Collection<OwnerField> ownerFields=getOwnerClass().getUiFields();
  for (  OwnerField ownerField : ownerFields) {
    if (ownerField.isProvided()) {
      String fieldName=ownerField.getName();
      FieldWriter fieldWriter=fieldManager.lookup(fieldName);
      if (fieldWriter != null) {
        fieldManager.lookup(fieldName).setInitializerMaybe(formatCode(""String_Node_Str"",fieldName));
      }
    }
  }
  fieldManager.writeGwtFieldsDeclaration(niceWriter,uiOwnerType.getName());
}",0.9872717210846708
54422,"@Override public List<TestInfo[]> getTestBlocks(String syntheticModuleName){
  Set<TestInfo> allTestsInModule=GWTTestCase.getTestsForModule(syntheticModuleName).getTests();
  TestInfo[] testBlock=allTestsInModule.toArray(new TestInfo[allTestsInModule.size()]);
  List<TestInfo[]> testBlocks=new ArrayList<TestInfo[]>();
  testBlocks.add(testBlock);
  return testBlocks;
}","@Override public List<TestInfo[]> getTestBlocks(String syntheticModuleName){
  Set<TestInfo> allTestsInModule=getTestsForModule(syntheticModuleName);
  List<TestInfo[]> testBlocks=new ArrayList<TestInfo[]>();
  if (allTestsInModule.size() > 0) {
    TestInfo[] testBlock=allTestsInModule.toArray(new TestInfo[allTestsInModule.size()]);
    testBlocks.add(testBlock);
  }
  return testBlocks;
}",0.5575916230366492
54423,"/** 
 * Get the list of remote user agents to compile. This method returns null until all clients have connected.
 * @return the list of remote user agents
 */
public static String[] getRemoteUserAgents(){
  return getUnitTestShell().remoteUserAgents;
}","/** 
 * Get the list of remote user agents to compile. This method returns null until all clients have connected.
 * @return the list of remote user agents
 */
public static String[] getRemoteUserAgents(){
  if (unitTestShell == null) {
    return null;
  }
  return unitTestShell.remoteUserAgents;
}",0.7992766726943942
54424,"/** 
 * Retrieves the JUnitShell. This should only be invoked during TestRunner execution of JUnit tests.
 */
private static JUnitShell getUnitTestShell(){
  if (unitTestShell == null) {
    unitTestShell=new JUnitShell();
    unitTestShell.lastLaunchFailed=true;
    String[] args=unitTestShell.synthesizeArgs();
    ArgProcessor argProcessor=unitTestShell.new ArgProcessor();
    if (!argProcessor.processArgs(args)) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.messageQueue=new JUnitMessageQueue(unitTestShell.numClients);
    if (!unitTestShell.startUp()) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.lastLaunchFailed=false;
  }
  return unitTestShell;
}","/** 
 * Retrieves the JUnitShell. This should only be invoked during TestRunner execution of JUnit tests.
 */
private static JUnitShell getUnitTestShell(){
  if (unitTestShell == null) {
    unitTestShell=new JUnitShell();
    unitTestShell.lastLaunchFailed=true;
    String[] args=unitTestShell.synthesizeArgs();
    ArgProcessor argProcessor=unitTestShell.new ArgProcessor();
    if (!argProcessor.processArgs(args)) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.messageQueue=new JUnitMessageQueue(unitTestShell.numClients);
    if (!unitTestShell.startUp()) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.lastLaunchFailed=false;
  }
  if (unitTestShell.thread != Thread.currentThread()) {
    throw new IllegalThreadStateException(""String_Node_Str"");
  }
  return unitTestShell;
}",0.8968944099378882
54425,"/** 
 * returns the set of banned   {@code Platform} for a test method.
 */
private static Set<Platform> getBannedPlatforms(TestCase testCase){
  Class<?> testClass=testCase.getClass();
  Set<Platform> bannedSet=EnumSet.noneOf(Platform.class);
  if (testClass.isAnnotationPresent(DoNotRunWith.class)) {
    bannedSet.addAll(Arrays.asList(testClass.getAnnotation(DoNotRunWith.class).value()));
  }
  try {
    Method testMethod=testClass.getMethod(testCase.getName());
    if (testMethod.isAnnotationPresent(DoNotRunWith.class)) {
      bannedSet.addAll(Arrays.asList(testMethod.getAnnotation(DoNotRunWith.class).value()));
    }
  }
 catch (  SecurityException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
  return bannedSet;
}","/** 
 * Returns the set of banned   {@code Platform} for a test method.
 * @param testClass the testClass
 * @param methodName the name of the test method
 */
private static Set<Platform> getBannedPlatforms(Class<?> testClass,String methodName){
  Set<Platform> bannedSet=EnumSet.noneOf(Platform.class);
  if (testClass.isAnnotationPresent(DoNotRunWith.class)) {
    bannedSet.addAll(Arrays.asList(testClass.getAnnotation(DoNotRunWith.class).value()));
  }
  try {
    Method testMethod=testClass.getMethod(methodName);
    if (testMethod.isAnnotationPresent(DoNotRunWith.class)) {
      bannedSet.addAll(Arrays.asList(testMethod.getAnnotation(DoNotRunWith.class).value()));
    }
  }
 catch (  SecurityException e) {
    e.printStackTrace();
  }
catch (  NoSuchMethodException e) {
    e.printStackTrace();
  }
  return bannedSet;
}",0.8971499380421314
54426,"/** 
 * Enforce the singleton pattern. The call to   {@link GWTShell}'s ctor forces server mode and disables processing extra arguments as URLs to be shown.
 */
private JUnitShell(){
  setRunTomcat(true);
  setHeadless(true);
  if (System.getProperty(PROP_JUNIT_HYBRID_MODE) != null) {
    runStyle=new RunStyleLocalWeb(this);
  }
}","/** 
 * Enforce the singleton pattern. The call to   {@link GWTShell}'s ctor forces server mode and disables processing extra arguments as URLs to be shown.
 */
private JUnitShell(){
  thread=Thread.currentThread();
  setRunTomcat(true);
  setHeadless(true);
  if (System.getProperty(PROP_JUNIT_HYBRID_MODE) != null) {
    runStyle=new RunStyleLocalWeb(this);
  }
}",0.9526542324246772
54427,"/** 
 * Runs a particular test case.
 */
private void runTestImpl(GWTTestCase testCase,TestResult testResult) throws UnableToCompleteException {
  if (mustNotExecuteTest(testCase)) {
    return;
  }
  if (lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  String moduleName=testCase.getModuleName();
  String syntheticModuleName=testCase.getSyntheticModuleName();
  Strategy strategy=testCase.getStrategy();
  boolean sameTest=(currentModule != null) && syntheticModuleName.equals(currentModule.getName());
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  if (!sameTest) {
    currentModule=compileStrategy.maybeCompileModule(moduleName,syntheticModuleName,strategy,runStyle,batchingStrategy,getTopLogger());
  }
  assert(currentModule != null);
  JUnitFatalLaunchException launchException=checkTestClassInCurrentModule(getTopLogger(),currentModule,moduleName,testCase);
  if (launchException != null) {
    testResult.addError(testCase,launchException);
    return;
  }
  currentTestInfo=new TestInfo(currentModule.getName(),testCase.getClass().getName(),testCase.getName());
  if (messageQueue.hasResults(currentTestInfo)) {
    processTestResult(testCase,testResult,strategy);
    return;
  }
  try {
    if (firstLaunch) {
      runStyle.launchModule(currentModule.getName());
    }
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTime=System.currentTimeMillis();
    testBeginTimeout=testBeginTime + TEST_BEGIN_TIMEOUT_MILLIS;
    testMethodTimeout=0;
    pumpEventLoop();
    if (pendingException != null) {
      UnableToCompleteException e=pendingException;
      pendingException=null;
      throw e;
    }
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  assert(messageQueue.hasResults(currentTestInfo));
  processTestResult(testCase,testResult,testCase.getStrategy());
}","/** 
 * Runs a particular test case.
 */
private void runTestImpl(GWTTestCase testCase,TestResult testResult) throws UnableToCompleteException {
  if (mustNotExecuteTest(getBannedPlatforms(testCase.getClass(),testCase.getName()))) {
    return;
  }
  if (lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  String moduleName=testCase.getModuleName();
  String syntheticModuleName=testCase.getSyntheticModuleName();
  Strategy strategy=testCase.getStrategy();
  boolean sameTest=(currentModule != null) && syntheticModuleName.equals(currentModule.getName());
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  if (!sameTest) {
    currentModule=compileStrategy.maybeCompileModule(moduleName,syntheticModuleName,strategy,runStyle,batchingStrategy,getTopLogger());
  }
  assert(currentModule != null);
  JUnitFatalLaunchException launchException=checkTestClassInCurrentModule(getTopLogger(),currentModule,moduleName,testCase);
  if (launchException != null) {
    testResult.addError(testCase,launchException);
    return;
  }
  currentTestInfo=new TestInfo(currentModule.getName(),testCase.getClass().getName(),testCase.getName());
  if (messageQueue.hasResults(currentTestInfo)) {
    processTestResult(testCase,testResult,strategy);
    return;
  }
  try {
    if (firstLaunch) {
      runStyle.launchModule(currentModule.getName());
    }
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTime=System.currentTimeMillis();
    testBeginTimeout=testBeginTime + TEST_BEGIN_TIMEOUT_MILLIS;
    testMethodTimeout=0;
    pumpEventLoop();
    if (pendingException != null) {
      UnableToCompleteException e=pendingException;
      pendingException=null;
      throw e;
    }
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  assert(messageQueue.hasResults(currentTestInfo));
  processTestResult(testCase,testResult,testCase.getStrategy());
}",0.983980582524272
54428,"@Override public void setName(String name){
  super.setName(name);
  if (JUnitShell.mustNotExecuteTest(this)) {
    return;
  }
synchronized (ALL_GWT_TESTS_LOCK) {
    String syntheticModuleName=getSyntheticModuleName();
    TestModuleInfo moduleInfo=ALL_GWT_TESTS.get(syntheticModuleName);
    if (moduleInfo == null) {
      moduleInfo=new TestModuleInfo(getModuleName(),syntheticModuleName,getStrategy());
      ALL_GWT_TESTS.put(syntheticModuleName,moduleInfo);
    }
    moduleInfo.getTests().add(new TestInfo(syntheticModuleName,getClass().getName(),getName()));
  }
}","@Override public void setName(String name){
  super.setName(name);
synchronized (ALL_GWT_TESTS_LOCK) {
    String syntheticModuleName=getSyntheticModuleName();
    TestModuleInfo moduleInfo=ALL_GWT_TESTS.get(syntheticModuleName);
    if (moduleInfo == null) {
      moduleInfo=new TestModuleInfo(getModuleName(),syntheticModuleName,getStrategy());
      ALL_GWT_TESTS.put(syntheticModuleName,moduleInfo);
    }
    moduleInfo.getTests().add(new TestInfo(syntheticModuleName,getClass().getName(),getName()));
  }
}",0.9438822447102116
54429,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(FakeMessagesMakerTest.class);
  suite.addTestSuite(BatchingStrategyTest.class);
  suite.addTestSuite(JUnitMessageQueueTest.class);
  suite.addTestSuite(GWTTestCaseNoClientTest.class);
  suite.addTestSuite(BenchmarkNoClientTest.class);
  suite.addTestSuite(GWTTestCaseTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(GWTTestCaseTest.class);
  suite.addTestSuite(BatchingStrategyTest.class);
  suite.addTestSuite(FakeMessagesMakerTest.class);
  suite.addTestSuite(JUnitMessageQueueTest.class);
  suite.addTestSuite(GWTTestCaseNoClientTest.class);
  suite.addTestSuite(BenchmarkNoClientTest.class);
  return suite;
}",0.8465346534653465
54430,"/** 
 * returns true iff execution completes normally.
 */
public boolean process() throws IOException, BrowserChannelException {
  if (!init()) {
    disconnectFromHost();
    return false;
  }
  logger.log(TreeLogger.DEBUG,""String_Node_Str"" + MessageType.LOAD_MODULE + ""String_Node_Str""+ htmlUnitSessionHandler.getUserAgent());
  ReturnMessage returnMessage=null;
synchronized (htmlUnitSessionHandler.getHtmlPage()) {
    new LoadModuleMessage(this,url,tabKey,sessionKey,moduleName,htmlUnitSessionHandler.getUserAgent()).send();
    returnMessage=reactToMessages(htmlUnitSessionHandler,true);
  }
  logger.log(TreeLogger.DEBUG,""String_Node_Str"" + returnMessage.getReturnValue() + ""String_Node_Str""+ returnMessage.isException());
  return !returnMessage.isException();
}","/** 
 * returns true iff execution completes normally.
 */
public boolean process() throws IOException, BrowserChannelException {
  if (!init()) {
    disconnectFromHost();
    return false;
  }
  logger.log(TreeLogger.DEBUG,""String_Node_Str"" + MessageType.LOAD_MODULE + ""String_Node_Str""+ htmlUnitSessionHandler.getUserAgent());
  ReturnMessage returnMessage=null;
synchronized (htmlUnitSessionHandler.getHtmlPage()) {
    new LoadModuleMessage(this,url,tabKey,sessionKey,moduleName,htmlUnitSessionHandler.getUserAgent()).send();
    returnMessage=reactToMessages(htmlUnitSessionHandler,true);
    if (shouldDisconnect) {
      disconnectFromHost();
    }
  }
  logger.log(TreeLogger.DEBUG,""String_Node_Str"" + returnMessage.getReturnValue() + ""String_Node_Str""+ returnMessage.isException());
  return !returnMessage.isException();
}",0.9613466334164588
54431,"public ReturnMessage reactToMessagesWhileWaitingForReturn(HtmlUnitSessionHandler handler) throws IOException, BrowserChannelException {
  return reactToMessages(handler,true);
}","public ReturnMessage reactToMessagesWhileWaitingForReturn(HtmlUnitSessionHandler handler) throws IOException, BrowserChannelException {
  ReturnMessage returnMessage=reactToMessages(handler,true);
  if (shouldDisconnect) {
    disconnectFromHost();
  }
  return returnMessage;
}",0.7472527472527473
54432,"public ExceptionOrReturnValue invoke(BrowserChannel channel,Value thisObj,String methodName,Value[] args){
  logger.log(TreeLogger.DEBUG,""String_Node_Str"" + thisObj + ""String_Node_Str""+ methodName+ ""String_Node_Str""+ args);
  Context jsContext=Context.getCurrentContext();
  ScriptableObject jsThis;
  if (thisObj.getType() == ValueType.NULL) {
    jsThis=(ScriptableObject)window;
  }
 else {
    jsThis=(ScriptableObject)makeJsvalFromValue(jsContext,thisObj);
  }
  Object functionObject=ScriptableObject.getProperty((ScriptableObject)window,methodName);
  if (functionObject == ScriptableObject.NOT_FOUND) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + methodName + ""String_Node_Str""+ jsThis+ ""String_Node_Str""+ methodName);
    return new ExceptionOrReturnValue(true,new Value(null));
  }
  Function jsFunction=(Function)functionObject;
  logger.log(TreeLogger.SPAM,""String_Node_Str"" + jsFunction);
  Object jsArgs[]=new Object[args.length];
  for (int i=0; i < args.length; i++) {
    jsArgs[i]=makeJsvalFromValue(jsContext,args[i]);
  }
  Object result=null;
  try {
    result=jsEngine.callFunction(htmlPage,jsFunction,jsContext,window,jsThis,jsArgs);
  }
 catch (  JavaScriptException ex) {
    logger.log(TreeLogger.INFO,""String_Node_Str"" + ex + ""String_Node_Str""+ ex.getMessage()+ ""String_Node_Str""+ methodName);
    return new ExceptionOrReturnValue(true,makeValueFromJsval(jsContext,ex.getValue()));
  }
catch (  Exception ex) {
    logger.log(TreeLogger.INFO,""String_Node_Str"" + ex + ""String_Node_Str""+ ex.getMessage()+ ""String_Node_Str""+ methodName);
    return new ExceptionOrReturnValue(true,makeValueFromJsval(jsContext,Undefined.instance));
  }
  logger.log(TreeLogger.INFO,""String_Node_Str"" + result + ""String_Node_Str""+ jsFunction);
  return new ExceptionOrReturnValue(false,makeValueFromJsval(jsContext,result));
}","public ExceptionOrReturnValue invoke(BrowserChannel channel,Value thisObj,String methodName,Value[] args){
  logger.log(TreeLogger.DEBUG,""String_Node_Str"" + thisObj + ""String_Node_Str""+ methodName+ ""String_Node_Str""+ args);
  Context jsContext=Context.getCurrentContext();
  ScriptableObject jsThis;
  if (thisObj.getType() == ValueType.NULL) {
    jsThis=(ScriptableObject)window;
  }
 else {
    jsThis=(ScriptableObject)makeJsvalFromValue(jsContext,thisObj);
  }
  Object functionObject=ScriptableObject.getProperty((ScriptableObject)window,methodName);
  if (functionObject == ScriptableObject.NOT_FOUND) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"" + methodName + ""String_Node_Str""+ jsThis+ ""String_Node_Str""+ methodName);
    return new ExceptionOrReturnValue(true,new Value(null));
  }
  Function jsFunction=(Function)functionObject;
  logger.log(TreeLogger.SPAM,""String_Node_Str"" + jsFunction);
  Object jsArgs[]=new Object[args.length];
  for (int i=0; i < args.length; i++) {
    jsArgs[i]=makeJsvalFromValue(jsContext,args[i]);
  }
  Object result=null;
  try {
    if (args.length == 1 && methodName.indexOf(REPLACE_METHOD_SIGNATURE) != -1) {
      String currentUrl=window.jsxGet_location().toString();
      currentUrl=getUrlBeforeHash(currentUrl);
      String newUrl=getUrlBeforeHash((String)args[0].getValue());
      if (!newUrl.equals(currentUrl)) {
        window.getWebWindow().getTopWindow().getJobManager().removeAllJobs();
        ((BrowserChannelClient)channel).shouldDisconnect=true;
      }
    }
    result=jsEngine.callFunction(htmlPage,jsFunction,jsContext,window,jsThis,jsArgs);
  }
 catch (  JavaScriptException ex) {
    logger.log(TreeLogger.INFO,""String_Node_Str"" + ex + ""String_Node_Str""+ ex.getMessage()+ ""String_Node_Str""+ methodName);
    return new ExceptionOrReturnValue(true,makeValueFromJsval(jsContext,ex.getValue()));
  }
catch (  Exception ex) {
    logger.log(TreeLogger.INFO,""String_Node_Str"" + ex + ""String_Node_Str""+ ex.getMessage()+ ""String_Node_Str""+ methodName);
    return new ExceptionOrReturnValue(true,makeValueFromJsval(jsContext,Undefined.instance));
  }
  logger.log(TreeLogger.INFO,""String_Node_Str"" + result + ""String_Node_Str""+ jsFunction);
  return new ExceptionOrReturnValue(false,makeValueFromJsval(jsContext,result));
}",0.8870616686819831
54433,"public void onModuleLoad(){
  SplitLayoutPanel p=new SplitLayoutPanel();
  p.add(new HTML(""String_Node_Str""),Direction.WEST,128);
  p.add(new HTML(""String_Node_Str""),Direction.NORTH,384);
  p.add(new HTML(""String_Node_Str""),Direction.CENTER,0);
  p.layout();
  RootLayoutPanel rp=RootLayoutPanel.get();
  rp.add(p);
  rp.layout();
}","public void onModuleLoad(){
  SplitLayoutPanel p=new SplitLayoutPanel();
  p.addWest(new HTML(""String_Node_Str""),128);
  p.addNorth(new HTML(""String_Node_Str""),384);
  p.add(new HTML(""String_Node_Str""));
  p.layout();
  RootLayoutPanel rp=RootLayoutPanel.get();
  rp.add(p);
  rp.layout();
}",0.9052969502407704
54434,"/** 
 * Gets the container element associated with the given child widget. <p> The container element is created by the   {@link Layout} class. This shouldbe used with certain styles, such as  {@link Style#setZIndex(int)}, that must be applied to the container, rather than directly to the child widget. </p> TODO(jgw): Is this really the best way to do this?
 * @param widget the widget whose container element is to be retrieved
 * @return the widget's container element
 */
public Element getContainerElementFor(Widget widget){
  assertIsChild(widget);
  return ((LayoutData)widget.getLayoutData()).layer.getContainerElement();
}","/** 
 * Gets the container element associated with the given child widget. <p> The container element is created by the   {@link Layout} class. This shouldbe used with certain styles, such as {@link com.google.gwt.dom.client.Style#setZIndex(int)}, that must be applied to the container, rather than directly to the child widget. </p> TODO(jgw): Is this really the best way to do this?
 * @param widget the widget whose container element is to be retrieved
 * @return the widget's container element
 */
public Element getContainerElementFor(Widget widget){
  assertIsChild(widget);
  return ((LayoutData)widget.getLayoutData()).layer.getContainerElement();
}",0.9790209790209792
54435,"public void makeBreakdownShell(SizeBreakdown breakdown,String permutationId) throws IOException {
  Map<String,CodeCollection> nameToCodeColl=breakdown.nameToCodeColl;
  Map<String,LiteralsCollection> nameToLitColl=breakdown.nameToLitColl;
  String classPath=settings.resources.get();
  if (classPath == null) {
    classPath=System.getProperty(""String_Node_Str"");
  }
  if (!classPath.endsWith(""String_Node_Str"")) {
    classPath+=""String_Node_Str"";
  }
  String inputFileName=""String_Node_Str"";
  File inputFile=new File(classPath + RESOURCES_PATH + inputFileName);
  File outputFile=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile,outputFile,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputFile2=new File(classPath + RESOURCES_PATH + inputFileName);
  File outputFile2=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile2,outputFile2,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputFile3=new File(classPath + RESOURCES_PATH + inputFileName);
  File outputFile3=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile3,outputFile3,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputDir=new File(classPath + RESOURCES_PATH + ""String_Node_Str"");
  File outputDir=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputDir,outputDir,classPath,inputFileName,true);
  final PrintWriter outFile=new PrintWriter(getOutFile(shellFileName(breakdown,permutationId)));
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  addHeaderWithBreakdownContext(breakdown,outFile);
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  String packageBreakdownFileName=makePackageHtml(breakdown,permutationId);
  outFile.println(""String_Node_Str"" + packageBreakdownFileName + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  String codeTypeBreakdownFileName=makeCodeTypeHtml(breakdown,nameToCodeColl,nameToLitColl,permutationId);
  outFile.println(""String_Node_Str"" + codeTypeBreakdownFileName + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.close();
}","public void makeBreakdownShell(SizeBreakdown breakdown,String permutationId) throws IOException {
  Map<String,CodeCollection> nameToCodeColl=breakdown.nameToCodeColl;
  Map<String,LiteralsCollection> nameToLitColl=breakdown.nameToLitColl;
  String classPath=settings.resources.get();
  if (classPath == null) {
    classPath=System.getProperty(""String_Node_Str"");
  }
  if (!classPath.endsWith(""String_Node_Str"")) {
    classPath+=""String_Node_Str"";
  }
  String inputFileName=""String_Node_Str"";
  File inputFile=new File(classPath + RESOURCES_PATH + inputFileName);
  if (!inputFile.exists()) {
    inputFile=new File(classPath + inputFileName);
  }
  File outputFile=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile,outputFile,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputFile2=new File(classPath + RESOURCES_PATH + inputFileName);
  if (!inputFile2.exists()) {
    inputFile2=new File(classPath + inputFileName);
  }
  File outputFile2=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile2,outputFile2,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputFile3=new File(classPath + RESOURCES_PATH + inputFileName);
  if (!inputFile3.exists()) {
    inputFile3=new File(classPath + inputFileName);
  }
  File outputFile3=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputFile3,outputFile3,classPath,RESOURCES_PATH + inputFileName,false);
  inputFileName=""String_Node_Str"";
  File inputDir=new File(classPath + RESOURCES_PATH + ""String_Node_Str"");
  if (!inputDir.exists()) {
    inputDir=new File(classPath + ""String_Node_Str"");
  }
  File outputDir=getOutFile(""String_Node_Str"");
  copyFileOrDirectory(inputDir,outputDir,classPath,inputFileName,true);
  final PrintWriter outFile=new PrintWriter(getOutFile(shellFileName(breakdown,permutationId)));
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  addHeaderWithBreakdownContext(breakdown,outFile);
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  String packageBreakdownFileName=makePackageHtml(breakdown,permutationId);
  outFile.println(""String_Node_Str"" + packageBreakdownFileName + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  String codeTypeBreakdownFileName=makeCodeTypeHtml(breakdown,nameToCodeColl,nameToLitColl,permutationId);
  outFile.println(""String_Node_Str"" + codeTypeBreakdownFileName + ""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.println(""String_Node_Str"");
  outFile.close();
}",0.9631624299870746
54436,"/** 
 * Interprets <ui:with> elements.
 */
private void createResource(XMLElement elem) throws UnableToCompleteException {
  String resourceName=elem.consumeRequiredAttribute(""String_Node_Str"");
  JClassType resourceType=consumeTypeAttribute(elem);
  if (elem.getAttributeCount() > 0) {
    writer.die(""String_Node_Str"");
  }
  FieldWriter fieldWriter=fieldManager.registerField(resourceType,resourceName);
  OwnerField ownerField=writer.getOwnerClass().getUiField(resourceName);
  if (ownerField != null) {
    if (!resourceType.equals(ownerField.getType().getRawType())) {
      writer.die(""String_Node_Str"",ownerField);
    }
    if (ownerField.isProvided()) {
      fieldWriter.setInitializer(""String_Node_Str"" + ownerField.getName());
      return;
    }
  }
  JMethod factoryMethod=writer.getOwnerClass().getUiFactoryMethod(resourceType);
  if (factoryMethod != null) {
    fieldWriter.setInitializer(String.format(""String_Node_Str"",factoryMethod.getName()));
  }
}","/** 
 * Interprets <ui:with> elements.
 */
private void createResource(XMLElement elem) throws UnableToCompleteException {
  String resourceName=elem.consumeRequiredAttribute(""String_Node_Str"");
  JClassType resourceType=consumeTypeAttribute(elem);
  if (elem.getAttributeCount() > 0) {
    writer.die(""String_Node_Str"",elem);
  }
  FieldWriter fieldWriter=fieldManager.registerField(resourceType,resourceName);
  OwnerField ownerField=writer.getOwnerClass().getUiField(resourceName);
  if (ownerField != null) {
    if (!resourceType.equals(ownerField.getType().getRawType())) {
      writer.die(""String_Node_Str"",elem,ownerField);
    }
    if (ownerField.isProvided()) {
      fieldWriter.setInitializer(""String_Node_Str"" + ownerField.getName());
      return;
    }
  }
  JMethod factoryMethod=writer.getOwnerClass().getUiFactoryMethod(resourceType);
  if (factoryMethod != null) {
    fieldWriter.setInitializer(String.format(""String_Node_Str"",factoryMethod.getName()));
  }
}",0.9948770491803278
54437,"/** 
 * Dependency information is normally recorded during code splitting, and it results in multiple dependency graphs. If the code splitter doesn't run, then this method can be used instead to record a single dependency graph for the whole program.
 */
private static void recordNonSplitDependencies(JProgram program,OutputStream out){
  DependencyRecorder deps=new DependencyRecorder(out);
  deps.open();
  deps.startDependencyGraph(""String_Node_Str"",null);
  ControlFlowAnalyzer cfa=new ControlFlowAnalyzer(program);
  cfa.setDependencyRecorder(deps);
  for (  List<JMethod> entryList : program.entryMethods) {
    for (    JMethod entry : entryList)     cfa.traverseFrom(entry);
  }
  deps.endDependencyGraph();
  deps.close();
}","/** 
 * Dependency information is normally recorded during code splitting, and it results in multiple dependency graphs. If the code splitter doesn't run, then this method can be used instead to record a single dependency graph for the whole program.
 */
private static void recordNonSplitDependencies(JProgram program,OutputStream out){
  DependencyRecorder deps=new DependencyRecorder(out);
  deps.open();
  deps.startDependencyGraph(""String_Node_Str"",null);
  ControlFlowAnalyzer cfa=new ControlFlowAnalyzer(program);
  cfa.setDependencyRecorder(deps);
  for (  List<JMethod> entryList : program.entryMethods) {
    for (    JMethod entry : entryList) {
      cfa.traverseFrom(entry);
    }
  }
  deps.endDependencyGraph();
  deps.close();
}",0.993234100135318
54438,int getPortHosted();,"public int getPortHosted(){
  return portHosted;
}",0.5714285714285714
54439,void setPortHosted(int portHosted);,"public void setPortHosted(int port){
  portHosted=port;
}",0.7391304347826086
54440,"@Override public String getTagName(Element elem){
  String tagName=getTagNameInternal(elem);
  String scopeName=getScopeNameInternal(elem);
  if (""String_Node_Str"".equalsIgnoreCase(scopeName) || ""String_Node_Str"".equalsIgnoreCase(scopeName)) {
    return tagName;
  }
  return scopeName + ""String_Node_Str"" + tagName;
}","@Override public String getTagName(Element elem){
  String tagName=getTagNameInternal(elem);
  String scopeName=getScopeNameInternal(elem);
  if ((scopeName == null) || ""String_Node_Str"".equalsIgnoreCase(scopeName)) {
    return tagName;
  }
  return scopeName + ""String_Node_Str"" + tagName;
}",0.8986928104575164
54441,"/** 
 * Create a method call whose type is overridden to the specified type, ignoring the return type of the target method. This constructor is used during normalizing transformations to preserve type semantics when calling externally-defined compiler implementation methods. For example, Cast.dynamicCast() returns Object but that method is used to implement the cast operation. Using a stronger type on the call expression allows us to preserve type information during the latter phases of compilation.
 */
public JMethodCall(SourceInfo info,JExpression instance,JMethod method,JType overrideReturnType){
  super(info);
  this.instance=instance;
  this.method=method;
  assert(overrideReturnType != null);
  this.overrideReturnType=overrideReturnType;
}","/** 
 * Create a method call whose type is overridden to the specified type, ignoring the return type of the target method. This constructor is used during normalizing transformations to preserve type semantics when calling externally-defined compiler implementation methods. For example, Cast.dynamicCast() returns Object but that method is used to implement the cast operation. Using a stronger type on the call expression allows us to preserve type information during the latter phases of compilation.
 */
public JMethodCall(SourceInfo info,JExpression instance,JMethod method,JType overrideReturnType){
  super(info);
  assert(method != null);
  assert(instance != null || method.isStatic());
  this.instance=instance;
  this.method=method;
  assert(overrideReturnType != null);
  this.overrideReturnType=overrideReturnType;
}",0.8643533123028391
54442,"public void testExpires(){
  Date expiresEarly=new Date(new Date().getTime() + (5 * 1000));
  Date expiresLate=new Date(new Date().getTime() + (60 * 1000));
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",expiresEarly);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",expiresLate);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null);
  Timer timer=new Timer(){
    public void run(){
      assertNull(Cookies.getCookie(""String_Node_Str""));
      assertEquals(Cookies.getCookie(""String_Node_Str""),""String_Node_Str"");
      assertEquals(Cookies.getCookie(""String_Node_Str""),""String_Node_Str"");
      Cookies.removeCookie(""String_Node_Str"");
      assertNull(Cookies.getCookie(""String_Node_Str""));
      finishTest();
    }
  }
;
  timer.schedule(5010);
  delayTestFinish(6 * 1000);
}","public void testExpires(){
  int uniqueId=Random.nextInt(9000000) + 1000000;
  final String earlyCookie=""String_Node_Str"" + uniqueId;
  final String lateCookie=""String_Node_Str"" + uniqueId;
  final String sessionCookie=""String_Node_Str"" + uniqueId;
  Date expiresEarly=new Date(new Date().getTime() + (5 * 1000));
  Date expiresLate=new Date(new Date().getTime() + (60 * 1000));
  Cookies.setCookie(earlyCookie,""String_Node_Str"",expiresEarly);
  Cookies.setCookie(lateCookie,""String_Node_Str"",expiresLate);
  Cookies.setCookie(sessionCookie,""String_Node_Str"",null);
  Timer timer=new Timer(){
    @Override public void run(){
      assertNull(Cookies.getCookie(earlyCookie));
      assertEquals(Cookies.getCookie(lateCookie),""String_Node_Str"");
      assertEquals(Cookies.getCookie(sessionCookie),""String_Node_Str"");
      Cookies.removeCookie(sessionCookie);
      assertNull(Cookies.getCookie(sessionCookie));
      finishTest();
    }
  }
;
  timer.schedule(5010);
  delayTestFinish(6 * 1000);
}",0.5669988925802879
54443,"/** 
 * Clear out all existing cookies.
 */
private void clearCookies(){
  Collection<String> cookies=Cookies.getCookieNames();
  for (  String cookie : cookies) {
    Cookies.removeCookie(cookie);
  }
}","/** 
 * Clear out all existing cookies, except the ones used in  {@link #testExpires()}.
 */
private void clearCookies(){
  Collection<String> cookies=Cookies.getCookieNames();
  for (  String cookie : cookies) {
    if (!cookie.startsWith(""String_Node_Str"")) {
      Cookies.removeCookie(cookie);
    }
  }
}",0.765625
54444,"/** 
 * Test that removing cookies with a path works correctly. Note that we do not verify failure to remove a cookie set with a path but removed without one as browser behavior differs.
 */
public void testRemoveCookiePath(){
  clearCookies();
  Cookies.setUriEncode(false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Collection<String> cookies=Cookies.getCookieNames();
  assertEquals(3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
  clearCookies();
  Cookies.setUriEncode(true);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  cookies=Cookies.getCookieNames();
  assertEquals(3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
}","/** 
 * Test that removing cookies with a path works correctly. Note that we do not verify failure to remove a cookie set with a path but removed without one as browser behavior differs.
 */
public void testRemoveCookiePath(){
  clearCookies();
  Cookies.setUriEncode(false);
  int curCount=Cookies.getCookieNames().size();
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Collection<String> cookies=Cookies.getCookieNames();
  assertEquals(curCount + 3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
  clearCookies();
  Cookies.setUriEncode(true);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",false);
  cookies=Cookies.getCookieNames();
  assertEquals(curCount + 3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
}",0.9834801762114538
54445,"public void run(){
  assertNull(Cookies.getCookie(""String_Node_Str""));
  assertEquals(Cookies.getCookie(""String_Node_Str""),""String_Node_Str"");
  assertEquals(Cookies.getCookie(""String_Node_Str""),""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  assertNull(Cookies.getCookie(""String_Node_Str""));
  finishTest();
}","@Override public void run(){
  assertNull(Cookies.getCookie(earlyCookie));
  assertEquals(Cookies.getCookie(lateCookie),""String_Node_Str"");
  assertEquals(Cookies.getCookie(sessionCookie),""String_Node_Str"");
  Cookies.removeCookie(sessionCookie);
  assertNull(Cookies.getCookie(sessionCookie));
  finishTest();
}",0.6541471048513302
54446,"/** 
 * Test that removing cookies works correctly.
 */
public void testRemoveCookie(){
  clearCookies();
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Collection<String> cookies=Cookies.getCookieNames();
  assertEquals(3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
  Cookies.setUriEncode(false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  cookies=Cookies.getCookieNames();
  assertEquals(0,cookies.size());
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}","/** 
 * Test that removing cookies works correctly.
 */
public void testRemoveCookie(){
  clearCookies();
  int curCount=Cookies.getCookieNames().size();
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Collection<String> cookies=Cookies.getCookieNames();
  assertEquals(curCount + 3,cookies.size());
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(""String_Node_Str"",Cookies.getCookie(""String_Node_Str""));
  Cookies.removeCookie(""String_Node_Str"");
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  assertEquals(null,Cookies.getCookie(""String_Node_Str""));
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
  Cookies.setUriEncode(false);
  Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
  Cookies.removeCookie(""String_Node_Str"");
  cookies=Cookies.getCookieNames();
  assertEquals(curCount,cookies.size());
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    Cookies.setCookie(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}",0.983248928710557
54447,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}",0.9230769230769232
54448,"private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
}","private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
}",0.9875042215467748
54449,"public void addBugs(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2318());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new Issue2855());
  addIssue(new Issue3172());
}","public void addBugs(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2318());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new Issue2855());
  addIssue(new Issue3172());
  addIssue(new Issue3973());
}",0.9754028837998304
54450,"@Override protected void onDetach(){
  super.onDetach();
  if (synthesizedFrame != null) {
    impl.unhookEvents(synthesizedFrame,getElement());
    Document.get().getBody().removeChild(synthesizedFrame);
    synthesizedFrame=null;
  }
}","@Override protected void onDetach(){
  super.onDetach();
  impl.unhookEvents(synthesizedFrame,getElement());
  if (synthesizedFrame != null) {
    Document.get().getBody().removeChild(synthesizedFrame);
    synthesizedFrame=null;
  }
}",0.7288135593220338
54451,"@Override protected void onAttach(){
  super.onAttach();
  if (frameName != null) {
    createFrame();
    Document.get().getBody().appendChild(synthesizedFrame);
    impl.hookEvents(synthesizedFrame,getElement(),this);
  }
}","@Override protected void onAttach(){
  super.onAttach();
  if (frameName != null) {
    createFrame();
    Document.get().getBody().appendChild(synthesizedFrame);
  }
  impl.hookEvents(synthesizedFrame,getElement(),this);
}",0.9866071428571428
54452,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(AsyncProxyTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(CalendarUtilTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FileUploadTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(TreeItemTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  suite.addTestSuite(RootPanelTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(AsyncProxyTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(CalendarUtilTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FileUploadTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(FormPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(TreeItemTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  suite.addTestSuite(RootPanelTest.class);
  return suite;
}",0.9937977787393624
54453,"public void addBugs(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2318());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new Issue2855());
  addIssue(new Issue3172());
  addIssue(new Issue3973());
}","public void addBugs(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2318());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new Issue2855());
  addIssue(new Issue3172());
  addIssue(new Issue3962());
  addIssue(new Issue3973());
}",0.9765561843168956
54454,"/** 
 * IE returns a numeric type for some attributes that are really properties, such as offsetWidth.  We need to coerce these to strings to prevent a runtime JS exception.
 */
@Override public native String getAttribute(Element elem,String name);","/** 
 * IE returns a numeric type for some attributes that are really properties, such as offsetWidth. We need to coerce these to strings to prevent a runtime JS exception.
 */
@Override public native String getAttribute(Element elem,String name);",0.997979797979798
54455,"public String getTagName(Element elem){
  String tagName=getTagNameInternal(elem);
  String scopeName=getScopeNameInternal(elem);
  if (""String_Node_Str"".equalsIgnoreCase(scopeName) || ""String_Node_Str"".equalsIgnoreCase(scopeName)) {
    return tagName;
  }
  return scopeName + ""String_Node_Str"" + tagName;
}","@Override public String getTagName(Element elem){
  String tagName=getTagNameInternal(elem);
  String scopeName=getScopeNameInternal(elem);
  if (""String_Node_Str"".equalsIgnoreCase(scopeName) || ""String_Node_Str"".equalsIgnoreCase(scopeName)) {
    return tagName;
  }
  return scopeName + ""String_Node_Str"" + tagName;
}",0.9840764331210192
54456,"public void execute(){
  unregisterCallbacks(CALLBACKS);
  Node script=Document.get().getElementById(callbackId);
  getDocumentElement().getFirstChild().removeChild(script);
}","public void execute(){
  unregisterCallbacks(CALLBACKS);
  Node script=Document.get().getElementById(callbackId);
  getHeadElement().removeChild(script);
}",0.9212121212121211
54457,"/** 
 * Cleans everything once the response has been received: deletes the script tag and unregisters the callback.
 */
private void unload(){
  DeferredCommand.addCommand(new Command(){
    public void execute(){
      unregisterCallbacks(CALLBACKS);
      Node script=Document.get().getElementById(callbackId);
      getDocumentElement().getFirstChild().removeChild(script);
    }
  }
);
}","/** 
 * Cleans everything once the response has been received: deletes the script tag and unregisters the callback.
 */
private void unload(){
  DeferredCommand.addCommand(new Command(){
    public void execute(){
      unregisterCallbacks(CALLBACKS);
      Node script=Document.get().getElementById(callbackId);
      getHeadElement().removeChild(script);
    }
  }
);
}",0.963254593175853
54458,"/** 
 * Sends a request using the JSONP mechanism.
 * @param baseUri To be sent to the server.
 */
void send(final String baseUri){
  registerCallbacks(CALLBACKS);
  StringBuffer uri=new StringBuffer(baseUri);
  uri.append(baseUri.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  String prefix=CALLBACKS_NAME + ""String_Node_Str"" + callbackId;
  uri.append(callbackParam).append(""String_Node_Str"").append(prefix).append(""String_Node_Str"");
  if (failureCallbackParam != null) {
    uri.append(""String_Node_Str"");
    uri.append(failureCallbackParam).append(""String_Node_Str"").append(prefix).append(""String_Node_Str"");
  }
  ScriptElement script=Document.get().createScriptElement();
  script.setType(""String_Node_Str"");
  script.setId(callbackId);
  script.setSrc(uri.toString());
  getDocumentElement().getFirstChild().appendChild(script);
  timer=new Timer(){
    @Override public void run(){
      onFailure(new TimeoutException(""String_Node_Str"" + baseUri));
    }
  }
;
  timer.schedule(timeout);
}","/** 
 * Sends a request using the JSONP mechanism.
 * @param baseUri To be sent to the server.
 */
void send(final String baseUri){
  registerCallbacks(CALLBACKS);
  StringBuffer uri=new StringBuffer(baseUri);
  uri.append(baseUri.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  String prefix=CALLBACKS_NAME + ""String_Node_Str"" + callbackId;
  uri.append(callbackParam).append(""String_Node_Str"").append(prefix).append(""String_Node_Str"");
  if (failureCallbackParam != null) {
    uri.append(""String_Node_Str"");
    uri.append(failureCallbackParam).append(""String_Node_Str"").append(prefix).append(""String_Node_Str"");
  }
  ScriptElement script=Document.get().createScriptElement();
  script.setType(""String_Node_Str"");
  script.setId(callbackId);
  script.setSrc(uri.toString());
  getHeadElement().appendChild(script);
  timer=new Timer(){
    @Override public void run(){
      onFailure(new TimeoutException(""String_Node_Str"" + baseUri));
    }
  }
;
  timer.schedule(timeout);
}",0.986206896551724
54459,"/** 
 * Adds a widget to the panel at the specified position. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the widget to be added
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void add(Widget w,int left,int top){
  w.removeFromParent();
  setWidgetPositionImpl(w,left,top);
  add(w);
}","/** 
 * Adds a widget to the panel at the specified position. Setting a position of <code>(-1, -1)</code> will cause the child widget to be positioned statically.
 * @param w the widget to be added
 * @param left the widget's left position
 * @param top the widget's top position
 */
public void add(Widget w,int left,int top){
  w.removeFromParent();
  int beforeIndex=getWidgetCount();
  setWidgetPositionImpl(w,left,top);
  insert(w,beforeIndex);
}",0.925969447708578
54460,"/** 
 * Adds the specified widget to the deck.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element container=createWidgetContainer();
  DOM.appendChild(getElement(),container);
  super.add(w,container);
  finishWidgetInitialization(container,w);
}","@Override public void add(Widget w){
  Element container=createWidgetContainer();
  DOM.appendChild(getElement(),container);
  super.add(w,container);
  finishWidgetInitialization(container,w);
}",0.819327731092437
54461,"/** 
 * Inserts a widget before the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  Element container=createWidgetContainer();
  DOM.insertChild(getElement(),container,beforeIndex);
  insert(w,container,beforeIndex,true);
  finishWidgetInitialization(container,w);
}","public void insert(Widget w,int beforeIndex){
  Element container=createWidgetContainer();
  DOM.insertChild(getElement(),container,beforeIndex);
  insert(w,container,beforeIndex,true);
  finishWidgetInitialization(container,w);
}",0.6571428571428571
54462,"/** 
 * Adds a child widget to the panel. If the Widget is already attached to the HorizontalPanel, it will be moved to the end of the panel.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element td=createAlignedTd();
  DOM.appendChild(tableRow,td);
  add(w,td);
}","@Override public void add(Widget w){
  Element td=createAlignedTd();
  DOM.appendChild(tableRow,td);
  add(w,td);
}",0.559610705596107
54463,"/** 
 * Inserts a widget before the specified index. If the Widget is already attached to the HorizontalPanel, it will be moved to the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  checkIndexBoundsForInsertion(beforeIndex);
  Element td=createAlignedTd();
  DOM.insertChild(tableRow,td,beforeIndex);
  insert(w,td,beforeIndex,false);
}","public void insert(Widget w,int beforeIndex){
  checkIndexBoundsForInsertion(beforeIndex);
  Element td=createAlignedTd();
  DOM.insertChild(tableRow,td,beforeIndex);
  insert(w,td,beforeIndex,false);
}",0.5437415881561238
54464,"/** 
 * Inserts a widget before the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  Element trh=DOM.createTR();
  Element tdh=DOM.createTD();
  DOM.appendChild(trh,tdh);
  DOM.appendChild(tdh,createHeaderElem());
  Element trb=DOM.createTR();
  Element tdb=DOM.createTD();
  DOM.appendChild(trb,tdb);
  beforeIndex=adjustIndex(w,beforeIndex);
  int effectiveIndex=beforeIndex * 2;
  DOM.insertChild(body,trb,effectiveIndex);
  DOM.insertChild(body,trh,effectiveIndex);
  setStyleName(tdh,DEFAULT_ITEM_STYLENAME,true);
  DOM.setElementPropertyInt(tdh,""String_Node_Str"",hashCode());
  DOM.setElementProperty(tdh,""String_Node_Str"",""String_Node_Str"");
  setStyleName(tdb,DEFAULT_STYLENAME + ""String_Node_Str"",true);
  DOM.setElementProperty(tdb,""String_Node_Str"",""String_Node_Str"");
  DOM.setElementProperty(tdb,""String_Node_Str"",""String_Node_Str"");
  insert(w,tdb,beforeIndex,false);
  updateIndicesFrom(beforeIndex);
  if (visibleStack == -1) {
    showStack(0);
  }
 else {
    setStackVisible(beforeIndex,false);
    if (visibleStack >= beforeIndex) {
      ++visibleStack;
    }
    setStackVisible(visibleStack,true);
  }
}","public void insert(Widget w,int beforeIndex){
  Element trh=DOM.createTR();
  Element tdh=DOM.createTD();
  DOM.appendChild(trh,tdh);
  DOM.appendChild(tdh,createHeaderElem());
  Element trb=DOM.createTR();
  Element tdb=DOM.createTD();
  DOM.appendChild(trb,tdb);
  beforeIndex=adjustIndex(w,beforeIndex);
  int effectiveIndex=beforeIndex * 2;
  DOM.insertChild(body,trb,effectiveIndex);
  DOM.insertChild(body,trh,effectiveIndex);
  setStyleName(tdh,DEFAULT_ITEM_STYLENAME,true);
  DOM.setElementPropertyInt(tdh,""String_Node_Str"",hashCode());
  DOM.setElementProperty(tdh,""String_Node_Str"",""String_Node_Str"");
  setStyleName(tdb,DEFAULT_STYLENAME + ""String_Node_Str"",true);
  DOM.setElementProperty(tdb,""String_Node_Str"",""String_Node_Str"");
  DOM.setElementProperty(tdb,""String_Node_Str"",""String_Node_Str"");
  insert(w,tdb,beforeIndex,false);
  updateIndicesFrom(beforeIndex);
  if (visibleStack == -1) {
    showStack(0);
  }
 else {
    setStackVisible(beforeIndex,false);
    if (visibleStack >= beforeIndex) {
      ++visibleStack;
    }
    setStackVisible(visibleStack,true);
  }
}",0.9007444168734492
54465,"/** 
 * Adds a child widget to the panel. If the Widget is already attached to the VerticalPanel, it will be moved to the end of the panel.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element tr=DOM.createTR();
  Element td=createAlignedTd();
  DOM.appendChild(tr,td);
  DOM.appendChild(getBody(),tr);
  add(w,td);
}","@Override public void add(Widget w){
  Element tr=DOM.createTR();
  Element td=createAlignedTd();
  DOM.appendChild(tr,td);
  DOM.appendChild(getBody(),tr);
  add(w,td);
}",0.6564299424184261
54466,"/** 
 * Inserts a widget before the specified index. If the Widget is already attached to the VerticalPanel, it will be moved to the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  checkIndexBoundsForInsertion(beforeIndex);
  Element tr=DOM.createTR();
  Element td=createAlignedTd();
  DOM.appendChild(tr,td);
  DOM.insertChild(getBody(),tr,beforeIndex);
  insert(w,td,beforeIndex,false);
}","public void insert(Widget w,int beforeIndex){
  checkIndexBoundsForInsertion(beforeIndex);
  Element tr=DOM.createTR();
  Element td=createAlignedTd();
  DOM.appendChild(tr,td);
  DOM.insertChild(getBody(),tr,beforeIndex);
  insert(w,td,beforeIndex,false);
}",0.6049237983587339
54467,"public boolean hasInstantiableSubtypes(){
  return isInstantiable() || instantiableSubtypes;
}","public boolean hasInstantiableSubtypes(){
  return isInstantiable() || instantiableSubtypes || isPendingInstantiable();
}",0.8744186046511628
54468,"/** 
 * Remove serializable types that were visited due to speculative paths but are not really needed for serialization. NOTE: This is currently much more limited than it should be. For example, a path sensitive prune could remove instantiable types also.
 */
private void pruneUnreachableTypes(){
  Set<JType> supersOfInstantiableTypes=new LinkedHashSet<JType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (tic.isInstantiable()) {
      JClassType type=tic.getType().getErasedType();
      JClassType sup=type;
      while (sup != null) {
        supersOfInstantiableTypes.add(sup.getErasedType());
        sup=sup.getErasedType().getSuperclass();
      }
    }
  }
  Set<JType> toKill=new LinkedHashSet<JType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (tic.isFieldSerializable() && !supersOfInstantiableTypes.contains(tic.getType().getErasedType())) {
      toKill.add(tic.getType());
    }
  }
  for (  JType type : toKill) {
    typeToTypeInfoComputed.remove(type);
  }
}","/** 
 * Remove serializable types that were visited due to speculative paths but are not really needed for serialization. NOTE: This is currently much more limited than it should be. For example, a path sensitive prune could remove instantiable types also.
 */
private void pruneUnreachableTypes(){
  Set<JType> supersOfInstantiableTypes=new LinkedHashSet<JType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (tic.isInstantiable() && tic.getType() instanceof JClassType) {
      JClassType type=(JClassType)tic.getType().getErasedType();
      JClassType sup=type;
      while (sup != null) {
        supersOfInstantiableTypes.add(sup.getErasedType());
        sup=sup.getErasedType().getSuperclass();
      }
    }
  }
  Set<JType> toKill=new LinkedHashSet<JType>();
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (tic.isFieldSerializable() && !supersOfInstantiableTypes.contains(tic.getType().getErasedType())) {
      toKill.add(tic.getType());
    }
  }
  for (  JType type : toKill) {
    typeToTypeInfoComputed.remove(type);
  }
}",0.9340196537201684
54469,"/** 
 * Consider any subtype of java.lang.Object which qualifies for serialization.
 * @param logger
 */
private void checkAllSubtypesOfObject(TreeLogger logger,TypePath parent,ProblemReport problems){
  if (alreadyCheckedObject) {
    return;
  }
  alreadyCheckedObject=true;
  TreeLogger localLogger=logger.branch(TreeLogger.WARN,""String_Node_Str"",null);
  JClassType[] allTypes=typeOracle.getJavaLangObject().getSubtypes();
  for (  JClassType cls : allTypes) {
    if (isDeclaredSerializable(cls)) {
      checkTypeInstantiable(localLogger,cls,TypePaths.createSubtypePath(parent,cls,typeOracle.getJavaLangObject()),problems);
    }
  }
}","/** 
 * Consider any subtype of java.lang.Object which qualifies for serialization.
 * @param logger
 */
private void checkAllSubtypesOfObject(TreeLogger logger,TypePath parent,ProblemReport problems){
  if (alreadyCheckedObject) {
    return;
  }
  alreadyCheckedObject=true;
  TreeLogger localLogger=logger.branch(TreeLogger.WARN,""String_Node_Str"",null);
  JClassType[] allTypes=typeOracle.getJavaLangObject().getSubtypes();
  for (  JClassType cls : allTypes) {
    if (isDeclaredSerializable(cls)) {
      computeTypeInstantiability(localLogger,cls,TypePaths.createSubtypePath(parent,cls,typeOracle.getJavaLangObject()),problems);
    }
  }
}",0.9867909867909868
54470,"/** 
 * Check the argument to a parameterized type to see if it will make the type it is applied to be serializable. As a side effect, populates  {@link #typeToTypeInfoComputed} in the same way as{@link #checkTypeInstantiable(TreeLogger,JType,boolean)}.
 * @param logger
 * @param baseType - The generic type the parameter is on
 * @param paramIndex - The index of the parameter in the generic type
 * @param typeArg - An upper bound on the actual argument being applied to thegeneric type
 * @return Whether the a parameterized type can be serializable if<code>baseType</code> is the base type and the <code>paramIndex</code>th type argument is a subtype of <code>typeArg</code>.
 */
private boolean checkTypeArgument(TreeLogger logger,JGenericType baseType,int paramIndex,JClassType typeArg,TypePath parent,ProblemReport problems){
  JWildcardType isWildcard=typeArg.isWildcard();
  if (isWildcard != null) {
    return checkTypeArgument(logger,baseType,paramIndex,isWildcard.getUpperBound(),parent,problems);
  }
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && otherFlowInfo.isTransitivelyAffectedBy(flowInfoForArrayParam)) {
          problems.add(baseType,""String_Node_Str"" + baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ typeArg.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ ""String_Node_Str"",Priority.DEFAULT);
          return false;
        }
      }
    }
  }
  TypePath path=TypePaths.createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case TypeParameterExposureComputer.EXPOSURE_DIRECT:
{
      TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
      return checkTypeInstantiable(branch,typeArg,path,problems) || mightNotBeExposed(baseType,paramIndex);
    }
case TypeParameterExposureComputer.EXPOSURE_NONE:
  logger.log(Type.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
return true;
default :
{
assert(exposure >= TypeParameterExposureComputer.EXPOSURE_MIN_BOUNDED_ARRAY);
problems.add(getArrayType(typeOracle,exposure,typeArg),""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ exposure+ ""String_Node_Str"",Priority.AUXILIARY);
return checkTypeInstantiable(logger,getArrayType(typeOracle,exposure,typeArg),path,problems) || mightNotBeExposed(baseType,paramIndex);
}
}
}","/** 
 * Check the argument to a parameterized type to see if it will make the type it is applied to be serializable. As a side effect, populates  {@link #typeToTypeInfoComputed} in the same way as{@link #checkTypeInstantiable(TreeLogger,JType,boolean)}.
 * @param logger
 * @param baseType - The generic type the parameter is on
 * @param paramIndex - The index of the parameter in the generic type
 * @param typeArg - An upper bound on the actual argument being applied to thegeneric type
 * @return Whether the a parameterized type can be serializable if<code>baseType</code> is the base type and the <code>paramIndex</code>th type argument is a subtype of <code>typeArg</code>.
 */
private boolean checkTypeArgument(TreeLogger logger,JGenericType baseType,int paramIndex,JClassType typeArg,TypePath parent,ProblemReport problems){
  JWildcardType isWildcard=typeArg.isWildcard();
  if (isWildcard != null) {
    return checkTypeArgument(logger,baseType,paramIndex,isWildcard.getUpperBound(),parent,problems);
  }
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && otherFlowInfo.isTransitivelyAffectedBy(flowInfoForArrayParam)) {
          problems.add(baseType,""String_Node_Str"" + baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ typeArg.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ ""String_Node_Str"",Priority.DEFAULT);
          return false;
        }
      }
    }
  }
  TypePath path=TypePaths.createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case TypeParameterExposureComputer.EXPOSURE_DIRECT:
{
      TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
      return computeTypeInstantiability(branch,typeArg,path,problems).hasInstantiableSubtypes() || mightNotBeExposed(baseType,paramIndex);
    }
case TypeParameterExposureComputer.EXPOSURE_NONE:
  logger.log(Type.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
return true;
default :
{
assert(exposure >= TypeParameterExposureComputer.EXPOSURE_MIN_BOUNDED_ARRAY);
problems.add(getArrayType(typeOracle,exposure,typeArg),""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ exposure+ ""String_Node_Str"",Priority.AUXILIARY);
return computeTypeInstantiability(logger,getArrayType(typeOracle,exposure,typeArg),path,problems).hasInstantiableSubtypes() || mightNotBeExposed(baseType,paramIndex);
}
}
}",0.977004152028106
54471,"public TypeInfoComputed(JClassType type,TypePath path){
  this.type=type;
  this.path=path;
  autoSerializable=SerializableTypeOracleBuilder.isAutoSerializable(type);
  manualSerializer=findCustomFieldSerializer(typeOracle,type);
  directlyImplementsMarker=directlyImplementsMarkerInterface(type);
  maybeEnhanced=hasJdoAnnotation(type) || hasJpaAnnotation(type);
}","public TypeInfoComputed(JType type,TypePath path){
  this.type=type;
  this.path=path;
  if (type instanceof JClassType) {
    JClassType typeClass=(JClassType)type;
    autoSerializable=SerializableTypeOracleBuilder.isAutoSerializable(typeClass);
    manualSerializer=findCustomFieldSerializer(typeOracle,typeClass);
    directlyImplementsMarker=directlyImplementsMarkerInterface(typeClass);
    maybeEnhanced=hasJdoAnnotation(typeClass) || hasJpaAnnotation(typeClass);
  }
 else {
    autoSerializable=false;
    manualSerializer=null;
    directlyImplementsMarker=false;
    maybeEnhanced=false;
  }
}",0.718266253869969
54472,"/** 
 * Returns <code>true</code> if the declared fields of this type are all instantiable. As a side-effect it fills in   {@link TypeInfoComputed} for allnecessary types.
 */
private boolean checkDeclaredFields(TreeLogger logger,TypeInfoComputed typeInfo,TypePath parent,ProblemReport problems){
  JClassType classOrInterface=typeInfo.getType();
  if (classOrInterface.isEnum() != null) {
    return true;
  }
  JClassType baseType=getBaseType(classOrInterface);
  boolean allSucceeded=true;
  JField[] fields=baseType.getFields();
  if (fields.length > 0) {
    TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classOrInterface.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
    for (    JField field : fields) {
      if (!shouldConsiderForSerialization(localLogger,suppressNonStaticFinalFieldWarnings,field)) {
        continue;
      }
      TreeLogger fieldLogger=localLogger.branch(TreeLogger.DEBUG,field.toString(),null);
      JType fieldType=field.getType();
      TypePath path=TypePaths.createFieldPath(parent,field);
      if (typeInfo.isManuallySerializable() && fieldType.getLeafType() == typeOracle.getJavaLangObject()) {
        checkAllSubtypesOfObject(fieldLogger.branch(TreeLogger.WARN,""String_Node_Str"",null),path,problems);
      }
 else {
        allSucceeded&=checkTypeInstantiable(fieldLogger,fieldType,path,problems);
      }
    }
  }
  boolean succeeded=allSucceeded || typeInfo.isManuallySerializable();
  if (succeeded) {
    typeInfo.setFieldSerializable();
  }
  return succeeded;
}","/** 
 * Returns <code>true</code> if the declared fields of this type are all instantiable. As a side-effect it fills in   {@link TypeInfoComputed} for allnecessary types.
 */
private boolean checkDeclaredFields(TreeLogger logger,TypeInfoComputed typeInfo,TypePath parent,ProblemReport problems){
  JClassType classOrInterface=(JClassType)typeInfo.getType();
  if (classOrInterface.isEnum() != null) {
    return true;
  }
  JClassType baseType=getBaseType(classOrInterface);
  boolean allSucceeded=true;
  JField[] fields=baseType.getFields();
  if (fields.length > 0) {
    TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classOrInterface.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
    for (    JField field : fields) {
      if (!shouldConsiderForSerialization(localLogger,suppressNonStaticFinalFieldWarnings,field)) {
        continue;
      }
      TreeLogger fieldLogger=localLogger.branch(TreeLogger.DEBUG,field.toString(),null);
      JType fieldType=field.getType();
      TypePath path=TypePaths.createFieldPath(parent,field);
      if (typeInfo.isManuallySerializable() && fieldType.getLeafType() == typeOracle.getJavaLangObject()) {
        checkAllSubtypesOfObject(fieldLogger.branch(TreeLogger.WARN,""String_Node_Str"",null),path,problems);
      }
 else {
        allSucceeded&=computeTypeInstantiability(fieldLogger,fieldType,path,problems).hasInstantiableSubtypes();
      }
    }
  }
  boolean succeeded=allSucceeded || typeInfo.isManuallySerializable();
  if (succeeded) {
    typeInfo.setFieldSerializable();
  }
  return succeeded;
}",0.9825783972125436
54473,"public JClassType getType(){
  return type;
}","public JType getType(){
  return type;
}",0.9411764705882352
54474,"private boolean checkArrayInstantiable(TreeLogger logger,JArrayType array,TypePath path,ProblemReport problems){
}","private TypeInfoComputed checkArrayInstantiable(TreeLogger logger,JArrayType array,TypePath path,ProblemReport problems){
}",0.9282700421940928
54475,"private TypeInfoComputed getTypeInfoComputed(JClassType type,TypePath path,boolean createIfNeeded){
  TypeInfoComputed tic=typeToTypeInfoComputed.get(type);
  if (tic == null && createIfNeeded) {
    tic=new TypeInfoComputed(type,path);
    typeToTypeInfoComputed.put(type,tic);
  }
  return tic;
}","private TypeInfoComputed getTypeInfoComputed(JType type,TypePath path,boolean createIfNeeded){
  TypeInfoComputed tic=typeToTypeInfoComputed.get(type);
  if (tic == null && createIfNeeded) {
    tic=new TypeInfoComputed(type,path);
    typeToTypeInfoComputed.put(type,tic);
  }
  return tic;
}",0.9915397631133672
54476,"/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=checkTypeInstantiable(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems);
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyEnhancedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    JClassType type=tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if ((enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName())) || tic.maybeEnhanced()) {
      possiblyEnhancedTypes.add(type);
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes,possiblyEnhancedTypes);
}","/** 
 * Builds a   {@link SerializableTypeOracle} for a given set of root types.
 * @param logger
 * @return a {@link SerializableTypeOracle} for the specified set of roottypes
 * @throws UnableToCompleteException if there was not at least oneinstantiable type assignable to each of the specified root types
 */
public SerializableTypeOracle build(TreeLogger logger) throws UnableToCompleteException {
  alreadyCheckedObject=false;
  boolean allSucceeded=true;
  for (  Entry<JClassType,TreeLogger> entry : rootTypes.entrySet()) {
    ProblemReport problems=new ProblemReport();
    problems.setContextType(entry.getKey());
    boolean entrySucceeded=computeTypeInstantiability(entry.getValue(),entry.getKey(),TypePaths.createRootPath(entry.getKey()),problems).hasInstantiableSubtypes();
    if (!entrySucceeded) {
      problems.report(logger,TreeLogger.ERROR,TreeLogger.INFO);
    }
 else {
      if (problems.hasFatalProblems()) {
        entrySucceeded=false;
        problems.reportFatalProblems(logger,TreeLogger.ERROR);
      }
      problems.report(logger,TreeLogger.DEBUG,TreeLogger.DEBUG);
    }
    allSucceeded&=entrySucceeded;
  }
  if (!allSucceeded) {
    throw new UnableToCompleteException();
  }
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    assert(!tic.isPendingInstantiable());
  }
  pruneUnreachableTypes();
  logReachableTypes(logger);
  Set<JClassType> possiblyEnhancedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> possiblyInstantiatedTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  Set<JClassType> fieldSerializableTypes=new TreeSet<JClassType>(JTYPE_COMPARATOR);
  for (  TypeInfoComputed tic : typeToTypeInfoComputed.values()) {
    if (!(tic.getType() instanceof JClassType)) {
      continue;
    }
    JClassType type=(JClassType)tic.getType();
    type=type.getErasedType();
    if (tic.isInstantiable()) {
      assert(!type.isAbstract() || type.isEnum() != null);
      possiblyInstantiatedTypes.add(type);
    }
    if (tic.isFieldSerializable()) {
      assert(type.isInterface() == null);
      fieldSerializableTypes.add(type);
    }
    if ((enhancedClasses != null && enhancedClasses.contains(type.getQualifiedSourceName())) || tic.maybeEnhanced()) {
      possiblyEnhancedTypes.add(type);
    }
  }
  logSerializableTypes(logger,fieldSerializableTypes);
  return new SerializableTypeOracleImpl(fieldSerializableTypes,possiblyInstantiatedTypes,possiblyEnhancedTypes);
}",0.9389201584323535
54477,"public DependencyRecorder(OutputStream out) throws IOException {
  try {
    this.writer=new OutputStreamWriter(new GZIPOutputStream(out),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new InternalCompilerException(""String_Node_Str"",e);
  }
}","public DependencyRecorder(OutputStream out){
  this.finalOutput=out;
}",0.3848396501457726
54478,"public void open(){
  printPre();
}","public void open(){
  try {
    this.writer=new OutputStreamWriter(new GZIPOutputStream(finalOutput),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new InternalCompilerException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new NestedIOException(e);
  }
  printPre();
}",0.1538461538461538
54479,"/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a{@link #precompile(TreeLogger,WebModeCompilerFrontEnd,String[],JJSOptions,boolean)}
 * @param rebindAnswers the set of rebind answers to resolve all outstandingrebind decisions
 * @param propertyOracles All property oracles corresponding to thispermutation.
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Map<String,String> rebindAnswers,PropertyOracle[] propertyOracles,int permutationId) throws UnableToCompleteException {
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    JJSOptions options=unifiedAst.getOptions();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,rebindAnswers);
    if (options.isDraftCompile()) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    LongCastNormalizer.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeAfterOptimizations();
    JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable);
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      boolean didChange;
      do {
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
        didChange=false;
        didChange=JsStaticEval.exec(jsProgram) || didChange;
        didChange=JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
    if (jprogram.getDeclaredTypes().contains(jprogram.getFromTypeMap(""String_Node_Str""))) {
      JsStackEmulator.exec(jsProgram,propertyOracles);
    }
    SoycArtifact dependencies=null;
    if (options.isAggressivelyOptimize() && options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      CodeSplitter.exec(logger,jprogram,jsProgram,map,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      if (baos.size() > 0) {
        dependencies=new SoycArtifact(""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
JsIEBlockSizeVisitor.exec(jsProgram);
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=options.isSoycExtra() ? new ArrayList<Map<Range,SourceInfo>>() : null;
generateJavaScriptCode(options,jsProgram,map,js,ranges,sizeBreakdowns,sourceInfoMaps);
PermutationResult toReturn=new PermutationResultImpl(js,makeSymbolMap(symbolTable),ranges,permutationId);
toReturn.getArtifacts().add(makeSoycArtifact(logger,permutationId,jprogram,js,sizeBreakdowns,sourceInfoMaps,dependencies,map,obfuscateMap));
System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
return toReturn;
}
 catch (Throwable e) {
throw logAndTranslateException(logger,e);
}
}","/** 
 * Compiles a particular permutation, based on a precompiled unified AST.
 * @param logger the logger to use
 * @param unifiedAst the result of a{@link #precompile(TreeLogger,WebModeCompilerFrontEnd,String[],JJSOptions,boolean)}
 * @param rebindAnswers the set of rebind answers to resolve all outstandingrebind decisions
 * @param propertyOracles All property oracles corresponding to thispermutation.
 * @return the output JavaScript
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static PermutationResult compilePermutation(TreeLogger logger,UnifiedAst unifiedAst,Map<String,String> rebindAnswers,PropertyOracle[] propertyOracles,int permutationId) throws UnableToCompleteException {
  long permStart=System.currentTimeMillis();
  try {
    if (JProgram.isTracingEnabled()) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
    AST ast=unifiedAst.getFreshAst();
    JProgram jprogram=ast.getJProgram();
    JsProgram jsProgram=ast.getJsProgram();
    JJSOptions options=unifiedAst.getOptions();
    Map<StandardSymbolData,JsName> symbolTable=new TreeMap<StandardSymbolData,JsName>(new SymbolData.ClassIdentComparator());
    ResolveRebinds.exec(jprogram,rebindAnswers);
    if (options.isDraftCompile()) {
      draftOptimize(jprogram);
    }
 else {
      optimize(options,jprogram);
    }
    LongCastNormalizer.exec(jprogram);
    JsoDevirtualizer.exec(jprogram);
    CatchBlockNormalizer.exec(jprogram);
    PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
    LongEmulationNormalizer.exec(jprogram);
    CastNormalizer.exec(jprogram,options.isCastCheckingDisabled());
    ArrayNormalizer.exec(jprogram);
    EqualityNormalizer.exec(jprogram);
    Pruner.exec(jprogram,false);
    jprogram.typeOracle.recomputeAfterOptimizations();
    JavaToJavaScriptMap map=GenerateJavaScriptAST.exec(jprogram,jsProgram,options.getOutput(),symbolTable);
    JsNormalizer.exec(jsProgram);
    JsSymbolResolver.exec(jsProgram);
    EvalFunctionsAtTopScope.exec(jsProgram);
    if (options.isAggressivelyOptimize()) {
      boolean didChange;
      do {
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
        didChange=false;
        didChange=JsStaticEval.exec(jsProgram) || didChange;
        didChange=JsInliner.exec(jsProgram) || didChange;
        didChange=JsUnusedFunctionRemover.exec(jsProgram) || didChange;
      }
 while (didChange);
    }
    if (jprogram.getDeclaredTypes().contains(jprogram.getFromTypeMap(""String_Node_Str""))) {
      JsStackEmulator.exec(jsProgram,propertyOracles);
    }
    SoycArtifact dependencies=null;
    if (options.isAggressivelyOptimize() && options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      CodeSplitter.exec(logger,jprogram,jsProgram,map,chooseDependencyRecorder(options.isSoycEnabled(),baos));
      if (baos.size() == 0 && options.isSoycEnabled()) {
        recordNonSplitDependencies(jprogram,baos);
      }
      if (baos.size() > 0) {
        dependencies=new SoycArtifact(""String_Node_Str"" + permutationId + ""String_Node_Str"",baos.toByteArray());
      }
    }
    Map<JsName,String> obfuscateMap=Maps.create();
switch (options.getOutput()) {
case OBFUSCATED:
      obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
    JsObfuscateNamer.exec(jsProgram);
  break;
case PRETTY:
JsPrettyNamer.exec(jsProgram);
break;
case DETAILED:
obfuscateMap=JsStringInterner.exec(jprogram,jsProgram);
JsVerboseNamer.exec(jsProgram);
break;
default :
throw new InternalCompilerException(""String_Node_Str"");
}
JsIEBlockSizeVisitor.exec(jsProgram);
JsBreakUpLargeVarStatements.exec(jsProgram,propertyOracles);
String[] js=new String[jsProgram.getFragmentCount()];
StatementRanges[] ranges=new StatementRanges[js.length];
SizeBreakdown[] sizeBreakdowns=options.isSoycEnabled() ? new SizeBreakdown[js.length] : null;
List<Map<Range,SourceInfo>> sourceInfoMaps=options.isSoycExtra() ? new ArrayList<Map<Range,SourceInfo>>() : null;
generateJavaScriptCode(options,jsProgram,map,js,ranges,sizeBreakdowns,sourceInfoMaps);
PermutationResult toReturn=new PermutationResultImpl(js,makeSymbolMap(symbolTable),ranges,permutationId);
toReturn.getArtifacts().add(makeSoycArtifact(logger,permutationId,jprogram,js,sizeBreakdowns,sourceInfoMaps,dependencies,map,obfuscateMap));
System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - permStart) + ""String_Node_Str"");
return toReturn;
}
 catch (Throwable e) {
throw logAndTranslateException(logger,e);
}
}",0.9873307121013544
54480,"public WebModePayloadSink(ClientOracle clientOracle,OutputStream out){
  this.clientOracle=clientOracle;
  this.out=out;
  backRefIdent=clientOracle.createUnusedIdent(""String_Node_Str"");
}","public WebModePayloadSink(ClientOracle clientOracle,OutputStream out){
  this.clientOracle=clientOracle;
  this.out=out;
}",0.7870967741935484
54481,"byte[] makeBackRef(ValueCommand x){
  byte[] toReturn=valueBackRefs.get(x);
  if (toReturn == null) {
    if (freeBackRefs.isEmpty()) {
      int idx=valueBackRefs.size();
      toReturn=getBytes(backRefIdent + ""String_Node_Str"" + Integer.toString(idx,Character.MAX_RADIX));
    }
 else {
      toReturn=freeBackRefs.pop();
    }
    valueBackRefs.put(x,toReturn);
  }
  return toReturn;
}","byte[] makeBackRef(ValueCommand x){
  byte[] toReturn=valueBackRefs.get(x);
  if (toReturn == null) {
    if (freeBackRefs.isEmpty()) {
      int idx=valueBackRefs.size();
      toReturn=getBytes(BACKREF_IDENT + ""String_Node_Str"" + Integer.toString(idx,Character.MAX_RADIX));
    }
 else {
      toReturn=freeBackRefs.pop();
    }
    valueBackRefs.put(x,toReturn);
  }
  return toReturn;
}",0.9704749679075738
54482,"/** 
 * Run the specified callback once the necessary code for it has been loaded.
 */
public static void runAsync(RunAsyncCallback callback){
  UncaughtExceptionHandler handler=sUncaughtExceptionHandler;
  if (handler == null) {
    callback.onSuccess();
  }
 else {
    try {
      callback.onSuccess();
    }
 catch (    Throwable e) {
      handler.onUncaughtException(e);
    }
  }
}","/** 
 * Run the specified callback once the necessary code for it has been loaded.
 */
public static void runAsync(RunAsyncCallback callback){
  if (isScript()) {
    AsyncFragmentLoader.BROWSER_LOADER.logEventProgress(""String_Node_Str"",""String_Node_Str"");
    AsyncFragmentLoader.BROWSER_LOADER.logEventProgress(""String_Node_Str"",""String_Node_Str"");
  }
  UncaughtExceptionHandler handler=sUncaughtExceptionHandler;
  if (handler == null) {
    callback.onSuccess();
  }
 else {
    try {
      callback.onSuccess();
    }
 catch (    Throwable e) {
      handler.onUncaughtException(e);
    }
  }
}",0.7854251012145749
54483,"private static String downloadGroup(int splitPoint){
  return ""String_Node_Str"" + splitPoint;
}","private String downloadGroup(int fragment){
  return (fragment == leftoversFragment()) ? LwmLabels.LEFTOVERS_DOWNLOAD : LwmLabels.downloadGroupForExclusive(fragment);
}",0.4182509505703422
54484,"private void logFragmentLoaded(int fragment){
  String logGroup=(fragment == leftoversFragment()) ? LwmLabels.LEFTOVERS_DOWNLOAD : LwmLabels.downloadGroup(fragment);
  logEventProgress(logGroup,LwmLabels.END,fragment,null);
}","private void logFragmentLoaded(int fragment){
  String logGroup=downloadGroup(fragment);
  logEventProgress(logGroup,LwmLabels.END,fragment,null);
}",0.7935656836461126
54485,"/** 
 * Start downloading the next fragment in the initial sequence, if there are any left.
 */
private void startLoadingNextInitial(){
  if (remainingInitialFragments == null) {
    remainingInitialFragments=new BoundedIntQueue(initialLoadSequence.length + 1);
    for (    int sp : initialLoadSequence) {
      remainingInitialFragments.add(sp);
    }
    remainingInitialFragments.add(leftoversFragment());
  }
  if (initialFragmentErrorHandlers.isEmpty() && waitingForInitialFragmentsErrorHandlers.isEmpty() && remainingInitialFragments.size() > 1) {
    initialFragmentsLoading=false;
    return;
  }
  if (remainingInitialFragments.size() > 0) {
    initialFragmentsLoading=true;
    int nextSplitPoint=remainingInitialFragments.peek();
    logEventProgress(LwmLabels.downloadGroup(nextSplitPoint),LwmLabels.BEGIN,nextSplitPoint,null);
    startLoadingFragment(nextSplitPoint,new InitialFragmentDownloadFailed());
    return;
  }
  initialFragmentsLoading=false;
  assert(haveInitialFragmentsLoaded());
  assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
  while (waitingForInitialFragments.size() > 0) {
    startLoadingFragment(waitingForInitialFragments.remove(),waitingForInitialFragmentsErrorHandlers.remove());
  }
}","/** 
 * Start downloading the next fragment in the initial sequence, if there are any left.
 */
private void startLoadingNextInitial(){
  if (remainingInitialFragments == null) {
    remainingInitialFragments=new BoundedIntQueue(initialLoadSequence.length + 1);
    for (    int sp : initialLoadSequence) {
      remainingInitialFragments.add(sp);
    }
    remainingInitialFragments.add(leftoversFragment());
  }
  if (initialFragmentErrorHandlers.isEmpty() && waitingForInitialFragmentsErrorHandlers.isEmpty() && remainingInitialFragments.size() > 1) {
    initialFragmentsLoading=false;
    return;
  }
  if (remainingInitialFragments.size() > 0) {
    initialFragmentsLoading=true;
    int nextSplitPoint=remainingInitialFragments.peek();
    logDownloadStart(nextSplitPoint);
    startLoadingFragment(nextSplitPoint,new InitialFragmentDownloadFailed());
    return;
  }
  initialFragmentsLoading=false;
  assert(haveInitialFragmentsLoaded());
  assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
  while (waitingForInitialFragments.size() > 0) {
    int nextSplitPoint=waitingForInitialFragments.remove();
    LoadErrorHandler handler=waitingForInitialFragmentsErrorHandlers.remove();
    logDownloadStart(nextSplitPoint);
    startLoadingFragment(nextSplitPoint,handler);
  }
}",0.6271186440677966
54486,"/** 
 * Loads the specified split point.
 * @param splitPoint the split point whose code needs to be loaded
 */
public void inject(int splitPoint,LoadErrorHandler loadErrorHandler){
  if (haveInitialFragmentsLoaded()) {
    logEventProgress(LwmLabels.downloadGroup(splitPoint),LwmLabels.BEGIN,splitPoint,null);
    startLoadingFragment(splitPoint,loadErrorHandler);
    return;
  }
  if (isInitial(splitPoint)) {
    initialFragmentErrorHandlers.put(splitPoint,loadErrorHandler);
  }
 else {
    assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
    waitingForInitialFragments.add(splitPoint);
    waitingForInitialFragmentsErrorHandlers.add(loadErrorHandler);
  }
  if (!initialFragmentsLoading) {
    startLoadingNextInitial();
  }
}","/** 
 * Loads the specified split point.
 * @param splitPoint the split point whose code needs to be loaded
 */
public void inject(int splitPoint,LoadErrorHandler loadErrorHandler){
  if (haveInitialFragmentsLoaded()) {
    logDownloadStart(splitPoint);
    startLoadingFragment(splitPoint,loadErrorHandler);
    return;
  }
  if (isInitial(splitPoint)) {
    initialFragmentErrorHandlers.put(splitPoint,loadErrorHandler);
  }
 else {
    assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
    waitingForInitialFragments.add(splitPoint);
    waitingForInitialFragmentsErrorHandlers.add(loadErrorHandler);
  }
  if (!initialFragmentsLoading) {
    startLoadingNextInitial();
  }
}",0.932621747831888
54487,"private JsExpression mapUnaryVariant(Node unOp) throws JsParserException {
switch (unOp.getIntDatum()) {
case TokenStream.SUB:
    return mapPrefixOperation(JsUnaryOperator.NEG,unOp);
case TokenStream.NOT:
  return mapPrefixOperation(JsUnaryOperator.NOT,unOp);
case TokenStream.BITNOT:
return mapPrefixOperation(JsUnaryOperator.BIT_NOT,unOp);
case TokenStream.TYPEOF:
return mapPrefixOperation(JsUnaryOperator.TYPEOF,unOp);
case TokenStream.ADD:
return mapExpression(unOp.getFirstChild());
case TokenStream.VOID:
return mapPrefixOperation(JsUnaryOperator.VOID,unOp);
default :
throw new JsParserException(""String_Node_Str"" + unOp.getIntDatum());
}
}","private JsExpression mapUnaryVariant(Node unOp) throws JsParserException {
switch (unOp.getIntDatum()) {
case TokenStream.SUB:
    return mapPrefixOperation(JsUnaryOperator.NEG,unOp);
case TokenStream.NOT:
  return mapPrefixOperation(JsUnaryOperator.NOT,unOp);
case TokenStream.BITNOT:
return mapPrefixOperation(JsUnaryOperator.BIT_NOT,unOp);
case TokenStream.TYPEOF:
return mapPrefixOperation(JsUnaryOperator.TYPEOF,unOp);
case TokenStream.ADD:
if (unOp.getFirstChild().getType() != TokenStream.NUMBER) {
return mapPrefixOperation(JsUnaryOperator.POS,unOp);
}
 else {
return mapExpression(unOp.getFirstChild());
}
case TokenStream.VOID:
return mapPrefixOperation(JsUnaryOperator.VOID,unOp);
default :
throw new JsParserException(""String_Node_Str"" + unOp.getIntDatum());
}
}",0.8840477863668307
54488,"private void doTest(String js) throws Exception {
  List<JsStatement> expected=JsParser.parse(SourceOrigin.UNKNOWN,new JsProgram().getScope(),new StringReader(js));
  List<JsStatement> actual=parse(expected,true);
  ComparingVisitor.exec(expected,actual);
  actual=parse(expected,false);
  ComparingVisitor.exec(expected,actual);
}","private void doTest(String js,String expectedJs) throws Exception {
  List<JsStatement> actual=JsParser.parse(SourceOrigin.UNKNOWN,new JsProgram().getScope(),new StringReader(js));
  List<JsStatement> expected=JsParser.parse(SourceOrigin.UNKNOWN,new JsProgram().getScope(),new StringReader(expectedJs));
  ComparingVisitor.exec(expected,actual);
}",0.6607669616519174
54489,"public void testUnaryOperations() throws Exception {
  doTest(""String_Node_Str"");
}","public void testUnaryOperations() throws Exception {
  doTest(""String_Node_Str"");
  doTest(""String_Node_Str"",""String_Node_Str"");
  doTest(""String_Node_Str"",""String_Node_Str"");
}",0.6384615384615384
54490,"private JsExpression mapUnaryVariant(Node unOp) throws JsParserException {
switch (unOp.getIntDatum()) {
case TokenStream.SUB:
    return mapPrefixOperation(JsUnaryOperator.NEG,unOp);
case TokenStream.NOT:
  return mapPrefixOperation(JsUnaryOperator.NOT,unOp);
case TokenStream.BITNOT:
return mapPrefixOperation(JsUnaryOperator.BIT_NOT,unOp);
case TokenStream.TYPEOF:
return mapPrefixOperation(JsUnaryOperator.TYPEOF,unOp);
case TokenStream.ADD:
return mapExpression(unOp.getFirstChild());
case TokenStream.VOID:
return mapPrefixOperation(JsUnaryOperator.VOID,unOp);
default :
throw new JsParserException(""String_Node_Str"" + unOp.getIntDatum());
}
}","private JsExpression mapUnaryVariant(Node unOp) throws JsParserException {
switch (unOp.getIntDatum()) {
case TokenStream.SUB:
    return mapPrefixOperation(JsUnaryOperator.NEG,unOp);
case TokenStream.NOT:
  return mapPrefixOperation(JsUnaryOperator.NOT,unOp);
case TokenStream.BITNOT:
return mapPrefixOperation(JsUnaryOperator.BIT_NOT,unOp);
case TokenStream.TYPEOF:
return mapPrefixOperation(JsUnaryOperator.TYPEOF,unOp);
case TokenStream.ADD:
if (unOp.getFirstChild().getType() != TokenStream.NUMBER) {
return mapPrefixOperation(JsUnaryOperator.POS,unOp);
}
 else {
return mapExpression(unOp.getFirstChild());
}
case TokenStream.VOID:
return mapPrefixOperation(JsUnaryOperator.VOID,unOp);
default :
throw new JsParserException(""String_Node_Str"" + unOp.getIntDatum());
}
}",0.8840477863668307
54491,"/** 
 * Decide whether, if <code>op</code> is printed followed by <code>arg</code>, there needs to be a space between the operator and expression.
 * @return <code>true</code> if a space needs to be printed
 */
private boolean _spaceCalc(JsOperator op,JsExpression arg){
  if (op.isKeyword()) {
    return true;
  }
  if (arg instanceof JsBinaryOperation) {
    JsBinaryOperation binary=(JsBinaryOperation)arg;
    if (binary.getOperator().getPrecedence() > op.getPrecedence()) {
      return _spaceCalc(op,binary.getArg1());
    }
    return false;
  }
  if (arg instanceof JsPrefixOperation) {
    JsOperator op2=((JsPrefixOperation)arg).getOperator();
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (op2 == JsUnaryOperator.DEC || op2 == JsUnaryOperator.NEG) || (op == JsBinaryOperator.ADD && op2 == JsUnaryOperator.INC);
  }
  if (arg instanceof JsNumberLiteral) {
    JsNumberLiteral literal=(JsNumberLiteral)arg;
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (literal.getValue() < 0);
  }
  return false;
}","/** 
 * Decide whether, if <code>op</code> is printed followed by <code>arg</code>, there needs to be a space between the operator and expression.
 * @return <code>true</code> if a space needs to be printed
 */
private boolean _spaceCalc(JsOperator op,JsExpression arg){
  if (op.isKeyword()) {
    return true;
  }
  if (arg instanceof JsBinaryOperation) {
    JsBinaryOperation binary=(JsBinaryOperation)arg;
    if (binary.getOperator().getPrecedence() > op.getPrecedence()) {
      return _spaceCalc(op,binary.getArg1());
    }
    return false;
  }
  if (arg instanceof JsPrefixOperation) {
    JsOperator op2=((JsPrefixOperation)arg).getOperator();
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (op2 == JsUnaryOperator.DEC || op2 == JsUnaryOperator.NEG) || (op == JsBinaryOperator.ADD || op == JsUnaryOperator.POS) && (op2 == JsUnaryOperator.INC || op2 == JsUnaryOperator.POS);
  }
  if (arg instanceof JsNumberLiteral) {
    JsNumberLiteral literal=(JsNumberLiteral)arg;
    return (op == JsBinaryOperator.SUB || op == JsUnaryOperator.NEG) && (literal.getValue() < 0);
  }
  return false;
}",0.9720823798627002
54492,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}",0.9230769230769232
54493,"public double getUnitSizeInPixels(Element parent,Unit unit,boolean vertical){
  if (unit == null) {
    return 1;
  }
switch (unit) {
default :
case PX:
    return 1;
case PCT:
  return (vertical ? parent.getClientHeight() : parent.getClientWidth()) / 100.0;
case EM:
return relativeRuler.getOffsetWidth();
case EX:
return relativeRuler.getOffsetHeight();
case CM:
return fixedRuler.getOffsetWidth();
case MM:
return fixedRuler.getOffsetWidth() / 10.0;
case IN:
return fixedRuler.getOffsetWidth() / 2.54;
case PT:
return fixedRuler.getOffsetWidth() / 28.4;
case PC:
return fixedRuler.getOffsetWidth() / 2.36;
}
}","public double getUnitSizeInPixels(Element parent,Unit unit,boolean vertical){
  if (unit == null) {
    return 1;
  }
switch (unit) {
case PCT:
    return (vertical ? parent.getClientHeight() : parent.getClientWidth()) / 100.0;
case EM:
  return relativeRuler.getOffsetWidth();
case EX:
return relativeRuler.getOffsetHeight();
case CM:
return fixedRuler.getOffsetWidth();
case MM:
return fixedRuler.getOffsetWidth() / 10.0;
case IN:
return fixedRuler.getOffsetWidth() / 2.54;
case PT:
return fixedRuler.getOffsetWidth() / 28.4;
case PC:
return fixedRuler.getOffsetWidth() / 2.36;
default :
case PX:
return 1;
}
}",0.946078431372549
54494,"private static String downloadGroup(int splitPoint){
  return ""String_Node_Str"" + splitPoint;
}","private String downloadGroup(int fragment){
  return (fragment == leftoversFragment()) ? LwmLabels.LEFTOVERS_DOWNLOAD : LwmLabels.downloadGroupForExclusive(fragment);
}",0.4182509505703422
54495,"private void logFragmentLoaded(int fragment){
  String logGroup=(fragment == leftoversFragment()) ? LwmLabels.LEFTOVERS_DOWNLOAD : LwmLabels.downloadGroup(fragment);
  logEventProgress(logGroup,LwmLabels.END,fragment,null);
}","private void logFragmentLoaded(int fragment){
  String logGroup=downloadGroup(fragment);
  logEventProgress(logGroup,LwmLabels.END,fragment,null);
}",0.7935656836461126
54496,"/** 
 * Start downloading the next fragment in the initial sequence, if there are any left.
 */
private void startLoadingNextInitial(){
  if (remainingInitialFragments == null) {
    remainingInitialFragments=new BoundedIntQueue(initialLoadSequence.length + 1);
    for (    int sp : initialLoadSequence) {
      remainingInitialFragments.add(sp);
    }
    remainingInitialFragments.add(leftoversFragment());
  }
  if (initialFragmentErrorHandlers.isEmpty() && waitingForInitialFragmentsErrorHandlers.isEmpty() && remainingInitialFragments.size() > 1) {
    initialFragmentsLoading=false;
    return;
  }
  if (remainingInitialFragments.size() > 0) {
    initialFragmentsLoading=true;
    int nextSplitPoint=remainingInitialFragments.peek();
    logEventProgress(LwmLabels.downloadGroup(nextSplitPoint),LwmLabels.BEGIN,nextSplitPoint,null);
    startLoadingFragment(nextSplitPoint,new InitialFragmentDownloadFailed());
    return;
  }
  initialFragmentsLoading=false;
  assert(haveInitialFragmentsLoaded());
  assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
  while (waitingForInitialFragments.size() > 0) {
    startLoadingFragment(waitingForInitialFragments.remove(),waitingForInitialFragmentsErrorHandlers.remove());
  }
}","/** 
 * Start downloading the next fragment in the initial sequence, if there are any left.
 */
private void startLoadingNextInitial(){
  if (remainingInitialFragments == null) {
    remainingInitialFragments=new BoundedIntQueue(initialLoadSequence.length + 1);
    for (    int sp : initialLoadSequence) {
      remainingInitialFragments.add(sp);
    }
    remainingInitialFragments.add(leftoversFragment());
  }
  if (initialFragmentErrorHandlers.isEmpty() && waitingForInitialFragmentsErrorHandlers.isEmpty() && remainingInitialFragments.size() > 1) {
    initialFragmentsLoading=false;
    return;
  }
  if (remainingInitialFragments.size() > 0) {
    initialFragmentsLoading=true;
    int nextSplitPoint=remainingInitialFragments.peek();
    logDownloadStart(nextSplitPoint);
    startLoadingFragment(nextSplitPoint,new InitialFragmentDownloadFailed());
    return;
  }
  initialFragmentsLoading=false;
  assert(haveInitialFragmentsLoaded());
  assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
  while (waitingForInitialFragments.size() > 0) {
    int nextSplitPoint=waitingForInitialFragments.remove();
    LoadErrorHandler handler=waitingForInitialFragmentsErrorHandlers.remove();
    logDownloadStart(nextSplitPoint);
    startLoadingFragment(nextSplitPoint,handler);
  }
}",0.6271186440677966
54497,"/** 
 * Loads the specified split point.
 * @param splitPoint the split point whose code needs to be loaded
 */
public void inject(int splitPoint,LoadErrorHandler loadErrorHandler){
  if (haveInitialFragmentsLoaded()) {
    logEventProgress(LwmLabels.downloadGroup(splitPoint),LwmLabels.BEGIN,splitPoint,null);
    startLoadingFragment(splitPoint,loadErrorHandler);
    return;
  }
  if (isInitial(splitPoint)) {
    initialFragmentErrorHandlers.put(splitPoint,loadErrorHandler);
  }
 else {
    assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
    waitingForInitialFragments.add(splitPoint);
    waitingForInitialFragmentsErrorHandlers.add(loadErrorHandler);
  }
  if (!initialFragmentsLoading) {
    startLoadingNextInitial();
  }
}","/** 
 * Loads the specified split point.
 * @param splitPoint the split point whose code needs to be loaded
 */
public void inject(int splitPoint,LoadErrorHandler loadErrorHandler){
  if (haveInitialFragmentsLoaded()) {
    logDownloadStart(splitPoint);
    startLoadingFragment(splitPoint,loadErrorHandler);
    return;
  }
  if (isInitial(splitPoint)) {
    initialFragmentErrorHandlers.put(splitPoint,loadErrorHandler);
  }
 else {
    assert(waitingForInitialFragments.size() == waitingForInitialFragmentsErrorHandlers.size());
    waitingForInitialFragments.add(splitPoint);
    waitingForInitialFragmentsErrorHandlers.add(loadErrorHandler);
  }
  if (!initialFragmentsLoading) {
    startLoadingNextInitial();
  }
}",0.932621747831888
54498,"/** 
 * This test catches a case in an earlier version of AsyncFragmentLoader where AsyncFragmentLoader.waitingForInitialFragments could exhaust its available space.
 */
public void testOverflowInWaitingForInitialFragments(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,NULL_LOGGER);
  for (int i=0; i < 10; i++) {
    MockErrorHandler error=new MockErrorHandler();
    loader.inject(4,error);
    reqs.assertFragmentsRequested(1);
    loadFailed(reqs,1);
    assertTrue(error.getWasCalled());
  }
}","/** 
 * This test catches a case in an earlier version of AsyncFragmentLoader where AsyncFragmentLoader.waitingForInitialFragments could exhaust its available space.
 */
public void testOverflowInWaitingForInitialFragments(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,progress);
  for (int i=0; i < 10; i++) {
    MockErrorHandler error=new MockErrorHandler();
    loader.inject(4,error);
    reqs.assertFragmentsRequested(1);
    progress.assertEvent(""String_Node_Str"",BEGIN,1);
    loadFailed(reqs,1);
    assertTrue(error.getWasCalled());
    progress.assertNoEvents();
  }
}",0.8826568265682657
54499,"/** 
 * Check the behavior when there are download failures.
 */
public void testDownloadFailures(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,NULL_LOGGER);
  MockErrorHandler error1try1=new MockErrorHandler();
  loader.inject(1,error1try1);
  reqs.assertFragmentsRequested(1);
  loadFailed(reqs,1);
  assertTrue(error1try1.getWasCalled());
  MockErrorHandler error1try2=new MockErrorHandler();
  loader.inject(1,error1try2);
  reqs.assertFragmentsRequested(1);
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested();
  assertFalse(error1try2.getWasCalled());
  MockErrorHandler error3try1=new MockErrorHandler();
  loader.inject(3,error3try1);
  reqs.assertFragmentsRequested(2);
  loadFailed(reqs,2);
  assertTrue(error3try1.wasCalled);
  MockErrorHandler error3try2=new MockErrorHandler();
  MockErrorHandler error5try1=new MockErrorHandler();
  loader.inject(3,error3try2);
  loader.inject(5,error5try1);
  reqs.assertFragmentsRequested(2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested(3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  loadFailed(reqs,numEntries);
  assertFalse(error3try2.getWasCalled());
  assertTrue(error5try1.getWasCalled());
  reqs.errorHandlers.get(numEntries);
  MockErrorHandler error5try2=new MockErrorHandler();
  loader.inject(5,error5try2);
  reqs.assertFragmentsRequested(numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  assertFalse(error5try2.getWasCalled());
}","/** 
 * Check the behavior when there are download failures.
 */
public void testDownloadFailures(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,progress);
  MockErrorHandler error1try1=new MockErrorHandler();
  loader.inject(1,error1try1);
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loadFailed(reqs,1);
  assertTrue(error1try1.getWasCalled());
  MockErrorHandler error1try2=new MockErrorHandler();
  loader.inject(1,error1try2);
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested();
  assertFalse(error1try2.getWasCalled());
  progress.assertEvent(""String_Node_Str"",END,1);
  MockErrorHandler error3try1=new MockErrorHandler();
  loader.inject(3,error3try1);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loadFailed(reqs,2);
  assertTrue(error3try1.wasCalled);
  MockErrorHandler error3try2=new MockErrorHandler();
  MockErrorHandler error5try1=new MockErrorHandler();
  loader.inject(3,error3try2);
  loader.inject(5,error5try1);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested(3);
  progress.assertEvent(""String_Node_Str"",END,2);
  progress.assertEvent(""String_Node_Str"",BEGIN,3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(""String_Node_Str"",END,3);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,BEGIN,numEntries);
  loadFailed(reqs,numEntries);
  assertFalse(error3try2.getWasCalled());
  assertTrue(error5try1.getWasCalled());
  reqs.errorHandlers.get(numEntries);
  MockErrorHandler error5try2=new MockErrorHandler();
  loader.inject(5,error5try2);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,BEGIN,numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(5);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,END,numEntries);
  progress.assertEvent(""String_Node_Str"",BEGIN,5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  assertFalse(error5try2.getWasCalled());
  progress.assertEvent(""String_Node_Str"",END,5);
  progress.assertNoEvents();
}",0.8088413893611853
54500,"/** 
 * A thorough exercise of loading with an initial load sequence specified.
 */
public void testWithInitialLoadSequence(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,NULL_LOGGER);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(1);
  loader.inject(3,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested();
  loader.inject(5,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested();
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested(2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested(3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  loader.inject(4,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(4);
  loader.fragmentHasLoaded(4);
  reqs.assertFragmentsRequested();
}","/** 
 * A thorough exercise of loading with an initial load sequence specified.
 */
public void testWithInitialLoadSequence(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,progress);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loader.inject(3,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested();
  progress.assertNoEvents();
  loader.inject(5,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested();
  progress.assertNoEvents();
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",END,1);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested(3);
  progress.assertEvent(""String_Node_Str"",END,2);
  progress.assertEvent(""String_Node_Str"",BEGIN,3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(""String_Node_Str"",END,3);
  progress.assertEvent(""String_Node_Str"",BEGIN,numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(5);
  progress.assertEvent(""String_Node_Str"",END,numEntries);
  progress.assertEvent(""String_Node_Str"",BEGIN,5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,5);
  progress.assertNoEvents();
  loader.inject(4,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(4);
  progress.assertEvent(""String_Node_Str"",BEGIN,4);
  loader.fragmentHasLoaded(4);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,4);
  progress.assertNoEvents();
}",0.7119971520113919
54501,"public void logEventProgress(String eventGroup,String type,Integer fragment,Integer size){
}","public void logEventProgress(String eventGroup,String type,Integer fragment,Integer size){
  events.add(new MockProgressEvent(eventGroup,type,fragment));
}",0.7449392712550608
54502,"public void testBasics(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=5;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{},reqs,NULL_LOGGER);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(1);
  loader.fragmentHasLoaded(1);
  loader.inject(2,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(2);
  loader.fragmentHasLoaded(2);
}","public void testBasics(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=5;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{},reqs,progress);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,BEGIN,numEntries);
  loader.leftoversFragmentHasLoaded();
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,END,numEntries);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loader.fragmentHasLoaded(1);
  progress.assertEvent(""String_Node_Str"",END,1);
  loader.inject(2,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loader.fragmentHasLoaded(2);
  progress.assertEvent(""String_Node_Str"",END,2);
  progress.assertNoEvents();
}",0.6914119359534207
54503,"/** 
 * If only the first part of the initial load sequence is requested, then don't request more.
 */
public void testLoadingPartOfInitialSequence(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,NULL_LOGGER);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(1);
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested();
  loader.inject(2,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested();
  loader.inject(3,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  loader.fragmentHasLoaded(numEntries);
  reqs.assertFragmentsRequested();
  loader.inject(5,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
}","/** 
 * If only the first part of the initial load sequence is requested, then don't request more.
 */
public void testLoadingPartOfInitialSequence(){
  MockLoadStrategy reqs=new MockLoadStrategy();
  MockProgressLogger progress=new MockProgressLogger();
  int numEntries=6;
  AsyncFragmentLoader loader=new AsyncFragmentLoader(numEntries,new int[]{1,2,3},reqs,progress);
  loader.inject(1,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(1);
  progress.assertEvent(""String_Node_Str"",BEGIN,1);
  loader.fragmentHasLoaded(1);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,1);
  loader.inject(2,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(2);
  progress.assertEvent(""String_Node_Str"",BEGIN,2);
  loader.fragmentHasLoaded(2);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,2);
  loader.inject(3,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(3);
  progress.assertEvent(""String_Node_Str"",BEGIN,3);
  loader.fragmentHasLoaded(3);
  reqs.assertFragmentsRequested(numEntries);
  progress.assertEvent(""String_Node_Str"",END,3);
  progress.assertEvent(LEFTOVERS_DOWNLOAD,BEGIN,numEntries);
  loader.fragmentHasLoaded(numEntries);
  reqs.assertFragmentsRequested();
  progress.assertEvent(LEFTOVERS_DOWNLOAD,END,numEntries);
  loader.inject(5,NULL_ERROR_HANDLER);
  reqs.assertFragmentsRequested(5);
  progress.assertEvent(""String_Node_Str"",BEGIN,5);
  loader.fragmentHasLoaded(5);
  reqs.assertFragmentsRequested();
  progress.assertEvent(""String_Node_Str"",END,5);
  progress.assertNoEvents();
}",0.7543307086614173
54504,"private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
}","private void doGetModule(HttpServletRequest request,HttpServletResponse response,TreeLogger logger,RequestParts parts) throws IOException {
  String msg=""String_Node_Str"" + parts.moduleName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.TRACE,msg,null);
  try {
    getModuleDef(logger,parts.moduleName);
  }
 catch (  UnableToCompleteException e) {
    sendErrorResponse(response,HttpServletResponse.SC_NOT_FOUND,""String_Node_Str"" + Util.escapeXml(parts.moduleName) + ""String_Node_Str"");
    return;
  }
  response.setContentType(""String_Node_Str"");
  PrintWriter writer=response.getWriter();
  writer.println(""String_Node_Str"");
  writer.print(""String_Node_Str"");
  writer.print(parts.moduleName);
  writer.println(""String_Node_Str"");
  Map<String,String[]> params=getParameterMap(request);
  for (  Map.Entry<String,String[]> entry : params.entrySet()) {
    String[] values=entry.getValue();
    if (values.length > 0) {
      writer.print(""String_Node_Str"");
      writer.print(entry.getKey());
      writer.print(""String_Node_Str"");
      writer.print(values[values.length - 1]);
      writer.println(""String_Node_Str"");
    }
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + ""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"");
}",0.9324571011318
54505,"/** 
 * Returns the Object associated with the given key in the (key, value) mapping associated with the given Object instance.
 * @param instance the source Object.
 * @param key a String key.
 * @return an Object associated with that key on the given instance, or null.
 */
public static void set(Object instance,String key,Object value){
}","/** 
 * Associates a value with a given key in the (key, value) mapping associated with the given Object instance. Note that the key space is module-wide, so some care should be taken to choose sufficiently unique identifiers.
 * @param instance the source Object.
 * @param key a String key.
 * @param value the Object to associate with the key on the given sourceObject.
 */
public static void set(Object instance,String key,Object value){
}",0.6267515923566879
54506,"/** 
 * Associates a value with a given key in the (key, value) mapping associated with the given Object instance. Note that the key space is module-wide, so some care should be taken to choose sufficiently unique identifiers.
 * @param instance the source Object.
 * @param key a String key.
 * @param value the Object to associate with the key on the given sourceObject.
 */
public static native Object get(Object instance,String key);","/** 
 * Returns the Object associated with the given key in the (key, value) mapping associated with the given Object instance.
 * @param instance the source Object.
 * @param key a String key.
 * @return an Object associated with that key on the given instance, or null.
 */
public static native Object get(Object instance,String key);",0.2328589909443725
54507,"/** 
 * Forward link type.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/struct/links.html#adef-rel"">W3C HTML Specification</a>
 */
public final native void setRel(String name);","/** 
 * Forward link type.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/struct/links.html#adef-rel"">W3C HTML Specification</a>
 */
public final native void setRel(String rel);",0.987146529562982
54508,"/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  if (GWT.isScript()) {
    try {
      t.compareTo(d2);
      fail(""String_Node_Str"");
    }
 catch (    ClassCastException e) {
    }
  }
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(2);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}","/** 
 * Timestamps have some non-obvious comparison semantics when compared to dates.
 */
public void testDateComparison(){
  long now=System.currentTimeMillis();
  Date d=new Date(now);
  Timestamp t=new Timestamp(d.getTime());
  if (now % 1000 == 0) {
    t.setNanos(1000001);
  }
 else {
    t.setNanos(1);
  }
  Date d2=new Date(t.getTime());
  assertFalse(""String_Node_Str"",d.equals(t));
  assertEquals(""String_Node_Str"",d2,t);
  assertEquals(""String_Node_Str"",d2.hashCode(),t.hashCode());
  assertFalse(""String_Node_Str"",t.equals(d2));
  if (GWT.isScript()) {
    try {
      t.compareTo(d2);
      fail(""String_Node_Str"");
    }
 catch (    ClassCastException e) {
    }
  }
  Timestamp t2=new Timestamp(d.getTime());
  t2.setNanos(t.getNanos() + 1);
  assertFalse(""String_Node_Str"",t.equals(t2));
  assertEquals(""String_Node_Str"",t.hashCode(),t2.hashCode());
}",0.990122022080186
54509,"private void writeArtifactToFile(TreeLogger logger,EmittedArtifact artifact,File outFile,Set<String> createdDirs) throws UnableToCompleteException {
  if (!outFile.exists() || (outFile.lastModified() <= artifact.getLastModified())) {
    if (!mkdirs(outFile.getParentFile(),createdDirs)) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"");
    }
 else {
      try {
        FileOutputStream out=new FileOutputStream(outFile);
        artifact.writeTo(logger,out);
        out.close();
      }
 catch (      IOException e) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"",e);
        throw new UnableToCompleteException();
      }
      outFile.setLastModified(artifact.getLastModified());
    }
  }
}","private void writeArtifactToFile(TreeLogger logger,EmittedArtifact artifact,File outFile,Set<String> createdDirs) throws UnableToCompleteException {
  if (!outFile.exists() || (outFile.lastModified() < artifact.getLastModified())) {
    if (!mkdirs(outFile.getParentFile(),createdDirs)) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"");
    }
 else {
      try {
        FileOutputStream out=new FileOutputStream(outFile);
        artifact.writeTo(logger,out);
        out.close();
      }
 catch (      IOException e) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"",e);
        throw new UnableToCompleteException();
      }
      outFile.setLastModified(artifact.getLastModified());
    }
  }
}",0.999380037197768
54510,@Override public native Element eventGetToElement(Event evt);,"@Override public Element eventGetToElement(Event evt){
  if (evt.getType().equals(""String_Node_Str"")) {
    return evt.getTarget().cast();
  }
  if (evt.getType().equals(""String_Node_Str"")) {
    return evt.getRelatedTarget().cast();
  }
  return null;
}",0.3428571428571428
54511,@Override public native Element eventGetFromElement(Event evt);,"@Override public Element eventGetFromElement(Event evt){
  if (evt.getType().equals(""String_Node_Str"")) {
    return evt.getRelatedTarget().cast();
  }
  if (evt.getType().equals(""String_Node_Str"")) {
    return evt.getTarget().cast();
  }
  return null;
}",0.3510971786833856
54512,"public void setText(String text){
  DOM.setElementProperty(getElement(),""String_Node_Str"",text != null ? text : ""String_Node_Str"");
}","/** 
 * Sets this object's text.  Note that some browsers will manipulate the text before adding it to the widget.  For example, most browsers will strip all <code>\r</code> from the text, except IE which will add a <code>\r</code> before each <code>\n</code>.  Use   {@link #getText()} to get the textdirectly from the widget.
 * @param text the object's new text
 */
public void setText(String text){
  DOM.setElementProperty(getElement(),""String_Node_Str"",text != null ? text : ""String_Node_Str"");
}",0.4188976377952756
54513,@Override public native int getTextAreaCursorPos(Element elem);,"/** 
 * The text reported in the text range does not include newline characters at the end of the selection. So, we need to create 2 ranges and subtract a character from one until the lengths are different. At that point, we know exactly how many \r\n were truncated from the selection.
 */
@Override public native int getTextAreaCursorPos(Element elem);",0.302158273381295
54514,"@Override public native void setSelectionRange(Element elem,int pos,int length);","/** 
 * Moving the start 1 character will move across a \r\n, but \r\n counts as two characters, so we need to offset the position accordingly.
 */
@Override public native void setSelectionRange(Element elem,int pos,int length);",0.5194805194805194
54515,"/** 
 * Creates a JMultiExpression from a set of JExpressionStatements, optionally terminated by a JReturnStatement. If the method doesn't match this pattern, it returns <code>null</code>. If a method has a non-void return statement and can be represented as a multi-expression, the output of the multi-expression will be the return expression of the method. If the method is void, the output of the multi-expression should be considered undefined.
 */
private JMultiExpression createMultiExpressionFromBody(JMethodBody body,boolean ignoringReturnValue){
  JMultiExpression multi=new JMultiExpression(body.getSourceInfo());
  CloneCalleeExpressionVisitor cloner=new CloneCalleeExpressionVisitor();
  for (  JStatement stmt : body.getStatements()) {
    if (stmt instanceof JExpressionStatement) {
      JExpressionStatement exprStmt=(JExpressionStatement)stmt;
      JExpression expr=exprStmt.getExpr();
      JExpression clone=cloner.cloneExpression(expr);
      multi.exprs.add(clone);
    }
 else     if (stmt instanceof JReturnStatement) {
      JReturnStatement returnStatement=(JReturnStatement)stmt;
      JExpression expr=returnStatement.getExpr();
      if (expr != null) {
        if (!ignoringReturnValue || expr.hasSideEffects()) {
          JExpression clone=cloner.cloneExpression(expr);
          multi.exprs.add(clone);
        }
      }
      break;
    }
 else {
      return null;
    }
  }
  return multi;
}","/** 
 * Creates a JMultiExpression from a set of JExpressionStatements, optionally terminated by a JReturnStatement. If the method doesn't match this pattern, it returns <code>null</code>. If a method has a non-void return statement and can be represented as a multi-expression, the output of the multi-expression will be the return expression of the method. If the method is void, the output of the multi-expression should be considered undefined.
 */
private JMultiExpression createMultiExpressionFromBody(JMethodBody body,boolean ignoringReturnValue){
  JMultiExpression multi=new JMultiExpression(body.getSourceInfo());
  CloneCalleeExpressionVisitor cloner=new CloneCalleeExpressionVisitor();
  for (  JStatement stmt : body.getStatements()) {
    if (stmt instanceof JExpressionStatement) {
      JExpressionStatement exprStmt=(JExpressionStatement)stmt;
      JExpression expr=exprStmt.getExpr();
      JExpression clone=cloner.cloneExpression(expr);
      multi.exprs.add(clone);
    }
 else     if (stmt instanceof JReturnStatement) {
      JReturnStatement returnStatement=(JReturnStatement)stmt;
      JExpression expr=returnStatement.getExpr();
      if (expr != null) {
        if (!ignoringReturnValue || expr.hasSideEffects()) {
          JExpression clone=cloner.cloneExpression(expr);
          clone=maybeCast(clone,body.getMethod().getType());
          multi.exprs.add(clone);
        }
      }
      break;
    }
 else {
      return null;
    }
  }
  return multi;
}",0.979073756432247
54516,"public void testImplicitCastToLong(){
  long l=10;
  l+=5;
  assertEquals(15,l);
  assertTrue(15 == l);
}","public void testImplicitCastToLong(){
  long l=10;
  l+=5;
  assertEquals(15,l);
  assertTrue(15 == l);
  IntegerWrapper wrap=new IntegerWrapper(20);
  assertEquals(400L,wrap.longValue() * wrap.longValue());
}",0.6687898089171974
54517,"/** 
 * Call the toSource() on the JSO
 */
public native String toSource();","/** 
 * Call the toSource() on the JSO.
 */
public native String toSource();",0.9933774834437086
54518,"/** 
 * Check whether the given date and time falls within a daylight savings time period
 * @param date and time to check.
 * @return true if daylight savings time is in effect.
 */
public boolean isDaylightTime(Date date){
  return getDaylightAdjustment(date) > 0;
}","/** 
 * Check whether the given date and time falls within a daylight savings time period.
 * @param date and time to check.
 * @return true if daylight savings time is in effect.
 */
public boolean isDaylightTime(Date date){
  return getDaylightAdjustment(date) > 0;
}",0.9981378026070764
54519,"/** 
 * Returns this locale in canonical form: <ul> <li>Deprecated language/region tags are replaced with official versions <li> </ul>
 * @return GwtLocale instance 
 */
public GwtLocale getCanonicalForm(){
  String canonLanguage=language;
  String canonScript=script;
  String canonRegion=region;
  String canonVariant=variant;
  int n=deprecatedLanguages.length;
  for (int i=0; i < n; i+=2) {
    if (deprecatedLanguages[i + 1].equals(canonLanguage)) {
      canonLanguage=deprecatedLanguages[i];
      break;
    }
  }
  n=deprecatedRegions.length;
  for (int i=0; i < n; i+=2) {
    if (deprecatedRegions[i + 1].equals(canonRegion)) {
      canonRegion=deprecatedRegions[i];
      break;
    }
  }
  if (""String_Node_Str"".equals(canonLanguage)) {
    if (canonRegion != null) {
      if (""String_Node_Str"".equals(canonRegion) && ""String_Node_Str"".equals(canonScript)) {
        canonScript=null;
      }
 else       if (""String_Node_Str"".equals(canonRegion) && ""String_Node_Str"".equals(canonScript)) {
        canonScript=null;
      }
    }
 else     if (""String_Node_Str"".equals(canonScript)) {
      canonRegion=""String_Node_Str"";
      canonScript=null;
    }
 else     if (""String_Node_Str"".equals(canonScript)) {
      canonRegion=""String_Node_Str"";
      canonScript=null;
    }
  }
  if (""String_Node_Str"".equals(canonLanguage)) {
    canonLanguage=""String_Node_Str"";
    canonVariant=null;
  }
 else   if (""String_Node_Str"".equals(canonLanguage)) {
    canonLanguage=""String_Node_Str"";
    canonVariant=null;
  }
 else   if (""String_Node_Str"".equals(canonLanguage)) {
    if (canonVariant == null || ""String_Node_Str"".equals(canonVariant)) {
      canonLanguage=""String_Node_Str"";
      canonVariant=null;
    }
 else     if (""String_Node_Str"".equals(canonVariant)) {
      canonLanguage=""String_Node_Str"";
      canonVariant=null;
    }
  }
  if (canonScript != null && canonScript.equals(DefaultLanguageScripts.getDefaultScript(canonLanguage))) {
    canonScript=null;
  }
  return factory.fromComponents(canonLanguage,canonScript,canonRegion,canonVariant);
}","/** 
 * Returns this locale in canonical form.  Changes for canonical form are: <ul> <li>Deprecated language/region tags are replaced with official versions </ul>
 * @return GwtLocale instance 
 */
public GwtLocale getCanonicalForm(){
  String canonLanguage=language;
  String canonScript=script;
  String canonRegion=region;
  String canonVariant=variant;
  int n=deprecatedLanguages.length;
  for (int i=0; i < n; i+=2) {
    if (deprecatedLanguages[i + 1].equals(canonLanguage)) {
      canonLanguage=deprecatedLanguages[i];
      break;
    }
  }
  n=deprecatedRegions.length;
  for (int i=0; i < n; i+=2) {
    if (deprecatedRegions[i + 1].equals(canonRegion)) {
      canonRegion=deprecatedRegions[i];
      break;
    }
  }
  if (""String_Node_Str"".equals(canonLanguage)) {
    if (canonRegion != null) {
      if (""String_Node_Str"".equals(canonRegion) && ""String_Node_Str"".equals(canonScript)) {
        canonScript=null;
      }
 else       if (""String_Node_Str"".equals(canonRegion) && ""String_Node_Str"".equals(canonScript)) {
        canonScript=null;
      }
    }
 else     if (""String_Node_Str"".equals(canonScript)) {
      canonRegion=""String_Node_Str"";
      canonScript=null;
    }
 else     if (""String_Node_Str"".equals(canonScript)) {
      canonRegion=""String_Node_Str"";
      canonScript=null;
    }
  }
  if (""String_Node_Str"".equals(canonLanguage)) {
    canonLanguage=""String_Node_Str"";
    canonVariant=null;
  }
 else   if (""String_Node_Str"".equals(canonLanguage)) {
    canonLanguage=""String_Node_Str"";
    canonVariant=null;
  }
 else   if (""String_Node_Str"".equals(canonLanguage)) {
    if (canonVariant == null || ""String_Node_Str"".equals(canonVariant)) {
      canonLanguage=""String_Node_Str"";
      canonVariant=null;
    }
 else     if (""String_Node_Str"".equals(canonVariant)) {
      canonLanguage=""String_Node_Str"";
      canonVariant=null;
    }
  }
  if (canonScript != null && canonScript.equals(DefaultLanguageScripts.getDefaultScript(canonLanguage))) {
    canonScript=null;
  }
  return factory.fromComponents(canonLanguage,canonScript,canonRegion,canonVariant);
}",0.9909047391096218
54520,"/** 
 * This is the real implementation of <code>getModulePrefix</code> for this linker. The other versions forward to this one.
 */
private String getModulePrefix(LinkerContext context,String strongName,boolean supportRunAsync){
  DefaultTextOutput out=new DefaultTextOutput(context.isOutputCompact());
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + About.getGwtVersionNum() + ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + strongName + ""String_Node_Str"");
  out.newlineOpt();
  if (supportRunAsync) {
    out.print(""String_Node_Str"");
    out.indentIn();
    out.newlineOpt();
    out.print(""String_Node_Str"" + getFragmentSubdir() + ""String_Node_Str""+ FRAGMENT_EXTENSION+ ""String_Node_Str"");
    out.indentOut();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.indentIn();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.indentOut();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
  }
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + context.getModuleName() + ""String_Node_Str""+ ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newline();
  return out.toString();
}","/** 
 * This is the real implementation of <code>getModulePrefix</code> for this linker. The other versions forward to this one.
 */
private String getModulePrefix(LinkerContext context,String strongName,boolean supportRunAsync){
  DefaultTextOutput out=new DefaultTextOutput(context.isOutputCompact());
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + About.getGwtVersionNum() + ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + strongName + ""String_Node_Str"");
  out.newlineOpt();
  if (supportRunAsync) {
    out.print(""String_Node_Str"");
    out.indentIn();
    out.newlineOpt();
    out.print(""String_Node_Str"" + getFragmentSubdir() + ""String_Node_Str""+ FRAGMENT_EXTENSION+ ""String_Node_Str"");
    out.indentOut();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.indentIn();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.indentOut();
    out.newlineOpt();
    out.print(""String_Node_Str"");
    out.newlineOpt();
  }
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"" + context.getModuleName() + ""String_Node_Str""+ ""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newlineOpt();
  out.print(""String_Node_Str"");
  out.newline();
  return out.toString();
}",0.9823788546255506
54521,"public Precompilation newInstance(TreeLogger logger) throws UnableToCompleteException {
  Precompilation toReturn;
  try {
    toReturn=Util.readStreamAsObject(jarFile.getInputStream(zipEntry),Precompilation.class);
  }
 catch (  IOException e) {
    toReturn=null;
  }
catch (  ClassNotFoundException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
  if (toReturn == null) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"");
    throw new UnableToCompleteException();
  }
  return toReturn;
}","public Precompilation newInstance(TreeLogger logger) throws UnableToCompleteException {
  try {
    return Util.readStreamAsObject(jarFile.getInputStream(zipEntry),Precompilation.class);
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
catch (  ClassNotFoundException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}",0.8150346191889218
54522,"public <T>T readObject(long token,Class<T> type){
  try {
    byte[] bytes=readByteArray(token);
    ByteArrayInputStream in=new ByteArrayInputStream(bytes);
    return Util.readStreamAsObject(in,type);
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public <T>T readObject(long token,Class<T> type){
  try {
    byte[] bytes=readByteArray(token);
    ByteArrayInputStream in=new ByteArrayInputStream(bytes);
    return Util.readStreamAsObject(in,type);
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.8795355587808418
54523,"/** 
 * Construct a new instance of the object stored in the backing file.
 * @param logger a sink for error messages
 * @return a new instance of the object stored in the backing file
 * @throws UnableToCompleteException if the backing store does not contain anobject of type <code>T</code>
 */
public T newInstance(TreeLogger logger) throws UnableToCompleteException {
  try {
    T toReturn=Util.readFileAsObject(backingFile,clazz);
    if (toReturn == null) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"");
      throw new UnableToCompleteException();
    }
    return toReturn;
  }
 catch (  ClassNotFoundException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}","/** 
 * Construct a new instance of the object stored in the backing file.
 * @param logger a sink for error messages
 * @return a new instance of the object stored in the backing file
 * @throws UnableToCompleteException if the backing store does not contain anobject of type <code>T</code>
 */
public T newInstance(TreeLogger logger) throws UnableToCompleteException {
  try {
    return Util.readFileAsObject(backingFile,clazz);
  }
 catch (  ClassNotFoundException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}",0.9241475295755044
54524,"public static <T>T readStreamAsObject(InputStream inputStream,Class<T> type) throws ClassNotFoundException {
  ObjectInputStream objectInputStream=null;
  try {
    objectInputStream=new ObjectInputStream(inputStream);
    return type.cast(objectInputStream.readObject());
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(objectInputStream);
  }
}","public static <T>T readStreamAsObject(InputStream inputStream,Class<T> type) throws ClassNotFoundException, IOException {
  ObjectInputStream objectInputStream=null;
  try {
    objectInputStream=new ObjectInputStream(inputStream);
    return type.cast(objectInputStream.readObject());
  }
  finally {
    Utility.close(objectInputStream);
  }
}",0.5165745856353591
54525,"public static <T extends Serializable>T readFileAsObject(File file,Class<T> type) throws ClassNotFoundException {
  FileInputStream fileInputStream=null;
  try {
    fileInputStream=new FileInputStream(file);
    return readStreamAsObject(fileInputStream,type);
  }
 catch (  IOException e) {
    return null;
  }
 finally {
    Utility.close(fileInputStream);
  }
}","public static <T extends Serializable>T readFileAsObject(File file,Class<T> type) throws ClassNotFoundException, IOException {
  FileInputStream fileInputStream=null;
  try {
    fileInputStream=new FileInputStream(file);
    return readStreamAsObject(fileInputStream,type);
  }
  finally {
    Utility.close(fileInputStream);
  }
}",0.9140401146131804
54526,"/** 
 * Loads an image from the classpath, optionally prepending this package.
 * @param name name of an image file.
 * @param prependPackage true if {@link #PACKAGE_PATH} should be prepended tothis name.
 */
static ImageIcon loadImageIcon(String name,boolean prependPackage){
  ClassLoader cl=OophmHostedModeBase.class.getClassLoader();
  if (prependPackage) {
    name=PACKAGE_PATH + name;
  }
  URL url=cl.getResource(name);
  if (url != null) {
    ImageIcon image=new ImageIcon(url);
    return image;
  }
 else {
    return new ImageIcon();
  }
}","/** 
 * Loads an image from the classpath, optionally prepending this package.
 * @param name name of an image file.
 * @param prependPackage true if {@link #PACKAGE_PATH} should be prepended tothis name.
 */
static ImageIcon loadImageIcon(String name,boolean prependPackage){
  ClassLoader cl=OophmHostedModeBase.class.getClassLoader();
  if (prependPackage) {
    name=PACKAGE_PATH + name;
  }
  URL url=(name == null) ? null : cl.getResource(name);
  if (url != null) {
    ImageIcon image=new ImageIcon(url);
    return image;
  }
 else {
    return new ImageIcon();
  }
}",0.9787234042553192
54527,"static int compute(String str){
  int n=str.length();
  int inc=(n < 64) ? 1 : (n / 32);
  int hashCode=0;
  for (int i=0; i < n; i+=inc) {
    hashCode<<=1;
    hashCode+=str.charAt(i);
  }
  hashCode|=0;
  return hashCode;
}","static int compute(String str){
  int hashCode=0;
  int n=str.length();
  int nBatch=n - 4;
  int i=0;
  while (i < nBatch) {
    hashCode=(str.charAt(i + 3) + 31 * (str.charAt(i + 2) + 31 * (str.charAt(i + 1) + 31 * (str.charAt(i) + 31 * hashCode)))) | 0;
    i+=4;
  }
  while (i < n) {
    hashCode=hashCode * 31 + str.charAt(i++);
  }
  return hashCode | 0;
}",0.230899830220713
54528,"/** 
 * Tests hashing with strings. The specific strings used in this test used to trigger failures because we use a JavaScript object as a hash map to cache the computed hash codes. This conflicts with built-in properties defined on objects -- see issue #631.
 */
public void testHashCode(){
  String[] testStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] savedHash=new int[testStrings.length];
  for (int i=0; i < testStrings.length; ++i) {
    savedHash[i]=testStrings[i].hashCode();
    String str=Integer.toString(savedHash[i]);
    for (int j=0; j < str.length(); ++j) {
      char ch=str.charAt(j);
      assertTrue(""String_Node_Str"" + ch + ""String_Node_Str""+ Integer.toHexString(ch)+ ""String_Node_Str"",ch == '-' || ch == ' ' || Character.isDigit(ch));
    }
  }
  for (int i=0; i < testStrings.length; ++i) {
    assertEquals(savedHash[i],testStrings[i].hashCode());
  }
}","/** 
 * Tests hashing with strings. The specific strings used in this test used to trigger failures because we use a JavaScript object as a hash map to cache the computed hash codes. This conflicts with built-in properties defined on objects -- see issue #631.
 */
public void testHashCode(){
  String[] testStrings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int[] javaHashes={112903375,-274141738,-1776922004,-1781441930,3125404,231605032,-1588406278,2139739112,Integer.MIN_VALUE,3841,120,0};
  for (int i=0; i < testStrings.length; ++i) {
    String testString=testStrings[i];
    int expectedHash=javaHashes[i];
    assertEquals(""String_Node_Str"" + testString,expectedHash,testString.hashCode());
    String str=Integer.toString(expectedHash);
    for (int j=0; j < str.length(); ++j) {
      char ch=str.charAt(j);
      assertTrue(""String_Node_Str"" + ch + ""String_Node_Str""+ Integer.toHexString(ch)+ ""String_Node_Str"",ch == '-' || ch == ' ' || Character.isDigit(ch));
    }
    assertEquals(expectedHash,testStrings[i].hashCode());
  }
}",0.7985546522131888
54529,"private byte[] findClassBytes(String className){
  if (JavaScriptHost.class.getName().equals(className)) {
    return javaScriptHostBytes;
  }
  if (classRewriter != null && classRewriter.isJsoIntf(className)) {
    byte[] newBytes=classRewriter.writeJsoIntf(className);
    if (CLASS_DUMP) {
      classDump(className,newBytes);
    }
    return newBytes;
  }
  String lookupClassName=canonicalizeClassName(className);
  CompiledClass compiledClass=compilationState.getClassFileMap().get(lookupClassName);
  CompilationUnit unit=(compiledClass == null) ? getUnitForClassName(lookupClassName) : compiledClass.getUnit();
  if (emmaAvailable) {
    List<JsniMethod> jsniMethods=(unit == null) ? null : unit.getJsniMethods();
    if (unit != null && !unit.isSuperSource() && !unit.isGenerated() && unit.hasAnonymousClasses() && jsniMethods != null && jsniMethods.size() > 0 && !unit.createdClassMapping()) {
      if (!unit.constructAnonymousClassMappings(logger)) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ className);
        return null;
      }
    }
  }
  byte classBytes[]=null;
  if (compiledClass != null) {
    classBytes=compiledClass.getBytes();
    if (!compiledClass.getUnit().isSuperSource()) {
      classBytes=emmaStrategy.getEmmaClassBytes(classBytes,lookupClassName,compiledClass.getUnit().getLastModified());
    }
 else {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
    }
  }
 else   if (emmaAvailable) {
    if (typeHasCompilationUnit(lookupClassName) && isClassnameGenerated(className)) {
      logger.log(TreeLogger.DEBUG,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
      classBytes=emmaStrategy.getEmmaClassBytes(null,lookupClassName,0);
    }
  }
  if (classBytes != null && classRewriter != null) {
    Map<String,String> anonymousClassMap=Collections.emptyMap();
    if (unit != null) {
      anonymousClassMap=unit.getAnonymousClassMap();
    }
    byte[] newBytes=classRewriter.rewrite(this,className,classBytes,anonymousClassMap);
    if (CLASS_DUMP) {
      if (!Arrays.equals(classBytes,newBytes)) {
        classDump(className,newBytes);
      }
    }
    classBytes=newBytes;
  }
  return classBytes;
}","private byte[] findClassBytes(String className){
  if (JavaScriptHost.class.getName().equals(className)) {
    return javaScriptHostBytes;
  }
  if (classRewriter != null && classRewriter.isJsoIntf(className)) {
    byte[] newBytes=classRewriter.writeJsoIntf(className);
    if (CLASS_DUMP) {
      classDump(className,newBytes);
    }
    return newBytes;
  }
  String lookupClassName=canonicalizeClassName(className);
  CompiledClass compiledClass=compilationState.getClassFileMap().get(lookupClassName);
  CompilationUnit unit=(compiledClass == null) ? getUnitForClassName(lookupClassName) : compiledClass.getUnit();
  if (emmaAvailable) {
    List<JsniMethod> jsniMethods=(unit == null) ? null : unit.getJsniMethods();
    if (unit != null && !unit.isSuperSource() && !unit.isGenerated() && unit.hasAnonymousClasses() && jsniMethods != null && jsniMethods.size() > 0 && !unit.createdClassMapping()) {
      if (!unit.constructAnonymousClassMappings(logger)) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ className);
        return null;
      }
    }
  }
  byte classBytes[]=null;
  if (compiledClass != null) {
    classBytes=compiledClass.getBytes();
    if (!compiledClass.getUnit().isSuperSource()) {
      classBytes=emmaStrategy.getEmmaClassBytes(classBytes,lookupClassName,compiledClass.getUnit().getLastModified());
    }
 else {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
    }
  }
 else   if (emmaAvailable) {
    if (typeHasCompilationUnit(lookupClassName) && isClassnameGenerated(className)) {
      logger.log(TreeLogger.DEBUG,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
      classBytes=emmaStrategy.getEmmaClassBytes(null,lookupClassName,0);
    }
  }
  if (classBytes != null && classRewriter != null) {
    Map<String,String> anonymousClassMap=Collections.emptyMap();
    if (unit != null) {
      anonymousClassMap=unit.getAnonymousClassMap();
    }
    byte[] newBytes=classRewriter.rewrite(typeOracle,className,classBytes,anonymousClassMap);
    if (CLASS_DUMP) {
      if (!Arrays.equals(classBytes,newBytes)) {
        classDump(className,newBytes);
      }
    }
    classBytes=newBytes;
  }
  return classBytes;
}",0.9973345179920036
54530,"/** 
 * Performs rewriting transformations on a class.
 * @param ccl the ClassLoader requesting the rewrite
 * @param className the name of the class
 * @param classBytes the bytes of the class
 * @param anonymousClassMap a map between the anonymous class names of javacompiler used to compile code and jdt. Emma-specific.
 */
public byte[] rewrite(ClassLoader ccl,String className,byte[] classBytes,Map<String,String> anonymousClassMap){
  String desc=toDescriptor(className);
  assert(!jsoIntfDescs.contains(desc));
  ClassWriter writer=new ClassWriter(0);
  ClassVisitor v=writer;
  v=new RewriteSingleJsoImplDispatches(v,ccl,singleJsoImplTypes,mangledNamesToImplementations);
  v=new RewriteRefsToJsoClasses(v,jsoIntfDescs,mapper);
  if (jsoImplDescs.contains(desc)) {
    v=WriteJsoImpl.create(v,desc,jsoIntfDescs,mapper,mangledNamesToImplementations);
  }
  v=new RewriteJsniMethods(v,anonymousClassMap);
  if (Double.parseDouble(System.getProperty(""String_Node_Str"")) < Opcodes.V1_6) {
    v=new ForceClassVersion15(v);
  }
  new ClassReader(classBytes).accept(v,0);
  return writer.toByteArray();
}","/** 
 * Performs rewriting transformations on a class.
 * @param typeOracle a typeOracle modeling the user classes
 * @param className the name of the class
 * @param classBytes the bytes of the class
 * @param anonymousClassMap a map between the anonymous class names of javacompiler used to compile code and jdt. Emma-specific.
 */
public byte[] rewrite(TypeOracle typeOracle,String className,byte[] classBytes,Map<String,String> anonymousClassMap){
  String desc=toDescriptor(className);
  assert(!jsoIntfDescs.contains(desc));
  ClassWriter writer=new ClassWriter(0);
  ClassVisitor v=writer;
  v=new RewriteSingleJsoImplDispatches(v,typeOracle,singleJsoImplTypes,mangledNamesToImplementations);
  v=new RewriteRefsToJsoClasses(v,jsoIntfDescs,mapper);
  if (jsoImplDescs.contains(desc)) {
    v=WriteJsoImpl.create(v,desc,jsoIntfDescs,mapper,mangledNamesToImplementations);
  }
  v=new RewriteJsniMethods(v,anonymousClassMap);
  if (Double.parseDouble(System.getProperty(""String_Node_Str"")) < Opcodes.V1_6) {
    v=new ForceClassVersion15(v);
  }
  new ClassReader(classBytes).accept(v,0);
  return writer.toByteArray();
}",0.942652329749104
54531,"public RewriteSingleJsoImplDispatches(ClassVisitor v,ClassLoader ccl,Set<String> singleJsoImplTypes,SortedMap<String,Method> mangledNamesToImplementations){
  super(v);
  this.ccl=ccl;
  this.singleJsoImplTypes=Collections.unmodifiableSet(singleJsoImplTypes);
  this.mangledNamesToImplementations=Collections.unmodifiableSortedMap(mangledNamesToImplementations);
}","public RewriteSingleJsoImplDispatches(ClassVisitor v,TypeOracle typeOracle,Set<String> singleJsoImplTypes,SortedMap<String,Method> mangledNamesToImplementations){
  super(v);
  this.typeOracle=typeOracle;
  this.singleJsoImplTypes=Collections.unmodifiableSet(singleJsoImplTypes);
  this.mangledNamesToImplementations=Collections.unmodifiableSortedMap(mangledNamesToImplementations);
}",0.9171122994652406
54532,"private Set<String> computeAllInterfaces(String... interfaces){
}","private Set<String> computeAllInterfaces(String[] interfaces){
  Set<String> toReturn=new HashSet<String>();
  for (  String intfName : interfaces) {
    toReturn.addAll(computeAllInterfaces(intfName));
  }
  return toReturn;
}",0.3356164383561644
54533,"public static String slurpSource(SourcePosition position){
  FileReader fr=null;
  try {
    fr=new FileReader(position.file());
    BufferedReader br=new BufferedReader(fr);
    for (int i=0, n=position.line() - 1; i < n; ++i) {
      br.readLine();
    }
    StringBuffer lines=new StringBuffer();
    String line=br.readLine();
    int braceDepth=0;
    int indent=-1;
    boolean seenSemiColonOrBrace=false;
    while (line != null) {
      if (indent == -1) {
        for (indent=0; Character.isWhitespace(line.charAt(indent)); ++indent) {
        }
      }
      if (line.length() >= indent) {
        line=line.substring(indent);
      }
      lines.append(line + ""String_Node_Str"");
      for (int i=0, n=line.length(); i < n; ++i) {
        char c=line.charAt(i);
        if (c == '{') {
          seenSemiColonOrBrace=true;
          ++braceDepth;
        }
 else         if (c == '}') {
          --braceDepth;
        }
 else         if (c == ';') {
          seenSemiColonOrBrace=true;
        }
      }
      if (braceDepth > 0 || !seenSemiColonOrBrace) {
        line=br.readLine();
      }
 else {
        break;
      }
    }
    String code=lines.toString();
    return code;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      if (fr != null) {
        fr.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return ""String_Node_Str"";
}","public static String slurpSource(SourcePosition position){
  BufferedReader br=null;
  try {
    br=new BufferedReader(new FileReader(position.file()));
    for (int i=0, n=position.line() - 1; i < n; ++i) {
      br.readLine();
    }
    StringBuffer lines=new StringBuffer();
    String line=br.readLine();
    int braceDepth=0;
    int indent=-1;
    boolean seenSemiColonOrBrace=false;
    while (line != null) {
      if (indent == -1) {
        for (indent=0; Character.isWhitespace(line.charAt(indent)); ++indent) {
        }
      }
      if (line.length() >= indent) {
        line=line.substring(indent);
      }
      lines.append(line + ""String_Node_Str"");
      for (int i=0, n=line.length(); i < n; ++i) {
        char c=line.charAt(i);
        if (c == '{') {
          seenSemiColonOrBrace=true;
          ++braceDepth;
        }
 else         if (c == '}') {
          --braceDepth;
        }
 else         if (c == ';') {
          seenSemiColonOrBrace=true;
        }
      }
      if (braceDepth > 0 || !seenSemiColonOrBrace) {
        line=br.readLine();
      }
 else {
        break;
      }
    }
    String code=lines.toString();
    return code;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    try {
      if (br != null) {
        br.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return ""String_Node_Str"";
}",0.934982332155477
54534,"public boolean copyFile(File in,File out){
  FileInputStream fis=null;
  FileOutputStream fos=null;
  try {
    fis=new FileInputStream(in);
    fos=new FileOutputStream(out);
    byte[] buf=new byte[4096];
    int i=0;
    while ((i=fis.read(buf)) != -1) {
      fos.write(buf,0,i);
    }
    return true;
  }
 catch (  Exception e) {
    return false;
  }
 finally {
    close(fis);
    close(fos);
  }
}","public boolean copyFile(File in,File out){
  FileInputStream fis=null;
  FileOutputStream fos=null;
  try {
    fis=new FileInputStream(in);
    fos=new FileOutputStream(out);
    byte[] buf=new byte[4096];
    int i=0;
    while ((i=fis.read(buf)) != -1) {
      fos.write(buf,0,i);
    }
    return true;
  }
 catch (  IOException e) {
    return false;
  }
 finally {
    close(fis);
    close(fos);
  }
}",0.9975429975429976
54535,"private String getFileFromClassPath(String filename){
  InputStream in=null;
  try {
    in=getClass().getClassLoader().getResourceAsStream(filename);
    try {
      if (in == null) {
        err.println(""String_Node_Str"" + filename);
        System.exit(-1);
      }
      StringWriter sw=new StringWriter();
      int ch;
      while ((ch=in.read()) != -1) {
        sw.write(ch);
      }
      return sw.toString();
    }
  finally {
      if (in != null) {
        in.close();
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","private String getFileFromClassPath(String filename){
  InputStream in=null;
  try {
    in=getClass().getClassLoader().getResourceAsStream(filename);
    try {
      if (in == null) {
        throw new RuntimeException(""String_Node_Str"" + filename);
      }
      StringWriter sw=new StringWriter();
      int ch;
      while ((ch=in.read()) != -1) {
        sw.write(ch);
      }
      return sw.toString();
    }
  finally {
      if (in != null) {
        in.close();
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9483985765124556
54536,"private static void split(String[] files) throws IOException {
  BufferedReader reader=null;
  String prefix=null;
  File inputFile=null;
  for (int i=0; i < files.length; i++) {
    if (reader != null) {
      reader.close();
    }
    String file=files[i];
    inputFile=new File(file);
    if (!inputFile.exists()) {
      System.err.println(""String_Node_Str"" + inputFile.getPath());
      return;
    }
    reader=new BufferedReader(new FileReader(inputFile));
    File outFile=null;
    PrintWriter writer=null;
    String line=reader.readLine();
    while (line != null) {
      if (prefix == null) {
        prefix=line.trim();
        if (prefix.length() == 0) {
          prefix=null;
        }
      }
 else       if (line.startsWith(prefix)) {
        if (writer != null) {
          writer.close();
        }
        String outPath=line.substring(prefix.length()).trim();
        outFile=new File(outPath);
        if (!outFile.isAbsolute()) {
          File absoluteParentDir=inputFile.getCanonicalFile().getParentFile();
          outFile=new File(absoluteParentDir,outPath);
          outFile.getParentFile().mkdirs();
        }
        writer=new PrintWriter(new FileWriter(outFile),true);
        writer.println(""String_Node_Str"");
      }
 else       if (writer != null) {
        writer.println(line);
      }
 else {
      }
      line=reader.readLine();
    }
    if (writer != null) {
      writer.close();
    }
  }
}","private static void split(String[] files) throws IOException {
  String prefix=null;
  File inputFile=null;
  for (int i=0; i < files.length; i++) {
    BufferedReader reader=null;
    try {
      String file=files[i];
      inputFile=new File(file);
      if (!inputFile.exists()) {
        System.err.println(""String_Node_Str"" + inputFile.getPath());
        return;
      }
      reader=new BufferedReader(new FileReader(inputFile));
      File outFile=null;
      PrintWriter writer=null;
      String line=reader.readLine();
      while (line != null) {
        if (prefix == null) {
          prefix=line.trim();
          if (prefix.length() == 0) {
            prefix=null;
          }
        }
 else         if (line.startsWith(prefix)) {
          if (writer != null) {
            writer.close();
          }
          String outPath=line.substring(prefix.length()).trim();
          outFile=new File(outPath);
          if (!outFile.isAbsolute()) {
            File absoluteParentDir=inputFile.getCanonicalFile().getParentFile();
            outFile=new File(absoluteParentDir,outPath);
            outFile.getParentFile().mkdirs();
          }
          writer=new PrintWriter(new FileWriter(outFile),true);
          writer.println(""String_Node_Str"");
        }
 else         if (writer != null) {
          writer.println(line);
        }
 else {
        }
        line=reader.readLine();
      }
      if (writer != null) {
        writer.close();
      }
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
  }
}",0.8201199200532978
54537,"/** 
 * Determines whether or not the URL is relative.
 * @param src the test url
 * @return <code>true</code> if the URL is relative, <code>false</code> if not
 */
@SuppressWarnings(""String_Node_Str"") protected static boolean isRelativeURL(String src){
  if (src.startsWith(""String_Node_Str"")) {
    return false;
  }
  try {
    URL testUrl=new URL(src);
    return false;
  }
 catch (  MalformedURLException e) {
  }
  return true;
}","/** 
 * Determines whether or not the URL is relative.
 * @param src the test url
 * @return <code>true</code> if the URL is relative, <code>false</code> if not
 */
@SuppressWarnings(""String_Node_Str"") protected static boolean isRelativeURL(String src){
  if (src.startsWith(""String_Node_Str"")) {
    return false;
  }
  try {
    new URL(src);
    return false;
  }
 catch (  MalformedURLException e) {
  }
  return true;
}",0.986046511627907
54538,"private void writeArtifactToFile(TreeLogger logger,EmittedArtifact artifact,File outFile,Set<String> createdDirs) throws UnableToCompleteException {
  if (!outFile.exists() || (outFile.lastModified() <= artifact.getLastModified())) {
    mkdirs(outFile.getParentFile(),createdDirs);
    try {
      FileOutputStream out=new FileOutputStream(outFile);
      artifact.writeTo(logger,out);
      out.close();
    }
 catch (    IOException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"",e);
      throw new UnableToCompleteException();
    }
    outFile.setLastModified(artifact.getLastModified());
  }
}","private void writeArtifactToFile(TreeLogger logger,EmittedArtifact artifact,File outFile,Set<String> createdDirs) throws UnableToCompleteException {
  if (!outFile.exists() || (outFile.lastModified() <= artifact.getLastModified())) {
    if (!mkdirs(outFile.getParentFile(),createdDirs)) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"");
    }
 else {
      try {
        FileOutputStream out=new FileOutputStream(outFile);
        artifact.writeTo(logger,out);
        out.close();
      }
 catch (      IOException e) {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + outFile.getAbsolutePath() + ""String_Node_Str"",e);
        throw new UnableToCompleteException();
      }
      outFile.setLastModified(artifact.getLastModified());
    }
  }
}",0.6839590443686007
54539,"/** 
 * A faster bulk version of   {@link File#mkdirs()} that takes advantage ofcached state to avoid a lot of file system access.
 */
private static void mkdirs(File dir,Set<String> createdDirs){
  if (dir == null) {
    return;
  }
  String path=dir.getPath();
  if (createdDirs.contains(path)) {
    return;
  }
  if (!dir.exists()) {
    mkdirs(dir.getParentFile(),createdDirs);
    dir.mkdir();
  }
  createdDirs.add(path);
}","/** 
 * A faster bulk version of   {@link File#mkdirs()} that takes advantage ofcached state to avoid a lot of file system access.
 */
private static boolean mkdirs(File dir,Set<String> createdDirs){
  if (dir == null) {
    return true;
  }
  String path=dir.getPath();
  if (createdDirs.contains(path)) {
    return true;
  }
  if (!dir.exists()) {
    if (!mkdirs(dir.getParentFile(),createdDirs)) {
      return false;
    }
    if (!dir.mkdir()) {
      return false;
    }
  }
  createdDirs.add(path);
  return true;
}",0.8763102725366876
54540,"/** 
 * Used to record dependencies of a program.
 * @param jprogram
 * @param workDir
 * @param permutationId
 * @param logger
 * @return The file that the dependencies are recorded in
 */
public File recordDependencies(JProgram jprogram,File workDir,int permutationId,TreeLogger logger){
  logger=logger.branch(TreeLogger.INFO,""String_Node_Str"");
  ControlFlowAnalyzer dependencyAnalyzer=new ControlFlowAnalyzer(jprogram);
  dependencyAnalyzer.setDependencyRecorder(this);
  File appendDepFile=new File(workDir,""String_Node_Str"" + permutationId + ""String_Node_Str"");
  try {
    FileOutputStream stream=new FileOutputStream(appendDepFile,true);
    writer=new OutputStreamWriter(new GZIPOutputStream(stream),""String_Node_Str"");
    appendDepFile.getParentFile().mkdirs();
    pw=new PrintWriter(writer);
    htmlOut=new HtmlTextOutput(pw,false);
  }
 catch (  Throwable e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
  }
  printPre();
  for (  JMethod method : jprogram.getAllEntryMethods()) {
    dependencyAnalyzer.traverseFrom(method);
  }
  printPost();
  pw.close();
  Utility.close(writer);
  logger.log(TreeLogger.INFO,""String_Node_Str"");
  return appendDepFile;
}","/** 
 * Used to record dependencies of a program.
 * @param jprogram
 * @param workDir
 * @param permutationId
 * @param logger
 * @return The file that the dependencies are recorded in
 */
public File recordDependencies(JProgram jprogram,File workDir,int permutationId,TreeLogger logger){
  logger=logger.branch(TreeLogger.INFO,""String_Node_Str"");
  ControlFlowAnalyzer dependencyAnalyzer=new ControlFlowAnalyzer(jprogram);
  dependencyAnalyzer.setDependencyRecorder(this);
  File appendDepFile=new File(workDir,""String_Node_Str"" + permutationId + ""String_Node_Str"");
  try {
    appendDepFile.getParentFile().mkdirs();
    FileOutputStream stream=new FileOutputStream(appendDepFile,true);
    writer=new OutputStreamWriter(new GZIPOutputStream(stream),""String_Node_Str"");
    pw=new PrintWriter(writer);
    htmlOut=new HtmlTextOutput(pw,false);
  }
 catch (  Throwable e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
  }
  printPre();
  for (  JMethod method : jprogram.getAllEntryMethods()) {
    dependencyAnalyzer.traverseFrom(method);
  }
  printPost();
  pw.close();
  Utility.close(writer);
  logger.log(TreeLogger.INFO,""String_Node_Str"");
  return appendDepFile;
}",0.9628691983122364
54541,"/** 
 * Used to record (runAsync) split points of a program.
 * @param jprogram
 * @param workDir
 * @param permutationId
 * @param logger
 * @return The file that the dependencies are recorded in
 */
public File recordSplitPoints(JProgram jprogram,File workDir,int permutationId,TreeLogger logger){
  logger=logger.branch(TreeLogger.INFO,""String_Node_Str"");
  File splitPointsFile=new File(workDir,""String_Node_Str"" + Integer.toString(permutationId) + ""String_Node_Str"");
  try {
    stream=new FileOutputStream(splitPointsFile,true);
    writer=new OutputStreamWriter(new GZIPOutputStream(stream),""String_Node_Str"");
    splitPointsFile.getParentFile().mkdirs();
    pw=new PrintWriter(writer);
    htmlOut=new HtmlTextOutput(pw,false);
    String curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    htmlOut.indentIn();
    htmlOut.indentIn();
    Map<Integer,String> splitPointMap=jprogram.getSplitPointMap();
    if (splitPointMap.size() > 0) {
      curLine=""String_Node_Str"";
      htmlOut.printRaw(curLine);
      htmlOut.newline();
      htmlOut.indentIn();
      htmlOut.indentIn();
      for (      Integer splitPointCount : splitPointMap.keySet()) {
        curLine=""String_Node_Str"" + splitPointCount + ""String_Node_Str""+ splitPointMap.get(splitPointCount)+ ""String_Node_Str"";
        htmlOut.printRaw(curLine);
        htmlOut.newline();
      }
      htmlOut.indentOut();
      htmlOut.indentOut();
      curLine=""String_Node_Str"";
      htmlOut.printRaw(curLine);
      htmlOut.newline();
    }
    htmlOut.indentOut();
    htmlOut.indentOut();
    curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    Utility.close(writer);
    pw.close();
    logger.log(TreeLogger.INFO,""String_Node_Str"");
  }
 catch (  Throwable e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
  }
  return splitPointsFile;
}","/** 
 * Used to record (runAsync) split points of a program.
 * @param jprogram
 * @param workDir
 * @param permutationId
 * @param logger
 * @return The file that the dependencies are recorded in
 */
public File recordSplitPoints(JProgram jprogram,File workDir,int permutationId,TreeLogger logger){
  logger=logger.branch(TreeLogger.INFO,""String_Node_Str"");
  File splitPointsFile=new File(workDir,""String_Node_Str"" + Integer.toString(permutationId) + ""String_Node_Str"");
  try {
    splitPointsFile.getParentFile().mkdirs();
    stream=new FileOutputStream(splitPointsFile,true);
    writer=new OutputStreamWriter(new GZIPOutputStream(stream),""String_Node_Str"");
    pw=new PrintWriter(writer);
    htmlOut=new HtmlTextOutput(pw,false);
    String curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    htmlOut.indentIn();
    htmlOut.indentIn();
    Map<Integer,String> splitPointMap=jprogram.getSplitPointMap();
    if (splitPointMap.size() > 0) {
      curLine=""String_Node_Str"";
      htmlOut.printRaw(curLine);
      htmlOut.newline();
      htmlOut.indentIn();
      htmlOut.indentIn();
      for (      Map.Entry<Integer,String> entry : splitPointMap.entrySet()) {
        Integer splitPointCount=entry.getKey();
        curLine=""String_Node_Str"" + splitPointCount + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"";
        htmlOut.printRaw(curLine);
        htmlOut.newline();
      }
      htmlOut.indentOut();
      htmlOut.indentOut();
      curLine=""String_Node_Str"";
      htmlOut.printRaw(curLine);
      htmlOut.newline();
    }
    htmlOut.indentOut();
    htmlOut.indentOut();
    curLine=""String_Node_Str"";
    htmlOut.printRaw(curLine);
    htmlOut.newline();
    Utility.close(writer);
    pw.close();
    logger.log(TreeLogger.INFO,""String_Node_Str"");
  }
 catch (  Throwable e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
  }
  return splitPointsFile;
}",0.9050728277247614
54542,"private boolean removeWithState(K key,State<V> state){
  if (root == null) {
    return false;
  }
  Node<K,V> node;
  Node<K,V> found=null;
  Node<K,V> parent=null;
  Node<K,V> grandparent=null;
  Node<K,V> head=new Node<K,V>(null,null);
  int dir=1;
  head.child[RIGHT]=root;
  node=head;
  while (node.child[dir] != null) {
    int last=dir;
    grandparent=parent;
    parent=node;
    node=node.child[dir];
    int c=cmp.compare(node.key,key);
    dir=c < 0 ? RIGHT : LEFT;
    if (c == 0 && (!state.matchValue || node.value.equals(state.value))) {
      found=node;
    }
    if (!isRed(node) && !isRed(node.child[dir])) {
      if (isRed(node.child[otherChild(dir)])) {
        parent=parent.child[last]=rotateSingle(node,dir);
      }
 else       if (!isRed(node.child[otherChild(dir)])) {
        Node<K,V> sibling=parent.child[otherChild(last)];
        if (sibling != null) {
          if (!isRed(sibling.child[otherChild(last)]) && !isRed(sibling.child[last])) {
            parent.isRed=false;
            sibling.isRed=true;
            node.isRed=true;
          }
 else {
            int dir2=grandparent.child[RIGHT] == parent ? RIGHT : LEFT;
            if (isRed(sibling.child[last])) {
              grandparent.child[dir2]=rotateDouble(parent,last);
            }
 else             if (isRed(sibling.child[otherChild(last)])) {
              grandparent.child[dir2]=rotateSingle(parent,last);
            }
            node.isRed=grandparent.child[dir2].isRed=true;
            grandparent.child[dir2].child[LEFT].isRed=false;
            grandparent.child[dir2].child[RIGHT].isRed=false;
          }
        }
      }
    }
  }
  if (found != null) {
    if (state != null) {
      state.found=true;
      state.value=found.value;
    }
    found.key=node.key;
    found.value=node.value;
    parent.child[parent.child[RIGHT] == node ? RIGHT : LEFT]=node.child[node.child[LEFT] == null ? RIGHT : LEFT];
    size--;
  }
  root=head.child[RIGHT];
  if (root != null) {
    root.isRed=false;
  }
  return state.found;
}","private boolean removeWithState(K key,State<V> state){
  if (root == null) {
    return false;
  }
  Node<K,V> node;
  Node<K,V> found=null;
  Node<K,V> parent=null;
  Node<K,V> grandparent=null;
  Node<K,V> head=new Node<K,V>(null,null);
  int dir=1;
  head.child[RIGHT]=root;
  node=head;
  while (node.child[dir] != null) {
    int last=dir;
    grandparent=parent;
    parent=node;
    node=node.child[dir];
    int c=cmp.compare(node.key,key);
    dir=c < 0 ? RIGHT : LEFT;
    if (c == 0 && (!state.matchValue || node.value.equals(state.value))) {
      found=node;
    }
    if (!isRed(node) && !isRed(node.child[dir])) {
      if (isRed(node.child[otherChild(dir)])) {
        parent=parent.child[last]=rotateSingle(node,dir);
      }
 else       if (!isRed(node.child[otherChild(dir)])) {
        Node<K,V> sibling=parent.child[otherChild(last)];
        if (sibling != null) {
          if (!isRed(sibling.child[otherChild(last)]) && !isRed(sibling.child[last])) {
            parent.isRed=false;
            sibling.isRed=true;
            node.isRed=true;
          }
 else {
            int dir2=grandparent.child[RIGHT] == parent ? RIGHT : LEFT;
            if (isRed(sibling.child[last])) {
              grandparent.child[dir2]=rotateDouble(parent,last);
            }
 else             if (isRed(sibling.child[otherChild(last)])) {
              grandparent.child[dir2]=rotateSingle(parent,last);
            }
            node.isRed=grandparent.child[dir2].isRed=true;
            grandparent.child[dir2].child[LEFT].isRed=false;
            grandparent.child[dir2].child[RIGHT].isRed=false;
          }
        }
      }
    }
  }
  if (found != null) {
    if (state != null) {
      state.found=true;
      state.value=found.value;
    }
    if (node != found) {
      Node<K,V> newNode=new Node<K,V>(node.key,node.value);
      replaceNode(head,found,newNode);
      if (parent == found) {
        parent=newNode;
      }
    }
    parent.child[parent.child[RIGHT] == node ? RIGHT : LEFT]=node.child[node.child[LEFT] == null ? RIGHT : LEFT];
    size--;
  }
  root=head.child[RIGHT];
  if (root != null) {
    root.isRed=false;
  }
  return state.found;
}",0.9494661921708184
54543,"public static long parseLong(String orig,int intRadix) throws NumberFormatException {
  if (orig == null) {
    throw new NumberFormatException(""String_Node_Str"");
  }
  if (orig.length() == 0) {
    throw NumberFormatException.forInputString(orig);
  }
  if (intRadix < Character.MIN_RADIX || intRadix > Character.MAX_RADIX) {
    throw new NumberFormatException(""String_Node_Str"" + intRadix + ""String_Node_Str"");
  }
  boolean neg=false;
  String s;
  if (orig.charAt(0) == '-') {
    neg=true;
    s=orig.substring(1);
  }
 else {
    s=orig;
  }
  long result=0;
  if (intRadix == 16) {
    result=parseHex(s);
  }
 else {
    long radix=intRadix;
    for (int i=0, len=s.length(); i < len; ++i) {
      if (result < 0) {
        throw NumberFormatException.forInputString(s);
      }
      result*=radix;
      char c=s.charAt(i);
      int value=Character.digit(c,intRadix);
      if (value < 0) {
        throw NumberFormatException.forInputString(s);
      }
      result+=value;
    }
  }
  if (result < 0 && result != MIN_VALUE) {
    throw NumberFormatException.forInputString(s);
  }
  if (neg) {
    return -result;
  }
 else {
    return result;
  }
}","public static long parseLong(String orig,int intRadix) throws NumberFormatException {
  if (orig == null) {
    throw new NumberFormatException(""String_Node_Str"");
  }
  if (orig.length() == 0) {
    throw NumberFormatException.forInputString(orig);
  }
  if (intRadix < Character.MIN_RADIX || intRadix > Character.MAX_RADIX) {
    throw new NumberFormatException(""String_Node_Str"" + intRadix + ""String_Node_Str"");
  }
  boolean neg=false;
  String s;
  if (orig.charAt(0) == '-') {
    neg=true;
    s=orig.substring(1);
    if (s.equals(""String_Node_Str"")) {
      throw NumberFormatException.forInputString(orig);
    }
  }
 else {
    s=orig;
  }
  long result=0;
  if (intRadix == 16) {
    result=parseHex(s);
  }
 else {
    long radix=intRadix;
    for (int i=0, len=s.length(); i < len; ++i) {
      if (result < 0) {
        throw NumberFormatException.forInputString(s);
      }
      result*=radix;
      char c=s.charAt(i);
      int value=Character.digit(c,intRadix);
      if (value < 0) {
        throw NumberFormatException.forInputString(s);
      }
      result+=value;
    }
  }
  if (result < 0 && result != MIN_VALUE) {
    throw NumberFormatException.forInputString(s);
  }
  if (neg) {
    return -result;
  }
 else {
    return result;
  }
}",0.958453311394488
54544,"public void testParse(){
  assertEquals(0L,Long.parseLong(""String_Node_Str""));
  assertEquals(100000000000L,Long.parseLong(""String_Node_Str""));
  assertEquals(-100000000000L,Long.parseLong(""String_Node_Str""));
  assertEquals(10L,Long.parseLong(""String_Node_Str""));
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"",12);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  assertEquals(0L,Long.parseLong(""String_Node_Str"",12));
  assertEquals(73686780563L,Long.parseLong(""String_Node_Str"",12));
  assertEquals(-73686780563L,Long.parseLong(""String_Node_Str"",12));
  try {
    Long.parseLong(""String_Node_Str"",12);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  assertEquals(0L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(-1L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(1L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(0xdeadbeefdeadL,Long.parseLong(""String_Node_Str"",16));
  assertEquals(-0xdeadbeefdeadL,Long.parseLong(""String_Node_Str"",16));
  try {
    Long.parseLong(""String_Node_Str"",16);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"",16);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
}","public void testParse(){
  assertEquals(0L,Long.parseLong(""String_Node_Str""));
  assertEquals(100000000000L,Long.parseLong(""String_Node_Str""));
  assertEquals(-100000000000L,Long.parseLong(""String_Node_Str""));
  assertEquals(10L,Long.parseLong(""String_Node_Str""));
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    new Long(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"",12);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  assertEquals(0L,Long.parseLong(""String_Node_Str"",12));
  assertEquals(73686780563L,Long.parseLong(""String_Node_Str"",12));
  assertEquals(-73686780563L,Long.parseLong(""String_Node_Str"",12));
  try {
    Long.parseLong(""String_Node_Str"",12);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  assertEquals(0L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(-1L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(1L,Long.parseLong(""String_Node_Str"",16));
  assertEquals(0xdeadbeefdeadL,Long.parseLong(""String_Node_Str"",16));
  assertEquals(-0xdeadbeefdeadL,Long.parseLong(""String_Node_Str"",16));
  try {
    Long.parseLong(""String_Node_Str"",16);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
  try {
    Long.parseLong(""String_Node_Str"",16);
    fail(""String_Node_Str"");
  }
 catch (  NumberFormatException ex) {
  }
}",0.8308056872037914
54545,"/** 
 * Returns the permutation's strong name. This can be used to distinguish between different permutations of the same module. In hosted mode, this method will return   {@value #HOSTED_MODE_PERMUTATION_ID}.
 */
public static String getPermutationStrongName(){
  if (GWT.isScript()) {
    return Impl.getPermutationStrongName();
  }
 else {
    return HOSTED_MODE_PERMUTATION_STRONG_NAME;
  }
}","/** 
 * Returns the permutation's strong name. This can be used to distinguish between different permutations of the same module. In hosted mode, this method will return   {@value #HOSTED_MODE_PERMUTATION_STRONG_NAME}.
 */
public static String getPermutationStrongName(){
  if (GWT.isScript()) {
    return Impl.getPermutationStrongName();
  }
 else {
    return HOSTED_MODE_PERMUTATION_STRONG_NAME;
  }
}",0.9837702871410736
54546,"/** 
 * Gets the element to which the mouse pointer was moved (only valid for  {@link Event#ONMOUSEOUT}).
 * @deprecated use {@link NativeEvent#getRelatedTarget()} instead
 * @return the element to which the mouse pointer was moved
 */
@Deprecated public final Element getToElement(){
  return DOM.eventGetToElement(this);
}","/** 
 * Gets the element to which the mouse pointer was moved (only valid for  {@link Event#ONMOUSEOUT}).
 * @deprecated use {@link NativeEvent#getRelatedEventTarget()} instead
 * @return the element to which the mouse pointer was moved
 */
@Deprecated public final Element getToElement(){
  return DOM.eventGetToElement(this);
}",0.9923430321592648
54547,"/** 
 * Gets the element from which the mouse pointer was moved (only valid for  {@link Event#ONMOUSEOVER}).
 * @deprecated use {@link NativeEvent#getRelatedTarget()} instead
 * @return the element from which the mouse pointer was moved
 */
@Deprecated public final Element getFromElement(){
  return DOM.eventGetFromElement(this);
}","/** 
 * Gets the element from which the mouse pointer was moved (only valid for  {@link Event#ONMOUSEOVER}).
 * @deprecated use {@link NativeEvent#getRelatedEventTarget()} instead
 * @return the element from which the mouse pointer was moved
 */
@Deprecated public final Element getFromElement(){
  return DOM.eventGetFromElement(this);
}",0.992548435171386
54548,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler} method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(DisclosureHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(DisclosureHandler handler);",0.9982668977469672
54549,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler} method on the object returned by an add*Handler method instead
 */
@Deprecated void removeFormHandler(FormHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeFormHandler(FormHandler handler);",0.9982847341337908
54550,"/** 
 * Adds a handler interface to receive click events.
 * @deprecated Use {@link FormPanel#addSubmitCompleteHandler FormPanel.addSubmitCompleteHandler} and{@link FormPanel#addSubmitHandler FormPanel.addSubmitHandler} instead
 * @param handler the handler interface to add
 */
@Deprecated void addFormHandler(FormHandler handler);","/** 
 * Adds a handler interface to receive click events.
 * @deprecated Use {@link FormPanel#addSubmitCompleteHandler} and{@link FormPanel#addSubmitHandler} instead
 * @param handler the handler interface to add
 */
@Deprecated void addFormHandler(FormHandler handler);",0.8571428571428571
54551,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler} method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(SuggestionHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(SuggestionHandler handler);",0.9982668977469672
54552,"/** 
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link addScrollHandler} instead
 */
@Deprecated public void removeScrollListener(ScrollListener listener){
  ListenerWrapper.WrappedScrollListener.remove(this,listener);
}","/** 
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link #addScrollHandler} instead
 */
@Deprecated public void removeScrollListener(ScrollListener listener){
  ListenerWrapper.WrappedScrollListener.remove(this,listener);
}",0.9981916817359856
54553,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link #addChangeHandler} instead
 */
@Deprecated void removeChangeListener(ChangeListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasChangeHandlers#addChangeHandler}instead
 */
@Deprecated void removeChangeListener(ChangeListener listener);",0.9714285714285714
54554,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link #addClickHandler} instead
 */
@Deprecated void removeClickListener(ClickListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasClickHandlers#addClickHandler}instead
 */
@Deprecated void removeClickListener(ClickListener listener);",0.9727126805778492
54555,"/** 
 * Adds a listener interface to receive focus events.
 * @param listener the listener interface to add
 * @deprecated use <code>addFocusHandler</code> and <cod>addBlurHandler</code>instead.
 */
@Deprecated void addFocusListener(FocusListener listener);","/** 
 * Adds a listener interface to receive focus events.
 * @param listener the listener interface to add
 * @deprecated use addFocusHandler and addBlurHandler instead.
 */
@Deprecated void addFocusListener(FocusListener listener);",0.926530612244898
54556,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link #addFocusHandler} instead
 */
@Deprecated void removeFocusListener(FocusListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasFocusHandlers#addFocusHandler}instead
 */
@Deprecated void removeFocusListener(FocusListener listener);",0.9727126805778492
54557,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasLoadHandlers#addLoadListener} instead
 */
@Deprecated void removeLoadListener(LoadListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasLoadHandlers#addLoadHandler}instead
 */
@Deprecated void removeLoadListener(LoadListener listener);",0.981012658227848
54558,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use add* methods of {@link com.google.gwt.event.dom.client.HasAllMouseHandlers}instead
 */
@Deprecated void addMouseListener(MouseListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use add* methods of {@link HasAllMouseHandlers} instead
 */
@Deprecated void addMouseListener(MouseListener listener);",0.935672514619883
54559,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated Use {@link com.google.gwt.event.dom.client.HasMouseWheelHandlers#addMouseWheelHandler}instead
 */
@Deprecated void addMouseWheelListener(MouseWheelListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated Use {@link HasMouseWheelHandlers#addMouseWheelHandler} instead
 */
@Deprecated void addMouseWheelListener(MouseWheelListener listener);",0.939670932358318
54560,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link com.google.gwt.event.dom.client.HasMouseWheelHandlers#addMouseWheelHandler}instead
 */
@Deprecated void removeMouseWheelListener(MouseWheelListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by  {@link HasMouseWheelHandlers#addMouseWheelHandler} instead
 */
@Deprecated void removeMouseWheelListener(MouseWheelListener listener);",0.952112676056338
54561,"/** 
 * Adds a listener interface to receive popup events.
 * @param listener the listener interface to add.
 * @deprecated use {@link com.google.gwt.event.logical.shared.HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void addPopupListener(PopupListener listener);","/** 
 * Adds a listener interface to receive popup events.
 * @param listener the listener interface to add.
 * @deprecated use {@link HasCloseHandlers#addCloseHandler} instead
 */
@Deprecated void addPopupListener(PopupListener listener);",0.9278752436647172
54562,"/** 
 * Removes a previously added popup listener.
 * @param listener the listener interface to remove.
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link com.google.gwt.event.logical.shared.HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void removePopupListener(PopupListener listener);","/** 
 * Removes a previously added popup listener.
 * @param listener the listener interface to remove.
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void removePopupListener(PopupListener listener);",0.9461077844311376
54563,"/** 
 * Load the Google Gears BHO if possible.
 * @return true if Gears was successfully loaded and initialized
 */
public boolean startGears(){
  try {
    GUID appClsid=getClassID(""String_Node_Str"");
    if (appClsid == null) {
      return false;
    }
  }
 catch (  SWTException e) {
    return false;
  }
  int[] address=new int[1];
  if (COM.CoCreateInstance(appClsid,0,COM.CLSCTX_INPROC_SERVER,COM.IIDIUnknown,address) != COM.S_OK) {
    return false;
  }
  IUnknown obj=new IUnknown(address[0]);
  int[] ppvObject=new int[1];
  if (obj.QueryInterface(COM.IIDIObjectWithSite,ppvObject) == COM.S_OK) {
    IObjectWithSite objectWithSite=new IObjectWithSite(ppvObject[0]);
    objectWithSite.SetSite(objIUnknown);
    objectWithSite.Release();
    return true;
  }
  return false;
}","/** 
 * Load the Google Gears BHO if possible.
 * @return true if Gears was successfully loaded and initialized
 */
public boolean startGears(){
  GUID appClsid=null;
  try {
    appClsid=getClassID(""String_Node_Str"");
    if (appClsid == null) {
      return false;
    }
  }
 catch (  SWTException e) {
    return false;
  }
  int[] address=new int[1];
  if (COM.CoCreateInstance(appClsid,0,COM.CLSCTX_INPROC_SERVER,COM.IIDIUnknown,address) != COM.S_OK) {
    return false;
  }
  IUnknown obj=new IUnknown(address[0]);
  int[] ppvObject=new int[1];
  if (obj.QueryInterface(COM.IIDIObjectWithSite,ppvObject) == COM.S_OK) {
    IObjectWithSite objectWithSite=new IObjectWithSite(ppvObject[0]);
    objectWithSite.SetSite(objIUnknown);
    objectWithSite.Release();
    return true;
  }
  return false;
}",0.9767441860465116
54564,"/** 
 * The control is unavailable in this context.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-disabled"">W3C HTML Specification</a>
 */
public final native void setDisabled(String disabled);","/** 
 * The control is unavailable in this context.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-disabled"">W3C HTML Specification</a>
 * @deprecated use {@link #setDisabled(boolean)} instead
 */
public final native void setDisabled(String disabled);",0.8922495274102079
54565,"/** 
 * The control is unavailable in this context.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-disabled"">W3C HTML Specification</a>
 */
public final native String getDisabled();","/** 
 * The control is unavailable in this context.
 * @see <a href=""http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-disabled"">W3C HTML Specification</a>
 * @deprecated use {@link #isDisabled()} instead.
 */
public final native String getDisabled();",0.8991935483870968
54566,"/** 
 * Enables/disables the link. This is currently only used for style sheet links, and may be used to activate or deactivate style sheets.
 */
public final native boolean getDisabled();","/** 
 * Enables/disables the link. This is currently only used for style sheet links, and may be used to activate or deactivate style sheets.
 * @deprecated use {@link #isDisabled()} instead.
 */
public final native boolean getDisabled();",0.8826291079812206
54567,"/** 
 * Enables/disables the style sheet.
 */
public final native boolean getDisabled();","/** 
 * Enables/disables the style sheet.
 * @deprecated use {@link #isDisabled()} instead
 */
public final native boolean getDisabled();",0.7822222222222223
54568,public final native boolean getDisabled();,"/** 
 * @deprecated use {@link #isDisabled()} instead
 */
public final native boolean getDisabled();",0.5915492957746479
54569,public final native boolean getReadOnly();,"/** 
 * @deprecated use {@link #isReadOnly()} instead.
 */
public final native boolean getReadOnly();",0.5874125874125874
54570,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(DisclosureHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(DisclosureHandler handler);",0.9519071310116086
54571,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeFormHandler(FormHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeFormHandler(FormHandler handler);",0.9523809523809524
54572,"/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(SuggestionHandler handler);","/** 
 * Removes a previously added handler interface.
 * @param handler the handler to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeEventHandler(SuggestionHandler handler);",0.9519071310116086
54573,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasChangeHandlers#addChangeHandler}instead
 */
@Deprecated void removeChangeListener(ChangeListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasChangeHandlers#addChangeHandler}instead
 */
@Deprecated void removeChangeListener(ChangeListener listener);",0.9119318181818182
54574,"/** 
 * Adds a listener interface to receive change events.
 * @param listener the listener interface to add
 * @deprecated use <code>addChangeHandler</code> or<code>addValueChangeHandler</code> instead
 */
@Deprecated void addChangeListener(ChangeListener listener);","/** 
 * Adds a listener interface to receive change events.
 * @param listener the listener interface to add
 * @deprecated use addChangeHandler or addValueChangeHandler instead
 */
@Deprecated void addChangeListener(ChangeListener listener);",0.9351669941060904
54575,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasClickHandlers#addClickHandler}instead
 */
@Deprecated void removeClickListener(ClickListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasClickHandlers#addClickHandler}instead
 */
@Deprecated void removeClickListener(ClickListener listener);",0.9109195402298852
54576,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasFocusHandlers#addFocusHandler}instead
 */
@Deprecated void removeFocusListener(FocusListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasFocusHandlers#addFocusHandler}instead
 */
@Deprecated void removeFocusListener(FocusListener listener);",0.9109195402298852
54577,"/** 
 * Adds a listener interface to receive keyboard events.
 * @param listener the listener interface to add
 * @deprecated use<code>addKeyPressHandler/addKeyDownKeyDownHandler/addKeyUpHandler</code> instead
 */
@Deprecated void addKeyboardListener(KeyboardListener listener);","/** 
 * Adds a listener interface to receive keyboard events.
 * @param listener the listener interface to add
 * @deprecated use addKeyPressHandler/addKeyDownKeyDownHandler/addKeyUpHandlerinstead
 */
@Deprecated void addKeyboardListener(KeyboardListener listener);",0.9723756906077348
54578,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeKeyboardListener(KeyboardListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeKeyboardListener(KeyboardListener listener);",0.9544740973312402
54579,"/** 
 * Adds a listener interface to receive load events.
 * @param listener the listener interface to add
 * @deprecated use {@link HasLoadHandlers#addLoadHandler} instead
 */
@Deprecated void addLoadListener(LoadListener listener);","/** 
 * Adds a listener interface to receive load events.
 * @param listener the listener interface to add
 * @deprecated use{@link com.google.gwt.event.dom.client.HasLoadHandlers#addLoadHandler}instead
 */
@Deprecated void addLoadListener(LoadListener listener);",0.9314516129032258
54580,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasLoadHandlers#addLoadHandler}instead
 */
@Deprecated void removeLoadListener(LoadListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasLoadHandlers#addLoadHandler}instead
 */
@Deprecated void removeLoadListener(LoadListener listener);",0.9098837209302324
54581,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeMouseListener(MouseListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by an add*Handler method instead
 */
@Deprecated void removeMouseListener(MouseListener listener);",0.9536
54582,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use add* methods of {@link HasAllMouseHandlers} instead
 */
@Deprecated void addMouseListener(MouseListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use add* methods of{@link com.google.gwt.event.dom.client.HasAllMouseHandlers} instead
 */
@Deprecated void addMouseListener(MouseListener listener);",0.935672514619883
54583,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated Use {@link HasMouseWheelHandlers#addMouseWheelHandler} instead
 */
@Deprecated void addMouseWheelListener(MouseWheelListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated Use{@link com.google.gwt.event.dom.client.HasMouseWheelHandlers#addMouseWheelHandler}instead
 */
@Deprecated void addMouseWheelListener(MouseWheelListener listener);",0.9377289377289376
54584,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by  {@link HasMouseWheelHandlers#addMouseWheelHandler} instead
 */
@Deprecated void removeMouseWheelListener(MouseWheelListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.dom.client.HasMouseWheelHandlers#addMouseWheelHandler}instead
 */
@Deprecated void removeMouseWheelListener(MouseWheelListener listener);",0.9157608695652174
54585,"/** 
 * Adds a listener interface to receive popup events.
 * @param listener the listener interface to add.
 * @deprecated use {@link HasCloseHandlers#addCloseHandler} instead
 */
@Deprecated void addPopupListener(PopupListener listener);","/** 
 * Adds a listener interface to receive popup events.
 * @param listener the listener interface to add.
 * @deprecated use{@link com.google.gwt.event.logical.shared.HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void addPopupListener(PopupListener listener);",0.92578125
54586,"/** 
 * Removes a previously added popup listener.
 * @param listener the listener interface to remove.
 * @deprecated Use the {@link HandlerRegistration#removeHandler}method on the object returned by   {@link HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void removePopupListener(PopupListener listener);","/** 
 * Removes a previously added popup listener.
 * @param listener the listener interface to remove.
 * @deprecated Use the{@link com.google.gwt.event.shared.HandlerRegistration#removeHandler}method on the object returned by  {@link com.google.gwt.event.logical.shared.HasCloseHandlers#addCloseHandler}instead
 */
@Deprecated void removePopupListener(PopupListener listener);",0.904899135446686
54587,"public void onClick(ClickEvent event){
  ValueChangeEvent.fireIfNotEqual(CheckBox.this,valueBeforeClick,getValue());
}","public void onClick(ClickEvent event){
  ValueChangeEvent.fire(CheckBox.this,getValue());
}",0.8708133971291866
54588,"public HandlerRegistration addValueChangeHandler(ValueChangeHandler<Boolean> handler){
  if (!valueChangeHandlerInitialized) {
    this.addKeyUpHandler(new KeyUpHandler(){
      public void onKeyUp(      KeyUpEvent event){
        valueBeforeClick=getValue();
      }
    }
);
    this.addMouseUpHandler(new MouseUpHandler(){
      public void onMouseUp(      MouseUpEvent event){
        valueBeforeClick=getValue();
      }
    }
);
    this.addClickHandler(new ClickHandler(){
      public void onClick(      ClickEvent event){
        ValueChangeEvent.fireIfNotEqual(CheckBox.this,valueBeforeClick,getValue());
      }
    }
);
    valueChangeHandlerInitialized=true;
  }
  return addHandler(handler,ValueChangeEvent.getType());
}","public HandlerRegistration addValueChangeHandler(ValueChangeHandler<Boolean> handler){
  if (!valueChangeHandlerInitialized) {
    ensureDomEventHandlers();
    valueChangeHandlerInitialized=true;
  }
  return addHandler(handler,ValueChangeEvent.getType());
}",0.4894259818731117
54589,"@Override public void sinkEvents(int eventBitsToAdd){
  if (isOrWasAttached()) {
    Event.sinkEvents(inputElem,eventBitsToAdd | Event.getEventsSunk(inputElem));
    Event.sinkEvents(labelElem,eventBitsToAdd | Event.getEventsSunk(labelElem));
  }
 else {
    super.sinkEvents(eventBitsToAdd);
  }
}","@Override public void sinkEvents(int eventBitsToAdd){
  if (isOrWasAttached()) {
    Event.sinkEvents(inputElem,eventBitsToAdd | Event.getEventsSunk(inputElem));
  }
 else {
    super.sinkEvents(eventBitsToAdd);
  }
}",0.7689320388349514
54590,"public void onClick(Widget sender){
  ++fired;
}","public void onClick(ClickEvent arg0){
  clickCount[0]++;
}",0.660377358490566
54591,"private void visitInNewContext(List<CssNode> nodes){
  MergeRulesByContentVisitor v=new MergeRulesByContentVisitor();
  v.accept(nodes);
  rulesInOrder.addAll(v.rulesInOrder);
}","private void visitInNewContext(List<CssNode> nodes){
  MergeRulesByContentVisitor v=new MergeRulesByContentVisitor();
  v.acceptWithInsertRemove(nodes);
  rulesInOrder.addAll(v.rulesInOrder);
}",0.9567567567567568
54592,"/** 
 * Parses text to produce a numeric value. <p> The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated <code>pos</code> can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of <code>pos</code> is not changed. </p>
 * @param text the string to be parsed
 * @param inOutPos position to pass in and get back
 * @return a double value representing the parsed number, or <code>0.0</code>if the parse fails
 * @throws NumberFormatException if the text segment could not be converted into a number
 */
public double parse(String text,int[] inOutPos) throws NumberFormatException {
  int start=inOutPos[0];
  double ret=0.0;
  boolean gotPositivePrefix=text.startsWith(positivePrefix,inOutPos[0]);
  boolean gotNegativePrefix=text.startsWith(negativePrefix,inOutPos[0]);
  boolean gotPositiveSuffix=text.endsWith(positiveSuffix);
  boolean gotNegativeSuffix=text.endsWith(negativeSuffix);
  boolean gotPositive=gotPositivePrefix && gotPositiveSuffix;
  boolean gotNegative=gotNegativePrefix && gotNegativeSuffix;
  if (gotPositive && gotNegative) {
    if (positivePrefix.length() > negativePrefix.length()) {
      gotNegative=false;
    }
 else     if (positivePrefix.length() < negativePrefix.length()) {
      gotPositive=false;
    }
 else     if (positiveSuffix.length() > negativeSuffix.length()) {
      gotNegative=false;
    }
 else     if (positiveSuffix.length() < negativeSuffix.length()) {
      gotPositive=false;
    }
 else {
      gotNegative=false;
    }
  }
 else   if (!gotPositive && !gotNegative) {
    throw new NumberFormatException(text + ""String_Node_Str"");
  }
  String valueOnly=null;
  if (gotPositive) {
    inOutPos[0]+=positivePrefix.length();
    valueOnly=text.substring(inOutPos[0],text.length() - positiveSuffix.length());
  }
 else {
    inOutPos[0]+=negativePrefix.length();
    valueOnly=text.substring(inOutPos[0],text.length() - negativeSuffix.length());
  }
  if (valueOnly.equals(numberConstants.infinity())) {
    inOutPos[0]+=numberConstants.infinity().length();
    ret=Double.POSITIVE_INFINITY;
  }
 else   if (valueOnly.equals(numberConstants.notANumber())) {
    inOutPos[0]+=numberConstants.notANumber().length();
    ret=Double.NaN;
  }
 else {
    int[] tempPos={0};
    ret=parseNumber(valueOnly,tempPos);
    inOutPos[0]+=tempPos[0];
  }
  if (gotPositive) {
    inOutPos[0]+=positiveSuffix.length();
  }
 else   if (gotNegative) {
    inOutPos[0]+=negativeSuffix.length();
  }
  if (gotNegative) {
    ret=-ret;
  }
  return ret;
}","/** 
 * Parses text to produce a numeric value. <p> The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated <code>pos</code> can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of <code>pos</code> is not changed. </p>
 * @param text the string to be parsed
 * @param inOutPos position to pass in and get back
 * @return a double value representing the parsed number, or <code>0.0</code>if the parse fails
 * @throws NumberFormatException if the text segment could not be converted into a number
 */
public double parse(String text,int[] inOutPos) throws NumberFormatException {
  double ret=0.0;
  boolean gotPositivePrefix=text.startsWith(positivePrefix,inOutPos[0]);
  boolean gotNegativePrefix=text.startsWith(negativePrefix,inOutPos[0]);
  boolean gotPositiveSuffix=text.endsWith(positiveSuffix);
  boolean gotNegativeSuffix=text.endsWith(negativeSuffix);
  boolean gotPositive=gotPositivePrefix && gotPositiveSuffix;
  boolean gotNegative=gotNegativePrefix && gotNegativeSuffix;
  if (gotPositive && gotNegative) {
    if (positivePrefix.length() > negativePrefix.length()) {
      gotNegative=false;
    }
 else     if (positivePrefix.length() < negativePrefix.length()) {
      gotPositive=false;
    }
 else     if (positiveSuffix.length() > negativeSuffix.length()) {
      gotNegative=false;
    }
 else     if (positiveSuffix.length() < negativeSuffix.length()) {
      gotPositive=false;
    }
 else {
      gotNegative=false;
    }
  }
 else   if (!gotPositive && !gotNegative) {
    throw new NumberFormatException(text + ""String_Node_Str"");
  }
  String valueOnly=null;
  if (gotPositive) {
    inOutPos[0]+=positivePrefix.length();
    valueOnly=text.substring(inOutPos[0],text.length() - positiveSuffix.length());
  }
 else {
    inOutPos[0]+=negativePrefix.length();
    valueOnly=text.substring(inOutPos[0],text.length() - negativeSuffix.length());
  }
  if (valueOnly.equals(numberConstants.infinity())) {
    inOutPos[0]+=numberConstants.infinity().length();
    ret=Double.POSITIVE_INFINITY;
  }
 else   if (valueOnly.equals(numberConstants.notANumber())) {
    inOutPos[0]+=numberConstants.notANumber().length();
    ret=Double.NaN;
  }
 else {
    int[] tempPos={0};
    ret=parseNumber(valueOnly,tempPos);
    inOutPos[0]+=tempPos[0];
  }
  if (gotPositive) {
    inOutPos[0]+=positiveSuffix.length();
  }
 else   if (gotNegative) {
    inOutPos[0]+=negativeSuffix.length();
  }
  if (gotNegative) {
    ret=-ret;
  }
  return ret;
}",0.9955044056824311
54593,"/** 
 * Maps each split point number to its corresponding generated <code>runAsync</code> method. If that method has been discarded, then map the split point number to <code>null</code>.
 */
private static Map<Integer,JMethod> findRunAsyncMethods(JProgram program) throws NumberFormatException {
  Map<Integer,JMethod> splitPointToLoadMethod=new HashMap<Integer,JMethod>();
  for (  JReferenceType type : program.getDeclaredTypes()) {
    Matcher matcher=LOADER_CLASS_PATTERN.matcher(type.getName());
    if (matcher.matches()) {
      int sp=Integer.parseInt(matcher.group(1));
      JMethod loadMethod=null;
      for (      JMethod meth : type.methods) {
        if (meth.getName().equals(FragmentLoaderCreator.LOADER_METHOD_RUN_ASYNC)) {
          loadMethod=meth;
        }
      }
      splitPointToLoadMethod.put(sp,loadMethod);
    }
  }
  return splitPointToLoadMethod;
}","/** 
 * Maps each split point number to its corresponding generated <code>runAsync</code> method. If that method has been discarded, then map the split point number to <code>null</code>.
 */
private static Map<Integer,JMethod> findRunAsyncMethods(JProgram program) throws NumberFormatException {
  Map<Integer,JMethod> splitPointToLoadMethod=new HashMap<Integer,JMethod>();
  for (  JDeclaredType type : program.getDeclaredTypes()) {
    Matcher matcher=LOADER_CLASS_PATTERN.matcher(type.getName());
    if (matcher.matches()) {
      int sp=Integer.parseInt(matcher.group(1));
      JMethod loadMethod=null;
      for (      JMethod meth : type.getMethods()) {
        if (meth.getName().equals(FragmentLoaderCreator.LOADER_METHOD_RUN_ASYNC)) {
          loadMethod=meth;
        }
      }
      splitPointToLoadMethod.put(sp,loadMethod);
    }
  }
  return splitPointToLoadMethod;
}",0.979591836734694
54594,"public static double[] shr(double[] a,int n){
  n&=63;
  double shiftFact=pwrAsDouble(n);
  double newHigh=a[HIGH] / shiftFact;
  double newLow=Math.floor(a[LOW] / shiftFact);
  return create(newLow,newHigh);
}","public static double[] shr(double[] a,int n){
  n&=63;
  double shiftFact=pwrAsDouble(n);
  double newHigh=Math.floor(a[HIGH] / shiftFact);
  double newLow=Math.floor(a[LOW] / shiftFact);
  return create(newLow,newHigh);
}",0.9722222222222222
54595,"public void testShift(){
  assertEquals(longFromBits(0xd048d115,0x9d159c00),LongLib.shl(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0x48d04,0x8d1159d1),LongLib.shr(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0x48d04,0x8d1159d1),LongLib.shru(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0xd048d115,0x9d159c00),LongLib.shl(longFromBits(0x92341234,0x45674567),10));
  assertEquals(longFromBits(0xffe48d04,0x8d1159d1),LongLib.shr(longFromBits(0x92341234,0x45674567),10));
  assertEquals(longFromBits(0x248d04,0x8d1159d1),LongLib.shru(longFromBits(0x92341234,0x45674567),10));
  assertEquals(LongLib.fromInt(-1),LongLib.shr(LongLib.fromInt(-1),10));
  assertEquals(LongLib.fromInt(-1 << 5),LongLib.shl(LongLib.fromInt(-1),5));
  assertEquals(LongLib.fromInt(-1),LongLib.shl(LongLib.fromInt(-1),0));
  assertEquals(LongLib.neg(LongLib.typeChange(0x4000000000000000L)),LongLib.shr(LongLib.shl(LongLib.fromInt(1),63),1));
  assertEquals(LongLib.fromInt(0),LongLib.shl(LongLib.shl(LongLib.fromInt(-1),32),32));
  assertEquals(Const.MIN_VALUE,LongLib.shl(Const.MIN_VALUE,0));
  assertEquals(LongLib.fromInt(0),LongLib.shl(Const.MIN_VALUE,1));
  assertEquals(longFromBits(0xfffffffc,0x00000000),LongLib.shr(LongLib.neg(longFromBits(8,0)),1));
  assertEquals(longFromBits(0x7ffffffc,0x0),LongLib.shru(LongLib.neg(longFromBits(8,0)),1));
}","public void testShift(){
  assertEquals(longFromBits(0xd048d115,0x9d159c00),LongLib.shl(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0x48d04,0x8d1159d1),LongLib.shr(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0x48d04,0x8d1159d1),LongLib.shru(longFromBits(0x12341234,0x45674567),10));
  assertEquals(longFromBits(0xd048d115,0x9d159c00),LongLib.shl(longFromBits(0x92341234,0x45674567),10));
  assertEquals(longFromBits(0xffe48d04,0x8d1159d1),LongLib.shr(longFromBits(0x92341234,0x45674567),10));
  assertEquals(LongLib.fromInt(67108863),LongLib.shr(longFromBits(0xFFFFFFF,0xFFFFFFFF),34));
  assertEquals(longFromBits(0x248d04,0x8d1159d1),LongLib.shru(longFromBits(0x92341234,0x45674567),10));
  assertEquals(LongLib.fromInt(-1),LongLib.shr(LongLib.fromInt(-1),10));
  assertEquals(LongLib.fromInt(-1),LongLib.shr(LongLib.fromInt(-1),63));
  assertEquals(LongLib.fromInt(-1 << 5),LongLib.shl(LongLib.fromInt(-1),5));
  assertEquals(LongLib.fromInt(-1),LongLib.shl(LongLib.fromInt(-1),0));
  assertEquals(LongLib.neg(LongLib.typeChange(0x4000000000000000L)),LongLib.shr(LongLib.shl(LongLib.fromInt(1),63),1));
  assertEquals(LongLib.fromInt(0),LongLib.shl(LongLib.shl(LongLib.fromInt(-1),32),32));
  assertEquals(Const.MIN_VALUE,LongLib.shl(Const.MIN_VALUE,0));
  assertEquals(LongLib.fromInt(0),LongLib.shl(Const.MIN_VALUE,1));
  assertEquals(longFromBits(0xfffffffc,0x00000000),LongLib.shr(LongLib.neg(longFromBits(8,0)),1));
  assertEquals(longFromBits(0x7ffffffc,0x0),LongLib.shru(LongLib.neg(longFromBits(8,0)),1));
}",0.9438277833837874
54596,"/** 
 * Returns the   {@link Class} which can serialize the given instance type. Notethat arrays never have custom field serializers.
 */
public static Class<?> hasCustomFieldSerializer(Class<?> instanceType){
  assert(instanceType != null);
  if (instanceType.isArray()) {
    return null;
  }
  Class<?> result=getCachedSerializerForClass(instanceType);
  if (result != null) {
    return result;
  }
  if (containsCachedSerializerForClass(instanceType)) {
    if (instanceType.getName().equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      System.err.println(""String_Node_Str"");
    }
    return null;
  }
  result=computeHasCustomFieldSerializer(instanceType);
  putCachedSerializerForClass(instanceType,result);
  return result;
}","/** 
 * Returns the   {@link Class} which can serialize the given instance type, or<code>null</code> if this class has no custom field serializer. Note that arrays never have custom field serializers.
 */
public static Class<?> hasCustomFieldSerializer(Class<?> instanceType){
  assert(instanceType != null);
  if (instanceType.isArray()) {
    return null;
  }
  Class<?> result;
synchronized (classCustomSerializerCache) {
    result=classCustomSerializerCache.get(instanceType);
    if (result == null) {
      result=computeHasCustomFieldSerializer(instanceType);
      if (result == null) {
        result=instanceType;
      }
      classCustomSerializerCache.put(instanceType,result);
    }
  }
  return (result == instanceType) ? null : result;
}",0.5474934036939314
54597,"public static Field[] applyFieldSerializationPolicy(Class<?> clazz){
  Field[] serializableFields=getCachedSerializableFieldsForClass(clazz);
  if (serializableFields == null) {
    ArrayList<Field> fieldList=new ArrayList<Field>();
    Field[] fields=clazz.getDeclaredFields();
    for (    Field field : fields) {
      if (fieldQualifiesForSerialization(field)) {
        fieldList.add(field);
      }
    }
    serializableFields=fieldList.toArray(new Field[fieldList.size()]);
    Arrays.sort(serializableFields,0,serializableFields.length,FIELD_COMPARATOR);
    putCachedSerializableFieldsForClass(clazz,serializableFields);
  }
  return serializableFields;
}","/** 
 * Returns the fields of a particular class that can be considered for serialization. The returned list will be sorted into a canonical order to ensure consistent answers. TODO: this method needs a better name, I think.
 */
public static Field[] applyFieldSerializationPolicy(Class<?> clazz){
  Field[] serializableFields;
synchronized (classSerializableFieldsCache) {
    serializableFields=classSerializableFieldsCache.get(clazz);
    if (serializableFields == null) {
      ArrayList<Field> fieldList=new ArrayList<Field>();
      Field[] fields=clazz.getDeclaredFields();
      for (      Field field : fields) {
        if (fieldQualifiesForSerialization(field)) {
          fieldList.add(field);
        }
      }
      serializableFields=fieldList.toArray(new Field[fieldList.size()]);
      Arrays.sort(serializableFields,0,serializableFields.length,FIELD_COMPARATOR);
      classSerializableFieldsCache.put(clazz,serializableFields);
    }
  }
  return serializableFields;
}",0.721113127646703
54598,"public static String getSerializationSignature(Class<?> instanceType){
  String result=getCachedCRCForClass(instanceType);
  if (result == null) {
    CRC32 crc=new CRC32();
    try {
      generateSerializationSignature(instanceType,crc);
    }
 catch (    UnsupportedEncodingException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
    result=Long.toString(crc.getValue());
    putCachedCRCForClass(instanceType,result);
  }
  return result;
}","public static String getSerializationSignature(Class<?> instanceType){
  String result;
synchronized (classCRC32Cache) {
    result=classCRC32Cache.get(instanceType);
    if (result == null) {
      CRC32 crc=new CRC32();
      try {
        generateSerializationSignature(instanceType,crc);
      }
 catch (      UnsupportedEncodingException e) {
        throw new RuntimeException(""String_Node_Str"",e);
      }
      result=Long.toString(crc.getValue());
      classCRC32Cache.put(instanceType,result);
    }
  }
  return result;
}",0.8405215646940822
54599,"/** 
 * Method subParseMonth parses Month field.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param cal DateRecord object that will hold parsed value
 * @param value numeric value if this field is expressed using numbericpattern
 * @param start from where parse start
 * @return <code>true</code> if parsing successful
 */
private boolean subParseMonth(String text,int[] pos,DateRecord cal,int value,int start){
  if (value < 0) {
    value=matchString(text,start,dateTimeConstants.months(),pos);
    if (value < 0) {
      value=matchString(text,start,dateTimeConstants.shortMonths(),pos);
    }
    if (value < 0) {
      return false;
    }
    cal.setMonth(value);
    return true;
  }
 else {
    cal.setMonth(value - 1);
    return true;
  }
}","/** 
 * Method subParseMonth parses Month field.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param cal DateRecord object that will hold parsed value
 * @param value numeric value if this field is expressed using numbericpattern
 * @param start from where parse start
 * @return <code>true</code> if parsing successful
 */
private boolean subParseMonth(String text,int[] pos,DateRecord cal,int value,int start){
  if (value < 0) {
    value=matchString(text,start,dateTimeConstants.months(),pos);
    if (value < 0) {
      value=matchString(text,start,dateTimeConstants.shortMonths(),pos);
    }
    if (value < 0) {
      return false;
    }
    cal.setMonth(value);
    return true;
  }
 else   if (value > 0) {
    cal.setMonth(value - 1);
    return true;
  }
  return false;
}",0.9792583280955374
54600,"/** 
 * Converts one field of the input string into a numeric field value. Returns <code>false</code> if failed.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param part the pattern part for this field
 * @param digitCount when greater than 0, numeric parsing must obey the count
 * @param cal DateRecord object that will hold parsed value
 * @return <code>true</code> if parsing successful
 */
@SuppressWarnings(""String_Node_Str"") private boolean subParse(String text,int[] pos,PatternPart part,int digitCount,DateRecord cal){
  skipSpace(text,pos);
  int start=pos[0];
  char ch=part.text.charAt(0);
  int value=-1;
  if (isNumeric(part)) {
    if (digitCount > 0) {
      if ((start + digitCount) > text.length()) {
        return false;
      }
      value=parseInt(text.substring(0,start + digitCount),pos);
    }
 else {
      value=parseInt(text,pos);
    }
  }
switch (ch) {
case 'G':
    value=matchString(text,start,dateTimeConstants.eras(),pos);
  cal.setEra(value);
return true;
case 'M':
return subParseMonth(text,pos,cal,value,start);
case 'E':
return subParseDayOfWeek(text,pos,start,cal);
case 'a':
value=matchString(text,start,dateTimeConstants.ampms(),pos);
cal.setAmpm(value);
return true;
case 'y':
return subParseYear(text,pos,start,value,part,cal);
case 'd':
cal.setDayOfMonth(value);
return true;
case 'S':
return subParseFractionalSeconds(value,start,pos[0],cal);
case 'h':
if (value == 12) {
value=0;
}
case 'K':
case 'H':
cal.setHours(value);
return true;
case 'k':
cal.setHours(value);
return true;
case 'm':
cal.setMinutes(value);
return true;
case 's':
cal.setSeconds(value);
return true;
case 'z':
case 'Z':
case 'v':
return subParseTimeZoneInGMT(text,start,pos,cal);
default :
return false;
}
}","/** 
 * Converts one field of the input string into a numeric field value. Returns <code>false</code> if failed.
 * @param text the time text to be parsed
 * @param pos Parse position
 * @param part the pattern part for this field
 * @param digitCount when greater than 0, numeric parsing must obey the count
 * @param cal DateRecord object that will hold parsed value
 * @return <code>true</code> if parsing successful
 */
@SuppressWarnings(""String_Node_Str"") private boolean subParse(String text,int[] pos,PatternPart part,int digitCount,DateRecord cal){
  skipSpace(text,pos);
  int start=pos[0];
  char ch=part.text.charAt(0);
  int value=-1;
  if (isNumeric(part)) {
    if (digitCount > 0) {
      if ((start + digitCount) > text.length()) {
        return false;
      }
      value=parseInt(text.substring(0,start + digitCount),pos);
    }
 else {
      value=parseInt(text,pos);
    }
  }
switch (ch) {
case 'G':
    value=matchString(text,start,dateTimeConstants.eras(),pos);
  cal.setEra(value);
return true;
case 'M':
return subParseMonth(text,pos,cal,value,start);
case 'E':
return subParseDayOfWeek(text,pos,start,cal);
case 'a':
value=matchString(text,start,dateTimeConstants.ampms(),pos);
cal.setAmpm(value);
return true;
case 'y':
return subParseYear(text,pos,start,value,part,cal);
case 'd':
if (value <= 0) {
return false;
}
cal.setDayOfMonth(value);
return true;
case 'S':
return subParseFractionalSeconds(value,start,pos[0],cal);
case 'h':
if (value == 12) {
value=0;
}
case 'K':
case 'H':
cal.setHours(value);
return true;
case 'k':
cal.setHours(value);
return true;
case 'm':
cal.setMinutes(value);
return true;
case 's':
cal.setSeconds(value);
return true;
case 'z':
case 'Z':
case 'v':
return subParseTimeZoneInGMT(text,start,pos,cal);
default :
return false;
}
}",0.9904009034443816
54601,"/** 
 * Sets a cookie.
 * @param name the cookie's name
 * @param value the cookie's value
 * @param expires when the cookie expires
 * @param domain the domain to be associated with this cookie
 * @param path the path to be associated with this cookie
 * @param secure <code>true</code> to make this a secure cookie
 */
public static void setCookie(String name,String value,Date expires,String domain,String path,boolean secure){
  setCookieImpl(name,value,(expires == null) ? 0 : expires.getTime(),domain,path,secure);
}","/** 
 * Sets a cookie.
 * @param name the cookie's name
 * @param value the cookie's value
 * @param expires when the cookie expires
 * @param domain the domain to be associated with this cookie
 * @param path the path to be associated with this cookie
 * @param secure <code>true</code> to make this a secure cookie (that is,only accessible over an SSL connection)
 */
public static void setCookie(String name,String value,Date expires,String domain,String path,boolean secure){
  setCookieImpl(name,value,(expires == null) ? 0 : expires.getTime(),domain,path,secure);
}",0.9551692589204026
54602,"/** 
 * Find all Artifacts assignable to some base type. The returned value will be a snapshot of the values in the ArtifactSet. The following two examples result in an equivalent set: <pre> SortedSet&lt;EmittedArtifact&gt; search = artifactSet.find(PublicResource.class); search.addAll(artifactSet.find(GeneratedResource.class); </pre> or <pre> SortedSet&lt;EmittedArtifact&gt; search = artifactSet.find(EmittedArtifact.class); </pre>
 * @param < A > a type bound possibly wider than the desired type of artifact
 * @param < T > the desired type of Artifact
 * @param artifactType the desired type of Artifact
 * @return all Artifacts in the ArtifactSet assignable to the desired type
 */
public <A extends Artifact<?>,T extends A>SortedSet<A> find(Class<T> artifactType){
  SortedSet<A> toReturn=new TreeSet<A>();
  for (  Artifact<?> artifact : this) {
    if (artifactType.isInstance(artifact)) {
      toReturn.add(artifactType.cast(artifact));
    }
  }
  return toReturn;
}","/** 
 * Find all Artifacts assignable to some base type. The returned value will be a snapshot of the values in the ArtifactSet. An example of how this could be used: <pre> for (EmittedArtifact ea : artifactSet.find(EmittedArtifact.class)) { ... } </pre>
 * @param < T > the desired type of Artifact
 * @param artifactType the desired type of Artifact
 * @return all Artifacts in the ArtifactSet assignable to the desired type
 */
public <T extends Artifact<? super T>>SortedSet<T> find(Class<T> artifactType){
  SortedSet<T> toReturn=new TreeSet<T>();
  for (  Artifact<?> artifact : this) {
    if (artifactType.isInstance(artifact)) {
      toReturn.add(artifactType.cast(artifact));
    }
  }
  return toReturn;
}",0.7589864466705951
54603,"public int hashCode(){
  return treeSet.hashCode();
}","@Override public int hashCode(){
  return treeSet.hashCode();
}",0.913793103448276
54604,"public boolean equals(Object o){
  return treeSet.equals(o);
}","@Override public boolean equals(Object o){
  return treeSet.equals(o);
}",0.9253731343283582
54605,"String mangleNameForPolyImpl(JMethod x){
  String s=getNameString(x) + ""String_Node_Str"";
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    s+=type.getJavahSignatureName();
  }
  s+=x.getOriginalReturnType().getJavahSignatureName();
  return s;
}","String mangleNameForPolyImpl(JMethod x){
  StringBuffer sb=new StringBuffer();
  if (x.isPrivate() && !x.isStatic()) {
    sb.append(""String_Node_Str"");
    sb.append(getNameString(x.getEnclosingType()));
    sb.append(""String_Node_Str"");
  }
  sb.append(getNameString(x));
  sb.append(""String_Node_Str"");
  for (int i=0; i < x.getOriginalParamTypes().size(); ++i) {
    JType type=x.getOriginalParamTypes().get(i);
    sb.append(type.getJavahSignatureName());
  }
  sb.append(x.getOriginalReturnType().getJavahSignatureName());
  return sb.toString();
}",0.6597222222222222
54606,"@Override public Widget createIssue(){
  htmlElement=DOM.getParent(RootPanel.getBodyElement());
  final SimplePanel positioner=new SimplePanel();
  positioner.setPixelSize(30,30);
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  final HTML echo=new HTML();
  final Label sandbox=new Label();
  sandbox.sinkEvents(Event.ONMOUSEMOVE);
  sandbox.setPixelSize(300,300);
  sandbox.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  sandbox.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  Event.addNativePreviewHandler(new NativePreviewHandler(){
    public void onPreviewNativeEvent(    NativePreviewEvent event){
      NativeEvent nativeEvent=event.getNativeEvent();
      Element target=nativeEvent.getTarget();
      if (!sandbox.getElement().isOrHasChild(target) && !positioner.getElement().isOrHasChild(target)) {
        positioner.removeFromParent();
        return;
      }
switch (Event.as(nativeEvent).getTypeInt()) {
case Event.ONMOUSEMOVE:
        int absX=nativeEvent.getClientX() + Window.getScrollLeft();
      int absY=nativeEvent.getClientY() + Window.getScrollTop();
    RootPanel.get().add(positioner,absX,absY);
  echo.setHTML(""String_Node_Str"" + nativeEvent.getClientX() + ""String_Node_Str""+ ""String_Node_Str""+ nativeEvent.getClientY()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteLeft()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteTop());
break;
}
}
}
);
VerticalPanel vPanel=new VerticalPanel();
vPanel.add(new ControlPanel());
vPanel.add(echo);
vPanel.add(sandbox);
return vPanel;
}","@Override public Widget createIssue(){
  htmlElement=DOM.getParent(RootPanel.getBodyElement());
  final SimplePanel positioner=new SimplePanel();
  positioner.setPixelSize(30,30);
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  positioner.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  final HTML echo=new HTML();
  final Label sandbox=new Label();
  sandbox.sinkEvents(Event.ONMOUSEMOVE);
  sandbox.setPixelSize(300,300);
  sandbox.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  sandbox.getElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  Event.addNativePreviewHandler(new NativePreviewHandler(){
    public void onPreviewNativeEvent(    NativePreviewEvent event){
      NativeEvent nativeEvent=event.getNativeEvent();
      Element target=Element.as(nativeEvent.getEventTarget());
      if (!sandbox.getElement().isOrHasChild(target) && !positioner.getElement().isOrHasChild(target)) {
        positioner.removeFromParent();
        return;
      }
switch (Event.as(nativeEvent).getTypeInt()) {
case Event.ONMOUSEMOVE:
        int absX=nativeEvent.getClientX() + Window.getScrollLeft();
      int absY=nativeEvent.getClientY() + Window.getScrollTop();
    RootPanel.get().add(positioner,absX,absY);
  echo.setHTML(""String_Node_Str"" + nativeEvent.getClientX() + ""String_Node_Str""+ ""String_Node_Str""+ nativeEvent.getClientY()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteLeft()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteTop());
break;
}
}
}
);
VerticalPanel vPanel=new VerticalPanel();
vPanel.add(new ControlPanel());
vPanel.add(echo);
vPanel.add(sandbox);
return vPanel;
}",0.9875656258634982
54607,"public void onPreviewNativeEvent(NativePreviewEvent event){
  NativeEvent nativeEvent=event.getNativeEvent();
  Element target=nativeEvent.getTarget();
  if (!sandbox.getElement().isOrHasChild(target) && !positioner.getElement().isOrHasChild(target)) {
    positioner.removeFromParent();
    return;
  }
switch (Event.as(nativeEvent).getTypeInt()) {
case Event.ONMOUSEMOVE:
    int absX=nativeEvent.getClientX() + Window.getScrollLeft();
  int absY=nativeEvent.getClientY() + Window.getScrollTop();
RootPanel.get().add(positioner,absX,absY);
echo.setHTML(""String_Node_Str"" + nativeEvent.getClientX() + ""String_Node_Str""+ ""String_Node_Str""+ nativeEvent.getClientY()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteLeft()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteTop());
break;
}
}","public void onPreviewNativeEvent(NativePreviewEvent event){
  NativeEvent nativeEvent=event.getNativeEvent();
  Element target=Element.as(nativeEvent.getEventTarget());
  if (!sandbox.getElement().isOrHasChild(target) && !positioner.getElement().isOrHasChild(target)) {
    positioner.removeFromParent();
    return;
  }
switch (Event.as(nativeEvent).getTypeInt()) {
case Event.ONMOUSEMOVE:
    int absX=nativeEvent.getClientX() + Window.getScrollLeft();
  int absY=nativeEvent.getClientY() + Window.getScrollTop();
RootPanel.get().add(positioner,absX,absY);
echo.setHTML(""String_Node_Str"" + nativeEvent.getClientX() + ""String_Node_Str""+ ""String_Node_Str""+ nativeEvent.getClientY()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteLeft()+ ""String_Node_Str""+ ""String_Node_Str""+ positioner.getAbsoluteTop());
break;
}
}",0.9725776965265084
54608,"public JExpression conditional(JConditional original,SourceInfo sourceInfo,JType type,JExpression condExpr,JExpression thenExpr,JExpression elseExpr){
  if (condExpr instanceof JMultiExpression) {
    JMultiExpression condMulti=(JMultiExpression)condExpr;
    JMultiExpression newMulti=new JMultiExpression(program,sourceInfo);
    newMulti.exprs.addAll(allButLast(condMulti.exprs));
    newMulti.exprs.add(conditional(null,sourceInfo,type,last(condMulti.exprs),thenExpr,elseExpr));
    return newMulti;
  }
  if (condExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)condExpr).getValue()) {
      return thenExpr;
    }
 else {
      return elseExpr;
    }
  }
 else   if (thenExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)thenExpr).getValue()) {
      JBinaryOperation binOp=new JBinaryOperation(program,original.getSourceInfo(),original.getType(),JBinaryOperator.OR,condExpr,elseExpr);
      return binOp;
    }
 else {
      JPrefixOperation notCondExpr=new JPrefixOperation(program,condExpr.getSourceInfo(),JUnaryOperator.NOT,condExpr);
      JBinaryOperation binOp=new JBinaryOperation(program,original.getSourceInfo(),original.getType(),JBinaryOperator.AND,notCondExpr,elseExpr);
      return binOp;
    }
  }
 else   if (elseExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)elseExpr).getValue()) {
      JPrefixOperation notCondExpr=new JPrefixOperation(program,condExpr.getSourceInfo(),JUnaryOperator.NOT,condExpr);
      JBinaryOperation binOp=new JBinaryOperation(program,original.getSourceInfo(),original.getType(),JBinaryOperator.OR,notCondExpr,thenExpr);
      return binOp;
    }
 else {
      JBinaryOperation binOp=new JBinaryOperation(program,original.getSourceInfo(),original.getType(),JBinaryOperator.AND,condExpr,thenExpr);
      return binOp;
    }
  }
 else {
    JExpression unflipped=maybeUnflipBoolean(condExpr);
    if (unflipped != null) {
      return new JConditional(program,original.getSourceInfo(),original.getType(),unflipped,elseExpr,thenExpr);
    }
  }
  if (original != null) {
    return original;
  }
  return new JConditional(program,sourceInfo,type,condExpr,thenExpr,elseExpr);
}","public JExpression conditional(JConditional original,SourceInfo sourceInfo,JType type,JExpression condExpr,JExpression thenExpr,JExpression elseExpr){
  if (condExpr instanceof JMultiExpression) {
    JMultiExpression condMulti=(JMultiExpression)condExpr;
    JMultiExpression newMulti=new JMultiExpression(program,sourceInfo);
    newMulti.exprs.addAll(allButLast(condMulti.exprs));
    newMulti.exprs.add(conditional(null,sourceInfo,type,last(condMulti.exprs),thenExpr,elseExpr));
    return newMulti;
  }
  if (condExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)condExpr).getValue()) {
      return thenExpr;
    }
 else {
      return elseExpr;
    }
  }
 else   if (thenExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)thenExpr).getValue()) {
      JBinaryOperation binOp=new JBinaryOperation(program,sourceInfo,type,JBinaryOperator.OR,condExpr,elseExpr);
      return binOp;
    }
 else {
      JPrefixOperation notCondExpr=new JPrefixOperation(program,condExpr.getSourceInfo(),JUnaryOperator.NOT,condExpr);
      JBinaryOperation binOp=new JBinaryOperation(program,sourceInfo,type,JBinaryOperator.AND,notCondExpr,elseExpr);
      return binOp;
    }
  }
 else   if (elseExpr instanceof JBooleanLiteral) {
    if (((JBooleanLiteral)elseExpr).getValue()) {
      JPrefixOperation notCondExpr=new JPrefixOperation(program,condExpr.getSourceInfo(),JUnaryOperator.NOT,condExpr);
      JBinaryOperation binOp=new JBinaryOperation(program,sourceInfo,type,JBinaryOperator.OR,notCondExpr,thenExpr);
      return binOp;
    }
 else {
      JBinaryOperation binOp=new JBinaryOperation(program,sourceInfo,type,JBinaryOperator.AND,condExpr,thenExpr);
      return binOp;
    }
  }
 else {
    JExpression unflipped=maybeUnflipBoolean(condExpr);
    if (unflipped != null) {
      return new JConditional(program,sourceInfo,type,unflipped,elseExpr,thenExpr);
    }
  }
  if (original != null) {
    return original;
  }
  return new JConditional(program,sourceInfo,type,condExpr,thenExpr,elseExpr);
}",0.8099569171852561
54609,"private String getBinaryOrPrimitiveName(JType type){
  JClassType asClass=type.isClassOrInterface();
  JPrimitiveType asPrimitive=type.isPrimitive();
  if (asClass != null) {
    return getBinaryName(asClass);
  }
 else   if (asPrimitive != null) {
    return asPrimitive.getQualifiedSourceName();
  }
 else {
    throw new InternalCompilerException(""String_Node_Str"" + type.getQualifiedSourceName());
  }
}","private String getBinaryOrPrimitiveName(JType type){
  JArrayType asArray=type.isArray();
  JClassType asClass=type.isClassOrInterface();
  JPrimitiveType asPrimitive=type.isPrimitive();
  if (asClass != null) {
    return getBinaryName(asClass);
  }
 else   if (asPrimitive != null) {
    return asPrimitive.getQualifiedSourceName();
  }
 else   if (asArray != null) {
    JType componentType=asArray.getComponentType();
    return getBinaryOrPrimitiveName(componentType) + ""String_Node_Str"";
  }
 else {
    throw new InternalCompilerException(""String_Node_Str"" + type.getQualifiedSourceName());
  }
}",0.805940594059406
54610,"/** 
 * Retrieve the DateTimeFormat object for short date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortDateFormat(){
  if (cachedShortDateFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[SHORT_DATE_FORMAT];
    cachedShortDateFormat=new DateTimeFormat(pattern);
  }
  return cachedShortDateFormat;
}","/** 
 * Retrieve the DateTimeFormat object for short date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortDateFormat(){
  if (cachedShortDateFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[SHORT_DATE_FORMAT];
    cachedShortDateFormat=new DateTimeFormat(pattern);
  }
  return cachedShortDateFormat;
}",0.991812865497076
54611,"/** 
 * Retrieve the DateTimeFormat object for medium date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumDateFormat(){
  if (cachedMediumDateFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[MEDIUM_DATE_FORMAT];
    cachedMediumDateFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumDateFormat;
}","/** 
 * Retrieve the DateTimeFormat object for medium date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumDateFormat(){
  if (cachedMediumDateFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[MEDIUM_DATE_FORMAT];
    cachedMediumDateFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumDateFormat;
}",0.9919261822376008
54612,"/** 
 * Returns a DateTimeFormat object using the specified pattern. If you need to format or parse repeatedly using the same pattern, it is highly recommended that you cache the returned <code>DateTimeFormat</code> object and reuse it rather than calling this method repeatedly.
 * @param pattern string to specify how the date should be formatted
 * @return a <code>DateTimeFormat</code> object that can be used for format orparse date/time values matching the specified pattern
 * @throws IllegalArgumentException if the specified pattern could not beparsed
 */
public static DateTimeFormat getFormat(String pattern){
  return new DateTimeFormat(pattern,defaultDateTimeConstants);
}","/** 
 * Returns a DateTimeFormat object using the specified pattern. If you need to format or parse repeatedly using the same pattern, it is highly recommended that you cache the returned <code>DateTimeFormat</code> object and reuse it rather than calling this method repeatedly.
 * @param pattern string to specify how the date should be formatted
 * @return a <code>DateTimeFormat</code> object that can be used for format orparse date/time values matching the specified pattern
 * @throws IllegalArgumentException if the specified pattern could not beparsed
 */
public static DateTimeFormat getFormat(String pattern){
  return new DateTimeFormat(pattern,getDefaultDateTimeConstants());
}",0.9876363636363636
54613,"/** 
 * Retrieve the DateTimeFormat object for medium date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumDateTimeFormat(){
  if (cachedMediumDateTimeFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[MEDIUM_DATE_FORMAT] + ""String_Node_Str"" + defaultDateTimeConstants.timeFormats()[MEDIUM_TIME_FORMAT];
    cachedMediumDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumDateTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for medium date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumDateTimeFormat(){
  if (cachedMediumDateTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[MEDIUM_DATE_FORMAT] + ""String_Node_Str"" + getDefaultDateTimeConstants().timeFormats()[MEDIUM_TIME_FORMAT];
    cachedMediumDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumDateTimeFormat;
}",0.9870848708487084
54614,"/** 
 * Retrieve the DateTimeFormat object for short date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortDateTimeFormat(){
  if (cachedShortDateTimeFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[SHORT_DATE_FORMAT] + ""String_Node_Str"" + defaultDateTimeConstants.timeFormats()[SHORT_TIME_FORMAT];
    cachedShortDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedShortDateTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for short date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortDateTimeFormat(){
  if (cachedShortDateTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[SHORT_DATE_FORMAT] + ""String_Node_Str"" + getDefaultDateTimeConstants().timeFormats()[SHORT_TIME_FORMAT];
    cachedShortDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedShortDateTimeFormat;
}",0.9869158878504672
54615,"/** 
 * Retrieve the DateTimeFormat object for long date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongDateFormat(){
  if (cachedLongDateFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[LONG_DATE_FORMAT];
    cachedLongDateFormat=new DateTimeFormat(pattern);
  }
  return cachedLongDateFormat;
}","/** 
 * Retrieve the DateTimeFormat object for long date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongDateFormat(){
  if (cachedLongDateFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[LONG_DATE_FORMAT];
    cachedLongDateFormat=new DateTimeFormat(pattern);
  }
  return cachedLongDateFormat;
}",0.9916963226571768
54616,"/** 
 * Retrieve the DateTimeFormat object for short time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortTimeFormat(){
  if (cachedShortTimeFormat == null) {
    String pattern=defaultDateTimeConstants.timeFormats()[SHORT_TIME_FORMAT];
    cachedShortTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedShortTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for short time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getShortTimeFormat(){
  if (cachedShortTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().timeFormats()[SHORT_TIME_FORMAT];
    cachedShortTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedShortTimeFormat;
}",0.991812865497076
54617,"/** 
 * Retrieve the DateTimeFormat object for long time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongTimeFormat(){
  if (cachedLongTimeFormat == null) {
    String pattern=defaultDateTimeConstants.timeFormats()[LONG_TIME_FORMAT];
    cachedLongTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedLongTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for long time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongTimeFormat(){
  if (cachedLongTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().timeFormats()[LONG_TIME_FORMAT];
    cachedLongTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedLongTimeFormat;
}",0.9916963226571768
54618,"/** 
 * Retrieve the DateTimeFormat object for full time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullTimeFormat(){
  if (cachedFullTimeFormat == null) {
    String pattern=defaultDateTimeConstants.timeFormats()[FULL_TIME_FORMAT];
    cachedFullTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedFullTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for full time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullTimeFormat(){
  if (cachedFullTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().timeFormats()[FULL_TIME_FORMAT];
    cachedFullTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedFullTimeFormat;
}",0.9916963226571768
54619,"/** 
 * Retrieve the DateTimeFormat object for full date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullDateTimeFormat(){
  if (cachedFullDateTimeFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[FULL_DATE_FORMAT] + ""String_Node_Str"" + defaultDateTimeConstants.timeFormats()[FULL_TIME_FORMAT];
    cachedFullDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedFullDateTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for full date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullDateTimeFormat(){
  if (cachedFullDateTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[FULL_DATE_FORMAT] + ""String_Node_Str"" + getDefaultDateTimeConstants().timeFormats()[FULL_TIME_FORMAT];
    cachedFullDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedFullDateTimeFormat;
}",0.9867424242424242
54620,"/** 
 * Retrieve the DateTimeFormat object for long date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongDateTimeFormat(){
  if (cachedLongDateTimeFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[LONG_DATE_FORMAT] + ""String_Node_Str"" + defaultDateTimeConstants.timeFormats()[LONG_TIME_FORMAT];
    cachedLongDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedLongDateTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for long date and time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getLongDateTimeFormat(){
  if (cachedLongDateTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[LONG_DATE_FORMAT] + ""String_Node_Str"" + getDefaultDateTimeConstants().timeFormats()[LONG_TIME_FORMAT];
    cachedLongDateTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedLongDateTimeFormat;
}",0.9867424242424242
54621,"/** 
 * Retrieve the DateTimeFormat object for medium time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumTimeFormat(){
  if (cachedMediumTimeFormat == null) {
    String pattern=defaultDateTimeConstants.timeFormats()[MEDIUM_TIME_FORMAT];
    cachedMediumTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumTimeFormat;
}","/** 
 * Retrieve the DateTimeFormat object for medium time format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getMediumTimeFormat(){
  if (cachedMediumTimeFormat == null) {
    String pattern=getDefaultDateTimeConstants().timeFormats()[MEDIUM_TIME_FORMAT];
    cachedMediumTimeFormat=new DateTimeFormat(pattern);
  }
  return cachedMediumTimeFormat;
}",0.9919261822376008
54622,"/** 
 * Retrieve the DateTimeFormat object for full date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullDateFormat(){
  if (cachedFullDateFormat == null) {
    String pattern=defaultDateTimeConstants.dateFormats()[FULL_DATE_FORMAT];
    cachedFullDateFormat=new DateTimeFormat(pattern);
  }
  return cachedFullDateFormat;
}","/** 
 * Retrieve the DateTimeFormat object for full date format. The pattern for this format is predefined for each locale.
 * @return A DateTimeFormat object.
 */
public static DateTimeFormat getFullDateFormat(){
  if (cachedFullDateFormat == null) {
    String pattern=getDefaultDateTimeConstants().dateFormats()[FULL_DATE_FORMAT];
    cachedFullDateFormat=new DateTimeFormat(pattern);
  }
  return cachedFullDateFormat;
}",0.9916963226571768
54623,"/** 
 * Gets the day of week formatter.
 * @return the day of week formatter
 */
protected DateTimeFormat getDayOfWeekFormatter(){
  return dayOfWeekFormatter;
}","/** 
 * Gets the day of week formatter.
 * @return the day of week formatter
 */
protected DateTimeFormat getDayOfWeekFormatter(){
  return DateTimeFormat.getFormat(""String_Node_Str"");
}",0.8933717579250721
54624,"/** 
 * Gets the month and year formatter.
 * @return the month and year formatter
 */
protected DateTimeFormat getMonthAndYearFormatter(){
  return monthAndYearFormatter;
}","/** 
 * Gets the month and year formatter.
 * @return the month and year formatter
 */
protected DateTimeFormat getMonthAndYearFormatter(){
  return DateTimeFormat.getFormat(""String_Node_Str"");
}",0.8858695652173914
54625,"/** 
 * Gets the date of month formatter.
 * @return the day of month formatter
 */
protected DateTimeFormat getDayOfMonthFormatter(){
  return dayOfMonthFormatter;
}","/** 
 * Gets the date of month formatter.
 * @return the day of month formatter
 */
protected DateTimeFormat getDayOfMonthFormatter(){
  return DateTimeFormat.getFormat(""String_Node_Str"");
}",0.8876404494382022
54626,"private String generateRuntimeSelection(TreeLogger logger,GeneratorContext context,JClassType targetClass,GwtLocale compileLocale,Set<GwtLocale> locales) throws UnableToCompleteException {
  String packageName=targetClass.getPackage().getName();
  String className=targetClass.getName().replace('.','_') + ""String_Node_Str"" + compileLocale.getAsString()+ ""String_Node_Str"";
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.setSuperclass(targetClass.getQualifiedSourceName());
    factory.addImport(CURRENCY_LIST);
    factory.addImport(CURRENCY_DATA);
    factory.addImport(""String_Node_Str"");
    SourceWriter writer=factory.createSourceWriter(context,pw);
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.indent();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    boolean fetchedLocale=false;
    Map<String,Set<GwtLocale>> localeMap=new HashMap<String,Set<GwtLocale>>();
    String compileLocaleClass=processChildLocale(logger,context,targetClass,localeMap,compileLocale);
    if (compileLocaleClass == null) {
      return null;
    }
    for (    GwtLocale runtimeLocale : locales) {
      processChildLocale(logger,context,targetClass,localeMap,runtimeLocale);
    }
    for (    Entry<String,Set<GwtLocale>> entry : localeMap.entrySet()) {
      if (!fetchedLocale) {
        writer.println(""String_Node_Str"");
        fetchedLocale=true;
      }
      boolean firstLocale=true;
      String generatedClass=entry.getKey();
      if (compileLocaleClass.equals(generatedClass)) {
        continue;
      }
      writer.print(""String_Node_Str"");
      for (      GwtLocale locale : entry.getValue()) {
        if (firstLocale) {
          firstLocale=false;
        }
 else {
          writer.println();
          writer.print(""String_Node_Str"");
        }
        writer.print(""String_Node_Str"" + locale.toString() + ""String_Node_Str"");
      }
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"" + generatedClass + ""String_Node_Str"");
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"");
    }
    writer.println(""String_Node_Str"" + compileLocaleClass + ""String_Node_Str"");
    writer.outdent();
    writer.println(""String_Node_Str"");
    writer.commit(logger);
  }
  return packageName + ""String_Node_Str"" + className;
}","private String generateRuntimeSelection(TreeLogger logger,GeneratorContext context,JClassType targetClass,GwtLocale compileLocale,Set<GwtLocale> locales) throws UnableToCompleteException {
  String packageName=targetClass.getPackage().getName();
  String className=targetClass.getName().replace('.','_') + ""String_Node_Str"" + compileLocale.getAsString()+ ""String_Node_Str"";
  PrintWriter pw=context.tryCreate(logger,packageName,className);
  if (pw != null) {
    ClassSourceFileComposerFactory factory=new ClassSourceFileComposerFactory(packageName,className);
    factory.setSuperclass(targetClass.getQualifiedSourceName());
    factory.addImport(CURRENCY_LIST);
    factory.addImport(CURRENCY_DATA);
    factory.addImport(""String_Node_Str"");
    SourceWriter writer=factory.createSourceWriter(context,pw);
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println();
    writer.println(""String_Node_Str"");
    writer.indent();
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    writer.println(""String_Node_Str"");
    boolean fetchedLocale=false;
    Map<String,Set<GwtLocale>> localeMap=new HashMap<String,Set<GwtLocale>>();
    String compileLocaleClass=processChildLocale(logger,context,targetClass,localeMap,compileLocale);
    if (compileLocaleClass == null) {
      return null;
    }
    for (    GwtLocale runtimeLocale : locales) {
      processChildLocale(logger,context,targetClass,localeMap,runtimeLocale);
    }
    for (    Entry<String,Set<GwtLocale>> entry : localeMap.entrySet()) {
      if (!fetchedLocale) {
        writer.println(""String_Node_Str"");
        fetchedLocale=true;
      }
      boolean firstLocale=true;
      String generatedClass=entry.getKey();
      if (compileLocaleClass.equals(generatedClass)) {
        continue;
      }
      writer.print(""String_Node_Str"");
      for (      GwtLocale locale : entry.getValue()) {
        if (firstLocale) {
          firstLocale=false;
        }
 else {
          writer.println();
          writer.print(""String_Node_Str"");
        }
        writer.print(""String_Node_Str"" + locale.toString() + ""String_Node_Str"");
      }
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"" + generatedClass + ""String_Node_Str"");
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"");
    }
    writer.println(""String_Node_Str"" + compileLocaleClass + ""String_Node_Str"");
    writer.outdent();
    writer.println(""String_Node_Str"");
    writer.commit(logger);
  }
  return packageName + ""String_Node_Str"" + className;
}",0.9880331389996933
54627,"public Date getValue(){
  return CalendarUtil.copyDate(super.getValue());
}","@Override public Date getValue(){
  return CalendarUtil.copyDate(super.getValue());
}",0.9375
54628,"/** 
 * Creates a new date value change event.
 * @param value the value
 */
protected DateChangeEvent(Date value){
  super(value);
}","/** 
 * Creates a new date value change event.
 * @param value the value
 */
protected DateChangeEvent(Date value){
  super(CalendarUtil.copyDate(value));
}",0.9204152249134948
54629,"/** 
 * Test that   {@link Event#fireNativePreviewEvent(Event)} returns the correctvalue if no handlers are present.
 */
public void testFireNativePreviewEventWithoutHandlers(){
  assertTrue(Event.fireNativePreviewEvent(null));
}","/** 
 * Test that   {@link Event#fireNativePreviewEvent(NativeEvent)} returns thecorrect value if no handlers are present.
 */
public void testFireNativePreviewEventWithoutHandlers(){
  assertTrue(Event.fireNativePreviewEvent(null));
}",0.9827586206896552
54630,"/** 
 * Test that   {@link Event#fireNativePreviewEvent(Event)} returns the correctvalue if the native event is not canceled.
 */
public void testFireNativePreviewEventWithoutCancel(){
  TestNativePreviewHandler handler0=new TestNativePreviewHandler(false,false);
  TestNativePreviewHandler handler1=new TestNativePreviewHandler(false,false);
  HandlerRegistration reg0=Event.addNativePreviewHandler(handler0);
  HandlerRegistration reg1=Event.addNativePreviewHandler(handler1);
  assertTrue(Event.fireNativePreviewEvent(null));
  handler0.assertIsFired(true);
  handler1.assertIsFired(true);
  reg0.removeHandler();
  reg1.removeHandler();
}","/** 
 * Test that   {@link Event#fireNativePreviewEvent(NativeEvent)} returns thecorrect value if the native event is not canceled.
 */
public void testFireNativePreviewEventWithoutCancel(){
  TestNativePreviewHandler handler0=new TestNativePreviewHandler(false,false);
  TestNativePreviewHandler handler1=new TestNativePreviewHandler(false,false);
  HandlerRegistration reg0=Event.addNativePreviewHandler(handler0);
  HandlerRegistration reg1=Event.addNativePreviewHandler(handler1);
  assertTrue(Event.fireNativePreviewEvent(null));
  handler0.assertIsFired(true);
  handler1.assertIsFired(true);
  reg0.removeHandler();
  reg1.removeHandler();
}",0.993798449612403
54631,"/** 
 * Test that   {@link Event#fireNativePreviewEvent(Event)} returns the correctvalue if the native event is prevented from being canceled, even if another handler cancels the event.
 */
public void testFireNativePreviewEventPreventCancel(){
  TestNativePreviewHandler handler0=new TestNativePreviewHandler(false,true);
  TestNativePreviewHandler handler1=new TestNativePreviewHandler(true,false);
  HandlerRegistration reg0=Event.addNativePreviewHandler(handler0);
  HandlerRegistration reg1=Event.addNativePreviewHandler(handler1);
  assertTrue(Event.fireNativePreviewEvent(null));
  handler0.assertIsFired(true);
  handler1.assertIsFired(true);
  reg0.removeHandler();
  reg1.removeHandler();
}","/** 
 * Test that   {@link Event#fireNativePreviewEvent(NativeEvent)} returns thecorrect value if the native event is prevented from being canceled, even if another handler cancels the event.
 */
public void testFireNativePreviewEventPreventCancel(){
  TestNativePreviewHandler handler0=new TestNativePreviewHandler(false,true);
  TestNativePreviewHandler handler1=new TestNativePreviewHandler(true,false);
  HandlerRegistration reg0=Event.addNativePreviewHandler(handler0);
  HandlerRegistration reg1=Event.addNativePreviewHandler(handler1);
  assertTrue(Event.fireNativePreviewEvent(null));
  handler0.assertIsFired(true);
  handler1.assertIsFired(true);
  reg0.removeHandler();
  reg1.removeHandler();
}",0.9943100995732574
54632,"/** 
 * Test that   {@link Event#fireNativePreviewEvent(Event)} fires handlers inreverse order, and that the legacy EventPreview fires only if it is at the top of the stack.
 */
@SuppressWarnings(""String_Node_Str"") public void testFireNativePreviewEventReverseOrder(){
  final TestEventPreview preview0=new TestEventPreview(false);
  final TestEventPreview preview1=new TestEventPreview(false);
  final TestNativePreviewHandler handler0=new TestNativePreviewHandler(false,false){
    @Override public void onPreviewNativeEvent(    NativePreviewEvent event){
      super.onPreviewNativeEvent(event);
      preview0.assertIsFired(false);
      preview1.assertIsFired(true);
      assertFalse(event.isFirstHandler());
    }
  }
;
  final TestNativePreviewHandler handler1=new TestNativePreviewHandler(false,false){
    @Override public void onPreviewNativeEvent(    NativePreviewEvent event){
      super.onPreviewNativeEvent(event);
      handler0.assertIsFired(false);
      preview0.assertIsFired(false);
      preview1.assertIsFired(true);
      assertFalse(event.isFirstHandler());
    }
  }
;
  final TestNativePreviewHandler handler2=new TestNativePreviewHandler(false,false){
    @Override public void onPreviewNativeEvent(    NativePreviewEvent event){
      super.onPreviewNativeEvent(event);
      handler0.assertIsFired(false);
      handler1.assertIsFired(false);
      preview0.assertIsFired(false);
      preview1.assertIsFired(true);
      assertFalse(event.isFirstHandler());
    }
  }
;
  final TestNativePreviewHandler handler3=new TestNativePreviewHandler(false,false){
    @Override public void onPreviewNativeEvent(    NativePreviewEvent event){
      super.onPreviewNativeEvent(event);
      handler0.assertIsFired(false);
      handler1.assertIsFired(false);
      handler2.assertIsFired(false);
      preview0.assertIsFired(false);
      preview1.assertIsFired(true);
      assertFalse(event.isFirstHandler());
    }
  }
;
  DOM.addEventPreview(preview0);
  HandlerRegistration reg0=Event.addNativePreviewHandler(handler0);
  HandlerRegistration reg1=Event.addNativePreviewHandler(handler1);
  HandlerRegistration reg2=Event.addNativePreviewHandler(handler2);
  HandlerRegistration reg3=Event.addNativePreviewHandler(handler3);
  DOM.addEventPreview(preview1);
  assertTrue(DOM.previewEvent(null));
  handler0.assertIsFired(true);
  handler1.assertIsFired(true);
  handler2.assertIsFired(true);
  handler3.assertIsFired(true);
  preview0.assertIsFired(false);
  preview1.assertIsFired(true);
  reg0.removeHandler();
  reg1.removeHandler();
  reg2.removeHandler();
  reg3.removeHandler();
  DOM.removeEventPreview(preview0);
  DOM.removeEventPreview(preview1);
}","/** 
 * Test that   {@link Event#fireNativePreviewEvent(NativeEvent)} fires handlersin reverse order, and that the legacy EventPreview fires only if it is at the top of the stack.
 */
@SuppressWarnings(""String_Node_Str"") public void testFireNativePreviewEventReverseOrder(){
  final TestEventPreview preview0=new TestEventPreview(false);
  final TestEventPreview preview1=new TestEventPreview(false);
  final TestNativePreviewHandler handler0=new TestNativePreviewHandler(false,false){
    @Override public void onPreviewNativeEvent(    NativePreviewEvent event){
      super.onPreviewNativeEvent(event);
      preview0.assertIsFired(false);
      preview1.assertIsFired(true);
      assertFalse(event.isFirstHandler());
    }
  }
;
  final TestNativePreviewHandler handler1=new TestNativePreviewHandler(false,false){
    @Override public void onPreviewNativeEvent(    NativePreviewEvent event){
      super.onPreviewNativeEvent(event);
      handler0.assertIsFired(false);
      preview0.assertIsFired(false);
      preview1.assertIsFired(true);
      assertFalse(event.isFirstHandler());
    }
  }
;
  final TestNativePreviewHandler handler2=new TestNativePreviewHandler(false,false){
    @Override public void onPreviewNativeEvent(    NativePreviewEvent event){
      super.onPreviewNativeEvent(event);
      handler0.assertIsFired(false);
      handler1.assertIsFired(false);
      preview0.assertIsFired(false);
      preview1.assertIsFired(true);
      assertFalse(event.isFirstHandler());
    }
  }
;
  final TestNativePreviewHandler handler3=new TestNativePreviewHandler(false,false){
    @Override public void onPreviewNativeEvent(    NativePreviewEvent event){
      super.onPreviewNativeEvent(event);
      handler0.assertIsFired(false);
      handler1.assertIsFired(false);
      handler2.assertIsFired(false);
      preview0.assertIsFired(false);
      preview1.assertIsFired(true);
      assertFalse(event.isFirstHandler());
    }
  }
;
  DOM.addEventPreview(preview0);
  HandlerRegistration reg0=Event.addNativePreviewHandler(handler0);
  HandlerRegistration reg1=Event.addNativePreviewHandler(handler1);
  HandlerRegistration reg2=Event.addNativePreviewHandler(handler2);
  HandlerRegistration reg3=Event.addNativePreviewHandler(handler3);
  DOM.addEventPreview(preview1);
  assertTrue(DOM.previewEvent(null));
  handler0.assertIsFired(true);
  handler1.assertIsFired(true);
  handler2.assertIsFired(true);
  handler3.assertIsFired(true);
  preview0.assertIsFired(false);
  preview1.assertIsFired(true);
  reg0.removeHandler();
  reg1.removeHandler();
  reg2.removeHandler();
  reg3.removeHandler();
  DOM.removeEventPreview(preview0);
  DOM.removeEventPreview(preview1);
}",0.9977661950856292
54633,"/** 
 * Test that   {@link Event#fireNativePreviewEvent(Event)} returns the correctvalue if the native event is canceled.
 */
public void testFireNativePreviewEventCancel(){
  TestNativePreviewHandler handler0=new TestNativePreviewHandler(true,false);
  TestNativePreviewHandler handler1=new TestNativePreviewHandler(true,false);
  HandlerRegistration reg0=Event.addNativePreviewHandler(handler0);
  HandlerRegistration reg1=Event.addNativePreviewHandler(handler1);
  assertFalse(Event.fireNativePreviewEvent(null));
  handler0.assertIsFired(true);
  handler1.assertIsFired(true);
  reg0.removeHandler();
  reg1.removeHandler();
}","/** 
 * Test that   {@link Event#fireNativePreviewEvent(NativeEvent)} returns thecorrect value if the native event is canceled.
 */
public void testFireNativePreviewEventCancel(){
  TestNativePreviewHandler handler0=new TestNativePreviewHandler(true,false);
  TestNativePreviewHandler handler1=new TestNativePreviewHandler(true,false);
  HandlerRegistration reg0=Event.addNativePreviewHandler(handler0);
  HandlerRegistration reg1=Event.addNativePreviewHandler(handler1);
  assertFalse(Event.fireNativePreviewEvent(null));
  handler0.assertIsFired(true);
  handler1.assertIsFired(true);
  reg0.removeHandler();
  reg1.removeHandler();
}",0.9936808846761452
54634,"private Widget dateRange(){
  VerticalPanel v=new VerticalPanel();
  HorizontalPanel p=new HorizontalPanel();
  v.add(p);
  final DateBox start=new DateBox(new DatePicker(),null,new FormatWithNewYearsEve());
  start.setWidth(""String_Node_Str"");
  final DateBox end=new DateBox();
  end.setWidth(""String_Node_Str"");
  end.getDatePicker().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      start.removeStyleName(""String_Node_Str"");
    }
  }
);
  final TextBox startText=start.getTextBox();
  startText.addKeyDownHandler(new KeyDownHandler(){
    public void onKeyDown(    KeyDownEvent e){
      if (e.isRightArrow() && start.getCursorPos() == startText.getText().length()) {
        start.hideDatePicker();
        end.setFocus(true);
      }
    }
  }
);
  end.getTextBox().addKeyDownHandler(new KeyDownHandler(){
    public void onKeyDown(    KeyDownEvent e){
      if ((e.isLeftArrow()) && end.getCursorPos() == 0) {
        end.hideDatePicker();
        start.setFocus(true);
      }
    }
  }
);
  end.setValue(new Date());
  p.add(start);
  Label l=new Label(""String_Node_Str"");
  l.setStyleName(""String_Node_Str"");
  p.add(l);
  p.add(end);
  final Label value=new Label();
  p.add(value);
  HorizontalPanel h2=new HorizontalPanel();
  v.add(h2);
  h2.add(new Button(""String_Node_Str"",new ClickHandler(){
    public void onClick(    ClickEvent event){
      updateFormat(start,end,DateTimeFormat.getShortDateFormat());
    }
  }
));
  h2.add(new Button(""String_Node_Str"",new ClickHandler(){
    public void onClick(    ClickEvent event){
      updateFormat(start,end,DateTimeFormat.getMediumDateFormat());
    }
  }
));
  h2.add(new Button(""String_Node_Str"",new ClickHandler(){
    public void onClick(    ClickEvent sender){
      start.setValue(null);
      end.setValue(null);
    }
  }
));
  h2.add(new Button(""String_Node_Str"",new ClickHandler(){
    public void onClick(    ClickEvent event){
      DateTimeFormat f=DateTimeFormat.getShortDateFormat();
      Date d1=start.getValue();
      Date d2=end.getValue();
      value.setText(""String_Node_Str"" + (d1 == null ? ""String_Node_Str"" : f.format(d1)) + ""String_Node_Str""+ (d2 == null ? ""String_Node_Str"" : f.format(d2))+ ""String_Node_Str"");
    }
  }
));
  return v;
}","private Widget dateRange(){
  VerticalPanel v=new VerticalPanel();
  HorizontalPanel p=new HorizontalPanel();
  v.add(p);
  final DateBox start=new DateBox(new DatePicker(),null,new FormatWithNewYearsEve());
  start.setWidth(""String_Node_Str"");
  final DateBox end=new DateBox();
  end.setWidth(""String_Node_Str"");
  end.getDatePicker().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      start.removeStyleName(""String_Node_Str"");
    }
  }
);
  final TextBox startText=start.getTextBox();
  startText.addKeyDownHandler(new KeyDownHandler(){
    public void onKeyDown(    KeyDownEvent e){
      if (e.isRightArrow() && start.getCursorPos() == startText.getText().length()) {
        start.hideDatePicker();
        end.setFocus(true);
      }
    }
  }
);
  end.getTextBox().addKeyDownHandler(new KeyDownHandler(){
    public void onKeyDown(    KeyDownEvent e){
      if ((e.isLeftArrow()) && end.getCursorPos() == 0) {
        end.hideDatePicker();
        start.setFocus(true);
      }
    }
  }
);
  end.setValue(new Date());
  p.add(start);
  Label l=new Label(""String_Node_Str"");
  l.setStyleName(""String_Node_Str"");
  p.add(l);
  p.add(end);
  final Label value=new Label();
  p.add(value);
  HorizontalPanel h2=new HorizontalPanel();
  v.add(h2);
  h2.add(new Button(""String_Node_Str"",new ClickHandler(){
    public void onClick(    ClickEvent event){
      updateFormat(start,end,DateTimeFormat.getShortDateFormat());
    }
  }
));
  h2.add(new Button(""String_Node_Str"",new ClickHandler(){
    public void onClick(    ClickEvent event){
      updateFormat(start,end,DateTimeFormat.getMediumDateFormat());
    }
  }
));
  h2.add(new Button(""String_Node_Str"",new ClickHandler(){
    public void onClick(    ClickEvent sender){
      start.setValue(null);
      end.setValue(null);
    }
  }
));
  h2.add(new Button(""String_Node_Str"",new ClickHandler(){
    public void onClick(    ClickEvent event){
      DateTimeFormat f=DateTimeFormat.getShortDateFormat();
      Date d1=start.getValue();
      Date d2=end.getValue();
      value.setText(""String_Node_Str"" + (d1 == null ? ""String_Node_Str"" : f.format(d1)) + ""String_Node_Str""+ (d2 == null ? ""String_Node_Str"" : f.format(d2))+ ""String_Node_Str"");
    }
  }
));
  EventReporter<Date,DateBox> reporter=new EventReporter<Date,DateBox>();
  start.addValueChangeHandler(reporter);
  end.addValueChangeHandler(reporter);
  reporter.report(""String_Node_Str"");
  v.add(reporter);
  return v;
}",0.9562512958739374
54635,"public void onValueChange(ValueChangeEvent<Date> event){
  setValue(event.getValue());
  hideDatePicker();
  preventDatePickerPopup();
  box.setFocus(true);
}","public void onValueChange(ValueChangeEvent<Date> event){
  setValue(parseDate(false),event.getValue(),true);
  hideDatePicker();
  preventDatePickerPopup();
  box.setFocus(true);
}",0.9349112426035504
54636,"private void updateDateFromTextBox(){
  Date parsedDate=parseDate(true);
  if (parsedDate != null) {
    setValue(parsedDate);
  }
}","private void updateDateFromTextBox(){
  Date parsedDate=parseDate(true);
  if (parsedDate != null) {
    setValue(picker.getValue(),parsedDate,true);
  }
}",0.9198606271777005
54637,"public void setValue(Date date,boolean fireEvents){
  Date oldDate=parseDate(false);
  if (date != null) {
    picker.setCurrentMonth(date);
  }
  picker.setValue(date,false);
  setDate(date);
  if (fireEvents) {
    DateChangeEvent.fireIfNotEqualDates(this,oldDate,date);
  }
}","private void setValue(Date oldDate,Date date,boolean fireEvents){
  if (date != null) {
    picker.setCurrentMonth(date);
  }
  picker.setValue(date,false);
  format.reset(this,false);
  box.setText(getFormat().format(this,date));
  if (fireEvents) {
    DateChangeEvent.fireIfNotEqualDates(this,oldDate,date);
  }
}",0.6835016835016835
54638,"public void testValueChangeEvent(){
  DateBox db=new DateBox();
  RootPanel.get().add(db);
  new DateValueChangeTester(db).run();
}","public void testValueChangeEvent(){
  DateBox db=new DateBox();
  RootPanel.get().add(db);
  new DateValueChangeTester(db).run();
  final DateBox db2=new DateBox();
  RootPanel.get().add(db2);
  new DateValueChangeTester(db2){
    @Override protected void fire(    java.util.Date d){
      db2.getTextBox().setText(d.toString());
      NativeEvent e=Document.get().createBlurEvent();
      db2.getTextBox().getElement().dispatchEvent(e);
    }
  }
.run();
  final DateBox db3=new DateBox();
  RootPanel.get().add(db3);
  new DateValueChangeTester(db3){
    @Override protected void fire(    java.util.Date d){
      db3.getDatePicker().setValue(d,true);
    }
  }
.run();
}",0.3258706467661691
54639,"/** 
 * Asserts that the default value is null, checks that value change events do and don't fire when appropriate, and that getValue() always returns what was handed to getValue().
 */
@SuppressWarnings(""String_Node_Str"") public void run(){
  TestCase.assertNull(subject.getValue());
  DateValueChangeTester.Handler h=new Handler();
  subject.addValueChangeHandler(h);
  subject.setValue(null);
  TestCase.assertNull(subject.getValue());
  TestCase.assertNull(h.received);
  Date able=new Date(1999,5,15);
  subject.setValue(able);
  TestCase.assertEquals(able,subject.getValue());
  TestCase.assertNull(h.received);
  subject.setValue(able);
  TestCase.assertNull(h.received);
  Date baker=new Date(1965,12,7);
  subject.setValue(baker);
  TestCase.assertNull(h.received);
  subject.setValue(baker,true);
  TestCase.assertNull(h.received);
  subject.setValue(able,true);
  TestCase.assertEquals(able,h.received);
  TestCase.assertNotSame(able,h.received);
  subject.setValue(baker,true);
  TestCase.assertEquals(baker,h.received);
  TestCase.assertNotSame(baker,h.received);
  h.received=null;
  subject.setValue(baker,false);
  TestCase.assertNull(h.received);
}","/** 
 * Asserts that the default value is null, checks that value change events do and don't fire when appropriate, and that getValue() always returns what was handed to getValue().
 */
@SuppressWarnings(""String_Node_Str"") public void run(){
  TestCase.assertNull(subject.getValue());
  DateValueChangeTester.Handler h=new Handler();
  subject.addValueChangeHandler(h);
  subject.setValue(null);
  TestCase.assertNull(subject.getValue());
  TestCase.assertNull(h.received);
  Date able=new Date(1999,5,15);
  subject.setValue(able);
  TestCase.assertEquals(able,subject.getValue());
  TestCase.assertNull(h.received);
  subject.setValue(able);
  TestCase.assertNull(h.received);
  Date baker=new Date(1965,12,7);
  subject.setValue(baker);
  TestCase.assertNull(h.received);
  fire(baker);
  TestCase.assertNull(h.received);
  fire(able);
  TestCase.assertEquals(able,h.received);
  TestCase.assertNotSame(able,h.received);
  fire(baker);
  TestCase.assertEquals(baker,h.received);
  TestCase.assertNotSame(baker,h.received);
  h.received=null;
  subject.setValue(baker,false);
  TestCase.assertNull(h.received);
}",0.9653356735410268
54640,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(AnchorTest.class);
  suite.addTestSuite(ButtonTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(DateBoxTest.class);
  suite.addTestSuite(DatePickerTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratedPopupTest.class);
  suite.addTestSuite(DecoratedStackPanelTest.class);
  suite.addTestSuite(DecoratedTabBarTest.class);
  suite.addTestSuite(DecoratedTabPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(DOMRtlTest.class);
  suite.addTestSuite(ElementWrappingTest.class);
  suite.addTestSuite(EventTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HistoryTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LazyPanelTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SimpleCheckBoxTest.class);
  suite.addTestSuite(SimpleRadioButtonTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(SuggestBoxTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WidgetSubclassingTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  suite.addTestSuite(ClassInitTest.class);
  suite.addTestSuite(DateChangeEventTest.class);
  suite.addTestSuite(CreateEventTest.class);
  suite.addTestSuite(WidgetTest.class);
  return suite;
}",0.9937616968184654
54641,"/** 
 * Sets whether this list allows multiple selections. <em>NOTE: The preferred way of enabling multiple selections in a list box is by using the  {@link #ListBox(boolean)} constructor. Using this method can spuriouslyfail on Internet Explorer 6.0.</em>
 * @param multiple <code>true</code> to allow multiple selections
 */
public void setMultipleSelect(boolean multiple){
  getSelectElement().setMultiple(multiple);
}","/** 
 * Sets whether this list allows multiple selections. <em>NOTE: The preferred way of enabling multiple selections in a list box is by using the  {@link #ListBox(boolean)} constructor. Using this method can spuriouslyfail on Internet Explorer 6.0.</em>
 * @param multiple <code>true</code> to allow multiple selections
 * @deprecated use {@link #ListBox(boolean) instead}
 */
@Deprecated public void setMultipleSelect(boolean multiple){
  getSelectElement().setMultiple(multiple);
}",0.928335170893054
54642,"/** 
 * Validates the given module can be compiled.
 * @param logger a logger to use
 * @param jjsOptions a set of compiler options
 * @param module the module to compile
 * @param genDir optional directory to dump generated source, may be<code>null</code>
 * @param generatorResourcesDir required directory to dump generator resources
 */
public static boolean validate(TreeLogger logger,JJSOptions jjsOptions,ModuleDef module,File genDir,File generatorResourcesDir){
  try {
    CompilationState compilationState=module.getCompilationState(logger);
    String[] declEntryPts=module.getEntryPointTypeNames();
    if (declEntryPts.length == 0) {
      Set<CompilationUnit> compilationUnits=compilationState.getCompilationUnits();
      declEntryPts=new String[compilationUnits.size()];
      int i=0;
      for (      CompilationUnit unit : compilationUnits) {
        declEntryPts[i++]=unit.getTypeName();
      }
    }
    ArtifactSet generatorArtifacts=new ArtifactSet();
    DistillerRebindPermutationOracle rpo=new DistillerRebindPermutationOracle(module,compilationState,generatorArtifacts,new PropertyPermutations(module.getProperties()),genDir,generatorResourcesDir);
    WebModeCompilerFrontEnd frontEnd=new WebModeCompilerFrontEnd(compilationState,rpo);
    JavaToJavaScriptCompiler.precompile(logger,frontEnd,declEntryPts,jjsOptions,true);
    return true;
  }
 catch (  UnableToCompleteException e) {
    return false;
  }
}","/** 
 * Validates the given module can be compiled.
 * @param logger a logger to use
 * @param jjsOptions a set of compiler options
 * @param module the module to compile
 * @param genDir optional directory to dump generated source, may be<code>null</code>
 * @param generatorResourcesDir required directory to dump generator resources
 */
public static boolean validate(TreeLogger logger,JJSOptions jjsOptions,ModuleDef module,File genDir,File generatorResourcesDir){
  try {
    CompilationState compilationState=module.getCompilationState(logger);
    String[] declEntryPts=module.getEntryPointTypeNames();
    String[] additionalRootTypes=null;
    if (declEntryPts.length == 0) {
      Set<CompilationUnit> compilationUnits=compilationState.getCompilationUnits();
      additionalRootTypes=new String[compilationUnits.size()];
      int i=0;
      for (      CompilationUnit unit : compilationUnits) {
        additionalRootTypes[i++]=unit.getTypeName();
      }
    }
    ArtifactSet generatorArtifacts=new ArtifactSet();
    DistillerRebindPermutationOracle rpo=new DistillerRebindPermutationOracle(module,compilationState,generatorArtifacts,new PropertyPermutations(module.getProperties()),genDir,generatorResourcesDir);
    WebModeCompilerFrontEnd frontEnd=new WebModeCompilerFrontEnd(compilationState,rpo);
    JavaToJavaScriptCompiler.precompile(logger,frontEnd,declEntryPts,additionalRootTypes,jjsOptions,true);
    return true;
  }
 catch (  UnableToCompleteException e) {
    return false;
  }
}",0.9616298811544992
54643,"/** 
 * Precompiles the given module.
 * @param logger a logger to use
 * @param jjsOptions a set of compiler options
 * @param module the module to compile
 * @param genDir optional directory to dump generated source, may be<code>null</code>
 * @param generatorResourcesDir required directory to dump generator resources
 * @return the precompilation
 */
public static Precompilation precompile(TreeLogger logger,JJSOptions jjsOptions,ModuleDef module,File genDir,File generatorResourcesDir){
  try {
    CompilationState compilationState=module.getCompilationState(logger);
    String[] declEntryPts=module.getEntryPointTypeNames();
    if (declEntryPts.length == 0) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",null);
      throw new UnableToCompleteException();
    }
    ArtifactSet generatedArtifacts=new ArtifactSet();
    DistillerRebindPermutationOracle rpo=new DistillerRebindPermutationOracle(module,compilationState,generatedArtifacts,new PropertyPermutations(module.getProperties()),genDir,generatorResourcesDir);
    WebModeCompilerFrontEnd frontEnd=new WebModeCompilerFrontEnd(compilationState,rpo);
    PerfLogger.start(""String_Node_Str"");
    UnifiedAst unifiedAst=JavaToJavaScriptCompiler.precompile(logger,frontEnd,declEntryPts,jjsOptions,rpo.getPermuationCount() == 1);
    PerfLogger.end();
    Permutation[] permutations=rpo.getPermutations();
    SortedMap<String,Permutation> merged=new TreeMap<String,Permutation>();
    for (    Permutation permutation : permutations) {
      permutation.reduceRebindAnswers(unifiedAst.getRebindRequests());
      String rebindResultsString=permutation.getRebindAnswers().toString();
      if (merged.containsKey(rebindResultsString)) {
        Permutation existing=merged.get(rebindResultsString);
        existing.mergeFrom(permutation);
      }
 else {
        merged.put(rebindResultsString,permutation);
      }
    }
    return new Precompilation(unifiedAst,merged.values(),generatedArtifacts);
  }
 catch (  UnableToCompleteException e) {
    return null;
  }
}","/** 
 * Precompiles the given module.
 * @param logger a logger to use
 * @param jjsOptions a set of compiler options
 * @param module the module to compile
 * @param genDir optional directory to dump generated source, may be<code>null</code>
 * @param generatorResourcesDir required directory to dump generator resources
 * @return the precompilation
 */
public static Precompilation precompile(TreeLogger logger,JJSOptions jjsOptions,ModuleDef module,File genDir,File generatorResourcesDir){
  try {
    CompilationState compilationState=module.getCompilationState(logger);
    String[] declEntryPts=module.getEntryPointTypeNames();
    if (declEntryPts.length == 0) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",null);
      throw new UnableToCompleteException();
    }
    ArtifactSet generatedArtifacts=new ArtifactSet();
    DistillerRebindPermutationOracle rpo=new DistillerRebindPermutationOracle(module,compilationState,generatedArtifacts,new PropertyPermutations(module.getProperties()),genDir,generatorResourcesDir);
    WebModeCompilerFrontEnd frontEnd=new WebModeCompilerFrontEnd(compilationState,rpo);
    PerfLogger.start(""String_Node_Str"");
    UnifiedAst unifiedAst=JavaToJavaScriptCompiler.precompile(logger,frontEnd,declEntryPts,null,jjsOptions,rpo.getPermuationCount() == 1);
    PerfLogger.end();
    Permutation[] permutations=rpo.getPermutations();
    SortedMap<String,Permutation> merged=new TreeMap<String,Permutation>();
    for (    Permutation permutation : permutations) {
      permutation.reduceRebindAnswers(unifiedAst.getRebindRequests());
      String rebindResultsString=permutation.getRebindAnswers().toString();
      if (merged.containsKey(rebindResultsString)) {
        Permutation existing=merged.get(rebindResultsString);
        existing.mergeFrom(permutation);
      }
 else {
        merged.put(rebindResultsString,permutation);
      }
    }
    return new Precompilation(unifiedAst,merged.values(),generatedArtifacts);
  }
 catch (  UnableToCompleteException e) {
    return null;
  }
}",0.9987742093650404
54644,"/** 
 * Pull in types implicitly referenced through rebind answers.
 */
protected String[] doFindAdditionalTypesUsingRebinds(TreeLogger logger,CompilationUnitDeclaration cud){
  Set<String> dependentTypeNames=new HashSet<String>();
  FindDeferredBindingSitesVisitor v=new FindDeferredBindingSitesVisitor();
  cud.traverse(v,cud.scope);
  Map<String,DeferredBindingSite> requestedTypes=v.getSites();
  for (  String reqType : requestedTypes.keySet()) {
    DeferredBindingSite site=requestedTypes.get(reqType);
    try {
      String[] resultTypes=rebindPermOracle.getAllPossibleRebindAnswers(logger,reqType);
      for (int i=0; i < resultTypes.length; ++i) {
        String typeName=resultTypes[i];
        ReferenceBinding type=resolvePossiblyNestedType(typeName);
        if (type == null) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (!type.isClass()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isAbstract()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isNestedType() && !type.isStatic()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isLocalType()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        MethodBinding noArgCtor=type.getExactMethod(""String_Node_Str"".toCharArray(),TypeBinding.NO_PARAMETERS,cud.scope);
        if (noArgCtor == null) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        dependentTypeNames.add(typeName);
      }
      Util.addAll(dependentTypeNames,resultTypes);
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + reqType + ""String_Node_Str"");
    }
  }
  return dependentTypeNames.toArray(Empty.STRINGS);
}","/** 
 * Pull in types implicitly referenced through rebind answers.
 */
protected String[] doFindAdditionalTypesUsingRebinds(TreeLogger logger,CompilationUnitDeclaration cud){
  Set<String> dependentTypeNames=new HashSet<String>();
  FindDeferredBindingSitesVisitor v=new FindDeferredBindingSitesVisitor();
  cud.traverse(v,cud.scope);
  Map<String,DeferredBindingSite> requestedTypes=v.getSites();
  for (  String reqType : requestedTypes.keySet()) {
    DeferredBindingSite site=requestedTypes.get(reqType);
    try {
      String[] resultTypes=rebindPermOracle.getAllPossibleRebindAnswers(logger,reqType);
      for (int i=0; i < resultTypes.length; ++i) {
        String typeName=resultTypes[i];
        ReferenceBinding type=resolvePossiblyNestedType(typeName);
        if (type == null) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (!type.isClass()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isAbstract()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isNestedType() && !type.isStatic()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        if (type.isLocalType()) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        MethodBinding noArgCtor=type.getExactMethod(""String_Node_Str"".toCharArray(),TypeBinding.NO_PARAMETERS,cud.scope);
        if (noArgCtor == null) {
          FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + typeName + ""String_Node_Str"");
          continue;
        }
        dependentTypeNames.add(typeName);
      }
      Collections.addAll(dependentTypeNames,resultTypes);
    }
 catch (    UnableToCompleteException e) {
      FindDeferredBindingSitesVisitor.reportRebindProblem(site,""String_Node_Str"" + reqType + ""String_Node_Str"");
    }
  }
  return dependentTypeNames.toArray(Empty.STRINGS);
}",0.9967679379444084
54645,"/** 
 * Performs a precompilation, returning a unified AST.
 * @param logger the logger to use
 * @param compilerFrontEnd the compiler front ent
 * @param declEntryPts the set of entry classes
 * @param options the compiler options
 * @param singlePermutation if true, do not pre-optimize the resulting AST orallow serialization of the result
 * @return the unified AST used to drive permutation compiles
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static UnifiedAst precompile(TreeLogger logger,WebModeCompilerFrontEnd compilerFrontEnd,String[] declEntryPts,JJSOptions options,boolean singlePermutation) throws UnableToCompleteException {
  if (declEntryPts.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  RebindPermutationOracle rpo=compilerFrontEnd.getRebindPermutationOracle();
  Set<String> allEntryPoints=new TreeSet<String>();
  for (  String element : declEntryPts) {
    String[] all=rpo.getAllPossibleRebindAnswers(logger,element);
    Util.addAll(allEntryPoints,all);
  }
  allEntryPoints.addAll(JProgram.CODEGEN_TYPES_SET);
  allEntryPoints.addAll(JProgram.INDEX_TYPES_SET);
  CompilationUnitDeclaration[] goldenCuds=compilerFrontEnd.getCompilationUnitDeclarations(logger,allEntryPoints.toArray(new String[0]));
  checkForErrors(logger,goldenCuds,false);
  PerfLogger.start(""String_Node_Str"");
  JProgram jprogram=new JProgram();
  JsProgram jsProgram=new JsProgram();
  try {
    TypeMap typeMap=new TypeMap(jprogram);
    TypeDeclaration[] allTypeDeclarations=BuildTypeMap.exec(typeMap,goldenCuds,jsProgram);
    checkForErrors(logger,goldenCuds,true);
    jprogram.typeOracle.computeBeforeAST();
    GenerateJavaAST.exec(allTypeDeclarations,typeMap,jprogram,jsProgram,options.isEnableAssertions());
    checkForErrors(logger,goldenCuds,true);
    goldenCuds=null;
    typeMap=null;
    allTypeDeclarations=null;
    FixAssignmentToUnbox.exec(jprogram);
    if (options.isEnableAssertions()) {
      AssertionNormalizer.exec(jprogram);
    }
 else {
      AssertionRemover.exec(jprogram);
    }
    ReplaceRebinds.exec(logger,jprogram,rpo);
    findEntryPoints(logger,rpo,declEntryPts,jprogram);
    JavaScriptObjectNormalizer.exec(jprogram);
    if (!singlePermutation) {
      optimize(options,jprogram);
    }
    Set<String> rebindRequests=new HashSet<String>();
    RecordRebinds.exec(jprogram,rebindRequests);
    return new UnifiedAst(options,new AST(jprogram,jsProgram),singlePermutation,rebindRequests);
  }
 catch (  Throwable e) {
    throw logAndTranslateException(logger,e);
  }
 finally {
    PerfLogger.end();
  }
}","/** 
 * Performs a precompilation, returning a unified AST.
 * @param logger the logger to use
 * @param compilerFrontEnd the compiler front ent
 * @param declEntryPts the set of entry classes declared in a GWT module;these will be automatically rebound
 * @param additionalRootTypes additional classes that should serve as coderoots; will not be rebound; may be <code>null</code>
 * @param options the compiler options
 * @param singlePermutation if true, do not pre-optimize the resulting AST orallow serialization of the result
 * @return the unified AST used to drive permutation compiles
 * @throws UnableToCompleteException if an error other than{@link OutOfMemoryError} occurs
 */
public static UnifiedAst precompile(TreeLogger logger,WebModeCompilerFrontEnd compilerFrontEnd,String[] declEntryPts,String[] additionalRootTypes,JJSOptions options,boolean singlePermutation) throws UnableToCompleteException {
  if (additionalRootTypes == null) {
    additionalRootTypes=Empty.STRINGS;
  }
  if (declEntryPts.length + additionalRootTypes.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  RebindPermutationOracle rpo=compilerFrontEnd.getRebindPermutationOracle();
  Set<String> allRootTypes=new TreeSet<String>();
  for (  String element : declEntryPts) {
    String[] all=rpo.getAllPossibleRebindAnswers(logger,element);
    Collections.addAll(allRootTypes,all);
  }
  Collections.addAll(allRootTypes,additionalRootTypes);
  allRootTypes.addAll(JProgram.CODEGEN_TYPES_SET);
  allRootTypes.addAll(JProgram.INDEX_TYPES_SET);
  CompilationUnitDeclaration[] goldenCuds=compilerFrontEnd.getCompilationUnitDeclarations(logger,allRootTypes.toArray(new String[0]));
  checkForErrors(logger,goldenCuds,false);
  PerfLogger.start(""String_Node_Str"");
  JProgram jprogram=new JProgram();
  JsProgram jsProgram=new JsProgram();
  try {
    TypeMap typeMap=new TypeMap(jprogram);
    TypeDeclaration[] allTypeDeclarations=BuildTypeMap.exec(typeMap,goldenCuds,jsProgram);
    checkForErrors(logger,goldenCuds,true);
    jprogram.typeOracle.computeBeforeAST();
    GenerateJavaAST.exec(allTypeDeclarations,typeMap,jprogram,jsProgram,options.isEnableAssertions());
    checkForErrors(logger,goldenCuds,true);
    goldenCuds=null;
    typeMap=null;
    allTypeDeclarations=null;
    FixAssignmentToUnbox.exec(jprogram);
    if (options.isEnableAssertions()) {
      AssertionNormalizer.exec(jprogram);
    }
 else {
      AssertionRemover.exec(jprogram);
    }
    ReplaceRebinds.exec(logger,jprogram,rpo);
    findEntryPoints(logger,rpo,declEntryPts,jprogram);
    JavaScriptObjectNormalizer.exec(jprogram);
    if (!singlePermutation) {
      optimize(options,jprogram);
    }
    Set<String> rebindRequests=new HashSet<String>();
    RecordRebinds.exec(jprogram,rebindRequests);
    return new UnifiedAst(options,new AST(jprogram,jsProgram),singlePermutation,rebindRequests);
  }
 catch (  Throwable e) {
    throw logAndTranslateException(logger,e);
  }
 finally {
    PerfLogger.end();
  }
}",0.9059677704976092
54646,"private void generateOnLoadMethod(PrintWriter srcWriter){
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(""String_Node_Str"" + getLoaderSimpleName() + ""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
}","private void generateOnLoadMethod(PrintWriter srcWriter){
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(""String_Node_Str"" + getLoaderSimpleName() + ""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
  srcWriter.println(ASYNC_FRAGMENT_LOADER + ""String_Node_Str"" + entryNumber+ ""String_Node_Str"");
  srcWriter.println(""String_Node_Str"");
}",0.6837763519706691
54647,"/** 
 * Create an event object suitable for submitting to the lightweight metrics framework.
 */
private static native JavaScriptObject createStatsEvent(String eventGroup,String type);","private static native JavaScriptObject createStatsEvent(String eventGroup,String type,Integer fragment,Integer size);",0.5780730897009967
54648,"/** 
 * Logs an event with the GWT lightweight metrics framework.
 */
public static void logEventProgress(String eventGroup,String type){
  @SuppressWarnings(""String_Node_Str"") boolean toss=isStatsAvailable() && stats(createStatsEvent(eventGroup,type));
}","/** 
 * Log an event with the lightweight metrics framework. The <code>fragment</code> and <code>size</code> objects are allowed to be <code>null</code>.
 */
private static void logEventProgress(String eventGroup,String type,Integer fragment,Integer size){
  @SuppressWarnings(""String_Node_Str"") boolean toss=isStatsAvailable() && stats(createStatsEvent(eventGroup,type,fragment,size));
}",0.6220839813374806
54649,"/** 
 * Inform the loader that the ""leftovers"" fragment has loaded.
 */
public static void leftoversFragmentHasLoaded(){
  leftoversLoaded=true;
  leftoversLoading=false;
  while (!waitingForLeftovers.isEmpty()) {
    inject(waitingForLeftovers.remove());
  }
}","/** 
 * Inform the loader that the ""leftovers"" fragment has loaded.
 */
public static void leftoversFragmentHasLoaded(){
  leftoversLoaded=true;
  leftoversLoading=false;
  logEventProgress(LwmLabels.LEFTOVERS_DOWNLOAD,LwmLabels.END,leftoversFragmentNumber(),null);
  while (!waitingForLeftovers.isEmpty()) {
    inject(waitingForLeftovers.remove());
  }
}",0.8460291734197731
54650,"/** 
 * Inform the loader that the code for an entry point has now finished loading.
 * @param entry The entry whose code fragment is now loaded.
 */
public static void fragmentHasLoaded(int entry){
  if (base < 0) {
    base=entry;
    baseLoading=false;
    leftoversLoading=true;
    startLoadingFragment(numEntries + 2 * (entry - 1) + 1);
  }
}","/** 
 * Inform the loader that the code for an entry point has now finished loading.
 * @param entry The entry whose code fragment is now loaded.
 */
public static void fragmentHasLoaded(int entry){
  int fragment=base >= 0 ? entry : baseFragmentNumber(entry);
  logEventProgress(LwmLabels.downloadGroup(entry),LwmLabels.END,fragment,null);
  if (base < 0) {
    base=entry;
    baseLoading=false;
    leftoversLoading=true;
    logEventProgress(LwmLabels.LEFTOVERS_DOWNLOAD,LwmLabels.BEGIN,leftoversFragmentNumber(),null);
    startLoadingFragment(leftoversFragmentNumber());
  }
}",0.6387096774193548
54651,"/** 
 * Loads the specified split point.
 * @param splitPoint the fragment to load
 */
public static void inject(int splitPoint){
  if (leftoversLoaded) {
    startLoadingFragment(splitPoint);
    return;
  }
  if (baseLoading || leftoversLoading) {
    waitingForLeftovers.add(splitPoint);
    return;
  }
  baseLoading=true;
  startLoadingFragment(numEntries + 2 * (splitPoint - 1));
}","/** 
 * Loads the specified split point.
 * @param splitPoint the fragment to load
 */
public static void inject(int splitPoint){
  if (leftoversLoaded) {
    logEventProgress(LwmLabels.downloadGroup(splitPoint),LwmLabels.BEGIN,splitPoint,null);
    startLoadingFragment(splitPoint);
    return;
  }
  if (baseLoading || leftoversLoading) {
    waitingForLeftovers.add(splitPoint);
    return;
  }
  baseLoading=true;
  logEventProgress(LwmLabels.downloadGroup(splitPoint),LwmLabels.BEGIN,baseFragmentNumber(splitPoint),null);
  startLoadingFragment(baseFragmentNumber(splitPoint));
}",0.7044284243048403
54652,"private static void startLoadingFragment(int fragment){
  logEventProgress(""String_Node_Str"" + fragment,""String_Node_Str"");
  gwtStartLoadingFragment(fragment);
}","private static void startLoadingFragment(int fragment){
  gwtStartLoadingFragment(fragment);
}",0.734375
54653,"private static void fireResizedImpl(){
  if (resizeHandlersInitialized) {
    ResizeEvent.fire(getHandlers(),getClientWidth(),getClientHeight());
  }
}","private static void fireResizedImpl(){
  if (resizeHandlersInitialized) {
    int width=getClientWidth();
    int height=getClientHeight();
    if (lastResizeWidth != width || lastResizeHeight != height) {
      lastResizeWidth=width;
      lastResizeHeight=height;
      ResizeEvent.fire(getHandlers(),width,height);
    }
  }
}",0.4791666666666667
54654,"/** 
 * Shows the popup and attach it to the page. It must have a child widget before this method is called.
 */
public void show(){
  if (showing) {
    return;
  }
  showing=true;
  nativePreviewHandlerRegistration=Event.addNativePreviewHandler(new NativePreviewHandler(){
    public void onPreviewNativeEvent(    NativePreviewEvent event){
      previewNativeEvent(event);
    }
  }
);
  resizeAnimation.setState(true);
}","/** 
 * Shows the popup and attach it to the page. It must have a child widget before this method is called.
 */
public void show(){
  if (showing) {
    return;
  }
  setState(true,true);
}",0.6026058631921825
54655,"@Override protected void onUnload(){
  cleanup();
}","@Override protected void onUnload(){
  if (isShowing()) {
    setState(false,false);
  }
}",0.6524822695035462
54656,"/** 
 * Hides the popup and detaches it from the page. This has no effect if it is not currently showing.
 * @param autoClosed the value that will be passed to{@link CloseHandler#onClose(CloseEvent)} when the popup is closed
 */
public void hide(boolean autoClosed){
  if (!isShowing()) {
    return;
  }
  cleanup();
  resizeAnimation.setState(false);
  CloseEvent.fire(this,this,autoClosed);
}","/** 
 * Hides the popup and detaches it from the page. This has no effect if it is not currently showing.
 * @param autoClosed the value that will be passed to{@link CloseHandler#onClose(CloseEvent)} when the popup is closed
 */
public void hide(boolean autoClosed){
  if (!isShowing()) {
    return;
  }
  setState(false,true);
  CloseEvent.fire(this,this,autoClosed);
}",0.9556135770234988
54657,"/** 
 * Open or close the content. This method always called immediately after the PopupPanel showing state has changed, so we base the animation on the current state.
 * @param showing true if the popup is showing, false if not
 */
public void setState(boolean showing){
  cancel();
  boolean animate=curPanel.isAnimationEnabled;
  if (curPanel.animType != AnimationType.CENTER && !showing) {
    animate=false;
  }
  this.showing=showing;
  if (animate) {
    if (showing) {
      DOM.setStyleAttribute(curPanel.getElement(),""String_Node_Str"",""String_Node_Str"");
      if (curPanel.topPosition != -1) {
        curPanel.setPopupPosition(curPanel.leftPosition,curPanel.topPosition);
      }
      impl.setClip(curPanel.getElement(),getRectString(0,0,0,0));
      RootPanel.get().add(curPanel);
      impl.onShow(curPanel.getElement());
    }
    DeferredCommand.addCommand(new Command(){
      public void execute(){
        run(ANIMATION_DURATION);
      }
    }
);
  }
 else {
    onInstantaneousRun();
  }
}","/** 
 * Set the showing state of the popup. If maybeAnimate is true, the animation will be used to set the state. If it is false, the animation will be cancelled.
 * @param showing the new state
 * @param maybeAnimate true to possibly run the animation
 */
private void setState(boolean showing,boolean maybeAnimate){
  if (maybeAnimate) {
    resizeAnimation.setState(showing);
  }
 else {
    resizeAnimation.cancel();
  }
  this.showing=showing;
  if (showing) {
    nativePreviewHandlerRegistration=Event.addNativePreviewHandler(new NativePreviewHandler(){
      public void onPreviewNativeEvent(      NativePreviewEvent event){
        previewNativeEvent(event);
      }
    }
);
  }
 else   if (nativePreviewHandlerRegistration != null) {
    nativePreviewHandlerRegistration.removeHandler();
    nativePreviewHandlerRegistration=null;
  }
}",0.0678148546824542
54658,"protected void onPreviewNativeEvent(NativePreviewEvent event){
  if (event.isFirstHandler() && !onEventPreview(Event.as(event.getNativeEvent()))) {
    event.cancel();
  }
}","public void onPreviewNativeEvent(NativePreviewEvent event){
  previewNativeEvent(event);
}",0.6463878326996197
54659,"public static int deepHashCode(Object[] a){
  if (a == null) {
    return 0;
  }
  int hashCode=1;
  for (int i=0, n=a.length; i < n; ++i) {
    Object obj=a[i];
    int hash;
    if (obj instanceof Object[]) {
      hash=deepHashCode((Object[])obj);
    }
 else     if (obj instanceof boolean[]) {
      hash=hashCode((boolean[])obj);
    }
 else     if (obj instanceof byte[]) {
      hash=hashCode((byte[])obj);
    }
 else     if (obj instanceof char[]) {
      hash=hashCode((char[])obj);
    }
 else     if (obj instanceof short[]) {
      hash=hashCode((short[])obj);
    }
 else     if (obj instanceof int[]) {
      hash=hashCode((int[])obj);
    }
 else     if (obj instanceof long[]) {
      hash=hashCode((long[])obj);
    }
 else     if (obj instanceof float[]) {
      hash=hashCode((float[])obj);
    }
 else     if (obj instanceof double[]) {
      hash=hashCode((double[])obj);
    }
 else {
      hash=obj.hashCode();
    }
    hashCode=(31 * hashCode + hash) | 0;
  }
  return hashCode;
}","public static int deepHashCode(Object[] a){
  if (a == null) {
    return 0;
  }
  int hashCode=1;
  for (int i=0, n=a.length; i < n; ++i) {
    Object obj=a[i];
    int hash;
    if (obj instanceof Object[]) {
      hash=deepHashCode((Object[])obj);
    }
 else     if (obj instanceof boolean[]) {
      hash=hashCode((boolean[])obj);
    }
 else     if (obj instanceof byte[]) {
      hash=hashCode((byte[])obj);
    }
 else     if (obj instanceof char[]) {
      hash=hashCode((char[])obj);
    }
 else     if (obj instanceof short[]) {
      hash=hashCode((short[])obj);
    }
 else     if (obj instanceof int[]) {
      hash=hashCode((int[])obj);
    }
 else     if (obj instanceof long[]) {
      hash=hashCode((long[])obj);
    }
 else     if (obj instanceof float[]) {
      hash=hashCode((float[])obj);
    }
 else     if (obj instanceof double[]) {
      hash=hashCode((double[])obj);
    }
 else     if (obj != null) {
      hash=obj.hashCode();
    }
 else {
      hash=0;
    }
    hashCode=(31 * hashCode + hash) | 0;
  }
  return hashCode;
}",0.9762481822588464
54660,"/** 
 * Checks or unchecks the text box, firing   {@link ValueChangeEvent} ifappropriate. <p> Note that this <em>does not</em> set the value property of the checkbox input element wrapped by this widget. For access to that property, see {@link #setFormValue(String)}
 * @param value true to check, false to uncheck. Must not be null.
 * @param fireEvents If true, and value has changed, fire a{@link ValueChangeEvent}
 * @thows IllegalArgumentException if value is null
 */
public void setValue(Boolean value,boolean fireEvents){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (value.equals(getValue())) {
    return;
  }
  inputElem.setChecked(value);
  inputElem.setDefaultChecked(value);
  if (fireEvents) {
    ValueChangeEvent.fire(this,value);
  }
}","/** 
 * Checks or unchecks the text box, firing   {@link ValueChangeEvent} ifappropriate. <p> Note that this <em>does not</em> set the value property of the checkbox input element wrapped by this widget. For access to that property, see {@link #setFormValue(String)}
 * @param value true to check, false to uncheck. Must not be null.
 * @param fireEvents If true, and value has changed, fire a{@link ValueChangeEvent}
 * @thows IllegalArgumentException if value is null
 */
public void setValue(Boolean value,boolean fireEvents){
  if (value == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Boolean oldValue=getValue();
  inputElem.setChecked(value);
  inputElem.setDefaultChecked(value);
  if (value.equals(oldValue)) {
    return;
  }
  if (fireEvents) {
    ValueChangeEvent.fire(this,value);
  }
}",0.8223724646588814
54661,"public boolean run(TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  boolean tempWorkDir=false;
  try {
    if (options.getWorkDir() == null) {
      options.setWorkDir(Utility.makeTemporaryDirectory(null,""String_Node_Str""));
      tempWorkDir=true;
    }
    for (    String moduleName : options.getModuleNames()) {
      ModuleDef module=ModuleDefLoader.loadFromClassPath(logger,moduleName);
      File compilerWorkDir=options.getCompilerWorkDir(moduleName);
      if (options.isValidateOnly()) {
        if (!Precompile.validate(logger,options,module,options.getGenDir(),compilerWorkDir)) {
          return false;
        }
      }
 else {
        long compileStart=System.currentTimeMillis();
        logger=logger.branch(TreeLogger.INFO,""String_Node_Str"" + moduleName);
        Precompilation precompilation=Precompile.precompile(logger,options,module,options.getGenDir(),compilerWorkDir);
        if (precompilation == null) {
          return false;
        }
        Permutation[] allPerms=precompilation.getPermutations();
        File[] resultFiles=CompilePerms.makeResultFiles(compilerWorkDir,allPerms);
        CompilePerms.compile(logger,precompilation,allPerms,options.getLocalWorkers(),resultFiles);
        Link.link(logger.branch(TreeLogger.INFO,""String_Node_Str"" + options.getWarDir().getPath()),module,precompilation,resultFiles,options.getWarDir(),options.getExtraDir());
        long compileDone=System.currentTimeMillis();
        long delta=compileDone - compileStart;
        logger.log(TreeLogger.INFO,""String_Node_Str"" + String.format(""String_Node_Str"",delta / 1000d) + ""String_Node_Str"");
      }
    }
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    return false;
  }
 finally {
    PerfLogger.end();
    if (tempWorkDir) {
      Util.recursiveDelete(options.getWorkDir(),false);
    }
  }
  return true;
}","public boolean run(TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  boolean tempWorkDir=false;
  try {
    if (options.getWorkDir() == null) {
      options.setWorkDir(Utility.makeTemporaryDirectory(null,""String_Node_Str""));
      tempWorkDir=true;
    }
    for (    String moduleName : options.getModuleNames()) {
      ModuleDef module=ModuleDefLoader.loadFromClassPath(logger,moduleName,true);
      File compilerWorkDir=options.getCompilerWorkDir(moduleName);
      if (options.isValidateOnly()) {
        if (!Precompile.validate(logger,options,module,options.getGenDir(),compilerWorkDir)) {
          return false;
        }
      }
 else {
        long compileStart=System.currentTimeMillis();
        logger=logger.branch(TreeLogger.INFO,""String_Node_Str"" + moduleName);
        Precompilation precompilation=Precompile.precompile(logger,options,module,options.getGenDir(),compilerWorkDir);
        if (precompilation == null) {
          return false;
        }
        Permutation[] allPerms=precompilation.getPermutations();
        File[] resultFiles=CompilePerms.makeResultFiles(compilerWorkDir,allPerms);
        CompilePerms.compile(logger,precompilation,allPerms,options.getLocalWorkers(),resultFiles);
        Link.link(logger.branch(TreeLogger.INFO,""String_Node_Str"" + options.getWarDir().getPath()),module,precompilation,resultFiles,options.getWarDir(),options.getExtraDir());
        long compileDone=System.currentTimeMillis();
        long delta=compileDone - compileStart;
        logger.log(TreeLogger.INFO,""String_Node_Str"" + String.format(""String_Node_Str"",delta / 1000d) + ""String_Node_Str"");
      }
    }
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    return false;
  }
 finally {
    PerfLogger.end();
    if (tempWorkDir) {
      Util.recursiveDelete(options.getWorkDir(),false);
    }
  }
  return true;
}",0.9987002859370938
54662,"private EmbeddedTomcatServer(final TreeLogger topLogger,int listeningPort,final WorkDirs workDirs) throws LifecycleException {
  if (topLogger == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final TreeLogger logger=topLogger.branch(TreeLogger.INFO,""String_Node_Str"" + listeningPort,null);
  startupBranchLogger=logger;
  sTomcat=this;
  File topWorkDir=new File(System.getProperty(""String_Node_Str""));
  String catBase=System.getProperty(""String_Node_Str"");
  if (catBase == null) {
    catBase=generateDefaultCatalinaBase(logger,topWorkDir);
    System.setProperty(""String_Node_Str"",catBase);
  }
  logger.log(TreeLogger.DEBUG,""String_Node_Str"" + catBase,null);
  String adapterClassName=CommonsLoggerAdapter.class.getName();
  System.setProperty(""String_Node_Str"",adapterClassName);
  Logger catalinaLogger=new CatalinaLoggerAdapter(topLogger);
  catEmbedded=new Embedded();
  catEmbedded.setDebug(0);
  catEmbedded.setLogger(catalinaLogger);
  catEngine=catEmbedded.createEngine();
  catEngine.setName(""String_Node_Str"");
  catEngine.setDefaultHost(""String_Node_Str"");
  String appBase=catBase + ""String_Node_Str"";
  catHost=(StandardHost)catEmbedded.createHost(""String_Node_Str"",appBase);
  HostConfig hostConfig=new HostConfig();
  catHost.addLifecycleListener(hostConfig);
  catHost.addContainerListener(new ContainerListener(){
    public void containerEvent(    ContainerEvent event){
      if (StandardHost.PRE_INSTALL_EVENT.equals(event.getType())) {
        StandardContext webapp=(StandardContext)event.getData();
        publishShellLoggerAttribute(logger,topLogger,webapp);
        publishShellWorkDirsAttribute(logger,workDirs,webapp);
      }
    }
  }
);
  catEngine.addChild(catHost);
  catEngine.setDefaultHost(catHost.getName());
  catEmbedded.addEngine(catEngine);
  InetAddress nullAddr=null;
  Connector connector=catEmbedded.createConnector(nullAddr,listeningPort,false);
  catEmbedded.addConnector(connector);
  catEmbedded.start();
  port=computeLocalPort(connector);
  if (port != listeningPort) {
    logger.log(TreeLogger.INFO,""String_Node_Str"" + port,null);
  }
}","private EmbeddedTomcatServer(final TreeLogger topLogger,int listeningPort,final WorkDirs workDirs) throws LifecycleException {
  if (topLogger == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  final TreeLogger logger=topLogger.branch(TreeLogger.INFO,""String_Node_Str"" + listeningPort,null);
  startupBranchLogger=logger;
  sTomcat=this;
  File topWorkDir=new File(System.getProperty(""String_Node_Str""));
  String catBase=System.getProperty(""String_Node_Str"");
  if (catBase == null) {
    catBase=generateDefaultCatalinaBase(logger,topWorkDir);
    System.setProperty(""String_Node_Str"",catBase);
  }
  logger.log(TreeLogger.DEBUG,""String_Node_Str"" + catBase,null);
  String adapterClassName=CommonsLoggerAdapter.class.getName();
  System.setProperty(""String_Node_Str"",adapterClassName);
  Logger catalinaLogger=new CatalinaLoggerAdapter(topLogger);
  catEmbedded=new Embedded();
  catEmbedded.setDebug(0);
  catEmbedded.setLogger(catalinaLogger);
  catEngine=catEmbedded.createEngine();
  catEngine.setName(""String_Node_Str"");
  catEngine.setDefaultHost(""String_Node_Str"");
  catEngine.setParentClassLoader(this.getClass().getClassLoader());
  String appBase=catBase + ""String_Node_Str"";
  catHost=(StandardHost)catEmbedded.createHost(""String_Node_Str"",appBase);
  HostConfig hostConfig=new HostConfig();
  catHost.addLifecycleListener(hostConfig);
  catHost.addContainerListener(new ContainerListener(){
    public void containerEvent(    ContainerEvent event){
      if (StandardHost.PRE_INSTALL_EVENT.equals(event.getType())) {
        StandardContext webapp=(StandardContext)event.getData();
        publishShellLoggerAttribute(logger,topLogger,webapp);
        publishShellWorkDirsAttribute(logger,workDirs,webapp);
      }
    }
  }
);
  catEngine.addChild(catHost);
  catEngine.setDefaultHost(catHost.getName());
  catEmbedded.addEngine(catEngine);
  InetAddress nullAddr=null;
  Connector connector=catEmbedded.createConnector(nullAddr,listeningPort,false);
  catEmbedded.addConnector(connector);
  catEmbedded.start();
  port=computeLocalPort(connector);
  if (port != listeningPort) {
    logger.log(TreeLogger.INFO,""String_Node_Str"" + port,null);
  }
}",0.9841933984193398
54663,"/** 
 * Load the class with the specified name, searching using the following algorithm until it finds and returns the class.  If the class cannot be found, returns <code>ClassNotFoundException</code>. <ul> <li>Call <code>findLoadedClass(String)</code> to check if the class has already been loaded.  If it has, the same <code>Class</code> object is returned.</li> <li>If the <code>delegate</code> property is set to <code>true</code>, call the <code>loadClass()</code> method of the parent class loader, if any.</li> <li>Call <code>findClass()</code> to find this class in our locally defined repositories.</li> <li>Call the <code>loadClass()</code> method of our parent class loader, if any.</li> </ul> If the class was found using the above steps, and the <code>resolve</code> flag is <code>true</code>, this method will then call <code>resolveClass(Class)</code> on the resulting Class object.
 * @param name Name of the class to be loaded
 * @param resolve If <code>true</code> then resolve the class
 * @exception ClassNotFoundException if the class was not found
 */
public Class loadClass(String name,boolean resolve) throws ClassNotFoundException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + name + ""String_Node_Str""+ resolve+ ""String_Node_Str"");
  Class clazz=null;
  if (!started) {
    log.info(sm.getString(""String_Node_Str""));
    throw new ThreadDeath();
  }
  clazz=findLoadedClass0(name);
  if (clazz != null) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    if (resolve)     resolveClass(clazz);
    return (clazz);
  }
  clazz=findLoadedClass(name);
  if (clazz != null) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    if (resolve)     resolveClass(clazz);
    return (clazz);
  }
  try {
    clazz=system.loadClass(name);
    if (clazz != null) {
      if (resolve)       resolveClass(clazz);
      return (clazz);
    }
  }
 catch (  ClassNotFoundException e) {
  }
  if (securityManager != null) {
    int i=name.lastIndexOf('.');
    if (i >= 0) {
      try {
        securityManager.checkPackageAccess(name.substring(0,i));
      }
 catch (      SecurityException se) {
        String error=""String_Node_Str"" + ""String_Node_Str"" + name;
        log.info(error,se);
        throw new ClassNotFoundException(error,se);
      }
    }
  }
  boolean delegateLoad=delegate || filter(name);
  if (delegateLoad) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + parent);
    ClassLoader loader=parent;
    if (loader == null)     loader=system;
    try {
      clazz=loader.loadClass(name);
      if (clazz != null) {
        if (log.isDebugEnabled())         log.debug(""String_Node_Str"");
        if (resolve)         resolveClass(clazz);
        return (clazz);
      }
    }
 catch (    ClassNotFoundException e) {
      ;
    }
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  try {
    clazz=findClass(name);
    if (clazz != null) {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"");
      if (resolve)       resolveClass(clazz);
      return (clazz);
    }
  }
 catch (  ClassNotFoundException e) {
    ;
  }
  if (!delegateLoad) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + parent);
    ClassLoader loader=parent;
    if (loader == null)     loader=system;
    try {
      clazz=loader.loadClass(name);
      if (clazz != null) {
        if (log.isDebugEnabled())         log.debug(""String_Node_Str"");
        if (resolve)         resolveClass(clazz);
        return (clazz);
      }
    }
 catch (    ClassNotFoundException e) {
      ;
    }
  }
  throw new ClassNotFoundException(name);
}","/** 
 * Load the class with the specified name, searching using the following algorithm until it finds and returns the class.  If the class cannot be found, returns <code>ClassNotFoundException</code>. <ul> <li>Call <code>findLoadedClass(String)</code> to check if the class has already been loaded.  If it has, the same <code>Class</code> object is returned.</li> <li>If the <code>delegate</code> property is set to <code>true</code>, call the <code>loadClass()</code> method of the parent class loader, if any.</li> <li>Call <code>findClass()</code> to find this class in our locally defined repositories.</li> <li>Call the <code>loadClass()</code> method of our parent class loader, if any.</li> </ul> If the class was found using the above steps, and the <code>resolve</code> flag is <code>true</code>, this method will then call <code>resolveClass(Class)</code> on the resulting Class object.
 * @param name Name of the class to be loaded
 * @param resolve If <code>true</code> then resolve the class
 * @exception ClassNotFoundException if the class was not found
 */
public Class loadClass(String name,boolean resolve) throws ClassNotFoundException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + name + ""String_Node_Str""+ resolve+ ""String_Node_Str"");
  Class clazz=null;
  if (!started) {
    log.info(sm.getString(""String_Node_Str""));
    throw new ThreadDeath();
  }
  clazz=findLoadedClass0(name);
  if (clazz != null) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    if (resolve)     resolveClass(clazz);
    return (clazz);
  }
  clazz=findLoadedClass(name);
  if (clazz != null) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    if (resolve)     resolveClass(clazz);
    return (clazz);
  }
  try {
    clazz=Class.forName(name,false,null);
    if (clazz != null) {
      if (resolve)       resolveClass(clazz);
      return (clazz);
    }
  }
 catch (  ClassNotFoundException e) {
  }
  if (securityManager != null) {
    int i=name.lastIndexOf('.');
    if (i >= 0) {
      try {
        securityManager.checkPackageAccess(name.substring(0,i));
      }
 catch (      SecurityException se) {
        String error=""String_Node_Str"" + ""String_Node_Str"" + name;
        log.info(error,se);
        throw new ClassNotFoundException(error,se);
      }
    }
  }
  boolean delegateLoad=delegate || filter(name);
  if (delegateLoad) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + parent);
    ClassLoader loader=parent;
    if (loader == null)     loader=system;
    try {
      clazz=loader.loadClass(name);
      if (clazz != null) {
        if (log.isDebugEnabled())         log.debug(""String_Node_Str"");
        if (resolve)         resolveClass(clazz);
        return (clazz);
      }
    }
 catch (    ClassNotFoundException e) {
      ;
    }
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  try {
    clazz=findClass(name);
    if (clazz != null) {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"");
      if (resolve)       resolveClass(clazz);
      return (clazz);
    }
  }
 catch (  ClassNotFoundException e) {
    ;
  }
  if (!delegateLoad) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + parent);
    ClassLoader loader=parent;
    if (loader == null)     loader=system;
    try {
      clazz=loader.loadClass(name);
      if (clazz != null) {
        if (log.isDebugEnabled())         log.debug(""String_Node_Str"");
        if (resolve)         resolveClass(clazz);
        return (clazz);
      }
    }
 catch (    ClassNotFoundException e) {
      ;
    }
  }
  throw new ClassNotFoundException(name);
}",0.9947945205479451
54664,"private void onSelection(TreeItem item,boolean fireEvents,boolean moveFocus){
  if (item == root) {
    return;
  }
  if (curSelection != null) {
    curSelection.setSelected(false);
  }
  curSelection=item;
  if (moveFocus && curSelection != null) {
    moveFocus();
    curSelection.setSelected(true);
    if (fireEvents) {
      SelectionEvent.fire(this,curSelection);
    }
  }
}","private void onSelection(TreeItem item,boolean fireEvents,boolean moveFocus){
  if (item == root) {
    return;
  }
  if (curSelection != null) {
    curSelection.setSelected(false);
  }
  curSelection=item;
  if (curSelection != null) {
    if (moveFocus) {
      moveFocus();
    }
    curSelection.setSelected(true);
    if (fireEvents) {
      SelectionEvent.fire(this,curSelection);
    }
  }
}",0.907928388746803
54665,"private void init(TreeImages images,boolean useLeafImages){
  setImages(images,useLeafImages);
  setElement(DOM.createDiv());
  DOM.setStyleAttribute(getElement(),""String_Node_Str"",""String_Node_Str"");
  DOM.setStyleAttribute(getElement(),""String_Node_Str"",""String_Node_Str"");
  focusable=FocusPanel.impl.createFocusable();
  DOM.setStyleAttribute(focusable,""String_Node_Str"",""String_Node_Str"");
  DOM.setStyleAttribute(focusable,""String_Node_Str"",""String_Node_Str"");
  DOM.setStyleAttribute(focusable,""String_Node_Str"",""String_Node_Str"");
  DOM.setElementAttribute(focusable,""String_Node_Str"",""String_Node_Str"");
  DOM.setIntStyleAttribute(focusable,""String_Node_Str"",-1);
  DOM.appendChild(getElement(),focusable);
  sinkEvents(Event.MOUSEEVENTS | Event.ONCLICK | Event.KEYEVENTS);
  DOM.sinkEvents(focusable,Event.FOCUSEVENTS);
  root=new TreeItem(){
    @Override public void addItem(    TreeItem item){
      if ((item.getParentItem() != null) || (item.getTree() != null)) {
        item.remove();
      }
      DOM.appendChild(Tree.this.getElement(),item.getElement());
      item.setTree(this.getTree());
      item.setParentItem(null);
      getChildren().add(item);
      if (LocaleInfo.getCurrentLocale().isRTL()) {
        DOM.setIntStyleAttribute(item.getElement(),""String_Node_Str"",0);
      }
 else {
        DOM.setIntStyleAttribute(item.getElement(),""String_Node_Str"",0);
      }
    }
    @Override public void removeItem(    TreeItem item){
      if (!getChildren().contains(item)) {
        return;
      }
      item.setTree(null);
      item.setParentItem(null);
      getChildren().remove(item);
      DOM.removeChild(Tree.this.getElement(),item.getElement());
    }
  }
;
  root.initChildren();
  root.setTree(this);
  setStyleName(""String_Node_Str"");
  Accessibility.setRole(getElement(),Accessibility.ROLE_TREE);
  Accessibility.setRole(focusable,Accessibility.ROLE_TREEITEM);
}","private void init(TreeImages images,boolean useLeafImages){
  setImages(images,useLeafImages);
  setElement(DOM.createDiv());
  DOM.setStyleAttribute(getElement(),""String_Node_Str"",""String_Node_Str"");
  DOM.setStyleAttribute(getElement(),""String_Node_Str"",""String_Node_Str"");
  focusable=FocusPanel.impl.createFocusable();
  DOM.setStyleAttribute(focusable,""String_Node_Str"",""String_Node_Str"");
  DOM.setStyleAttribute(focusable,""String_Node_Str"",""String_Node_Str"");
  DOM.setStyleAttribute(focusable,""String_Node_Str"",""String_Node_Str"");
  DOM.setElementAttribute(focusable,""String_Node_Str"",""String_Node_Str"");
  DOM.setIntStyleAttribute(focusable,""String_Node_Str"",-1);
  DOM.appendChild(getElement(),focusable);
  sinkEvents(Event.ONMOUSEDOWN | Event.ONCLICK | Event.KEYEVENTS);
  DOM.sinkEvents(focusable,Event.FOCUSEVENTS);
  root=new TreeItem(){
    @Override public void addItem(    TreeItem item){
      if ((item.getParentItem() != null) || (item.getTree() != null)) {
        item.remove();
      }
      DOM.appendChild(Tree.this.getElement(),item.getElement());
      item.setTree(this.getTree());
      item.setParentItem(null);
      getChildren().add(item);
      if (LocaleInfo.getCurrentLocale().isRTL()) {
        DOM.setIntStyleAttribute(item.getElement(),""String_Node_Str"",0);
      }
 else {
        DOM.setIntStyleAttribute(item.getElement(),""String_Node_Str"",0);
      }
    }
    @Override public void removeItem(    TreeItem item){
      if (!getChildren().contains(item)) {
        return;
      }
      item.setTree(null);
      item.setParentItem(null);
      getChildren().remove(item);
      DOM.removeChild(Tree.this.getElement(),item.getElement());
    }
  }
;
  root.initChildren();
  root.setTree(this);
  setStyleName(""String_Node_Str"");
  Accessibility.setRole(getElement(),Accessibility.ROLE_TREE);
  Accessibility.setRole(focusable,Accessibility.ROLE_TREEITEM);
}",0.996845425867508
54666,"/** 
 * Rescans the associated paths to recompute the available resources.
 * @param logger status and error details are written here
 * @throws UnableToCompleteException
 */
public void refresh(TreeLogger logger){
  TreeLogger refreshBranch=Messages.REFRESHING_RESOURCES.branch(logger,null);
  final Map<String,AbstractResource> newInternalMap=new HashMap<String,AbstractResource>();
  int changeCount=0;
  for (  ClassPathEntry pathRoot : classPath) {
    TreeLogger branchForClassPathEntry=Messages.EXAMINING_PATH_ROOT.branch(refreshBranch,pathRoot.getLocation(),null);
    int prevChangeCount=changeCount;
    Set<AbstractResource> newResources=pathRoot.findApplicableResources(branchForClassPathEntry,pathPrefixSet);
    for (    AbstractResource newResource : newResources) {
      String resourcePath=newResource.getPath();
      if (newInternalMap.containsKey(resourcePath)) {
        Messages.IGNORING_SHADOWED_RESOURCE.log(branchForClassPathEntry,resourcePath,null);
        continue;
      }
      AbstractResource oldResource=internalMap.get(resourcePath);
      if (shouldUseNewResource(branchForClassPathEntry,oldResource,newResource)) {
        newInternalMap.put(resourcePath,newResource);
        ++changeCount;
      }
 else       if (oldResource != null) {
        newInternalMap.put(resourcePath,oldResource);
      }
    }
    if (changeCount == prevChangeCount) {
      Messages.NO_RESOURCES_CHANGED.log(branchForClassPathEntry,null);
    }
  }
  if (changeCount == 0) {
    if (newInternalMap.size() == internalMap.size()) {
      return;
    }
  }
  internalMap=newInternalMap;
  Map<String,Resource> externalMap=rerootResourcePaths(newInternalMap);
  Set<Resource> newResources=new HashSet<Resource>(externalMap.values());
  assert(newResources.size() == externalMap.size());
  exposedResources=Collections.unmodifiableSet(newResources);
  exposedResourceMap=Collections.unmodifiableMap(externalMap);
  exposedPathNames=Collections.unmodifiableSet(externalMap.keySet());
}","/** 
 * Rescans the associated paths to recompute the available resources.
 * @param logger status and error details are written here
 */
public void refresh(TreeLogger logger){
  TreeLogger refreshBranch=Messages.REFRESHING_RESOURCES.branch(logger,null);
  final Map<String,AbstractResource> newInternalMap=new LinkedHashMap<String,AbstractResource>();
  int changeCount=0;
  for (  ClassPathEntry pathRoot : classPath) {
    TreeLogger branchForClassPathEntry=Messages.EXAMINING_PATH_ROOT.branch(refreshBranch,pathRoot.getLocation(),null);
    int prevChangeCount=changeCount;
    Set<AbstractResource> newResources=pathRoot.findApplicableResources(branchForClassPathEntry,pathPrefixSet);
    for (    AbstractResource newResource : newResources) {
      String resourcePath=newResource.getPath();
      if (newInternalMap.containsKey(resourcePath)) {
        Messages.IGNORING_SHADOWED_RESOURCE.log(branchForClassPathEntry,resourcePath,null);
        continue;
      }
      AbstractResource oldResource=internalMap.get(resourcePath);
      if (shouldUseNewResource(branchForClassPathEntry,oldResource,newResource)) {
        newInternalMap.put(resourcePath,newResource);
        ++changeCount;
      }
 else       if (oldResource != null) {
        newInternalMap.put(resourcePath,oldResource);
      }
    }
    if (changeCount == prevChangeCount) {
      Messages.NO_RESOURCES_CHANGED.log(branchForClassPathEntry,null);
    }
  }
  if (changeCount == 0) {
    if (newInternalMap.size() == internalMap.size()) {
      return;
    }
  }
  internalMap=newInternalMap;
  Map<String,Resource> externalMap=rerootResourcePaths(newInternalMap);
  Set<Resource> newResources=new HashSet<Resource>(externalMap.values());
  assert(newResources.size() == externalMap.size());
  exposedResources=Collections.unmodifiableSet(newResources);
  exposedResourceMap=Collections.unmodifiableMap(externalMap);
  exposedPathNames=Collections.unmodifiableSet(externalMap.keySet());
}",0.989149634115569
54667,"private Map<String,Resource> rerootResourcePaths(Map<String,AbstractResource> newInternalMap){
  Map<String,Resource> externalMap;
  externalMap=new HashMap<String,Resource>();
  for (  AbstractResource resource : newInternalMap.values()) {
    String path=resource.getPath();
    if (externalMap.get(path) instanceof ResourceWrapper) {
      continue;
    }
    int hitCount=0;
    for (    PathPrefix pathPrefix : pathPrefixSet.values()) {
      if (pathPrefix.allows(path)) {
        assert(path.startsWith(pathPrefix.getPrefix()));
        if (pathPrefix.shouldReroot()) {
          String rerootedPath=pathPrefix.getRerootedPath(path);
          Resource exposed=exposedResourceMap.get(rerootedPath);
          if (exposed instanceof ResourceWrapper) {
            ResourceWrapper exposedWrapper=(ResourceWrapper)exposed;
            if (exposedWrapper.resource == resource) {
              externalMap.put(rerootedPath,exposedWrapper);
              ++hitCount;
              break;
            }
          }
          AbstractResource wrapper=new ResourceWrapper(rerootedPath,resource);
          externalMap.put(rerootedPath,wrapper);
          ++hitCount;
        }
 else {
          externalMap.put(path,resource);
          ++hitCount;
        }
      }
    }
    assert(hitCount > 0);
  }
  return externalMap;
}","private Map<String,Resource> rerootResourcePaths(Map<String,AbstractResource> newInternalMap){
  Map<String,Resource> externalMap;
  externalMap=new HashMap<String,Resource>();
  for (  AbstractResource resource : newInternalMap.values()) {
    String path=resource.getPath();
    if (externalMap.get(path) instanceof ResourceWrapper) {
      continue;
    }
    int hitCount=0;
    for (    PathPrefix pathPrefix : pathPrefixSet.values()) {
      if (pathPrefix.allows(path)) {
        assert(path.startsWith(pathPrefix.getPrefix()));
        if (pathPrefix.shouldReroot()) {
          String rerootedPath=pathPrefix.getRerootedPath(path);
          if (externalMap.get(rerootedPath) instanceof ResourceWrapper) {
            ++hitCount;
            break;
          }
          Resource exposed=exposedResourceMap.get(rerootedPath);
          if (exposed instanceof ResourceWrapper) {
            ResourceWrapper exposedWrapper=(ResourceWrapper)exposed;
            if (exposedWrapper.resource == resource) {
              externalMap.put(rerootedPath,exposedWrapper);
              ++hitCount;
              break;
            }
          }
          AbstractResource wrapper=new ResourceWrapper(rerootedPath,resource);
          externalMap.put(rerootedPath,wrapper);
          ++hitCount;
        }
 else {
          externalMap.put(path,resource);
          ++hitCount;
        }
      }
    }
    assert(hitCount > 0);
  }
  return externalMap;
}",0.9535469931580842
54668,"protected void assertPathNotIncluded(Set<AbstractResource> resources,String path){
  assertNull(findResourceWithPath(resources,path));
}","protected void assertPathNotIncluded(Set<AbstractResource> resources,String path){
  assertNull(""String_Node_Str"" + path + ""String_Node_Str""+ resources,findResourceWithPath(resources,path));
}",0.8292682926829268
54669,"protected void assertPathIncluded(Set<AbstractResource> resources,String path){
  assertNotNull(findResourceWithPath(resources,path));
}","protected void assertPathIncluded(Set<AbstractResource> resources,String path){
  assertNotNull(""String_Node_Str"" + path + ""String_Node_Str""+ resources,findResourceWithPath(resources,path));
}",0.8292682926829268
54670,"private void testResourceModification(ClassPathEntry cpe1,ClassPathEntry cpe2){
  TreeLogger logger=createTestTreeLogger();
  MOCK_CPE0 cpe0=new MOCK_CPE0();
  MOCK_CPE3 cpe3=new MOCK_CPE3();
  ResourceOracleImpl oracle=createResourceOracle(cpe0,cpe1,cpe2,cpe3);
{
    oracle.refresh(logger);
    ResourceOracleSnapshot s=new ResourceOracleSnapshot(oracle);
    s.assertPathIncluded(""String_Node_Str"",cpe1);
    s.assertPathIncluded(""String_Node_Str"",cpe1);
  }
  cpe0.addResource(""String_Node_Str"");
  cpe3.addResource(""String_Node_Str"");
{
    oracle.refresh(logger);
    ResourceOracleSnapshot s=new ResourceOracleSnapshot(oracle);
    s.assertPathIncluded(""String_Node_Str"",cpe0);
    s.assertPathIncluded(""String_Node_Str"",cpe1);
  }
{
    ResourceOracleSnapshot before=new ResourceOracleSnapshot(oracle);
    before.assertCollectionsConsistent(9);
    cpe3.updateResource(""String_Node_Str"");
    ResourceOracleSnapshot after=refreshAndSnapshot(logger,oracle);
    after.assertSameCollections(before);
  }
{
    ResourceOracleSnapshot before=new ResourceOracleSnapshot(oracle);
    before.assertCollectionsConsistent(9);
    cpe0.updateResource(""String_Node_Str"");
    ResourceOracleSnapshot after=refreshAndSnapshot(logger,oracle);
    after.assertNotSameCollections(before);
  }
}","private void testResourceModification(ClassPathEntry cpe1,ClassPathEntry cpe2){
  TreeLogger logger=createTestTreeLogger();
  MOCK_CPE0 cpe0=new MOCK_CPE0();
  MOCK_CPE3 cpe3=new MOCK_CPE3();
  ResourceOracleImpl oracle=createResourceOracle(cpe0,cpe1,cpe2,cpe3);
{
    ResourceOracleSnapshot s=refreshAndSnapshot(logger,oracle);
    s.assertPathIncluded(""String_Node_Str"",cpe1);
    s.assertPathIncluded(""String_Node_Str"",cpe1);
  }
  cpe0.addResource(""String_Node_Str"");
  cpe3.addResource(""String_Node_Str"");
{
    ResourceOracleSnapshot s=refreshAndSnapshot(logger,oracle);
    s.assertPathIncluded(""String_Node_Str"",cpe0);
    s.assertPathIncluded(""String_Node_Str"",cpe1);
  }
{
    ResourceOracleSnapshot before=new ResourceOracleSnapshot(oracle);
    before.assertCollectionsConsistent(9);
    cpe3.updateResource(""String_Node_Str"");
    ResourceOracleSnapshot after=refreshAndSnapshot(logger,oracle);
    after.assertSameCollections(before);
  }
{
    ResourceOracleSnapshot before=new ResourceOracleSnapshot(oracle);
    before.assertCollectionsConsistent(9);
    cpe0.updateResource(""String_Node_Str"");
    ResourceOracleSnapshot after=refreshAndSnapshot(logger,oracle);
    after.assertNotSameCollections(before);
  }
}",0.9356120826709062
54671,"private void testReadingResource(ClassPathEntry cpe1,ClassPathEntry cpe2) throws IOException {
  TreeLogger logger=createTestTreeLogger();
  ResourceOracleImpl oracle=createResourceOracle(cpe1,cpe2);
  oracle.refresh(logger);
  ResourceOracleSnapshot s=new ResourceOracleSnapshot(oracle);
  s.assertCollectionsConsistent(9);
  s.assertPathIncluded(""String_Node_Str"",cpe1);
  s.assertPathIncluded(""String_Node_Str"",cpe2);
{
    AbstractResource res=s.findResourceWithPath(""String_Node_Str"");
    BufferedReader rdr=null;
    try {
      InputStream is=res.openContents();
      assertNotNull(is);
      rdr=new BufferedReader(new InputStreamReader(is));
      assertTrue(rdr.readLine().indexOf(""String_Node_Str"") >= 0);
    }
  finally {
      Utility.close(rdr);
    }
  }
{
    AbstractResource res=s.findResourceWithPath(""String_Node_Str"");
    BufferedReader rdr=null;
    try {
      InputStream is=res.openContents();
      assertNotNull(is);
      rdr=new BufferedReader(new InputStreamReader(is));
      assertTrue(rdr.readLine().indexOf(""String_Node_Str"") >= 0);
    }
  finally {
      Utility.close(rdr);
    }
  }
{
  }
}","private void testReadingResource(ClassPathEntry cpe1,ClassPathEntry cpe2) throws IOException {
  TreeLogger logger=createTestTreeLogger();
  ResourceOracleImpl oracle=createResourceOracle(cpe1,cpe2);
  ResourceOracleSnapshot s=refreshAndSnapshot(logger,oracle);
  s.assertCollectionsConsistent(9);
  s.assertPathIncluded(""String_Node_Str"",cpe1);
  s.assertPathIncluded(""String_Node_Str"",cpe2);
{
    AbstractResource res=s.findResourceWithPath(""String_Node_Str"");
    BufferedReader rdr=null;
    try {
      InputStream is=res.openContents();
      assertNotNull(is);
      rdr=new BufferedReader(new InputStreamReader(is));
      assertTrue(rdr.readLine().indexOf(""String_Node_Str"") >= 0);
    }
  finally {
      Utility.close(rdr);
    }
  }
{
    AbstractResource res=s.findResourceWithPath(""String_Node_Str"");
    BufferedReader rdr=null;
    try {
      InputStream is=res.openContents();
      assertNotNull(is);
      rdr=new BufferedReader(new InputStreamReader(is));
      assertTrue(rdr.readLine().indexOf(""String_Node_Str"") >= 0);
    }
  finally {
      Utility.close(rdr);
    }
  }
{
  }
}",0.953956191327671
54672,"/** 
 * Creates an array of class path entries, setting up each one with a well-known set of client prefixes.
 * @param entries
 * @return
 */
private ResourceOracleImpl createResourceOracle(ClassPathEntry... entries){
  PathPrefixSet pps=new PathPrefixSet();
  pps.add(new PathPrefix(""String_Node_Str"",null));
  pps.add(new PathPrefix(""String_Node_Str"",null));
  pps.add(new PathPrefix(""String_Node_Str"",null));
  pps.add(new PathPrefix(""String_Node_Str"",null));
  List<ClassPathEntry> classPath=new ArrayList<ClassPathEntry>();
  for (  ClassPathEntry entry : entries) {
    classPath.add(entry);
  }
  ResourceOracleImpl oracle=new ResourceOracleImpl(classPath);
  oracle.setPathPrefixes(pps);
  return oracle;
}","/** 
 * Creates an array of class path entries, setting up each one with a well-known set of client prefixes.
 */
private ResourceOracleImpl createResourceOracle(ClassPathEntry... entries){
  PathPrefixSet pps=new PathPrefixSet();
  pps.add(new PathPrefix(""String_Node_Str"",null));
  pps.add(new PathPrefix(""String_Node_Str"",null));
  pps.add(new PathPrefix(""String_Node_Str"",null));
  pps.add(new PathPrefix(""String_Node_Str"",null));
  List<ClassPathEntry> classPath=new ArrayList<ClassPathEntry>();
  for (  ClassPathEntry entry : entries) {
    classPath.add(entry);
  }
  ResourceOracleImpl oracle=new ResourceOracleImpl(classPath);
  oracle.setPathPrefixes(pps);
  return oracle;
}",0.979300499643112
54673,"/** 
 * Compare two methods based on name and original argument types  {@link JMethod#getOriginalParamTypes()}. Note that nothing special is done here regarding methods with type parameters in their argument lists. The caller must be careful that this level of matching is sufficient.
 */
private static boolean methodsDoMatch(JMethod method1,JMethod method2){
  if (method1.isStatic() || method2.isStatic()) {
    return false;
  }
  if (!method1.getName().equals(method2.getName())) {
    return false;
  }
  List<JType> params1=method1.getOriginalParamTypes();
  List<JType> params2=method2.getOriginalParamTypes();
  int params1size=params1.size();
  if (params1size != params2.size()) {
    return false;
  }
  for (int i=0; i < params1size; ++i) {
    if (params1.get(i) != params2.get(i)) {
      return false;
    }
  }
  return true;
}","/** 
 * Compare two methods based on name and original argument types  {@link JMethod#getOriginalParamTypes()}. Note that nothing special is done here regarding methods with type parameters in their argument lists. The caller must be careful that this level of matching is sufficient.
 */
public static boolean methodsDoMatch(JMethod method1,JMethod method2){
  if (method1.isStatic() || method2.isStatic()) {
    return false;
  }
  if (!method1.getName().equals(method2.getName())) {
    return false;
  }
  List<JType> params1=method1.getOriginalParamTypes();
  List<JType> params2=method2.getOriginalParamTypes();
  int params1size=params1.size();
  if (params1size != params2.size()) {
    return false;
  }
  for (int i=0; i < params1size; ++i) {
    if (params1.get(i) != params2.get(i)) {
      return false;
    }
  }
  return true;
}",0.993479549496147
54674,"public void testUninstantiableAccess(){
  UninstantiableType u=null;
  try {
    accessUninstantiableField(u);
    fail(""String_Node_Str"");
  }
 catch (  JavaScriptException expected) {
  }
  try {
    accessUninstantiableMethod(u);
    fail(""String_Node_Str"");
  }
 catch (  JavaScriptException expected) {
  }
  try {
    volatileUninstantiableType=(UninstantiableType)(new Object());
    fail(""String_Node_Str"");
  }
 catch (  ClassCastException expected) {
  }
  try {
    volatileInt=u.intField++;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileInt=u.intField--;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileInt=++u.intField;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileInt=--u.intField;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    u.intField=0;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileBoolean=u.intField == 0;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileBoolean=u.returnInt() == 0;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
}","public void testUninstantiableAccess(){
  UninstantiableType u=null;
  try {
    accessUninstantiableField(u);
    fail(""String_Node_Str"");
  }
 catch (  JavaScriptException expected) {
  }
  try {
    accessUninstantiableMethod(u);
    fail(""String_Node_Str"");
  }
 catch (  JavaScriptException expected) {
  }
  try {
    volatileUninstantiableType=(UninstantiableType)(new Object());
    fail(""String_Node_Str"");
  }
 catch (  ClassCastException expected) {
  }
  try {
    volatileInt=u.intField++;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileInt=u.intField--;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileInt=++u.intField;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileInt=--u.intField;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    u.intField=0;
  }
 catch (  Exception expected) {
  }
  try {
    volatileBoolean=u.intField == 0;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
  try {
    volatileBoolean=u.returnInt() == 0;
    fail(""String_Node_Str"");
  }
 catch (  Exception expected) {
  }
}",0.9075072583990046
54675,"@SuppressWarnings(""String_Node_Str"") private void openPopup(final MenuItem item){
  popup=new DecoratedPopupPanel(true,false,""String_Node_Str""){
{
      setWidget(item.getSubMenu());
      setPreviewingAllNativeEvents(true);
      item.getSubMenu().onShow();
    }
    @Override protected void onPreviewNativeEvent(    NativePreviewEvent event){
      if (!event.isCanceled()) {
        Event nativeEvent=event.getNativeEvent();
switch (nativeEvent.getTypeInt()) {
case Event.ONMOUSEDOWN:
          com.google.gwt.dom.client.Element target=nativeEvent.getTarget();
        Element parentMenuElement=item.getParentMenu().getElement();
      if (parentMenuElement.isOrHasChild(target)) {
        event.cancel();
        return;
      }
    super.onPreviewNativeEvent(event);
  if (event.isCanceled()) {
    selectItem(null);
  }
return;
}
}
super.onPreviewNativeEvent(event);
}
}
;
popup.setAnimationType(AnimationType.ONE_WAY_CORNER);
popup.setAnimationEnabled(isAnimationEnabled);
popup.setStyleName(STYLENAME_DEFAULT + ""String_Node_Str"");
String primaryStyleName=getStylePrimaryName();
if (!STYLENAME_DEFAULT.equals(primaryStyleName)) {
popup.addStyleName(primaryStyleName + ""String_Node_Str"");
}
popup.addPopupListener(this);
shownChildMenu=item.getSubMenu();
item.getSubMenu().parentMenu=this;
popup.setPopupPositionAndShow(new PopupPanel.PositionCallback(){
public void setPosition(int offsetWidth,int offsetHeight){
if (LocaleInfo.getCurrentLocale().isRTL()) {
if (vertical) {
popup.setPopupPosition(MenuBar.this.getAbsoluteLeft() - offsetWidth + 1,item.getAbsoluteTop());
}
 else {
popup.setPopupPosition(item.getAbsoluteLeft() + item.getOffsetWidth() - offsetWidth,MenuBar.this.getAbsoluteTop() + MenuBar.this.getOffsetHeight() - 1);
}
}
 else {
if (vertical) {
popup.setPopupPosition(MenuBar.this.getAbsoluteLeft() + MenuBar.this.getOffsetWidth() - 1,item.getAbsoluteTop());
}
 else {
popup.setPopupPosition(item.getAbsoluteLeft(),MenuBar.this.getAbsoluteTop() + MenuBar.this.getOffsetHeight() - 1);
}
}
}
}
);
}","@SuppressWarnings(""String_Node_Str"") private void openPopup(final MenuItem item){
  if (parentMenu != null && parentMenu.popup != null) {
    parentMenu.popup.setPreviewingAllNativeEvents(false);
  }
  popup=new DecoratedPopupPanel(true,false,""String_Node_Str""){
{
      setWidget(item.getSubMenu());
      setPreviewingAllNativeEvents(true);
      item.getSubMenu().onShow();
    }
    @Override protected void onPreviewNativeEvent(    NativePreviewEvent event){
      if (!event.isCanceled()) {
        Event nativeEvent=event.getNativeEvent();
switch (nativeEvent.getTypeInt()) {
case Event.ONMOUSEDOWN:
          com.google.gwt.dom.client.Element target=nativeEvent.getTarget();
        Element parentMenuElement=item.getParentMenu().getElement();
      if (parentMenuElement.isOrHasChild(target)) {
        event.cancel();
        return;
      }
    super.onPreviewNativeEvent(event);
  if (event.isCanceled()) {
    selectItem(null);
  }
return;
}
}
super.onPreviewNativeEvent(event);
}
}
;
popup.setAnimationType(AnimationType.ONE_WAY_CORNER);
popup.setAnimationEnabled(isAnimationEnabled);
popup.setStyleName(STYLENAME_DEFAULT + ""String_Node_Str"");
String primaryStyleName=getStylePrimaryName();
if (!STYLENAME_DEFAULT.equals(primaryStyleName)) {
popup.addStyleName(primaryStyleName + ""String_Node_Str"");
}
popup.addPopupListener(this);
shownChildMenu=item.getSubMenu();
item.getSubMenu().parentMenu=this;
popup.setPopupPositionAndShow(new PopupPanel.PositionCallback(){
public void setPosition(int offsetWidth,int offsetHeight){
if (LocaleInfo.getCurrentLocale().isRTL()) {
if (vertical) {
popup.setPopupPosition(MenuBar.this.getAbsoluteLeft() - offsetWidth + 1,item.getAbsoluteTop());
}
 else {
popup.setPopupPosition(item.getAbsoluteLeft() + item.getOffsetWidth() - offsetWidth,MenuBar.this.getAbsoluteTop() + MenuBar.this.getOffsetHeight() - 1);
}
}
 else {
if (vertical) {
popup.setPopupPosition(MenuBar.this.getAbsoluteLeft() + MenuBar.this.getOffsetWidth() - 1,item.getAbsoluteTop());
}
 else {
popup.setPopupPosition(item.getAbsoluteLeft(),MenuBar.this.getAbsoluteTop() + MenuBar.this.getOffsetHeight() - 1);
}
}
}
}
);
}",0.9716209716209716
54676,"/** 
 * Closes the menu bar.
 * @deprecated use {@link #addCloseHandler(CloseHandler)} instead.
 */
@Deprecated public void onPopupClosed(PopupPanel sender,boolean autoClosed){
  if (autoClosed) {
    closeAllParents();
  }
  onHide();
  CloseEvent.fire(MenuBar.this,sender);
  shownChildMenu=null;
  popup=null;
}","/** 
 * Closes the menu bar.
 * @deprecated use {@link #addCloseHandler(CloseHandler)} instead.
 */
@Deprecated public void onPopupClosed(PopupPanel sender,boolean autoClosed){
  if (autoClosed) {
    closeAllParents();
  }
  onHide();
  CloseEvent.fire(MenuBar.this,sender);
  shownChildMenu=null;
  popup=null;
  if (parentMenu != null && parentMenu.popup != null) {
    parentMenu.popup.setPreviewingAllNativeEvents(true);
  }
}",0.8429530201342282
54677,"public void onError(Widget sender){
  fail(""String_Node_Str"" + image.getUrl() + ""String_Node_Str"");
}","public void onError(Widget sender){
  ++firedError;
}",0.5974025974025974
54678,"public void onLoad(LoadEvent event){
  if (++onLoadEventCount == 4) {
    if (listener.isFinished()) {
      finishTest();
    }
 else {
      fail(""String_Node_Str"");
    }
  }
}","public void onLoad(Widget sender){
  ++firedLoad;
}",0.3217391304347826
54679,"/** 
 * Perform an initial hosted mode link, without overwriting newer or unmodified files in the output folder.
 * @param logger the logger to use
 * @param module the module to link
 * @param includePublicFiles if <code>true</code>, include public files inthe link, otherwise do not include them
 * @throws UnableToCompleteException
 */
private void link(TreeLogger logger,ModuleDef module,boolean includePublicFiles) throws UnableToCompleteException {
  File moduleOutDir=new File(options.getWarDir(),module.getName());
  File moduleExtraDir=(options.getExtraDir() == null) ? null : new File(options.getExtraDir(),module.getName());
  StandardLinkerContext linkerStack=new StandardLinkerContext(logger,module,options);
  linkerStacks.put(module.getName(),linkerStack);
  if (!includePublicFiles) {
    linkerStack.getArtifacts().clear();
  }
  ArtifactSet artifacts=linkerStack.invokeLink(logger);
  linkerStack.produceOutputDirectory(logger,artifacts,moduleOutDir,moduleExtraDir);
}","/** 
 * Perform an initial hosted mode link, without overwriting newer or unmodified files in the output folder.
 * @param logger the logger to use
 * @param module the module to link
 * @param includePublicFiles if <code>true</code>, include public files inthe link, otherwise do not include them
 * @throws UnableToCompleteException
 */
private void link(TreeLogger logger,ModuleDef module) throws UnableToCompleteException {
  File moduleOutDir=new File(options.getWarDir(),module.getName());
  File moduleExtraDir=(options.getExtraDir() == null) ? null : new File(options.getExtraDir(),module.getName());
  StandardLinkerContext linkerStack=new StandardLinkerContext(logger,module,options);
  linkerStacks.put(module.getName(),linkerStack);
  ArtifactSet artifacts=linkerStack.invokeLink(logger);
  linkerStack.produceOutputDirectory(logger,artifacts,moduleOutDir,moduleExtraDir);
}",0.9465811965811964
54680,"@Override protected boolean doStartup(){
  if (!super.doStartup()) {
    return false;
  }
  tempWorkDir=options.getWorkDir() == null;
  if (tempWorkDir) {
    try {
      options.setWorkDir(Utility.makeTemporaryDirectory(null,""String_Node_Str""));
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
      return false;
    }
  }
  for (  String moduleName : options.getModuleNames()) {
    TreeLogger loadLogger=getTopLogger().branch(TreeLogger.DEBUG,""String_Node_Str"" + moduleName);
    try {
      ModuleDef module=loadModule(loadLogger,moduleName,false);
      String[] servletPaths=module.getServletPaths();
      if (servletPaths.length > 0) {
        loadLogger.log(TreeLogger.WARN,""String_Node_Str"" + moduleName + ""String_Node_Str"");
      }
      link(loadLogger,module,false);
    }
 catch (    UnableToCompleteException e) {
      return false;
    }
  }
  return true;
}","@Override protected boolean doStartup(){
  if (!super.doStartup()) {
    return false;
  }
  tempWorkDir=options.getWorkDir() == null;
  if (tempWorkDir) {
    try {
      options.setWorkDir(Utility.makeTemporaryDirectory(null,""String_Node_Str""));
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
      return false;
    }
  }
  for (  String moduleName : options.getModuleNames()) {
    TreeLogger loadLogger=getTopLogger().branch(TreeLogger.DEBUG,""String_Node_Str"" + moduleName);
    try {
      ModuleDef module=loadModule(loadLogger,moduleName,false);
      String[] servletPaths=module.getServletPaths();
      if (servletPaths.length > 0) {
        loadLogger.log(TreeLogger.WARN,""String_Node_Str"" + moduleName + ""String_Node_Str"");
      }
      link(loadLogger,module);
    }
 catch (    UnableToCompleteException e) {
      return false;
    }
  }
  return true;
}",0.9967880085653104
54681,"@Override protected boolean initModule(String moduleName){
  ModuleDef module=modulesByName.get(moduleName);
  if (module == null) {
    getTopLogger().log(TreeLogger.WARN,""String_Node_Str"" + moduleName + ""String_Node_Str"");
    return false;
  }
  try {
    boolean shouldRefreshPage=false;
    if (module.isGwtXmlFileStale()) {
      shouldRefreshPage=true;
      module=loadModule(getTopLogger(),module.getCanonicalName(),false);
    }
    link(getTopLogger(),module,true);
    return shouldRefreshPage;
  }
 catch (  UnableToCompleteException e) {
    return false;
  }
}","@Override protected boolean initModule(String moduleName){
  ModuleDef module=modulesByName.get(moduleName);
  if (module == null) {
    getTopLogger().log(TreeLogger.WARN,""String_Node_Str"" + moduleName + ""String_Node_Str"");
    return false;
  }
  try {
    boolean shouldRefreshPage=false;
    if (module.isGwtXmlFileStale()) {
      shouldRefreshPage=true;
      module=loadModule(getTopLogger(),module.getCanonicalName(),false);
    }
    link(getTopLogger(),module);
    return shouldRefreshPage;
  }
 catch (  UnableToCompleteException e) {
    return false;
  }
}",0.9956331877729258
54682,"/** 
 * Overridden to defer the call to super.sinkEvents until the first time this widget is attached to the dom, as a performance enhancement. Subclasses wishing to customize sinkEvents can preserve this deferred sink behavior by putting their implementation behind a check of   {@link #isOrWasAttached()}: <pre>  {@literal @}Override public void sinkEvents(int eventBitsToAdd) { if (isOrWasAttached()) { /  {@literal *} customized sink code goes here {@literal *}/ } else { super.sinkEvents(eventBitsToAdd); } } </pre>
 */
@Override public void sinkEvents(int eventBitsToAdd){
  if (isOrWasAttached()) {
    super.sinkEvents(eventBitsToAdd);
  }
 else {
    eventsToSink|=eventBitsToAdd;
  }
}","/** 
 * Overridden to defer the call to super.sinkEvents until the first time this widget is attached to the dom, as a performance enhancement. Subclasses wishing to customize sinkEvents can preserve this deferred sink behavior by putting their implementation behind a check of <code>isOrWasAttached()</code>: <pre>  {@literal @}Override public void sinkEvents(int eventBitsToAdd) { if (isOrWasAttached()) { /  {@literal *} customized sink code goes here {@literal *}/ } else { super.sinkEvents(eventBitsToAdd); } } </pre>
 */
@Override public void sinkEvents(int eventBitsToAdd){
  if (isOrWasAttached()) {
    super.sinkEvents(eventBitsToAdd);
  }
 else {
    eventsToSink|=eventBitsToAdd;
  }
}",0.6839080459770115
54683,"/** 
 * Move the tree focus to the specified selected item.
 */
private void moveFocus(){
  HasFocus focusableWidget=curSelection.getFocusableWidget();
  if (focusableWidget != null) {
    focusableWidget.setFocus(true);
    DOM.scrollIntoView(((Widget)focusableWidget).getElement());
  }
 else {
    Element selectedElem=curSelection.getContentElem();
    int containerLeft=getAbsoluteLeft();
    int containerTop=getAbsoluteTop();
    int left=DOM.getAbsoluteLeft(selectedElem) - containerLeft;
    int top=DOM.getAbsoluteTop(selectedElem) - containerTop;
    int width=DOM.getElementPropertyInt(selectedElem,""String_Node_Str"");
    int height=DOM.getElementPropertyInt(selectedElem,""String_Node_Str"");
    if (width == 0 || height == 0) {
      DOM.setIntStyleAttribute(focusable,""String_Node_Str"",0);
      DOM.setIntStyleAttribute(focusable,""String_Node_Str"",0);
      return;
    }
    DOM.setStyleAttribute(focusable,""String_Node_Str"",left + ""String_Node_Str"");
    DOM.setStyleAttribute(focusable,""String_Node_Str"",top + ""String_Node_Str"");
    DOM.setStyleAttribute(focusable,""String_Node_Str"",width + ""String_Node_Str"");
    DOM.setStyleAttribute(focusable,""String_Node_Str"",height + ""String_Node_Str"");
    DOM.scrollIntoView(focusable);
    updateAriaAttributes();
    setFocus(true);
  }
}","/** 
 * Move the tree focus to the specified selected item.
 */
private void moveFocus(){
  Focusable focusableWidget=curSelection.getFocusable();
  if (focusableWidget != null) {
    focusableWidget.setFocus(true);
    DOM.scrollIntoView(((Widget)focusableWidget).getElement());
  }
 else {
    Element selectedElem=curSelection.getContentElem();
    int containerLeft=getAbsoluteLeft();
    int containerTop=getAbsoluteTop();
    int left=DOM.getAbsoluteLeft(selectedElem) - containerLeft;
    int top=DOM.getAbsoluteTop(selectedElem) - containerTop;
    int width=DOM.getElementPropertyInt(selectedElem,""String_Node_Str"");
    int height=DOM.getElementPropertyInt(selectedElem,""String_Node_Str"");
    if (width == 0 || height == 0) {
      DOM.setIntStyleAttribute(focusable,""String_Node_Str"",0);
      DOM.setIntStyleAttribute(focusable,""String_Node_Str"",0);
      return;
    }
    DOM.setStyleAttribute(focusable,""String_Node_Str"",left + ""String_Node_Str"");
    DOM.setStyleAttribute(focusable,""String_Node_Str"",top + ""String_Node_Str"");
    DOM.setStyleAttribute(focusable,""String_Node_Str"",width + ""String_Node_Str"");
    DOM.setStyleAttribute(focusable,""String_Node_Str"",height + ""String_Node_Str"");
    DOM.scrollIntoView(focusable);
    updateAriaAttributes();
    setFocus(true);
  }
}",0.9949980761831474
54684,"/** 
 * Returns the widget, if any, that should be focused on if this TreeItem is selected.
 * @return widget to be focused.
 */
protected HasFocus getFocusableWidget(){
  Widget w=getWidget();
  if (w instanceof HasFocus) {
    return (HasFocus)w;
  }
 else {
    return null;
  }
}","/** 
 * Returns the widget, if any, that should be focused on if this TreeItem is selected.
 * @deprecated use {@link #getFocusable()} instead
 * @return widget to be focused.
 */
@Deprecated protected HasFocus getFocusableWidget(){
  Widget w=getWidget();
  if (w instanceof HasFocus) {
    return (HasFocus)w;
  }
 else {
    return null;
  }
}",0.8457869634340223
54685,"/** 
 * Gets the mouse x-position on the user's display.
 * @return the mouse x-position
 * @throws AssertionError if event type is not one of{@link Event#MOUSEEVENTS},   {@link Event#ONMOUSEWHEEL},  {@link Event#ONCLICK},   {@link Event#ONDBLCLICK}, or  {@link Event#ONCONTEXTMENU}
 */
public final int getScreenX(){
  return DOM.eventGetScreenX(this);
}","/** 
 * Gets the mouse x-position on the user's display.
 * @return the mouse x-position
 */
public final int getScreenX(){
  return DOM.eventGetScreenX(this);
}",0.624031007751938
54686,"@Override public void onBrowserEvent(Event event){
  widget.onBrowserEvent(event);
}","@Override public void onBrowserEvent(Event event){
  super.onBrowserEvent(event);
  widget.onBrowserEvent(event);
}",0.8442211055276382
54687,"@Override public void onBrowserEvent(Event event){
  if (DOM.eventGetType(event) == Event.ONCLICK) {
    super.onBrowserEvent(event);
    if (impl.handleAsClick(event)) {
      History.newItem(getTargetHistoryToken());
      DOM.eventPreventDefault(event);
    }
  }
}","@Override public void onBrowserEvent(Event event){
  super.onBrowserEvent(event);
  if (DOM.eventGetType(event) == Event.ONCLICK && impl.handleAsClick(event)) {
    History.newItem(getTargetHistoryToken());
    DOM.eventPreventDefault(event);
  }
}",0.8255813953488372
54688,"@Override public void onBrowserEvent(Event event){
  super.onBrowserEvent(event);
  MenuItem item=findItem(DOM.eventGetTarget(event));
switch (DOM.eventGetType(event)) {
case Event.ONCLICK:
{
      FocusPanel.impl.focus(getElement());
      if (item != null) {
        doItemAction(item,true);
      }
      break;
    }
case Event.ONMOUSEOVER:
{
    if (item != null) {
      itemOver(item,true);
    }
    break;
  }
case Event.ONMOUSEOUT:
{
  if (item != null) {
    itemOver(null,true);
  }
  break;
}
case Event.ONFOCUS:
{
selectFirstItemIfNoneSelected();
break;
}
case Event.ONKEYDOWN:
{
int keyCode=DOM.eventGetKeyCode(event);
switch (keyCode) {
case KeyCodes.KEY_LEFT:
if (LocaleInfo.getCurrentLocale().isRTL()) {
  moveToNextItem();
}
 else {
  moveToPrevItem();
}
eatEvent(event);
break;
case KeyCodes.KEY_RIGHT:
if (LocaleInfo.getCurrentLocale().isRTL()) {
moveToPrevItem();
}
 else {
moveToNextItem();
}
eatEvent(event);
break;
case KeyCodes.KEY_UP:
moveUp();
eatEvent(event);
break;
case KeyCodes.KEY_DOWN:
moveDown();
eatEvent(event);
break;
case KeyCodes.KEY_ESCAPE:
closeAllParents();
eatEvent(event);
break;
case KeyCodes.KEY_ENTER:
if (!selectFirstItemIfNoneSelected()) {
doItemAction(selectedItem,true);
eatEvent(event);
}
break;
}
break;
}
}
}","@Override public void onBrowserEvent(Event event){
  MenuItem item=findItem(DOM.eventGetTarget(event));
switch (DOM.eventGetType(event)) {
case Event.ONCLICK:
{
      FocusPanel.impl.focus(getElement());
      if (item != null) {
        doItemAction(item,true);
      }
      break;
    }
case Event.ONMOUSEOVER:
{
    if (item != null) {
      itemOver(item,true);
    }
    break;
  }
case Event.ONMOUSEOUT:
{
  if (item != null) {
    itemOver(null,true);
  }
  break;
}
case Event.ONFOCUS:
{
selectFirstItemIfNoneSelected();
break;
}
case Event.ONKEYDOWN:
{
int keyCode=DOM.eventGetKeyCode(event);
switch (keyCode) {
case KeyCodes.KEY_LEFT:
if (LocaleInfo.getCurrentLocale().isRTL()) {
  moveToNextItem();
}
 else {
  moveToPrevItem();
}
eatEvent(event);
break;
case KeyCodes.KEY_RIGHT:
if (LocaleInfo.getCurrentLocale().isRTL()) {
moveToPrevItem();
}
 else {
moveToNextItem();
}
eatEvent(event);
break;
case KeyCodes.KEY_UP:
moveUp();
eatEvent(event);
break;
case KeyCodes.KEY_DOWN:
moveDown();
eatEvent(event);
break;
case KeyCodes.KEY_ESCAPE:
closeAllParents();
eatEvent(event);
break;
case KeyCodes.KEY_ENTER:
if (!selectFirstItemIfNoneSelected()) {
doItemAction(selectedItem,true);
eatEvent(event);
}
break;
}
break;
}
}
super.onBrowserEvent(event);
}",0.9754358161648178
54689,"@Override public void onBrowserEvent(Event event){
  if (DOM.eventGetType(event) == Event.ONCLICK) {
    Element target=DOM.eventGetTarget(event);
    int index=findDividerIndex(target);
    if (index != -1) {
      showStack(index);
    }
  }
}","@Override public void onBrowserEvent(Event event){
  if (DOM.eventGetType(event) == Event.ONCLICK) {
    Element target=DOM.eventGetTarget(event);
    int index=findDividerIndex(target);
    if (index != -1) {
      showStack(index);
    }
  }
  super.onBrowserEvent(event);
}",0.9404990403071016
54690,"@Override protected final Type<BlurHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<BlurHandler> getAssociatedType(){
  return TYPE;
}",0.9308176100628932
54691,"@Override protected final Type<ChangeHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<ChangeHandler> getAssociatedType(){
  return TYPE;
}",0.9325153374233128
54692,"@Override protected final Type<ClickHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<ClickHandler> getAssociatedType(){
  return TYPE;
}",0.9316770186335404
54693,"@Override protected final Type<ContextMenuHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<ContextMenuHandler> getAssociatedType(){
  return TYPE;
}",0.9364161849710982
54694,@Override protected abstract DomEvent.Type<H> getAssociatedType();,@Override public abstract DomEvent.Type<H> getAssociatedType();,0.9147286821705426
54695,"@Override protected final Type<DoubleClickHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<DoubleClickHandler> getAssociatedType(){
  return TYPE;
}",0.9364161849710982
54696,"@Override protected final Type<ErrorHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<ErrorHandler> getAssociatedType(){
  return TYPE;
}",0.9316770186335404
54697,"@Override protected final Type<FocusHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<FocusHandler> getAssociatedType(){
  return TYPE;
}",0.9316770186335404
54698,"@Override protected final Type<KeyDownHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<KeyDownHandler> getAssociatedType(){
  return TYPE;
}",0.9333333333333332
54699,"@Override protected final Type<KeyPressHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<KeyPressHandler> getAssociatedType(){
  return TYPE;
}",0.934131736526946
54700,"@Override protected final Type<KeyUpHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<KeyUpHandler> getAssociatedType(){
  return TYPE;
}",0.9316770186335404
54701,"@Override protected final Type<LoadHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<LoadHandler> getAssociatedType(){
  return TYPE;
}",0.9308176100628932
54702,"@Override protected final Type<LoseCaptureHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<LoseCaptureHandler> getAssociatedType(){
  return TYPE;
}",0.9364161849710982
54703,"@Override protected final Type<MouseDownHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<MouseDownHandler> getAssociatedType(){
  return TYPE;
}",0.9349112426035504
54704,"@Override protected final Type<MouseMoveHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<MouseMoveHandler> getAssociatedType(){
  return TYPE;
}",0.9349112426035504
54705,"@Override protected final Type<MouseOutHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<MouseOutHandler> getAssociatedType(){
  return TYPE;
}",0.934131736526946
54706,"@Override protected final Type<MouseOverHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<MouseOverHandler> getAssociatedType(){
  return TYPE;
}",0.9349112426035504
54707,"@Override protected final Type<MouseUpHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<MouseUpHandler> getAssociatedType(){
  return TYPE;
}",0.9333333333333332
54708,"@Override protected final Type<MouseWheelHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<MouseWheelHandler> getAssociatedType(){
  return TYPE;
}",0.935672514619883
54709,"@Override protected final Type<ScrollHandler> getAssociatedType(){
  return TYPE;
}","@Override public final Type<ScrollHandler> getAssociatedType(){
  return TYPE;
}",0.9325153374233128
54710,"/** 
 * Gets the result text of the form submission.
 * @return the result html, or <code>null</code> if there was an errorreading it
 * @tip The result html can be <code>null</code> as a result of submitting aform to a different domain.
 */
public String getResults(){
  return resultHtml;
}","/** 
 * Gets the result text of the form submission.
 * @return the result html, or <code>null</code> if there was an error readingit
 * @tip The result html can be <code>null</code> as a result of submitting aform to a different domain.
 */
public String getResults(){
  return resultHtml;
}",0.9726027397260274
54711,"/** 
 * Fired when the popup is closed.
 * @param sender popup being closed.
 * @param autoClosed <code>true</code> if the popup was automaticallyclosed; <code>false</code> if it was closed programmatically.
 */
@Deprecated void onPopupClosed(PopupPanel sender,boolean autoClosed);","/** 
 * Fired when the popup is closed.
 * @param sender popup being closed.
 * @param autoClosed <code>true</code> if the popup was automatically closed;<code>false</code> if it was closed programmatically.
 */
@Deprecated void onPopupClosed(PopupPanel sender,boolean autoClosed);",0.99644128113879
54712,"/** 
 * Fires a popup closed event to all listeners.
 * @param sender the widget sending the event.
 * @param autoClosed <code>true</code> if the popup was automaticallyclosed; <code>false</code> if it was closed programmatically.
 */
@Deprecated public void firePopupClosed(PopupPanel sender,boolean autoClosed){
  for (  PopupListener listener : this) {
    listener.onPopupClosed(sender,autoClosed);
  }
}","/** 
 * Fires a popup closed event to all listeners.
 * @param sender the widget sending the event.
 * @param autoClosed <code>true</code> if the popup was automatically closed;<code>false</code> if it was closed programmatically.
 */
@Deprecated public void firePopupClosed(PopupPanel sender,boolean autoClosed){
  for (  PopupListener listener : this) {
    listener.onPopupClosed(sender,autoClosed);
  }
}",0.9975490196078431
54713,"/** 
 * Gets the style associated with a date (does not include styles set via   {@link #addTransientStyleToDates}).
 * @param date the date
 * @return the styles associated with this date
 */
public String getStyleOfDate(Date date){
  return styler.getStyleName(date);
}","/** 
 * Gets the style associated with a date (does not include styles set via  {@link #addTransientStyleToDates}).
 * @param date the date
 * @return the styles associated with this date
 */
public String getStyleOfDate(Date date){
  return styler.getStyleName(date);
}",0.99815157116451
54714,"/** 
 * Refreshes all components of this date picker.
 */
protected final void refreshAll(){
  highlighted=null;
  getModel().refresh();
  getView().refresh();
  getMonthSelector().refresh();
  ShowRangeEvent.fire(this,getFirstDate(),getLastDate());
}","/** 
 * Refreshes all components of this date picker.
 */
protected final void refreshAll(){
  highlighted=null;
  getModel().refresh();
  getView().refresh();
  getMonthSelector().refresh();
  if (isAttached()) {
    ShowRangeEvent.fire(this,getFirstDate(),getLastDate());
  }
}",0.9471698113207548
54715,"/** 
 * Adds the given style name to the specified dates, which must be visible.  This is only set until the next time the DatePicker is refreshed.
 */
public final void addTransientStyleToDates(String styleName,Iterable<Date> dates){
  for (  Date d : dates) {
    addTransientStyleToDates(styleName,d);
  }
}","/** 
 * Adds the given style name to the specified dates, which must be visible. This is only set until the next time the DatePicker is refreshed.
 */
public final void addTransientStyleToDates(String styleName,Iterable<Date> dates){
  for (  Date d : dates) {
    addTransientStyleToDates(styleName,d);
  }
}",0.9983844911147012
54716,"private byte[] findClassBytes(String className){
  if (JavaScriptHost.class.getName().equals(className)) {
    return javaScriptHostBytes;
  }
  if (classRewriter != null && classRewriter.isJsoIntf(className)) {
    return classRewriter.writeJsoIntf(className);
  }
  String lookupClassName=className.replace('.','/');
  if (classRewriter != null && classRewriter.isJsoImpl(className)) {
    lookupClassName=lookupClassName.substring(0,lookupClassName.length() - 1);
  }
  CompiledClass compiledClass=compilationState.getClassFileMap().get(lookupClassName);
  if (compiledClass != null) {
    injectJsniFor(compiledClass);
    byte[] classBytes=compiledClass.getBytes();
    if (!compiledClass.getUnit().isSuperSource()) {
      classBytes=emmaStrategy.getEmmaClassBytes(classBytes,lookupClassName,compiledClass.getUnit().getLastModified());
    }
 else {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
    }
    if (classRewriter != null) {
      byte[] newBytes=classRewriter.rewrite(className,classBytes);
      if (CLASS_DUMP) {
        if (!Arrays.equals(classBytes,newBytes)) {
          classDump(className,newBytes);
        }
      }
      classBytes=newBytes;
    }
    return classBytes;
  }
  return null;
}","private byte[] findClassBytes(String className){
  if (JavaScriptHost.class.getName().equals(className)) {
    return javaScriptHostBytes;
  }
  if (classRewriter != null && classRewriter.isJsoIntf(className)) {
    return classRewriter.writeJsoIntf(className);
  }
  String lookupClassName=className.replace('.','/');
  if (classRewriter != null && classRewriter.isJsoImpl(className)) {
    lookupClassName=lookupClassName.substring(0,lookupClassName.length() - 1);
  }
  CompiledClass compiledClass=compilationState.getClassFileMap().get(lookupClassName);
  byte classBytes[]=null;
  if (compiledClass != null) {
    injectJsniFor(compiledClass);
    classBytes=compiledClass.getBytes();
    if (!compiledClass.getUnit().isSuperSource()) {
      classBytes=emmaStrategy.getEmmaClassBytes(classBytes,lookupClassName,compiledClass.getUnit().getLastModified());
    }
 else {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
    }
  }
 else   if (emmaIsAvailable) {
    if (isSynthetic(className)) {
      logger.log(TreeLogger.SPAM,""String_Node_Str"" + lookupClassName + ""String_Node_Str"");
      classBytes=emmaStrategy.getEmmaClassBytes(null,lookupClassName,0);
    }
  }
  if (classBytes != null && classRewriter != null) {
    byte[] newBytes=classRewriter.rewrite(className,classBytes);
    if (CLASS_DUMP) {
      if (!Arrays.equals(classBytes,newBytes)) {
        classDump(className,newBytes);
      }
    }
    classBytes=newBytes;
  }
  return classBytes;
}",0.8704438830747022
54717,"@SuppressWarnings(""String_Node_Str"") protected static void baseRemove(HandlerManager manager,EventListener listener,Type... keys){
  if (manager != null) {
    for (    Type key : keys) {
      int handlerCount=manager.getHandlerCount(key);
      for (int i=0; i < handlerCount; i++) {
        EventHandler handler=manager.getHandler(key,i);
        if (handler instanceof ListenerWrapper && ((ListenerWrapper)handler).listener.equals(listener)) {
          manager.removeHandler(key,handler);
        }
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") static <H extends EventHandler>void baseRemove(HandlerManager manager,EventListener listener,Type... keys){
  if (manager != null) {
    for (    Type<H> key : keys) {
      int handlerCount=manager.getHandlerCount(key);
      for (int i=handlerCount - 1; i >= 0; i--) {
        H handler=manager.getHandler(key,i);
        if (handler instanceof ListenerWrapper && ((ListenerWrapper)handler).listener.equals(listener)) {
          manager.removeHandler(key,handler);
        }
      }
    }
  }
}",0.8987701040681173
54718,"@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes=findClassBytes(className);
  if (classBytes == null) {
    throw new ClassNotFoundException(className);
  }
  Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
  if (className.equals(JavaScriptHost.class.getName())) {
    javaScriptHostClass=newClass;
    updateJavaScriptHost();
  }
  if (!classRewriter.isJsoIntf(className)) {
    CompiledClass compiledClass=compilationState.getClassFileMap().get(canonicalizeClassName(className));
    if (compiledClass != null) {
      toInject.push(compiledClass);
    }
  }
  if (!isInjectingClass) {
    try {
      isInjectingClass=true;
      while (toInject.size() > 0) {
        injectJsniFor(toInject.remove(0));
      }
    }
  finally {
      isInjectingClass=false;
    }
  }
  if (className.equals(""String_Node_Str"")) {
    gwtClass=newClass;
    updateGwtClass();
  }
  return newClass;
}","@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes=findClassBytes(className);
  if (classBytes == null) {
    throw new ClassNotFoundException(className);
  }
  boolean localInjection;
  if (!isInjectingClass) {
    localInjection=isInjectingClass=true;
  }
 else {
    localInjection=false;
  }
  Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
  if (className.equals(JavaScriptHost.class.getName())) {
    javaScriptHostClass=newClass;
    updateJavaScriptHost();
  }
  if (!classRewriter.isJsoIntf(className)) {
    CompiledClass compiledClass=compilationState.getClassFileMap().get(canonicalizeClassName(className));
    if (compiledClass != null) {
      toInject.push(compiledClass);
    }
  }
  if (localInjection) {
    try {
      while (toInject.size() > 0) {
        injectJsniFor(toInject.remove(0));
      }
    }
  finally {
      isInjectingClass=false;
    }
  }
  if (className.equals(""String_Node_Str"")) {
    gwtClass=newClass;
    updateGwtClass();
  }
  return newClass;
}",0.9321971100407558
54719,"public void testStaticAccess(){
  Foo.field=3;
  assertEquals(3,Foo.field--);
  assertEquals(""String_Node_Str"",Foo.staticValue());
  assertEquals(""String_Node_Str"",Foo.staticNative());
  Bar.field=10;
  assertEquals(11,++Bar.field);
  assertEquals(""String_Node_Str"",Bar.staticValue());
  assertEquals(""String_Node_Str"",Bar.staticNative());
}","public void testStaticAccess(){
  Foo.field=3;
  assertEquals(3,Foo.field--);
  assertEquals(""String_Node_Str"",Foo.staticValue());
  assertEquals(""String_Node_Str"",Foo.staticNative());
  assertEquals(""String_Node_Str"",Foo.staticNativeToSub());
  Bar.field=10;
  assertEquals(11,++Bar.field);
  assertEquals(""String_Node_Str"",Bar.staticValue());
  assertEquals(""String_Node_Str"",Bar.staticNative());
}",0.9203778677462888
54720,"/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove 
 */
@Deprecated void removeChangeListener(ChangeListener listener);","/** 
 * Removes a previously added listener interface.
 * @param listener the listener interface to remove
 */
@Deprecated void removeChangeListener(ChangeListener listener);",0.997134670487106
54721,"/** 
 * Adds a listener interface to receive keyboard events.
 * @param listener the listener interface to add
 * @deprecated use <code>addKeyPressHandler/addKeyDownKeyDownHandler/addKeyUpHandler</code> instead
 */
@Deprecated void addKeyboardListener(KeyboardListener listener);","/** 
 * Adds a listener interface to receive keyboard events.
 * @param listener the listener interface to add
 * @deprecated use<code>addKeyPressHandler/addKeyDownKeyDownHandler/addKeyUpHandler</code> instead
 */
@Deprecated void addKeyboardListener(KeyboardListener listener);",0.9982046678635548
54722,"/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use <code>addMouse(Down/Up/Over/Out/Move/Scroll)Handler</code> instead
 */
@Deprecated void addMouseListener(MouseListener listener);","/** 
 * Adds a listener interface to receive mouse events.
 * @param listener the listener interface to add
 * @deprecated use <code>addMouse(Down/Up/Over/Out/Move/Scroll)Handler</code>instead
 */
@Deprecated void addMouseListener(MouseListener listener);",0.9980430528375732
54723,"/** 
 * Adds a listener interface to receive tree events.
 * @param listener the listener interface to add
 * @deprecated use addSelectionHandler,addOpenHandler, and addCloseHandler instead
 */
@Deprecated void addTreeListener(TreeListener listener);","/** 
 * Adds a listener interface to receive tree events.
 * @param listener the listener interface to add
 * @deprecated use addSelectionHandler,addOpenHandler, and addCloseHandlerinstead
 */
@Deprecated void addTreeListener(TreeListener listener);",0.997995991983968
54724,"public void onMouseOut(MouseOutEvent event){
  listener.onMouseLeave(source(event));
}","public void onMouseOut(MouseOutEvent event){
  Element to=event.getToElement();
  Widget source=source(event);
  if (to == null || !source.getElement().isOrHasChild(to)) {
    listener.onMouseLeave(source(event));
  }
}",0.5639344262295082
54725,"public void onMouseDown(MouseDownEvent event){
  listener.onMouseDown(source(event),event.getClientX(),event.getClientY());
}","public void onMouseDown(MouseDownEvent event){
  Widget source=source(event);
  Element elem=source.getElement();
  listener.onMouseDown(source,event.getRelativeX(elem),event.getRelativeY(elem));
}",0.639751552795031
54726,"public void onMouseOver(MouseOverEvent event){
  listener.onMouseEnter(source(event));
}","public void onMouseOver(MouseOverEvent event){
  Element from=event.getFromElement();
  Widget source=source(event);
  if (from == null || !source.getElement().isOrHasChild(from)) {
    listener.onMouseEnter(source(event));
  }
}",0.555205047318612
54727,"public void onMouseMove(MouseMoveEvent event){
  listener.onMouseMove(source(event),event.getClientX(),event.getClientY());
}","public void onMouseMove(MouseMoveEvent event){
  Widget source=source(event);
  Element elem=source.getElement();
  listener.onMouseMove(source,event.getRelativeX(elem),event.getRelativeY(elem));
}",0.639751552795031
54728,"public void onMouseUp(MouseUpEvent event){
  listener.onMouseUp(source(event),event.getClientX(),event.getClientY());
}","public void onMouseUp(MouseUpEvent event){
  Widget source=source(event);
  Element elem=source.getElement();
  listener.onMouseUp(source,event.getRelativeX(elem),event.getRelativeY(elem));
}",0.6258064516129033
54729,"public long lastModified(){
  long lastModified=moduleDefCreationTime;
  for (Iterator<File> iter=gwtXmlFiles.iterator(); iter.hasNext(); ) {
    File xmlFile=iter.next();
    if (xmlFile.exists()) {
      lastModified=Math.min(lastModified,xmlFile.lastModified());
    }
  }
  return lastModified;
}","public long lastModified(){
  long lastModified=0;
  for (  File xmlFile : gwtXmlFiles) {
    if (xmlFile.exists()) {
      lastModified=Math.max(lastModified,xmlFile.lastModified());
    }
  }
  return lastModified > 0 ? lastModified : moduleDefCreationTime;
}",0.7058823529411765
54730,"public StandardGeneratedResource(Class<? extends Generator> generatorType,String partialPath,URL url){
  super(StandardLinkerContext.class,generatorType,partialPath);
  this.url=url;
}","public StandardGeneratedResource(Class<? extends Generator> generatorType,String partialPath,File file){
  super(StandardLinkerContext.class,generatorType,partialPath);
  this.file=file;
}",0.9408602150537636
54731,"@Override public InputStream getContents(TreeLogger logger) throws UnableToCompleteException {
  try {
    return url.openStream();
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}","@Override public InputStream getContents(TreeLogger logger) throws UnableToCompleteException {
  try {
    return new FileInputStream(file);
  }
 catch (  IOException e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}",0.927643784786642
54732,"/** 
 * Writes artifacts into output directories in the standard way.
 * @param logger logs the operation
 * @param artifacts the set of artifacts to write
 * @param outputPath the output path for deployable artifacts
 * @param extraPath optional extra path for non-deployable artifacts
 * @throws UnableToCompleteException
 */
public void produceOutputDirectory(TreeLogger logger,ArtifactSet artifacts,File outputPath,File extraPath) throws UnableToCompleteException {
  logger=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + outputPath.getPath(),null);
  for (  EmittedArtifact artifact : artifacts.find(EmittedArtifact.class)) {
    TreeLogger artifactLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + artifact.getPartialPath(),null);
    File outFile;
    if (artifact.isPrivate()) {
      if (extraPath == null) {
        continue;
      }
      outFile=new File(getExtraPathForLinker(extraPath,artifact.getLinker()),artifact.getPartialPath());
    }
 else {
      outFile=new File(outputPath,artifact.getPartialPath());
    }
    Util.copy(artifactLogger,artifact.getContents(artifactLogger),outFile);
  }
}","/** 
 * Writes artifacts into output directories in the standard way.
 * @param logger logs the operation
 * @param artifacts the set of artifacts to write
 * @param outputPath the output path for deployable artifacts
 * @param extraPath optional extra path for non-deployable artifacts
 * @throws UnableToCompleteException
 */
public void produceOutputDirectory(TreeLogger logger,ArtifactSet artifacts,File outputPath,File extraPath) throws UnableToCompleteException {
  logger=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + outputPath.getPath(),null);
  for (  EmittedArtifact artifact : artifacts.find(EmittedArtifact.class)) {
    TreeLogger artifactLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + artifact.getPartialPath(),null);
    File outFile;
    if (artifact.isPrivate()) {
      if (extraPath == null) {
        continue;
      }
      outFile=new File(getExtraPathForLinker(extraPath,artifact.getLinker()),artifact.getPartialPath());
    }
 else {
      outFile=new File(outputPath,artifact.getPartialPath());
    }
    Util.copy(artifactLogger,artifact.getContents(artifactLogger),outFile);
    outFile.setLastModified(artifact.getLastModified());
  }
}",0.9752711496746204
54733,"private Object writeReplace(){
  if (resource instanceof Serializable) {
    return this;
  }
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    Util.copy(resource.openContents(),baos);
    return new SerializedPublicResource(getPartialPath(),baos.toByteArray());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","private Object writeReplace(){
  if (resource instanceof Serializable) {
    return this;
  }
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    Util.copy(resource.openContents(),baos);
    return new SerializedPublicResource(getPartialPath(),baos.toByteArray(),getLastModified());
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9753424657534246
54734,"protected SerializedPublicResource(String partialPath,byte[] data){
  super(StandardLinkerContext.class,partialPath);
  this.data=data;
}","protected SerializedPublicResource(String partialPath,byte[] data,long lastModified){
  super(StandardLinkerContext.class,partialPath);
  this.data=data;
  this.lastModified=lastModified;
}",0.8404907975460123
54735,"@Override public void hide(){
  resizeHandlerRegistration.removeHandler();
  resizeHandlerRegistration=null;
  super.hide();
}","@Override public void hide(){
  if (resizeHandlerRegistration != null) {
    resizeHandlerRegistration.removeHandler();
    resizeHandlerRegistration=null;
  }
  super.hide();
}",0.8316831683168316
54736,"/** 
 * Synchronize against the source oracle to check for added/removed/updated units. Updated units are invalidated, and any units depending on changed units are also invalidated. All generated units are removed. TODO: something more optimal with generated files?
 */
public void refresh(TreeLogger logger){
  for (Iterator<CompilationUnit> it=unitMap.values().iterator(); it.hasNext(); ) {
    CompilationUnit unit=it.next();
    if (unit.isGenerated()) {
      unit.setState(State.FRESH);
      it.remove();
    }
  }
  refreshFromSourceOracle();
  updateExposedUnits();
  CompilationUnitInvalidator.invalidateUnitsWithInvalidRefs(TreeLogger.NULL,getCompilationUnits());
  jdtCompiler=new JdtCompiler();
  validBinaryTypeNames.clear();
  compile(logger,getCompilationUnits());
  mediator.refresh(logger,getCompilationUnits());
  markSurvivorsChecked(getCompilationUnits());
}","/** 
 * Synchronize against the source oracle to check for added/removed/updated units. Updated units are invalidated, and any units depending on changed units are also invalidated. All generated units are removed. TODO: something more optimal with generated files?
 */
public void refresh(TreeLogger logger){
  for (Iterator<CompilationUnit> it=unitMap.values().iterator(); it.hasNext(); ) {
    CompilationUnit unit=it.next();
    if (unit.isGenerated()) {
      unit.setState(State.FRESH);
      it.remove();
    }
  }
  refreshFromSourceOracle();
  updateExposedUnits();
  CompilationUnitInvalidator.invalidateUnitsWithInvalidRefs(TreeLogger.NULL,getCompilationUnits());
  jdtCompiler=new JdtCompiler();
  compile(logger,getCompilationUnits());
  mediator.refresh(logger,getCompilationUnits());
  markSurvivorsChecked(getCompilationUnits());
}",0.981460023174971
54737,"/** 
 * Compile units and update their internal state. Invalidate any units with compile errors.
 */
private void compile(TreeLogger logger,Set<CompilationUnit> newUnits){
  PerfLogger.start(""String_Node_Str"");
  if (jdtCompiler.doCompile(newUnits)) {
    boolean anyErrors=CompilationUnitInvalidator.invalidateUnitsWithErrors(logger,newUnits);
    CompilationUnitInvalidator.validateCompilationUnits(newUnits,validBinaryTypeNames);
    anyErrors|=CompilationUnitInvalidator.invalidateUnitsWithErrors(logger,newUnits);
    if (anyErrors) {
      CompilationUnitInvalidator.invalidateUnitsWithInvalidRefs(logger,newUnits);
    }
    recordValidBinaryTypeNames(newUnits);
    JsniCollector.collectJsniMethods(logger,newUnits,new JsProgram());
  }
  PerfLogger.end();
}","/** 
 * Compile units and update their internal state. Invalidate any units with compile errors.
 */
private void compile(TreeLogger logger,Set<CompilationUnit> newUnits){
  PerfLogger.start(""String_Node_Str"");
  if (jdtCompiler.doCompile(newUnits)) {
    boolean anyErrors=CompilationUnitInvalidator.invalidateUnitsWithErrors(logger,newUnits);
    CompilationUnitInvalidator.validateCompilationUnits(newUnits,jdtCompiler.getBinaryTypeNames());
    anyErrors|=CompilationUnitInvalidator.invalidateUnitsWithErrors(logger,newUnits);
    if (anyErrors) {
      CompilationUnitInvalidator.invalidateUnitsWithInvalidRefs(logger,newUnits);
    }
    JsniCollector.collectJsniMethods(logger,newUnits,new JsProgram());
  }
  PerfLogger.end();
}",0.9573901464713716
54738,"private void addPackages(String packageName){
  while (true) {
    packages.add(String.valueOf(packageName));
    int pos=packageName.lastIndexOf('.');
    if (pos > 0) {
      packageName=packageName.substring(0,pos);
    }
 else {
      packages.add(""String_Node_Str"");
      break;
    }
  }
}","private void addPackages(String slashedPackageName){
  while (packages.add(slashedPackageName)) {
    int pos=slashedPackageName.lastIndexOf('/');
    if (pos > 0) {
      slashedPackageName=slashedPackageName.substring(0,pos);
    }
 else {
      packages.add(""String_Node_Str"");
      break;
    }
  }
}",0.7986688851913477
54739,"private boolean isPackage(String packageName){
  if (packages.contains(packageName)) {
    return true;
  }
  if (notPackages.contains(packageName)) {
    return false;
  }
  String resourceName=packageName.replace('.','/') + '/';
  if (getClassLoader().getResource(resourceName) != null) {
    addPackages(packageName);
    return true;
  }
 else {
    notPackages.add(packageName);
    return false;
  }
}","private boolean isPackage(String slashedPackageName){
  if (packages.contains(slashedPackageName)) {
    return true;
  }
  if (notPackages.contains(slashedPackageName)) {
    return false;
  }
  String resourceName=slashedPackageName + '/';
  if (getClassLoader().getResource(resourceName) != null) {
    addPackages(slashedPackageName);
    return true;
  }
 else {
    notPackages.add(slashedPackageName);
    return false;
  }
}",0.7127532777115614
54740,"public boolean doCompile(Collection<CompilationUnit> units){
  List<ICompilationUnit> icus=new ArrayList<ICompilationUnit>();
  for (  CompilationUnit unit : units) {
    String packageName=Shared.getPackageName(unit.getTypeName());
    addPackages(packageName);
    Set<CompiledClass> compiledClasses=unit.getCompiledClasses();
    if (compiledClasses == null) {
      icus.add(new CompilationUnitAdapter(unit));
    }
 else {
      recordBinaryTypes(compiledClasses);
    }
  }
  if (icus.isEmpty()) {
    return false;
  }
  PerfLogger.start(""String_Node_Str"");
  compiler.compile(icus.toArray(new ICompilationUnit[icus.size()]));
  PerfLogger.end();
  return true;
}","public boolean doCompile(Collection<CompilationUnit> units){
  List<ICompilationUnit> icus=new ArrayList<ICompilationUnit>();
  for (  CompilationUnit unit : units) {
    String packageName=Shared.getPackageName(unit.getTypeName()).replace('.','/');
    addPackages(packageName);
    Set<CompiledClass> compiledClasses=unit.getCompiledClasses();
    if (compiledClasses == null) {
      icus.add(new CompilationUnitAdapter(unit));
    }
 else {
      recordBinaryTypes(compiledClasses);
    }
  }
  if (icus.isEmpty()) {
    return false;
  }
  PerfLogger.start(""String_Node_Str"");
  compiler.compile(icus.toArray(new ICompilationUnit[icus.size()]));
  PerfLogger.end();
  return true;
}",0.9874723655121592
54741,"public NameEnvironmentAnswer findType(char[][] compoundTypeName){
  char[] binaryNameChars=CharOperation.concatWith(compoundTypeName,'.');
  String binaryName=String.valueOf(binaryNameChars);
  CompiledClass compiledClass=binaryTypes.get(binaryName);
  if (compiledClass != null) {
    return compiledClass.getNameEnvironmentAnswer();
  }
  if (isPackage(binaryName)) {
    return null;
  }
  try {
    Class.forName(binaryName,false,getClassLoader());
    String resourcePath=binaryName.replace('.','/') + ""String_Node_Str"";
    URL resource=getClassLoader().getResource(resourcePath);
    InputStream openStream=resource.openStream();
    try {
      ClassFileReader cfr=ClassFileReader.read(openStream,resource.toExternalForm(),true);
      return new NameEnvironmentAnswer(cfr,null);
    }
  finally {
      Utility.close(openStream);
    }
  }
 catch (  NoClassDefFoundError e) {
  }
catch (  ClassNotFoundException e) {
  }
catch (  ClassFormatException e) {
  }
catch (  IOException e) {
  }
  return null;
}","public NameEnvironmentAnswer findType(char[][] compoundTypeName){
  char[] binaryNameChars=CharOperation.concatWith(compoundTypeName,'/');
  String binaryName=String.valueOf(binaryNameChars);
  CompiledClass compiledClass=binaryTypes.get(binaryName);
  if (compiledClass != null) {
    return compiledClass.getNameEnvironmentAnswer();
  }
  if (isPackage(binaryName)) {
    return null;
  }
  try {
    URL resource=getClassLoader().getResource(binaryName + ""String_Node_Str"");
    if (resource != null) {
      InputStream openStream=resource.openStream();
      try {
        ClassFileReader cfr=ClassFileReader.read(openStream,resource.toExternalForm(),true);
        return new NameEnvironmentAnswer(cfr,null);
      }
  finally {
        Utility.close(openStream);
      }
    }
  }
 catch (  ClassFormatException e) {
  }
catch (  IOException e) {
  }
  return null;
}",0.841715193223928
54742,"private void recordBinaryTypes(Set<CompiledClass> compiledClasses){
  for (  CompiledClass compiledClass : compiledClasses) {
    binaryTypes.put(compiledClass.getBinaryName().replace('/','.'),compiledClass);
  }
}","private void recordBinaryTypes(Set<CompiledClass> compiledClasses){
  for (  CompiledClass compiledClass : compiledClasses) {
    binaryTypes.put(compiledClass.getBinaryName(),compiledClass);
  }
}",0.9586374695863747
54743,"/** 
 * Full refresh based on new units.
 */
public void refresh(TreeLogger logger,Set<CompilationUnit> units){
  binaryMapper.clear();
  sourceMapper.clear();
  typeOracle.reset();
  addNewUnits(logger,units);
}","/** 
 * Full refresh based on new units.
 */
public void refresh(TreeLogger logger,Set<CompilationUnit> units){
  binaryMapper.clear();
  typeOracle.reset();
  addNewUnits(logger,units);
}",0.94
54744,"@Override protected int startUpServer(){
  PerfLogger.start(""String_Node_Str"");
  try {
    TreeLogger serverLogger=getTopLogger().branch(TreeLogger.INFO,""String_Node_Str"" + getPort(),null);
    ModuleDef[] moduleArray=modules.toArray(new ModuleDef[modules.size()]);
    for (    ModuleDef moduleDef : moduleArray) {
      String[] servletPaths=moduleDef.getServletPaths();
      if (servletPaths.length > 0) {
        serverLogger.log(TreeLogger.WARN,""String_Node_Str"" + moduleDef.getName() + ""String_Node_Str"");
      }
    }
    servletFilter=new GWTShellServletFilter(serverLogger,options,moduleArray);
    server=launcher.start(serverLogger,getPort(),options.getOutDir(),servletFilter);
  }
 catch (  UnableToCompleteException e) {
    PerfLogger.end();
    return -1;
  }
  assert(server != null);
  PerfLogger.end();
  return server.getPort();
}","@Override protected int startUpServer(){
  PerfLogger.start(""String_Node_Str"");
  try {
    TreeLogger serverLogger=getTopLogger().branch(TreeLogger.INFO,""String_Node_Str"" + getPort(),null);
    ModuleDef[] moduleArray=modules.toArray(new ModuleDef[modules.size()]);
    for (    ModuleDef moduleDef : moduleArray) {
      String[] servletPaths=moduleDef.getServletPaths();
      if (servletPaths.length > 0) {
        serverLogger.log(TreeLogger.WARN,""String_Node_Str"" + moduleDef.getName() + ""String_Node_Str"");
      }
    }
    servletFilter=new GWTShellServletFilter(serverLogger,options,moduleArray);
    server=launcher.start(serverLogger,getPort(),options.getOutDir(),servletFilter);
    assert(server != null);
    return server.getPort();
  }
 catch (  BindException e) {
    System.err.println(""String_Node_Str"" + getPort() + ""String_Node_Str"");
  }
catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    PerfLogger.end();
  }
  return -1;
}",0.8161290322580645
54745,"ServletContainer start(TreeLogger topLogger,int port,File appRootDir,Filter shellServletFilter) throws UnableToCompleteException ;","/** 
 * Start an embedded HTTP server.
 * @param logger the server logger
 * @param port the TCP port to serve on
 * @param appRootDir the base WAR directory
 * @param filter a servlet filter that must be installed on the root path toserve generated files
 * @return the launch servlet contained
 * @throws BindException if the requested port is already in use
 * @throws Exception if the server fails to start for any other reason
 */
ServletContainer start(TreeLogger logger,int port,File appRootDir,Filter filter) throws BindException, Exception ;",0.2852941176470588
54746,"@SuppressWarnings(""String_Node_Str"") public ServletContainer start(TreeLogger logger,int port,File appRootDir,Filter shellServletFilter) throws UnableToCompleteException {
  checkStartParams(logger,port,appRootDir);
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  JettyTreeLogger.setDefaultConstruction(logger,TreeLogger.INFO);
  System.setProperty(""String_Node_Str"",JettyTreeLogger.class.getName());
  Log.isDebugEnabled();
  if (JettyTreeLogger.isDefaultConstructionReady()) {
    Log.setLog(new JettyTreeLogger());
  }
  Server server=new Server();
  SelectChannelConnector connector=new SelectChannelConnector();
  connector.setPort(port);
  connector.setHost(""String_Node_Str"");
  server.addConnector(connector);
  WebAppContext wac=new WebAppContext(appRootDir.getAbsolutePath(),""String_Node_Str"");
  wac.getInitParams().put(""String_Node_Str"",""String_Node_Str"");
  FilterHolder filterHolder=new FilterHolder();
  filterHolder.setFilter(shellServletFilter);
  wac.addFilter(filterHolder,""String_Node_Str"",Handler.ALL);
  server.setHandler(wac);
  server.setStopAtShutdown(true);
  try {
    server.start();
    int actualPort=connector.getLocalPort();
    return new JettyServletContainer(logger,wac,actualPort,appRootDir);
  }
 catch (  Exception e) {
    logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
    throw new UnableToCompleteException();
  }
}","@SuppressWarnings(""String_Node_Str"") public ServletContainer start(TreeLogger logger,int port,File appRootDir,Filter shellServletFilter) throws Exception {
  checkStartParams(logger,port,appRootDir);
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  JettyTreeLogger.setDefaultConstruction(logger,TreeLogger.INFO);
  System.setProperty(""String_Node_Str"",JettyTreeLogger.class.getName());
  Log.isDebugEnabled();
  if (JettyTreeLogger.isDefaultConstructionReady()) {
    Log.setLog(new JettyTreeLogger());
  }
  Server server=new Server();
  SelectChannelConnector connector=new SelectChannelConnector();
  connector.setPort(port);
  connector.setHost(""String_Node_Str"");
  connector.setReuseAddress(false);
  server.addConnector(connector);
  WebAppContext wac=new WebAppContext(appRootDir.getAbsolutePath(),""String_Node_Str"");
  wac.getInitParams().put(""String_Node_Str"",""String_Node_Str"");
  FilterHolder filterHolder=new FilterHolder();
  filterHolder.setFilter(shellServletFilter);
  wac.addFilter(filterHolder,""String_Node_Str"",Handler.ALL);
  server.setHandler(wac);
  server.setStopAtShutdown(true);
  server.start();
  return new JettyServletContainer(logger,wac,connector.getLocalPort(),appRootDir);
}",0.8546085615117625
54747,"public static void main(String[] args){
  BootStrapPlatform.init();
  GWTHosted shellMain=new GWTHosted();
  if (shellMain.processArgs(args)) {
    shellMain.run();
  }
  System.exit(0);
}","public static void main(String[] args){
  GWTHosted shellMain=new GWTHosted();
  if (shellMain.processArgs(args)) {
    shellMain.run();
  }
  System.exit(0);
}",0.9195402298850576
54748,"public static void main(String[] args){
  BootStrapPlatform.init();
  GWTShell shellMain=new GWTShell();
  if (shellMain.processArgs(args)) {
    shellMain.run();
  }
  System.exit(0);
}","public static void main(String[] args){
  GWTShell shellMain=new GWTShell();
  if (shellMain.processArgs(args)) {
    shellMain.run();
  }
  System.exit(0);
}",0.9186046511627908
54749,"/** 
 * Sets up all the major aspects of running the shell graphically, including creating the main window and optionally starting the embedded Tomcat server.
 */
public void run(){
  try {
    BootStrapPlatform.applyPlatformHacks();
    if (!startUp()) {
      return;
    }
    BootStrapPlatform.maybeInitializeAWT();
    launchStartupUrls(getTopLogger());
    pumpEventLoop();
    shutDown();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Sets up all the major aspects of running the shell graphically, including creating the main window and optionally starting the embedded Tomcat server.
 */
public void run(){
  try {
    if (!startUp()) {
      return;
    }
    BootStrapPlatform.maybeInitializeAWT();
    launchStartupUrls(getTopLogger());
    pumpEventLoop();
    shutDown();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9491916859122402
54750,"protected GWTShell(boolean forceServer,boolean noURLs){
  registerHandler(getArgHandlerPort());
  if (!forceServer) {
    registerHandler(new ArgHandlerNoServerFlag());
  }
  registerHandler(new ArgHandlerWhitelist());
  registerHandler(new ArgHandlerBlacklist());
  registerHandler(new ArgHandlerLogLevel(options));
  registerHandler(new ArgHandlerGenDir(options));
  registerHandler(new ArgHandlerExtraDir(options));
  if (!noURLs) {
    registerHandler(new ArgHandlerStartupURLsExtra());
  }
  registerHandler(new ArgHandlerOutDir(options));
  registerHandler(new ArgHandlerScriptStyle(options));
  registerHandler(new ArgHandlerEnableAssertions(options));
  registerHandler(new ArgHandlerDisableAggressiveOptimization(options));
}","protected GWTShell(boolean forceServer,boolean noURLs){
  BootStrapPlatform.init();
  BootStrapPlatform.applyPlatformHacks();
  registerHandler(getArgHandlerPort());
  if (!forceServer) {
    registerHandler(new ArgHandlerNoServerFlag());
  }
  registerHandler(new ArgHandlerWhitelist());
  registerHandler(new ArgHandlerBlacklist());
  registerHandler(new ArgHandlerLogLevel(options));
  registerHandler(new ArgHandlerGenDir(options));
  registerHandler(new ArgHandlerExtraDir(options));
  if (!noURLs) {
    registerHandler(new ArgHandlerStartupURLsExtra());
  }
  registerHandler(new ArgHandlerOutDir(options));
  registerHandler(new ArgHandlerScriptStyle(options));
  registerHandler(new ArgHandlerEnableAssertions(options));
  registerHandler(new ArgHandlerDisableAggressiveOptimization(options));
}",0.9544863459037712
54751,"/** 
 * Retrieves the JUnitShell. This should only be invoked during TestRunner execution of JUnit tests.
 */
private static JUnitShell getUnitTestShell(){
  if (unitTestShell == null) {
    BootStrapPlatform.init();
    BootStrapPlatform.applyPlatformHacks();
    unitTestShell=new JUnitShell();
    unitTestShell.lastLaunchFailed=true;
    String[] args=unitTestShell.synthesizeArgs();
    if (!unitTestShell.processArgs(args)) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.messageQueue=new JUnitMessageQueue(unitTestShell.numClients);
    if (!unitTestShell.startUp()) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.lastLaunchFailed=false;
  }
  return unitTestShell;
}","/** 
 * Retrieves the JUnitShell. This should only be invoked during TestRunner execution of JUnit tests.
 */
private static JUnitShell getUnitTestShell(){
  if (unitTestShell == null) {
    unitTestShell=new JUnitShell();
    unitTestShell.lastLaunchFailed=true;
    String[] args=unitTestShell.synthesizeArgs();
    if (!unitTestShell.processArgs(args)) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.messageQueue=new JUnitMessageQueue(unitTestShell.numClients);
    if (!unitTestShell.startUp()) {
      throw new JUnitFatalLaunchException(""String_Node_Str"");
    }
    unitTestShell.lastLaunchFailed=false;
  }
  return unitTestShell;
}",0.9484679665738162
54752,"/** 
 * Returns <code>true</code>if the object is an instance of EventListener and the object belongs to this module.
 */
protected static boolean isMyListener(Object object){
  return object instanceof com.google.gwt.user.client.EventListener && !(object instanceof JavaScriptObject);
}","/** 
 * Returns <code>true</code>if the object is an instance of EventListener and the object belongs to this module.
 */
protected static boolean isMyListener(Object object){
  return !(object instanceof JavaScriptObject) && (object instanceof com.google.gwt.user.client.EventListener);
}",0.8576388888888888
54753,"@Override public boolean add(E o){
  return map.put(o,this) == null;
}","@Override public boolean add(E o){
  return map.put(o,Boolean.FALSE) == null;
}",0.8859060402684564
54754,"/** 
 * Used to wrap subset maps in a new TreeSet.
 * @param map map to use for backing store
 */
private TreeSet(SortedMap<E,Object> map){
  this.map=map;
}","/** 
 * Used to wrap subset maps in a new TreeSet.
 * @param map map to use for backing store
 */
private TreeSet(SortedMap<E,Boolean> map){
  this.map=map;
}",0.9650793650793652
54755,"public int compare(String a,String b){
  if (a == null || b == null) {
    throw new NullPointerException();
  }
  return b.compareTo(a);
}","public int compare(T a,T b){
  if (a == null || b == null) {
    throw new NullPointerException();
  }
  return b.compareTo(a);
}",0.9477611940298508
54756,"public static TreeMap<String,MarkerTypeTreeMap> createTreeMap(boolean defaultComparator){
  TreeMap<String,MarkerTypeTreeMap> map;
  if (defaultComparator) {
    map=new TreeMap<String,MarkerTypeTreeMap>();
  }
 else {
    map=new TreeMap<String,MarkerTypeTreeMap>(new ReverseSorter());
  }
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  return map;
}","public static TreeMap<String,MarkerTypeTreeMap> createTreeMap(boolean defaultComparator){
  TreeMap<String,MarkerTypeTreeMap> map;
  if (defaultComparator) {
    map=new TreeMap<String,MarkerTypeTreeMap>();
  }
 else {
    map=new TreeMap<String,MarkerTypeTreeMap>(new ReverseSorter<String>());
  }
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  map.put(""String_Node_Str"",new MarkerTypeTreeMap(""String_Node_Str""));
  return map;
}",0.9939849624060152
54757,"/** 
 * Gets the text currently selected within this text box.
 * @return the selected text, or an empty string if none is selected
 */
public String getSelectedText(){
  int start=getCursorPos(), length=getSelectionLength();
  return getText().substring(start,start + length);
}","/** 
 * Gets the text currently selected within this text box.
 * @return the selected text, or an empty string if none is selected
 */
public String getSelectedText(){
  int start=getCursorPos();
  if (start < 0) {
    return ""String_Node_Str"";
  }
  int length=getSelectionLength();
  return getText().substring(start,start + length);
}",0.6482982171799028
54758,"/** 
 * Sets the cursor position.
 * @param pos the new cursor position
 */
public void setCursorPos(int pos){
  setSelectionRange(pos,0);
}","/** 
 * Sets the cursor position. This will only work when the widget is attached to the document and not hidden.
 * @param pos the new cursor position
 */
public void setCursorPos(int pos){
  setSelectionRange(pos,0);
}",0.7777777777777778
54759,"/** 
 * Selects all of the text in the box. This will only work when the widget is attached to the document.
 */
public void selectAll(){
  int length=getText().length();
  if (length > 0) {
    setSelectionRange(0,length);
  }
}","/** 
 * Selects all of the text in the box. This will only work when the widget is attached to the document and not hidden.
 */
public void selectAll(){
  int length=getText().length();
  if (length > 0) {
    setSelectionRange(0,length);
  }
}",0.9682875264270612
54760,"/** 
 * Sets the range of text to be selected. This will only work when the widget is attached to the document.
 * @param pos the position of the first character to be selected
 * @param length the number of characters to be selected
 */
public void setSelectionRange(int pos,int length){
  if (!isAttached()) {
    return;
  }
  if (length < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + length);
  }
  if ((pos < 0) || (length + pos > getText().length())) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + pos + ""String_Node_Str""+ (pos + length)+ ""String_Node_Str""+ getText().length());
  }
  impl.setSelectionRange(getElement(),pos,length);
}","/** 
 * Sets the range of text to be selected. This will only work when the widget is attached to the document and not hidden.
 * @param pos the position of the first character to be selected
 * @param length the number of characters to be selected
 */
public void setSelectionRange(int pos,int length){
  if (!isAttached()) {
    return;
  }
  if (length < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + length);
  }
  if ((pos < 0) || (length + pos > getText().length())) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + pos + ""String_Node_Str""+ (pos + length)+ ""String_Node_Str""+ getText().length());
  }
  impl.setSelectionRange(getElement(),pos,length);
}",0.9890270665691296
54761,"/** 
 * Tests various text selection methods in text area.
 */
public void disabledTestSelection(){
  TextBoxBase area=createTextBoxBase();
  assertEquals(""String_Node_Str"",area.getSelectedText());
  area.selectAll();
  assertEquals(0,area.getSelectionLength());
  try {
    area.setSelectionRange(0,1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  RootPanel.get().add(area);
  area.setText(""String_Node_Str"");
  area.selectAll();
  assertEquals(1,area.getSelectionLength());
  area.setText(""String_Node_Str"");
  assertEquals(0,area.getSelectionLength());
  area.setText(""String_Node_Str"");
  area.setSelectionRange(2,2);
  assertEquals(2,area.getCursorPos());
  area.setSelectionRange(0,0);
}","/** 
 * Tests various text selection methods in text area.
 */
public void disabledTestSelection(){
  TextBoxBase area=createTextBoxBase();
  assertEquals(""String_Node_Str"",area.getSelectedText());
  area.selectAll();
  assertEquals(0,area.getSelectionLength());
  try {
    area.setSelectionRange(0,1);
    fail(""String_Node_Str"");
  }
 catch (  IndexOutOfBoundsException e) {
  }
  RootPanel.get().add(area);
  area.setText(""String_Node_Str"");
  area.selectAll();
  assertEquals(1,area.getSelectionLength());
  area.setText(""String_Node_Str"");
  assertEquals(0,area.getSelectionLength());
  area.setText(""String_Node_Str"");
  area.setSelectionRange(2,2);
  assertEquals(2,area.getCursorPos());
  area.setSelectionRange(0,0);
{
    TextBoxBase area2=createTextBoxBase();
    area2.setVisible(false);
    RootPanel.get().add(area2);
    area.selectAll();
  }
}",0.9168765743073048
54762,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new TestFireEvents());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue1932());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2390());
  addIssue(new Issue1169());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new Issue2553());
  addIssue(new TreeVisuals());
  addIssue(new TestFireEvents());
}",0.9427480916030534
54763,"@Override void initializeClonableElements(){
  super.initializeClonableElements();
  if (GWT.isClient()) {
    DOM.setElementPropertyInt(BASE_INTERNAL_ELEM,""String_Node_Str"",0);
    DOM.setElementPropertyInt(BASE_INTERNAL_ELEM,""String_Node_Str"",0);
    BASE_INTERNAL_ELEM.getStyle().setPropertyPx(""String_Node_Str"",3);
    DOM.setStyleAttribute(BASE_BARE_ELEM,""String_Node_Str"",""String_Node_Str"");
    DOM.setStyleAttribute(BASE_BARE_ELEM,""String_Node_Str"",""String_Node_Str"");
  }
}","@Override void initializeClonableElements(){
  super.initializeClonableElements();
  if (GWT.isClient()) {
    DOM.setStyleAttribute(BASE_BARE_ELEM,""String_Node_Str"",""String_Node_Str"");
    DOM.setStyleAttribute(BASE_BARE_ELEM,""String_Node_Str"",""String_Node_Str"");
  }
}",0.3936170212765957
54764,"public void onMouseUp(Widget sender,int x,int y){
  dragging=false;
  DOM.releaseCapture(caption.getElement());
}","public void onMouseUp(Widget sender,int x,int y){
  dragging=false;
  DOM.releaseCapture(getElement());
}",0.963302752293578
54765,"public void onMouseDown(Widget sender,int x,int y){
  dragging=true;
  DOM.setCapture(caption.getElement());
  dragStartX=x;
  dragStartY=y;
}","public void onMouseDown(Widget sender,int x,int y){
  dragging=true;
  DOM.setCapture(getElement());
  dragStartX=x;
  dragStartY=y;
}",0.9710144927536232
54766,"/** 
 * Creates an empty dialog box specifying its ""auto-hide"" property. It should not be shown until its child widget has been added using  {@link #add(Widget)}.
 * @param autoHide <code>true</code> if the dialog should be automaticallyhidden when the user clicks outside of it
 * @param modal <code>true</code> if keyboard and mouse events for widgetsnot contained by the dialog should be ignored
 */
public DialogBox(boolean autoHide,boolean modal){
  super(autoHide,modal,""String_Node_Str"");
  Element td=getCellElement(0,1);
  DOM.appendChild(td,caption.getElement());
  adopt(caption);
  caption.setStyleName(""String_Node_Str"");
  caption.addMouseListener(this);
  setStyleName(DEFAULT_STYLENAME);
}","/** 
 * Creates an empty dialog box specifying its ""auto-hide"" property. It should not be shown until its child widget has been added using  {@link #add(Widget)}.
 * @param autoHide <code>true</code> if the dialog should be automaticallyhidden when the user clicks outside of it
 * @param modal <code>true</code> if keyboard and mouse events for widgetsnot contained by the dialog should be ignored
 */
public DialogBox(boolean autoHide,boolean modal){
  super(autoHide,modal,""String_Node_Str"");
  Element td=getCellElement(0,1);
  DOM.appendChild(td,caption.getElement());
  adopt(caption);
  caption.setStyleName(""String_Node_Str"");
  mouseListeners.add(this);
  setStyleName(DEFAULT_STYLENAME);
  sinkEvents(Event.MOUSEEVENTS);
}",0.953375086986778
54767,"/** 
 * Called only from   {@link TreeItem}: Shows the leaf image on a tree item.
 * @param treeItem the tree item
 */
void showLeafImage(TreeItem treeItem){
  if (useLeafImages) {
    showImage(treeItem,images.treeLeaf());
  }
 else {
    DOM.setStyleAttribute(treeItem.getElement(),""String_Node_Str"",indentValue);
  }
}","/** 
 * Called only from   {@link TreeItem}: Shows the leaf image on a tree item.
 * @param treeItem the tree item
 */
void showLeafImage(TreeItem treeItem){
  if (useLeafImages || treeItem.isFullNode()) {
    showImage(treeItem,images.treeLeaf());
  }
 else {
    DOM.setStyleAttribute(treeItem.getElement(),""String_Node_Str"",indentValue);
  }
}",0.9625187406296852
54768,"Element getImageHolderElement(){
  if (imageHolder == null) {
    convertToFullNode();
  }
  return imageHolder;
}","Element getImageHolderElement(){
  if (!isFullNode()) {
    convertToFullNode();
  }
  return imageHolder;
}",0.8918918918918919
54769,"@Override protected void nativeUpdate(String historyToken){
  if (isOldSafari) {
    nativeUpdateImpl(historyToken);
  }
 else {
    super.nativeUpdate(historyToken);
  }
}","@Override protected void nativeUpdate(String historyToken){
  if (isOldSafari) {
    oldNativeUpdate(historyToken);
  }
 else {
    newNativeUpdate(historyToken);
  }
}",0.9470588235294116
54770,"public void onHistoryChanged(String historyToken){
  if (historyToken == null) {
    fail(""String_Node_Str"");
  }
  assertEquals(token,historyToken);
  finishTest();
}","public void onHistoryChanged(String historyToken){
  counter.add(new Object());
  assertFalse(""String_Node_Str"",isBorked());
}",0.6006825938566553
54771,public native int getBodyOffsetTop();,@Override public native int getBodyOffsetTop();,0.8809523809523809
54772,public native int getBodyOffsetLeft();,@Override public native int getBodyOffsetLeft();,0.8837209302325582
54773,"public static String getStackTraceAsString(Throwable e){
  StringBuffer message=new StringBuffer();
  Throwable currentCause=e;
  String causedBy=""String_Node_Str"";
  HashSet<Throwable> seenCauses=new HashSet<Throwable>();
  while (currentCause != null && !seenCauses.contains(currentCause)) {
    seenCauses.add(currentCause);
    message.append(causedBy);
    causedBy=""String_Node_Str"";
    message.append(currentCause.getClass().getName());
    message.append(""String_Node_Str"" + currentCause.getMessage());
    StackTraceElement[] stackElems=currentCause.getStackTrace();
    if (stackElems != null) {
      for (int i=0; i < stackElems.length; ++i) {
        message.append(""String_Node_Str"");
        message.append(stackElems[i].toString());
      }
    }
    currentCause=currentCause.getCause();
  }
  return message.toString();
}","public static String getStackTraceAsString(Throwable e){
  if (e == null || e instanceof UnableToCompleteException) {
    return null;
  }
  StringBuffer message=new StringBuffer();
  Throwable currentCause=e;
  String causedBy=""String_Node_Str"";
  HashSet<Throwable> seenCauses=new HashSet<Throwable>();
  while (currentCause != null && !seenCauses.contains(currentCause)) {
    seenCauses.add(currentCause);
    message.append(causedBy);
    causedBy=""String_Node_Str"";
    message.append(currentCause.getClass().getName());
    message.append(""String_Node_Str"" + currentCause.getMessage());
    StackTraceElement[] stackElems=currentCause.getStackTrace();
    if (stackElems != null) {
      for (int i=0; i < stackElems.length; ++i) {
        message.append(""String_Node_Str"");
        message.append(stackElems[i].toString());
      }
    }
    currentCause=currentCause.getCause();
  }
  return message.toString();
}",0.9534619750283768
54774,"public LogEvent(TreeItemLogger logger,boolean isBranchCommit,int index,Type type,String message,Throwable caught,HelpInfo helpInfo){
  this.logger=logger;
  this.isBranchCommit=isBranchCommit;
  this.index=index;
  this.type=type;
  this.message=message;
  this.caught=caught;
  this.helpInfo=helpInfo;
}","public LogEvent(TreeItemLogger logger,boolean isBranchCommit,int index,Type type,String message,Throwable caught,HelpInfo helpInfo){
  this.exceptionDetail=AbstractTreeLogger.getStackTraceAsString(caught);
  this.exceptionName=AbstractTreeLogger.getExceptionName(caught);
  this.logger=logger;
  this.isBranchCommit=isBranchCommit;
  this.index=index;
  this.type=type;
  this.message=message;
  this.helpInfo=helpInfo;
}",0.7779310344827586
54775,"/** 
 * Creates a tree item in a way that is sensitive to the log event and its position in the tree.
 */
private TreeItem createTreeItem(Tree tree){
  TreeItem treeItem=null;
  if (isBranchCommit) {
    TreeItemLogger parentLogger=(TreeItemLogger)logger.getParentLogger();
    if (parentLogger.lazyTreeItem == null) {
      treeItem=new TreeItem(tree,SWT.NONE);
      logger.lazyTreeItem=treeItem;
    }
 else     if (!parentLogger.lazyTreeItem.isDisposed()) {
      treeItem=new TreeItem(parentLogger.lazyTreeItem,SWT.NONE);
      logger.lazyTreeItem=treeItem;
    }
 else {
      parentLogger.markLoggerDead();
      return null;
    }
  }
 else {
    if (logger.lazyTreeItem == null) {
      treeItem=new TreeItem(tree,SWT.NONE);
    }
 else     if (!logger.lazyTreeItem.isDisposed()) {
      treeItem=new TreeItem(logger.lazyTreeItem,SWT.NONE);
    }
 else {
      logger.markLoggerDead();
      return null;
    }
  }
  String label=message;
  if (label == null) {
    if (caught != null) {
      label=caught.getMessage();
      if (label == null || label.trim().length() == 0) {
        label=caught.toString();
      }
    }
  }
  treeItem.setText(label);
  if (helpInfo != null) {
    URL url=helpInfo.getURL();
    if (url != null) {
      TreeItem helpItem=new TreeItem(treeItem,SWT.NONE);
      helpItem.setImage(imageLink);
      helpItem.setText(""String_Node_Str"" + url.toString());
      helpItem.setForeground(helpItem.getDisplay().getSystemColor(SWT.COLOR_BLUE));
      helpItem.setData(helpInfo);
      treeItem.setExpanded(true);
    }
  }
  treeItem.setData(this);
  return treeItem;
}","/** 
 * Creates a tree item in a way that is sensitive to the log event and its position in the tree.
 */
private TreeItem createTreeItem(Tree tree){
  TreeItem treeItem=null;
  if (isBranchCommit) {
    TreeItemLogger parentLogger=(TreeItemLogger)logger.getParentLogger();
    if (parentLogger.lazyTreeItem == null) {
      treeItem=new TreeItem(tree,SWT.NONE);
      logger.lazyTreeItem=treeItem;
    }
 else     if (!parentLogger.lazyTreeItem.isDisposed()) {
      treeItem=new TreeItem(parentLogger.lazyTreeItem,SWT.NONE);
      logger.lazyTreeItem=treeItem;
    }
 else {
      parentLogger.markLoggerDead();
      return null;
    }
  }
 else {
    if (logger.lazyTreeItem == null) {
      treeItem=new TreeItem(tree,SWT.NONE);
    }
 else     if (!logger.lazyTreeItem.isDisposed()) {
      treeItem=new TreeItem(logger.lazyTreeItem,SWT.NONE);
    }
 else {
      logger.markLoggerDead();
      return null;
    }
  }
  String label=message;
  if (label == null) {
    assert(exceptionName != null);
    label=exceptionName;
  }
  treeItem.setText(label);
  if (helpInfo != null) {
    URL url=helpInfo.getURL();
    if (url != null) {
      TreeItem helpItem=new TreeItem(treeItem,SWT.NONE);
      helpItem.setImage(imageLink);
      helpItem.setText(""String_Node_Str"" + url.toString());
      helpItem.setForeground(helpItem.getDisplay().getSystemColor(SWT.COLOR_BLUE));
      helpItem.setData(helpInfo);
      treeItem.setExpanded(true);
    }
  }
  treeItem.setData(this);
  return treeItem;
}",0.9449983917658412
54776,"private void syncDetailsPane(TreeItem item){
  TreeItemLogger.LogEvent logEvent=null;
  Object testLogEvent=item.getData();
  if (testLogEvent instanceof TreeItemLogger.LogEvent) {
    logEvent=(LogEvent)testLogEvent;
  }
  StringBuffer sb=new StringBuffer();
  if (logEvent != null && logEvent.type != null) {
    sb.append(""String_Node_Str"");
    sb.append(logEvent.type.getLabel());
    sb.append(""String_Node_Str"");
  }
  sb.append(item.getText());
  sb.append(""String_Node_Str"");
  if (logEvent != null && logEvent.caught != null) {
    if (!(logEvent.caught instanceof UnableToCompleteException)) {
      String stackTrace=AbstractTreeLogger.getStackTraceAsString(logEvent.caught);
      sb.append(stackTrace);
    }
  }
  details.setText(sb.toString());
}","private void syncDetailsPane(TreeItem item){
  TreeItemLogger.LogEvent logEvent=null;
  Object testLogEvent=item.getData();
  if (testLogEvent instanceof TreeItemLogger.LogEvent) {
    logEvent=(LogEvent)testLogEvent;
  }
  StringBuffer sb=new StringBuffer();
  if (logEvent != null && logEvent.type != null) {
    sb.append(""String_Node_Str"");
    sb.append(logEvent.type.getLabel());
    sb.append(""String_Node_Str"");
  }
  sb.append(item.getText());
  sb.append(""String_Node_Str"");
  if (logEvent != null && logEvent.exceptionDetail != null) {
    sb.append(logEvent.exceptionDetail);
  }
  details.setText(sb.toString());
}",0.7760979121670266
54777,"/** 
 * Embed a script on the outer window and use it to initialize an event.
 * @param initFunc the string representation of the init function
 * @param funcName the name to assign to the init function
 * @param cmd the command to execute the init function
 */
private static void initHandler(String initFunc,String funcName,Command cmd){
  if (GWT.isClient()) {
    maybeInitializeCloseHandlers();
    initFunc=initFunc.replaceFirst(""String_Node_Str"",""String_Node_Str"" + funcName);
    ScriptElement scriptElem=Document.get().createScriptElement(initFunc);
    Document.get().getBody().appendChild(scriptElem);
    cmd.execute();
    RootPanel.getBodyElement().removeChild(scriptElem);
  }
}","/** 
 * Initialize an event on the outer window.
 * @param initFunc the string representation of the init function
 * @param funcName the name to assign to the init function
 * @param cmd the command to execute the init function
 */
private static void initHandler(String initFunc,String funcName,Command cmd){
  if (GWT.isClient()) {
    maybeInitializeCloseHandlers();
    impl.initHandler(initFunc,funcName,cmd);
  }
}",0.6732495511669659
54778,"public void visitLocalVariable(final String name,final String desc,final String signature,final Label start,final Label end,final int index){
  if (signature != null) {
    if (localVarType == null) {
      localVarType=new ByteVector();
    }
    ++localVarTypeCount;
    localVarType.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature)).putShort(index);
  }
  if (localVar == null) {
    localVar=new ByteVector();
  }
  ++localVarCount;
  localVar.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc)).putShort(index);
  if (compute != NOTHING) {
    char c=desc.charAt(0);
    int n=index + (c == 'J' || c == 'D' ? 2 : 1);
    if (n > maxLocals) {
      maxLocals=n;
    }
  }
}","public void visitLocalVariable(final String name,final String desc,final String signature,final Label start,final Label end,final int index){
  if (((start.status & labels.RESOLVED) != 0) && ((end.status & labels.RESOLVED) != 0)) {
    if (signature != null) {
      if (localVarType == null) {
        localVarType=new ByteVector();
      }
      ++localVarTypeCount;
      localVarType.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature)).putShort(index);
    }
    if (localVar == null) {
      localVar=new ByteVector();
    }
    ++localVarCount;
    localVar.putShort(start.position).putShort(end.position - start.position).putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc)).putShort(index);
  }
  if (compute != NOTHING) {
    char c=desc.charAt(0);
    int n=index + (c == 'J' || c == 'D' ? 2 : 1);
    if (n > maxLocals) {
      maxLocals=n;
    }
  }
}",0.9327251995438997
54779,"/** 
 * Attempts to get a named deferred binding property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return a value for the property
 */
String getPropertyValue(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property. Throws <code>BadPropertyValueException</code> if the property is either undefined or has a value that is unsupported. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return a value for the property
 */
String getPropertyValue(TreeLogger logger,String propertyName) throws BadPropertyValueException ;",0.8974069898534386
54780,"/** 
 * Attempts to get a named deferred binding property and returns the list of possible values. Throws <code>BadPropertyValueException</code> if the property is undefined.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return the possible values for the property
 */
String[] getPropertyValueSet(TreeLogger logger,String propertyName) throws BadPropertyValueException ;","/** 
 * Attempts to get a named deferred binding property and returns the list of possible values. Throws <code>BadPropertyValueException</code> if the property is undefined. The result of invoking this method with the same <code>propertyName</code> must be stable.
 * @param logger the current logger
 * @param propertyName the name of the property
 * @return the possible values for the property
 */
String[] getPropertyValueSet(TreeLogger logger,String propertyName) throws BadPropertyValueException ;",0.900763358778626
54781,"public DistillerRebindPermutationOracle(ArtifactSet generatorArtifacts,PropertyPermutations perms){
  rebindOracles=new CompilationRebindOracle[perms.size()];
  Property[] orderedProps=perms.getOrderedProperties();
  for (int i=0; i < rebindOracles.length; ++i) {
    String[] orderedPropValues=perms.getOrderedPropertyValues(i);
    StaticPropertyOracle propOracle=new StaticPropertyOracle(orderedProps,orderedPropValues);
    rebindOracles[i]=new CompilationRebindOracle(generatorArtifacts,propOracle);
  }
}","public DistillerRebindPermutationOracle(ArtifactSet generatorArtifacts,PropertyPermutations perms){
  propertyOracles=new StaticPropertyOracle[perms.size()];
  rebindOracles=new RebindOracle[perms.size()];
  Property[] orderedProps=perms.getOrderedProperties();
  for (int i=0; i < rebindOracles.length; ++i) {
    String[] orderedPropValues=perms.getOrderedPropertyValues(i);
    propertyOracles[i]=new StaticPropertyOracle(orderedProps,orderedPropValues);
    rebindOracles[i]=new StandardRebindOracle(compilationState,propertyOracles[i],module,rules,genDir,generatorResourcesDir,generatorArtifacts);
  }
}",0.6744186046511628
54782,"public String[] getAllPossibleRebindAnswers(TreeLogger logger,String requestTypeName) throws UnableToCompleteException {
  String msg=""String_Node_Str"" + requestTypeName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.DEBUG,msg,null);
  Set<String> answers=new HashSet<String>();
  for (  CompilationRebindOracle rebindOracle : rebindOracles) {
    String resultTypeName=rebindOracle.rebind(logger,requestTypeName);
    answers.add(resultTypeName);
  }
  return Util.toArray(String.class,answers);
}","public String[] getAllPossibleRebindAnswers(TreeLogger logger,String requestTypeName) throws UnableToCompleteException {
  String msg=""String_Node_Str"" + requestTypeName + ""String_Node_Str"";
  logger=logger.branch(TreeLogger.DEBUG,msg,null);
  Set<String> answers=new HashSet<String>();
  for (  RebindOracle rebindOracle : rebindOracles) {
    String resultTypeName=rebindOracle.rebind(logger,requestTypeName);
    answers.add(resultTypeName);
  }
  return Util.toArray(String.class,answers);
}",0.989010989010989
54783,"public CompilationRebindOracle getRebindOracle(int permNumber){
  return rebindOracles[permNumber];
}","public RebindOracle getRebindOracle(int permNumber){
  return rebindOracles[permNumber];
}",0.9424083769633508
54784,"private void compilePermutations(TreeLogger logger,JavaToJavaScriptCompiler jjs,DistillerRebindPermutationOracle rpo,StandardLinkerContext linkerContext) throws UnableToCompleteException {
  int permCount=rpo.getPermuationCount();
  PerfLogger.start(""String_Node_Str"" + permCount + ""String_Node_Str"");
  Permutation[] perms=new Permutation[permCount];
  for (int i=0; i < permCount; ++i) {
    CompilationRebindOracle rebindOracle=rpo.getRebindOracle(i);
    perms[i]=new Permutation(i,rebindOracle,rebindOracle.getPropertyOracle());
  }
  PermutationCompiler permCompiler=new PermutationCompiler(logger,jjs,perms);
  permCompiler.go(linkerContext);
}","private void compilePermutations(TreeLogger logger,JavaToJavaScriptCompiler jjs,DistillerRebindPermutationOracle rpo,StandardLinkerContext linkerContext) throws UnableToCompleteException {
  int permCount=rpo.getPermuationCount();
  PerfLogger.start(""String_Node_Str"" + permCount + ""String_Node_Str"");
  Permutation[] perms=new Permutation[permCount];
  for (int i=0; i < permCount; ++i) {
    perms[i]=new Permutation(i,rpo.getRebindOracle(i),rpo.getPropertyOracle(i));
  }
  PermutationCompiler permCompiler=new PermutationCompiler(logger,jjs,perms);
  permCompiler.go(linkerContext);
}",0.9249394673123488
54785,"public StaticPropertyOracle getPropertyOracle(){
  return propOracle;
}","public StaticPropertyOracle getPropertyOracle(int permNumber){
  return propertyOracles[permNumber];
}",0.8208092485549133
54786,"public String rebind(TreeLogger logger,String typeName) throws UnableToCompleteException {
  logger=Messages.TRACE_TOPLEVEL_REBIND.branch(logger,typeName,null);
  Rebinder rebinder=new Rebinder();
  String result=rebinder.rebind(logger,typeName);
  Messages.TRACE_TOPLEVEL_REBIND_RESULT.log(logger,result,null);
  return result;
}","public String rebind(TreeLogger logger,String typeName) throws UnableToCompleteException {
  String result=cache.get(typeName);
  if (result == null) {
    logger=Messages.TRACE_TOPLEVEL_REBIND.branch(logger,typeName,null);
    Rebinder rebinder=new Rebinder();
    result=rebinder.rebind(logger,typeName);
    cache.put(typeName,result);
    Messages.TRACE_TOPLEVEL_REBIND_RESULT.log(logger,result,null);
  }
  return result;
}",0.8153034300791556
54787,"private static void maybeInitializeHandlers(){
  if (GWT.isClient() && !handlersAreInitialized) {
    ScriptElement scriptElem=Document.get().createScriptElement();
    scriptElem.setText(getInitHandlerMethodString());
    Document.get().getBody().appendChild(scriptElem);
    init();
    RootPanel.getBodyElement().removeChild(scriptElem);
    handlersAreInitialized=true;
  }
}","private static void maybeInitializeHandlers(){
  if (GWT.isClient() && !handlersAreInitialized) {
    handlersAreInitialized=true;
    ScriptElement scriptElem=Document.get().createScriptElement();
    String initFunc=getInitHandlerMethodString().replaceFirst(""String_Node_Str"",""String_Node_Str"");
    scriptElem.setText(initFunc);
    Document.get().getBody().appendChild(scriptElem);
    init();
    RootPanel.getBodyElement().removeChild(scriptElem);
  }
}",0.7589498806682577
54788,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new TestFireEvents());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1772());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2392());
  addIssue(new Issue2443());
  addIssue(new TestFireEvents());
}",0.9630573248407645
54789,"/** 
 * Initializes the split panel.
 * @param mainElem the root element for the split panel
 * @param splitElem the element that acts as the splitter
 * @param headElem the element to contain the top or left most widget
 * @param tailElem the element to contain the bottom or right most widget
 */
SplitPanel(Element mainElem,Element splitElem,Element headElem,Element tailElem){
  setElement(mainElem);
  this.splitElem=splitElem;
  elements[0]=headElem;
  elements[1]=tailElem;
  sinkEvents(Event.MOUSEEVENTS);
}","/** 
 * Initializes the split panel.
 * @param mainElem the root element for the split panel
 * @param splitElem the element that acts as the splitter
 * @param headElem the element to contain the top or left most widget
 * @param tailElem the element to contain the bottom or right most widget
 */
SplitPanel(Element mainElem,Element splitElem,Element headElem,Element tailElem){
  setElement(mainElem);
  this.splitElem=splitElem;
  elements[0]=headElem;
  elements[1]=tailElem;
  sinkEvents(Event.MOUSEEVENTS | Event.ONLOSECAPTURE);
  if (glassElem == null) {
    glassElem=DOM.createDiv();
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    glassElem.getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  }
}",0.5723868082727781
54790,"private void startResizingFrom(int x,int y){
  isResizing=true;
  onSplitterResizeStarted(x,y);
}","private void startResizingFrom(int x,int y){
  isResizing=true;
  onSplitterResizeStarted(x,y);
  int height=RootPanel.getBodyElement().getScrollHeight() - 1;
  int width=RootPanel.getBodyElement().getScrollWidth() - 1;
  glassElem.getStyle().setProperty(""String_Node_Str"",height + ""String_Node_Str"");
  glassElem.getStyle().setProperty(""String_Node_Str"",width + ""String_Node_Str"");
  RootPanel.getBodyElement().appendChild(glassElem);
}",0.3632958801498127
54791,"private void stopResizing(){
  isResizing=false;
}","private void stopResizing(){
  isResizing=false;
  RootPanel.getBodyElement().removeChild(glassElem);
}",0.6535947712418301
54792,"/** 
 * Generates the client's asynchronous proxy method.
 */
private void generateProxyMethod(SourceWriter w,SerializableTypeOracle serializableTypeOracle,JMethod syncMethod,JMethod asyncMethod){
  w.println();
  JType asyncReturnType=asyncMethod.getReturnType();
  w.print(""String_Node_Str"");
  w.print(asyncReturnType.getQualifiedSourceName());
  w.print(""String_Node_Str"");
  w.print(asyncMethod.getName() + ""String_Node_Str"");
  boolean needsComma=false;
  boolean needsTryCatchBlock=false;
  NameFactory nameFactory=new NameFactory();
  JParameter[] asyncParams=asyncMethod.getParameters();
  for (int i=0; i < asyncParams.length; ++i) {
    JParameter param=asyncParams[i];
    if (needsComma) {
      w.print(""String_Node_Str"");
    }
 else {
      needsComma=true;
    }
    JType paramType=param.getType();
    if (i < asyncParams.length - 1 && paramType.isPrimitive() == null && !paramType.getQualifiedSourceName().equals(String.class.getCanonicalName())) {
      needsTryCatchBlock=true;
    }
    w.print(paramType.getParameterizedQualifiedSourceName());
    w.print(""String_Node_Str"");
    String paramName=param.getName();
    nameFactory.addName(paramName);
    w.print(paramName);
  }
  w.println(""String_Node_Str"");
  w.indent();
  String requestIdName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + requestIdName + ""String_Node_Str"");
  String statsMethodExpr=getProxySimpleName() + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"";
  String tossName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + tossName + ""String_Node_Str""+ statsMethodExpr+ ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.print(ClientSerializationStreamWriter.class.getSimpleName());
  w.print(""String_Node_Str"");
  String streamWriterName=nameFactory.createName(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  w.println(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  if (needsTryCatchBlock) {
    w.println(""String_Node_Str"");
    w.indent();
  }
  if (!shouldEnforceTypeVersioning()) {
    w.println(streamWriterName + ""String_Node_Str"" + ClientSerializationStreamReader.class.getName()+ ""String_Node_Str"");
  }
  w.println(streamWriterName + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"");
  JParameter[] syncParams=syncMethod.getParameters();
  w.println(streamWriterName + ""String_Node_Str"" + syncParams.length+ ""String_Node_Str"");
  for (  JParameter param : syncParams) {
    w.println(streamWriterName + ""String_Node_Str"" + serializableTypeOracle.getSerializedTypeName(param.getType())+ ""String_Node_Str"");
  }
  for (int i=0; i < asyncParams.length - 1; ++i) {
    JParameter asyncParam=asyncParams[i];
    w.print(streamWriterName + ""String_Node_Str"");
    w.print(Shared.getStreamWriteMethodNameFor(asyncParam.getType()));
    w.println(""String_Node_Str"" + asyncParam.getName() + ""String_Node_Str"");
  }
  JParameter callbackParam=asyncParams[asyncParams.length - 1];
  String callbackName=callbackParam.getName();
  if (needsTryCatchBlock) {
    w.outdent();
    w.print(""String_Node_Str"");
    String exceptionName=nameFactory.createName(""String_Node_Str"");
    w.println(exceptionName + ""String_Node_Str"");
    w.indent();
    w.println(callbackName + ""String_Node_Str"" + exceptionName+ ""String_Node_Str"");
    w.outdent();
    w.println(""String_Node_Str"");
  }
  w.println();
  String payloadName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + payloadName + ""String_Node_Str""+ streamWriterName+ ""String_Node_Str"");
  w.println(tossName + ""String_Node_Str"" + statsMethodExpr+ ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  if (asyncReturnType == JPrimitiveType.VOID) {
    w.print(""String_Node_Str"");
  }
 else   if (asyncReturnType.getQualifiedSourceName().equals(RequestBuilder.class.getName())) {
    w.print(""String_Node_Str"");
  }
 else   if (asyncReturnType.getQualifiedSourceName().equals(Request.class.getName())) {
    w.print(""String_Node_Str"");
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + asyncReturnType.getQualifiedSourceName());
  }
  JType returnType=syncMethod.getReturnType();
  w.print(""String_Node_Str"" + getResponseReaderFor(returnType).name());
  w.println(""String_Node_Str"" + getProxySimpleName() + ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str""+ payloadName+ ""String_Node_Str""+ callbackName+ ""String_Node_Str"");
  w.outdent();
  w.println(""String_Node_Str"");
}","/** 
 * Generates the client's asynchronous proxy method.
 */
private void generateProxyMethod(SourceWriter w,SerializableTypeOracle serializableTypeOracle,JMethod syncMethod,JMethod asyncMethod){
  w.println();
  JType asyncReturnType=asyncMethod.getReturnType().getErasedType();
  w.print(""String_Node_Str"");
  w.print(asyncReturnType.getQualifiedSourceName());
  w.print(""String_Node_Str"");
  w.print(asyncMethod.getName() + ""String_Node_Str"");
  boolean needsComma=false;
  boolean needsTryCatchBlock=false;
  NameFactory nameFactory=new NameFactory();
  JParameter[] asyncParams=asyncMethod.getParameters();
  for (int i=0; i < asyncParams.length; ++i) {
    JParameter param=asyncParams[i];
    if (needsComma) {
      w.print(""String_Node_Str"");
    }
 else {
      needsComma=true;
    }
    JType paramType=param.getType();
    paramType=paramType.getErasedType();
    if (i < asyncParams.length - 1 && paramType.isPrimitive() == null && !paramType.getQualifiedSourceName().equals(String.class.getCanonicalName())) {
      needsTryCatchBlock=true;
    }
    w.print(paramType.getQualifiedSourceName());
    w.print(""String_Node_Str"");
    String paramName=param.getName();
    nameFactory.addName(paramName);
    w.print(paramName);
  }
  w.println(""String_Node_Str"");
  w.indent();
  String requestIdName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + requestIdName + ""String_Node_Str"");
  String statsMethodExpr=getProxySimpleName() + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"";
  String tossName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + tossName + ""String_Node_Str""+ statsMethodExpr+ ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  w.print(ClientSerializationStreamWriter.class.getSimpleName());
  w.print(""String_Node_Str"");
  String streamWriterName=nameFactory.createName(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  w.println(""String_Node_Str"");
  w.println(streamWriterName + ""String_Node_Str"");
  if (needsTryCatchBlock) {
    w.println(""String_Node_Str"");
    w.indent();
  }
  if (!shouldEnforceTypeVersioning()) {
    w.println(streamWriterName + ""String_Node_Str"" + ClientSerializationStreamReader.class.getName()+ ""String_Node_Str"");
  }
  w.println(streamWriterName + ""String_Node_Str"" + syncMethod.getName()+ ""String_Node_Str"");
  JParameter[] syncParams=syncMethod.getParameters();
  w.println(streamWriterName + ""String_Node_Str"" + syncParams.length+ ""String_Node_Str"");
  for (  JParameter param : syncParams) {
    w.println(streamWriterName + ""String_Node_Str"" + serializableTypeOracle.getSerializedTypeName(param.getType().getErasedType())+ ""String_Node_Str"");
  }
  for (int i=0; i < asyncParams.length - 1; ++i) {
    JParameter asyncParam=asyncParams[i];
    w.print(streamWriterName + ""String_Node_Str"");
    w.print(Shared.getStreamWriteMethodNameFor(asyncParam.getType()));
    w.println(""String_Node_Str"" + asyncParam.getName() + ""String_Node_Str"");
  }
  JParameter callbackParam=asyncParams[asyncParams.length - 1];
  String callbackName=callbackParam.getName();
  if (needsTryCatchBlock) {
    w.outdent();
    w.print(""String_Node_Str"");
    String exceptionName=nameFactory.createName(""String_Node_Str"");
    w.println(exceptionName + ""String_Node_Str"");
    w.indent();
    w.println(callbackName + ""String_Node_Str"" + exceptionName+ ""String_Node_Str"");
    w.outdent();
    w.println(""String_Node_Str"");
  }
  w.println();
  String payloadName=nameFactory.createName(""String_Node_Str"");
  w.println(""String_Node_Str"" + payloadName + ""String_Node_Str""+ streamWriterName+ ""String_Node_Str"");
  w.println(tossName + ""String_Node_Str"" + statsMethodExpr+ ""String_Node_Str""+ getProxySimpleName()+ ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str"");
  if (asyncReturnType == JPrimitiveType.VOID) {
    w.print(""String_Node_Str"");
  }
 else   if (asyncReturnType.getQualifiedSourceName().equals(RequestBuilder.class.getName())) {
    w.print(""String_Node_Str"");
  }
 else   if (asyncReturnType.getQualifiedSourceName().equals(Request.class.getName())) {
    w.print(""String_Node_Str"");
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + asyncReturnType.getQualifiedSourceName());
  }
  JType returnType=syncMethod.getReturnType();
  w.print(""String_Node_Str"" + getResponseReaderFor(returnType).name());
  w.println(""String_Node_Str"" + getProxySimpleName() + ""String_Node_Str""+ syncMethod.getName()+ ""String_Node_Str""+ payloadName+ ""String_Node_Str""+ callbackName+ ""String_Node_Str"");
  w.outdent();
  w.println(""String_Node_Str"");
}",0.990698680510491
54793,"private void generateProxyMethods(SourceWriter w,SerializableTypeOracle serializableTypeOracle,Map<JMethod,JMethod> syncMethToAsyncMethMap){
  JMethod[] syncMethods=serviceIntf.getOverridableMethods();
  for (  JMethod syncMethod : syncMethods) {
    JMethod asyncMethod=syncMethToAsyncMethMap.get(syncMethod);
    assert(asyncMethod != null);
    generateProxyMethod(w,serializableTypeOracle,syncMethod,asyncMethod);
  }
}","private void generateProxyMethods(SourceWriter w,SerializableTypeOracle serializableTypeOracle,Map<JMethod,JMethod> syncMethToAsyncMethMap){
  JMethod[] syncMethods=serviceIntf.getOverridableMethods();
  for (  JMethod syncMethod : syncMethods) {
    JMethod asyncMethod=syncMethToAsyncMethMap.get(syncMethod);
    assert(asyncMethod != null);
    JClassType enclosingType=syncMethod.getEnclosingType();
    JParameterizedType isParameterizedType=enclosingType.isParameterized();
    if (isParameterizedType != null) {
      JMethod[] methods=isParameterizedType.getMethods();
      for (int i=0; i < methods.length; ++i) {
        if (methods[i] == syncMethod) {
          syncMethod=isParameterizedType.getBaseType().getMethods()[i];
        }
      }
    }
    generateProxyMethod(w,serializableTypeOracle,syncMethod,asyncMethod);
  }
}",0.6703645007923931
54794,"private SourceWriter getSourceWriter(TreeLogger logger,GeneratorContext ctx,JClassType serviceAsync){
  JPackage serviceIntfPkg=serviceAsync.getPackage();
  String packageName=serviceIntfPkg == null ? ""String_Node_Str"" : serviceIntfPkg.getName();
  PrintWriter printWriter=ctx.tryCreate(logger,packageName,getProxySimpleName());
  if (printWriter == null) {
    return null;
  }
  ClassSourceFileComposerFactory composerFactory=new ClassSourceFileComposerFactory(packageName,getProxySimpleName());
  String[] imports=new String[]{RemoteServiceProxy.class.getCanonicalName(),ClientSerializationStreamWriter.class.getCanonicalName(),GWT.class.getCanonicalName(),ResponseReader.class.getCanonicalName(),SerializationException.class.getCanonicalName()};
  for (  String imp : imports) {
    composerFactory.addImport(imp);
  }
  composerFactory.setSuperclass(RemoteServiceProxy.class.getSimpleName());
  composerFactory.addImplementedInterface(serviceAsync.getParameterizedQualifiedSourceName());
  return composerFactory.createSourceWriter(ctx,printWriter);
}","private SourceWriter getSourceWriter(TreeLogger logger,GeneratorContext ctx,JClassType serviceAsync){
  JPackage serviceIntfPkg=serviceAsync.getPackage();
  String packageName=serviceIntfPkg == null ? ""String_Node_Str"" : serviceIntfPkg.getName();
  PrintWriter printWriter=ctx.tryCreate(logger,packageName,getProxySimpleName());
  if (printWriter == null) {
    return null;
  }
  ClassSourceFileComposerFactory composerFactory=new ClassSourceFileComposerFactory(packageName,getProxySimpleName());
  String[] imports=new String[]{RemoteServiceProxy.class.getCanonicalName(),ClientSerializationStreamWriter.class.getCanonicalName(),GWT.class.getCanonicalName(),ResponseReader.class.getCanonicalName(),SerializationException.class.getCanonicalName()};
  for (  String imp : imports) {
    composerFactory.addImport(imp);
  }
  composerFactory.setSuperclass(RemoteServiceProxy.class.getSimpleName());
  composerFactory.addImplementedInterface(serviceAsync.getErasedType().getQualifiedSourceName());
  return composerFactory.createSourceWriter(ctx,printWriter);
}",0.9881796690307328
54795,"/** 
 * Loads a new module into <code>moduleDef</code> as an included module.
 * @param logger Logs the process.
 * @param moduleName The module to load.
 * @param moduleDef The module to add the new module to.
 * @throws UnableToCompleteException
 */
void nestedLoad(TreeLogger logger,String moduleName,ModuleDef moduleDef) throws UnableToCompleteException {
  if (alreadyLoadedModules.contains(moduleName)) {
    logger.log(TreeLogger.TRACE,""String_Node_Str"" + moduleName + ""String_Node_Str"",null);
    return;
  }
 else {
    alreadyLoadedModules.add(moduleName);
  }
  String slashedModuleName=moduleName.replace('.','/');
  String resName=slashedModuleName + ""String_Node_Str"";
  URL moduleURL=classLoader.getResource(resName);
  if (moduleURL != null) {
    String externalForm=moduleURL.toExternalForm();
    logger.log(TreeLogger.TRACE,""String_Node_Str"" + externalForm,null);
    try {
      if ((!(externalForm.startsWith(""String_Node_Str""))) && (!(externalForm.startsWith(""String_Node_Str""))) && (!(externalForm.startsWith(""String_Node_Str"")))&& (!(externalForm.startsWith(""String_Node_Str"")))) {
        File gwtXmlFile=new File(new URI(externalForm));
        moduleDef.addGwtXmlFile(gwtXmlFile);
      }
    }
 catch (    URISyntaxException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
      throw new UnableToCompleteException();
    }
  }
  if (moduleURL == null) {
    String msg=""String_Node_Str"" + resName + ""String_Node_Str"";
    logger.log(TreeLogger.ERROR,msg,null);
    throw new UnableToCompleteException();
  }
  String moduleDir=""String_Node_Str"";
  int i=slashedModuleName.lastIndexOf('/');
  if (i != -1) {
    moduleDir=slashedModuleName.substring(0,i) + ""String_Node_Str"";
  }
  Reader r=null;
  try {
    r=Util.createReader(logger,moduleURL);
    ModuleDefSchema schema=new ModuleDefSchema(logger,this,moduleURL,moduleDir,moduleDef);
    ReflectiveParser.parse(logger,schema,r);
  }
  finally {
    Utility.close(r);
  }
}","/** 
 * Loads a new module into <code>moduleDef</code> as an included module.
 * @param logger Logs the process.
 * @param moduleName The module to load.
 * @param moduleDef The module to add the new module to.
 * @throws UnableToCompleteException
 */
void nestedLoad(TreeLogger logger,String moduleName,ModuleDef moduleDef) throws UnableToCompleteException {
  if (alreadyLoadedModules.contains(moduleName)) {
    logger.log(TreeLogger.TRACE,""String_Node_Str"" + moduleName + ""String_Node_Str"",null);
    return;
  }
 else {
    alreadyLoadedModules.add(moduleName);
  }
  String slashedModuleName=moduleName.replace('.','/');
  String resName=slashedModuleName + ModuleDefLoader.GWT_MODULE_XML_SUFFIX;
  URL moduleURL=classLoader.getResource(resName);
  if (moduleURL != null) {
    String externalForm=moduleURL.toExternalForm();
    logger.log(TreeLogger.TRACE,""String_Node_Str"" + externalForm,null);
    try {
      if ((!(externalForm.startsWith(""String_Node_Str""))) && (!(externalForm.startsWith(""String_Node_Str""))) && (!(externalForm.startsWith(""String_Node_Str"")))&& (!(externalForm.startsWith(""String_Node_Str"")))) {
        File gwtXmlFile=new File(new URI(externalForm));
        moduleDef.addGwtXmlFile(gwtXmlFile);
      }
    }
 catch (    URISyntaxException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"",e);
      throw new UnableToCompleteException();
    }
  }
  if (moduleURL == null) {
    String msg=""String_Node_Str"" + resName + ""String_Node_Str"";
    logger.log(TreeLogger.ERROR,msg,null);
    throw new UnableToCompleteException();
  }
  String moduleDir=""String_Node_Str"";
  int i=slashedModuleName.lastIndexOf('/');
  if (i != -1) {
    moduleDir=slashedModuleName.substring(0,i) + ""String_Node_Str"";
  }
  Reader r=null;
  try {
    r=Util.createReader(logger,moduleURL);
    ModuleDefSchema schema=new ModuleDefSchema(logger,this,moduleURL,moduleDir,moduleDef);
    ReflectiveParser.parse(logger,schema,r);
  }
  finally {
    Utility.close(r);
  }
}",0.986356745831228
54796,"public void onWindowResized(int width,int height){
  if (width == windowWidth) {
    return;
  }
  windowWidth=width;
  int menuWidth=mainMenu.getOffsetWidth();
  int contentWidth=width - menuWidth - 30;
  int contentWidthInner=contentWidth - 10;
  bottomPanel.setCellWidth(mainMenu,menuWidth + ""String_Node_Str"");
  bottomPanel.setCellWidth(contentLayout,contentWidth + ""String_Node_Str"");
  contentLayout.getCellFormatter().setWidth(0,0,contentWidthInner + ""String_Node_Str"");
  contentLayout.getCellFormatter().setWidth(1,0,contentWidthInner + ""String_Node_Str"");
}","public void onWindowResized(int width,int height){
  if (width == windowWidth) {
    return;
  }
  windowWidth=width;
  onWindowResizedImpl(width);
}",0.3709902370990237
54797,"@Override public void run(){
  styleTester.setVisible(false);
  styleTester.setVisible(true);
  if (styleTester.getOffsetWidth() > 0) {
    RootPanel.getBodyElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    RootPanel.getBodyElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    schedule(25);
  }
}","@Override public void run(){
  styleTester.setVisible(false);
  styleTester.setVisible(true);
  if (styleTester.getOffsetWidth() > 0) {
    RootPanel.getBodyElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    RootPanel.getBodyElement().getStyle().setProperty(""String_Node_Str"",""String_Node_Str"");
    app.onWindowResizedImpl(Window.getClientWidth());
  }
 else {
    schedule(25);
  }
}",0.9293193717277488
54798,"/** 
 * Update the style sheets to reflect the current theme and direction.
 */
private void updateStyleSheets(){
  String gwtStyleSheet=""String_Node_Str"" + CUR_THEME + ""String_Node_Str""+ CUR_THEME+ ""String_Node_Str"";
  String showcaseStyleSheet=CUR_THEME + ""String_Node_Str"";
  if (LocaleInfo.getCurrentLocale().isRTL()) {
    gwtStyleSheet=gwtStyleSheet.replace(""String_Node_Str"",""String_Node_Str"");
    showcaseStyleSheet=showcaseStyleSheet.replace(""String_Node_Str"",""String_Node_Str"");
  }
  HeadElement headElem=getHeadElement();
  NodeList<Node> children=headElem.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    Node node=children.getItem(i);
    if (node.getNodeType() == Node.ELEMENT_NODE) {
      Element elem=Element.as(node);
      if (elem.getTagName().equalsIgnoreCase(""String_Node_Str"") && elem.getPropertyString(""String_Node_Str"").equalsIgnoreCase(""String_Node_Str"")) {
        String href=elem.getPropertyString(""String_Node_Str"");
        if (gwtStyleSheet != null && href.contains(gwtStyleSheet)) {
          gwtStyleSheet=null;
        }
 else         if (showcaseStyleSheet != null && href.contains(showcaseStyleSheet)) {
          showcaseStyleSheet=null;
        }
 else {
          headElem.removeChild(elem);
          i--;
        }
      }
    }
  }
  String modulePath=GWT.getModuleBaseURL();
  if (gwtStyleSheet != null) {
    styleTesterTimer.schedule(25);
    loadStyleSheet(modulePath + gwtStyleSheet);
  }
  if (showcaseStyleSheet != null) {
    loadStyleSheet(modulePath + showcaseStyleSheet);
  }
}","/** 
 * Update the style sheets to reflect the current theme and direction.
 */
private void updateStyleSheets(){
  String gwtStyleSheet=""String_Node_Str"" + CUR_THEME + ""String_Node_Str""+ CUR_THEME+ ""String_Node_Str"";
  String showcaseStyleSheet=CUR_THEME + ""String_Node_Str"";
  if (LocaleInfo.getCurrentLocale().isRTL()) {
    gwtStyleSheet=gwtStyleSheet.replace(""String_Node_Str"",""String_Node_Str"");
    showcaseStyleSheet=showcaseStyleSheet.replace(""String_Node_Str"",""String_Node_Str"");
  }
  HeadElement headElem=getHeadElement();
  NodeList<Node> children=headElem.getChildNodes();
  for (int i=0; i < children.getLength(); i++) {
    Node node=children.getItem(i);
    if (node.getNodeType() == Node.ELEMENT_NODE) {
      Element elem=Element.as(node);
      if (elem.getTagName().equalsIgnoreCase(""String_Node_Str"") && elem.getPropertyString(""String_Node_Str"").equalsIgnoreCase(""String_Node_Str"")) {
        String href=elem.getPropertyString(""String_Node_Str"");
        if (gwtStyleSheet != null && href.contains(gwtStyleSheet)) {
          gwtStyleSheet=null;
        }
 else         if (showcaseStyleSheet != null && href.contains(showcaseStyleSheet)) {
          showcaseStyleSheet=null;
        }
 else {
          headElem.removeChild(elem);
          i--;
        }
      }
    }
  }
  styleTesterTimer.schedule(25);
  String modulePath=GWT.getModuleBaseURL();
  if (gwtStyleSheet != null) {
    loadStyleSheet(modulePath + gwtStyleSheet);
  }
  if (showcaseStyleSheet != null) {
    loadStyleSheet(modulePath + showcaseStyleSheet);
  }
}",0.9079201545396008
54799,"/** 
 * Check the argument to a parameterized type to see if it will make the type it is applied to be serializable. As a side effect, populates  {@link #typeToTypeInfoComputed} in the same way as{@link #checkTypeInstantiable(TreeLogger,JType,boolean)}.
 * @param logger
 * @param baseType - The generic type the parameter is on
 * @param paramIndex - The index of the parameter in the generic type
 * @param typeArg - An upper bound on the actual argument being applied to thegeneric type
 * @param isSpeculative
 * @return Whether the a parameterized type can be serializable if<code>baseType</code> is the base type and the <code>paramIndex</code>th type argument is a subtype of <code>typeArg</code>.
 */
private boolean checkTypeArgument(TreeLogger logger,JGenericType baseType,int paramIndex,JClassType typeArg,boolean isSpeculative,Path parent){
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && flowInfoForArrayParam.infiniteArrayExpansionPathBetween(otherFlowInfo)) {
          logger.branch(getLogLevel(isSpeculative),""String_Node_Str"" + baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ typeArg.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
          return false;
        }
      }
    }
  }
  Path path=createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case EXPOSURE_DIRECT:
    return checkTypeInstantiable(logger,typeArg,true,path) || mightNotBeExposed(baseType,paramIndex);
case EXPOSURE_NONE:
  return true;
default :
assert(exposure >= EXPOSURE_MIN_BOUNDED_ARRAY);
return checkTypeInstantiable(logger,getArrayType(typeOracle,exposure,typeArg),true,path) || mightNotBeExposed(baseType,paramIndex);
}
}","/** 
 * Check the argument to a parameterized type to see if it will make the type it is applied to be serializable. As a side effect, populates  {@link #typeToTypeInfoComputed} in the same way as{@link #checkTypeInstantiable(TreeLogger,JType,boolean)}.
 * @param logger
 * @param baseType - The generic type the parameter is on
 * @param paramIndex - The index of the parameter in the generic type
 * @param typeArg - An upper bound on the actual argument being applied to thegeneric type
 * @param isSpeculative
 * @return Whether the a parameterized type can be serializable if<code>baseType</code> is the base type and the <code>paramIndex</code>th type argument is a subtype of <code>typeArg</code>.
 */
private boolean checkTypeArgument(TreeLogger logger,JGenericType baseType,int paramIndex,JClassType typeArg,boolean isSpeculative,Path parent){
  JArrayType typeArgAsArray=typeArg.isArray();
  if (typeArgAsArray != null) {
    JTypeParameter parameterOfTypeArgArray=typeArgAsArray.getLeafType().isTypeParameter();
    if (parameterOfTypeArgArray != null) {
      JGenericType declaringClass=parameterOfTypeArgArray.getDeclaringClass();
      if (declaringClass != null) {
        TypeParameterFlowInfo flowInfoForArrayParam=getFlowInfo(declaringClass,parameterOfTypeArgArray.getOrdinal());
        TypeParameterFlowInfo otherFlowInfo=getFlowInfo(baseType,paramIndex);
        if (otherFlowInfo.getExposure() >= 0 && flowInfoForArrayParam.infiniteArrayExpansionPathBetween(otherFlowInfo)) {
          logger.branch(getLogLevel(isSpeculative),""String_Node_Str"" + baseType.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ typeArg.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
          return false;
        }
      }
    }
  }
  Path path=createTypeArgumentPath(parent,baseType,paramIndex,typeArg);
  int exposure=getTypeParameterExposure(baseType,paramIndex);
switch (exposure) {
case EXPOSURE_DIRECT:
{
      TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
      return checkTypeInstantiable(branch,typeArg,true,path) || mightNotBeExposed(baseType,paramIndex);
    }
case EXPOSURE_NONE:
  logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
return true;
default :
{
assert(exposure >= EXPOSURE_MIN_BOUNDED_ARRAY);
TreeLogger branch=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + paramIndex + ""String_Node_Str""+ baseType.getParameterizedQualifiedSourceName()+ ""String_Node_Str""+ exposure+ ""String_Node_Str"");
return checkTypeInstantiable(branch,getArrayType(typeOracle,exposure,typeArg),true,path) || mightNotBeExposed(baseType,paramIndex);
}
}
}",0.8846761453396524
54800,"private boolean checkFields(TreeLogger logger,JClassType classOrInterface,boolean isSpeculative,Path parent){
  TypeInfoComputed typeInfo=getTypeInfoComputed(classOrInterface,parent);
  JClassType superType=classOrInterface.getSuperclass();
  if (superType != null && getTypeInfoComputed(superType,parent).isDeclaredSerializable()) {
    boolean superTypeOk=checkFields(logger,superType,isSpeculative,parent);
    if (!superTypeOk && !typeInfo.isDirectlySerializable()) {
      return false;
    }
  }
  if (typeInfo.isManuallySerializable()) {
    isSpeculative=true;
  }
  boolean allSucceeded=true;
  JField[] fields=classOrInterface.getFields();
  if (fields.length > 0) {
    TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
    for (    JField field : fields) {
      if (!qualfiesForSerialization(localLogger,field)) {
        continue;
      }
      TreeLogger fieldLogger=localLogger.branch(TreeLogger.DEBUG,field.toString(),null);
      JType fieldType=field.getType();
      Path path=createFieldPath(parent,field);
      if (typeInfo.isManuallySerializable() && fieldType.getLeafType() == typeOracle.getJavaLangObject()) {
        checkAllSubtypesOfObject(fieldLogger.branch(TreeLogger.WARN,""String_Node_Str"",null),path);
      }
 else {
        allSucceeded&=checkTypeInstantiable(fieldLogger,fieldType,isSpeculative,path);
      }
    }
  }
  boolean succeeded=allSucceeded || typeInfo.isManuallySerializable();
  if (succeeded) {
    getTypeInfoComputed(classOrInterface,parent).setFieldSerializable();
  }
  return succeeded;
}","private boolean checkFields(TreeLogger logger,JClassType classOrInterface,boolean isSpeculative,Path parent){
  TypeInfoComputed typeInfo=getTypeInfoComputed(classOrInterface,parent);
  JClassType superType=classOrInterface.getSuperclass();
  if (superType != null && getTypeInfoComputed(superType,parent).isDeclaredSerializable()) {
    boolean superTypeOk=checkFields(logger,superType,isSpeculative,parent);
    if (!superTypeOk && !typeInfo.isDirectlySerializable()) {
      return false;
    }
  }
  if (typeInfo.isManuallySerializable()) {
    isSpeculative=true;
  }
  boolean allSucceeded=true;
  JField[] fields=classOrInterface.getFields();
  if (fields.length > 0) {
    TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classOrInterface.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
    for (    JField field : fields) {
      if (!qualfiesForSerialization(localLogger,field)) {
        continue;
      }
      TreeLogger fieldLogger=localLogger.branch(TreeLogger.DEBUG,field.toString(),null);
      JType fieldType=field.getType();
      Path path=createFieldPath(parent,field);
      if (typeInfo.isManuallySerializable() && fieldType.getLeafType() == typeOracle.getJavaLangObject()) {
        checkAllSubtypesOfObject(fieldLogger.branch(TreeLogger.WARN,""String_Node_Str"",null),path);
      }
 else {
        allSucceeded&=checkTypeInstantiable(fieldLogger,fieldType,isSpeculative,path);
      }
    }
  }
  boolean succeeded=allSucceeded || typeInfo.isManuallySerializable();
  if (succeeded) {
    getTypeInfoComputed(classOrInterface,parent).setFieldSerializable();
  }
  return succeeded;
}",0.9761092150170648
54801,"/** 
 * This method determines whether a type can be serialized by GWT. To do so, it must traverse all subtypes as well as all field types of those types, transitively. It returns a boolean indicating whether this type or any of its subtypes are instantiable. As a side effect, all types needed--plus some--to serialize this type are accumulated in   {@link #typeToTypeInfoComputed}. The method is exposed using default access to enable testing.
 */
final boolean checkTypeInstantiable(TreeLogger logger,JType type,boolean isSpeculative,final Path path){
  assert(type != null);
  if (type.isPrimitive() != null) {
    return true;
  }
  assert(type instanceof JClassType);
  JClassType classType=(JClassType)type;
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,classType.getParameterizedQualifiedSourceName(),null);
  if (!isAllowedByFilter(localLogger,classType,isSpeculative)) {
    return false;
  }
  JTypeParameter isTypeParameter=classType.isTypeParameter();
  if (isTypeParameter != null) {
    if (typeParametersInRootTypes.contains(isTypeParameter)) {
      return checkTypeInstantiable(localLogger,isTypeParameter.getFirstBound(),isSpeculative,path);
    }
    return true;
  }
  JWildcardType isWildcard=classType.isWildcard();
  if (isWildcard != null) {
    boolean success=true;
    for (    JClassType bound : isWildcard.getUpperBounds()) {
      success&=checkTypeInstantiable(localLogger,bound,isSpeculative,path);
    }
    return success;
  }
  TypeInfoComputed tic=getTypeInfoComputed(classType,path);
  if (tic.isPendingInstantiable()) {
    return true;
  }
 else   if (tic.isDone()) {
    return tic.hasInstantiableSubtypes();
  }
  tic.setPendingInstantiable();
  JArrayType isArray=classType.isArray();
  if (isArray != null) {
    JType leafType=isArray.getLeafType();
    JTypeParameter isLeafTypeParameter=leafType.isTypeParameter();
    if (isLeafTypeParameter != null && !typeParametersInRootTypes.contains(isLeafTypeParameter)) {
      tic.setInstantiable(false);
      tic.setInstantiableSubytpes(true);
      return true;
    }
    boolean succeeded=checkArrayInstantiable(localLogger,isArray,isSpeculative,path);
    if (succeeded) {
      JClassType leafClass=leafType.isClassOrInterface();
      if (leafClass != null) {
        JClassType[] leafSubtypes=leafClass.getErasedType().getSubtypes();
        for (        JClassType leafSubtype : leafSubtypes) {
          JArrayType covariantArray=getArrayType(typeOracle,isArray.getRank(),leafSubtype);
          checkTypeInstantiable(localLogger,covariantArray,true,path);
        }
      }
    }
    tic.setInstantiable(succeeded);
    return succeeded;
  }
  if (classType == typeOracle.getJavaLangObject()) {
    localLogger.branch(getLogLevel(isSpeculative),""String_Node_Str"",null);
    tic.setInstantiable(false);
    return false;
  }
  if (classType.isRawType() != null) {
    TreeLogger rawTypeLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classType.getQualifiedSourceName() + ""String_Node_Str"",null);
    if (classType.isAssignableTo(collectionClass) || classType.isAssignableTo(mapClass)) {
      checkAllSubtypesOfObject(rawTypeLogger,path);
    }
  }
  JClassType originalType=(JClassType)type;
  JRealClassType baseType;
  if (type.isRawType() != null) {
    baseType=type.isRawType().getBaseType();
  }
 else   if (type.isParameterized() != null) {
    baseType=type.isParameterized().getBaseType();
  }
 else {
    baseType=(JRealClassType)originalType;
  }
  if (isSpeculative && tic.isDirectlySerializable()) {
    isSpeculative=false;
  }
  boolean isInstantiable=checkTypeInstantiableNoSubtypes(localLogger,baseType,isSpeculative,path);
  JClassType[] typeArgs=NO_JCLASSES;
  JParameterizedType isParameterized=originalType.isParameterized();
  JGenericType baseAsGenericType=baseType.isGenericType();
  if (isParameterized != null) {
    typeArgs=isParameterized.getTypeArgs();
  }
 else   if (baseAsGenericType != null) {
    List<JClassType> arguments=new ArrayList<JClassType>();
    for (    JTypeParameter typeParameter : baseAsGenericType.getTypeParameters()) {
      arguments.add(typeParameter.getFirstBound());
    }
    typeArgs=arguments.toArray(NO_JCLASSES);
  }
  boolean parametersOkay=true;
  JRawType isRaw=originalType.isRawType();
  if (isParameterized != null || isRaw != null) {
    assert(baseAsGenericType != null);
    int numDeclaredParams=baseAsGenericType.getTypeParameters().length;
    if (numDeclaredParams == typeArgs.length) {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeArgument(localLogger,baseAsGenericType,i,typeArg,isSpeculative,path);
      }
    }
 else {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeInstantiable(localLogger,typeArg,isSpeculative,path);
      }
    }
  }
  isInstantiable&=parametersOkay;
  boolean anySubtypes=false;
  if (parametersOkay) {
    JClassType[] subtypes=baseType.getSubtypes();
    if (subtypes.length > 0) {
      TreeLogger subtypesLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
      for (      JClassType subtype : subtypes) {
        TreeLogger subtypeLogger=subtypesLogger.branch(TreeLogger.DEBUG,subtype.getParameterizedQualifiedSourceName(),null);
        Path subtypePath=createSubtypePath(path,subtype,originalType);
        boolean subInstantiable=checkTypeInstantiableNoSubtypes(subtypeLogger,subtype,true,subtypePath);
        JGenericType genericSub=subtype.isGenericType();
        if (genericSub != null) {
          TreeLogger paramsLogger=subtypeLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + genericSub.getParameterizedQualifiedSourceName() + ""String_Node_Str"");
          Map<JTypeParameter,Set<JTypeParameter>> subParamsConstrainedBy=subParamsConstrainedBy(baseType,genericSub);
          for (int i=0; i < genericSub.getTypeParameters().length; i++) {
            JTypeParameter param=genericSub.getTypeParameters()[i];
            TreeLogger paramLogger=paramsLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + param.getParameterizedQualifiedSourceName() + ""String_Node_Str"");
            Set<JTypeParameter> constBy=subParamsConstrainedBy.get(param);
            if (constBy == null) {
              subInstantiable&=checkTypeArgument(paramLogger,genericSub,i,param.getFirstBound(),true,path);
            }
 else {
              boolean paramOK=false;
              for (              JTypeParameter constrained : constBy) {
                paramOK|=checkTypeArgument(paramLogger,genericSub,i,typeArgs[constrained.getOrdinal()],true,path);
              }
              subInstantiable&=paramOK;
            }
          }
        }
 else {
          if (subInstantiable && isParameterized != null) {
            HashSet<JTypeParameter> typeParamsInQueryType=new HashSet<JTypeParameter>();
            recordTypeParametersIn(isParameterized,typeParamsInQueryType);
            if (typeParamsInQueryType.isEmpty()) {
              if (!isParameterized.isAssignableFrom(subtype)) {
                subtypeLogger.log(TreeLogger.DEBUG,""String_Node_Str"" + subtype.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ isParameterized.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
                subInstantiable=false;
              }
            }
          }
        }
        if (subInstantiable) {
          getTypeInfoComputed(subtype,path).setInstantiable(true);
          anySubtypes=true;
        }
      }
    }
  }
  anySubtypes|=isInstantiable;
  tic.setInstantiable(isInstantiable);
  tic.setInstantiableSubytpes(anySubtypes);
  if (!anySubtypes && !isSpeculative) {
    localLogger.branch(getLogLevel(isSpeculative),""String_Node_Str"" + classType.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
  }
  return tic.hasInstantiableSubtypes();
}","/** 
 * This method determines whether a type can be serialized by GWT. To do so, it must traverse all subtypes as well as all field types of those types, transitively. It returns a boolean indicating whether this type or any of its subtypes are instantiable. As a side effect, all types needed--plus some--to serialize this type are accumulated in   {@link #typeToTypeInfoComputed}. The method is exposed using default access to enable testing.
 */
final boolean checkTypeInstantiable(TreeLogger logger,JType type,boolean isSpeculative,final Path path){
  assert(type != null);
  if (type.isPrimitive() != null) {
    return true;
  }
  assert(type instanceof JClassType);
  JClassType classType=(JClassType)type;
  TreeLogger localLogger=logger.branch(TreeLogger.DEBUG,classType.getParameterizedQualifiedSourceName(),null);
  if (!isAllowedByFilter(localLogger,classType,isSpeculative)) {
    return false;
  }
  JTypeParameter isTypeParameter=classType.isTypeParameter();
  if (isTypeParameter != null) {
    if (typeParametersInRootTypes.contains(isTypeParameter)) {
      return checkTypeInstantiable(localLogger,isTypeParameter.getFirstBound(),isSpeculative,path);
    }
    return true;
  }
  JWildcardType isWildcard=classType.isWildcard();
  if (isWildcard != null) {
    boolean success=true;
    for (    JClassType bound : isWildcard.getUpperBounds()) {
      success&=checkTypeInstantiable(localLogger,bound,isSpeculative,path);
    }
    return success;
  }
  TypeInfoComputed tic=getTypeInfoComputed(classType,path);
  if (tic.isPendingInstantiable()) {
    return true;
  }
 else   if (tic.isDone()) {
    return tic.hasInstantiableSubtypes();
  }
  tic.setPendingInstantiable();
  JArrayType isArray=classType.isArray();
  if (isArray != null) {
    JType leafType=isArray.getLeafType();
    JTypeParameter isLeafTypeParameter=leafType.isTypeParameter();
    if (isLeafTypeParameter != null && !typeParametersInRootTypes.contains(isLeafTypeParameter)) {
      tic.setInstantiable(false);
      tic.setInstantiableSubytpes(true);
      return true;
    }
    boolean succeeded=checkArrayInstantiable(localLogger,isArray,isSpeculative,path);
    if (succeeded) {
      JClassType leafClass=leafType.isClassOrInterface();
      if (leafClass != null) {
        JClassType[] leafSubtypes=leafClass.getErasedType().getSubtypes();
        for (        JClassType leafSubtype : leafSubtypes) {
          if (leafSubtype.isRawType() != null) {
            JGenericType leafGenericSub=leafSubtype.isRawType().getBaseType();
            leafSubtype=typeOracle.getParameterizedType(leafGenericSub,leafGenericSub.getTypeParameters());
          }
          if (!isAccessibleToClassesInSamePackage(leafSubtype)) {
            continue;
          }
          JArrayType covariantArray=getArrayType(typeOracle,isArray.getRank(),leafSubtype);
          checkTypeInstantiable(localLogger,covariantArray,true,path);
        }
      }
    }
    tic.setInstantiable(succeeded);
    return succeeded;
  }
  if (classType == typeOracle.getJavaLangObject()) {
    localLogger.branch(getLogLevel(isSpeculative),""String_Node_Str"",null);
    tic.setInstantiable(false);
    return false;
  }
  if (classType.isRawType() != null) {
    TreeLogger rawTypeLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + classType.getQualifiedSourceName() + ""String_Node_Str"",null);
    if (classType.isAssignableTo(collectionClass) || classType.isAssignableTo(mapClass)) {
      checkAllSubtypesOfObject(rawTypeLogger,path);
    }
  }
  JClassType originalType=(JClassType)type;
  JRealClassType baseType;
  if (type.isRawType() != null) {
    baseType=type.isRawType().getBaseType();
  }
 else   if (type.isParameterized() != null) {
    baseType=type.isParameterized().getBaseType();
  }
 else {
    baseType=(JRealClassType)originalType;
  }
  if (isSpeculative && tic.isDirectlySerializable()) {
    isSpeculative=false;
  }
  boolean isInstantiable=checkTypeInstantiableNoSubtypes(localLogger,baseType,isSpeculative,path);
  JClassType[] typeArgs=NO_JCLASSES;
  JParameterizedType isParameterized=originalType.isParameterized();
  JGenericType baseAsGenericType=baseType.isGenericType();
  if (isParameterized != null) {
    typeArgs=isParameterized.getTypeArgs();
  }
 else   if (baseAsGenericType != null) {
    List<JClassType> arguments=new ArrayList<JClassType>();
    for (    JTypeParameter typeParameter : baseAsGenericType.getTypeParameters()) {
      arguments.add(typeParameter.getFirstBound());
    }
    typeArgs=arguments.toArray(NO_JCLASSES);
  }
  boolean parametersOkay=true;
  JRawType isRaw=originalType.isRawType();
  if (isParameterized != null || isRaw != null) {
    assert(baseAsGenericType != null);
    int numDeclaredParams=baseAsGenericType.getTypeParameters().length;
    if (numDeclaredParams == typeArgs.length) {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeArgument(localLogger,baseAsGenericType,i,typeArg,isSpeculative,path);
      }
    }
 else {
      for (int i=0; i < numDeclaredParams; ++i) {
        JClassType typeArg=typeArgs[i];
        parametersOkay&=checkTypeInstantiable(localLogger,typeArg,isSpeculative,path);
      }
    }
  }
  isInstantiable&=parametersOkay;
  boolean anySubtypes=false;
  if (parametersOkay) {
    JClassType[] subtypes=baseType.getSubtypes();
    if (subtypes.length > 0) {
      TreeLogger subtypesLogger=localLogger.branch(TreeLogger.DEBUG,""String_Node_Str"",null);
      for (      JClassType subtype : subtypes) {
        TreeLogger subtypeLogger=subtypesLogger.branch(TreeLogger.DEBUG,subtype.getParameterizedQualifiedSourceName(),null);
        Path subtypePath=createSubtypePath(path,subtype,originalType);
        boolean subInstantiable=checkTypeInstantiableNoSubtypes(subtypeLogger,subtype,true,subtypePath);
        if (!subInstantiable) {
          continue;
        }
        JGenericType genericSub=subtype.isGenericType();
        if (genericSub != null) {
          TreeLogger paramsLogger=subtypeLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + genericSub.getParameterizedQualifiedSourceName() + ""String_Node_Str"");
          Map<JTypeParameter,Set<JTypeParameter>> subParamsConstrainedBy=subParamsConstrainedBy(baseType,genericSub);
          for (int i=0; i < genericSub.getTypeParameters().length; i++) {
            JTypeParameter param=genericSub.getTypeParameters()[i];
            TreeLogger paramLogger=paramsLogger.branch(TreeLogger.DEBUG,""String_Node_Str"" + param.getParameterizedQualifiedSourceName() + ""String_Node_Str"");
            Set<JTypeParameter> constBy=subParamsConstrainedBy.get(param);
            if (constBy == null) {
              subInstantiable&=checkTypeArgument(paramLogger,genericSub,i,param.getFirstBound(),true,path);
            }
 else {
              boolean paramOK=false;
              for (              JTypeParameter constrained : constBy) {
                paramOK|=checkTypeArgument(paramLogger,genericSub,i,typeArgs[constrained.getOrdinal()],true,path);
              }
              subInstantiable&=paramOK;
            }
          }
        }
 else {
          if (isParameterized != null) {
            HashSet<JTypeParameter> typeParamsInQueryType=new HashSet<JTypeParameter>();
            recordTypeParametersIn(isParameterized,typeParamsInQueryType);
            if (typeParamsInQueryType.isEmpty()) {
              if (!isParameterized.isAssignableFrom(subtype)) {
                subtypeLogger.log(TreeLogger.DEBUG,""String_Node_Str"" + subtype.getParameterizedQualifiedSourceName() + ""String_Node_Str""+ isParameterized.getParameterizedQualifiedSourceName()+ ""String_Node_Str"");
                subInstantiable=false;
              }
            }
          }
        }
        if (subInstantiable) {
          getTypeInfoComputed(subtype,path).setInstantiable(true);
          anySubtypes=true;
        }
      }
    }
  }
  anySubtypes|=isInstantiable;
  tic.setInstantiable(isInstantiable);
  tic.setInstantiableSubytpes(anySubtypes);
  if (!anySubtypes && !isSpeculative) {
    localLogger.branch(getLogLevel(isSpeculative),""String_Node_Str"" + classType.getParameterizedQualifiedSourceName() + ""String_Node_Str"",null);
  }
  return tic.hasInstantiableSubtypes();
}",0.9734677469231244
54802,"/** 
 * Returns <code>true</code> if the query type is accessible to classes in the same package.
 */
private static boolean isAccessibleToClassesInSamePackage(JClassType type){
  if (type.isPrivate()) {
    return false;
  }
  if (type.isMemberType()) {
    return isAccessibleToClassesInSamePackage(type.getEnclosingType());
  }
  return true;
}","/** 
 * Returns <code>true</code> if the query type is accessible to classes in the same package.
 */
private static boolean isAccessibleToClassesInSamePackage(JClassType type){
  if (type.isPrivate() || type.isLocalType()) {
    return false;
  }
  if (type.isMemberType()) {
    return isAccessibleToClassesInSamePackage(type.getEnclosingType());
  }
  return true;
}",0.9692737430167596
54803,private static native boolean detectOldSafari();,static native boolean detectOldSafari();,0.9090909090909092
54804,"public void testTokenEscaping(){
  final String escToken=""String_Node_Str"";
  delayTestFinish(5000);
  History.addHistoryListener(new HistoryListener(){
    public void onHistoryChanged(    String token){
      assertEquals(escToken,token);
      finishTest();
      History.removeHistoryListener(this);
    }
  }
);
  History.newItem(escToken);
}","public void testTokenEscaping(){
  final String shouldBeEncoded=""String_Node_Str"";
  final String shouldBeEncodedAs=""String_Node_Str"";
  delayTestFinish(5000);
  History.addHistoryListener(new HistoryListener(){
    public void onHistoryChanged(    String token){
      assertEquals(shouldBeEncodedAs,getCurrentLocationHash());
      assertEquals(shouldBeEncoded,token);
      finishTest();
      History.removeHistoryListener(this);
    }
  }
);
  History.newItem(shouldBeEncoded);
}",0.7773766546329723
54805,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new TestFireEvents());
}",0.943894389438944
54806,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new TestFireEvents());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
  addIssue(new Issue2392());
  addIssue(new TestFireEvents());
}",0.9566517189835576
54807,"/** 
 * This method formats a <code>double</code> into a fractional representation.
 * @param number value need to be formated
 * @param result result will be written here
 * @param minIntDigits minimum integer digits
 */
private void subformatFixed(double number,StringBuffer result,int minIntDigits){
  double power=Math.pow(10,maximumFractionDigits);
  number=Math.round(number * power);
  double intValue=(double)Math.floor(number / power);
  double fracValue=(double)Math.floor(number - intValue * power);
  boolean fractionPresent=(minimumFractionDigits > 0) || (fracValue > 0);
  String intPart=String.valueOf(intValue);
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  int zeroDelta=numberConstants.zeroDigit().charAt(0) - '0';
  int digitLen=intPart.length();
  if (intValue > 0 || minIntDigits > 0) {
    for (int i=digitLen; i < minIntDigits; i++) {
      result.append(numberConstants.zeroDigit());
    }
    for (int i=0; i < digitLen; i++) {
      result.append((char)(intPart.charAt(i) + zeroDelta));
      if (digitLen - i > 1 && groupingSize > 0 && ((digitLen - i) % groupingSize == 1)) {
        result.append(grouping);
      }
    }
  }
 else   if (!fractionPresent) {
    result.append(numberConstants.zeroDigit());
  }
  if (decimalSeparatorAlwaysShown || fractionPresent) {
    result.append(decimal);
  }
  String fracPart=String.valueOf(fracValue + power);
  int fracLen=fracPart.length();
  while (fracPart.charAt(fracLen - 1) == '0' && fracLen > minimumFractionDigits + 1) {
    fracLen--;
  }
  for (int i=1; i < fracLen; i++) {
    result.append((char)(fracPart.charAt(i) + zeroDelta));
  }
}","/** 
 * This method formats a <code>double</code> into a fractional representation.
 * @param number value need to be formated
 * @param result result will be written here
 * @param minIntDigits minimum integer digits
 */
private void subformatFixed(double number,StringBuffer result,int minIntDigits){
  double power=Math.pow(10,maximumFractionDigits);
  double intValue=(double)Math.floor(number);
  double fracValue=(double)Math.floor((number - intValue) * power + 0.5d);
  if (fracValue >= power) {
    intValue+=1.0;
    fracValue-=power;
  }
  boolean fractionPresent=(minimumFractionDigits > 0) || (fracValue > 0);
  String intPart=makeIntString(intValue);
  String grouping=isCurrencyFormat ? numberConstants.monetaryGroupingSeparator() : numberConstants.groupingSeparator();
  String decimal=isCurrencyFormat ? numberConstants.monetarySeparator() : numberConstants.decimalSeparator();
  int zeroDelta=numberConstants.zeroDigit().charAt(0) - '0';
  int digitLen=intPart.length();
  if (intValue > 0 || minIntDigits > 0) {
    for (int i=digitLen; i < minIntDigits; i++) {
      result.append(numberConstants.zeroDigit());
    }
    for (int i=0; i < digitLen; i++) {
      result.append((char)(intPart.charAt(i) + zeroDelta));
      if (digitLen - i > 1 && groupingSize > 0 && ((digitLen - i) % groupingSize == 1)) {
        result.append(grouping);
      }
    }
  }
 else   if (!fractionPresent) {
    result.append(numberConstants.zeroDigit());
  }
  if (decimalSeparatorAlwaysShown || fractionPresent) {
    result.append(decimal);
  }
  String fracPart=makeIntString(Math.floor(fracValue + power + 0.5d));
  int fracLen=fracPart.length();
  while (fracPart.charAt(fracLen - 1) == '0' && fracLen > minimumFractionDigits + 1) {
    fracLen--;
  }
  for (int i=1; i < fracLen; i++) {
    result.append((char)(fracPart.charAt(i) + zeroDelta));
  }
}",0.9120699071545604
54808,"private Map<String,Resource> rerootResourcePaths(Map<String,AbstractResource> newInternalMap){
  Map<String,Resource> externalMap;
  externalMap=new HashMap<String,Resource>();
  for (  AbstractResource resource : newInternalMap.values()) {
    String path=resource.getPath();
    if (externalMap.get(path) instanceof ResourceWrapper) {
      continue;
    }
    for (    PathPrefix pathPrefix : pathPrefixSet.values()) {
      if (pathPrefix.allows(path)) {
        assert(path.startsWith(pathPrefix.getPrefix()));
        if (pathPrefix.shouldReroot()) {
          path=pathPrefix.getRerootedPath(path);
          AbstractResource wrapper=new ResourceWrapper(path,resource);
          externalMap.put(path,wrapper);
        }
 else {
          externalMap.put(path,resource);
        }
        break;
      }
    }
    assert(externalMap.containsKey(path));
  }
  return externalMap;
}","private Map<String,Resource> rerootResourcePaths(Map<String,AbstractResource> newInternalMap){
  Map<String,Resource> externalMap;
  externalMap=new HashMap<String,Resource>();
  for (  AbstractResource resource : newInternalMap.values()) {
    String path=resource.getPath();
    if (externalMap.get(path) instanceof ResourceWrapper) {
      continue;
    }
    for (    PathPrefix pathPrefix : pathPrefixSet.values()) {
      if (pathPrefix.allows(path)) {
        assert(path.startsWith(pathPrefix.getPrefix()));
        if (pathPrefix.shouldReroot()) {
          path=pathPrefix.getRerootedPath(path);
          Resource exposed=exposedResourceMap.get(path);
          if (exposed instanceof ResourceWrapper) {
            ResourceWrapper exposedWrapper=(ResourceWrapper)exposed;
            if (exposedWrapper.resource == resource) {
              externalMap.put(path,exposedWrapper);
              break;
            }
          }
          AbstractResource wrapper=new ResourceWrapper(path,resource);
          externalMap.put(path,wrapper);
        }
 else {
          externalMap.put(path,resource);
        }
        break;
      }
    }
    assert(externalMap.containsKey(path));
  }
  return externalMap;
}",0.842355175688509
54809,private static native void initUrlCheckTimer();,private native void initUrlCheckTimer();,0.9195402298850576
54810,"public synchronized void refresh(TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  lazyPublicOracle.refresh(logger);
  compilationState.refresh();
  if (lazyTypeOracle != null) {
    updateTypeOracle(logger);
  }
  PerfLogger.end();
}","public synchronized void refresh(TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  lazyPublicOracle.refresh(logger);
  lazySourceOracle.refresh(logger);
  compilationState.refresh();
  if (lazyTypeOracle != null) {
    updateTypeOracle(logger);
  }
  PerfLogger.end();
}",0.9393939393939394
54811,"public void testReplaceString(){
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
}","public void testReplaceString(){
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",hideFromCompiler(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
}",0.6382536382536382
54812,"@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes;
  try {
    String lookupClassName=className;
    if (classRewriter != null && classRewriter.isJsoImpl(className)) {
      lookupClassName=className.substring(0,className.length() - 1);
    }
    classBytes=compiler.getClassBytes(logger,lookupClassName);
    if (classRewriter != null) {
      classBytes=classRewriter.rewrite(className,classBytes);
    }
    Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
    if (className.equals(JavaScriptHost.class.getName())) {
      javaScriptHostClass=newClass;
      updateJavaScriptHost();
    }
    return newClass;
  }
 catch (  UnableToCompleteException e) {
    throw new ClassNotFoundException(className);
  }
}","@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes;
  try {
    ++stackDepth;
    String lookupClassName=className;
    if (classRewriter != null && classRewriter.isJsoImpl(className)) {
      lookupClassName=className.substring(0,className.length() - 1);
    }
    classBytes=compiler.getClassBytes(logger,lookupClassName);
    if (classRewriter != null) {
      classBytes=classRewriter.rewrite(className,classBytes);
    }
    Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
    if (className.equals(JavaScriptHost.class.getName())) {
      javaScriptHostClass=newClass;
      updateJavaScriptHost();
    }
    return newClass;
  }
 catch (  UnableToCompleteException e) {
    throw new ClassNotFoundException(className);
  }
 finally {
    --stackDepth;
  }
}",0.9777583951155692
54813,"/** 
 * Overridden to process JSNI annotations.
 */
@Override protected synchronized Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {
  Class<?> newClass=super.loadClass(name,resolve);
  JsniMethods jsniMethods=newClass.getAnnotation(JsniMethods.class);
  if (jsniMethods != null) {
    for (    JsniMethod jsniMethod : jsniMethods.value()) {
      String[] bodyParts=jsniMethod.body();
      int size=0;
      for (      String bodyPart : bodyParts) {
        size+=bodyPart.length();
      }
      StringBuilder body=new StringBuilder(size);
      for (      String bodyPart : bodyParts) {
        body.append(bodyPart);
      }
      shellJavaScriptHost.createNative(jsniMethod.file(),jsniMethod.line(),jsniMethod.name(),jsniMethod.paramNames(),body.toString());
    }
  }
  return newClass;
}","/** 
 * Overridden to process JSNI annotations.
 */
@Override protected synchronized Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {
  Class<?> newClass=super.loadClass(name,resolve);
  if (!newClass.isInterface() && !newClass.isLocalClass()) {
    pendingJsniInjectionClasses.add(newClass);
  }
  if (stackDepth == 0 && !pendingJsniInjectionClasses.isEmpty()) {
    Class<?>[] toCheck=pendingJsniInjectionClasses.toArray(new Class<?>[pendingJsniInjectionClasses.size()]);
    pendingJsniInjectionClasses.clear();
    for (    Class<?> checkClass : toCheck) {
      JsniMethods jsniMethods=checkClass.getAnnotation(JsniMethods.class);
      if (jsniMethods != null) {
        for (        JsniMethod jsniMethod : jsniMethods.value()) {
          String[] bodyParts=jsniMethod.body();
          int size=0;
          for (          String bodyPart : bodyParts) {
            size+=bodyPart.length();
          }
          StringBuilder body=new StringBuilder(size);
          for (          String bodyPart : bodyParts) {
            body.append(bodyPart);
          }
          shellJavaScriptHost.createNative(jsniMethod.file(),jsniMethod.line(),jsniMethod.name(),jsniMethod.paramNames(),body.toString());
        }
      }
    }
  }
  return newClass;
}",0.7795648060548723
54814,"/** 
 * Runs a particular test case.
 */
private void runTestImpl(String moduleName,TestCase testCase,TestResult testResult,Strategy strategy) throws UnableToCompleteException {
  if (lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  String syntheticModuleName=moduleName + ""String_Node_Str"" + strategy.getSyntheticModuleExtension();
  boolean sameTest=(currentModule != null) && syntheticModuleName.equals(currentModule.getName());
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  if (!sameTest) {
    currentModule=ModuleDefLoader.createSyntheticModule(getTopLogger(),syntheticModuleName,new String[]{moduleName,strategy.getModuleInherit()},true);
    currentModule.clearEntryPoints();
    currentModule.addEntryPointTypeName(GWTRunner.class.getName());
    Property moduleNameProp=currentModule.getProperties().create(""String_Node_Str"");
    moduleNameProp.addKnownValue(moduleName);
    moduleNameProp.setActiveValue(moduleName);
    runStyle.maybeCompileModule(syntheticModuleName);
  }
  messageQueue.setNextTest(new TestInfo(currentModule.getName(),testCase.getClass().getName(),testCase.getName()));
  try {
    if (firstLaunch) {
      runStyle.launchModule(currentModule.getName());
    }
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTime=System.currentTimeMillis();
    testBeginTimeout=testBeginTime + TEST_BEGIN_TIMEOUT_MILLIS;
    pumpEventLoop();
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  assert(messageQueue.hasResult());
  Map<String,JUnitResult> results=messageQueue.getResults();
  boolean parallelTesting=numClients > 1;
  for (  Entry<String,JUnitResult> entry : results.entrySet()) {
    String clientId=entry.getKey();
    JUnitResult result=entry.getValue();
    Throwable exception=result.getException();
    if (parallelTesting && exception != null) {
      String msg=""String_Node_Str"" + clientId;
      if (exception instanceof AssertionFailedError) {
        AssertionFailedError newException=new AssertionFailedError(msg + ""String_Node_Str"" + exception.getMessage());
        newException.setStackTrace(exception.getStackTrace());
        exception=newException;
      }
 else {
        exception=new RuntimeException(msg,exception);
      }
    }
    if (exception instanceof AssertionFailedError) {
      testResult.addFailure(testCase,(AssertionFailedError)exception);
    }
 else     if (exception != null) {
      if (exception instanceof JUnitFatalLaunchException) {
        lastLaunchFailed=true;
      }
      testResult.addError(testCase,exception);
    }
    strategy.processResult(testCase,result);
  }
}","/** 
 * Runs a particular test case.
 */
private void runTestImpl(String moduleName,TestCase testCase,TestResult testResult,Strategy strategy) throws UnableToCompleteException {
  if (lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  String syntheticModuleName=moduleName + ""String_Node_Str"" + strategy.getSyntheticModuleExtension();
  boolean sameTest=(currentModule != null) && syntheticModuleName.equals(currentModule.getName());
  if (sameTest && lastLaunchFailed) {
    throw new UnableToCompleteException();
  }
  if (!sameTest) {
    currentModule=ModuleDefLoader.createSyntheticModule(getTopLogger(),syntheticModuleName,new String[]{moduleName,strategy.getModuleInherit()},true);
    currentModule.clearEntryPoints();
    currentModule.addEntryPointTypeName(GWTRunner.class.getName());
    Property moduleNameProp=currentModule.getProperties().create(""String_Node_Str"");
    moduleNameProp.addKnownValue(moduleName);
    moduleNameProp.setActiveValue(moduleName);
    runStyle.maybeCompileModule(syntheticModuleName);
  }
  messageQueue.setNextTest(new TestInfo(currentModule.getName(),testCase.getClass().getName(),testCase.getName()));
  try {
    if (firstLaunch) {
      runStyle.launchModule(currentModule.getName());
    }
  }
 catch (  UnableToCompleteException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,new JUnitFatalLaunchException(e));
    return;
  }
  try {
    testBeginTime=System.currentTimeMillis();
    testBeginTimeout=testBeginTime + TEST_BEGIN_TIMEOUT_MILLIS;
    pumpEventLoop();
  }
 catch (  TimeoutException e) {
    lastLaunchFailed=true;
    testResult.addError(testCase,e);
    return;
  }
  assert(messageQueue.hasResult());
  Map<String,JUnitResult> results=messageQueue.getResults();
  boolean parallelTesting=numClients > 1;
  for (  Entry<String,JUnitResult> entry : results.entrySet()) {
    String clientId=entry.getKey();
    JUnitResult result=entry.getValue();
    Throwable exception=null;
    if (result == null) {
      String msg=""String_Node_Str"" + clientId;
      exception=new RuntimeException();
    }
 else {
      exception=result.getException();
      if (parallelTesting && exception != null) {
        String msg=""String_Node_Str"" + clientId;
        if (exception instanceof AssertionFailedError) {
          AssertionFailedError newException=new AssertionFailedError(msg + ""String_Node_Str"" + exception.getMessage());
          newException.setStackTrace(exception.getStackTrace());
          exception=newException;
        }
 else {
          exception=new RuntimeException(msg,exception);
        }
      }
    }
    if (exception instanceof AssertionFailedError) {
      testResult.addFailure(testCase,(AssertionFailedError)exception);
    }
 else     if (exception != null) {
      if (exception instanceof JUnitFatalLaunchException) {
        lastLaunchFailed=true;
      }
      testResult.addError(testCase,exception);
    }
    strategy.processResult(testCase,result);
  }
}",0.9490940465918896
54815,"protected static void validateDeclaredAnnotations(Annotation[] expected,Annotation[] actual){
  assertArraysEqual(expected,actual);
}","protected static void validateDeclaredAnnotations(Annotation[] expected,Annotation[] actual){
  Arrays.sort(expected,ANNOTATION_COMPARATOR);
  Arrays.sort(actual,ANNOTATION_COMPARATOR);
  assertArraysEqual(expected,actual);
}",0.7430167597765364
54816,"protected static void validateAnnotations(Annotation[] expected,Annotation[] actual){
  assertArraysEqual(expected,actual);
}","protected static void validateAnnotations(Annotation[] expected,Annotation[] actual){
  Arrays.sort(expected,ANNOTATION_COMPARATOR);
  Arrays.sort(actual,ANNOTATION_COMPARATOR);
  assertArraysEqual(expected,actual);
}",0.7309941520467836
54817,"protected static void validateMetaDataTags(HasMetaData md1,HasMetaData md2){
  assertEquals(md1.getMetaDataTags().length,md2.getMetaDataTags().length);
}","@SuppressWarnings(""String_Node_Str"") protected static void validateMetaDataTags(HasMetaData md1,HasMetaData md2){
  assertEquals(md1.getMetaDataTags().length,md2.getMetaDataTags().length);
}",0.892128279883382
54818,"protected static void validateMetaData(HasMetaData md1,HasMetaData md2){
  validateMetaDataTags(md1,md2);
  String[] md1TagNames=md1.getMetaDataTags();
  String[] md2TagNames=md2.getMetaDataTags();
  for (int i=0; i < md1TagNames.length; ++i) {
    assertEquals(md1TagNames[i],md2TagNames[i]);
    String[][] md1TagValues=md1.getMetaData(md1TagNames[i]);
    String[][] md2TagValues=md2.getMetaData(md2TagNames[i]);
    assertTrue(Arrays.deepEquals(md1TagValues,md2TagValues));
  }
}","@SuppressWarnings(""String_Node_Str"") protected static void validateMetaData(HasMetaData md1,HasMetaData md2){
  validateMetaDataTags(md1,md2);
  String[] md1TagNames=md1.getMetaDataTags();
  String[] md2TagNames=md2.getMetaDataTags();
  for (int i=0; i < md1TagNames.length; ++i) {
    assertEquals(md1TagNames[i],md2TagNames[i]);
    String[][] md1TagValues=md1.getMetaData(md1TagNames[i]);
    String[][] md2TagValues=md2.getMetaData(md2TagNames[i]);
    assertTrue(Arrays.deepEquals(md1TagValues,md2TagValues));
  }
}",0.963110667996012
54819,"public boolean execute(){
  if (++executionCount >= 10) {
    fail(""String_Node_Str"");
  }
  if (executionCount == 9) {
    finishTest();
  }
  return executionCount < 10;
}","public boolean execute(){
  if (++executionCount > 10) {
    fail(""String_Node_Str"");
  }
  if (executionCount == 10) {
    finishTest();
  }
  return executionCount < 10;
}",0.9884393063583816
54820,"/** 
 * Test method for  {@link com.google.gwt.user.client.CommandExecutor#submit(com.google.gwt.user.client.IncrementalCommand)}. <p/> Cases: <ul> <li>Submit <code>null</code></li> <li>Submit   {@link IncrementalCommand} and make sure that it fires as manytimes as we want it to</li> </ul>
 */
public void testSubmitIncrementalCommand(){
  CommandExecutor ce=new CommandExecutor();
  ce.submit((Command)null);
  delayTestFinish(TEST_FINISH_DELAY_MILLIS);
  ce.submit(new IncrementalCommand(){
    private int executionCount=0;
    public boolean execute(){
      if (++executionCount >= 10) {
        fail(""String_Node_Str"");
      }
      if (executionCount == 9) {
        finishTest();
      }
      return executionCount < 10;
    }
  }
);
}","/** 
 * Test method for  {@link com.google.gwt.user.client.CommandExecutor#submit(com.google.gwt.user.client.IncrementalCommand)}. <p/> Cases: <ul> <li>Submit <code>null</code></li> <li>Submit   {@link IncrementalCommand} and make sure that it fires as manytimes as we want it to</li> </ul>
 */
public void testSubmitIncrementalCommand(){
  CommandExecutor ce=new CommandExecutor();
  ce.submit((Command)null);
  delayTestFinish(TEST_FINISH_DELAY_MILLIS);
  ce.submit(new IncrementalCommand(){
    private int executionCount=0;
    public boolean execute(){
      if (++executionCount > 10) {
        fail(""String_Node_Str"");
      }
      if (executionCount == 10) {
        finishTest();
      }
      return executionCount < 10;
    }
  }
);
}",0.9973190348525468
54821,"/** 
 * Returns a pretty printed list of clients that have not retrieved the current test. Used for error reporting.
 * @return a string containing the list of clients that have not retrieved thecurrent test.
 */
String getUnretrievedClients(){
  StringBuilder buf=new StringBuilder();
synchronized (clientStatusesLock) {
    int lineCount=0;
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      if (!clientStatus.hasRequestedCurrentTest) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(clientStatus.clientId);
      lineCount++;
    }
    int difference=numClients - numClientsHaveRequestedTest;
    if (difference > 0) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      buf.append(""String_Node_Str"" + difference + ""String_Node_Str"");
    }
  }
  return buf.toString();
}","/** 
 * Returns a pretty printed list of clients that have not retrieved the current test. Used for error reporting.
 * @return a string containing the list of clients that have not retrieved thecurrent test.
 */
String getUnretrievedClients(){
synchronized (clientStatusesLock) {
    StringBuilder buf=new StringBuilder();
    int lineCount=0;
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      if (!clientStatus.hasRequestedCurrentTest) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(clientStatus.clientId);
      lineCount++;
    }
    int difference=numClients - numClientsHaveRequestedTest;
    if (difference > 0) {
      if (lineCount > 0) {
        buf.append('\n');
      }
      buf.append(""String_Node_Str"" + difference + ""String_Node_Str"");
    }
    return buf.toString();
  }
}",0.9334741288278776
54822,"/** 
 * Called by the servlet to query for for the next method to test.
 * @param timeout how long to wait for an answer
 * @return the next test to run, or <code>null</code> if<code>timeout</code> is exceeded or the next test does not match <code>testClassName</code>
 */
public TestInfo getNextTestInfo(String clientId,long timeout) throws TimeoutException {
synchronized (clientStatusesLock) {
    ClientStatus clientStatus=clientStatuses.get(clientId);
    if (clientStatus == null) {
      clientStatus=new ClientStatus(clientId);
      clientStatuses.put(clientId,clientStatus);
    }
    long startTime=System.currentTimeMillis();
    long stopTime=startTime + timeout;
    while (clientStatus.hasRequestedCurrentTest == true) {
      long timeToWait=stopTime - System.currentTimeMillis();
      if (timeToWait < 1) {
        double elapsed=(System.currentTimeMillis() - startTime) / 1000.0;
        throw new TimeoutException(""String_Node_Str"" + ""String_Node_Str"" + timeout + ""String_Node_Str""+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
      }
      try {
        clientStatusesLock.wait(timeToWait);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
        return null;
      }
    }
    clientStatus.hasRequestedCurrentTest=true;
    ++numClientsHaveRequestedTest;
    return currentTest;
  }
}","/** 
 * Called by the servlet to query for for the next method to test.
 * @param timeout how long to wait for an answer
 * @return the next test to run, or <code>null</code> if<code>timeout</code> is exceeded or the next test does not match <code>testClassName</code>
 */
public TestInfo getNextTestInfo(String clientId,long timeout) throws TimeoutException {
synchronized (clientStatusesLock) {
    ClientStatus clientStatus=clientStatuses.get(clientId);
    if (clientStatus == null) {
      clientStatus=new ClientStatus(clientId);
      clientStatuses.put(clientId,clientStatus);
    }
    long startTime=System.currentTimeMillis();
    long stopTime=startTime + timeout;
    while (clientStatus.currentTestResults != null) {
      long timeToWait=stopTime - System.currentTimeMillis();
      if (timeToWait < 1) {
        double elapsed=(System.currentTimeMillis() - startTime) / 1000.0;
        throw new TimeoutException(""String_Node_Str"" + ""String_Node_Str"" + timeout + ""String_Node_Str""+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ elapsed+ ""String_Node_Str"");
      }
      try {
        clientStatusesLock.wait(timeToWait);
      }
 catch (      InterruptedException e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
        return null;
      }
    }
    clientStatus.hasRequestedCurrentTest=true;
    ++numClientsHaveRequestedTest;
    return currentTest;
  }
}",0.9821865176388404
54823,"/** 
 * Fetches the results of a completed test.
 * @return A map of results from all clients.
 */
Map<String,JUnitResult> getResults(){
  Map<String,JUnitResult> result=new HashMap<String,JUnitResult>();
synchronized (clientStatusesLock) {
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      result.put(clientStatus.clientId,clientStatus.currentTestResults);
    }
  }
  return result;
}","/** 
 * Fetches the results of a completed test.
 * @return A map of results from all clients.
 */
Map<String,JUnitResult> getResults(){
synchronized (clientStatusesLock) {
    Map<String,JUnitResult> result=new HashMap<String,JUnitResult>();
    for (    ClientStatus clientStatus : clientStatuses.values()) {
      result.put(clientStatus.clientId,clientStatus.currentTestResults);
    }
    return result;
  }
}",0.866504854368932
54824,"/** 
 * Only instantiable within this package.
 * @param numClients The number of parallel clients being served by thisqueue.
 */
JUnitMessageQueue(int numClients){
  this.numClients=numClients;
}","/** 
 * Only instantiable within this package.
 * @param numClients The number of parallel clients being served by thisqueue.
 */
JUnitMessageQueue(int numClients){
synchronized (clientStatusesLock) {
    this.numClients=numClients;
  }
}",0.9032258064516128
54825,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
  addIssue(new Issue2339());
}",0.9465930018416208
54826,"@Override public void onStart(){
  onUpdate(0.0);
  UIObject.setVisible(container1,true);
  UIObject.setVisible(container2,true);
}","@Override public void onStart(){
  com.google.gwt.dom.client.Element deckElem=container1.getParentElement();
  int deckHeight=deckElem.getOffsetHeight();
  if (growing) {
    fixedHeight=container2.getOffsetHeight();
    container2.getStyle().setPropertyPx(""String_Node_Str"",fixedHeight - 1);
  }
 else {
    fixedHeight=container1.getOffsetHeight();
    container1.getStyle().setPropertyPx(""String_Node_Str"",fixedHeight - 1);
  }
  if (deckElem.getOffsetHeight() != deckHeight) {
    fixedHeight=-1;
  }
  onUpdate(0.0);
  UIObject.setVisible(container1,true);
  UIObject.setVisible(container2,true);
}",0.3569482288828338
54827,"@Override public void onUpdate(double progress){
  if (!growing) {
    progress=1.0 - progress;
  }
  int height1;
  int height2;
  if (fixedHeight == -1) {
    height1=(int)(progress * DOM.getElementPropertyInt(container1,""String_Node_Str""));
    height2=(int)((1.0 - progress) * DOM.getElementPropertyInt(container2,""String_Node_Str""));
  }
 else {
    height1=(int)(progress * fixedHeight);
    height2=fixedHeight - height1;
  }
  DOM.setStyleAttribute(container1,""String_Node_Str"",height1 + ""String_Node_Str"");
  DOM.setStyleAttribute(container2,""String_Node_Str"",height2 + ""String_Node_Str"");
}","@Override public void onUpdate(double progress){
  if (!growing) {
    progress=1.0 - progress;
  }
  int height1;
  int height2;
  if (fixedHeight == -1) {
    height1=(int)(progress * DOM.getElementPropertyInt(container1,""String_Node_Str""));
    height2=(int)((1.0 - progress) * DOM.getElementPropertyInt(container2,""String_Node_Str""));
  }
 else {
    height1=(int)(progress * fixedHeight);
    height2=fixedHeight - height1;
  }
  if (height1 == 0) {
    height1=1;
    height2=Math.max(1,height2 - 1);
  }
 else   if (height2 == 0) {
    height2=1;
    height1=Math.max(1,height1 - 1);
  }
  DOM.setStyleAttribute(container1,""String_Node_Str"",height1 + ""String_Node_Str"");
  DOM.setStyleAttribute(container2,""String_Node_Str"",height2 + ""String_Node_Str"");
}",0.8810572687224669
54828,"public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
}","public DefaultMuseum(){
  addIssue(new Issue1245());
  addIssue(new Issue1897());
  addIssue(new Issue2261());
  addIssue(new Issue2290());
  addIssue(new Issue2307());
  addIssue(new Issue2321());
  addIssue(new Issue2331());
  addIssue(new Issue2338());
}",0.9402061855670104
54829,"@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",height + ""String_Node_Str"");
  int scrollWidth=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",scrollWidth + ""String_Node_Str"");
}","@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  height=Math.max(height,1);
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",height + ""String_Node_Str"");
  int scrollWidth=DOM.getElementPropertyInt(curItem.childSpanElem,""String_Node_Str"");
  DOM.setStyleAttribute(curItem.childSpanElem,""String_Node_Str"",scrollWidth + ""String_Node_Str"");
}",0.9726156751652504
54830,"public CompilingClassLoader(TreeLogger logger,ByteCodeCompiler compiler,TypeOracle typeOracle) throws UnableToCompleteException {
  super(null);
  this.logger=logger;
  this.compiler=compiler;
  this.typeOracle=typeOracle;
  setDefaultAssertionStatus(true);
  for (int i=0; i < CacheManager.BOOTSTRAP_CLASSES.length; i++) {
    Class<?> clazz=CacheManager.BOOTSTRAP_CLASSES[i];
    String className=clazz.getName();
    try {
      String path=clazz.getName().replace('.','/').concat(""String_Node_Str"");
      ClassLoader cl=Thread.currentThread().getContextClassLoader();
      URL url=cl.getResource(path);
      if (url != null) {
        byte classBytes[]=getClassBytesFromStream(url.openStream());
        String loc=url.toExternalForm();
        compiler.putClassBytes(logger,className,classBytes,loc);
      }
 else {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + className + ""String_Node_Str"",null);
        throw new UnableToCompleteException();
      }
    }
 catch (    IOException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + className,e);
      throw new UnableToCompleteException();
    }
  }
  compiler.removeStaleByteCode(logger);
  JClassType jsoType=typeOracle.findType(JsValueGlue.JSO_CLASS);
  if (jsoType != null) {
    Set<JClassType> jsoTypes=new HashSet<JClassType>();
    JClassType[] jsoSubtypes=jsoType.getSubtypes();
    Collections.addAll(jsoTypes,jsoSubtypes);
    jsoTypes.add(jsoType);
    Set<String> jsoTypeNames=new HashSet<String>();
    for (    JClassType type : jsoTypes) {
      jsoTypeNames.add(getBinaryName(type));
    }
    MyInstanceMethodOracle mapper=new MyInstanceMethodOracle(jsoTypes,typeOracle.getJavaLangObject());
    classRewriter=new HostedModeClassRewriter(jsoTypeNames,mapper);
  }
 else {
    classRewriter=null;
  }
}","public CompilingClassLoader(TreeLogger logger,ByteCodeCompiler compiler,TypeOracle typeOracle,ShellJavaScriptHost javaScriptHost) throws UnableToCompleteException {
  super(null);
  this.logger=logger;
  this.compiler=compiler;
  this.typeOracle=typeOracle;
  this.shellJavaScriptHost=javaScriptHost;
  setDefaultAssertionStatus(true);
  for (  Class<?> clazz : CacheManager.BOOTSTRAP_CLASSES) {
    String className=clazz.getName();
    try {
      String path=clazz.getName().replace('.','/').concat(""String_Node_Str"");
      ClassLoader cl=Thread.currentThread().getContextClassLoader();
      URL url=cl.getResource(path);
      if (url != null) {
        byte classBytes[]=getClassBytesFromStream(url.openStream());
        String loc=url.toExternalForm();
        compiler.putClassBytes(logger,className,classBytes,loc);
      }
 else {
        logger.log(TreeLogger.ERROR,""String_Node_Str"" + className + ""String_Node_Str"",null);
        throw new UnableToCompleteException();
      }
    }
 catch (    IOException e) {
      logger.log(TreeLogger.ERROR,""String_Node_Str"" + className,e);
      throw new UnableToCompleteException();
    }
  }
  compiler.removeStaleByteCode(logger);
  JClassType jsoType=typeOracle.findType(JsValueGlue.JSO_CLASS);
  if (jsoType != null) {
    Set<JClassType> jsoTypes=new HashSet<JClassType>();
    JClassType[] jsoSubtypes=jsoType.getSubtypes();
    Collections.addAll(jsoTypes,jsoSubtypes);
    jsoTypes.add(jsoType);
    Set<String> jsoTypeNames=new HashSet<String>();
    for (    JClassType type : jsoTypes) {
      jsoTypeNames.add(getBinaryName(type));
    }
    MyInstanceMethodOracle mapper=new MyInstanceMethodOracle(jsoTypes,typeOracle.getJavaLangObject());
    classRewriter=new HostedModeClassRewriter(jsoTypeNames,mapper);
  }
 else {
    classRewriter=null;
  }
}",0.9524599226091764
54831,"void clear(){
  weakJsoCache.clear();
  weakJavaWrapperCache.clear();
  dispClassInfoOracle.clear();
}","void clear(){
  shellJavaScriptHost=null;
  updateJavaScriptHost();
  weakJsoCache.clear();
  weakJavaWrapperCache.clear();
  dispClassInfoOracle.clear();
}",0.7906976744186046
54832,"@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (className.equals(ShellJavaScriptHost.class.getName())) {
    return ShellJavaScriptHost.class;
  }
  byte[] classBytes;
  try {
    String lookupClassName=className;
    if (classRewriter != null && classRewriter.isJsoImpl(className)) {
      lookupClassName=className.substring(0,className.length() - 1);
    }
    classBytes=compiler.getClassBytes(logger,lookupClassName);
    if (classRewriter != null) {
      classBytes=classRewriter.rewrite(className,classBytes);
    }
    return defineClass(className,classBytes,0,classBytes.length);
  }
 catch (  UnableToCompleteException e) {
    throw new ClassNotFoundException(className);
  }
}","@Override protected synchronized Class<?> findClass(String className) throws ClassNotFoundException {
  if (className == null) {
    throw new ClassNotFoundException(""String_Node_Str"",new NullPointerException());
  }
  if (isInStandardJavaPackage(className)) {
    throw new ClassNotFoundException(className);
  }
  if (BRIDGE_CLASS_NAMES.containsKey(className)) {
    return BRIDGE_CLASS_NAMES.get(className);
  }
  byte[] classBytes;
  try {
    String lookupClassName=className;
    if (classRewriter != null && classRewriter.isJsoImpl(className)) {
      lookupClassName=className.substring(0,className.length() - 1);
    }
    classBytes=compiler.getClassBytes(logger,lookupClassName);
    if (classRewriter != null) {
      classBytes=classRewriter.rewrite(className,classBytes);
    }
    Class<?> newClass=defineClass(className,classBytes,0,classBytes.length);
    if (className.equals(JavaScriptHost.class.getName())) {
      javaScriptHostClass=newClass;
      updateJavaScriptHost();
    }
    JsniMethods jsniMethods=newClass.getAnnotation(JsniMethods.class);
    if (jsniMethods != null) {
      for (      JsniMethod jsniMethod : jsniMethods.value()) {
        shellJavaScriptHost.createNative(jsniMethod.file(),jsniMethod.line(),jsniMethod.name(),jsniMethod.paramNames(),jsniMethod.body());
      }
    }
    return newClass;
  }
 catch (  UnableToCompleteException e) {
    throw new ClassNotFoundException(className);
  }
}",0.7221990837151187
54833,"/** 
 * This method is called via reflection from the shell, providing the hosted mode application with all of the methods it needs to interface with the browser and the server (for deferred binding).
 */
public static void setHost(ShellJavaScriptHost host){
  sHost=host;
}","/** 
 * This method is called via reflection from the   {@link CompilingClassLoader}, providing the hosted mode application with all of the methods it needs to interface with the browser and the server (for deferred binding).
 */
public static void setHost(ShellJavaScriptHost host){
  sHost=host;
}",0.9389179755671904
54834,"@Override public void uninitElement(){
  unhookEvents();
  String html=getHTML();
  beforeInitPlaceholder=DOM.createDiv();
  DOM.setInnerHTML(beforeInitPlaceholder,html);
}","@Override public void uninitElement(){
  if (initializing) {
    initializing=false;
    return;
  }
  unhookEvents();
  String html=getHTML();
  beforeInitPlaceholder=DOM.createDiv();
  DOM.setInnerHTML(beforeInitPlaceholder,html);
}",0.8472906403940886
54835,"@Override protected void onElementInitialized(){
  super.onElementInitialized();
  if (beforeInitPlaceholder != null) {
    setHTMLImpl(DOM.getInnerHTML(beforeInitPlaceholder));
    beforeInitPlaceholder=null;
  }
}","@Override protected void onElementInitialized(){
  if (!initializing) {
    return;
  }
  initializing=false;
  super.onElementInitialized();
  if (beforeInitPlaceholder != null) {
    setHTMLImpl(DOM.getInnerHTML(beforeInitPlaceholder));
    beforeInitPlaceholder=null;
  }
}",0.8757637474541752
54836,"/** 
 * Test that an immediate set of text is reflected immediately and after a delay. Some platforms have timing subtleties that need to be tested.
 */
public void testSetTextBeforeInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  richTextArea.setText(""String_Node_Str"");
  assertEquals(""String_Node_Str"",richTextArea.getText());
  new Timer(){
    public void run(){
      assertEquals(""String_Node_Str"",richTextArea.getText());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}","/** 
 * Test that an immediate set of text is reflected immediately and after a delay. Some platforms have timing subtleties that need to be tested.
 */
public void testSetTextBeforeInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  richTextArea.setText(""String_Node_Str"");
  assertEquals(""String_Node_Str"",richTextArea.getText());
  new Timer(){
    @Override public void run(){
      assertEquals(""String_Node_Str"",richTextArea.getText());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}",0.9910554561717352
54837,"/** 
 * Test that a delayed set of HTML is reflected. Some platforms have timing subtleties that need to be tested.
 */
public void testSetHTMLAfterInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  new Timer(){
    public void run(){
      richTextArea.setHTML(""String_Node_Str"");
      assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}","/** 
 * Test that a delayed set of HTML is reflected. Some platforms have timing subtleties that need to be tested.
 */
public void testSetHTMLAfterInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  new Timer(){
    @Override public void run(){
      richTextArea.setHTML(""String_Node_Str"");
      assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}",0.9896907216494846
54838,"/** 
 * Test that delayed set of text is reflected. Some platforms have timing subtleties that need to be tested.
 */
public void testSetTextAfterInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  new Timer(){
    public void run(){
      richTextArea.setText(""String_Node_Str"");
      assertEquals(""String_Node_Str"",richTextArea.getText());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}","/** 
 * Test that delayed set of text is reflected. Some platforms have timing subtleties that need to be tested.
 */
public void testSetTextAfterInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  new Timer(){
    @Override public void run(){
      richTextArea.setText(""String_Node_Str"");
      assertEquals(""String_Node_Str"",richTextArea.getText());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}",0.9893390191897654
54839,"public void run(){
  assertEquals(""String_Node_Str"",richTextArea.getText());
  finishTest();
}","@Override public void run(){
  assertEquals(""String_Node_Str"",richTextArea.getText());
  finishTest();
}",0.9494949494949496
54840,"/** 
 * Test that an immediate set of HTML is reflected immediately and after a delay. Some platforms have timing subtleties that need to be tested.
 */
public void testSetHTMLBeforeInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  richTextArea.setHTML(""String_Node_Str"");
  assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
  new Timer(){
    public void run(){
      assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}","/** 
 * Test that an immediate set of HTML is reflected immediately and after a delay. Some platforms have timing subtleties that need to be tested.
 */
public void testSetHTMLBeforeInit(){
  final RichTextArea richTextArea=new RichTextArea();
  RootPanel.get().add(richTextArea);
  richTextArea.setHTML(""String_Node_Str"");
  assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
  new Timer(){
    @Override public void run(){
      assertEquals(""String_Node_Str"",richTextArea.getHTML().toLowerCase());
      finishTest();
    }
  }
.schedule(200);
  delayTestFinish(1000);
}",0.9914821124361158
54841,"public String getModuleName(){
  return ""String_Node_Str"";
}","@Override public String getModuleName(){
  return ""String_Node_Str"";
}",0.9230769230769232
54842,"/** 
 * Test that removing and re-adding an RTA doesn't destroy its contents (Only IE actually preserves dynamically-created iframe contents across DOM removal/re-adding).
 */
public void testAddEditRemoveAdd(){
  final RichTextArea area=new RichTextArea();
  RootPanel.get().add(area);
  area.setHTML(""String_Node_Str"");
  this.delayTestFinish(1000);
  new Timer(){
    public void run(){
      RootPanel.get().remove(area);
      RootPanel.get().add(area);
      assertEquals(""String_Node_Str"",area.getHTML());
      finishTest();
    }
  }
.schedule(500);
}","/** 
 * Test that removing and re-adding an RTA doesn't destroy its contents (Only IE actually preserves dynamically-created iframe contents across DOM removal/re-adding).
 */
public void testAddEditRemoveAdd(){
  final RichTextArea area=new RichTextArea();
  RootPanel.get().add(area);
  area.setHTML(""String_Node_Str"");
  this.delayTestFinish(1000);
  new Timer(){
    @Override public void run(){
      RootPanel.get().remove(area);
      RootPanel.get().add(area);
      assertEquals(""String_Node_Str"",area.getHTML());
      finishTest();
    }
  }
.schedule(500);
}",0.991150442477876
54843,"/** 
 * @see HasAnimation#isAnimationEnabled()
 */
public boolean isAnimationEnabled(){
  return isAnimationEnabled;
}","public boolean isAnimationEnabled(){
  return isAnimationEnabled;
}",0.7243243243243244
54844,"/** 
 * @see HasAnimation#setAnimationEnabled(boolean)
 */
public void setAnimationEnabled(boolean enable){
  isAnimationEnabled=enable;
}","public void setAnimationEnabled(boolean enable){
  isAnimationEnabled=enable;
}",0.728110599078341
54845,"@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curPanel.contentWrapper.getElement(),""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  DOM.setStyleAttribute(curPanel.contentWrapper.getElement(),""String_Node_Str"",height + ""String_Node_Str"");
  DOM.setStyleAttribute(curPanel.contentWrapper.getElement(),""String_Node_Str"",""String_Node_Str"");
}","@Override public void onUpdate(double progress){
  int scrollHeight=DOM.getElementPropertyInt(curPanel.contentWrapper.getElement(),""String_Node_Str"");
  int height=(int)(progress * scrollHeight);
  if (!opening) {
    height=scrollHeight - height;
  }
  height=Math.max(height,1);
  DOM.setStyleAttribute(curPanel.contentWrapper.getElement(),""String_Node_Str"",height + ""String_Node_Str"");
  DOM.setStyleAttribute(curPanel.contentWrapper.getElement(),""String_Node_Str"",""String_Node_Str"");
}",0.9694415173867228
54846,"public boolean removeAll(Collection<?> c){
  Iterator<?> iter=c.iterator();
  boolean changed=false;
  while (iter.hasNext()) {
    if (remove(iter.next())) {
      changed=true;
    }
  }
  return changed;
}","public boolean removeAll(Collection<?> c){
  Iterator<?> iter=iterator();
  boolean changed=false;
  while (iter.hasNext()) {
    if (c.contains(iter.next())) {
      iter.remove();
      changed=true;
    }
  }
  return changed;
}",0.8701594533029613
54847,"protected final void rememberDecodedObject(Object o){
  seenArray.add(o);
}","protected final void rememberDecodedObject(int index,Object o){
  seenArray.set(index - 1,o);
}",0.8470588235294118
54848,"@Override protected Object deserialize(String typeSignature) throws SerializationException {
  Object instance=serializer.instantiate(this,typeSignature);
  rememberDecodedObject(instance);
  serializer.deserialize(this,instance,typeSignature);
  return instance;
}","@Override protected Object deserialize(String typeSignature) throws SerializationException {
  int id=reserveDecodedObjectIndex();
  Object instance=serializer.instantiate(this,typeSignature);
  rememberDecodedObject(id,instance);
  serializer.deserialize(this,instance,typeSignature);
  return instance;
}",0.9281961471103328
54849,"@Override protected Object deserialize(String typeSignature) throws SerializationException {
  Object instance=null;
  SerializedInstanceReference serializedInstRef=SerializabilityUtil.decodeSerializedInstanceReference(typeSignature);
  try {
    Class<?> instanceClass=Class.forName(serializedInstRef.getName(),false,classLoader);
    assert(serializationPolicy != null);
    serializationPolicy.validateDeserialize(instanceClass);
    validateTypeVersions(instanceClass,serializedInstRef);
    Class<?> customSerializer=SerializabilityUtil.hasCustomFieldSerializer(instanceClass);
    instance=instantiate(customSerializer,instanceClass);
    rememberDecodedObject(instance);
    Object replacement=deserializeImpl(customSerializer,instanceClass,instance);
    if (instance != replacement) {
      replaceRememberedObject(instance,replacement);
      instance=replacement;
    }
    return instance;
  }
 catch (  ClassNotFoundException e) {
    throw new SerializationException(e);
  }
catch (  InstantiationException e) {
    throw new SerializationException(e);
  }
catch (  IllegalAccessException e) {
    throw new SerializationException(e);
  }
catch (  IllegalArgumentException e) {
    throw new SerializationException(e);
  }
catch (  InvocationTargetException e) {
    throw new SerializationException(e);
  }
catch (  NoSuchMethodException e) {
    throw new SerializationException(e);
  }
}","@Override protected Object deserialize(String typeSignature) throws SerializationException {
  Object instance=null;
  SerializedInstanceReference serializedInstRef=SerializabilityUtil.decodeSerializedInstanceReference(typeSignature);
  try {
    Class<?> instanceClass=Class.forName(serializedInstRef.getName(),false,classLoader);
    assert(serializationPolicy != null);
    serializationPolicy.validateDeserialize(instanceClass);
    validateTypeVersions(instanceClass,serializedInstRef);
    Class<?> customSerializer=SerializabilityUtil.hasCustomFieldSerializer(instanceClass);
    int index=reserveDecodedObjectIndex();
    instance=instantiate(customSerializer,instanceClass);
    rememberDecodedObject(index,instance);
    Object replacement=deserializeImpl(customSerializer,instanceClass,instance);
    if (instance != replacement) {
      rememberDecodedObject(index,replacement);
      instance=replacement;
    }
    return instance;
  }
 catch (  ClassNotFoundException e) {
    throw new SerializationException(e);
  }
catch (  InstantiationException e) {
    throw new SerializationException(e);
  }
catch (  IllegalAccessException e) {
    throw new SerializationException(e);
  }
catch (  IllegalArgumentException e) {
    throw new SerializationException(e);
  }
catch (  InvocationTargetException e) {
    throw new SerializationException(e);
  }
catch (  NoSuchMethodException e) {
    throw new SerializationException(e);
  }
}",0.8387096774193549
54850,"public void onFailure(Throwable caught){
  fail(""String_Node_Str"");
}","public void onFailure(Throwable caught){
  fail(""String_Node_Str"" + caught);
}",0.9387755102040816
54851,"public void onSuccess(Object result){
  assertNotNull(result);
  assertTrue(CustomFieldSerializerTestSetValidator.isValid((SerializableSubclass)result));
  finishTest();
}","public void onSuccess(Object result){
  assertNotNull(result);
  assertTrue(CustomFieldSerializerTestSetValidator.isValid((ManuallySerializedImmutableClass[])result));
  finishTest();
}",0.9382022471910112
54852,"public <T>T[] toArray(T[] a){
  int size=size();
  if (a.length < size) {
    a=Array.clonify(a,size);
  }
  Object[] result=a;
  Iterator<E> it=iterator();
  for (int i=0; i < size; ++i) {
    result[i]=it.next();
  }
  if (a.length > size) {
    a[size]=null;
  }
  return a;
}","public <T>T[] toArray(T[] a){
  int size=size();
  if (a.length < size) {
    a=Array.createFrom(a,size);
  }
  Object[] result=a;
  Iterator<E> it=iterator();
  for (int i=0; i < size; ++i) {
    result[i]=it.next();
  }
  if (a.length > size) {
    a[size]=null;
  }
  return a;
}",0.9732620320855616
54853,"@Override public <T>T[] toArray(T[] out){
  if (out.length < size) {
    out=Array.clonify(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=ArrayList.<T>getImpl(array,i);
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}","@Override public <T>T[] toArray(T[] out){
  if (out.length < size) {
    out=Array.createFrom(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=ArrayList.<T>getImpl(array,i);
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}",0.9702970297029704
54854,"@SuppressWarnings(""String_Node_Str"") @Override public <T>T[] toArray(T[] out){
  int size=size();
  if (out.length < size) {
    out=Array.clonify(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=(T)array[i];
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}","@SuppressWarnings(""String_Node_Str"") @Override public <T>T[] toArray(T[] out){
  int size=size();
  if (out.length < size) {
    out=Array.createFrom(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=(T)array[i];
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}",0.974182444061962
54855,"public Entry<K,V> next(){
  key=it.next();
  return new MapEntryImpl<K,V>(key,values.get(key.ordinal()));
}","public Entry<K,V> next(){
  key=it.next();
  return new MapEntry(key);
}",0.8044692737430168
54856,"/** 
 * Returns <code>key</code> as <code>K</code>. Doesn't actually perform any runtime checks. Should only be called when you are sure <code>key</code> is of type <code>K</code>.
 */
@SuppressWarnings(""String_Node_Str"") private K asKey(Object key){
  return (K)key;
}","/** 
 * Returns <code>key</code> as <code>K</code>. Only runtime checks that key is an Enum, not that it's the particular Enum K. Should only be called when you are sure <code>key</code> is of type <code>K</code>.
 */
@SuppressWarnings(""String_Node_Str"") private K asKey(Object key){
  return (K)key;
}",0.8021015761821366
54857,"private void init(EnumMap<K,? extends V> m){
  allEnums=m.allEnums;
  keySet=m.keySet.clone();
  values=new ArrayList<V>(m.values);
}","private void init(EnumMap<K,? extends V> m){
  keySet=m.keySet.clone();
  values=Array.clone(m.values);
}",0.8319327731092437
54858,"@Override public void clear(){
  keySet.clear();
  Collections.fill(values,null);
}","@SuppressWarnings(""String_Node_Str"") @Override public void clear(){
  keySet.clear();
  values=(V[])new Object[values.length];
}",0.5971563981042654
54859,"@Override public V remove(Object key){
  return keySet.remove(key) ? values.set(asKey(key).ordinal(),null) : null;
}","@Override public V remove(Object key){
  return keySet.remove(key) ? set(asOrdinal(key),null) : null;
}",0.9041095890410958
54860,"@Override public boolean containsValue(Object value){
  if (value != null) {
    return values.contains(value);
  }
  for (int i=0, n=values.size(); i < n; ++i) {
    V v=values.get(i);
    if (v == null && keySet.contains(allEnums[i])) {
      return true;
    }
  }
  return false;
}","@Override public boolean containsValue(Object value){
  for (  K key : keySet) {
    if (Utility.equalsWithNullCheck(value,values[key.ordinal()])) {
      return true;
    }
  }
  return false;
}",0.575
54861,"@Override public V put(K key,V value){
  keySet.add(key);
  return values.set(key.ordinal(),value);
}","@Override public V put(K key,V value){
  keySet.add(key);
  return set(key.ordinal(),value);
}",0.964102564102564
54862,"public Iterator<Map.Entry<K,V>> iterator(){
  return new Iterator<Entry<K,V>>(){
    Iterator<K> it=keySet.iterator();
    K key;
    public boolean hasNext(){
      return it.hasNext();
    }
    public Entry<K,V> next(){
      key=it.next();
      return new MapEntryImpl<K,V>(key,values.get(key.ordinal()));
    }
    public void remove(){
      if (key == null) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      EnumMap.this.remove(key);
      key=null;
    }
  }
;
}","@Override public Iterator<Entry<K,V>> iterator(){
  return new EntrySetIterator();
}",0.2512908777969019
54863,"@Override public V get(Object k){
  return keySet.contains(k) ? values.get(asKey(k).ordinal()) : null;
}","@Override public V get(Object k){
  return keySet.contains(k) ? values[asOrdinal(k)] : null;
}",0.9090909090909092
54864,"private static native void addAllStringEntries(JavaScriptObject stringMap,Collection<?> dest);",private native void addAllStringEntries(Collection<?> dest);,0.7792207792207793
54865,"private static native void addAllHashEntries(JavaScriptObject hashCodeMap,Collection<?> dest);",private native void addAllHashEntries(Collection<?> dest);,0.7631578947368421
54866,"/** 
 * Constructor for <code>EntrySetIterator</code>.
 */
public EntrySetIterator(){
  List<Map.Entry<K,V>> list=new ArrayList<Map.Entry<K,V>>();
  if (nullSlotLive) {
    MapEntryImpl<K,V> entryImpl=new MapEntryImpl<K,V>(null,nullSlot);
    list.add(entryImpl);
  }
  addAllStringEntries(stringMap,list);
  addAllHashEntries(hashCodeMap,list);
  this.iter=list.iterator();
}","/** 
 * Constructor for <code>EntrySetIterator</code>.
 */
public EntrySetIterator(){
  List<Map.Entry<K,V>> list=new ArrayList<Map.Entry<K,V>>();
  if (nullSlotLive) {
    list.add(new MapEntryNull());
  }
  addAllStringEntries(list);
  addAllHashEntries(list);
  this.iter=list.iterator();
}",0.547085201793722
54867,"@Override public <T>T[] toArray(T[] a){
  if (a.length < size) {
    a=Array.clonify(a,size);
  }
  for (int i=0; i < size; ++i) {
    a[i]=ArrayList.<T>getImpl(array,i);
  }
  if (a.length > size) {
    a[size]=null;
  }
  return a;
}","@Override public <T>T[] toArray(T[] out){
  if (out.length < size) {
    out=Array.clonify(out,size);
  }
  for (int i=0; i < size; ++i) {
    out[i]=ArrayList.<T>getImpl(array,i);
  }
  if (out.length > size) {
    out[size]=null;
  }
  return out;
}",0.7777777777777778
54868,"public static <T>List<T> asList(T... array){
  List<T> accum=new ArrayList<T>();
  for (int i=0; i < array.length; i++) {
    accum.add(array[i]);
  }
  return accum;
}","public static <T>List<T> asList(T... array){
  return new ArrayList<T>(array);
}",0.6048387096774194
54869,"/** 
 * Tests   {@link Arrays#asList(Object[])}.
 */
public void testAsList(){
  Object[] test={};
  List result=Arrays.asList(test);
  assertEquals(test,result);
  Object[] test2={new Integer(0),new Integer(1),new Integer(2)};
  List result2=Arrays.asList(test2);
  assertEquals(test2,result2);
  Object[] test3={""String_Node_Str""};
  List result3=Arrays.asList(test3);
  assertEquals(test3,result3);
}","/** 
 * Tests   {@link Arrays#asList(Object[])}.
 */
@SuppressWarnings(""String_Node_Str"") public void testAsList(){
  Object[] test={};
  List result=Arrays.asList(test);
  assertEquals(test,result);
  Object[] test2={0,1,2};
  List result2=Arrays.asList(test2);
  assertEquals(test2,result2);
  Object[] test3={""String_Node_Str""};
  List result3=Arrays.asList(test3);
  assertEquals(test3,result3);
}",0.3582089552238806
54870,"/** 
 * Test Arrays.binarySearch(Object[], Object, Comparator). <pre> Verify the following cases: empty array odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements Comparator uses natural ordering as a default </pre>
 */
public void testBinarySearchObjectComparator(){
  Comparator inverseSort=new Comparator(){
    public int compare(    Object o1,    Object o2){
      return ((Comparable)o2).compareTo(o1);
    }
  }
;
  Object[] a1={};
  int ret=Arrays.binarySearch(a1,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  Object[] a2={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(-3,ret);
  ret=Arrays.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(2,ret);
  Object[] a3={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-5,ret);
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(0,ret);
  Object[] a4={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a4,""String_Node_Str"",null);
  assertEquals(3,ret);
}","/** 
 * Test Arrays.binarySearch(Object[], Object, Comparator). <pre> Verify the following cases: empty array odd numbers of elements even numbers of elements not found value larger than all elements not found value smaller than all elements Comparator uses natural ordering as a default </pre>
 */
@SuppressWarnings(""String_Node_Str"") public void testBinarySearchObjectComparator(){
  Comparator inverseSort=new Comparator(){
    public int compare(    Object o1,    Object o2){
      return ((Comparable)o2).compareTo(o1);
    }
  }
;
  Object[] a1={};
  int ret=Arrays.binarySearch(a1,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  Object[] a2={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(-3,ret);
  ret=Arrays.binarySearch(a2,""String_Node_Str"",inverseSort);
  assertEquals(2,ret);
  Object[] a3={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-5,ret);
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(-1,ret);
  ret=Arrays.binarySearch(a3,""String_Node_Str"",inverseSort);
  assertEquals(0,ret);
  Object[] a4={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ret=Arrays.binarySearch(a4,""String_Node_Str"",null);
  assertEquals(3,ret);
}",0.986724076067456
54871,"/** 
 * Tests sorting a subrange of a primitive array.
 */
public void testPrimitiveSubrangeSort(){
  int[] x=new int[]{3,11,2,1,22,3};
  Arrays.sort(x,1,5);
  assertEquals(3,x[0]);
  assertEquals(1,x[1]);
  assertEquals(2,x[2]);
  assertEquals(11,x[3]);
  assertEquals(22,x[4]);
  assertEquals(3,x[5]);
}","/** 
 * Tests sorting a subrange of a primitive array.
 */
public void testPrimitiveSubrangeSort(){
  int[] x={3,11,2,1,22,3};
  Arrays.sort(x,1,5);
  assertEquals(3,x[0]);
  assertEquals(1,x[1]);
  assertEquals(2,x[2]);
  assertEquals(11,x[3]);
  assertEquals(22,x[4]);
  assertEquals(3,x[5]);
}",0.9850249584026622
54872,"/** 
 * Verifies that values are sorted numerically rather than as strings.
 */
public void testNumericSort(){
  Integer[] x=new Integer[]{new Integer(3),new Integer(11),new Integer(2),new Integer(1)};
  Arrays.sort(x);
  assertEquals(2,x[1].intValue());
  assertEquals(11,x[3].intValue());
}","/** 
 * Verifies that values are sorted numerically rather than as strings.
 */
public void testNumericSort(){
  Integer[] x={3,11,2,1};
  Arrays.sort(x);
  assertEquals(2,x[1].intValue());
  assertEquals(11,x[3].intValue());
}",0.8516377649325626
54873,"/** 
 * Tests sorting primitives.
 */
public void testPrimitiveSort(){
  int[] x=new int[]{3,11,2,1,22,3};
  Arrays.sort(x);
  assertEquals(1,x[0]);
  assertEquals(2,x[1]);
  assertEquals(3,x[2]);
  assertEquals(3,x[3]);
  assertEquals(11,x[4]);
  assertEquals(22,x[5]);
}","/** 
 * Tests sorting primitives.
 */
public void testPrimitiveSort(){
  int[] x={3,11,2,1,22,3};
  Arrays.sort(x);
  assertEquals(1,x[0]);
  assertEquals(2,x[1]);
  assertEquals(3,x[2]);
  assertEquals(3,x[3]);
  assertEquals(11,x[4]);
  assertEquals(22,x[5]);
}",0.983177570093458
54874,"/** 
 * Tests   {@link Arrays#sort(Object[],Comparator)}.
 */
public void testSort(){
  Object[] x={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int hash=x[1].hashCode();
  Arrays.sort(x);
  int hash2=x[1].hashCode();
  assertEquals(hash,hash2);
  Object[] sorted={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,sorted);
  Comparator<Object> t=new Comparator<Object>(){
    public int compare(    Object o1,    Object o2){
      return ((Comparable<Object>)o2).compareTo(o1);
    }
  }
;
  Arrays.sort(x,t);
  int hash3=x[1].hashCode();
  assertEquals(hash,hash3);
  Object[] reverseSorted={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,reverseSorted);
}","/** 
 * Tests   {@link Arrays#sort(Object[],Comparator)}.
 */
public void testSort(){
  Object[] x={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  int hash=x[1].hashCode();
  Arrays.sort(x);
  int hash2=x[1].hashCode();
  assertEquals(hash,hash2);
  Object[] sorted={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,sorted);
  Comparator<Object> t=new Comparator<Object>(){
    @SuppressWarnings(""String_Node_Str"") public int compare(    Object o1,    Object o2){
      return ((Comparable<Object>)o2).compareTo(o1);
    }
  }
;
  Arrays.sort(x,t);
  int hash3=x[1].hashCode();
  assertEquals(hash,hash3);
  Object[] reverseSorted={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertEquals(x,reverseSorted);
}",0.9766561514195584
54875,"/** 
 * Tests simple use cases for   {@link Arrays#sort(Object[])}.
 */
public void testSimpleSort(){
  Object[] test={};
  Arrays.sort(test);
  assertEquals(test.length,0);
  Integer[] test2={new Integer(1)};
  Arrays.sort(test2);
  assertEquals(1,test2[0].intValue());
  Number[] test3={new Integer(3),new Integer(0),new Integer(2),new Integer(4),new Integer(1)};
  Arrays.sort(test3);
  for (int i=0; i < test3.length; i++) {
    assertEquals(i,test3[i].intValue());
  }
}","/** 
 * Tests simple use cases for   {@link Arrays#sort(Object[])}.
 */
public void testSimpleSort(){
  Object[] test={};
  Arrays.sort(test);
  assertEquals(test.length,0);
  Integer[] test2={1};
  Arrays.sort(test2);
  assertEquals(1,test2[0].intValue());
  Number[] test3={3,0,2,4,1};
  Arrays.sort(test3);
  for (int i=0; i < test3.length; i++) {
    assertEquals(i,test3[i].intValue());
  }
}",0.8990825688073395
54876,"private void generateClassLiterals(JsVars vars){
  for (  JType type : classLits.keySet()) {
    JsName jsName=classLits.get(type);
    JsExpression classObjectAlloc=classObjects.get(jsName);
    JsVar var=new JsVar(jsName);
    var.setInitExpr(classObjectAlloc);
    vars.add(var);
  }
}","private void generateClassLiterals(JsVars vars){
  JClassType objType=program.getTypeJavaLangObject();
  if (classLits.containsKey(objType)) {
    generateClassLiteral(objType,vars);
  }
  for (  JType type : classLits.keySet()) {
    if (type != objType) {
      generateClassLiteral(type,vars);
    }
  }
}",0.3624161073825503
54877,"/** 
 * Adds the specified widget to the deck.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element container=DOM.createDiv();
  DOM.appendChild(getElement(),container);
  initChildWidget(w);
  initWidgetContainer(container);
  super.add(w,container);
}","/** 
 * Adds the specified widget to the deck.
 * @param w the widget to be added
 */
@Override public void add(Widget w){
  Element container=createWidgetContainer();
  DOM.appendChild(getElement(),container);
  super.add(w,container);
  finishWidgetInitialization(container,w);
}",0.6172839506172839
54878,"/** 
 * Inserts a widget before the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  Element container=DOM.createDiv();
  DOM.insertChild(getElement(),container,beforeIndex);
  initChildWidget(w);
  initWidgetContainer(container);
  super.insert(w,container,beforeIndex,true);
}","/** 
 * Inserts a widget before the specified index.
 * @param w the widget to be inserted
 * @param beforeIndex the index before which it will be inserted
 * @throws IndexOutOfBoundsException if <code>beforeIndex</code> is out ofrange
 */
public void insert(Widget w,int beforeIndex){
  Element container=createWidgetContainer();
  DOM.insertChild(getElement(),container,beforeIndex);
  super.insert(w,container,beforeIndex,true);
  finishWidgetInitialization(container,w);
}",0.7063740856844305
54879,"public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  return suite;
}","public static Test suite(){
  GWTTestSuite suite=new GWTTestSuite(""String_Node_Str"");
  suite.addTestSuite(AbsolutePanelTest.class);
  suite.addTestSuite(CaptionPanelTest.class);
  suite.addTestSuite(CheckBoxTest.class);
  suite.addTestSuite(ClippedImagePrototypeTest.class);
  suite.addTestSuite(CommandExecutorTest.class);
  suite.addTestSuite(CompositeTest.class);
  suite.addTestSuite(CookieTest.class);
  suite.addTestSuite(CustomButtonTest.class);
  suite.addTestSuite(DeckPanelTest.class);
  suite.addTestSuite(DecoratorPanelTest.class);
  suite.addTestSuite(DelegatingKeyboardListenerCollectionTest.class);
  suite.addTestSuite(DialogBoxTest.class);
  suite.addTestSuite(DisclosurePanelTest.class);
  suite.addTestSuite(DockPanelTest.class);
  suite.addTestSuite(DOMTest.class);
  suite.addTestSuite(FastStringMapTest.class);
  suite.addTestSuite(FlexTableTest.class);
  suite.addTestSuite(FlowPanelTest.class);
  suite.addTestSuite(FocusPanelTest.class);
  suite.addTestSuite(GridTest.class);
  suite.addTestSuite(HiddenTest.class);
  suite.addTestSuite(HorizontalPanelTest.class);
  suite.addTestSuite(HTMLPanelTest.class);
  suite.addTestSuite(HyperlinkTest.class);
  suite.addTestSuite(ImageBundleGeneratorTest.class);
  suite.addTestSuite(ImageTest.class);
  suite.addTestSuite(LinearPanelTest.class);
  suite.addTestSuite(ListBoxTest.class);
  suite.addTestSuite(MenuBarTest.class);
  suite.addTestSuite(NamedFrameTest.class);
  suite.addTestSuite(PanelTest.class);
  suite.addTestSuite(PopupTest.class);
  suite.addTestSuite(PrefixTreeTest.class);
  suite.addTestSuite(RadioButtonTest.class);
  suite.addTestSuite(RichTextAreaTest.class);
  suite.addTestSuite(ScrollPanelTest.class);
  suite.addTestSuite(SplitPanelTest.class);
  suite.addTestSuite(StackPanelTest.class);
  suite.addTestSuite(TabBarTest.class);
  suite.addTestSuite(TabPanelTest.class);
  suite.addTestSuite(TextAreaTest.class);
  suite.addTestSuite(TreeTest.class);
  suite.addTestSuite(UIObjectTest.class);
  suite.addTestSuite(VerticalPanelTest.class);
  suite.addTestSuite(WidgetCollectionTest.class);
  suite.addTestSuite(WidgetIteratorsTest.class);
  suite.addTestSuite(WidgetOnLoadTest.class);
  suite.addTestSuite(WindowTest.class);
  suite.addTestSuite(XMLTest.class);
  return suite;
}",0.9904677455109732
54880,"public boolean addAll(int index,Collection<? extends E> c){
  Iterator<? extends E> iter=c.iterator();
  while (iter.hasNext()) {
    add(index,iter.next());
    ++index;
  }
  return !c.isEmpty();
}","public boolean addAll(int index,Collection<? extends E> c){
  Iterator<? extends E> iter=c.iterator();
  while (iter.hasNext()) {
    add(index++,iter.next());
  }
  return !c.isEmpty();
}",0.9612403100775194
54881,"@Override public boolean addAll(Collection<? extends E> c){
  Iterator<? extends E> iter=c.iterator();
  boolean changed=iter.hasNext();
  while (iter.hasNext()) {
    setImpl(array,size++,iter.next());
  }
  return changed;
}","public boolean addAll(int index,Collection<? extends E> c){
  if (c.isEmpty()) {
    return false;
  }
  if (index < 0 || index > size) {
    indexOutOfBounds(index,size);
  }
  insertImpl(array,index,c.toArray());
  size+=c.size();
  return true;
}",0.3452631578947368
54882,"private boolean computeHasClinitRecursive(JReferenceType type,Set<JReferenceType> computed,Set<JReferenceType> alreadySeen){
  alreadySeen.add(type);
  if (computed.contains(type)) {
    return hasClinitSet.contains(type);
  }
  JMethod method=type.methods.get(0);
  assert(JProgram.isClinit(method));
  CheckClinitVisitor v=new CheckClinitVisitor();
  v.accept(method);
  if (v.hasNonClinitCalls()) {
    return true;
  }
  for (  JReferenceType target : v.getClinitTargets()) {
    if (alreadySeen.contains(target)) {
      continue;
    }
    if (computeHasClinitRecursive(target,computed,alreadySeen)) {
      return true;
    }
 else {
      continue;
    }
  }
  return false;
}","private boolean computeHasClinitRecursive(JReferenceType type,Set<JReferenceType> computed,Set<JReferenceType> alreadySeen){
  alreadySeen.add(type);
  if (computed.contains(type)) {
    return hasClinitSet.contains(type);
  }
  JMethod method=type.methods.get(0);
  assert(JProgram.isClinit(method));
  CheckClinitVisitor v=new CheckClinitVisitor();
  v.accept(method);
  if (v.hasLiveCode()) {
    return true;
  }
  for (  JReferenceType target : v.getClinitTargets()) {
    if (alreadySeen.contains(target)) {
      continue;
    }
    if (computeHasClinitRecursive(target,computed,alreadySeen)) {
      return true;
    }
 else {
      continue;
    }
  }
  return false;
}",0.9838472834067548
54883,"@Override public boolean visit(JMultiExpression x,Context ctx){
  for (  JExpression expr : x.exprs) {
    if (canContainClinitCalls(expr)) {
      accept(expr);
    }
 else {
      hasNonClinitCalls=true;
    }
  }
  return false;
}","@Override public boolean visit(JMultiExpression x,Context ctx){
  for (  JExpression expr : x.exprs) {
    if (mightBeDeadCode(expr)) {
      accept(expr);
    }
 else {
      hasLiveCode=true;
    }
  }
  return false;
}",0.5550660792951542
54884,"public static Boolean valueOf(String s){
  if (s != null && s.equalsIgnoreCase(""String_Node_Str"")) {
    return TRUE;
  }
 else {
    return FALSE;
  }
}","public static Boolean valueOf(String s){
  return valueOf(parseBoolean(s));
}",0.4608695652173913
54885,"@Override public int hashCode(){
  final int hashCodeForTrue=1231;
  final int hashCodeForFalse=1237;
  return value ? hashCodeForTrue : hashCodeForFalse;
}","@Override public int hashCode(){
  return value ? 1231 : 1237;
}",0.509090909090909
54886,"public int compareTo(Boolean other){
  if (!value) {
    return other.value ? -1 : 0;
  }
 else {
    return other.value ? 0 : 1;
  }
}","public int compareTo(Boolean other){
  return (this.value == other.value) ? 0 : (this.value ? 1 : -1);
}",0.6778242677824268
54887,"public Boolean(String s){
  this((s != null) && s.equalsIgnoreCase(""String_Node_Str""));
}","public Boolean(String s){
  this(parseBoolean(s));
}",0.5673758865248227
54888,"@Override public void onBrowserEvent(Event event){
  int eventType=DOM.eventGetType(event);
switch (eventType) {
case Event.ONCLICK:
{
      Element e=DOM.eventGetTarget(event);
      if (shouldTreeDelegateFocusToElement(e)) {
      }
 else {
        setFocus(true);
      }
      break;
    }
case Event.ONMOUSEDOWN:
{
    if (mouseListeners != null) {
      mouseListeners.fireMouseEvent(this,event);
    }
    if (DOM.eventGetCurrentTarget(event) == getElement()) {
      elementClicked(DOM.eventGetTarget(event));
    }
    break;
  }
case Event.ONMOUSEUP:
{
  if (mouseListeners != null) {
    mouseListeners.fireMouseEvent(this,event);
  }
  break;
}
case Event.ONMOUSEMOVE:
{
if (mouseListeners != null) {
  mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEOVER:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEOUT:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONFOCUS:
if (focusListeners != null) {
focusListeners.fireFocusEvent(this,event);
}
break;
case Event.ONBLUR:
{
if (focusListeners != null) {
focusListeners.fireFocusEvent(this,event);
}
break;
}
case Event.ONKEYDOWN:
if (DOM.eventGetAltKey(event) || DOM.eventGetMetaKey(event)) {
super.onBrowserEvent(event);
return;
}
if (curSelection == null) {
if (root.getChildCount() > 0) {
onSelection(root.getChild(0),true,true);
}
super.onBrowserEvent(event);
return;
}
if (lastEventType == Event.ONKEYDOWN) {
return;
}
if (isKeyboardNavigationEnabled(curSelection)) {
switch (DOM.eventGetKeyCode(event)) {
case KeyboardListener.KEY_UP:
{
moveSelectionUp(curSelection);
DOM.eventPreventDefault(event);
break;
}
case KeyboardListener.KEY_DOWN:
{
moveSelectionDown(curSelection,true);
DOM.eventPreventDefault(event);
break;
}
case KeyboardListener.KEY_LEFT:
{
if (LocaleInfo.getCurrentLocale().isRTL()) {
maybeExpandTreeItem();
}
 else {
maybeCollapseTreeItem();
}
DOM.eventPreventDefault(event);
break;
}
case KeyboardListener.KEY_RIGHT:
{
if (LocaleInfo.getCurrentLocale().isRTL()) {
maybeCollapseTreeItem();
}
 else {
maybeExpandTreeItem();
}
DOM.eventPreventDefault(event);
break;
}
}
}
case Event.ONKEYUP:
if (eventType == Event.ONKEYUP) {
if (DOM.eventGetKeyCode(event) == KeyboardListener.KEY_TAB) {
ArrayList<Element> chain=new ArrayList<Element>();
collectElementChain(chain,getElement(),DOM.eventGetTarget(event));
TreeItem item=findItemByChain(chain,0,root);
if (item != getSelectedItem()) {
setSelectedItem(item,true);
}
}
}
case Event.ONKEYPRESS:
{
if (keyboardListeners != null) {
keyboardListeners.fireKeyboardEvent(this,event);
}
break;
}
}
super.onBrowserEvent(event);
lastEventType=eventType;
}","@Override @SuppressWarnings(""String_Node_Str"") public void onBrowserEvent(Event event){
  int eventType=DOM.eventGetType(event);
switch (eventType) {
case Event.ONKEYDOWN:
{
      if (curSelection == null) {
        if (root.getChildCount() > 0) {
          onSelection(root.getChild(0),true,true);
        }
        super.onBrowserEvent(event);
        return;
      }
    }
case Event.ONKEYPRESS:
case Event.ONKEYUP:
  if (DOM.eventGetAltKey(event) || DOM.eventGetMetaKey(event)) {
    super.onBrowserEvent(event);
    return;
  }
break;
}
switch (eventType) {
case Event.ONCLICK:
{
Element e=DOM.eventGetTarget(event);
if (shouldTreeDelegateFocusToElement(e)) {
}
 else {
  setFocus(true);
}
break;
}
case Event.ONMOUSEDOWN:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
if (DOM.eventGetCurrentTarget(event) == getElement()) {
elementClicked(DOM.eventGetTarget(event));
}
break;
}
case Event.ONMOUSEUP:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEMOVE:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEOVER:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONMOUSEOUT:
{
if (mouseListeners != null) {
mouseListeners.fireMouseEvent(this,event);
}
break;
}
case Event.ONFOCUS:
if (focusListeners != null) {
focusListeners.fireFocusEvent(this,event);
}
break;
case Event.ONBLUR:
{
if (focusListeners != null) {
focusListeners.fireFocusEvent(this,event);
}
break;
}
case Event.ONKEYDOWN:
{
keyboardNavigation(event);
lastWasKeyDown=true;
break;
}
case Event.ONKEYPRESS:
{
if (!lastWasKeyDown) {
keyboardNavigation(event);
}
lastWasKeyDown=false;
break;
}
case Event.ONKEYUP:
{
if (DOM.eventGetKeyCode(event) == KeyboardListener.KEY_TAB) {
ArrayList<Element> chain=new ArrayList<Element>();
collectElementChain(chain,getElement(),DOM.eventGetTarget(event));
TreeItem item=findItemByChain(chain,0,root);
if (item != getSelectedItem()) {
setSelectedItem(item,true);
}
}
lastWasKeyDown=false;
break;
}
}
switch (eventType) {
case Event.ONKEYDOWN:
case Event.ONKEYUP:
case Event.ONKEYPRESS:
{
if (keyboardListeners != null) {
keyboardListeners.fireKeyboardEvent(this,event);
}
if (isArrowKey(DOM.eventGetKeyCode(event))) {
DOM.eventCancelBubble(event,true);
DOM.eventPreventDefault(event);
}
break;
}
}
super.onBrowserEvent(event);
}",0.6317844591956268
54889,"/** 
 * Evaluates a trusted JSON string and returns its JSONValue representation. CAUTION! For efficiency, this method is implemented using the JavaScript <code>eval()</code> function, which can execute arbitrary script. DO NOT pass an untrusted string into this method.
 * @param jsonString a JSON object to parse
 * @return a JSONValue that has been built by parsing the JSON string
 * @throws NullPointerException if <code>jsonString</code> is<code>null</code>
 * @throws IllegalArgumentException if <code>jsonString</code> is empty
 */
public static JSONValue parse(String jsonString){
  if (jsonString == null) {
    throw new NullPointerException();
  }
  if (jsonString == ""String_Node_Str"") {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return evaluate(jsonString);
  }
 catch (  JavaScriptException ex) {
    throw new JSONException(ex);
  }
}","/** 
 * Evaluates a trusted JSON string and returns its JSONValue representation. CAUTION! For efficiency, this method is implemented using the JavaScript <code>eval()</code> function, which can execute arbitrary script. DO NOT pass an untrusted string into this method.
 * @param jsonString a JSON object to parse
 * @return a JSONValue that has been built by parsing the JSON string
 * @throws NullPointerException if <code>jsonString</code> is<code>null</code>
 * @throws IllegalArgumentException if <code>jsonString</code> is empty
 */
public static JSONValue parse(String jsonString){
  if (jsonString == null) {
    throw new NullPointerException();
  }
  if (jsonString.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return evaluate(jsonString);
  }
 catch (  JavaScriptException ex) {
    throw new JSONException(ex);
  }
}",0.984650369528141
54890,"/** 
 * Ensure a number is displayed with two digits.
 * @return A two-character representation of the number.
 */
@SuppressWarnings(""String_Node_Str"") private static String padTwo(int number){
  if (number < 10) {
    return ""String_Node_Str"" + number;
  }
 else {
    return String.valueOf(number);
  }
}","/** 
 * Ensure a number is displayed with two digits.
 * @return a two-character base 10 representation of the number
 */
protected static String padTwo(int number){
  if (number < 10) {
    return ""String_Node_Str"" + number;
  }
 else {
    return String.valueOf(number);
  }
}",0.8904109589041096
54891,"public float invokeNativeFloat(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Float value=JsValueGlue.get(result,null,Float.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.floatValue();
}","public float invokeNativeFloat(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Float value=JsValueGlue.get(result,null,Float.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.floatValue();
}",0.9269461077844312
54892,"public short invokeNativeShort(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Short value=JsValueGlue.get(result,null,Short.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.shortValue();
}","public short invokeNativeShort(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Short value=JsValueGlue.get(result,null,Short.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.shortValue();
}",0.9269461077844312
54893,"public char invokeNativeChar(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Character value=JsValueGlue.get(result,null,Character.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.charValue();
}","public char invokeNativeChar(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Character value=JsValueGlue.get(result,null,Character.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.charValue();
}",0.927810650887574
54894,"public double invokeNativeDouble(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Double value=JsValueGlue.get(result,null,Double.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.doubleValue();
}","public double invokeNativeDouble(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Double value=JsValueGlue.get(result,null,Double.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.doubleValue();
}",0.927810650887574
54895,"public int invokeNativeInt(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Integer value=JsValueGlue.get(result,null,Integer.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.intValue();
}","public int invokeNativeInt(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Integer value=JsValueGlue.get(result,null,Integer.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.intValue();
}",0.9265944645006016
54896,"public byte invokeNativeByte(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Byte value=JsValueGlue.get(result,null,Byte.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.byteValue();
}","public byte invokeNativeByte(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Byte value=JsValueGlue.get(result,null,Byte.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.byteValue();
}",0.926060606060606
54897,"public Object invokeNativeObject(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  return JsValueGlue.get(result,getIsolatedClassLoader(),Object.class,""String_Node_Str"" + name + ""String_Node_Str"");
}","public Object invokeNativeObject(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  return JsValueGlue.get(result,getIsolatedClassLoader(),Object.class,msgPrefix);
}",0.7913188647746243
54898,"public boolean invokeNativeBoolean(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Boolean value=JsValueGlue.get(result,getIsolatedClassLoader(),boolean.class,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.booleanValue();
}","public boolean invokeNativeBoolean(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Boolean value=JsValueGlue.get(result,getIsolatedClassLoader(),boolean.class,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.booleanValue();
}",0.5217391304347826
54899,"public long invokeNativeLong(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=""String_Node_Str"" + name + ""String_Node_Str"";
  Long value=JsValueGlue.get(result,null,Long.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.longValue();
}","public long invokeNativeLong(String name,Object jthis,Class<?>[] types,Object[] args) throws Throwable {
  JsValue result=invokeNative(name,jthis,types,args);
  String msgPrefix=composeResultErrorMsgPrefix(name,""String_Node_Str"");
  Long value=JsValueGlue.get(result,null,Long.TYPE,msgPrefix);
  if (value == null) {
    throw new HostedModeException(msgPrefix + ""String_Node_Str"");
  }
  return value.longValue();
}",0.926060606060606
54900,"@Override protected void onTypeRef(SourceTypeBinding referencedType,CompilationUnitDeclaration unitOfReferrer){
  String referencedFn=String.valueOf(referencedType.getFileName());
  CompilationUnitDeclaration referencedCud=cudsByFileName.get(referencedFn);
  if (referencedCud == null) {
    String referrerFn=String.valueOf(unitOfReferrer.getFileName());
    if (cudsByFileName.containsKey(referrerFn) && !pendingRemovals.contains(referrerFn)) {
      TreeLogger branch=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + referrerFn + ""String_Node_Str"",null);
      final String badTypeName=CharOperation.toString(referencedType.compoundName);
      branch.branch(TreeLogger.TRACE,""String_Node_Str"" + badTypeName,null);
      pendingRemovals.add(referrerFn);
    }
  }
}","@Override protected void onTypeRef(SourceTypeBinding referencedType,CompilationUnitDeclaration unitOfReferrer){
  String referencedFn=String.valueOf(referencedType.getFileName());
  if (!unchangedCudsByFileName.containsKey(referencedFn) && !changedCudsByFileName.containsKey(referencedFn)) {
    String referrerFn=String.valueOf(unitOfReferrer.getFileName());
    if (changedCudsByFileName.containsKey(referrerFn) && !pendingRemovals.contains(referrerFn)) {
      TreeLogger branch=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + referrerFn + ""String_Node_Str"",null);
      final String badTypeName=CharOperation.toString(referencedType.compoundName);
      branch.branch(TreeLogger.TRACE,""String_Node_Str"" + badTypeName,null);
      pendingRemovals.add(referrerFn);
    }
  }
}",0.7762733720180529
54901,"private static void removeUnitsWithErrors(TreeLogger logger,Map<String,CompilationUnitDeclaration> cudsByFileName){
  boolean anyRemoved=false;
  for (Iterator<CompilationUnitDeclaration> iter=cudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    CompilationResult result=cud.compilationResult;
    IProblem[] errors=result.getErrors();
    if (errors != null && errors.length > 0) {
      anyRemoved=true;
      iter.remove();
      String fileName=CharOperation.charToString(cud.getFileName());
      char[] source=cud.compilationResult.compilationUnit.getContents();
      Util.maybeDumpSource(logger,fileName,source,String.valueOf(cud.getMainTypeName()));
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + fileName + ""String_Node_Str"",null);
    }
  }
  if (anyRemoved) {
    removeInfectedUnits(logger,cudsByFileName);
  }
}","private static void removeUnitsWithErrors(TreeLogger logger,Map<String,CompilationUnitDeclaration> changedCudsByFileName,Map<String,CompilationUnitDeclaration> unchangedCudsByFileName){
  boolean anyRemoved=false;
  for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    CompilationResult result=cud.compilationResult;
    IProblem[] errors=result.getErrors();
    if (errors != null && errors.length > 0) {
      anyRemoved=true;
      iter.remove();
      String fileName=CharOperation.charToString(cud.getFileName());
      char[] source=cud.compilationResult.compilationUnit.getContents();
      Util.maybeDumpSource(logger,fileName,source,String.valueOf(cud.getMainTypeName()));
      logger.log(TreeLogger.TRACE,""String_Node_Str"" + fileName + ""String_Node_Str"",null);
    }
  }
  if (anyRemoved) {
    removeInfectedUnits(logger,changedCudsByFileName,unchangedCudsByFileName);
  }
}",0.8873538788522848
54902,"public TypeOracle build(final TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  Set<CompilationUnitProvider> addedCups=cacheManager.getAddedCups();
  TypeOracle oracle=cacheManager.getTypeOracle();
  for (Iterator<CompilationUnitProvider> iter=addedCups.iterator(); iter.hasNext(); ) {
    CompilationUnitProvider cup=iter.next();
    String location=cup.getLocation();
    if (!((location.indexOf(""String_Node_Str"") != -1) || (location.indexOf(""String_Node_Str"") != -1))) {
      location=Util.findFileName(location);
      if (!(new File(location).exists() || cup.isTransient())) {
        iter.remove();
        logger.log(TreeLogger.TRACE,""String_Node_Str"" + location + ""String_Node_Str"",null);
      }
    }
  }
  CompilationUnitProvider[] cups=Util.toArray(CompilationUnitProvider.class,addedCups);
  Arrays.sort(cups,CompilationUnitProvider.LOCATION_COMPARATOR);
  boolean foundJavaLangPackage=oracle.findPackage(""String_Node_Str"") != null;
  ICompilationUnit[] units=new ICompilationUnit[cups.length];
  for (int i=0; i < cups.length; i++) {
    if (!foundJavaLangPackage && cups[i].getPackageName().equals(""String_Node_Str"")) {
      foundJavaLangPackage=true;
    }
    units[i]=cacheManager.findUnitForCup(cups[i]);
  }
  if (!foundJavaLangPackage) {
    Util.logMissingTypeErrorWithHints(logger,""String_Node_Str"");
    throw new UnableToCompleteException();
  }
  PerfLogger.start(""String_Node_Str"");
  CompilationUnitDeclaration[] cuds=cacheManager.getAstCompiler().getChangedCompilationUnitDeclarations(logger,units);
  PerfLogger.end();
  final Map<String,CompilationUnitDeclaration> cudsByFileName=new TreeMap<String,CompilationUnitDeclaration>();
  for (int i=0; i < cuds.length; i++) {
    CompilationUnitDeclaration cud=cuds[i];
    char[] location=cud.getFileName();
    cudsByFileName.put(String.valueOf(location),cud);
  }
  cacheManager.getCudsByFileName().putAll(cudsByFileName);
  removeUnitsWithErrors(logger,cudsByFileName);
  final CacheManager.Mapper identityMapper=cacheManager.getIdentityMapper();
  for (Iterator<CompilationUnitDeclaration> iter=cudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,true);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,false);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        processType(typeDecl,null,false);
        return true;
      }
    }
,cud.scope);
  }
  for (Iterator<CompilationUnitDeclaration> iter=cudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    String loc=String.valueOf(cud.getFileName());
    String processing=""String_Node_Str"" + loc;
    final TreeLogger cudLogger=logger.branch(TreeLogger.SPAM,processing,null);
    final char[] source=cud.compilationResult.compilationUnit.getContents();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
    }
,cud.scope);
  }
  Util.invokeInaccessableMethod(TypeOracle.class,""String_Node_Str"",new Class[]{TreeLogger.class},oracle,new Object[]{logger});
  PerfLogger.end();
  return oracle;
}","public TypeOracle build(final TreeLogger logger) throws UnableToCompleteException {
  PerfLogger.start(""String_Node_Str"");
  Set<CompilationUnitProvider> addedCups=cacheManager.getAddedCups();
  TypeOracle oracle=cacheManager.getTypeOracle();
  for (Iterator<CompilationUnitProvider> iter=addedCups.iterator(); iter.hasNext(); ) {
    CompilationUnitProvider cup=iter.next();
    String location=cup.getLocation();
    if (!((location.indexOf(""String_Node_Str"") != -1) || (location.indexOf(""String_Node_Str"") != -1))) {
      location=Util.findFileName(location);
      if (!(new File(location).exists() || cup.isTransient())) {
        iter.remove();
        logger.log(TreeLogger.TRACE,""String_Node_Str"" + location + ""String_Node_Str"",null);
      }
    }
  }
  CompilationUnitProvider[] cups=Util.toArray(CompilationUnitProvider.class,addedCups);
  Arrays.sort(cups,CompilationUnitProvider.LOCATION_COMPARATOR);
  boolean foundJavaLangPackage=oracle.findPackage(""String_Node_Str"") != null;
  ICompilationUnit[] units=new ICompilationUnit[cups.length];
  for (int i=0; i < cups.length; i++) {
    if (!foundJavaLangPackage && cups[i].getPackageName().equals(""String_Node_Str"")) {
      foundJavaLangPackage=true;
    }
    units[i]=cacheManager.findUnitForCup(cups[i]);
  }
  if (!foundJavaLangPackage) {
    Util.logMissingTypeErrorWithHints(logger,""String_Node_Str"");
    throw new UnableToCompleteException();
  }
  PerfLogger.start(""String_Node_Str"");
  CompilationUnitDeclaration[] cuds=cacheManager.getAstCompiler().getChangedCompilationUnitDeclarations(logger,units);
  PerfLogger.end();
  final Map<String,CompilationUnitDeclaration> unchangedCudsByFileName=new TreeMap<String,CompilationUnitDeclaration>();
  unchangedCudsByFileName.putAll(cacheManager.getCudsByFileName());
  final Map<String,CompilationUnitDeclaration> changedCudsByFileName=new TreeMap<String,CompilationUnitDeclaration>();
  for (int i=0; i < cuds.length; i++) {
    CompilationUnitDeclaration cud=cuds[i];
    String fileName=String.valueOf(cud.getFileName());
    changedCudsByFileName.put(fileName,cud);
    unchangedCudsByFileName.remove(fileName);
  }
  cacheManager.getCudsByFileName().putAll(changedCudsByFileName);
  removeUnitsWithErrors(logger,changedCudsByFileName,unchangedCudsByFileName);
  final CacheManager.Mapper identityMapper=cacheManager.getIdentityMapper();
  for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,true);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        JClassType enclosingType=identityMapper.get(typeDecl.binding.enclosingType());
        processType(typeDecl,enclosingType,false);
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        processType(typeDecl,null,false);
        return true;
      }
    }
,cud.scope);
  }
  for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
    CompilationUnitDeclaration cud=iter.next();
    String loc=String.valueOf(cud.getFileName());
    String processing=""String_Node_Str"" + loc;
    final TreeLogger cudLogger=logger.branch(TreeLogger.SPAM,processing,null);
    final char[] source=cud.compilationResult.compilationUnit.getContents();
    cud.traverse(new ASTVisitor(){
      @Override public boolean visit(      TypeDeclaration typeDecl,      BlockScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      ClassScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
      @Override public boolean visit(      TypeDeclaration typeDecl,      CompilationUnitScope scope){
        if (!resolveTypeDeclaration(cudLogger,source,typeDecl)) {
          String name=String.valueOf(typeDecl.binding.readableName());
          String msg=""String_Node_Str"" + name;
          logger.log(TreeLogger.WARN,msg,null);
        }
        return true;
      }
    }
,cud.scope);
  }
  Util.invokeInaccessableMethod(TypeOracle.class,""String_Node_Str"",new Class[]{TreeLogger.class},oracle,new Object[]{logger});
  PerfLogger.end();
  return oracle;
}",0.9552423088795144
54903,"private static void removeInfectedUnits(final TreeLogger logger,final Map<String,CompilationUnitDeclaration> cudsByFileName){
  final Set<String> pendingRemovals=new HashSet<String>();
  TypeRefVisitor trv=new TypeRefVisitor(){
    @Override protected void onTypeRef(    SourceTypeBinding referencedType,    CompilationUnitDeclaration unitOfReferrer){
      String referencedFn=String.valueOf(referencedType.getFileName());
      CompilationUnitDeclaration referencedCud=cudsByFileName.get(referencedFn);
      if (referencedCud == null) {
        String referrerFn=String.valueOf(unitOfReferrer.getFileName());
        if (cudsByFileName.containsKey(referrerFn) && !pendingRemovals.contains(referrerFn)) {
          TreeLogger branch=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + referrerFn + ""String_Node_Str"",null);
          final String badTypeName=CharOperation.toString(referencedType.compoundName);
          branch.branch(TreeLogger.TRACE,""String_Node_Str"" + badTypeName,null);
          pendingRemovals.add(referrerFn);
        }
      }
    }
  }
;
  do {
    for (Iterator<String> iter=pendingRemovals.iterator(); iter.hasNext(); ) {
      String fnToRemove=iter.next();
      Object removed=cudsByFileName.remove(fnToRemove);
      assert(removed != null);
    }
    pendingRemovals.clear();
    for (Iterator<CompilationUnitDeclaration> iter=cudsByFileName.values().iterator(); iter.hasNext(); ) {
      CompilationUnitDeclaration cud=iter.next();
      cud.traverse(trv,cud.scope);
    }
  }
 while (!pendingRemovals.isEmpty());
}","private static void removeInfectedUnits(final TreeLogger logger,final Map<String,CompilationUnitDeclaration> changedCudsByFileName,final Map<String,CompilationUnitDeclaration> unchangedCudsByFileName){
  final Set<String> pendingRemovals=new HashSet<String>();
  TypeRefVisitor trv=new TypeRefVisitor(){
    @Override protected void onTypeRef(    SourceTypeBinding referencedType,    CompilationUnitDeclaration unitOfReferrer){
      String referencedFn=String.valueOf(referencedType.getFileName());
      if (!unchangedCudsByFileName.containsKey(referencedFn) && !changedCudsByFileName.containsKey(referencedFn)) {
        String referrerFn=String.valueOf(unitOfReferrer.getFileName());
        if (changedCudsByFileName.containsKey(referrerFn) && !pendingRemovals.contains(referrerFn)) {
          TreeLogger branch=logger.branch(TreeLogger.TRACE,""String_Node_Str"" + referrerFn + ""String_Node_Str"",null);
          final String badTypeName=CharOperation.toString(referencedType.compoundName);
          branch.branch(TreeLogger.TRACE,""String_Node_Str"" + badTypeName,null);
          pendingRemovals.add(referrerFn);
        }
      }
    }
  }
;
  do {
    for (Iterator<String> iter=pendingRemovals.iterator(); iter.hasNext(); ) {
      String fnToRemove=iter.next();
      Object removed=changedCudsByFileName.remove(fnToRemove);
      assert(removed != null);
    }
    pendingRemovals.clear();
    for (Iterator<CompilationUnitDeclaration> iter=changedCudsByFileName.values().iterator(); iter.hasNext(); ) {
      CompilationUnitDeclaration cud=iter.next();
      cud.traverse(trv,cud.scope);
    }
  }
 while (!pendingRemovals.isEmpty());
}",0.8589302471066625
54904,"@Test public void testConstructorFromInjector(){
  provider=new GuiceInstanceProvider(createInjector());
  assertEquals(""String_Node_Str"",provider.getInstance(Service.class,""String_Node_Str"").sayHello());
}","@Test public void testConstructorFromInjector(){
  InstanceProvider provider=new GuiceInstanceProvider(createInjector());
  assertEquals(""String_Node_Str"",provider.getInstance(Service.class,""String_Node_Str"").sayHello());
}",0.9603729603729604
54905,"@Test public void testConstructorFromModule(){
  assertEquals(""String_Node_Str"",provider.getInstance(Service.class,""String_Node_Str"").sayHello());
}","@Test public void testConstructorFromModule(){
  assertEquals(""String_Node_Str"",getProvider().getInstance(Service.class,""String_Node_Str"").sayHello());
}",0.9767441860465116
54906,"@Override @Test public void testGetInstanceWithAnnotation(){
  Service3 service=provider.getInstance(Service3.class,MyBindingAnnotation.class);
  assertNotNull(service);
}","@Override @Test public void testGetInstanceWithAnnotation(){
  Service3 service=getProvider().getInstance(Service3.class,MyBindingAnnotation.class);
  assertNotNull(service);
}",0.9798270893371758
54907,"private ConfigurationFileImpl(final File file){
  if (file == null) {
    throw new ConfigurationException(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
  if (!file.exists()) {
    throw new ConfigurationException(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
  if (!file.canRead()) {
    throw new ConfigurationException(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
  load();
}","private ConfigurationFileImpl(final File file){
  if (file == null) {
    throw new ConfigurationException(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
  if (!file.exists()) {
    throw new ConfigurationException(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
  if (!file.canRead()) {
    throw new ConfigurationException(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
  this.file=file;
  load();
}",0.9653579676674364
54908,"@Override public void load(){
  hTable=new Hashtable<String,String>();
  Properties props=new Properties();
  InputStream in=null;
  try {
    in=new FileInputStream(file);
    props.load(in);
    hTable=pfu.rectifyProperties(props);
    LOGGER.debug(""String_Node_Str"",file.getAbsolutePath(),new Date());
  }
 catch (  IOException e) {
    throw new ConfigurationException(""String_Node_Str"" + file,e);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        throw new ConfigurationException(""String_Node_Str"",e);
      }
    }
  }
}","@Override public void load(){
  hTable=new Hashtable<String,String>();
  Properties props=new Properties();
  InputStream in=null;
  try {
    System.out.println(file.getName());
    in=new FileInputStream(file);
    props.load(in);
    hTable=pfu.rectifyProperties(props);
    LOGGER.debug(""String_Node_Str"",file.getAbsolutePath(),new Date());
  }
 catch (  IOException e) {
    throw new ConfigurationException(""String_Node_Str"" + file,e);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        throw new ConfigurationException(""String_Node_Str"",e);
      }
    }
  }
}",0.9673202614379084
54909,"@Test public void testFromFileSystemFile(){
  String pathname=getClass().getResource(""String_Node_Str"").getFile();
  File file=new File(pathname);
  assertTrue(instance.fromFileSystem(file) instanceof ConfigurationFileImpl);
}","@Test public void testFromFileSystemFile(){
  String pathname=getClass().getResource(""String_Node_Str"").getFile();
  File file=new File(pathname);
  assertTrue(file.canRead());
  assertTrue(instance.fromFileSystem(file) instanceof ConfigurationFileImpl);
}",0.9377593360995852
54910,"@Test public void testConstructorFromModule(){
  Service service=provider.getInstance(Service.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",service.sayHello());
}","@Test public void testConstructorFromModule(){
  Service service=getProvider().getInstance(Service.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",service.sayHello());
}",0.9802816901408452
54911,"@Test public void testGetInstanceByFactoryBean(){
  Service service=provider.getInstance(MyService1.class);
  assertEquals(""String_Node_Str"",service.sayHello());
}","@Test public void testGetInstanceByFactoryBean(){
  Service service=getProvider().getInstance(MyService1.class);
  assertEquals(""String_Node_Str"",service.sayHello());
}",0.9788519637462236
54912,"@Test public void testGetInstanceByFactoryBean(){
  Service service=provider.getInstance(MyService1.class);
  assertEquals(""String_Node_Str"",service.sayHello());
}","@Test public void testGetInstanceByFactoryBean(){
  Service service=getProvider().getInstance(MyService1.class);
  assertEquals(""String_Node_Str"",service.sayHello());
}",0.9788519637462236
54913,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryRolesForAssign(String page,String pagesize,Long userId,String userAccount,String roleNameForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  int start=Integer.parseInt(page);
  int limit=Integer.parseInt(pagesize);
  QueryConditionVO search=new QueryConditionVO();
  initSearchCondition(search,roleNameForSearch);
  Page<RoleVO> all=roleApplication.pageQueryByRoleCustom(start,limit,search);
  if (userId != null) {
    List<RoleVO> roles=all.getResult();
    for (    RoleVO role : roleApplication.findRoleByUserAccount(userAccount)) {
      roles.remove(role);
    }
  }
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",start * limit - limit);
  dataMap.put(""String_Node_Str"",limit);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryRolesForAssign(int page,int pagesize,String userAccount,String roleNameForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVO=new RoleVO();
  roleVO.setName(roleNameForSearch);
  Page<RoleVO> all=roleApplication.pageQueryNotAssignRoleByUseraccount(page,pagesize,userAccount,roleVO);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.3155115511551155
54914,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryUsersForAssign(int page,int pagesize,Long roleId,String userNameForSearch,String userAccountForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  QueryConditionVO search=new QueryConditionVO();
  initSearchCondition(search,userNameForSearch,userAccountForSearch);
  Page<UserVO> all=userApplication.pageQueryUserCustom(page,pagesize,search);
  if (roleId != null) {
    RoleVO role=new RoleVO();
    role.setId(roleId);
    List<UserVO> users=all.getResult();
    try {
      for (      UserVO user : roleApplication.findUserByRole(role)) {
        users.remove(user);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryUsersForAssign(int page,int pagesize,Long roleId,String userNameForSearch,String userAccountForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVO=new RoleVO();
  roleVO.setId(roleId);
  UserVO userVO=new UserVO();
  userVO.setName(userNameForSearch);
  userVO.setUserAccount(userAccountForSearch);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(page,pagesize,userVO,roleVO);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.3824046920821114
54915,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryNotAssignUserByRole(String page,String pagesize,Long roleId){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  int start=Integer.parseInt(page);
  int limit=Integer.parseInt(pagesize);
  RoleVO roleVoForFind=new RoleVO();
  roleVoForFind.setId(roleId);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(start,limit,roleVoForFind);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",start * limit - limit);
  dataMap.put(""String_Node_Str"",limit);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryNotAssignUserByRole(int page,int pagesize,Long roleId){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVoForFind=new RoleVO();
  roleVoForFind.setId(roleId);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(page,pagesize,null,roleVoForFind);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.7967871485943775
54916,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryRolesForAssign(String page,String pagesize,Long userId,String userAccount,String roleNameForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  int start=Integer.parseInt(page);
  int limit=Integer.parseInt(pagesize);
  QueryConditionVO search=new QueryConditionVO();
  initSearchCondition(search,roleNameForSearch);
  Page<RoleVO> all=roleApplication.pageQueryByRoleCustom(start,limit,search);
  if (userId != null) {
    List<RoleVO> roles=all.getResult();
    for (    RoleVO role : roleApplication.findRoleByUserAccount(userAccount)) {
      roles.remove(role);
    }
  }
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",start * limit - limit);
  dataMap.put(""String_Node_Str"",limit);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryRolesForAssign(int page,int pagesize,String userAccount,String roleNameForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVO=new RoleVO();
  roleVO.setName(roleNameForSearch);
  Page<RoleVO> all=roleApplication.pageQueryNotAssignRoleByUseraccount(page,pagesize,userAccount,roleVO);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.3155115511551155
54917,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryUsersForAssign(int page,int pagesize,Long roleId,String userNameForSearch,String userAccountForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  QueryConditionVO search=new QueryConditionVO();
  initSearchCondition(search,userNameForSearch,userAccountForSearch);
  Page<UserVO> all=userApplication.pageQueryUserCustom(page,pagesize,search);
  if (roleId != null) {
    RoleVO role=new RoleVO();
    role.setId(roleId);
    List<UserVO> users=all.getResult();
    try {
      for (      UserVO user : roleApplication.findUserByRole(role)) {
        users.remove(user);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryUsersForAssign(int page,int pagesize,Long roleId,String userNameForSearch,String userAccountForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVO=new RoleVO();
  roleVO.setId(roleId);
  UserVO userVO=new UserVO();
  userVO.setName(userNameForSearch);
  userVO.setUserAccount(userAccountForSearch);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(page,pagesize,userVO,roleVO);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.3824046920821114
54918,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryNotAssignUserByRole(String page,String pagesize,Long roleId){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  int start=Integer.parseInt(page);
  int limit=Integer.parseInt(pagesize);
  RoleVO roleVoForFind=new RoleVO();
  roleVoForFind.setId(roleId);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(start,limit,roleVoForFind);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",start * limit - limit);
  dataMap.put(""String_Node_Str"",limit);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryNotAssignUserByRole(int page,int pagesize,Long roleId){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVoForFind=new RoleVO();
  roleVoForFind.setId(roleId);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(page,pagesize,null,roleVoForFind);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.7967871485943775
54919,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryRolesForAssign(String page,String pagesize,Long userId,String userAccount,String roleNameForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  int start=Integer.parseInt(page);
  int limit=Integer.parseInt(pagesize);
  QueryConditionVO search=new QueryConditionVO();
  initSearchCondition(search,roleNameForSearch);
  Page<RoleVO> all=roleApplication.pageQueryByRoleCustom(start,limit,search);
  if (userId != null) {
    List<RoleVO> roles=all.getResult();
    for (    RoleVO role : roleApplication.findRoleByUserAccount(userAccount)) {
      roles.remove(role);
    }
  }
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",start * limit - limit);
  dataMap.put(""String_Node_Str"",limit);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryRolesForAssign(int page,int pagesize,String userAccount,String roleNameForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVO=new RoleVO();
  roleVO.setName(roleNameForSearch);
  Page<RoleVO> all=roleApplication.pageQueryNotAssignRoleByUseraccount(page,pagesize,userAccount,roleVO);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.3155115511551155
54920,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryUsersForAssign(int page,int pagesize,Long roleId,String userNameForSearch,String userAccountForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  QueryConditionVO search=new QueryConditionVO();
  initSearchCondition(search,userNameForSearch,userAccountForSearch);
  Page<UserVO> all=userApplication.pageQueryUserCustom(page,pagesize,search);
  if (roleId != null) {
    RoleVO role=new RoleVO();
    role.setId(roleId);
    List<UserVO> users=all.getResult();
    try {
      for (      UserVO user : roleApplication.findUserByRole(role)) {
        users.remove(user);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryUsersForAssign(int page,int pagesize,Long roleId,String userNameForSearch,String userAccountForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVO=new RoleVO();
  roleVO.setId(roleId);
  UserVO userVO=new UserVO();
  userVO.setName(userNameForSearch);
  userVO.setUserAccount(userAccountForSearch);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(page,pagesize,userVO,roleVO);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.3824046920821114
54921,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryNotAssignUserByRole(String page,String pagesize,Long roleId){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  int start=Integer.parseInt(page);
  int limit=Integer.parseInt(pagesize);
  RoleVO roleVoForFind=new RoleVO();
  roleVoForFind.setId(roleId);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(start,limit,roleVoForFind);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",start * limit - limit);
  dataMap.put(""String_Node_Str"",limit);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryNotAssignUserByRole(int page,int pagesize,Long roleId){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVoForFind=new RoleVO();
  roleVoForFind.setId(roleId);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(page,pagesize,null,roleVoForFind);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.7967871485943775
54922,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryRolesForAssign(String page,String pagesize,Long userId,String userAccount,String roleNameForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  int start=Integer.parseInt(page);
  int limit=Integer.parseInt(pagesize);
  QueryConditionVO search=new QueryConditionVO();
  initSearchCondition(search,roleNameForSearch);
  Page<RoleVO> all=roleApplication.pageQueryByRoleCustom(start,limit,search);
  if (userId != null) {
    List<RoleVO> roles=all.getResult();
    for (    RoleVO role : roleApplication.findRoleByUserAccount(userAccount)) {
      roles.remove(role);
    }
  }
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",start * limit - limit);
  dataMap.put(""String_Node_Str"",limit);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryRolesForAssign(int page,int pagesize,String userAccount,String roleNameForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVO=new RoleVO();
  roleVO.setName(roleNameForSearch);
  Page<RoleVO> all=roleApplication.pageQueryNotAssignRoleByUseraccount(page,pagesize,userAccount,roleVO);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.3155115511551155
54923,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryUsersForAssign(int page,int pagesize,Long roleId,String userNameForSearch,String userAccountForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  QueryConditionVO search=new QueryConditionVO();
  initSearchCondition(search,userNameForSearch,userAccountForSearch);
  Page<UserVO> all=userApplication.pageQueryUserCustom(page,pagesize,search);
  if (roleId != null) {
    RoleVO role=new RoleVO();
    role.setId(roleId);
    List<UserVO> users=all.getResult();
    try {
      for (      UserVO user : roleApplication.findUserByRole(role)) {
        users.remove(user);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryUsersForAssign(int page,int pagesize,Long roleId,String userNameForSearch,String userAccountForSearch){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVO=new RoleVO();
  roleVO.setId(roleId);
  UserVO userVO=new UserVO();
  userVO.setName(userNameForSearch);
  userVO.setUserAccount(userAccountForSearch);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(page,pagesize,userVO,roleVO);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.3824046920821114
54924,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryNotAssignUserByRole(String page,String pagesize,Long roleId){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  int start=Integer.parseInt(page);
  int limit=Integer.parseInt(pagesize);
  RoleVO roleVoForFind=new RoleVO();
  roleVoForFind.setId(roleId);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(start,limit,roleVoForFind);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",start * limit - limit);
  dataMap.put(""String_Node_Str"",limit);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> queryNotAssignUserByRole(int page,int pagesize,Long roleId){
  Map<String,Object> dataMap=new HashMap<String,Object>();
  RoleVO roleVoForFind=new RoleVO();
  roleVoForFind.setId(roleId);
  Page<UserVO> all=roleApplication.pageQueryNotAssignUserByRole(page,pagesize,null,roleVoForFind);
  dataMap.put(""String_Node_Str"",all.getResult());
  dataMap.put(""String_Node_Str"",page * pagesize - pagesize);
  dataMap.put(""String_Node_Str"",pagesize);
  dataMap.put(""String_Node_Str"",all.getTotalCount());
  return dataMap;
}",0.7967871485943775
54925,"@Override public void createUserIfNecessary(Project project,Developer developer){
  new ProjectAuthorization().authorize(jenkinsUrl,project,driver,developer);
}","@Override public void createUserIfNecessary(Project project,Developer developer){
  new UserCreator().createUser(jenkinsUrl,developer,driver);
}",0.8157894736842105
54926,"public void assignUsersToRole(Project project,String role,Developer... developers){
  new GlobalProjectAuthorization().authorize(jenkinsUrl,driver,developers);
}","public void assignUsersToRole(Project project,String role,Developer... developers){
  new ProjectAuthorization().authorize(jenkinsUrl,project,driver,developers);
  new GlobalProjectAuthorization().authorize(jenkinsUrl,driver,developers);
}",0.805
54927,"public void authorize(String jenkinsBaseUrl,Project project,WebDriver driver,Developer... developers){
  String jobConfigureUrl=UrlUtil.removeEndIfExists(jenkinsBaseUrl,""String_Node_Str"") + ""String_Node_Str"" + project.getArtifactId()+ ""String_Node_Str"";
  ProjectConfigUtil.openJobConfigurePage(driver,jobConfigureUrl);
  if (!SeleniumUtil.elementExist(driver,By.cssSelector(""String_Node_Str""))) {
    throw new CISClientBaseRuntimeException(""String_Node_Str"");
  }
  WebElement userProjectSecurityCheckbox=driver.findElement(By.cssSelector(""String_Node_Str""));
  if (!""String_Node_Str"".equals(userProjectSecurityCheckbox.getAttribute(""String_Node_Str""))) {
    userProjectSecurityCheckbox.click();
  }
  WebElement userProjectSecurityMartix=driver.findElement(By.xpath(""String_Node_Str""));
  List<Developer> notExistUsers=new ArrayList<Developer>();
  for (  Developer developer : developers) {
    if (SeleniumUtil.elementExist(driver,By.cssSelector(""String_Node_Str"" + developer.getName() + ""String_Node_Str""))) {
      continue;
    }
    WebElement userInput=userProjectSecurityMartix.findElement(By.cssSelector(""String_Node_Str""));
    userInput.sendKeys(developer.getName());
    WebElement addUserSubmitButton=userProjectSecurityMartix.findElement(By.cssSelector(""String_Node_Str""));
    addUserSubmitButton.click();
    WebElement readPermissionCheckbox=driver.findElement(By.cssSelector(""String_Node_Str"" + developer.getName() + ""String_Node_Str""));
    readPermissionCheckbox.click();
    if (SeleniumUtil.elementExist(driver,By.cssSelector(""String_Node_Str"" + developer.getName() + ""String_Node_Str""))) {
      notExistUsers.add(developer);
    }
  }
  ProjectConfigUtil.submitForm(driver,project.getArtifactId());
  for (  Developer developer : notExistUsers) {
    UserCreator userCreator=new UserCreator();
    userCreator.createUser(jenkinsBaseUrl,developer,driver);
  }
}","public void authorize(String jenkinsBaseUrl,Project project,WebDriver driver,Developer... developers){
  String jobConfigureUrl=UrlUtil.removeEndIfExists(jenkinsBaseUrl,""String_Node_Str"") + ""String_Node_Str"" + project.getArtifactId()+ ""String_Node_Str"";
  ProjectConfigUtil.openJobConfigurePage(driver,jobConfigureUrl);
  if (!SeleniumUtil.elementExist(driver,By.cssSelector(""String_Node_Str""))) {
    throw new CISClientBaseRuntimeException(""String_Node_Str"");
  }
  WebElement userProjectSecurityCheckbox=driver.findElement(By.cssSelector(""String_Node_Str""));
  if (!""String_Node_Str"".equals(userProjectSecurityCheckbox.getAttribute(""String_Node_Str""))) {
    userProjectSecurityCheckbox.click();
  }
  WebElement userProjectSecurityMartix=driver.findElement(By.xpath(""String_Node_Str""));
  List<Developer> notExistUsers=new ArrayList<Developer>();
  for (  Developer developer : developers) {
    if (SeleniumUtil.elementExist(driver,By.cssSelector(""String_Node_Str"" + developer.getName() + ""String_Node_Str""))) {
      continue;
    }
    WebElement userInput=userProjectSecurityMartix.findElement(By.cssSelector(""String_Node_Str""));
    userInput.sendKeys(developer.getName());
    WebElement addUserSubmitButton=userProjectSecurityMartix.findElement(By.cssSelector(""String_Node_Str""));
    addUserSubmitButton.click();
    WebElement readPermissionCheckbox=driver.findElement(By.cssSelector(""String_Node_Str"" + developer.getName() + ""String_Node_Str""));
    readPermissionCheckbox.click();
  }
  ProjectConfigUtil.submitForm(driver,project.getArtifactId());
}",0.8774978279756733
54928,"public boolean createUser(String jenkinsUrl,Developer developer,WebDriver driver){
  jenkinsUrl=UrlUtil.removeEndIfExists(jenkinsUrl,""String_Node_Str"");
  if (!(jenkinsUrl + ""String_Node_Str"").equals(driver.getCurrentUrl())) {
    driver.get(jenkinsUrl + ""String_Node_Str"");
  }
  WebElement usernameInput=driver.findElement(By.name(""String_Node_Str""));
  usernameInput.sendKeys(developer.getName());
  WebElement passwordInput1=driver.findElement(By.name(""String_Node_Str""));
  passwordInput1.sendKeys(developer.getPassword());
  WebElement passwordInput2=driver.findElement(By.name(""String_Node_Str""));
  passwordInput2.sendKeys(developer.getPassword());
  WebElement fullnameInput=driver.findElement(By.name(""String_Node_Str""));
  fullnameInput.sendKeys(developer.getFullName());
  WebElement emailInput=driver.findElement(By.name(""String_Node_Str""));
  emailInput.sendKeys(developer.getEmail());
  emailInput.submit();
  if (!driver.getCurrentUrl().endsWith(""String_Node_Str"")) {
    error=driver.findElement(By.cssSelector(""String_Node_Str"")).getText();
    return false;
  }
  return true;
}","public boolean createUser(String jenkinsUrl,Developer developer,WebDriver driver){
  jenkinsUrl=UrlUtil.removeEndIfExists(jenkinsUrl,""String_Node_Str"");
  if (!(jenkinsUrl + ""String_Node_Str"").equals(driver.getCurrentUrl())) {
    driver.get(jenkinsUrl + ""String_Node_Str"");
  }
  WebElement usernameInput=driver.findElement(By.name(""String_Node_Str""));
  usernameInput.sendKeys(developer.getName());
  WebElement passwordInput1=driver.findElement(By.name(""String_Node_Str""));
  passwordInput1.sendKeys(developer.getPassword());
  WebElement passwordInput2=driver.findElement(By.name(""String_Node_Str""));
  passwordInput2.sendKeys(developer.getPassword());
  WebElement fullnameInput=driver.findElement(By.name(""String_Node_Str""));
  fullnameInput.sendKeys(developer.getFullName());
  WebElement emailInput=driver.findElement(By.name(""String_Node_Str""));
  emailInput.sendKeys(developer.getEmail());
  emailInput.submit();
  if (!driver.getCurrentUrl().endsWith(""String_Node_Str"")) {
    throw new CISClientBaseRuntimeException(driver.findElement(By.cssSelector(""String_Node_Str"")).getText());
  }
  return true;
}",0.9706015377657168
54929,"@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> update(ParamsPojo params){
  ResourceTypeVO resourceTypeVO=params.getResourceTypeVO();
  Map<String,Object> dataMap=new HashMap<String,Object>();
  dataMap.put(""String_Node_Str"",""String_Node_Str"");
  try {
    resourceTypeApplication.update(resourceTypeVO);
  }
 catch (  ApplicationException e) {
    dataMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  return dataMap;
}","@ResponseBody @RequestMapping(""String_Node_Str"") public Map<String,Object> update(ParamsPojo params){
  ResourceTypeVO resourceTypeVO=params.getResourceTypeVO();
  Map<String,Object> dataMap=new HashMap<String,Object>();
  resourceTypeApplication.update(resourceTypeVO);
  dataMap.put(""String_Node_Str"",""String_Node_Str"");
  return dataMap;
}",0.6792929292929293
54930,"/** 
 * Common method as single entry point responsible fo request execution
 * @param context clientContext to be used when executing request
 * @param request Request to execute
 * @param responseHandler can be null if you need raw HttpResponse or not null response handler for result handling.
 * @param < T > will return raw HttpResponse when responseHandler is null or value reslved using provided ResponseHandler instance
 * @return value resolved using response handler or raw HttpResponse when responseHandler is null
 */
protected <T>T execute(HttpClientContext context,HttpRequestBase request,ResponseHandler<T> responseHandler) throws IOException {
  try {
    HttpContext requestLocalContext=new BasicHttpContext(context);
    if (responseHandler != null) {
      return this.client.execute(request,responseHandler,requestLocalContext);
    }
 else {
      return (T)this.client.execute(request,requestLocalContext);
    }
  }
 catch (  HttpResponseException e) {
    throw e;
  }
catch (  IOException e) {
    request.abort();
    throw e;
  }
}","/** 
 * Common method as single entry point responsible fo request execution
 * @param context clientContext to be used when executing request
 * @param request Request to execute
 * @param responseHandler can be null if you need raw HttpResponse or not null response handler for result handling.
 * @param < T > will return raw HttpResponse when responseHandler is null or value reslved using provided ResponseHandler instance
 * @return value resolved using response handler or raw HttpResponse when responseHandler is null
 */
protected <T>T execute(HttpClientContext context,HttpRequestBase request,ResponseHandler<T> responseHandler) throws IOException {
  HttpContext requestLocalContext=new BasicHttpContext(context);
  try {
    if (responseHandler != null) {
      return this.client.execute(request,responseHandler,requestLocalContext);
    }
 else {
      return (T)this.client.execute(request,requestLocalContext);
    }
  }
 catch (  HttpResponseException e) {
    throw e;
  }
catch (  IOException e) {
    request.abort();
    throw e;
  }
 finally {
    context.setAttribute(HttpClientContext.USER_TOKEN,requestLocalContext.getAttribute(HttpClientContext.USER_TOKEN));
  }
}",0.9323843416370108
54931,"public DavQuota(Response response){
  Prop prop=response.getPropstat().get(0).getProp();
  this.quotaAvailableBytes=Long.valueOf(prop.getQuotaAvailableBytes().getContent().get(0));
  this.quotaUsedBytes=Long.valueOf(prop.getQuotaUsedBytes().getContent().get(0));
}","public DavQuota(Response response){
  this.quotaAvailableBytes=this.getAvailable(response);
  this.quotaUsedBytes=this.getUsed(response);
}",0.6104218362282878
54932,"public String toXml(){
  return SardineUtil.toXml(toJaxb());
}","public String toXml() throws IOException {
  return SardineUtil.toXml(toJaxb());
}",0.8611111111111112
54933,"/** 
 * @return A new marshaller
 * @throws IOException When there is a JAXB error
 */
private static Marshaller createMarshaller(){
  try {
    return JAXB_CONTEXT.createMarshaller();
  }
 catch (  JAXBException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
}","/** 
 * @return A new marshaller
 * @throws IOException When there is a JAXB error
 */
private static Marshaller createMarshaller() throws IOException {
  try {
    return JAXB_CONTEXT.createMarshaller();
  }
 catch (  JAXBException e) {
    throw new IOException(e.getMessage(),e);
  }
}",0.948306595365419
54934,"/** 
 * Creates an   {@link Unmarshaller} from the {@link SardineUtil#JAXB_CONTEXT}. Note: the unmarshaller is not thread safe, so it must be created for every request.
 * @return A new unmarshaller
 * @throws IOException When there is a JAXB error
 */
private static Unmarshaller createUnmarshaller(){
  try {
    return JAXB_CONTEXT.createUnmarshaller();
  }
 catch (  JAXBException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
}","/** 
 * Creates an   {@link Unmarshaller} from the {@link SardineUtil#JAXB_CONTEXT}. Note: the unmarshaller is not thread safe, so it must be created for every request.
 * @return A new unmarshaller
 * @throws IOException When there is a JAXB error
 */
private static Unmarshaller createUnmarshaller() throws IOException {
  try {
    return JAXB_CONTEXT.createUnmarshaller();
  }
 catch (  JAXBException e) {
    throw new IOException(e.getMessage(),e);
  }
}",0.9679558011049724
54935,"/** 
 * @param jaxbElement An object from the model
 * @return The XML string for the WebDAV request
 * @throws RuntimeException When there is a JAXB error
 */
public static String toXml(Object jaxbElement){
  StringWriter writer=new StringWriter();
  try {
    Marshaller marshaller=createMarshaller();
    marshaller.marshal(jaxbElement,writer);
  }
 catch (  JAXBException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  return writer.toString();
}","/** 
 * @param jaxbElement An object from the model
 * @return The XML string for the WebDAV request
 * @throws RuntimeException When there is a JAXB error
 */
public static String toXml(Object jaxbElement) throws IOException {
  StringWriter writer=new StringWriter();
  try {
    Marshaller marshaller=createMarshaller();
    marshaller.marshal(jaxbElement,writer);
  }
 catch (  JAXBException e) {
    throw new RuntimeException(e.getMessage(),e);
  }
  return writer.toString();
}",0.978902953586498
54936,"/** 
 * @param msg			Custom description of failure
 * @param statusCode	 Error code returned by server
 * @param responsePhrase Response phrase following the error code
 */
public SardineException(String msg,int statusCode,String responsePhrase){
  super(statusCode,msg);
  this.responsePhrase=responsePhrase;
}","/** 
 * @param msg            Custom description of failure
 * @param statusCode     Error code returned by server
 * @param responsePhrase Response phrase following the error code
 */
public SardineException(String msg,int statusCode,String responsePhrase){
  super(statusCode,msg);
  this.responsePhrase=responsePhrase;
}",0.9684542586750788
54937,"@Test public void testLockUnlock() throws Exception {
  Sardine sardine=SardineFactory.begin();
  String url=""String_Node_Str"" + UUID.randomUUID().toString();
  sardine.put(url,new byte[]{});
  try {
    String token=sardine.lock(url);
    try {
      sardine.delete(url);
      fail(""String_Node_Str"");
    }
 catch (    SardineException e) {
      assertEquals(423,e.getStatusCode());
    }
    sardine.unlock(url,token);
  }
  finally {
    sardine.delete(url);
  }
}","@Test public void testLockUnlock() throws Exception {
  Sardine sardine=SardineFactory.begin();
  String url=String.format(""String_Node_Str"",UUID.randomUUID().toString());
  sardine.put(url,new byte[0]);
  try {
    String token=sardine.lock(url);
    try {
      sardine.delete(url);
      fail(""String_Node_Str"");
    }
 catch (    SardineException e) {
      assertEquals(423,e.getStatusCode());
    }
    sardine.unlock(url,token);
  }
  finally {
    sardine.delete(url);
  }
}",0.976890756302521
54938,"@Test public void lockRefreshUnlock() throws Exception {
  Sardine sardine=SardineFactory.begin();
  final UUID file=UUID.randomUUID();
  final String url=String.format(""String_Node_Str"",file);
  sardine.put(url,new ByteArrayInputStream(new byte[0]));
  String lockToken=sardine.lock(url);
  String result=sardine.refreshLock(url,lockToken,url);
  assertTrue(lockToken.startsWith(""String_Node_Str""));
  assertTrue(lockToken.equals(result));
  sardine.unlock(url,lockToken);
}","@Test public void lockRefreshUnlock() throws Exception {
  Sardine sardine=SardineFactory.begin();
  final UUID file=UUID.randomUUID();
  final String url=String.format(""String_Node_Str"",file);
  sardine.put(url,new ByteArrayInputStream(new byte[0]));
  try {
    String lockToken=sardine.lock(url);
    String result=sardine.refreshLock(url,lockToken,url);
    assertTrue(lockToken.startsWith(""String_Node_Str""));
    assertTrue(lockToken.equals(result));
    sardine.unlock(url,lockToken);
  }
  finally {
    sardine.delete(url);
  }
}",0.9378084896347484
54939,"/** 
 * Put an exclusive write lock on this resource. A write lock must prevent a principal without the lock from successfully executing a PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE, DELETE, or MKCOL on the locked resource. All other current methods, GET in particular, function independently of the lock. <p/> A WebDAV compliant server is not required to support locking in any form. If the server does support locking it may choose to support any combination of exclusive and shared locks for any access types.
 * @param url Path to the resource including protocol and hostname
 * @return The lock token to unlock this resource. A lock token is a type of state token, representedas a URI, which identifies a particular lock. A lock token is returned by every successful <code>LOCK</code> operation in the lockdiscovery property in the response body, and can also be found through lock discovery on a resource.
 * @throws IOException I/O error or HTTP response validation failure
 */
String lock(String url) throws IOException ;","/** 
 * <p> Put an exclusive write lock on this resource. A write lock must prevent a principal without the lock from successfully executing a PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE, DELETE, or MKCOL on the locked resource. All other current methods, GET in particular, function independently of the lock. </p> A WebDAV compliant server is not required to support locking in any form. If the server does support locking it may choose to support any combination of exclusive and shared locks for any access types.
 * @param url Path to the resource including protocol and hostname
 * @return The lock token to unlock this resource. A lock token is a type of state token, representedas a URI, which identifies a particular lock. A lock token is returned by every successful <code>LOCK</code> operation in the lockdiscovery property in the response body, and can also be found through lock discovery on a resource.
 * @throws IOException I/O error or HTTP response validation failure
 */
String lock(String url) throws IOException ;",0.9970845481049564
54940,"/** 
 * Unlock the resource. <p/> A WebDAV compliant server is not required to support locking in any form. If the server does support locking it may choose to support any combination of exclusive and shared locks for any access types.
 * @param url   Path to the resource including protocol and hostname
 * @param token The lock token to unlock this resource.
 * @throws IOException I/O error or HTTP response validation failure
 * @see #lock(String)
 */
void unlock(String url,String token) throws IOException ;","/** 
 * <p> Unlock the resource. </p> A WebDAV compliant server is not required to support locking in any form. If the server does support locking it may choose to support any combination of exclusive and shared locks for any access types.
 * @param url   Path to the resource including protocol and hostname
 * @param token The lock token to unlock this resource.
 * @throws IOException I/O error or HTTP response validation failure
 * @see #lock(String)
 */
void unlock(String url,String token) throws IOException ;",0.9941747572815534
54941,"/** 
 * Enables HTTP GZIP compression. If enabled, requests originating from Sardine will include ""gzip"" as an ""Accept-Encoding"" header. <p/> If the server also supports gzip compression, it should serve the contents in compressed gzip format and include ""gzip"" as the Content-Encoding. If the content encoding is present, Sardine will automatically decompress the files upon reception.
 */
void enableCompression();","/** 
 * <p> Enables HTTP GZIP compression. If enabled, requests originating from Sardine will include ""gzip"" as an ""Accept-Encoding"" header. </p> If the server also supports gzip compression, it should serve the contents in compressed gzip format and include ""gzip"" as the Content-Encoding. If the content encoding is present, Sardine will automatically decompress the files upon reception.
 */
void enableCompression();",0.992822966507177
54942,"/** 
 * Setter for attribute ignoreCookies.
 * @param Whether to ignore cookies.
 */
public void setIgnoreCookies(boolean ignoreCookies){
  this.ignoreCookies=ignoreCookies;
}","/** 
 * Setter for attribute ignoreCookies.
 * @param ignoreCookies to ignore cookies.
 */
public void setIgnoreCookies(boolean ignoreCookies){
  this.ignoreCookies=ignoreCookies;
}",0.9550561797752808
54943,"/** 
 * The Depth header may be used with the <code>LOCK</code> method. Values other than <code>0</code> or <code>infinity</code> must not be used with the Depth header on a <code>LOCK</code> method. All resources that support the <code>LOCK</code> method must support the Depth header. <p/> If no Depth header is submitted on a <code>LOCK</code> request then the request must act as if a <code>Depth:infinity</code> had been submitted.
 * @param depth <code>""0""</code> or <code>""infinity""</code>.
 */
public void setDepth(String depth){
  this.setHeader(HttpHeaders.DEPTH,depth);
}","/** 
 * <p> The Depth header may be used with the <code>LOCK</code> method. Values other than <code>0</code> or <code>infinity</code> must not be used with the Depth header on a <code>LOCK</code> method. All resources that support the <code>LOCK</code> method must support the Depth header. </p> <p> If no Depth header is submitted on a <code>LOCK</code> request then the request must act as if a <code>Depth:infinity</code> had been submitted. </p>
 * @param depth <code>""0""</code> or <code>""infinity""</code>.
 */
public void setDepth(String depth){
  this.setHeader(HttpHeaders.DEPTH,depth);
}",0.9855564995751912
54944,"/** 
 * Loops over all the possible date formats and tries to find the right one.
 * @param value ISO date string
 * @return Null if there is a parsing failure
 */
public static Date parseDate(String value){
  if (value == null) {
    return null;
  }
  Date date=null;
  for (  SimpleDateFormat format : DATETIME_FORMATS) {
    try {
      date=format.parse(value);
      break;
    }
 catch (    ParseException e) {
    }
  }
  return date;
}","/** 
 * Loops over all the possible date formats and tries to find the right one.
 * @param value ISO date string
 * @return Null if there is a parsing failure
 */
public static Date parseDate(String value){
  if (value == null) {
    return null;
  }
  Date date=null;
  for (  ThreadLocal<SimpleDateFormat> format : DATETIME_FORMATS) {
    try {
      date=format.get().parse(value);
      break;
    }
 catch (    ParseException e) {
    }
  }
  return date;
}",0.9790518191841234
54945,"@Override public HttpUriRequest getRedirect(HttpRequest request,HttpResponse response,HttpContext context) throws ProtocolException {
  URI uri=this.getLocationURI(request,response,context);
  String method=request.getRequestLine().getMethod();
  if (method.equalsIgnoreCase(HttpHead.METHOD_NAME)) {
    return new HttpHead(uri);
  }
  if (method.equalsIgnoreCase(HttpPropFind.METHOD_NAME)) {
    return new HttpPropFind(uri);
  }
  if (method.equalsIgnoreCase(HttpLock.METHOD_NAME)) {
    return new HttpLock(uri);
  }
  return new HttpGet(uri);
}","@Override public HttpUriRequest getRedirect(HttpRequest request,HttpResponse response,HttpContext context) throws ProtocolException {
  String method=request.getRequestLine().getMethod();
  if (method.equalsIgnoreCase(HttpPropFind.METHOD_NAME)) {
    return new HttpPropFind(this.getLocationURI(request,response,context));
  }
  if (method.equalsIgnoreCase(HttpLock.METHOD_NAME)) {
    return new HttpLock(this.getLocationURI(request,response,context));
  }
  return super.getRedirect(request,response,context);
}",0.6597549481621112
54946,"@Override public boolean isRedirected(HttpRequest request,HttpResponse response,HttpContext context) throws ProtocolException {
  int statusCode=response.getStatusLine().getStatusCode();
  String method=request.getRequestLine().getMethod();
  Header locationHeader=response.getFirstHeader(""String_Node_Str"");
switch (statusCode) {
case HttpStatus.SC_MOVED_TEMPORARILY:
    return (method.equalsIgnoreCase(HttpGet.METHOD_NAME) || method.equalsIgnoreCase(HttpHead.METHOD_NAME) || method.equalsIgnoreCase(HttpPropFind.METHOD_NAME)) && (locationHeader != null);
case HttpStatus.SC_MOVED_PERMANENTLY:
case HttpStatus.SC_TEMPORARY_REDIRECT:
  return method.equalsIgnoreCase(HttpGet.METHOD_NAME) || method.equalsIgnoreCase(HttpHead.METHOD_NAME) || method.equalsIgnoreCase(HttpPropFind.METHOD_NAME);
case HttpStatus.SC_SEE_OTHER:
return true;
default :
return false;
}
}","@Override public boolean isRedirected(HttpRequest request,HttpResponse response,HttpContext context) throws ProtocolException {
  int statusCode=response.getStatusLine().getStatusCode();
  String method=request.getRequestLine().getMethod();
  Header locationHeader=response.getFirstHeader(""String_Node_Str"");
switch (statusCode) {
case HttpStatus.SC_MOVED_TEMPORARILY:
    return (method.equalsIgnoreCase(HttpGet.METHOD_NAME) || method.equalsIgnoreCase(HttpHead.METHOD_NAME) || method.equalsIgnoreCase(HttpLock.METHOD_NAME)|| method.equalsIgnoreCase(HttpPropFind.METHOD_NAME)) && (locationHeader != null);
case HttpStatus.SC_MOVED_PERMANENTLY:
case HttpStatus.SC_TEMPORARY_REDIRECT:
  return method.equalsIgnoreCase(HttpGet.METHOD_NAME) || method.equalsIgnoreCase(HttpHead.METHOD_NAME) || method.equalsIgnoreCase(HttpLock.METHOD_NAME)|| method.equalsIgnoreCase(HttpPropFind.METHOD_NAME);
case HttpStatus.SC_SEE_OTHER:
return true;
default :
return false;
}
}",0.9472527472527472
54947,"private void init(AbstractHttpClient http,String username,String password){
  this.client=http;
  this.client.setRedirectStrategy(new DefaultRedirectStrategy(){
    @Override public boolean isRedirected(    HttpRequest request,    HttpResponse response,    HttpContext context) throws ProtocolException {
      int statusCode=response.getStatusLine().getStatusCode();
      String method=request.getRequestLine().getMethod();
      Header locationHeader=response.getFirstHeader(""String_Node_Str"");
switch (statusCode) {
case HttpStatus.SC_MOVED_TEMPORARILY:
        return (method.equalsIgnoreCase(HttpGet.METHOD_NAME) || method.equalsIgnoreCase(HttpHead.METHOD_NAME) || method.equalsIgnoreCase(HttpPropFind.METHOD_NAME)) && (locationHeader != null);
case HttpStatus.SC_MOVED_PERMANENTLY:
case HttpStatus.SC_TEMPORARY_REDIRECT:
      return method.equalsIgnoreCase(HttpGet.METHOD_NAME) || method.equalsIgnoreCase(HttpHead.METHOD_NAME) || method.equalsIgnoreCase(HttpPropFind.METHOD_NAME);
case HttpStatus.SC_SEE_OTHER:
    return true;
default :
  return false;
}
}
@Override public HttpUriRequest getRedirect(HttpRequest request,HttpResponse response,HttpContext context) throws ProtocolException {
URI uri=this.getLocationURI(request,response,context);
String method=request.getRequestLine().getMethod();
if (method.equalsIgnoreCase(HttpHead.METHOD_NAME)) {
return new HttpHead(uri);
}
if (method.equalsIgnoreCase(HttpPropFind.METHOD_NAME)) {
return new HttpPropFind(uri);
}
if (method.equalsIgnoreCase(HttpLock.METHOD_NAME)) {
return new HttpLock(uri);
}
return new HttpGet(uri);
}
}
);
this.setCredentials(username,password);
}","private void init(AbstractHttpClient http,String username,String password){
  this.client=http;
  this.client.setRedirectStrategy(new DefaultRedirectStrategy(){
    @Override public boolean isRedirected(    HttpRequest request,    HttpResponse response,    HttpContext context) throws ProtocolException {
      int statusCode=response.getStatusLine().getStatusCode();
      String method=request.getRequestLine().getMethod();
      Header locationHeader=response.getFirstHeader(""String_Node_Str"");
switch (statusCode) {
case HttpStatus.SC_MOVED_TEMPORARILY:
        return (method.equalsIgnoreCase(HttpGet.METHOD_NAME) || method.equalsIgnoreCase(HttpHead.METHOD_NAME) || method.equalsIgnoreCase(HttpLock.METHOD_NAME)|| method.equalsIgnoreCase(HttpPropFind.METHOD_NAME)) && (locationHeader != null);
case HttpStatus.SC_MOVED_PERMANENTLY:
case HttpStatus.SC_TEMPORARY_REDIRECT:
      return method.equalsIgnoreCase(HttpGet.METHOD_NAME) || method.equalsIgnoreCase(HttpHead.METHOD_NAME) || method.equalsIgnoreCase(HttpLock.METHOD_NAME)|| method.equalsIgnoreCase(HttpPropFind.METHOD_NAME);
case HttpStatus.SC_SEE_OTHER:
    return true;
default :
  return false;
}
}
@Override public HttpUriRequest getRedirect(HttpRequest request,HttpResponse response,HttpContext context) throws ProtocolException {
String method=request.getRequestLine().getMethod();
if (method.equalsIgnoreCase(HttpPropFind.METHOD_NAME)) {
return new HttpPropFind(this.getLocationURI(request,response,context));
}
if (method.equalsIgnoreCase(HttpLock.METHOD_NAME)) {
return new HttpLock(this.getLocationURI(request,response,context));
}
return super.getRedirect(request,response,context);
}
}
);
this.setCredentials(username,password);
}",0.789078907890789
54948,"/** 
 * No validation of the response. Wraps all checked exceptions to   {@link IOException}. Aborts the request if there is an exception.
 * @param request Request to execute
 * @return The response to check the reply status code
 */
protected HttpResponse execute(HttpRequestBase request) throws IOException {
  try {
    return this.client.execute(request,this.context);
  }
 catch (  IOException e) {
    request.abort();
    throw e;
  }
}","/** 
 * No validation of the response. Aborts the request if there is an exception.
 * @param request Request to execute
 * @return The response to check the reply status code
 */
protected HttpResponse execute(HttpRequestBase request) throws IOException {
  try {
    this.context.removeAttribute(DefaultRedirectStrategy.REDIRECT_LOCATIONS);
    return this.client.execute(request,this.context);
  }
 catch (  IOException e) {
    request.abort();
    throw e;
  }
}",0.2458836443468715
54949,"@Test public void testRedirectPermanently() throws Exception {
  Sardine sardine=SardineFactory.begin();
  final String url=""String_Node_Str"";
  try {
    final List<DavResource> resources=sardine.list(url);
    assertNotNull(resources);
  }
 catch (  SardineException e) {
    fail(""String_Node_Str"");
  }
}","@Test public void testRedirectPermanently() throws Exception {
  Sardine sardine=SardineFactory.begin();
  final String url=""String_Node_Str"";
  try {
    assertNotNull(sardine.list(url));
    assertNotNull(sardine.list(url));
  }
 catch (  SardineException e) {
    fail(""String_Node_Str"");
  }
}",0.8099173553719008
54950,"/** 
 * Creates default params setting the user agent.
 */
protected HttpParams createDefaultHttpParams(){
  HttpParams params=new BasicHttpParams();
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  HttpProtocolParams.setUserAgent(params,""String_Node_Str"" + Version.getSpecification());
  HttpProtocolParams.setUseExpectContinue(params,false);
  return params;
}","/** 
 * Creates default params setting the user agent.
 * @return
 */
protected HttpParams createDefaultHttpParams(){
  HttpParams params=new BasicHttpParams();
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  HttpProtocolParams.setUserAgent(params,""String_Node_Str"" + Version.getSpecification());
  HttpProtocolParams.setUseExpectContinue(params,false);
  return params;
}",0.9856209150326798
54951,"/** 
 * No validation of the response. Wraps all checked exceptions to   {@link IOException}. Aborts the request if there is an exception.
 * @param request Request to execute
 */
private HttpResponse execute(final HttpRequestBase request) throws IOException {
  try {
    return this.client.execute(request,this.context);
  }
 catch (  IOException e) {
    request.abort();
    throw e;
  }
}","/** 
 * No validation of the response. Wraps all checked exceptions to   {@link IOException}. Aborts the request if there is an exception.
 * @param request Request to execute
 * @return
 * @throws java.io.IOException
 */
private HttpResponse execute(final HttpRequestBase request) throws IOException {
  try {
    return this.client.execute(request,this.context);
  }
 catch (  IOException e) {
    request.abort();
    throw e;
  }
}",0.6231884057971014
54952,"/** 
 * Override to provide proxy configuration
 * @param schemeRegistry Protocol registry
 * @param selector		  Proxy configuration
 * @return ProxySelectorRoutePlanner configured with schemeRegistry and selector
 */
protected HttpRoutePlanner createDefaultRoutePlanner(SchemeRegistry schemeRegistry,ProxySelector selector){
  return new ProxySelectorRoutePlanner(schemeRegistry,selector);
}","/** 
 * Override to provide proxy configuration
 * @param schemeRegistry Protocol registry
 * @param selector	   Proxy configuration
 * @return ProxySelectorRoutePlanner configured with schemeRegistry and selector
 */
protected HttpRoutePlanner createDefaultRoutePlanner(SchemeRegistry schemeRegistry,ProxySelector selector){
  return new ProxySelectorRoutePlanner(schemeRegistry,selector);
}",0.9974489795918368
54953,"/** 
 * @param url	 Resource
 * @param entity  The entity to read from
 * @param headers Headers to add to request
 */
public void put(String url,AbstractHttpEntity entity,Map<String,String> headers) throws IOException {
  HttpPut put=new HttpPut(url);
  put.setEntity(entity);
  for (  String header : headers.keySet()) {
    put.addHeader(header,headers.get(header));
  }
  execute(put,new VoidResponseHandler());
}","/** 
 * @param url	 Resource
 * @param entity  The entity to read from
 * @param headers Headers to add to request
 * @throws java.io.IOException
 */
public void put(String url,AbstractHttpEntity entity,Map<String,String> headers) throws IOException {
  HttpPut put=new HttpPut(url);
  put.setEntity(entity);
  for (  String header : headers.keySet()) {
    put.addHeader(header,headers.get(header));
  }
  execute(put,new VoidResponseHandler());
}",0.9641618497109826
54954,"/** 
 * @param http	 Custom client configuration
 * @param username Use in authentication header credentials
 * @param password Use in authentication header credentials
 * @param selector Proxy configuration
 */
public SardineImpl(AbstractHttpClient http,String username,String password,ProxySelector selector){
  this.client=http;
  SchemeRegistry schemeRegistry=createDefaultSchemeRegistry();
  this.client.setRoutePlanner(createDefaultRoutePlanner(schemeRegistry,selector));
  setCredentials(username,password);
}","/** 
 * @param http	 Custom client configuration
 * @param username Use in authentication header credentials
 * @param password Use in authentication header credentials
 * @param selector Proxy configuration
 */
public SardineImpl(AbstractHttpClient http,String username,String password,ProxySelector selector){
  this.init(http,username,password,selector);
}",0.7405714285714285
54955,"/** 
 */
public Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner) throws SardineException {
  return new SardineImpl(this,username,password,sslSocketFactory,routePlanner);
}","/** 
 */
public Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner,Integer port) throws SardineException {
  return new SardineImpl(this,username,password,sslSocketFactory,routePlanner,port);
}",0.9629629629629628
54956,"/** 
 * Useful for when you need to define a http proxy
 */
public static Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner) throws SardineException {
  return Factory.instance().begin(username,password,sslSocketFactory);
}","/** 
 * Useful for when you need to define a http proxy
 */
public static Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner,Integer port) throws SardineException {
  return Factory.instance().begin(username,password,sslSocketFactory,routePlanner,port);
}",0.948073701842546
54957,"/** 
 * Main constructor.
 */
public SardineImpl(Factory factory,String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  HttpProtocolParams.setUserAgent(params,""String_Node_Str"" + Version.getSpecification());
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  if (sslSocketFactory != null)   schemeRegistry.register(new Scheme(""String_Node_Str"",sslSocketFactory,443));
 else   schemeRegistry.register(new Scheme(""String_Node_Str"",SSLSocketFactory.getSocketFactory(),443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if (routePlanner != null)   this.client.setRoutePlanner(routePlanner);
  if ((username != null) && (password != null)) {
    this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
    this.authEnabled=true;
  }
}","/** 
 * Main constructor.
 */
public SardineImpl(Factory factory,String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner,Integer port) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  HttpProtocolParams.setUserAgent(params,""String_Node_Str"" + Version.getSpecification());
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),port != null ? port : 80));
  if (sslSocketFactory != null)   schemeRegistry.register(new Scheme(""String_Node_Str"",sslSocketFactory,port != null ? port : 443));
 else   schemeRegistry.register(new Scheme(""String_Node_Str"",SSLSocketFactory.getSocketFactory(),port != null ? port : 443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if (routePlanner != null)   this.client.setRoutePlanner(routePlanner);
  if ((username != null) && (password != null)) {
    this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
    this.authEnabled=true;
  }
}",0.9700870882241576
54958,"/** 
 */
@Override public void execute() throws BuildException {
  try {
    this.sardine=SardineFactory.begin(this.username,this.password);
    for (    Command command : this.commands) {
      command.executeCommand();
    }
  }
 catch (  Exception e) {
    throw new BuildException(e);
  }
}","/** 
 */
@Override public void execute() throws BuildException {
  try {
    this.sardine=SardineFactory.begin(this.username,this.password,this.port);
    for (    Command command : this.commands) {
      command.executeCommand();
    }
  }
 catch (  Exception e) {
    throw new BuildException(e);
  }
}",0.9832775919732442
54959,"/** 
 */
public SardineException(String msg,String url,int statusCode,String responsePhrase,Exception initCause){
  super(msg + responsePhrase != null ? ""String_Node_Str"" + responsePhrase : ""String_Node_Str"" + ""String_Node_Str"" + statusCode);
  this.url=url;
  this.statusCode=statusCode;
  this.responsePhrase=responsePhrase;
  if (initCause != null)   this.initCause(initCause);
}","/** 
 */
public SardineException(String msg,String url,int statusCode,String responsePhrase,Exception initCause){
  super(msg,initCause);
  this.url=url;
  this.statusCode=statusCode;
  this.responsePhrase=responsePhrase;
  if (initCause != null)   this.initCause(initCause);
}",0.543247344461305
54960,"/** 
 * Small wrapper around HttpClient.execute() in order to wrap the IOException into a SardineException.
 */
private HttpResponse executeWrapper(HttpRequestBase base) throws SardineException {
  try {
    if (this.authEnabled) {
      Credentials creds=this.client.getCredentialsProvider().getCredentials(AuthScope.ANY);
      String value=""String_Node_Str"" + new String(Base64.encodeBase64(new String(creds.getUserPrincipal().getName() + ""String_Node_Str"" + creds.getPassword()).getBytes()));
      base.setHeader(""String_Node_Str"",value);
    }
    return this.client.execute(base);
  }
 catch (  IOException ex) {
    throw new SardineException(ex);
  }
}","/** 
 * Small wrapper around HttpClient.execute() in order to wrap the IOException into a SardineException.
 */
private HttpResponse executeWrapper(HttpRequestBase base) throws SardineException {
  try {
    if (this.authEnabled) {
      Credentials creds=this.client.getCredentialsProvider().getCredentials(AuthScope.ANY);
      String value=""String_Node_Str"" + new String(Base64.encodeBase64(new String(creds.getUserPrincipal().getName() + ""String_Node_Str"" + creds.getPassword()).getBytes()));
      base.setHeader(""String_Node_Str"",value);
    }
    return this.client.execute(base);
  }
 catch (  IOException ex) {
    base.abort();
    throw new SardineException(ex);
  }
}",0.9865671641791044
54961,"public void move(String sourceUrl,String destinationUrl) throws SardineException {
  HttpMove move=new HttpMove(sourceUrl,destinationUrl);
  HttpResponse response=this.executeWrapper(move);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"" + sourceUrl + ""String_Node_Str""+ destinationUrl,statusLine.getStatusCode(),statusLine.getReasonPhrase());
}","public void move(String sourceUrl,String destinationUrl) throws SardineException {
  HttpMove move=new HttpMove(sourceUrl,destinationUrl);
  HttpResponse response=this.executeWrapper(move);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    move.abort();
    throw new SardineException(""String_Node_Str"" + sourceUrl + ""String_Node_Str""+ destinationUrl,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}",0.9723404255319148
54962,"public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
        href+=""String_Node_Str"";
      }
      if (href.startsWith(hostPart)) {
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}","public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    propFind.abort();
    throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
        href+=""String_Node_Str"";
      }
      if (href.startsWith(hostPart)) {
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}",0.9949562878278412
54963,"public boolean exists(String url) throws SardineException {
  HttpHead head=new HttpHead(url);
  HttpResponse response=this.executeWrapper(head);
  StatusLine statusLine=response.getStatusLine();
  return (SardineUtil.isGoodResponse(statusLine.getStatusCode()));
}","public boolean exists(String url) throws SardineException {
  HttpHead head=new HttpHead(url);
  HttpResponse response=this.executeWrapper(head);
  StatusLine statusLine=response.getStatusLine();
  return SardineUtil.isGoodResponse(statusLine.getStatusCode());
}",0.9961977186311788
54964,"public void createDirectory(String url) throws SardineException {
  HttpMkCol mkcol=new HttpMkCol(url);
  HttpResponse response=this.executeWrapper(mkcol);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
}","public void createDirectory(String url) throws SardineException {
  HttpMkCol mkcol=new HttpMkCol(url);
  HttpResponse response=this.executeWrapper(mkcol);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    mkcol.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}",0.9639519359145527
54965,"public void copy(String sourceUrl,String destinationUrl) throws SardineException {
  HttpCopy copy=new HttpCopy(sourceUrl,destinationUrl);
  HttpResponse response=this.executeWrapper(copy);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"" + sourceUrl + ""String_Node_Str""+ destinationUrl,statusLine.getStatusCode(),statusLine.getReasonPhrase());
}","public void copy(String sourceUrl,String destinationUrl) throws SardineException {
  HttpCopy copy=new HttpCopy(sourceUrl,destinationUrl);
  HttpResponse response=this.executeWrapper(copy);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    copy.abort();
    throw new SardineException(""String_Node_Str"" + sourceUrl + ""String_Node_Str""+ destinationUrl,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}",0.9723404255319148
54966,"public InputStream getInputStream(String url) throws SardineException {
  HttpGet get=new HttpGet(url);
  HttpResponse response=this.executeWrapper(get);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  try {
    return response.getEntity().getContent();
  }
 catch (  IOException ex) {
    throw new SardineException(ex);
  }
}","public InputStream getInputStream(String url) throws SardineException {
  HttpGet get=new HttpGet(url);
  HttpResponse response=this.executeWrapper(get);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    get.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  try {
    return response.getEntity().getContent();
  }
 catch (  IOException ex) {
    get.abort();
    throw new SardineException(ex);
  }
}",0.958498023715415
54967,"public void delete(String url) throws SardineException {
  HttpDelete delete=new HttpDelete(url);
  HttpResponse response=this.executeWrapper(delete);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
}","public void delete(String url) throws SardineException {
  HttpDelete delete=new HttpDelete(url);
  HttpResponse response=this.executeWrapper(delete);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    delete.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}",0.9621621621621622
54968,"public void put(String url,InputStream dataStream) throws SardineException {
  HttpPut put=new HttpPut(url);
  InputStreamEntity entity=new InputStreamEntity(dataStream,-1);
  put.setEntity(entity);
  HttpResponse response=this.executeWrapper(put);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
}","public void put(String url,InputStream dataStream) throws SardineException {
  HttpPut put=new HttpPut(url);
  InputStreamEntity entity=new InputStreamEntity(dataStream,-1);
  put.setEntity(entity);
  HttpResponse response=this.executeWrapper(put);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    put.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}",0.9732047159699893
54969,"/** 
 * Represents a webdav response block.
 * @param baseUrl
 * @param name the name of the resource, with all /'s removed
 * @param creation
 * @param modified
 * @param contentType
 */
public DavResource(String baseUrl,String name,Date creation,Date modified,String contentType,Long contentLength,boolean currentDirectory){
  this.baseUrl=baseUrl;
  this.name=name;
  this.creation=creation;
  this.modified=modified;
  this.contentType=contentType;
  this.contentLength=contentLength;
  this.currentDirectory=currentDirectory;
}","/** 
 * Represents a webdav response block.
 * @param name the name of the resource, with all /'s removed
 */
public DavResource(String baseUrl,String name,Date creation,Date modified,String contentType,Long contentLength,boolean currentDirectory,Map<String,String> customProps){
  this.baseUrl=baseUrl;
  this.name=name;
  this.creation=creation;
  this.modified=modified;
  this.contentType=contentType;
  this.contentLength=contentLength;
  this.currentDirectory=currentDirectory;
  this.customProps=customProps;
}",0.3679694947569113
54970,"public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    propFind.abort();
    throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=SardineUtil.decode(resp.getHref().get(0));
    String name=null;
    if (baseUrl != null) {
      if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
        href+=""String_Node_Str"";
      }
      if (href.startsWith(hostPart)) {
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}","public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    propFind.abort();
    throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=SardineUtil.decode(resp.getHref().get(0));
    String name=null;
    if (baseUrl != null) {
      if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
        href+=""String_Node_Str"";
      }
      if (href.startsWith(hostPart)) {
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    Map<String,String> customProps=SardineUtil.extractCustomProps(prop.getAny());
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory,customProps);
    resources.add(dr);
  }
  return resources;
}",0.9846204188481676
54971,"public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    propFind.abort();
    throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
        href+=""String_Node_Str"";
      }
      if (href.startsWith(hostPart)) {
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}","public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    propFind.abort();
    throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=SardineUtil.decode(resp.getHref().get(0));
    String name=null;
    if (baseUrl != null) {
      if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
        href+=""String_Node_Str"";
      }
      if (href.startsWith(hostPart)) {
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}",0.9966655551850616
54972,"public void move(String sourceUrl,String destinationUrl) throws SardineException {
  HttpMove move=new HttpMove(sourceUrl,destinationUrl);
  HttpResponse response=this.executeWrapper(move);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    move.abort();
    throw new SardineException(""String_Node_Str"" + sourceUrl + ""String_Node_Str""+ destinationUrl,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}","public void move(String sourceUrl,String destinationUrl) throws SardineException {
  HttpMove move=new HttpMove(sourceUrl,destinationUrl);
  HttpResponse response=this.executeWrapper(move);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    move.abort();
    throw new SardineException(""String_Node_Str"" + sourceUrl + ""String_Node_Str""+ destinationUrl,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  try {
    response.getEntity().getContent().close();
  }
 catch (  Exception ex) {
  }
}",0.9156398104265404
54973,"public void createDirectory(String url) throws SardineException {
  HttpMkCol mkcol=new HttpMkCol(url);
  HttpResponse response=this.executeWrapper(mkcol);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    mkcol.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}","public void createDirectory(String url) throws SardineException {
  HttpMkCol mkcol=new HttpMkCol(url);
  HttpResponse response=this.executeWrapper(mkcol);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    mkcol.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  try {
    response.getEntity().getContent().close();
  }
 catch (  Exception ex) {
  }
}",0.8971098265895954
54974,"public void copy(String sourceUrl,String destinationUrl) throws SardineException {
  HttpCopy copy=new HttpCopy(sourceUrl,destinationUrl);
  HttpResponse response=this.executeWrapper(copy);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    copy.abort();
    throw new SardineException(""String_Node_Str"" + sourceUrl + ""String_Node_Str""+ destinationUrl,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}","public void copy(String sourceUrl,String destinationUrl) throws SardineException {
  HttpCopy copy=new HttpCopy(sourceUrl,destinationUrl);
  HttpResponse response=this.executeWrapper(copy);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    copy.abort();
    throw new SardineException(""String_Node_Str"" + sourceUrl + ""String_Node_Str""+ destinationUrl,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  try {
    response.getEntity().getContent().close();
  }
 catch (  Exception ex) {
  }
}",0.9156398104265404
54975,"public void delete(String url) throws SardineException {
  HttpDelete delete=new HttpDelete(url);
  HttpResponse response=this.executeWrapper(delete);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    delete.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}","public void delete(String url) throws SardineException {
  HttpDelete delete=new HttpDelete(url);
  HttpResponse response=this.executeWrapper(delete);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    delete.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  try {
    response.getEntity().getContent().close();
  }
 catch (  Exception ex) {
  }
}",0.8961493582263711
54976,"public void put(String url,InputStream dataStream) throws SardineException {
  HttpPut put=new HttpPut(url);
  InputStreamEntity entity=new InputStreamEntity(dataStream,-1);
  put.setEntity(entity);
  HttpResponse response=this.executeWrapper(put);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    put.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
}","public void put(String url,InputStream dataStream) throws SardineException {
  HttpPut put=new HttpPut(url);
  InputStreamEntity entity=new InputStreamEntity(dataStream,-1);
  put.setEntity(entity);
  HttpResponse response=this.executeWrapper(put);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode())) {
    put.abort();
    throw new SardineException(url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  }
  try {
    response.getEntity().getContent().close();
  }
 catch (  Exception ex) {
  }
}",0.9149952244508118
54977,"/** 
 */
public SardineException(String msg,String url,int statusCode,String responsePhrase,Exception initCause){
  super(msg,initCause);
  this.url=url;
  this.statusCode=statusCode;
  this.responsePhrase=responsePhrase;
  if (initCause != null)   this.initCause(initCause);
}","/** 
 */
public SardineException(String msg,String url,int statusCode,String responsePhrase,Exception initCause){
  super(msg,initCause);
  this.url=url;
  this.statusCode=statusCode;
  this.responsePhrase=responsePhrase;
}",0.892
54978,"public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      if (href.startsWith(hostPart))       name=href.substring(hostPart.length() + baseUrl.length());
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || name.length() == 0) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && contentType == null) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}","public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      if (href.startsWith(hostPart)) {
        if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
          href+=""String_Node_Str"";
        }
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}",0.9333333333333332
54979,"public HttpPropFind(String url){
  super();
  this.setDepth(1);
  this.setURI(URI.create(url));
}","public HttpPropFind(String url){
  super();
  this.setDepth(1);
  this.setURI(URI.create(url));
  this.setHeader(""String_Node_Str"",""String_Node_Str"");
}",0.7791164658634538
54980,"public HttpMkCol(String url){
  super();
  this.setURI(URI.create(url));
}","public HttpMkCol(String url){
  super();
  this.setURI(URI.create(url));
  this.setHeader(""String_Node_Str"",""String_Node_Str"");
}",0.729064039408867
54981,"/** 
 * @return the JAXB Unmarshaller
 */
public Unmarshaller getUnmarshaller() throws SardineException {
  try {
    return this.context.createUnmarshaller();
  }
 catch (  JAXBException e) {
    throw new SardineException(e);
  }
}","/** 
 * Note: the unmarshaller is not thread safe, so it must be created for every request.
 * @return the JAXB Unmarshaller
 */
public Unmarshaller getUnmarshaller() throws SardineException {
  try {
    return this.context.createUnmarshaller();
  }
 catch (  JAXBException e) {
    throw new SardineException(e);
  }
}",0.8426763110307414
54982,"/** 
 */
public Sardine begin(String username,String password,KeyStore trustStore) throws SardineException {
  return new SardineImpl(this,username,password);
}","/** 
 */
public Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  return new SardineImpl(this,username,password);
}",0.8982035928143712
54983,"/** 
 * Pass in a HTTP Auth username/password for being used with all connections and a KeyStore.
 */
public static Sardine begin(String username,String password,KeyStore trustStore) throws SardineException {
  return Factory.instance().begin(username,password,trustStore);
}","/** 
 * If you want to use custom HTTPS settings with Sardine, this allows you to pass in a SSLSocketFactory.
 * @see <a href=""http://hc.apache.org/httpcomponents-client/httpclient/xref/org/apache/http/conn/ssl/SSLSocketFactory.html"">SSLSocketFactory</a>
 */
public static Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  return Factory.instance().begin(username,password,sslSocketFactory);
}",0.4511691884456671
54984,"/** 
 */
public SardineImpl(Factory factory,String username,String password,KeyStore trustStore) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  schemeRegistry.register(new Scheme(""String_Node_Str"",this.getSSLSocketFactory(trustStore),443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if ((username != null) && (password != null))   this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
}","/** 
 * Main constructor.
 */
public SardineImpl(Factory factory,String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  if (sslSocketFactory != null)   schemeRegistry.register(new Scheme(""String_Node_Str"",sslSocketFactory,443));
 else   schemeRegistry.register(new Scheme(""String_Node_Str"",SSLSocketFactory.getSocketFactory(),443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if ((username != null) && (password != null))   this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
}",0.8838874680306905
54985,"public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      if (href.startsWith(hostPart)) {
        if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
          href+=""String_Node_Str"";
        }
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}","public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      if ((href.length() == baseUrl.length() - 1) && baseUrl.endsWith(""String_Node_Str"")) {
        href+=""String_Node_Str"";
      }
      if (href.startsWith(hostPart)) {
        name=href.substring(hostPart.length() + baseUrl.length());
      }
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || (name.length() == 0)) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && (contentType == null)) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}",0.9858203916272787
54986,"/** 
 */
public Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  return new SardineImpl(this,username,password);
}","/** 
 */
public Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  return new SardineImpl(this,username,password,sslSocketFactory);
}",0.9534246575342464
54987,"public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      name=href.substring(baseUrl.length());
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    boolean currentDirectory=false;
    if (baseUrl.equals(href))     currentDirectory=true;
    if (name.endsWith(""String_Node_Str""))     name=name.substring(0,name.length() - 1);
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}","public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  int firstSlash=url.indexOf('/',8);
  String baseUrl=null;
  if (url.endsWith(""String_Node_Str""))   baseUrl=url.substring(firstSlash);
  String hostPart=url.substring(0,firstSlash);
  for (  Response resp : responses) {
    boolean currentDirectory=false;
    boolean isDirectory=false;
    String href=resp.getHref().get(0);
    String name=null;
    if (baseUrl != null) {
      if (href.startsWith(hostPart))       name=href.substring(hostPart.length() + baseUrl.length());
 else       name=href.substring(baseUrl.length());
      if (""String_Node_Str"".equals(name) || name.length() == 0) {
        isDirectory=true;
        currentDirectory=true;
      }
    }
 else {
      int last=href.lastIndexOf(""String_Node_Str"") + 1;
      name=href.substring(last);
      baseUrl=href.substring(0,last);
    }
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str"")) {
      name=name.substring(0,name.length() - 1);
      isDirectory=true;
    }
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if ((gcd != null) && (gcd.getContent().size() == 1))     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if ((glm != null) && (glm.getContent().size() == 1))     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=null;
    Getcontenttype gtt=prop.getGetcontenttype();
    if ((gtt != null) && (gtt.getContent().size() == 1))     contentType=gtt.getContent().get(0);
    if (isDirectory && contentType == null) {
      contentType=""String_Node_Str"";
    }
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if ((gcl != null) && (gcl.getContent().size() == 1))     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(hostPart + baseUrl,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength),currentDirectory);
    resources.add(dr);
  }
  return resources;
}",0.8936411809235427
54988,"/** 
 * Main constructor.
 */
public SardineImpl(Factory factory,String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  if (sslSocketFactory != null)   schemeRegistry.register(new Scheme(""String_Node_Str"",sslSocketFactory,443));
 else   schemeRegistry.register(new Scheme(""String_Node_Str"",SSLSocketFactory.getSocketFactory(),443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if ((username != null) && (password != null))   this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
}","/** 
 * Main constructor.
 */
public SardineImpl(Factory factory,String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  HttpProtocolParams.setUserAgent(params,""String_Node_Str"" + Version.getSpecification());
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  if (sslSocketFactory != null)   schemeRegistry.register(new Scheme(""String_Node_Str"",sslSocketFactory,443));
 else   schemeRegistry.register(new Scheme(""String_Node_Str"",SSLSocketFactory.getSocketFactory(),443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if ((username != null) && (password != null))   this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
}",0.9590163934426228
54989,"/** 
 * @return the JAXB Unmarshaller
 */
public Unmarshaller getUnmarshaller(){
  return this.unmarshaller;
}","/** 
 * @return the JAXB Unmarshaller
 */
public Unmarshaller getUnmarshaller() throws SardineException {
  try {
    return this.context.createUnmarshaller();
  }
 catch (  JAXBException e) {
    throw new SardineException(e);
  }
}",0.5714285714285714
54990,"/** 
 */
public Factory(){
  try {
    if (this.context == null)     this.context=JAXBContext.newInstance(""String_Node_Str"");
    if (this.unmarshaller == null)     this.unmarshaller=this.context.createUnmarshaller();
  }
 catch (  JAXBException e) {
    e.printStackTrace();
  }
}","/** 
 */
public Factory(){
  try {
    if (this.context == null)     this.context=JAXBContext.newInstance(""String_Node_Str"");
  }
 catch (  JAXBException e) {
    e.printStackTrace();
  }
}",0.8042553191489362
54991,"/** 
 */
public Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  return new SardineImpl(this,username,password,sslSocketFactory);
}","/** 
 */
public Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner) throws SardineException {
  return new SardineImpl(this,username,password,sslSocketFactory,routePlanner);
}",0.8988235294117647
54992,"/** 
 * If you want to use custom HTTPS settings with Sardine, this allows you to pass in a SSLSocketFactory.
 * @see <a href=""http://hc.apache.org/httpcomponents-client/httpclient/xref/org/apache/http/conn/ssl/SSLSocketFactory.html"">SSLSocketFactory</a>
 */
public static Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  return Factory.instance().begin(username,password,sslSocketFactory);
}","/** 
 * Useful for when you need to define a http proxy
 */
public static Sardine begin(String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner) throws SardineException {
  return Factory.instance().begin(username,password,sslSocketFactory);
}",0.3047619047619048
54993,"/** 
 * Main constructor.
 */
public SardineImpl(Factory factory,String username,String password,SSLSocketFactory sslSocketFactory) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  HttpProtocolParams.setUserAgent(params,""String_Node_Str"" + Version.getSpecification());
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  if (sslSocketFactory != null)   schemeRegistry.register(new Scheme(""String_Node_Str"",sslSocketFactory,443));
 else   schemeRegistry.register(new Scheme(""String_Node_Str"",SSLSocketFactory.getSocketFactory(),443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if ((username != null) && (password != null))   this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
}","/** 
 * Main constructor.
 */
public SardineImpl(Factory factory,String username,String password,SSLSocketFactory sslSocketFactory,HttpRoutePlanner routePlanner) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  HttpProtocolParams.setUserAgent(params,""String_Node_Str"" + Version.getSpecification());
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  if (sslSocketFactory != null)   schemeRegistry.register(new Scheme(""String_Node_Str"",sslSocketFactory,443));
 else   schemeRegistry.register(new Scheme(""String_Node_Str"",SSLSocketFactory.getSocketFactory(),443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if (routePlanner != null)   this.client.setRoutePlanner(routePlanner);
  if ((username != null) && (password != null))   this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
}",0.9568857262452908
54994,"/** 
 */
public SardineException(String msg,String url,int statusCode,String responsePhrase,Exception initCause){
  super(msg);
  this.url=url;
  this.statusCode=statusCode;
  this.responsePhrase=responsePhrase;
  if (initCause != null)   this.initCause(initCause);
}","/** 
 */
public SardineException(String msg,String url,int statusCode,String responsePhrase,Exception initCause){
  super(msg + responsePhrase != null ? ""String_Node_Str"" + responsePhrase : ""String_Node_Str"" + ""String_Node_Str"" + statusCode);
  this.url=url;
  this.statusCode=statusCode;
  this.responsePhrase=responsePhrase;
  if (initCause != null)   this.initCause(initCause);
}",0.8228043143297381
54995,"/** 
 */
public Sardine begin(String username,String password) throws SardineException {
  return new SardineImpl(this,username,password);
}","/** 
 */
public Sardine begin(String username,String password,KeyStore trustStore) throws SardineException {
  return new SardineImpl(this,username,password);
}",0.9333333333333332
54996,"/** 
 * Pass in a HTTP Auth username/password for being used with all connections
 */
public static Sardine begin(String username,String password) throws SardineException {
  return Factory.instance().begin(username,password);
}","/** 
 * Pass in a HTTP Auth username/password for being used with all connections and a KeyStore.
 */
public static Sardine begin(String username,String password,KeyStore trustStore) throws SardineException {
  return Factory.instance().begin(username,password,trustStore);
}",0.9065606361829026
54997,"/** 
 */
public SardineImpl(Factory factory,String username,String password) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  SSLSocketFactory sf;
  try {
    SSLContext context=SSLContext.getDefault();
    sf=new SSLSocketFactory(context);
  }
 catch (  NoSuchAlgorithmException e) {
    throw new SardineException(e);
  }
  sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  schemeRegistry.register(new Scheme(""String_Node_Str"",sf,443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if ((username != null) && (password != null))   this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
}","/** 
 */
public SardineImpl(Factory factory,String username,String password,KeyStore trustStore) throws SardineException {
  this.factory=factory;
  HttpParams params=new BasicHttpParams();
  ConnManagerParams.setMaxTotalConnections(params,100);
  HttpProtocolParams.setVersion(params,HttpVersion.HTTP_1_1);
  SchemeRegistry schemeRegistry=new SchemeRegistry();
  schemeRegistry.register(new Scheme(""String_Node_Str"",PlainSocketFactory.getSocketFactory(),80));
  schemeRegistry.register(new Scheme(""String_Node_Str"",this.getSSLSocketFactory(trustStore),443));
  ClientConnectionManager cm=new ThreadSafeClientConnManager(params,schemeRegistry);
  this.client=new DefaultHttpClient(cm,params);
  if ((username != null) && (password != null))   this.client.getCredentialsProvider().setCredentials(new AuthScope(AuthScope.ANY_HOST,AuthScope.ANY_PORT),new UsernamePasswordCredentials(username,password));
}",0.8380386329866271
54998,"public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  String path=responses.get(0).getHref().get(0);
  for (  Response resp : responses) {
    String href=resp.getHref().get(0);
    if (href.equals(path))     continue;
    String name=href.substring(path.length(),href.length());
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str""))     name=name.substring(0,name.length() - 1);
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=prop.getCreationdate().getContent().get(0);
    String modifieddate;
    Getlastmodified glm=prop.getGetlastmodified();
    if (glm != null)     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=""String_Node_Str"";
    Getcontenttype gtt=prop.getGetcontenttype();
    if (gtt != null)     contentType=gtt.getContent().get(0);
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if (gcl != null)     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(url,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength));
    resources.add(dr);
  }
  return resources;
}","public List<DavResource> getResources(String url) throws SardineException {
  HttpPropFind propFind=new HttpPropFind(url);
  propFind.setEntity(SardineUtil.getResourcesEntity());
  HttpResponse response=this.executeWrapper(propFind);
  StatusLine statusLine=response.getStatusLine();
  if (!SardineUtil.isGoodResponse(statusLine.getStatusCode()))   throw new SardineException(""String_Node_Str"",url,statusLine.getStatusCode(),statusLine.getReasonPhrase());
  Multistatus multistatus=SardineUtil.getMulitstatus(this.factory.getUnmarshaller(),response,url);
  List<Response> responses=multistatus.getResponse();
  List<DavResource> resources=new ArrayList<DavResource>(responses.size());
  String path=responses.get(0).getHref().get(0);
  for (  Response resp : responses) {
    String href=resp.getHref().get(0);
    if (href.equals(path))     continue;
    String name=href.substring(path.length(),href.length());
    if (name.equals(""String_Node_Str""))     continue;
    if (name.endsWith(""String_Node_Str""))     name=name.substring(0,name.length() - 1);
    Prop prop=resp.getPropstat().get(0).getProp();
    String creationdate=null;
    Creationdate gcd=prop.getCreationdate();
    if (gcd != null && gcd.getContent().size() == 1)     creationdate=gcd.getContent().get(0);
    String modifieddate=null;
    Getlastmodified glm=prop.getGetlastmodified();
    if (glm != null && glm.getContent().size() == 1)     modifieddate=glm.getContent().get(0);
 else     modifieddate=creationdate;
    String contentType=""String_Node_Str"";
    Getcontenttype gtt=prop.getGetcontenttype();
    if (gtt != null && gtt.getContent().size() == 1)     contentType=gtt.getContent().get(0);
    String contentLength=""String_Node_Str"";
    Getcontentlength gcl=prop.getGetcontentlength();
    if (gcl != null && gcl.getContent().size() == 1)     contentLength=gcl.getContent().get(0);
    DavResource dr=new DavResource(url,name,SardineUtil.parseDate(creationdate),SardineUtil.parseDate(modifieddate),contentType,Long.valueOf(contentLength));
    resources.add(dr);
  }
  return resources;
}",0.9434440781131118
54999,"/** 
 * Uses webdav put to move a url to another
 */
public void move(String sourceUrl,String destinationUrl) throws SardineException ;","/** 
 * Move a url to from source to destination.
 */
public void move(String sourceUrl,String destinationUrl) throws SardineException ;",0.8118081180811808
55000,"/** 
 * Uses webdav to create a directory using url
 */
public void createDirectory(String url) throws SardineException ;","/** 
 * Uses webdav to create a directory at the specified url
 */
public void createDirectory(String url) throws SardineException ;",0.932806324110672
